open Aws
open Aws.BaseTypes
module VolumeType =
  struct
    type t =
      | Standard 
      | Io1 
      | Gp2 
      | Sc1 
      | St1 
    let str_to_t =
      [("st1", St1);
      ("sc1", Sc1);
      ("gp2", Gp2);
      ("io1", Io1);
      ("standard", Standard)]
    let t_to_str =
      [(St1, "st1");
      (Sc1, "sc1");
      (Gp2, "gp2");
      (Io1, "io1");
      (Standard, "standard")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module InstanceIpv6Address =
  struct
    type t =
      {
      ipv6_address: String.t option [@ocaml.doc "<p>The IPv6 address.</p>"]}
    [@@ocaml.doc "<p>Describes an IPv6 address.</p>"]
    let make ?ipv6_address  () = { ipv6_address }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> Query.Pair ("Ipv6Address", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> ("ipv6_address", (String.to_json f)))])
    let parse xml =
      Some
        {
          ipv6_address =
            (Util.option_bind (Xml.member "ipv6Address" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ipv6_address
              (fun f -> Ezxmlm.make_tag "ipv6Address" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an IPv6 address.</p>"]
module PrivateIpAddressSpecification =
  struct
    type t =
      {
      primary: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.</p>"];
      private_ip_address: String.t option
        [@ocaml.doc "<p>The private IPv4 addresses.</p>"]}[@@ocaml.doc
                                                            "<p>Describes a secondary private IPv4 address for a network interface.</p>"]
    let make ?primary  ?private_ip_address  () =
      { primary; private_ip_address }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.primary
             (fun f -> Query.Pair ("Primary", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.primary
             (fun f -> ("primary", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          primary =
            (Util.option_bind (Xml.member "primary" xml) Boolean.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.primary
               (fun f -> Ezxmlm.make_tag "primary" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.private_ip_address
              (fun f ->
                 Ezxmlm.make_tag "privateIpAddress" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a secondary private IPv4 address for a network interface.</p>"]
module Tag =
  struct
    type t =
      {
      key: String.t
        [@ocaml.doc
          "<p>The key of the tag.</p> <p>Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with <code>aws:</code>.</p>"];
      value: String.t
        [@ocaml.doc
          "<p>The value of the tag.</p> <p>Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.</p>"]}
    [@@ocaml.doc "<p>Describes a tag.</p>"]
    let make ~key  ~value  () = { key; value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Value", (String.to_query v.value)));
           Some (Query.Pair ("Key", (String.to_query v.key)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("value", (String.to_json v.value));
           Some ("key", (String.to_json v.key))])
    let parse xml =
      Some
        {
          key =
            (Xml.required "key"
               (Util.option_bind (Xml.member "key" xml) String.parse));
          value =
            (Xml.required "value"
               (Util.option_bind (Xml.member "value" xml) String.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "key" ([], (String.to_xml v.key)))]) @
           [Some (Ezxmlm.make_tag "value" ([], (String.to_xml v.value)))])
  end[@@ocaml.doc "<p>Describes a tag.</p>"]
module InstanceNetworkInterfaceAssociation =
  struct
    type t =
      {
      ip_owner_id: String.t option
        [@ocaml.doc "<p>The ID of the owner of the Elastic IP address.</p>"];
      public_dns_name: String.t option
        [@ocaml.doc "<p>The public DNS name.</p>"];
      public_ip: String.t option
        [@ocaml.doc
          "<p>The public IP address or Elastic IP address bound to the network interface.</p>"]}
    [@@ocaml.doc
      "<p>Describes association information for an Elastic IP address (IPv4).</p>"]
    let make ?ip_owner_id  ?public_dns_name  ?public_ip  () =
      { ip_owner_id; public_dns_name; public_ip }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.public_dns_name
             (fun f -> Query.Pair ("PublicDnsName", (String.to_query f)));
           Util.option_map v.ip_owner_id
             (fun f -> Query.Pair ("IpOwnerId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.public_dns_name
             (fun f -> ("public_dns_name", (String.to_json f)));
           Util.option_map v.ip_owner_id
             (fun f -> ("ip_owner_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          ip_owner_id =
            (Util.option_bind (Xml.member "ipOwnerId" xml) String.parse);
          public_dns_name =
            (Util.option_bind (Xml.member "publicDnsName" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.ip_owner_id
                (fun f -> Ezxmlm.make_tag "ipOwnerId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.public_dns_name
               (fun f ->
                  Ezxmlm.make_tag "publicDnsName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.public_ip
              (fun f -> Ezxmlm.make_tag "publicIp" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes association information for an Elastic IP address (IPv4).</p>"]
module EbsBlockDevice =
  struct
    type t =
      {
      delete_on_termination: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the EBS volume is deleted on instance termination. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination\">Preserving Amazon EBS Volumes on Instance Termination</a> in the Amazon Elastic Compute Cloud User Guide.</p>"];
      iops: Integer.t option
        [@ocaml.doc
          "<p>The number of I/O operations per second (IOPS) that the volume supports. For <code>io1</code> volumes, this represents the number of IOPS that are provisioned for the volume. For <code>gp2</code> volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html\">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Constraints: Range is 100-16,000 IOPS for <code>gp2</code> volumes and 100 to 64,000IOPS for <code>io1</code> volumes in most Regions. Maximum <code>io1</code> IOPS of 64,000 is guaranteed only on <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances\">Nitro-based instances</a>. Other instance families guarantee performance up to 32,000 IOPS. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html\">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Condition: This parameter is required for requests to create <code>io1</code> volumes; it is not used in requests to create <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>"];
      snapshot_id: String.t option
        [@ocaml.doc "<p>The ID of the snapshot.</p>"];
      volume_size: Integer.t option
        [@ocaml.doc
          "<p>The size of the volume, in GiB.</p> <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p> <p>Constraints: 1-16384 for General Purpose SSD (<code>gp2</code>), 4-16384 for Provisioned IOPS SSD (<code>io1</code>), 500-16384 for Throughput Optimized HDD (<code>st1</code>), 500-16384 for Cold HDD (<code>sc1</code>), and 1-1024 for Magnetic (<code>standard</code>) volumes. If you specify a snapshot, the volume size must be equal to or larger than the snapshot size.</p>"];
      volume_type: VolumeType.t option
        [@ocaml.doc
          "<p>The volume type. If you set the type to <code>io1</code>, you must also specify the <b>Iops</b> parameter. If you set the type to <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code>, you must omit the <b>Iops</b> parameter.</p> <p>Default: <code>gp2</code> </p>"];
      encrypted: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to <code>true</code> depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters\">Amazon EBS Encryption</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>In no case can you remove encryption from an encrypted volume.</p> <p>Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances\">Supported Instance Types</a>.</p>"];
      kms_key_id: String.t option
        [@ocaml.doc
          "<p>Identifier (key ID, key alias, ID ARN, or alias ARN) for a customer managed CMK under which the EBS volume is encrypted.</p> <p>This parameter is only supported on <code>BlockDeviceMapping</code> objects called by <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html\">RunInstances</a>, <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html\">RequestSpotFleet</a>, and <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html\">RequestSpotInstances</a>.</p>"]}
    [@@ocaml.doc "<p>Describes a block device for an EBS volume.</p>"]
    let make ?delete_on_termination  ?iops  ?snapshot_id  ?volume_size 
      ?volume_type  ?encrypted  ?kms_key_id  () =
      {
        delete_on_termination;
        iops;
        snapshot_id;
        volume_size;
        volume_type;
        encrypted;
        kms_key_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.volume_type
             (fun f -> Query.Pair ("VolumeType", (VolumeType.to_query f)));
           Util.option_map v.volume_size
             (fun f -> Query.Pair ("VolumeSize", (Integer.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.volume_type
             (fun f -> ("volume_type", (VolumeType.to_json f)));
           Util.option_map v.volume_size
             (fun f -> ("volume_size", (Integer.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          iops = (Util.option_bind (Xml.member "iops" xml) Integer.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          volume_size =
            (Util.option_bind (Xml.member "volumeSize" xml) Integer.parse);
          volume_type =
            (Util.option_bind (Xml.member "volumeType" xml) VolumeType.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "KmsKeyId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.delete_on_termination
                    (fun f ->
                       Ezxmlm.make_tag "deleteOnTermination"
                         ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.iops
                   (fun f -> Ezxmlm.make_tag "iops" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.snapshot_id
                  (fun f ->
                     Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.volume_size
                 (fun f ->
                    Ezxmlm.make_tag "volumeSize" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.volume_type
                (fun f ->
                   Ezxmlm.make_tag "volumeType" ([], (VolumeType.to_xml f)))])
            @
            [Util.option_map v.encrypted
               (fun f -> Ezxmlm.make_tag "encrypted" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.kms_key_id
              (fun f -> Ezxmlm.make_tag "KmsKeyId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a block device for an EBS volume.</p>"]
module InstanceIpv6AddressList =
  struct
    type t = InstanceIpv6Address.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InstanceIpv6Address.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceIpv6Address.to_headers v
    let to_json v = `List (List.map InstanceIpv6Address.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceIpv6Address.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstanceIpv6Address.to_xml x))) v
  end
module PrivateIpAddressSpecificationList =
  struct
    type t = PrivateIpAddressSpecification.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list PrivateIpAddressSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list PrivateIpAddressSpecification.to_headers v
    let to_json v = `List (List.map PrivateIpAddressSpecification.to_json v)
    let parse xml =
      Util.option_all
        (List.map PrivateIpAddressSpecification.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (PrivateIpAddressSpecification.to_xml x))) v
  end
module SecurityGroupIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "SecurityGroupId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module ResourceType =
  struct
    type t =
      | Client_vpn_endpoint 
      | Customer_gateway 
      | Dedicated_host 
      | Dhcp_options 
      | Elastic_ip 
      | Fleet 
      | Fpga_image 
      | Host_reservation 
      | Image 
      | Instance 
      | Internet_gateway 
      | Key_pair 
      | Launch_template 
      | Natgateway 
      | Network_acl 
      | Network_interface 
      | Placement_group 
      | Reserved_instances 
      | Route_table 
      | Security_group 
      | Snapshot 
      | Spot_fleet_request 
      | Spot_instances_request 
      | Subnet 
      | Traffic_mirror_filter 
      | Traffic_mirror_session 
      | Traffic_mirror_target 
      | Transit_gateway 
      | Transit_gateway_attachment 
      | Transit_gateway_multicast_domain 
      | Transit_gateway_route_table 
      | Volume 
      | Vpc 
      | Vpc_peering_connection 
      | Vpn_connection 
      | Vpn_gateway 
    let str_to_t =
      [("vpn-gateway", Vpn_gateway);
      ("vpn-connection", Vpn_connection);
      ("vpc-peering-connection", Vpc_peering_connection);
      ("vpc", Vpc);
      ("volume", Volume);
      ("transit-gateway-route-table", Transit_gateway_route_table);
      ("transit-gateway-multicast-domain", Transit_gateway_multicast_domain);
      ("transit-gateway-attachment", Transit_gateway_attachment);
      ("transit-gateway", Transit_gateway);
      ("traffic-mirror-target", Traffic_mirror_target);
      ("traffic-mirror-session", Traffic_mirror_session);
      ("traffic-mirror-filter", Traffic_mirror_filter);
      ("subnet", Subnet);
      ("spot-instances-request", Spot_instances_request);
      ("spot-fleet-request", Spot_fleet_request);
      ("snapshot", Snapshot);
      ("security-group", Security_group);
      ("route-table", Route_table);
      ("reserved-instances", Reserved_instances);
      ("placement-group", Placement_group);
      ("network-interface", Network_interface);
      ("network-acl", Network_acl);
      ("natgateway", Natgateway);
      ("launch-template", Launch_template);
      ("key-pair", Key_pair);
      ("internet-gateway", Internet_gateway);
      ("instance", Instance);
      ("image", Image);
      ("host-reservation", Host_reservation);
      ("fpga-image", Fpga_image);
      ("fleet", Fleet);
      ("elastic-ip", Elastic_ip);
      ("dhcp-options", Dhcp_options);
      ("dedicated-host", Dedicated_host);
      ("customer-gateway", Customer_gateway);
      ("client-vpn-endpoint", Client_vpn_endpoint)]
    let t_to_str =
      [(Vpn_gateway, "vpn-gateway");
      (Vpn_connection, "vpn-connection");
      (Vpc_peering_connection, "vpc-peering-connection");
      (Vpc, "vpc");
      (Volume, "volume");
      (Transit_gateway_route_table, "transit-gateway-route-table");
      (Transit_gateway_multicast_domain, "transit-gateway-multicast-domain");
      (Transit_gateway_attachment, "transit-gateway-attachment");
      (Transit_gateway, "transit-gateway");
      (Traffic_mirror_target, "traffic-mirror-target");
      (Traffic_mirror_session, "traffic-mirror-session");
      (Traffic_mirror_filter, "traffic-mirror-filter");
      (Subnet, "subnet");
      (Spot_instances_request, "spot-instances-request");
      (Spot_fleet_request, "spot-fleet-request");
      (Snapshot, "snapshot");
      (Security_group, "security-group");
      (Route_table, "route-table");
      (Reserved_instances, "reserved-instances");
      (Placement_group, "placement-group");
      (Network_interface, "network-interface");
      (Network_acl, "network-acl");
      (Natgateway, "natgateway");
      (Launch_template, "launch-template");
      (Key_pair, "key-pair");
      (Internet_gateway, "internet-gateway");
      (Instance, "instance");
      (Image, "image");
      (Host_reservation, "host-reservation");
      (Fpga_image, "fpga-image");
      (Fleet, "fleet");
      (Elastic_ip, "elastic-ip");
      (Dhcp_options, "dhcp-options");
      (Dedicated_host, "dedicated-host");
      (Customer_gateway, "customer-gateway");
      (Client_vpn_endpoint, "client-vpn-endpoint")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module TagList =
  struct
    type t = Tag.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Tag.to_query v
    let to_headers v = Headers.to_headers_list Tag.to_headers v
    let to_json v = `List (List.map Tag.to_json v)
    let parse xml =
      Util.option_all (List.map Tag.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Tag.to_xml x))) v
  end
module InstanceType =
  struct
    type t =
      | T1_micro 
      | T2_nano 
      | T2_micro 
      | T2_small 
      | T2_medium 
      | T2_large 
      | T2_xlarge 
      | T2_2xlarge 
      | T3_nano 
      | T3_micro 
      | T3_small 
      | T3_medium 
      | T3_large 
      | T3_xlarge 
      | T3_2xlarge 
      | T3a_nano 
      | T3a_micro 
      | T3a_small 
      | T3a_medium 
      | T3a_large 
      | T3a_xlarge 
      | T3a_2xlarge 
      | M1_small 
      | M1_medium 
      | M1_large 
      | M1_xlarge 
      | M3_medium 
      | M3_large 
      | M3_xlarge 
      | M3_2xlarge 
      | M4_large 
      | M4_xlarge 
      | M4_2xlarge 
      | M4_4xlarge 
      | M4_10xlarge 
      | M4_16xlarge 
      | M2_xlarge 
      | M2_2xlarge 
      | M2_4xlarge 
      | Cr1_8xlarge 
      | R3_large 
      | R3_xlarge 
      | R3_2xlarge 
      | R3_4xlarge 
      | R3_8xlarge 
      | R4_large 
      | R4_xlarge 
      | R4_2xlarge 
      | R4_4xlarge 
      | R4_8xlarge 
      | R4_16xlarge 
      | R5_large 
      | R5_xlarge 
      | R5_2xlarge 
      | R5_4xlarge 
      | R5_8xlarge 
      | R5_12xlarge 
      | R5_16xlarge 
      | R5_24xlarge 
      | R5_metal 
      | R5a_large 
      | R5a_xlarge 
      | R5a_2xlarge 
      | R5a_4xlarge 
      | R5a_8xlarge 
      | R5a_12xlarge 
      | R5a_16xlarge 
      | R5a_24xlarge 
      | R5d_large 
      | R5d_xlarge 
      | R5d_2xlarge 
      | R5d_4xlarge 
      | R5d_8xlarge 
      | R5d_12xlarge 
      | R5d_16xlarge 
      | R5d_24xlarge 
      | R5d_metal 
      | R5ad_large 
      | R5ad_xlarge 
      | R5ad_2xlarge 
      | R5ad_4xlarge 
      | R5ad_8xlarge 
      | R5ad_12xlarge 
      | R5ad_16xlarge 
      | R5ad_24xlarge 
      | X1_16xlarge 
      | X1_32xlarge 
      | X1e_xlarge 
      | X1e_2xlarge 
      | X1e_4xlarge 
      | X1e_8xlarge 
      | X1e_16xlarge 
      | X1e_32xlarge 
      | I2_xlarge 
      | I2_2xlarge 
      | I2_4xlarge 
      | I2_8xlarge 
      | I3_large 
      | I3_xlarge 
      | I3_2xlarge 
      | I3_4xlarge 
      | I3_8xlarge 
      | I3_16xlarge 
      | I3_metal 
      | I3en_large 
      | I3en_xlarge 
      | I3en_2xlarge 
      | I3en_3xlarge 
      | I3en_6xlarge 
      | I3en_12xlarge 
      | I3en_24xlarge 
      | I3en_metal 
      | Hi1_4xlarge 
      | Hs1_8xlarge 
      | C1_medium 
      | C1_xlarge 
      | C3_large 
      | C3_xlarge 
      | C3_2xlarge 
      | C3_4xlarge 
      | C3_8xlarge 
      | C4_large 
      | C4_xlarge 
      | C4_2xlarge 
      | C4_4xlarge 
      | C4_8xlarge 
      | C5_large 
      | C5_xlarge 
      | C5_2xlarge 
      | C5_4xlarge 
      | C5_9xlarge 
      | C5_12xlarge 
      | C5_18xlarge 
      | C5_24xlarge 
      | C5_metal 
      | C5d_large 
      | C5d_xlarge 
      | C5d_2xlarge 
      | C5d_4xlarge 
      | C5d_9xlarge 
      | C5d_12xlarge 
      | C5d_18xlarge 
      | C5d_24xlarge 
      | C5d_metal 
      | C5n_large 
      | C5n_xlarge 
      | C5n_2xlarge 
      | C5n_4xlarge 
      | C5n_9xlarge 
      | C5n_18xlarge 
      | Cc1_4xlarge 
      | Cc2_8xlarge 
      | G2_2xlarge 
      | G2_8xlarge 
      | G3_4xlarge 
      | G3_8xlarge 
      | G3_16xlarge 
      | G3s_xlarge 
      | G4dn_xlarge 
      | G4dn_2xlarge 
      | G4dn_4xlarge 
      | G4dn_8xlarge 
      | G4dn_12xlarge 
      | G4dn_16xlarge 
      | Cg1_4xlarge 
      | P2_xlarge 
      | P2_8xlarge 
      | P2_16xlarge 
      | P3_2xlarge 
      | P3_8xlarge 
      | P3_16xlarge 
      | P3dn_24xlarge 
      | D2_xlarge 
      | D2_2xlarge 
      | D2_4xlarge 
      | D2_8xlarge 
      | F1_2xlarge 
      | F1_4xlarge 
      | F1_16xlarge 
      | M5_large 
      | M5_xlarge 
      | M5_2xlarge 
      | M5_4xlarge 
      | M5_8xlarge 
      | M5_12xlarge 
      | M5_16xlarge 
      | M5_24xlarge 
      | M5_metal 
      | M5a_large 
      | M5a_xlarge 
      | M5a_2xlarge 
      | M5a_4xlarge 
      | M5a_8xlarge 
      | M5a_12xlarge 
      | M5a_16xlarge 
      | M5a_24xlarge 
      | M5d_large 
      | M5d_xlarge 
      | M5d_2xlarge 
      | M5d_4xlarge 
      | M5d_8xlarge 
      | M5d_12xlarge 
      | M5d_16xlarge 
      | M5d_24xlarge 
      | M5d_metal 
      | M5ad_large 
      | M5ad_xlarge 
      | M5ad_2xlarge 
      | M5ad_4xlarge 
      | M5ad_8xlarge 
      | M5ad_12xlarge 
      | M5ad_16xlarge 
      | M5ad_24xlarge 
      | H1_2xlarge 
      | H1_4xlarge 
      | H1_8xlarge 
      | H1_16xlarge 
      | Z1d_large 
      | Z1d_xlarge 
      | Z1d_2xlarge 
      | Z1d_3xlarge 
      | Z1d_6xlarge 
      | Z1d_12xlarge 
      | Z1d_metal 
      | U_6tb1_metal 
      | U_9tb1_metal 
      | U_12tb1_metal 
      | U_18tb1_metal 
      | U_24tb1_metal 
      | A1_medium 
      | A1_large 
      | A1_xlarge 
      | A1_2xlarge 
      | A1_4xlarge 
      | A1_metal 
      | M5dn_large 
      | M5dn_xlarge 
      | M5dn_2xlarge 
      | M5dn_4xlarge 
      | M5dn_8xlarge 
      | M5dn_12xlarge 
      | M5dn_16xlarge 
      | M5dn_24xlarge 
      | M5n_large 
      | M5n_xlarge 
      | M5n_2xlarge 
      | M5n_4xlarge 
      | M5n_8xlarge 
      | M5n_12xlarge 
      | M5n_16xlarge 
      | M5n_24xlarge 
      | R5dn_large 
      | R5dn_xlarge 
      | R5dn_2xlarge 
      | R5dn_4xlarge 
      | R5dn_8xlarge 
      | R5dn_12xlarge 
      | R5dn_16xlarge 
      | R5dn_24xlarge 
      | R5n_large 
      | R5n_xlarge 
      | R5n_2xlarge 
      | R5n_4xlarge 
      | R5n_8xlarge 
      | R5n_12xlarge 
      | R5n_16xlarge 
      | R5n_24xlarge 
      | Inf1_xlarge 
      | Inf1_2xlarge 
      | Inf1_6xlarge 
      | Inf1_24xlarge 
    let str_to_t =
      [("inf1.24xlarge", Inf1_24xlarge);
      ("inf1.6xlarge", Inf1_6xlarge);
      ("inf1.2xlarge", Inf1_2xlarge);
      ("inf1.xlarge", Inf1_xlarge);
      ("r5n.24xlarge", R5n_24xlarge);
      ("r5n.16xlarge", R5n_16xlarge);
      ("r5n.12xlarge", R5n_12xlarge);
      ("r5n.8xlarge", R5n_8xlarge);
      ("r5n.4xlarge", R5n_4xlarge);
      ("r5n.2xlarge", R5n_2xlarge);
      ("r5n.xlarge", R5n_xlarge);
      ("r5n.large", R5n_large);
      ("r5dn.24xlarge", R5dn_24xlarge);
      ("r5dn.16xlarge", R5dn_16xlarge);
      ("r5dn.12xlarge", R5dn_12xlarge);
      ("r5dn.8xlarge", R5dn_8xlarge);
      ("r5dn.4xlarge", R5dn_4xlarge);
      ("r5dn.2xlarge", R5dn_2xlarge);
      ("r5dn.xlarge", R5dn_xlarge);
      ("r5dn.large", R5dn_large);
      ("m5n.24xlarge", M5n_24xlarge);
      ("m5n.16xlarge", M5n_16xlarge);
      ("m5n.12xlarge", M5n_12xlarge);
      ("m5n.8xlarge", M5n_8xlarge);
      ("m5n.4xlarge", M5n_4xlarge);
      ("m5n.2xlarge", M5n_2xlarge);
      ("m5n.xlarge", M5n_xlarge);
      ("m5n.large", M5n_large);
      ("m5dn.24xlarge", M5dn_24xlarge);
      ("m5dn.16xlarge", M5dn_16xlarge);
      ("m5dn.12xlarge", M5dn_12xlarge);
      ("m5dn.8xlarge", M5dn_8xlarge);
      ("m5dn.4xlarge", M5dn_4xlarge);
      ("m5dn.2xlarge", M5dn_2xlarge);
      ("m5dn.xlarge", M5dn_xlarge);
      ("m5dn.large", M5dn_large);
      ("a1.metal", A1_metal);
      ("a1.4xlarge", A1_4xlarge);
      ("a1.2xlarge", A1_2xlarge);
      ("a1.xlarge", A1_xlarge);
      ("a1.large", A1_large);
      ("a1.medium", A1_medium);
      ("u-24tb1.metal", U_24tb1_metal);
      ("u-18tb1.metal", U_18tb1_metal);
      ("u-12tb1.metal", U_12tb1_metal);
      ("u-9tb1.metal", U_9tb1_metal);
      ("u-6tb1.metal", U_6tb1_metal);
      ("z1d.metal", Z1d_metal);
      ("z1d.12xlarge", Z1d_12xlarge);
      ("z1d.6xlarge", Z1d_6xlarge);
      ("z1d.3xlarge", Z1d_3xlarge);
      ("z1d.2xlarge", Z1d_2xlarge);
      ("z1d.xlarge", Z1d_xlarge);
      ("z1d.large", Z1d_large);
      ("h1.16xlarge", H1_16xlarge);
      ("h1.8xlarge", H1_8xlarge);
      ("h1.4xlarge", H1_4xlarge);
      ("h1.2xlarge", H1_2xlarge);
      ("m5ad.24xlarge", M5ad_24xlarge);
      ("m5ad.16xlarge", M5ad_16xlarge);
      ("m5ad.12xlarge", M5ad_12xlarge);
      ("m5ad.8xlarge", M5ad_8xlarge);
      ("m5ad.4xlarge", M5ad_4xlarge);
      ("m5ad.2xlarge", M5ad_2xlarge);
      ("m5ad.xlarge", M5ad_xlarge);
      ("m5ad.large", M5ad_large);
      ("m5d.metal", M5d_metal);
      ("m5d.24xlarge", M5d_24xlarge);
      ("m5d.16xlarge", M5d_16xlarge);
      ("m5d.12xlarge", M5d_12xlarge);
      ("m5d.8xlarge", M5d_8xlarge);
      ("m5d.4xlarge", M5d_4xlarge);
      ("m5d.2xlarge", M5d_2xlarge);
      ("m5d.xlarge", M5d_xlarge);
      ("m5d.large", M5d_large);
      ("m5a.24xlarge", M5a_24xlarge);
      ("m5a.16xlarge", M5a_16xlarge);
      ("m5a.12xlarge", M5a_12xlarge);
      ("m5a.8xlarge", M5a_8xlarge);
      ("m5a.4xlarge", M5a_4xlarge);
      ("m5a.2xlarge", M5a_2xlarge);
      ("m5a.xlarge", M5a_xlarge);
      ("m5a.large", M5a_large);
      ("m5.metal", M5_metal);
      ("m5.24xlarge", M5_24xlarge);
      ("m5.16xlarge", M5_16xlarge);
      ("m5.12xlarge", M5_12xlarge);
      ("m5.8xlarge", M5_8xlarge);
      ("m5.4xlarge", M5_4xlarge);
      ("m5.2xlarge", M5_2xlarge);
      ("m5.xlarge", M5_xlarge);
      ("m5.large", M5_large);
      ("f1.16xlarge", F1_16xlarge);
      ("f1.4xlarge", F1_4xlarge);
      ("f1.2xlarge", F1_2xlarge);
      ("d2.8xlarge", D2_8xlarge);
      ("d2.4xlarge", D2_4xlarge);
      ("d2.2xlarge", D2_2xlarge);
      ("d2.xlarge", D2_xlarge);
      ("p3dn.24xlarge", P3dn_24xlarge);
      ("p3.16xlarge", P3_16xlarge);
      ("p3.8xlarge", P3_8xlarge);
      ("p3.2xlarge", P3_2xlarge);
      ("p2.16xlarge", P2_16xlarge);
      ("p2.8xlarge", P2_8xlarge);
      ("p2.xlarge", P2_xlarge);
      ("cg1.4xlarge", Cg1_4xlarge);
      ("g4dn.16xlarge", G4dn_16xlarge);
      ("g4dn.12xlarge", G4dn_12xlarge);
      ("g4dn.8xlarge", G4dn_8xlarge);
      ("g4dn.4xlarge", G4dn_4xlarge);
      ("g4dn.2xlarge", G4dn_2xlarge);
      ("g4dn.xlarge", G4dn_xlarge);
      ("g3s.xlarge", G3s_xlarge);
      ("g3.16xlarge", G3_16xlarge);
      ("g3.8xlarge", G3_8xlarge);
      ("g3.4xlarge", G3_4xlarge);
      ("g2.8xlarge", G2_8xlarge);
      ("g2.2xlarge", G2_2xlarge);
      ("cc2.8xlarge", Cc2_8xlarge);
      ("cc1.4xlarge", Cc1_4xlarge);
      ("c5n.18xlarge", C5n_18xlarge);
      ("c5n.9xlarge", C5n_9xlarge);
      ("c5n.4xlarge", C5n_4xlarge);
      ("c5n.2xlarge", C5n_2xlarge);
      ("c5n.xlarge", C5n_xlarge);
      ("c5n.large", C5n_large);
      ("c5d.metal", C5d_metal);
      ("c5d.24xlarge", C5d_24xlarge);
      ("c5d.18xlarge", C5d_18xlarge);
      ("c5d.12xlarge", C5d_12xlarge);
      ("c5d.9xlarge", C5d_9xlarge);
      ("c5d.4xlarge", C5d_4xlarge);
      ("c5d.2xlarge", C5d_2xlarge);
      ("c5d.xlarge", C5d_xlarge);
      ("c5d.large", C5d_large);
      ("c5.metal", C5_metal);
      ("c5.24xlarge", C5_24xlarge);
      ("c5.18xlarge", C5_18xlarge);
      ("c5.12xlarge", C5_12xlarge);
      ("c5.9xlarge", C5_9xlarge);
      ("c5.4xlarge", C5_4xlarge);
      ("c5.2xlarge", C5_2xlarge);
      ("c5.xlarge", C5_xlarge);
      ("c5.large", C5_large);
      ("c4.8xlarge", C4_8xlarge);
      ("c4.4xlarge", C4_4xlarge);
      ("c4.2xlarge", C4_2xlarge);
      ("c4.xlarge", C4_xlarge);
      ("c4.large", C4_large);
      ("c3.8xlarge", C3_8xlarge);
      ("c3.4xlarge", C3_4xlarge);
      ("c3.2xlarge", C3_2xlarge);
      ("c3.xlarge", C3_xlarge);
      ("c3.large", C3_large);
      ("c1.xlarge", C1_xlarge);
      ("c1.medium", C1_medium);
      ("hs1.8xlarge", Hs1_8xlarge);
      ("hi1.4xlarge", Hi1_4xlarge);
      ("i3en.metal", I3en_metal);
      ("i3en.24xlarge", I3en_24xlarge);
      ("i3en.12xlarge", I3en_12xlarge);
      ("i3en.6xlarge", I3en_6xlarge);
      ("i3en.3xlarge", I3en_3xlarge);
      ("i3en.2xlarge", I3en_2xlarge);
      ("i3en.xlarge", I3en_xlarge);
      ("i3en.large", I3en_large);
      ("i3.metal", I3_metal);
      ("i3.16xlarge", I3_16xlarge);
      ("i3.8xlarge", I3_8xlarge);
      ("i3.4xlarge", I3_4xlarge);
      ("i3.2xlarge", I3_2xlarge);
      ("i3.xlarge", I3_xlarge);
      ("i3.large", I3_large);
      ("i2.8xlarge", I2_8xlarge);
      ("i2.4xlarge", I2_4xlarge);
      ("i2.2xlarge", I2_2xlarge);
      ("i2.xlarge", I2_xlarge);
      ("x1e.32xlarge", X1e_32xlarge);
      ("x1e.16xlarge", X1e_16xlarge);
      ("x1e.8xlarge", X1e_8xlarge);
      ("x1e.4xlarge", X1e_4xlarge);
      ("x1e.2xlarge", X1e_2xlarge);
      ("x1e.xlarge", X1e_xlarge);
      ("x1.32xlarge", X1_32xlarge);
      ("x1.16xlarge", X1_16xlarge);
      ("r5ad.24xlarge", R5ad_24xlarge);
      ("r5ad.16xlarge", R5ad_16xlarge);
      ("r5ad.12xlarge", R5ad_12xlarge);
      ("r5ad.8xlarge", R5ad_8xlarge);
      ("r5ad.4xlarge", R5ad_4xlarge);
      ("r5ad.2xlarge", R5ad_2xlarge);
      ("r5ad.xlarge", R5ad_xlarge);
      ("r5ad.large", R5ad_large);
      ("r5d.metal", R5d_metal);
      ("r5d.24xlarge", R5d_24xlarge);
      ("r5d.16xlarge", R5d_16xlarge);
      ("r5d.12xlarge", R5d_12xlarge);
      ("r5d.8xlarge", R5d_8xlarge);
      ("r5d.4xlarge", R5d_4xlarge);
      ("r5d.2xlarge", R5d_2xlarge);
      ("r5d.xlarge", R5d_xlarge);
      ("r5d.large", R5d_large);
      ("r5a.24xlarge", R5a_24xlarge);
      ("r5a.16xlarge", R5a_16xlarge);
      ("r5a.12xlarge", R5a_12xlarge);
      ("r5a.8xlarge", R5a_8xlarge);
      ("r5a.4xlarge", R5a_4xlarge);
      ("r5a.2xlarge", R5a_2xlarge);
      ("r5a.xlarge", R5a_xlarge);
      ("r5a.large", R5a_large);
      ("r5.metal", R5_metal);
      ("r5.24xlarge", R5_24xlarge);
      ("r5.16xlarge", R5_16xlarge);
      ("r5.12xlarge", R5_12xlarge);
      ("r5.8xlarge", R5_8xlarge);
      ("r5.4xlarge", R5_4xlarge);
      ("r5.2xlarge", R5_2xlarge);
      ("r5.xlarge", R5_xlarge);
      ("r5.large", R5_large);
      ("r4.16xlarge", R4_16xlarge);
      ("r4.8xlarge", R4_8xlarge);
      ("r4.4xlarge", R4_4xlarge);
      ("r4.2xlarge", R4_2xlarge);
      ("r4.xlarge", R4_xlarge);
      ("r4.large", R4_large);
      ("r3.8xlarge", R3_8xlarge);
      ("r3.4xlarge", R3_4xlarge);
      ("r3.2xlarge", R3_2xlarge);
      ("r3.xlarge", R3_xlarge);
      ("r3.large", R3_large);
      ("cr1.8xlarge", Cr1_8xlarge);
      ("m2.4xlarge", M2_4xlarge);
      ("m2.2xlarge", M2_2xlarge);
      ("m2.xlarge", M2_xlarge);
      ("m4.16xlarge", M4_16xlarge);
      ("m4.10xlarge", M4_10xlarge);
      ("m4.4xlarge", M4_4xlarge);
      ("m4.2xlarge", M4_2xlarge);
      ("m4.xlarge", M4_xlarge);
      ("m4.large", M4_large);
      ("m3.2xlarge", M3_2xlarge);
      ("m3.xlarge", M3_xlarge);
      ("m3.large", M3_large);
      ("m3.medium", M3_medium);
      ("m1.xlarge", M1_xlarge);
      ("m1.large", M1_large);
      ("m1.medium", M1_medium);
      ("m1.small", M1_small);
      ("t3a.2xlarge", T3a_2xlarge);
      ("t3a.xlarge", T3a_xlarge);
      ("t3a.large", T3a_large);
      ("t3a.medium", T3a_medium);
      ("t3a.small", T3a_small);
      ("t3a.micro", T3a_micro);
      ("t3a.nano", T3a_nano);
      ("t3.2xlarge", T3_2xlarge);
      ("t3.xlarge", T3_xlarge);
      ("t3.large", T3_large);
      ("t3.medium", T3_medium);
      ("t3.small", T3_small);
      ("t3.micro", T3_micro);
      ("t3.nano", T3_nano);
      ("t2.2xlarge", T2_2xlarge);
      ("t2.xlarge", T2_xlarge);
      ("t2.large", T2_large);
      ("t2.medium", T2_medium);
      ("t2.small", T2_small);
      ("t2.micro", T2_micro);
      ("t2.nano", T2_nano);
      ("t1.micro", T1_micro)]
    let t_to_str =
      [(Inf1_24xlarge, "inf1.24xlarge");
      (Inf1_6xlarge, "inf1.6xlarge");
      (Inf1_2xlarge, "inf1.2xlarge");
      (Inf1_xlarge, "inf1.xlarge");
      (R5n_24xlarge, "r5n.24xlarge");
      (R5n_16xlarge, "r5n.16xlarge");
      (R5n_12xlarge, "r5n.12xlarge");
      (R5n_8xlarge, "r5n.8xlarge");
      (R5n_4xlarge, "r5n.4xlarge");
      (R5n_2xlarge, "r5n.2xlarge");
      (R5n_xlarge, "r5n.xlarge");
      (R5n_large, "r5n.large");
      (R5dn_24xlarge, "r5dn.24xlarge");
      (R5dn_16xlarge, "r5dn.16xlarge");
      (R5dn_12xlarge, "r5dn.12xlarge");
      (R5dn_8xlarge, "r5dn.8xlarge");
      (R5dn_4xlarge, "r5dn.4xlarge");
      (R5dn_2xlarge, "r5dn.2xlarge");
      (R5dn_xlarge, "r5dn.xlarge");
      (R5dn_large, "r5dn.large");
      (M5n_24xlarge, "m5n.24xlarge");
      (M5n_16xlarge, "m5n.16xlarge");
      (M5n_12xlarge, "m5n.12xlarge");
      (M5n_8xlarge, "m5n.8xlarge");
      (M5n_4xlarge, "m5n.4xlarge");
      (M5n_2xlarge, "m5n.2xlarge");
      (M5n_xlarge, "m5n.xlarge");
      (M5n_large, "m5n.large");
      (M5dn_24xlarge, "m5dn.24xlarge");
      (M5dn_16xlarge, "m5dn.16xlarge");
      (M5dn_12xlarge, "m5dn.12xlarge");
      (M5dn_8xlarge, "m5dn.8xlarge");
      (M5dn_4xlarge, "m5dn.4xlarge");
      (M5dn_2xlarge, "m5dn.2xlarge");
      (M5dn_xlarge, "m5dn.xlarge");
      (M5dn_large, "m5dn.large");
      (A1_metal, "a1.metal");
      (A1_4xlarge, "a1.4xlarge");
      (A1_2xlarge, "a1.2xlarge");
      (A1_xlarge, "a1.xlarge");
      (A1_large, "a1.large");
      (A1_medium, "a1.medium");
      (U_24tb1_metal, "u-24tb1.metal");
      (U_18tb1_metal, "u-18tb1.metal");
      (U_12tb1_metal, "u-12tb1.metal");
      (U_9tb1_metal, "u-9tb1.metal");
      (U_6tb1_metal, "u-6tb1.metal");
      (Z1d_metal, "z1d.metal");
      (Z1d_12xlarge, "z1d.12xlarge");
      (Z1d_6xlarge, "z1d.6xlarge");
      (Z1d_3xlarge, "z1d.3xlarge");
      (Z1d_2xlarge, "z1d.2xlarge");
      (Z1d_xlarge, "z1d.xlarge");
      (Z1d_large, "z1d.large");
      (H1_16xlarge, "h1.16xlarge");
      (H1_8xlarge, "h1.8xlarge");
      (H1_4xlarge, "h1.4xlarge");
      (H1_2xlarge, "h1.2xlarge");
      (M5ad_24xlarge, "m5ad.24xlarge");
      (M5ad_16xlarge, "m5ad.16xlarge");
      (M5ad_12xlarge, "m5ad.12xlarge");
      (M5ad_8xlarge, "m5ad.8xlarge");
      (M5ad_4xlarge, "m5ad.4xlarge");
      (M5ad_2xlarge, "m5ad.2xlarge");
      (M5ad_xlarge, "m5ad.xlarge");
      (M5ad_large, "m5ad.large");
      (M5d_metal, "m5d.metal");
      (M5d_24xlarge, "m5d.24xlarge");
      (M5d_16xlarge, "m5d.16xlarge");
      (M5d_12xlarge, "m5d.12xlarge");
      (M5d_8xlarge, "m5d.8xlarge");
      (M5d_4xlarge, "m5d.4xlarge");
      (M5d_2xlarge, "m5d.2xlarge");
      (M5d_xlarge, "m5d.xlarge");
      (M5d_large, "m5d.large");
      (M5a_24xlarge, "m5a.24xlarge");
      (M5a_16xlarge, "m5a.16xlarge");
      (M5a_12xlarge, "m5a.12xlarge");
      (M5a_8xlarge, "m5a.8xlarge");
      (M5a_4xlarge, "m5a.4xlarge");
      (M5a_2xlarge, "m5a.2xlarge");
      (M5a_xlarge, "m5a.xlarge");
      (M5a_large, "m5a.large");
      (M5_metal, "m5.metal");
      (M5_24xlarge, "m5.24xlarge");
      (M5_16xlarge, "m5.16xlarge");
      (M5_12xlarge, "m5.12xlarge");
      (M5_8xlarge, "m5.8xlarge");
      (M5_4xlarge, "m5.4xlarge");
      (M5_2xlarge, "m5.2xlarge");
      (M5_xlarge, "m5.xlarge");
      (M5_large, "m5.large");
      (F1_16xlarge, "f1.16xlarge");
      (F1_4xlarge, "f1.4xlarge");
      (F1_2xlarge, "f1.2xlarge");
      (D2_8xlarge, "d2.8xlarge");
      (D2_4xlarge, "d2.4xlarge");
      (D2_2xlarge, "d2.2xlarge");
      (D2_xlarge, "d2.xlarge");
      (P3dn_24xlarge, "p3dn.24xlarge");
      (P3_16xlarge, "p3.16xlarge");
      (P3_8xlarge, "p3.8xlarge");
      (P3_2xlarge, "p3.2xlarge");
      (P2_16xlarge, "p2.16xlarge");
      (P2_8xlarge, "p2.8xlarge");
      (P2_xlarge, "p2.xlarge");
      (Cg1_4xlarge, "cg1.4xlarge");
      (G4dn_16xlarge, "g4dn.16xlarge");
      (G4dn_12xlarge, "g4dn.12xlarge");
      (G4dn_8xlarge, "g4dn.8xlarge");
      (G4dn_4xlarge, "g4dn.4xlarge");
      (G4dn_2xlarge, "g4dn.2xlarge");
      (G4dn_xlarge, "g4dn.xlarge");
      (G3s_xlarge, "g3s.xlarge");
      (G3_16xlarge, "g3.16xlarge");
      (G3_8xlarge, "g3.8xlarge");
      (G3_4xlarge, "g3.4xlarge");
      (G2_8xlarge, "g2.8xlarge");
      (G2_2xlarge, "g2.2xlarge");
      (Cc2_8xlarge, "cc2.8xlarge");
      (Cc1_4xlarge, "cc1.4xlarge");
      (C5n_18xlarge, "c5n.18xlarge");
      (C5n_9xlarge, "c5n.9xlarge");
      (C5n_4xlarge, "c5n.4xlarge");
      (C5n_2xlarge, "c5n.2xlarge");
      (C5n_xlarge, "c5n.xlarge");
      (C5n_large, "c5n.large");
      (C5d_metal, "c5d.metal");
      (C5d_24xlarge, "c5d.24xlarge");
      (C5d_18xlarge, "c5d.18xlarge");
      (C5d_12xlarge, "c5d.12xlarge");
      (C5d_9xlarge, "c5d.9xlarge");
      (C5d_4xlarge, "c5d.4xlarge");
      (C5d_2xlarge, "c5d.2xlarge");
      (C5d_xlarge, "c5d.xlarge");
      (C5d_large, "c5d.large");
      (C5_metal, "c5.metal");
      (C5_24xlarge, "c5.24xlarge");
      (C5_18xlarge, "c5.18xlarge");
      (C5_12xlarge, "c5.12xlarge");
      (C5_9xlarge, "c5.9xlarge");
      (C5_4xlarge, "c5.4xlarge");
      (C5_2xlarge, "c5.2xlarge");
      (C5_xlarge, "c5.xlarge");
      (C5_large, "c5.large");
      (C4_8xlarge, "c4.8xlarge");
      (C4_4xlarge, "c4.4xlarge");
      (C4_2xlarge, "c4.2xlarge");
      (C4_xlarge, "c4.xlarge");
      (C4_large, "c4.large");
      (C3_8xlarge, "c3.8xlarge");
      (C3_4xlarge, "c3.4xlarge");
      (C3_2xlarge, "c3.2xlarge");
      (C3_xlarge, "c3.xlarge");
      (C3_large, "c3.large");
      (C1_xlarge, "c1.xlarge");
      (C1_medium, "c1.medium");
      (Hs1_8xlarge, "hs1.8xlarge");
      (Hi1_4xlarge, "hi1.4xlarge");
      (I3en_metal, "i3en.metal");
      (I3en_24xlarge, "i3en.24xlarge");
      (I3en_12xlarge, "i3en.12xlarge");
      (I3en_6xlarge, "i3en.6xlarge");
      (I3en_3xlarge, "i3en.3xlarge");
      (I3en_2xlarge, "i3en.2xlarge");
      (I3en_xlarge, "i3en.xlarge");
      (I3en_large, "i3en.large");
      (I3_metal, "i3.metal");
      (I3_16xlarge, "i3.16xlarge");
      (I3_8xlarge, "i3.8xlarge");
      (I3_4xlarge, "i3.4xlarge");
      (I3_2xlarge, "i3.2xlarge");
      (I3_xlarge, "i3.xlarge");
      (I3_large, "i3.large");
      (I2_8xlarge, "i2.8xlarge");
      (I2_4xlarge, "i2.4xlarge");
      (I2_2xlarge, "i2.2xlarge");
      (I2_xlarge, "i2.xlarge");
      (X1e_32xlarge, "x1e.32xlarge");
      (X1e_16xlarge, "x1e.16xlarge");
      (X1e_8xlarge, "x1e.8xlarge");
      (X1e_4xlarge, "x1e.4xlarge");
      (X1e_2xlarge, "x1e.2xlarge");
      (X1e_xlarge, "x1e.xlarge");
      (X1_32xlarge, "x1.32xlarge");
      (X1_16xlarge, "x1.16xlarge");
      (R5ad_24xlarge, "r5ad.24xlarge");
      (R5ad_16xlarge, "r5ad.16xlarge");
      (R5ad_12xlarge, "r5ad.12xlarge");
      (R5ad_8xlarge, "r5ad.8xlarge");
      (R5ad_4xlarge, "r5ad.4xlarge");
      (R5ad_2xlarge, "r5ad.2xlarge");
      (R5ad_xlarge, "r5ad.xlarge");
      (R5ad_large, "r5ad.large");
      (R5d_metal, "r5d.metal");
      (R5d_24xlarge, "r5d.24xlarge");
      (R5d_16xlarge, "r5d.16xlarge");
      (R5d_12xlarge, "r5d.12xlarge");
      (R5d_8xlarge, "r5d.8xlarge");
      (R5d_4xlarge, "r5d.4xlarge");
      (R5d_2xlarge, "r5d.2xlarge");
      (R5d_xlarge, "r5d.xlarge");
      (R5d_large, "r5d.large");
      (R5a_24xlarge, "r5a.24xlarge");
      (R5a_16xlarge, "r5a.16xlarge");
      (R5a_12xlarge, "r5a.12xlarge");
      (R5a_8xlarge, "r5a.8xlarge");
      (R5a_4xlarge, "r5a.4xlarge");
      (R5a_2xlarge, "r5a.2xlarge");
      (R5a_xlarge, "r5a.xlarge");
      (R5a_large, "r5a.large");
      (R5_metal, "r5.metal");
      (R5_24xlarge, "r5.24xlarge");
      (R5_16xlarge, "r5.16xlarge");
      (R5_12xlarge, "r5.12xlarge");
      (R5_8xlarge, "r5.8xlarge");
      (R5_4xlarge, "r5.4xlarge");
      (R5_2xlarge, "r5.2xlarge");
      (R5_xlarge, "r5.xlarge");
      (R5_large, "r5.large");
      (R4_16xlarge, "r4.16xlarge");
      (R4_8xlarge, "r4.8xlarge");
      (R4_4xlarge, "r4.4xlarge");
      (R4_2xlarge, "r4.2xlarge");
      (R4_xlarge, "r4.xlarge");
      (R4_large, "r4.large");
      (R3_8xlarge, "r3.8xlarge");
      (R3_4xlarge, "r3.4xlarge");
      (R3_2xlarge, "r3.2xlarge");
      (R3_xlarge, "r3.xlarge");
      (R3_large, "r3.large");
      (Cr1_8xlarge, "cr1.8xlarge");
      (M2_4xlarge, "m2.4xlarge");
      (M2_2xlarge, "m2.2xlarge");
      (M2_xlarge, "m2.xlarge");
      (M4_16xlarge, "m4.16xlarge");
      (M4_10xlarge, "m4.10xlarge");
      (M4_4xlarge, "m4.4xlarge");
      (M4_2xlarge, "m4.2xlarge");
      (M4_xlarge, "m4.xlarge");
      (M4_large, "m4.large");
      (M3_2xlarge, "m3.2xlarge");
      (M3_xlarge, "m3.xlarge");
      (M3_large, "m3.large");
      (M3_medium, "m3.medium");
      (M1_xlarge, "m1.xlarge");
      (M1_large, "m1.large");
      (M1_medium, "m1.medium");
      (M1_small, "m1.small");
      (T3a_2xlarge, "t3a.2xlarge");
      (T3a_xlarge, "t3a.xlarge");
      (T3a_large, "t3a.large");
      (T3a_medium, "t3a.medium");
      (T3a_small, "t3a.small");
      (T3a_micro, "t3a.micro");
      (T3a_nano, "t3a.nano");
      (T3_2xlarge, "t3.2xlarge");
      (T3_xlarge, "t3.xlarge");
      (T3_large, "t3.large");
      (T3_medium, "t3.medium");
      (T3_small, "t3.small");
      (T3_micro, "t3.micro");
      (T3_nano, "t3.nano");
      (T2_2xlarge, "t2.2xlarge");
      (T2_xlarge, "t2.xlarge");
      (T2_large, "t2.large");
      (T2_medium, "t2.medium");
      (T2_small, "t2.small");
      (T2_micro, "t2.micro");
      (T2_nano, "t2.nano");
      (T1_micro, "t1.micro")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module AttachmentStatus =
  struct
    type t =
      | Attaching 
      | Attached 
      | Detaching 
      | Detached 
    let str_to_t =
      [("detached", Detached);
      ("detaching", Detaching);
      ("attached", Attached);
      ("attaching", Attaching)]
    let t_to_str =
      [(Detached, "detached");
      (Detaching, "detaching");
      (Attached, "attached");
      (Attaching, "attaching")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module GroupIdentifier =
  struct
    type t =
      {
      group_name: String.t option
        [@ocaml.doc "<p>The name of the security group.</p>"];
      group_id: String.t option
        [@ocaml.doc "<p>The ID of the security group.</p>"]}[@@ocaml.doc
                                                              "<p>Describes a security group.</p>"]
    let make ?group_name  ?group_id  () = { group_name; group_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_id
              (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_id
              (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)))])
    let parse xml =
      Some
        {
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.group_name
               (fun f -> Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.group_id
              (fun f -> Ezxmlm.make_tag "groupId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a security group.</p>"]
module InstancePrivateIpAddress =
  struct
    type t =
      {
      association: InstanceNetworkInterfaceAssociation.t option
        [@ocaml.doc
          "<p>The association information for an Elastic IP address for the network interface.</p>"];
      primary: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether this IPv4 address is the primary private IP address of the network interface.</p>"];
      private_dns_name: String.t option
        [@ocaml.doc "<p>The private IPv4 DNS name.</p>"];
      private_ip_address: String.t option
        [@ocaml.doc
          "<p>The private IPv4 address of the network interface.</p>"]}
    [@@ocaml.doc "<p>Describes a private IPv4 address.</p>"]
    let make ?association  ?primary  ?private_dns_name  ?private_ip_address 
      () = { association; primary; private_dns_name; private_ip_address }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.primary
             (fun f -> Query.Pair ("Primary", (Boolean.to_query f)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association",
                    (InstanceNetworkInterfaceAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.primary
             (fun f -> ("primary", (Boolean.to_json f)));
           Util.option_map v.association
             (fun f ->
                ("association",
                  (InstanceNetworkInterfaceAssociation.to_json f)))])
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               InstanceNetworkInterfaceAssociation.parse);
          primary =
            (Util.option_bind (Xml.member "primary" xml) Boolean.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.association
                 (fun f ->
                    Ezxmlm.make_tag "association"
                      ([], (InstanceNetworkInterfaceAssociation.to_xml f)))])
             @
             [Util.option_map v.primary
                (fun f -> Ezxmlm.make_tag "primary" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.private_dns_name
               (fun f ->
                  Ezxmlm.make_tag "privateDnsName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.private_ip_address
              (fun f ->
                 Ezxmlm.make_tag "privateIpAddress" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a private IPv4 address.</p>"]
module IKEVersionsListValue =
  struct
    type t = {
      value: String.t option [@ocaml.doc "<p>The IKE version.</p>"]}[@@ocaml.doc
                                                                    "<p>The internet key exchange (IKE) version permitted for the VPN tunnel.</p>"]
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>The internet key exchange (IKE) version permitted for the VPN tunnel.</p>"]
module Phase1DHGroupNumbersListValue =
  struct
    type t =
      {
      value: Integer.t option
        [@ocaml.doc "<p>The Diffie-Hellmann group number.</p>"]}[@@ocaml.doc
                                                                  "<p>The Diffie-Hellmann group number for phase 1 IKE negotiations.</p>"]
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Integer.to_json f)))])
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) Integer.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc
       "<p>The Diffie-Hellmann group number for phase 1 IKE negotiations.</p>"]
module Phase1EncryptionAlgorithmsListValue =
  struct
    type t =
      {
      value: String.t option
        [@ocaml.doc "<p>The value for the encryption algorithm.</p>"]}
    [@@ocaml.doc
      "<p>The encryption algorithm for phase 1 IKE negotiations.</p>"]
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>The encryption algorithm for phase 1 IKE negotiations.</p>"]
module Phase1IntegrityAlgorithmsListValue =
  struct
    type t =
      {
      value: String.t option
        [@ocaml.doc "<p>The value for the integrity algorithm.</p>"]}
    [@@ocaml.doc
      "<p>The integrity algorithm for phase 1 IKE negotiations.</p>"]
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>The integrity algorithm for phase 1 IKE negotiations.</p>"]
module Phase2DHGroupNumbersListValue =
  struct
    type t =
      {
      value: Integer.t option
        [@ocaml.doc "<p>The Diffie-Hellmann group number.</p>"]}[@@ocaml.doc
                                                                  "<p>The Diffie-Hellmann group number for phase 2 IKE negotiations.</p>"]
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Integer.to_json f)))])
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) Integer.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc
       "<p>The Diffie-Hellmann group number for phase 2 IKE negotiations.</p>"]
module Phase2EncryptionAlgorithmsListValue =
  struct
    type t =
      {
      value: String.t option [@ocaml.doc "<p>The encryption algorithm.</p>"]}
    [@@ocaml.doc
      "<p>The encryption algorithm for phase 2 IKE negotiations.</p>"]
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>The encryption algorithm for phase 2 IKE negotiations.</p>"]
module Phase2IntegrityAlgorithmsListValue =
  struct
    type t =
      {
      value: String.t option [@ocaml.doc "<p>The integrity algorithm.</p>"]}
    [@@ocaml.doc
      "<p>The integrity algorithm for phase 2 IKE negotiations.</p>"]
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>The integrity algorithm for phase 2 IKE negotiations.</p>"]
module DiskImageFormat =
  struct
    type t =
      | VMDK 
      | RAW 
      | VHD 
    let str_to_t = [("VHD", VHD); ("RAW", RAW); ("VMDK", VMDK)]
    let t_to_str = [(VHD, "VHD"); (RAW, "RAW"); (VMDK, "VMDK")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module PlacementResponse =
  struct
    type t =
      {
      group_name: String.t option
        [@ocaml.doc
          "<p>The name of the placement group that the instance is in.</p>"]}
    [@@ocaml.doc "<p>Describes the placement of an instance.</p>"]
    let make ?group_name  () = { group_name }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> Query.Pair ("GroupName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> ("group_name", (String.to_json f)))])
    let parse xml =
      Some
        {
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.group_name
              (fun f -> Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the placement of an instance.</p>"]
module BlockDeviceMapping =
  struct
    type t =
      {
      device_name: String.t
        [@ocaml.doc
          "<p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>"];
      virtual_name: String.t option
        [@ocaml.doc
          "<p>The virtual device name (<code>ephemeral</code>N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for <code>ephemeral0</code> and <code>ephemeral1</code>. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.</p> <p>NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.</p> <p>Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.</p>"];
      ebs: EbsBlockDevice.t option
        [@ocaml.doc
          "<p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>"];
      no_device: String.t option
        [@ocaml.doc
          "<p>Suppresses the specified device included in the block device mapping of the AMI.</p>"]}
    [@@ocaml.doc "<p>Describes a block device mapping.</p>"]
    let make ~device_name  ?virtual_name  ?ebs  ?no_device  () =
      { device_name; virtual_name; ebs; no_device }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.ebs
             (fun f -> Query.Pair ("Ebs", (EbsBlockDevice.to_query f)));
           Util.option_map v.virtual_name
             (fun f -> Query.Pair ("VirtualName", (String.to_query f)));
           Some (Query.Pair ("DeviceName", (String.to_query v.device_name)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.ebs
             (fun f -> ("ebs", (EbsBlockDevice.to_json f)));
           Util.option_map v.virtual_name
             (fun f -> ("virtual_name", (String.to_json f)));
           Some ("device_name", (String.to_json v.device_name))])
    let parse xml =
      Some
        {
          device_name =
            (Xml.required "deviceName"
               (Util.option_bind (Xml.member "deviceName" xml) String.parse));
          virtual_name =
            (Util.option_bind (Xml.member "virtualName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "ebs" xml) EbsBlockDevice.parse);
          no_device =
            (Util.option_bind (Xml.member "noDevice" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "deviceName"
                    ([], (String.to_xml v.device_name)))])
             @
             [Util.option_map v.virtual_name
                (fun f ->
                   Ezxmlm.make_tag "virtualName" ([], (String.to_xml f)))])
            @
            [Util.option_map v.ebs
               (fun f ->
                  Ezxmlm.make_tag "ebs" ([], (EbsBlockDevice.to_xml f)))])
           @
           [Util.option_map v.no_device
              (fun f -> Ezxmlm.make_tag "noDevice" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a block device mapping.</p>"]
module InstanceNetworkInterfaceSpecification =
  struct
    type t =
      {
      associate_public_ip_address: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is <code>true</code>.</p>"];
      delete_on_termination: Boolean.t option
        [@ocaml.doc
          "<p>If set to <code>true</code>, the interface is deleted when the instance is terminated. You can specify <code>true</code> only if creating a new network interface when launching an instance.</p>"];
      description: String.t option
        [@ocaml.doc
          "<p>The description of the network interface. Applies only if creating a network interface when launching an instance.</p>"];
      device_index: Integer.t option
        [@ocaml.doc
          "<p>The position of the network interface in the attachment order. A primary network interface has a device index of 0.</p> <p>If you specify a network interface when launching an instance, you must specify the device index.</p>"];
      groups: SecurityGroupIdStringList.t
        [@ocaml.doc
          "<p>The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.</p>"];
      ipv6_address_count: Integer.t option
        [@ocaml.doc
          "<p>A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.</p>"];
      ipv6_addresses: InstanceIpv6AddressList.t
        [@ocaml.doc
          "<p>One or more IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.</p>"];
      network_interface_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface.</p>"];
      private_ip_address: String.t option
        [@ocaml.doc
          "<p>The private IPv4 address of the network interface. Applies only if creating a network interface when launching an instance. You cannot specify this option if you're launching more than one instance in a <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html\">RunInstances</a> request.</p>"];
      private_ip_addresses: PrivateIpAddressSpecificationList.t
        [@ocaml.doc
          "<p>One or more private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html\">RunInstances</a> request.</p>"];
      secondary_private_ip_address_count: Integer.t option
        [@ocaml.doc
          "<p>The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html\">RunInstances</a> request.</p>"];
      subnet_id: String.t option
        [@ocaml.doc
          "<p>The ID of the subnet associated with the network interface. Applies only if creating a network interface when launching an instance.</p>"];
      interface_type: String.t option
        [@ocaml.doc
          "<p>The type of network interface. To create an Elastic Fabric Adapter (EFA), specify <code>efa</code>. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html\">Elastic Fabric Adapter</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>If you are not creating an EFA, specify <code>interface</code> or omit this parameter.</p> <p>Valid values: <code>interface</code> | <code>efa</code> </p>"]}
    [@@ocaml.doc "<p>Describes a network interface.</p>"]
    let make ?associate_public_ip_address  ?delete_on_termination 
      ?description  ?device_index  ?(groups= [])  ?ipv6_address_count 
      ?(ipv6_addresses= [])  ?network_interface_id  ?private_ip_address 
      ?(private_ip_addresses= [])  ?secondary_private_ip_address_count 
      ?subnet_id  ?interface_type  () =
      {
        associate_public_ip_address;
        delete_on_termination;
        description;
        device_index;
        groups;
        ipv6_address_count;
        ipv6_addresses;
        network_interface_id;
        private_ip_address;
        private_ip_addresses;
        secondary_private_ip_address_count;
        subnet_id;
        interface_type
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.interface_type
              (fun f -> Query.Pair ("InterfaceType", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddressesSet",
                  (PrivateIpAddressSpecificationList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6AddressesSet",
                  (InstanceIpv6AddressList.to_query v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.groups)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.associate_public_ip_address
             (fun f ->
                Query.Pair ("AssociatePublicIpAddress", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.interface_type
              (fun f -> ("interface_type", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_addresses",
               (PrivateIpAddressSpecificationList.to_json
                  v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (InstanceIpv6AddressList.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)));
           Some ("groups", (SecurityGroupIdStringList.to_json v.groups));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.associate_public_ip_address
             (fun f -> ("associate_public_ip_address", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          associate_public_ip_address =
            (Util.option_bind (Xml.member "associatePublicIpAddress" xml)
               Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          device_index =
            (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          ipv6_address_count =
            (Util.option_bind (Xml.member "ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6AddressesSet" xml)
                  InstanceIpv6AddressList.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddressesSet" xml)
                  PrivateIpAddressSpecificationList.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "secondaryPrivateIpAddressCount" xml)
               Integer.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          interface_type =
            (Util.option_bind (Xml.member "InterfaceType" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.associate_public_ip_address
                          (fun f ->
                             Ezxmlm.make_tag "associatePublicIpAddress"
                               ([], (Boolean.to_xml f)))])
                      @
                      [Util.option_map v.delete_on_termination
                         (fun f ->
                            Ezxmlm.make_tag "deleteOnTermination"
                              ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.description
                        (fun f ->
                           Ezxmlm.make_tag "description"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.device_index
                       (fun f ->
                          Ezxmlm.make_tag "deviceIndex"
                            ([], (Integer.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "SecurityGroupId"
                              ([], (SecurityGroupIdStringList.to_xml [x]))))
                      v.groups))
                  @
                  [Util.option_map v.ipv6_address_count
                     (fun f ->
                        Ezxmlm.make_tag "ipv6AddressCount"
                          ([], (Integer.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "ipv6AddressesSet"
                            ([], (InstanceIpv6AddressList.to_xml [x]))))
                    v.ipv6_addresses))
                @
                [Util.option_map v.network_interface_id
                   (fun f ->
                      Ezxmlm.make_tag "networkInterfaceId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.private_ip_address
                  (fun f ->
                     Ezxmlm.make_tag "privateIpAddress"
                       ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "privateIpAddressesSet"
                         ([], (PrivateIpAddressSpecificationList.to_xml [x]))))
                 v.private_ip_addresses))
             @
             [Util.option_map v.secondary_private_ip_address_count
                (fun f ->
                   Ezxmlm.make_tag "secondaryPrivateIpAddressCount"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.subnet_id
               (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.interface_type
              (fun f ->
                 Ezxmlm.make_tag "InterfaceType" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a network interface.</p>"]
module SpotFleetTagSpecification =
  struct
    type t =
      {
      resource_type: ResourceType.t option
        [@ocaml.doc
          "<p>The type of resource. Currently, the only resource type that is supported is <code>instance</code>.</p>"];
      tags: TagList.t [@ocaml.doc "<p>The tags.</p>"]}[@@ocaml.doc
                                                        "<p>The tags for a Spot Fleet resource.</p>"]
    let make ?resource_type  ?(tags= [])  () = { resource_type; tags }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Tag", (TagList.to_query v.tags)));
           Util.option_map v.resource_type
             (fun f -> Query.Pair ("ResourceType", (ResourceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.resource_type
             (fun f -> ("resource_type", (ResourceType.to_json f)))])
    let parse xml =
      Some
        {
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               ResourceType.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tag" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "resourceType"
                    ([], (ResourceType.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tag" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>The tags for a Spot Fleet resource.</p>"]
module Tenancy =
  struct
    type t =
      | Default 
      | Dedicated 
      | Host 
    let str_to_t =
      [("host", Host); ("dedicated", Dedicated); ("default", Default)]
    let t_to_str =
      [(Host, "host"); (Dedicated, "dedicated"); (Default, "default")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module LaunchTemplateOverrides =
  struct
    type t =
      {
      instance_type: InstanceType.t option
        [@ocaml.doc "<p>The instance type.</p>"];
      spot_price: String.t option
        [@ocaml.doc
          "<p>The maximum price per unit hour that you are willing to pay for a Spot Instance.</p>"];
      subnet_id: String.t option
        [@ocaml.doc
          "<p>The ID of the subnet in which to launch the instances.</p>"];
      availability_zone: String.t option
        [@ocaml.doc
          "<p>The Availability Zone in which to launch the instances.</p>"];
      weighted_capacity: Double.t option
        [@ocaml.doc
          "<p>The number of units provided by the specified instance type.</p>"];
      priority: Double.t option
        [@ocaml.doc
          "<p>The priority for the launch template override. If <b>OnDemandAllocationStrategy</b> is set to <code>prioritized</code>, Spot Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. Valid values are whole numbers starting at <code>0</code>. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.</p>"]}
    [@@ocaml.doc "<p>Describes overrides for a launch template.</p>"]
    let make ?instance_type  ?spot_price  ?subnet_id  ?availability_zone 
      ?weighted_capacity  ?priority  () =
      {
        instance_type;
        spot_price;
        subnet_id;
        availability_zone;
        weighted_capacity;
        priority
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.priority
              (fun f -> Query.Pair ("Priority", (Double.to_query f)));
           Util.option_map v.weighted_capacity
             (fun f -> Query.Pair ("WeightedCapacity", (Double.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.priority
              (fun f -> ("priority", (Double.to_json f)));
           Util.option_map v.weighted_capacity
             (fun f -> ("weighted_capacity", (Double.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)))])
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          weighted_capacity =
            (Util.option_bind (Xml.member "weightedCapacity" xml)
               Double.parse);
          priority =
            (Util.option_bind (Xml.member "priority" xml) Double.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.instance_type
                   (fun f ->
                      Ezxmlm.make_tag "instanceType"
                        ([], (InstanceType.to_xml f)))])
               @
               [Util.option_map v.spot_price
                  (fun f ->
                     Ezxmlm.make_tag "spotPrice" ([], (String.to_xml f)))])
              @
              [Util.option_map v.subnet_id
                 (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.availability_zone
                (fun f ->
                   Ezxmlm.make_tag "availabilityZone" ([], (String.to_xml f)))])
            @
            [Util.option_map v.weighted_capacity
               (fun f ->
                  Ezxmlm.make_tag "weightedCapacity" ([], (Double.to_xml f)))])
           @
           [Util.option_map v.priority
              (fun f -> Ezxmlm.make_tag "priority" ([], (Double.to_xml f)))])
  end[@@ocaml.doc "<p>Describes overrides for a launch template.</p>"]
module ClassicLoadBalancer =
  struct
    type t =
      {
      name: String.t option
        [@ocaml.doc "<p>The name of the load balancer.</p>"]}[@@ocaml.doc
                                                               "<p>Describes a Classic Load Balancer.</p>"]
    let make ?name  () = { name }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let parse xml =
      Some { name = (Util.option_bind (Xml.member "name" xml) String.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.name
              (fun f -> Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a Classic Load Balancer.</p>"]
module TargetGroup =
  struct
    type t =
      {
      arn: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the target group.</p>"]}
    [@@ocaml.doc "<p>Describes a load balancer target group.</p>"]
    let make ?arn  () = { arn }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.arn
              (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let parse xml =
      Some { arn = (Util.option_bind (Xml.member "arn" xml) String.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.arn
              (fun f -> Ezxmlm.make_tag "arn" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a load balancer target group.</p>"]
module EbsInstanceBlockDevice =
  struct
    type t =
      {
      attach_time: DateTime.t option
        [@ocaml.doc "<p>The time stamp when the attachment initiated.</p>"];
      delete_on_termination: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the volume is deleted on instance termination.</p>"];
      status: AttachmentStatus.t option
        [@ocaml.doc "<p>The attachment state.</p>"];
      volume_id: String.t option
        [@ocaml.doc "<p>The ID of the EBS volume.</p>"]}[@@ocaml.doc
                                                          "<p>Describes a parameter used to set up an EBS volume in a block device mapping.</p>"]
    let make ?attach_time  ?delete_on_termination  ?status  ?volume_id  () =
      { attach_time; delete_on_termination; status; volume_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (AttachmentStatus.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attach_time
             (fun f -> Query.Pair ("AttachTime", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> ("volume_id", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (AttachmentStatus.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attach_time
             (fun f -> ("attach_time", (DateTime.to_json f)))])
    let parse xml =
      Some
        {
          attach_time =
            (Util.option_bind (Xml.member "attachTime" xml) DateTime.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AttachmentStatus.parse);
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.attach_time
                 (fun f ->
                    Ezxmlm.make_tag "attachTime" ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.delete_on_termination
                (fun f ->
                   Ezxmlm.make_tag "deleteOnTermination"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.status
               (fun f ->
                  Ezxmlm.make_tag "status" ([], (AttachmentStatus.to_xml f)))])
           @
           [Util.option_map v.volume_id
              (fun f -> Ezxmlm.make_tag "volumeId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a parameter used to set up an EBS volume in a block device mapping.</p>"]
module GroupIdentifierList =
  struct
    type t = GroupIdentifier.t list
    let make elems () = elems
    let to_query v = Query.to_query_list GroupIdentifier.to_query v
    let to_headers v = Headers.to_headers_list GroupIdentifier.to_headers v
    let to_json v = `List (List.map GroupIdentifier.to_json v)
    let parse xml =
      Util.option_all
        (List.map GroupIdentifier.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (GroupIdentifier.to_xml x)))
        v
  end
module InstanceNetworkInterfaceAttachment =
  struct
    type t =
      {
      attach_time: DateTime.t option
        [@ocaml.doc "<p>The time stamp when the attachment initiated.</p>"];
      attachment_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface attachment.</p>"];
      delete_on_termination: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the network interface is deleted when the instance is terminated.</p>"];
      device_index: Integer.t option
        [@ocaml.doc
          "<p>The index of the device on the instance for the network interface attachment.</p>"];
      status: AttachmentStatus.t option
        [@ocaml.doc "<p>The attachment state.</p>"]}[@@ocaml.doc
                                                      "<p>Describes a network interface attachment.</p>"]
    let make ?attach_time  ?attachment_id  ?delete_on_termination 
      ?device_index  ?status  () =
      {
        attach_time;
        attachment_id;
        delete_on_termination;
        device_index;
        status
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (AttachmentStatus.to_query f)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attachment_id
             (fun f -> Query.Pair ("AttachmentId", (String.to_query f)));
           Util.option_map v.attach_time
             (fun f -> Query.Pair ("AttachTime", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (AttachmentStatus.to_json f)));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attachment_id
             (fun f -> ("attachment_id", (String.to_json f)));
           Util.option_map v.attach_time
             (fun f -> ("attach_time", (DateTime.to_json f)))])
    let parse xml =
      Some
        {
          attach_time =
            (Util.option_bind (Xml.member "attachTime" xml) DateTime.parse);
          attachment_id =
            (Util.option_bind (Xml.member "attachmentId" xml) String.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          device_index =
            (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AttachmentStatus.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.attach_time
                  (fun f ->
                     Ezxmlm.make_tag "attachTime" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.attachment_id
                 (fun f ->
                    Ezxmlm.make_tag "attachmentId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.delete_on_termination
                (fun f ->
                   Ezxmlm.make_tag "deleteOnTermination"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.device_index
               (fun f ->
                  Ezxmlm.make_tag "deviceIndex" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status" ([], (AttachmentStatus.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a network interface attachment.</p>"]
module InstancePrivateIpAddressList =
  struct
    type t = InstancePrivateIpAddress.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InstancePrivateIpAddress.to_query v
    let to_headers v =
      Headers.to_headers_list InstancePrivateIpAddress.to_headers v
    let to_json v = `List (List.map InstancePrivateIpAddress.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstancePrivateIpAddress.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstancePrivateIpAddress.to_xml x)))
        v
  end
module NetworkInterfaceStatus =
  struct
    type t =
      | Available 
      | Associated 
      | Attaching 
      | In_use 
      | Detaching 
    let str_to_t =
      [("detaching", Detaching);
      ("in-use", In_use);
      ("attaching", Attaching);
      ("associated", Associated);
      ("available", Available)]
    let t_to_str =
      [(Detaching, "detaching");
      (In_use, "in-use");
      (Attaching, "attaching");
      (Associated, "associated");
      (Available, "available")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ProductCodeValues =
  struct
    type t =
      | Devpay 
      | Marketplace 
    let str_to_t = [("marketplace", Marketplace); ("devpay", Devpay)]
    let t_to_str = [(Marketplace, "marketplace"); (Devpay, "devpay")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module AttributeValue =
  struct
    type t =
      {
      value: String.t option
        [@ocaml.doc
          "<p>The attribute value. The value is case-sensitive.</p>"]}
    [@@ocaml.doc
      "<p>Describes a value for a resource attribute that is a String.</p>"]
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a value for a resource attribute that is a String.</p>"]
module Scope =
  struct
    type t =
      | Availability_Zone 
      | Region 
    let str_to_t =
      [("Region", Region); ("Availability Zone", Availability_Zone)]
    let t_to_str =
      [(Region, "Region"); (Availability_Zone, "Availability Zone")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module StatusName =
  struct
    type t =
      | Reachability 
    let str_to_t = [("reachability", Reachability)]
    let t_to_str = [(Reachability, "reachability")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module StatusType =
  struct
    type t =
      | Passed 
      | Failed 
      | Insufficient_data 
      | Initializing 
    let str_to_t =
      [("initializing", Initializing);
      ("insufficient-data", Insufficient_data);
      ("failed", Failed);
      ("passed", Passed)]
    let t_to_str =
      [(Initializing, "initializing");
      (Insufficient_data, "insufficient-data");
      (Failed, "failed");
      (Passed, "passed")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module UserIdGroupPair =
  struct
    type t =
      {
      description: String.t option
        [@ocaml.doc
          "<p>A description for the security group rule that references this user ID group pair.</p> <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*</p>"];
      group_id: String.t option
        [@ocaml.doc "<p>The ID of the security group.</p>"];
      group_name: String.t option
        [@ocaml.doc
          "<p>The name of the security group. In a request, use this parameter for a security group in EC2-Classic or a default VPC only. For a security group in a nondefault VPC, use the security group ID. </p> <p>For a referenced security group in another VPC, this value is not returned if the referenced security group is deleted.</p>"];
      peering_status: String.t option
        [@ocaml.doc
          "<p>The status of a VPC peering connection, if applicable.</p>"];
      user_id: String.t option
        [@ocaml.doc
          "<p>The ID of an AWS account.</p> <p>For a referenced security group in another VPC, the account ID of the referenced security group is returned in the response. If the referenced security group is deleted, this value is not returned.</p> <p>[EC2-Classic] Required when adding or removing rules that reference a security group in another AWS account.</p>"];
      vpc_id: String.t option
        [@ocaml.doc
          "<p>The ID of the VPC for the referenced security group, if applicable.</p>"];
      vpc_peering_connection_id: String.t option
        [@ocaml.doc
          "<p>The ID of the VPC peering connection, if applicable.</p>"]}
    [@@ocaml.doc
      "<p>Describes a security group and AWS account ID pair.</p>"]
    let make ?description  ?group_id  ?group_name  ?peering_status  ?user_id 
      ?vpc_id  ?vpc_peering_connection_id  () =
      {
        description;
        group_id;
        group_name;
        peering_status;
        user_id;
        vpc_id;
        vpc_peering_connection_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.user_id
             (fun f -> Query.Pair ("UserId", (String.to_query f)));
           Util.option_map v.peering_status
             (fun f -> Query.Pair ("PeeringStatus", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.user_id
             (fun f -> ("user_id", (String.to_json f)));
           Util.option_map v.peering_status
             (fun f -> ("peering_status", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          peering_status =
            (Util.option_bind (Xml.member "peeringStatus" xml) String.parse);
          user_id = (Util.option_bind (Xml.member "userId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.description
                    (fun f ->
                       Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
                @
                [Util.option_map v.group_id
                   (fun f ->
                      Ezxmlm.make_tag "groupId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.group_name
                  (fun f ->
                     Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.peering_status
                 (fun f ->
                    Ezxmlm.make_tag "peeringStatus" ([], (String.to_xml f)))])
             @
             [Util.option_map v.user_id
                (fun f -> Ezxmlm.make_tag "userId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.vpc_id
               (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Ezxmlm.make_tag "vpcPeeringConnectionId"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a security group and AWS account ID pair.</p>"]
module FpgaDeviceMemoryInfo =
  struct
    type t =
      {
      size_in_mi_b: Integer.t option
        [@ocaml.doc
          "<p>The size (in MiB) for the memory available to the FPGA accelerator.</p>"]}
    [@@ocaml.doc
      "<p>Describes the memory for the FPGA accelerator for the instance type.</p>"]
    let make ?size_in_mi_b  () = { size_in_mi_b }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> Query.Pair ("SizeInMiB", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> ("size_in_mi_b", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          size_in_mi_b =
            (Util.option_bind (Xml.member "sizeInMiB" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.size_in_mi_b
              (fun f -> Ezxmlm.make_tag "sizeInMiB" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the memory for the FPGA accelerator for the instance type.</p>"]
module GpuDeviceMemoryInfo =
  struct
    type t =
      {
      size_in_mi_b: Integer.t option
        [@ocaml.doc
          "<p>The size (in MiB) for the memory available to the GPU accelerator.</p>"]}
    [@@ocaml.doc
      "<p>Describes the memory available to the GPU accelerator.</p>"]
    let make ?size_in_mi_b  () = { size_in_mi_b }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> Query.Pair ("SizeInMiB", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> ("size_in_mi_b", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          size_in_mi_b =
            (Util.option_bind (Xml.member "sizeInMiB" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.size_in_mi_b
              (fun f -> Ezxmlm.make_tag "sizeInMiB" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the memory available to the GPU accelerator.</p>"]
module DiskType =
  struct
    type t =
      | Hdd 
      | Ssd 
    let str_to_t = [("ssd", Ssd); ("hdd", Hdd)]
    let t_to_str = [(Ssd, "ssd"); (Hdd, "hdd")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module IKEVersionsList =
  struct
    type t = IKEVersionsListValue.t list
    let make elems () = elems
    let to_query v = Query.to_query_list IKEVersionsListValue.to_query v
    let to_headers v =
      Headers.to_headers_list IKEVersionsListValue.to_headers v
    let to_json v = `List (List.map IKEVersionsListValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map IKEVersionsListValue.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (IKEVersionsListValue.to_xml x))) v
  end
module Phase1DHGroupNumbersList =
  struct
    type t = Phase1DHGroupNumbersListValue.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list Phase1DHGroupNumbersListValue.to_query v
    let to_headers v =
      Headers.to_headers_list Phase1DHGroupNumbersListValue.to_headers v
    let to_json v = `List (List.map Phase1DHGroupNumbersListValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map Phase1DHGroupNumbersListValue.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase1DHGroupNumbersListValue.to_xml x))) v
  end
module Phase1EncryptionAlgorithmsList =
  struct
    type t = Phase1EncryptionAlgorithmsListValue.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list Phase1EncryptionAlgorithmsListValue.to_query v
    let to_headers v =
      Headers.to_headers_list Phase1EncryptionAlgorithmsListValue.to_headers
        v
    let to_json v =
      `List (List.map Phase1EncryptionAlgorithmsListValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map Phase1EncryptionAlgorithmsListValue.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase1EncryptionAlgorithmsListValue.to_xml x))) v
  end
module Phase1IntegrityAlgorithmsList =
  struct
    type t = Phase1IntegrityAlgorithmsListValue.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list Phase1IntegrityAlgorithmsListValue.to_query v
    let to_headers v =
      Headers.to_headers_list Phase1IntegrityAlgorithmsListValue.to_headers v
    let to_json v =
      `List (List.map Phase1IntegrityAlgorithmsListValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map Phase1IntegrityAlgorithmsListValue.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase1IntegrityAlgorithmsListValue.to_xml x))) v
  end
module Phase2DHGroupNumbersList =
  struct
    type t = Phase2DHGroupNumbersListValue.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list Phase2DHGroupNumbersListValue.to_query v
    let to_headers v =
      Headers.to_headers_list Phase2DHGroupNumbersListValue.to_headers v
    let to_json v = `List (List.map Phase2DHGroupNumbersListValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map Phase2DHGroupNumbersListValue.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase2DHGroupNumbersListValue.to_xml x))) v
  end
module Phase2EncryptionAlgorithmsList =
  struct
    type t = Phase2EncryptionAlgorithmsListValue.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list Phase2EncryptionAlgorithmsListValue.to_query v
    let to_headers v =
      Headers.to_headers_list Phase2EncryptionAlgorithmsListValue.to_headers
        v
    let to_json v =
      `List (List.map Phase2EncryptionAlgorithmsListValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map Phase2EncryptionAlgorithmsListValue.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase2EncryptionAlgorithmsListValue.to_xml x))) v
  end
module Phase2IntegrityAlgorithmsList =
  struct
    type t = Phase2IntegrityAlgorithmsListValue.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list Phase2IntegrityAlgorithmsListValue.to_query v
    let to_headers v =
      Headers.to_headers_list Phase2IntegrityAlgorithmsListValue.to_headers v
    let to_json v =
      `List (List.map Phase2IntegrityAlgorithmsListValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map Phase2IntegrityAlgorithmsListValue.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase2IntegrityAlgorithmsListValue.to_xml x))) v
  end
module DiskImageDescription =
  struct
    type t =
      {
      checksum: String.t option
        [@ocaml.doc "<p>The checksum computed for the disk image.</p>"];
      format: DiskImageFormat.t option
        [@ocaml.doc "<p>The disk image format.</p>"];
      import_manifest_url: String.t option
        [@ocaml.doc
          "<p>A presigned URL for the import manifest stored in Amazon S3. For information about creating a presigned URL for an Amazon S3 object, read the \"Query String Request Authentication Alternative\" section of the <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html\">Authenticating REST Requests</a> topic in the <i>Amazon Simple Storage Service Developer Guide</i>.</p> <p>For information about the import manifest referenced by this API action, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html\">VM Import Manifest</a>.</p>"];
      size: Long.t option
        [@ocaml.doc "<p>The size of the disk image, in GiB.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes a disk image.</p>"]
    let make ?checksum  ?format  ?import_manifest_url  ?size  () =
      { checksum; format; import_manifest_url; size }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.size
              (fun f -> Query.Pair ("Size", (Long.to_query f)));
           Util.option_map v.import_manifest_url
             (fun f -> Query.Pair ("ImportManifestUrl", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (DiskImageFormat.to_query f)));
           Util.option_map v.checksum
             (fun f -> Query.Pair ("Checksum", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.size (fun f -> ("size", (Long.to_json f)));
           Util.option_map v.import_manifest_url
             (fun f -> ("import_manifest_url", (String.to_json f)));
           Util.option_map v.format
             (fun f -> ("format", (DiskImageFormat.to_json f)));
           Util.option_map v.checksum
             (fun f -> ("checksum", (String.to_json f)))])
    let parse xml =
      Some
        {
          checksum =
            (Util.option_bind (Xml.member "checksum" xml) String.parse);
          format =
            (Util.option_bind (Xml.member "format" xml) DiskImageFormat.parse);
          import_manifest_url =
            (Util.option_bind (Xml.member "importManifestUrl" xml)
               String.parse);
          size = (Util.option_bind (Xml.member "size" xml) Long.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.checksum
                 (fun f -> Ezxmlm.make_tag "checksum" ([], (String.to_xml f)))])
             @
             [Util.option_map v.format
                (fun f ->
                   Ezxmlm.make_tag "format" ([], (DiskImageFormat.to_xml f)))])
            @
            [Util.option_map v.import_manifest_url
               (fun f ->
                  Ezxmlm.make_tag "importManifestUrl" ([], (String.to_xml f)))])
           @
           [Util.option_map v.size
              (fun f -> Ezxmlm.make_tag "size" ([], (Long.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a disk image.</p>"]
module DiskImageVolumeDescription =
  struct
    type t =
      {
      id: String.t option [@ocaml.doc "<p>The volume identifier.</p>"];
      size: Long.t option
        [@ocaml.doc "<p>The size of the volume, in GiB.</p>"]}[@@ocaml.doc
                                                                "<p>Describes a disk image volume.</p>"]
    let make ?id  ?size  () = { id; size }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.size
              (fun f -> Query.Pair ("Size", (Long.to_query f)));
           Util.option_map v.id
             (fun f -> Query.Pair ("Id", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.size (fun f -> ("size", (Long.to_json f)));
           Util.option_map v.id (fun f -> ("id", (String.to_json f)))])
    let parse xml =
      Some
        {
          id = (Util.option_bind (Xml.member "id" xml) String.parse);
          size = (Util.option_bind (Xml.member "size" xml) Long.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.id
               (fun f -> Ezxmlm.make_tag "id" ([], (String.to_xml f)))])
           @
           [Util.option_map v.size
              (fun f -> Ezxmlm.make_tag "size" ([], (Long.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a disk image volume.</p>"]
module RouteTableAssociationStateCode =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Failed, "failed");
      (Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module LaunchTemplateEbsBlockDevice =
  struct
    type t =
      {
      encrypted: Boolean.t option
        [@ocaml.doc "<p>Indicates whether the EBS volume is encrypted.</p>"];
      delete_on_termination: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the EBS volume is deleted on instance termination.</p>"];
      iops: Integer.t option
        [@ocaml.doc
          "<p>The number of I/O operations per second (IOPS) that the volume supports. </p>"];
      kms_key_id: String.t option
        [@ocaml.doc
          "<p>The ARN of the AWS Key Management Service (AWS KMS) CMK used for encryption.</p>"];
      snapshot_id: String.t option
        [@ocaml.doc "<p>The ID of the snapshot.</p>"];
      volume_size: Integer.t option
        [@ocaml.doc "<p>The size of the volume, in GiB.</p>"];
      volume_type: VolumeType.t option [@ocaml.doc "<p>The volume type.</p>"]}
    [@@ocaml.doc "<p>Describes a block device for an EBS volume.</p>"]
    let make ?encrypted  ?delete_on_termination  ?iops  ?kms_key_id 
      ?snapshot_id  ?volume_size  ?volume_type  () =
      {
        encrypted;
        delete_on_termination;
        iops;
        kms_key_id;
        snapshot_id;
        volume_size;
        volume_type
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> Query.Pair ("VolumeType", (VolumeType.to_query f)));
           Util.option_map v.volume_size
             (fun f -> Query.Pair ("VolumeSize", (Integer.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> ("volume_type", (VolumeType.to_json f)));
           Util.option_map v.volume_size
             (fun f -> ("volume_size", (Integer.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          iops = (Util.option_bind (Xml.member "iops" xml) Integer.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          volume_size =
            (Util.option_bind (Xml.member "volumeSize" xml) Integer.parse);
          volume_type =
            (Util.option_bind (Xml.member "volumeType" xml) VolumeType.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.encrypted
                    (fun f ->
                       Ezxmlm.make_tag "encrypted" ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.delete_on_termination
                   (fun f ->
                      Ezxmlm.make_tag "deleteOnTermination"
                        ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.iops
                  (fun f -> Ezxmlm.make_tag "iops" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.kms_key_id
                 (fun f -> Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.snapshot_id
                (fun f ->
                   Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.volume_size
               (fun f ->
                  Ezxmlm.make_tag "volumeSize" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.volume_type
              (fun f ->
                 Ezxmlm.make_tag "volumeType" ([], (VolumeType.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a block device for an EBS volume.</p>"]
module InstanceInterruptionBehavior =
  struct
    type t =
      | Hibernate 
      | Stop 
      | Terminate 
    let str_to_t =
      [("terminate", Terminate); ("stop", Stop); ("hibernate", Hibernate)]
    let t_to_str =
      [(Terminate, "terminate"); (Stop, "stop"); (Hibernate, "hibernate")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module SpotInstanceType =
  struct
    type t =
      | One_time 
      | Persistent 
    let str_to_t = [("persistent", Persistent); ("one-time", One_time)]
    let t_to_str = [(Persistent, "persistent"); (One_time, "one-time")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module GroupIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "groupId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module IpRange =
  struct
    type t =
      {
      cidr_ip: String.t
        [@ocaml.doc
          "<p>The IPv4 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv4 address, use the /32 prefix length.</p>"];
      description: String.t option
        [@ocaml.doc
          "<p>A description for the security group rule that references this IPv4 address range.</p> <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*</p>"]}
    [@@ocaml.doc "<p>Describes an IPv4 range.</p>"]
    let make ~cidr_ip  ?description  () = { cidr_ip; description }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some (Query.Pair ("CidrIp", (String.to_query v.cidr_ip)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Some ("cidr_ip", (String.to_json v.cidr_ip))])
    let parse xml =
      Some
        {
          cidr_ip =
            (Xml.required "cidrIp"
               (Util.option_bind (Xml.member "cidrIp" xml) String.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some (Ezxmlm.make_tag "cidrIp" ([], (String.to_xml v.cidr_ip)))])
           @
           [Util.option_map v.description
              (fun f -> Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an IPv4 range.</p>"]
module Ipv6Range =
  struct
    type t =
      {
      cidr_ipv6: String.t option
        [@ocaml.doc
          "<p>The IPv6 CIDR range. You can either specify a CIDR range or a source security group, not both. To specify a single IPv6 address, use the /128 prefix length.</p>"];
      description: String.t option
        [@ocaml.doc
          "<p>A description for the security group rule that references this IPv6 address range.</p> <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=&amp;;{}!$*</p>"]}
    [@@ocaml.doc "<p>[EC2-VPC only] Describes an IPv6 range.</p>"]
    let make ?cidr_ipv6  ?description  () = { cidr_ipv6; description }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.cidr_ipv6
             (fun f -> Query.Pair ("CidrIpv6", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.cidr_ipv6
             (fun f -> ("cidr_ipv6", (String.to_json f)))])
    let parse xml =
      Some
        {
          cidr_ipv6 =
            (Util.option_bind (Xml.member "cidrIpv6" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.cidr_ipv6
               (fun f -> Ezxmlm.make_tag "cidrIpv6" ([], (String.to_xml f)))])
           @
           [Util.option_map v.description
              (fun f -> Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>[EC2-VPC only] Describes an IPv6 range.</p>"]
module PrefixListId =
  struct
    type t =
      {
      description: String.t option
        [@ocaml.doc
          "<p>A description for the security group rule that references this prefix list ID.</p> <p>Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*</p>"];
      prefix_list_id: String.t option
        [@ocaml.doc "<p>The ID of the prefix.</p>"]}[@@ocaml.doc
                                                      "<p>Describes a prefix list ID.</p>"]
    let make ?description  ?prefix_list_id  () =
      { description; prefix_list_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.prefix_list_id
              (fun f -> Query.Pair ("PrefixListId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.prefix_list_id
              (fun f -> ("prefix_list_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          prefix_list_id =
            (Util.option_bind (Xml.member "prefixListId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.description
               (fun f ->
                  Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
           @
           [Util.option_map v.prefix_list_id
              (fun f ->
                 Ezxmlm.make_tag "prefixListId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a prefix list ID.</p>"]
module FleetLaunchTemplateOverrides =
  struct
    type t =
      {
      instance_type: InstanceType.t option
        [@ocaml.doc "<p>The instance type.</p>"];
      max_price: String.t option
        [@ocaml.doc
          "<p>The maximum price per unit hour that you are willing to pay for a Spot Instance.</p>"];
      subnet_id: String.t option
        [@ocaml.doc
          "<p>The ID of the subnet in which to launch the instances.</p>"];
      availability_zone: String.t option
        [@ocaml.doc
          "<p>The Availability Zone in which to launch the instances.</p>"];
      weighted_capacity: Double.t option
        [@ocaml.doc
          "<p>The number of units provided by the specified instance type.</p>"];
      priority: Double.t option
        [@ocaml.doc
          "<p>The priority for the launch template override. If <b>AllocationStrategy</b> is set to <code>prioritized</code>, EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. Valid values are whole numbers starting at <code>0</code>. The lower the number, the higher the priority. If no number is set, the override has the lowest priority.</p>"];
      placement: PlacementResponse.t option
        [@ocaml.doc
          "<p>The location where the instance launched, if applicable.</p>"]}
    [@@ocaml.doc "<p>Describes overrides for a launch template.</p>"]
    let make ?instance_type  ?max_price  ?subnet_id  ?availability_zone 
      ?weighted_capacity  ?priority  ?placement  () =
      {
        instance_type;
        max_price;
        subnet_id;
        availability_zone;
        weighted_capacity;
        priority;
        placement
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.placement
              (fun f ->
                 Query.Pair ("Placement", (PlacementResponse.to_query f)));
           Util.option_map v.priority
             (fun f -> Query.Pair ("Priority", (Double.to_query f)));
           Util.option_map v.weighted_capacity
             (fun f -> Query.Pair ("WeightedCapacity", (Double.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.max_price
             (fun f -> Query.Pair ("MaxPrice", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.placement
              (fun f -> ("placement", (PlacementResponse.to_json f)));
           Util.option_map v.priority
             (fun f -> ("priority", (Double.to_json f)));
           Util.option_map v.weighted_capacity
             (fun f -> ("weighted_capacity", (Double.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.max_price
             (fun f -> ("max_price", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)))])
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          max_price =
            (Util.option_bind (Xml.member "maxPrice" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          weighted_capacity =
            (Util.option_bind (Xml.member "weightedCapacity" xml)
               Double.parse);
          priority =
            (Util.option_bind (Xml.member "priority" xml) Double.parse);
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               PlacementResponse.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.instance_type
                    (fun f ->
                       Ezxmlm.make_tag "instanceType"
                         ([], (InstanceType.to_xml f)))])
                @
                [Util.option_map v.max_price
                   (fun f ->
                      Ezxmlm.make_tag "maxPrice" ([], (String.to_xml f)))])
               @
               [Util.option_map v.subnet_id
                  (fun f ->
                     Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.availability_zone
                 (fun f ->
                    Ezxmlm.make_tag "availabilityZone"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.weighted_capacity
                (fun f ->
                   Ezxmlm.make_tag "weightedCapacity" ([], (Double.to_xml f)))])
            @
            [Util.option_map v.priority
               (fun f -> Ezxmlm.make_tag "priority" ([], (Double.to_xml f)))])
           @
           [Util.option_map v.placement
              (fun f ->
                 Ezxmlm.make_tag "placement"
                   ([], (PlacementResponse.to_xml f)))])
  end[@@ocaml.doc "<p>Describes overrides for a launch template.</p>"]
module FleetLaunchTemplateSpecification =
  struct
    type t =
      {
      launch_template_id: String.t option
        [@ocaml.doc
          "<p>The ID of the launch template. You must specify either a template ID or a template name.</p>"];
      launch_template_name: String.t option
        [@ocaml.doc
          "<p>The name of the launch template. You must specify either a template name or a template ID.</p>"];
      version: String.t option
        [@ocaml.doc
          "<p>The version number of the launch template. You must specify a version number.</p>"]}
    [@@ocaml.doc "<p>Describes a launch template.</p>"]
    let make ?launch_template_id  ?launch_template_name  ?version  () =
      { launch_template_id; launch_template_name; version }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> Query.Pair ("Version", (String.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> ("version", (String.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "launchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "launchTemplateName" xml)
               String.parse);
          version =
            (Util.option_bind (Xml.member "version" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.launch_template_id
                (fun f ->
                   Ezxmlm.make_tag "launchTemplateId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.launch_template_name
               (fun f ->
                  Ezxmlm.make_tag "launchTemplateName"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.version
              (fun f -> Ezxmlm.make_tag "version" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a launch template.</p>"]
module BlockDeviceMappingList =
  struct
    type t = BlockDeviceMapping.t list
    let make elems () = elems
    let to_query v = Query.to_query_list BlockDeviceMapping.to_query v
    let to_headers v =
      Headers.to_headers_list BlockDeviceMapping.to_headers v
    let to_json v = `List (List.map BlockDeviceMapping.to_json v)
    let parse xml =
      Util.option_all
        (List.map BlockDeviceMapping.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (BlockDeviceMapping.to_xml x))) v
  end
module IamInstanceProfileSpecification =
  struct
    type t =
      {
      arn: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the instance profile.</p>"];
      name: String.t option
        [@ocaml.doc "<p>The name of the instance profile.</p>"]}[@@ocaml.doc
                                                                  "<p>Describes an IAM instance profile.</p>"]
    let make ?arn  ?name  () = { arn; name }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "arn" xml) String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.arn
               (fun f -> Ezxmlm.make_tag "arn" ([], (String.to_xml f)))])
           @
           [Util.option_map v.name
              (fun f -> Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an IAM instance profile.</p>"]
module InstanceNetworkInterfaceSpecificationList =
  struct
    type t = InstanceNetworkInterfaceSpecification.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list InstanceNetworkInterfaceSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list
        InstanceNetworkInterfaceSpecification.to_headers v
    let to_json v =
      `List (List.map InstanceNetworkInterfaceSpecification.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceNetworkInterfaceSpecification.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InstanceNetworkInterfaceSpecification.to_xml x))) v
  end
module SpotFleetMonitoring =
  struct
    type t =
      {
      enabled: Boolean.t option
        [@ocaml.doc
          "<p>Enables monitoring for the instance.</p> <p>Default: <code>false</code> </p>"]}
    [@@ocaml.doc "<p>Describes whether monitoring is enabled.</p>"]
    let make ?enabled  () = { enabled }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "enabled" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.enabled
              (fun f -> Ezxmlm.make_tag "enabled" ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc "<p>Describes whether monitoring is enabled.</p>"]
module SpotFleetTagSpecificationList =
  struct
    type t = SpotFleetTagSpecification.t list
    let make elems () = elems
    let to_query v = Query.to_query_list SpotFleetTagSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list SpotFleetTagSpecification.to_headers v
    let to_json v = `List (List.map SpotFleetTagSpecification.to_json v)
    let parse xml =
      Util.option_all
        (List.map SpotFleetTagSpecification.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (SpotFleetTagSpecification.to_xml x))) v
  end
module SpotPlacement =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc
          "<p>The Availability Zone.</p> <p>[Spot Fleet only] To specify multiple Availability Zones, separate them using commas; for example, \"us-west-2a, us-west-2b\".</p>"];
      group_name: String.t option
        [@ocaml.doc "<p>The name of the placement group.</p>"];
      tenancy: Tenancy.t option
        [@ocaml.doc
          "<p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware. The <code>host</code> tenancy is not supported for Spot Instances.</p>"]}
    [@@ocaml.doc "<p>Describes Spot Instance placement.</p>"]
    let make ?availability_zone  ?group_name  ?tenancy  () =
      { availability_zone; group_name; tenancy }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.tenancy
              (fun f -> Query.Pair ("Tenancy", (Tenancy.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.tenancy
              (fun f -> ("tenancy", (Tenancy.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          tenancy =
            (Util.option_bind (Xml.member "tenancy" xml) Tenancy.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.availability_zone
                (fun f ->
                   Ezxmlm.make_tag "availabilityZone" ([], (String.to_xml f)))])
            @
            [Util.option_map v.group_name
               (fun f -> Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.tenancy
              (fun f -> Ezxmlm.make_tag "tenancy" ([], (Tenancy.to_xml f)))])
  end[@@ocaml.doc "<p>Describes Spot Instance placement.</p>"]
module LaunchTemplateOverridesList =
  struct
    type t = LaunchTemplateOverrides.t list
    let make elems () = elems
    let to_query v = Query.to_query_list LaunchTemplateOverrides.to_query v
    let to_headers v =
      Headers.to_headers_list LaunchTemplateOverrides.to_headers v
    let to_json v = `List (List.map LaunchTemplateOverrides.to_json v)
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateOverrides.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (LaunchTemplateOverrides.to_xml x)))
        v
  end
module ClassicLoadBalancers =
  struct
    type t = ClassicLoadBalancer.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ClassicLoadBalancer.to_query v
    let to_headers v =
      Headers.to_headers_list ClassicLoadBalancer.to_headers v
    let to_json v = `List (List.map ClassicLoadBalancer.to_json v)
    let parse xml =
      Util.option_all
        (List.map ClassicLoadBalancer.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ClassicLoadBalancer.to_xml x))) v
  end
module TargetGroups =
  struct
    type t = TargetGroup.t list
    let make elems () = elems
    let to_query v = Query.to_query_list TargetGroup.to_query v
    let to_headers v = Headers.to_headers_list TargetGroup.to_headers v
    let to_json v = `List (List.map TargetGroup.to_json v)
    let parse xml =
      Util.option_all (List.map TargetGroup.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (TargetGroup.to_xml x))) v
  end
module VolumeStatusName =
  struct
    type t =
      | Io_enabled 
      | Io_performance 
    let str_to_t =
      [("io-performance", Io_performance); ("io-enabled", Io_enabled)]
    let t_to_str =
      [(Io_performance, "io-performance"); (Io_enabled, "io-enabled")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module CapacityReservationPreference =
  struct
    type t =
      | Open 
      | None 
    let str_to_t = [("none", None); ("open", Open)]
    let t_to_str = [(None, "none"); (Open, "open")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module CapacityReservationTargetResponse =
  struct
    type t =
      {
      capacity_reservation_id: String.t option
        [@ocaml.doc "<p>The ID of the Capacity Reservation.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes a target Capacity Reservation.</p>"]
    let make ?capacity_reservation_id  () = { capacity_reservation_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_id
              (fun f ->
                 Query.Pair ("CapacityReservationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_id
              (fun f -> ("capacity_reservation_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          capacity_reservation_id =
            (Util.option_bind (Xml.member "capacityReservationId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.capacity_reservation_id
              (fun f ->
                 Ezxmlm.make_tag "capacityReservationId"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a target Capacity Reservation.</p>"]
module ElasticGpuAssociation =
  struct
    type t =
      {
      elastic_gpu_id: String.t option
        [@ocaml.doc "<p>The ID of the Elastic Graphics accelerator.</p>"];
      elastic_gpu_association_id: String.t option
        [@ocaml.doc "<p>The ID of the association.</p>"];
      elastic_gpu_association_state: String.t option
        [@ocaml.doc
          "<p>The state of the association between the instance and the Elastic Graphics accelerator.</p>"];
      elastic_gpu_association_time: String.t option
        [@ocaml.doc
          "<p>The time the Elastic Graphics accelerator was associated with the instance.</p>"]}
    [@@ocaml.doc
      "<p>Describes the association between an instance and an Elastic Graphics accelerator.</p>"]
    let make ?elastic_gpu_id  ?elastic_gpu_association_id 
      ?elastic_gpu_association_state  ?elastic_gpu_association_time  () =
      {
        elastic_gpu_id;
        elastic_gpu_association_id;
        elastic_gpu_association_state;
        elastic_gpu_association_time
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.elastic_gpu_association_time
              (fun f ->
                 Query.Pair
                   ("ElasticGpuAssociationTime", (String.to_query f)));
           Util.option_map v.elastic_gpu_association_state
             (fun f ->
                Query.Pair
                  ("ElasticGpuAssociationState", (String.to_query f)));
           Util.option_map v.elastic_gpu_association_id
             (fun f ->
                Query.Pair ("ElasticGpuAssociationId", (String.to_query f)));
           Util.option_map v.elastic_gpu_id
             (fun f -> Query.Pair ("ElasticGpuId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.elastic_gpu_association_time
              (fun f -> ("elastic_gpu_association_time", (String.to_json f)));
           Util.option_map v.elastic_gpu_association_state
             (fun f -> ("elastic_gpu_association_state", (String.to_json f)));
           Util.option_map v.elastic_gpu_association_id
             (fun f -> ("elastic_gpu_association_id", (String.to_json f)));
           Util.option_map v.elastic_gpu_id
             (fun f -> ("elastic_gpu_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          elastic_gpu_id =
            (Util.option_bind (Xml.member "elasticGpuId" xml) String.parse);
          elastic_gpu_association_id =
            (Util.option_bind (Xml.member "elasticGpuAssociationId" xml)
               String.parse);
          elastic_gpu_association_state =
            (Util.option_bind (Xml.member "elasticGpuAssociationState" xml)
               String.parse);
          elastic_gpu_association_time =
            (Util.option_bind (Xml.member "elasticGpuAssociationTime" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.elastic_gpu_id
                 (fun f ->
                    Ezxmlm.make_tag "elasticGpuId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.elastic_gpu_association_id
                (fun f ->
                   Ezxmlm.make_tag "elasticGpuAssociationId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.elastic_gpu_association_state
               (fun f ->
                  Ezxmlm.make_tag "elasticGpuAssociationState"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.elastic_gpu_association_time
              (fun f ->
                 Ezxmlm.make_tag "elasticGpuAssociationTime"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the association between an instance and an Elastic Graphics accelerator.</p>"]
module ElasticInferenceAcceleratorAssociation =
  struct
    type t =
      {
      elastic_inference_accelerator_arn: String.t option
        [@ocaml.doc
          "<p> The Amazon Resource Name (ARN) of the elastic inference accelerator. </p>"];
      elastic_inference_accelerator_association_id: String.t option
        [@ocaml.doc "<p> The ID of the association. </p>"];
      elastic_inference_accelerator_association_state: String.t option
        [@ocaml.doc
          "<p> The state of the elastic inference accelerator. </p>"];
      elastic_inference_accelerator_association_time: DateTime.t option
        [@ocaml.doc
          "<p> The time at which the elastic inference accelerator is associated with an instance. </p>"]}
    [@@ocaml.doc
      "<p> Describes the association between an instance and an elastic inference accelerator. </p>"]
    let make ?elastic_inference_accelerator_arn 
      ?elastic_inference_accelerator_association_id 
      ?elastic_inference_accelerator_association_state 
      ?elastic_inference_accelerator_association_time  () =
      {
        elastic_inference_accelerator_arn;
        elastic_inference_accelerator_association_id;
        elastic_inference_accelerator_association_state;
        elastic_inference_accelerator_association_time
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.elastic_inference_accelerator_association_time
              (fun f ->
                 Query.Pair
                   ("ElasticInferenceAcceleratorAssociationTime",
                     (DateTime.to_query f)));
           Util.option_map v.elastic_inference_accelerator_association_state
             (fun f ->
                Query.Pair
                  ("ElasticInferenceAcceleratorAssociationState",
                    (String.to_query f)));
           Util.option_map v.elastic_inference_accelerator_association_id
             (fun f ->
                Query.Pair
                  ("ElasticInferenceAcceleratorAssociationId",
                    (String.to_query f)));
           Util.option_map v.elastic_inference_accelerator_arn
             (fun f ->
                Query.Pair
                  ("ElasticInferenceAcceleratorArn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.elastic_inference_accelerator_association_time
              (fun f ->
                 ("elastic_inference_accelerator_association_time",
                   (DateTime.to_json f)));
           Util.option_map v.elastic_inference_accelerator_association_state
             (fun f ->
                ("elastic_inference_accelerator_association_state",
                  (String.to_json f)));
           Util.option_map v.elastic_inference_accelerator_association_id
             (fun f ->
                ("elastic_inference_accelerator_association_id",
                  (String.to_json f)));
           Util.option_map v.elastic_inference_accelerator_arn
             (fun f ->
                ("elastic_inference_accelerator_arn", (String.to_json f)))])
    let parse xml =
      Some
        {
          elastic_inference_accelerator_arn =
            (Util.option_bind
               (Xml.member "elasticInferenceAcceleratorArn" xml) String.parse);
          elastic_inference_accelerator_association_id =
            (Util.option_bind
               (Xml.member "elasticInferenceAcceleratorAssociationId" xml)
               String.parse);
          elastic_inference_accelerator_association_state =
            (Util.option_bind
               (Xml.member "elasticInferenceAcceleratorAssociationState" xml)
               String.parse);
          elastic_inference_accelerator_association_time =
            (Util.option_bind
               (Xml.member "elasticInferenceAcceleratorAssociationTime" xml)
               DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.elastic_inference_accelerator_arn
                 (fun f ->
                    Ezxmlm.make_tag "elasticInferenceAcceleratorArn"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.elastic_inference_accelerator_association_id
                (fun f ->
                   Ezxmlm.make_tag "elasticInferenceAcceleratorAssociationId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map
               v.elastic_inference_accelerator_association_state
               (fun f ->
                  Ezxmlm.make_tag
                    "elasticInferenceAcceleratorAssociationState"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.elastic_inference_accelerator_association_time
              (fun f ->
                 Ezxmlm.make_tag "elasticInferenceAcceleratorAssociationTime"
                   ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc
       "<p> Describes the association between an instance and an elastic inference accelerator. </p>"]
module InstanceBlockDeviceMapping =
  struct
    type t =
      {
      device_name: String.t option
        [@ocaml.doc
          "<p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>"];
      ebs: EbsInstanceBlockDevice.t option
        [@ocaml.doc
          "<p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>"]}
    [@@ocaml.doc "<p>Describes a block device mapping.</p>"]
    let make ?device_name  ?ebs  () = { device_name; ebs }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ebs
              (fun f ->
                 Query.Pair ("Ebs", (EbsInstanceBlockDevice.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ebs
              (fun f -> ("ebs", (EbsInstanceBlockDevice.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "ebs" xml)
               EbsInstanceBlockDevice.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.device_name
               (fun f -> Ezxmlm.make_tag "deviceName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.ebs
              (fun f ->
                 Ezxmlm.make_tag "ebs"
                   ([], (EbsInstanceBlockDevice.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a block device mapping.</p>"]
module HttpTokensState =
  struct
    type t =
      | Optional 
      | Required 
    let str_to_t = [("required", Required); ("optional", Optional)]
    let t_to_str = [(Required, "required"); (Optional, "optional")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module InstanceMetadataEndpointState =
  struct
    type t =
      | Disabled 
      | Enabled 
    let str_to_t = [("enabled", Enabled); ("disabled", Disabled)]
    let t_to_str = [(Enabled, "enabled"); (Disabled, "disabled")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module InstanceMetadataOptionsState =
  struct
    type t =
      | Pending 
      | Applied 
    let str_to_t = [("applied", Applied); ("pending", Pending)]
    let t_to_str = [(Applied, "applied"); (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module InstanceNetworkInterface =
  struct
    type t =
      {
      association: InstanceNetworkInterfaceAssociation.t option
        [@ocaml.doc
          "<p>The association information for an Elastic IPv4 associated with the network interface.</p>"];
      attachment: InstanceNetworkInterfaceAttachment.t option
        [@ocaml.doc "<p>The network interface attachment.</p>"];
      description: String.t option [@ocaml.doc "<p>The description.</p>"];
      groups: GroupIdentifierList.t
        [@ocaml.doc "<p>One or more security groups.</p>"];
      ipv6_addresses: InstanceIpv6AddressList.t
        [@ocaml.doc
          "<p>One or more IPv6 addresses associated with the network interface.</p>"];
      mac_address: String.t option [@ocaml.doc "<p>The MAC address.</p>"];
      network_interface_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface.</p>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account that created the network interface.</p>"];
      private_dns_name: String.t option
        [@ocaml.doc "<p>The private DNS name.</p>"];
      private_ip_address: String.t option
        [@ocaml.doc
          "<p>The IPv4 address of the network interface within the subnet.</p>"];
      private_ip_addresses: InstancePrivateIpAddressList.t
        [@ocaml.doc
          "<p>One or more private IPv4 addresses associated with the network interface.</p>"];
      source_dest_check: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether to validate network traffic to or from this network interface.</p>"];
      status: NetworkInterfaceStatus.t option
        [@ocaml.doc "<p>The status of the network interface.</p>"];
      subnet_id: String.t option [@ocaml.doc "<p>The ID of the subnet.</p>"];
      vpc_id: String.t option [@ocaml.doc "<p>The ID of the VPC.</p>"];
      interface_type: String.t option
        [@ocaml.doc
          "<p>Describes the type of network interface.</p> <p>Valid values: <code>interface</code> | <code>efa</code> </p>"]}
    [@@ocaml.doc "<p>Describes a network interface.</p>"]
    let make ?association  ?attachment  ?description  ?(groups= []) 
      ?(ipv6_addresses= [])  ?mac_address  ?network_interface_id  ?owner_id 
      ?private_dns_name  ?private_ip_address  ?(private_ip_addresses= []) 
      ?source_dest_check  ?status  ?subnet_id  ?vpc_id  ?interface_type  () =
      {
        association;
        attachment;
        description;
        groups;
        ipv6_addresses;
        mac_address;
        network_interface_id;
        owner_id;
        private_dns_name;
        private_ip_address;
        private_ip_addresses;
        source_dest_check;
        status;
        subnet_id;
        vpc_id;
        interface_type
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.interface_type
              (fun f -> Query.Pair ("InterfaceType", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (NetworkInterfaceStatus.to_query f)));
           Util.option_map v.source_dest_check
             (fun f -> Query.Pair ("SourceDestCheck", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddressesSet",
                  (InstancePrivateIpAddressList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.mac_address
             (fun f -> Query.Pair ("MacAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6AddressesSet",
                  (InstanceIpv6AddressList.to_query v.ipv6_addresses)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.attachment
             (fun f ->
                Query.Pair
                  ("Attachment",
                    (InstanceNetworkInterfaceAttachment.to_query f)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association",
                    (InstanceNetworkInterfaceAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.interface_type
              (fun f -> ("interface_type", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (NetworkInterfaceStatus.to_json f)));
           Util.option_map v.source_dest_check
             (fun f -> ("source_dest_check", (Boolean.to_json f)));
           Some
             ("private_ip_addresses",
               (InstancePrivateIpAddressList.to_json v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.mac_address
             (fun f -> ("mac_address", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (InstanceIpv6AddressList.to_json v.ipv6_addresses));
           Some ("groups", (GroupIdentifierList.to_json v.groups));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.attachment
             (fun f ->
                ("attachment",
                  (InstanceNetworkInterfaceAttachment.to_json f)));
           Util.option_map v.association
             (fun f ->
                ("association",
                  (InstanceNetworkInterfaceAssociation.to_json f)))])
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               InstanceNetworkInterfaceAssociation.parse);
          attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               InstanceNetworkInterfaceAttachment.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6AddressesSet" xml)
                  InstanceIpv6AddressList.parse));
          mac_address =
            (Util.option_bind (Xml.member "macAddress" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddressesSet" xml)
                  InstancePrivateIpAddressList.parse));
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               Boolean.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               NetworkInterfaceStatus.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          interface_type =
            (Util.option_bind (Xml.member "interfaceType" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((([] @
                          [Util.option_map v.association
                             (fun f ->
                                Ezxmlm.make_tag "association"
                                  ([],
                                    (InstanceNetworkInterfaceAssociation.to_xml
                                       f)))])
                         @
                         [Util.option_map v.attachment
                            (fun f ->
                               Ezxmlm.make_tag "attachment"
                                 ([],
                                   (InstanceNetworkInterfaceAttachment.to_xml
                                      f)))])
                        @
                        [Util.option_map v.description
                           (fun f ->
                              Ezxmlm.make_tag "description"
                                ([], (String.to_xml f)))])
                       @
                       (List.map
                          (fun x ->
                             Some
                               (Ezxmlm.make_tag "groupSet"
                                  ([], (GroupIdentifierList.to_xml [x]))))
                          v.groups))
                      @
                      (List.map
                         (fun x ->
                            Some
                              (Ezxmlm.make_tag "ipv6AddressesSet"
                                 ([], (InstanceIpv6AddressList.to_xml [x]))))
                         v.ipv6_addresses))
                     @
                     [Util.option_map v.mac_address
                        (fun f ->
                           Ezxmlm.make_tag "macAddress"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.network_interface_id
                       (fun f ->
                          Ezxmlm.make_tag "networkInterfaceId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.owner_id
                      (fun f ->
                         Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.private_dns_name
                     (fun f ->
                        Ezxmlm.make_tag "privateDnsName"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.private_ip_address
                    (fun f ->
                       Ezxmlm.make_tag "privateIpAddress"
                         ([], (String.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "privateIpAddressesSet"
                           ([], (InstancePrivateIpAddressList.to_xml [x]))))
                   v.private_ip_addresses))
               @
               [Util.option_map v.source_dest_check
                  (fun f ->
                     Ezxmlm.make_tag "sourceDestCheck"
                       ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.status
                 (fun f ->
                    Ezxmlm.make_tag "status"
                      ([], (NetworkInterfaceStatus.to_xml f)))])
             @
             [Util.option_map v.subnet_id
                (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.vpc_id
               (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.interface_type
              (fun f ->
                 Ezxmlm.make_tag "interfaceType" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a network interface.</p>"]
module InstanceStateName =
  struct
    type t =
      | Pending 
      | Running 
      | Shutting_down 
      | Terminated 
      | Stopping 
      | Stopped 
    let str_to_t =
      [("stopped", Stopped);
      ("stopping", Stopping);
      ("terminated", Terminated);
      ("shutting-down", Shutting_down);
      ("running", Running);
      ("pending", Pending)]
    let t_to_str =
      [(Stopped, "stopped");
      (Stopping, "stopping");
      (Terminated, "terminated");
      (Shutting_down, "shutting-down");
      (Running, "running");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module LicenseConfiguration =
  struct
    type t =
      {
      license_configuration_arn: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the license configuration.</p>"]}
    [@@ocaml.doc "<p>Describes a license configuration.</p>"]
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "licenseConfigurationArn" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Ezxmlm.make_tag "licenseConfigurationArn"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a license configuration.</p>"]
module MonitoringState =
  struct
    type t =
      | Disabled 
      | Disabling 
      | Enabled 
      | Pending 
    let str_to_t =
      [("pending", Pending);
      ("enabled", Enabled);
      ("disabling", Disabling);
      ("disabled", Disabled)]
    let t_to_str =
      [(Pending, "pending");
      (Enabled, "enabled");
      (Disabling, "disabling");
      (Disabled, "disabled")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ProductCode =
  struct
    type t =
      {
      product_code_id: String.t option
        [@ocaml.doc "<p>The product code.</p>"];
      product_code_type: ProductCodeValues.t option
        [@ocaml.doc "<p>The type of product code.</p>"]}[@@ocaml.doc
                                                          "<p>Describes a product code.</p>"]
    let make ?product_code_id  ?product_code_type  () =
      { product_code_id; product_code_type }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.product_code_type
              (fun f -> Query.Pair ("Type", (ProductCodeValues.to_query f)));
           Util.option_map v.product_code_id
             (fun f -> Query.Pair ("ProductCode", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.product_code_type
              (fun f -> ("product_code_type", (ProductCodeValues.to_json f)));
           Util.option_map v.product_code_id
             (fun f -> ("product_code_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          product_code_id =
            (Util.option_bind (Xml.member "productCode" xml) String.parse);
          product_code_type =
            (Util.option_bind (Xml.member "type" xml) ProductCodeValues.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.product_code_id
               (fun f ->
                  Ezxmlm.make_tag "productCode" ([], (String.to_xml f)))])
           @
           [Util.option_map v.product_code_type
              (fun f ->
                 Ezxmlm.make_tag "type" ([], (ProductCodeValues.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a product code.</p>"]
module VpcCidrBlockStateCode =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
      | Failing 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("failing", Failing);
      ("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Failed, "failed");
      (Failing, "failing");
      (Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module SubnetCidrBlockStateCode =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
      | Failing 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("failing", Failing);
      ("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Failed, "failed");
      (Failing, "failing");
      (Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module DhcpConfigurationValueList =
  struct
    type t = AttributeValue.t list
    let make elems () = elems
    let to_query v = Query.to_query_list AttributeValue.to_query v
    let to_headers v = Headers.to_headers_list AttributeValue.to_headers v
    let to_json v = `List (List.map AttributeValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map AttributeValue.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (AttributeValue.to_xml x))) v
  end
module ReservedInstancesConfiguration =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc
          "<p>The Availability Zone for the modified Reserved Instances.</p>"];
      instance_count: Integer.t option
        [@ocaml.doc
          "<p>The number of modified Reserved Instances.</p> <note> <p>This is a required field for a request.</p> </note>"];
      instance_type: InstanceType.t option
        [@ocaml.doc
          "<p>The instance type for the modified Reserved Instances.</p>"];
      platform: String.t option
        [@ocaml.doc
          "<p>The network platform of the modified Reserved Instances, which is either EC2-Classic or EC2-VPC.</p>"];
      scope: Scope.t option
        [@ocaml.doc
          "<p>Whether the Reserved Instance is applied to instances in a Region or instances in a specific Availability Zone.</p>"]}
    [@@ocaml.doc
      "<p>Describes the configuration settings for the modified Reserved Instances.</p>"]
    let make ?availability_zone  ?instance_count  ?instance_type  ?platform 
      ?scope  () =
      { availability_zone; instance_count; instance_type; platform; scope }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.scope
              (fun f -> Query.Pair ("Scope", (Scope.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.scope (fun f -> ("scope", (Scope.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          scope = (Util.option_bind (Xml.member "scope" xml) Scope.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.availability_zone
                  (fun f ->
                     Ezxmlm.make_tag "availabilityZone"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.instance_count
                 (fun f ->
                    Ezxmlm.make_tag "instanceCount" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.instance_type
                (fun f ->
                   Ezxmlm.make_tag "instanceType"
                     ([], (InstanceType.to_xml f)))])
            @
            [Util.option_map v.platform
               (fun f -> Ezxmlm.make_tag "platform" ([], (String.to_xml f)))])
           @
           [Util.option_map v.scope
              (fun f -> Ezxmlm.make_tag "scope" ([], (Scope.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the configuration settings for the modified Reserved Instances.</p>"]
module TrafficDirection =
  struct
    type t =
      | Ingress 
      | Egress 
    let str_to_t = [("egress", Egress); ("ingress", Ingress)]
    let t_to_str = [(Egress, "egress"); (Ingress, "ingress")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module TrafficMirrorPortRange =
  struct
    type t =
      {
      from_port: Integer.t option
        [@ocaml.doc
          "<p>The start of the Traffic Mirror port range. This applies to the TCP and UDP protocols.</p>"];
      to_port: Integer.t option
        [@ocaml.doc
          "<p>The end of the Traffic Mirror port range. This applies to the TCP and UDP protocols.</p>"]}
    [@@ocaml.doc "<p>Describes the Traffic Mirror port range.</p>"]
    let make ?from_port  ?to_port  () = { from_port; to_port }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.to_port
              (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.to_port
              (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          from_port =
            (Util.option_bind (Xml.member "fromPort" xml) Integer.parse);
          to_port =
            (Util.option_bind (Xml.member "toPort" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.from_port
               (fun f -> Ezxmlm.make_tag "fromPort" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.to_port
              (fun f -> Ezxmlm.make_tag "toPort" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the Traffic Mirror port range.</p>"]
module TrafficMirrorRuleAction =
  struct
    type t =
      | Accept 
      | Reject 
    let str_to_t = [("reject", Reject); ("accept", Accept)]
    let t_to_str = [(Reject, "reject"); (Accept, "accept")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ListingState =
  struct
    type t =
      | Available 
      | Sold 
      | Cancelled 
      | Pending 
    let str_to_t =
      [("pending", Pending);
      ("cancelled", Cancelled);
      ("sold", Sold);
      ("available", Available)]
    let t_to_str =
      [(Pending, "pending");
      (Cancelled, "cancelled");
      (Sold, "sold");
      (Available, "available")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module CurrencyCodeValues =
  struct
    type t =
      | USD 
    let str_to_t = [("USD", USD)]
    let t_to_str = [(USD, "USD")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module EventCode =
  struct
    type t =
      | Instance_reboot 
      | System_reboot 
      | System_maintenance 
      | Instance_retirement 
      | Instance_stop 
    let str_to_t =
      [("instance-stop", Instance_stop);
      ("instance-retirement", Instance_retirement);
      ("system-maintenance", System_maintenance);
      ("system-reboot", System_reboot);
      ("instance-reboot", Instance_reboot)]
    let t_to_str =
      [(Instance_stop, "instance-stop");
      (Instance_retirement, "instance-retirement");
      (System_maintenance, "system-maintenance");
      (System_reboot, "system-reboot");
      (Instance_reboot, "instance-reboot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module InstanceStatusDetails =
  struct
    type t =
      {
      impaired_since: DateTime.t option
        [@ocaml.doc
          "<p>The time when a status check failed. For an instance that was launched and impaired, this is the time when the instance was launched.</p>"];
      name: StatusName.t option
        [@ocaml.doc "<p>The type of instance status.</p>"];
      status: StatusType.t option [@ocaml.doc "<p>The status.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes the instance status.</p>"]
    let make ?impaired_since  ?name  ?status  () =
      { impaired_since; name; status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (StatusType.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (StatusName.to_query f)));
           Util.option_map v.impaired_since
             (fun f -> Query.Pair ("ImpairedSince", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (StatusType.to_json f)));
           Util.option_map v.name (fun f -> ("name", (StatusName.to_json f)));
           Util.option_map v.impaired_since
             (fun f -> ("impaired_since", (DateTime.to_json f)))])
    let parse xml =
      Some
        {
          impaired_since =
            (Util.option_bind (Xml.member "impairedSince" xml) DateTime.parse);
          name = (Util.option_bind (Xml.member "name" xml) StatusName.parse);
          status =
            (Util.option_bind (Xml.member "status" xml) StatusType.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.impaired_since
                (fun f ->
                   Ezxmlm.make_tag "impairedSince" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.name
               (fun f -> Ezxmlm.make_tag "name" ([], (StatusName.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f -> Ezxmlm.make_tag "status" ([], (StatusType.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the instance status.</p>"]
module InstanceCapacity =
  struct
    type t =
      {
      available_capacity: Integer.t option
        [@ocaml.doc
          "<p>The number of instances that can be launched onto the Dedicated Host based on the host's available capacity.</p>"];
      instance_type: String.t option
        [@ocaml.doc
          "<p>The instance type supported by the Dedicated Host.</p>"];
      total_capacity: Integer.t option
        [@ocaml.doc
          "<p>The total number of instances that can be launched onto the Dedicated Host if there are no instances running on it.</p>"]}
    [@@ocaml.doc
      "<p>Information about the number of instances that can be launched onto the Dedicated Host.</p>"]
    let make ?available_capacity  ?instance_type  ?total_capacity  () =
      { available_capacity; instance_type; total_capacity }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_capacity
              (fun f -> Query.Pair ("TotalCapacity", (Integer.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.available_capacity
             (fun f -> Query.Pair ("AvailableCapacity", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_capacity
              (fun f -> ("total_capacity", (Integer.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.available_capacity
             (fun f -> ("available_capacity", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          available_capacity =
            (Util.option_bind (Xml.member "availableCapacity" xml)
               Integer.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          total_capacity =
            (Util.option_bind (Xml.member "totalCapacity" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.available_capacity
                (fun f ->
                   Ezxmlm.make_tag "availableCapacity"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.instance_type
               (fun f ->
                  Ezxmlm.make_tag "instanceType" ([], (String.to_xml f)))])
           @
           [Util.option_map v.total_capacity
              (fun f ->
                 Ezxmlm.make_tag "totalCapacity" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc
       "<p>Information about the number of instances that can be launched onto the Dedicated Host.</p>"]
module DisableFastSnapshotRestoreStateError =
  struct
    type t =
      {
      code: String.t option [@ocaml.doc "<p>The error code.</p>"];
      message: String.t option [@ocaml.doc "<p>The error message.</p>"]}
    [@@ocaml.doc
      "<p>Describes an error that occurred when disabling fast snapshot restores.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an error that occurred when disabling fast snapshot restores.</p>"]
module IpRanges =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module PrefixListIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module UserIdGroupPairSet =
  struct
    type t = UserIdGroupPair.t list
    let make elems () = elems
    let to_query v = Query.to_query_list UserIdGroupPair.to_query v
    let to_headers v = Headers.to_headers_list UserIdGroupPair.to_headers v
    let to_json v = `List (List.map UserIdGroupPair.to_json v)
    let parse xml =
      Util.option_all
        (List.map UserIdGroupPair.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (UserIdGroupPair.to_xml x)))
        v
  end
module VolumeAttachmentState =
  struct
    type t =
      | Attaching 
      | Attached 
      | Detaching 
      | Detached 
      | Busy 
    let str_to_t =
      [("busy", Busy);
      ("detached", Detached);
      ("detaching", Detaching);
      ("attached", Attached);
      ("attaching", Attaching)]
    let t_to_str =
      [(Busy, "busy");
      (Detached, "detached");
      (Detaching, "detaching");
      (Attached, "attached");
      (Attaching, "attaching")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module IKEVersionsRequestListValue =
  struct
    type t = {
      value: String.t option [@ocaml.doc "<p>The IKE version.</p>"]}[@@ocaml.doc
                                                                    "<p>The IKE version that is permitted for the VPN tunnel.</p>"]
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) String.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "Value" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>The IKE version that is permitted for the VPN tunnel.</p>"]
module Phase1DHGroupNumbersRequestListValue =
  struct
    type t =
      {
      value: Integer.t option
        [@ocaml.doc "<p>The Diffie-Hellmann group number.</p>"]}[@@ocaml.doc
                                                                  "<p>Specifies a Diffie-Hellman group number for the VPN tunnel for phase 1 IKE negotiations.</p>"]
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Integer.to_json f)))])
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) Integer.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "Value" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc
       "<p>Specifies a Diffie-Hellman group number for the VPN tunnel for phase 1 IKE negotiations.</p>"]
module Phase1EncryptionAlgorithmsRequestListValue =
  struct
    type t =
      {
      value: String.t option
        [@ocaml.doc "<p>The value for the encryption algorithm.</p>"]}
    [@@ocaml.doc
      "<p>Specifies the encryption algorithm for the VPN tunnel for phase 1 IKE negotiations.</p>"]
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) String.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "Value" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Specifies the encryption algorithm for the VPN tunnel for phase 1 IKE negotiations.</p>"]
module Phase1IntegrityAlgorithmsRequestListValue =
  struct
    type t =
      {
      value: String.t option
        [@ocaml.doc "<p>The value for the integrity algorithm.</p>"]}
    [@@ocaml.doc
      "<p>Specifies the integrity algorithm for the VPN tunnel for phase 1 IKE negotiations.</p>"]
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) String.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "Value" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Specifies the integrity algorithm for the VPN tunnel for phase 1 IKE negotiations.</p>"]
module Phase2DHGroupNumbersRequestListValue =
  struct
    type t =
      {
      value: Integer.t option
        [@ocaml.doc "<p>The Diffie-Hellmann group number.</p>"]}[@@ocaml.doc
                                                                  "<p>Specifies a Diffie-Hellman group number for the VPN tunnel for phase 2 IKE negotiations.</p>"]
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Integer.to_json f)))])
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) Integer.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "Value" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc
       "<p>Specifies a Diffie-Hellman group number for the VPN tunnel for phase 2 IKE negotiations.</p>"]
module Phase2EncryptionAlgorithmsRequestListValue =
  struct
    type t =
      {
      value: String.t option [@ocaml.doc "<p>The encryption algorithm.</p>"]}
    [@@ocaml.doc
      "<p>Specifies the encryption algorithm for the VPN tunnel for phase 2 IKE negotiations.</p>"]
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) String.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "Value" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Specifies the encryption algorithm for the VPN tunnel for phase 2 IKE negotiations.</p>"]
module Phase2IntegrityAlgorithmsRequestListValue =
  struct
    type t =
      {
      value: String.t option [@ocaml.doc "<p>The integrity algorithm.</p>"]}
    [@@ocaml.doc
      "<p>Specifies the integrity algorithm for the VPN tunnel for phase 2 IKE negotiations.</p>"]
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) String.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "Value" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Specifies the integrity algorithm for the VPN tunnel for phase 2 IKE negotiations.</p>"]
module FpgaDeviceInfo =
  struct
    type t =
      {
      name: String.t option
        [@ocaml.doc "<p>The name of the FPGA accelerator.</p>"];
      manufacturer: String.t option
        [@ocaml.doc "<p>The manufacturer of the FPGA accelerator.</p>"];
      count: Integer.t option
        [@ocaml.doc
          "<p>The count of FPGA accelerators for the instance type.</p>"];
      memory_info: FpgaDeviceMemoryInfo.t option
        [@ocaml.doc
          "<p>Describes the memory for the FPGA accelerator for the instance type.</p>"]}
    [@@ocaml.doc
      "<p>Describes the FPGA accelerator for the instance type.</p>"]
    let make ?name  ?manufacturer  ?count  ?memory_info  () =
      { name; manufacturer; count; memory_info }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.memory_info
              (fun f ->
                 Query.Pair ("MemoryInfo", (FpgaDeviceMemoryInfo.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Util.option_map v.manufacturer
             (fun f -> Query.Pair ("Manufacturer", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.memory_info
              (fun f -> ("memory_info", (FpgaDeviceMemoryInfo.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Util.option_map v.manufacturer
             (fun f -> ("manufacturer", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          manufacturer =
            (Util.option_bind (Xml.member "manufacturer" xml) String.parse);
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          memory_info =
            (Util.option_bind (Xml.member "memoryInfo" xml)
               FpgaDeviceMemoryInfo.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.name
                 (fun f -> Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
             @
             [Util.option_map v.manufacturer
                (fun f ->
                   Ezxmlm.make_tag "manufacturer" ([], (String.to_xml f)))])
            @
            [Util.option_map v.count
               (fun f -> Ezxmlm.make_tag "count" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.memory_info
              (fun f ->
                 Ezxmlm.make_tag "memoryInfo"
                   ([], (FpgaDeviceMemoryInfo.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the FPGA accelerator for the instance type.</p>"]
module GpuDeviceInfo =
  struct
    type t =
      {
      name: String.t option
        [@ocaml.doc "<p>The name of the GPU accelerator.</p>"];
      manufacturer: String.t option
        [@ocaml.doc "<p>The manufacturer of the GPU accelerator.</p>"];
      count: Integer.t option
        [@ocaml.doc "<p>The number of GPUs for the instance type.</p>"];
      memory_info: GpuDeviceMemoryInfo.t option
        [@ocaml.doc
          "<p>Describes the memory available to the GPU accelerator.</p>"]}
    [@@ocaml.doc
      "<p>Describes the GPU accelerators for the instance type.</p>"]
    let make ?name  ?manufacturer  ?count  ?memory_info  () =
      { name; manufacturer; count; memory_info }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.memory_info
              (fun f ->
                 Query.Pair ("MemoryInfo", (GpuDeviceMemoryInfo.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Util.option_map v.manufacturer
             (fun f -> Query.Pair ("Manufacturer", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.memory_info
              (fun f -> ("memory_info", (GpuDeviceMemoryInfo.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Util.option_map v.manufacturer
             (fun f -> ("manufacturer", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          manufacturer =
            (Util.option_bind (Xml.member "manufacturer" xml) String.parse);
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          memory_info =
            (Util.option_bind (Xml.member "memoryInfo" xml)
               GpuDeviceMemoryInfo.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.name
                 (fun f -> Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
             @
             [Util.option_map v.manufacturer
                (fun f ->
                   Ezxmlm.make_tag "manufacturer" ([], (String.to_xml f)))])
            @
            [Util.option_map v.count
               (fun f -> Ezxmlm.make_tag "count" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.memory_info
              (fun f ->
                 Ezxmlm.make_tag "memoryInfo"
                   ([], (GpuDeviceMemoryInfo.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the GPU accelerators for the instance type.</p>"]
module InferenceDeviceInfo =
  struct
    type t =
      {
      count: Integer.t option
        [@ocaml.doc
          "<p>The number of Inference accelerators for the instance type.</p>"];
      name: String.t option
        [@ocaml.doc "<p>The name of the Inference accelerator.</p>"];
      manufacturer: String.t option
        [@ocaml.doc "<p>The manufacturer of the Inference accelerator.</p>"]}
    [@@ocaml.doc
      "<p>Describes the Inference accelerators for the instance type.</p>"]
    let make ?count  ?name  ?manufacturer  () = { count; name; manufacturer }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.manufacturer
              (fun f -> Query.Pair ("Manufacturer", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.manufacturer
              (fun f -> ("manufacturer", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          manufacturer =
            (Util.option_bind (Xml.member "manufacturer" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.count
                (fun f -> Ezxmlm.make_tag "count" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.name
               (fun f -> Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
           @
           [Util.option_map v.manufacturer
              (fun f ->
                 Ezxmlm.make_tag "manufacturer" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the Inference accelerators for the instance type.</p>"]
module DiskInfo =
  struct
    type t =
      {
      size_in_g_b: Long.t option
        [@ocaml.doc "<p>The size of the disk in GB.</p>"];
      count: Integer.t option
        [@ocaml.doc "<p>The number of disks with this configuration.</p>"];
      type_: DiskType.t option [@ocaml.doc "<p>The type of disk.</p>"]}
    [@@ocaml.doc "<p>Describes the disk.</p>"]
    let make ?size_in_g_b  ?count  ?type_  () = { size_in_g_b; count; type_ }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> Query.Pair ("Type", (DiskType.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Util.option_map v.size_in_g_b
             (fun f -> Query.Pair ("SizeInGB", (Long.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> ("type_", (DiskType.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Util.option_map v.size_in_g_b
             (fun f -> ("size_in_g_b", (Long.to_json f)))])
    let parse xml =
      Some
        {
          size_in_g_b =
            (Util.option_bind (Xml.member "sizeInGB" xml) Long.parse);
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          type_ = (Util.option_bind (Xml.member "type" xml) DiskType.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.size_in_g_b
                (fun f -> Ezxmlm.make_tag "sizeInGB" ([], (Long.to_xml f)))])
            @
            [Util.option_map v.count
               (fun f -> Ezxmlm.make_tag "count" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.type_
              (fun f -> Ezxmlm.make_tag "type" ([], (DiskType.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the disk.</p>"]
module PlacementGroupStrategy =
  struct
    type t =
      | Cluster 
      | Partition 
      | Spread 
    let str_to_t =
      [("spread", Spread); ("partition", Partition); ("cluster", Cluster)]
    let t_to_str =
      [(Spread, "spread"); (Partition, "partition"); (Cluster, "cluster")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ArchitectureType =
  struct
    type t =
      | I386 
      | X86_64 
      | Arm64 
    let str_to_t = [("arm64", Arm64); ("x86_64", X86_64); ("i386", I386)]
    let t_to_str = [(Arm64, "arm64"); (X86_64, "x86_64"); (I386, "i386")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module TelemetryStatus =
  struct
    type t =
      | UP 
      | DOWN 
    let str_to_t = [("DOWN", DOWN); ("UP", UP)]
    let t_to_str = [(DOWN, "DOWN"); (UP, "UP")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module TunnelOption =
  struct
    type t =
      {
      outside_ip_address: String.t option
        [@ocaml.doc "<p>The external IP address of the VPN tunnel.</p>"];
      tunnel_inside_cidr: String.t option
        [@ocaml.doc
          "<p>The range of inside IP addresses for the tunnel.</p>"];
      pre_shared_key: String.t option
        [@ocaml.doc
          "<p>The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and the customer gateway.</p>"];
      phase1_lifetime_seconds: Integer.t option
        [@ocaml.doc
          "<p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p>"];
      phase2_lifetime_seconds: Integer.t option
        [@ocaml.doc
          "<p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p>"];
      rekey_margin_time_seconds: Integer.t option
        [@ocaml.doc
          "<p>The margin time, in seconds, before the phase 2 lifetime expires, during which the AWS side of the VPN connection performs an IKE rekey.</p>"];
      rekey_fuzz_percentage: Integer.t option
        [@ocaml.doc
          "<p>The percentage of the rekey window determined by <code>RekeyMarginTimeSeconds</code> during which the rekey time is randomly selected.</p>"];
      replay_window_size: Integer.t option
        [@ocaml.doc "<p>The number of packets in an IKE replay window.</p>"];
      dpd_timeout_seconds: Integer.t option
        [@ocaml.doc
          "<p>The number of seconds after which a DPD timeout occurs.</p>"];
      phase1_encryption_algorithms: Phase1EncryptionAlgorithmsList.t
        [@ocaml.doc
          "<p>The permitted encryption algorithms for the VPN tunnel for phase 1 IKE negotiations.</p>"];
      phase2_encryption_algorithms: Phase2EncryptionAlgorithmsList.t
        [@ocaml.doc
          "<p>The permitted encryption algorithms for the VPN tunnel for phase 2 IKE negotiations.</p>"];
      phase1_integrity_algorithms: Phase1IntegrityAlgorithmsList.t
        [@ocaml.doc
          "<p>The permitted integrity algorithms for the VPN tunnel for phase 1 IKE negotiations.</p>"];
      phase2_integrity_algorithms: Phase2IntegrityAlgorithmsList.t
        [@ocaml.doc
          "<p>The permitted integrity algorithms for the VPN tunnel for phase 2 IKE negotiations.</p>"];
      phase1_d_h_group_numbers: Phase1DHGroupNumbersList.t
        [@ocaml.doc
          "<p>The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 1 IKE negotiations.</p>"];
      phase2_d_h_group_numbers: Phase2DHGroupNumbersList.t
        [@ocaml.doc
          "<p>The permitted Diffie-Hellman group numbers for the VPN tunnel for phase 2 IKE negotiations.</p>"];
      ike_versions: IKEVersionsList.t
        [@ocaml.doc
          "<p>The IKE versions that are permitted for the VPN tunnel.</p>"]}
    [@@ocaml.doc "<p>The VPN tunnel options.</p>"]
    let make ?outside_ip_address  ?tunnel_inside_cidr  ?pre_shared_key 
      ?phase1_lifetime_seconds  ?phase2_lifetime_seconds 
      ?rekey_margin_time_seconds  ?rekey_fuzz_percentage  ?replay_window_size
       ?dpd_timeout_seconds  ?(phase1_encryption_algorithms= []) 
      ?(phase2_encryption_algorithms= [])  ?(phase1_integrity_algorithms= [])
       ?(phase2_integrity_algorithms= [])  ?(phase1_d_h_group_numbers= []) 
      ?(phase2_d_h_group_numbers= [])  ?(ike_versions= [])  () =
      {
        outside_ip_address;
        tunnel_inside_cidr;
        pre_shared_key;
        phase1_lifetime_seconds;
        phase2_lifetime_seconds;
        rekey_margin_time_seconds;
        rekey_fuzz_percentage;
        replay_window_size;
        dpd_timeout_seconds;
        phase1_encryption_algorithms;
        phase2_encryption_algorithms;
        phase1_integrity_algorithms;
        phase2_integrity_algorithms;
        phase1_d_h_group_numbers;
        phase2_d_h_group_numbers;
        ike_versions
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("IkeVersionSet", (IKEVersionsList.to_query v.ike_versions)));
           Some
             (Query.Pair
                ("Phase2DHGroupNumberSet",
                  (Phase2DHGroupNumbersList.to_query
                     v.phase2_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase1DHGroupNumberSet",
                  (Phase1DHGroupNumbersList.to_query
                     v.phase1_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase2IntegrityAlgorithmSet",
                  (Phase2IntegrityAlgorithmsList.to_query
                     v.phase2_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase1IntegrityAlgorithmSet",
                  (Phase1IntegrityAlgorithmsList.to_query
                     v.phase1_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase2EncryptionAlgorithmSet",
                  (Phase2EncryptionAlgorithmsList.to_query
                     v.phase2_encryption_algorithms)));
           Some
             (Query.Pair
                ("Phase1EncryptionAlgorithmSet",
                  (Phase1EncryptionAlgorithmsList.to_query
                     v.phase1_encryption_algorithms)));
           Util.option_map v.dpd_timeout_seconds
             (fun f -> Query.Pair ("DpdTimeoutSeconds", (Integer.to_query f)));
           Util.option_map v.replay_window_size
             (fun f -> Query.Pair ("ReplayWindowSize", (Integer.to_query f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f ->
                Query.Pair ("RekeyFuzzPercentage", (Integer.to_query f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f ->
                Query.Pair ("RekeyMarginTimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase2LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase1LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.pre_shared_key
             (fun f -> Query.Pair ("PreSharedKey", (String.to_query f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> Query.Pair ("TunnelInsideCidr", (String.to_query f)));
           Util.option_map v.outside_ip_address
             (fun f -> Query.Pair ("OutsideIpAddress", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("ike_versions", (IKEVersionsList.to_json v.ike_versions));
           Some
             ("phase2_d_h_group_numbers",
               (Phase2DHGroupNumbersList.to_json v.phase2_d_h_group_numbers));
           Some
             ("phase1_d_h_group_numbers",
               (Phase1DHGroupNumbersList.to_json v.phase1_d_h_group_numbers));
           Some
             ("phase2_integrity_algorithms",
               (Phase2IntegrityAlgorithmsList.to_json
                  v.phase2_integrity_algorithms));
           Some
             ("phase1_integrity_algorithms",
               (Phase1IntegrityAlgorithmsList.to_json
                  v.phase1_integrity_algorithms));
           Some
             ("phase2_encryption_algorithms",
               (Phase2EncryptionAlgorithmsList.to_json
                  v.phase2_encryption_algorithms));
           Some
             ("phase1_encryption_algorithms",
               (Phase1EncryptionAlgorithmsList.to_json
                  v.phase1_encryption_algorithms));
           Util.option_map v.dpd_timeout_seconds
             (fun f -> ("dpd_timeout_seconds", (Integer.to_json f)));
           Util.option_map v.replay_window_size
             (fun f -> ("replay_window_size", (Integer.to_json f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f -> ("rekey_fuzz_percentage", (Integer.to_json f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f -> ("rekey_margin_time_seconds", (Integer.to_json f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f -> ("phase2_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f -> ("phase1_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.pre_shared_key
             (fun f -> ("pre_shared_key", (String.to_json f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> ("tunnel_inside_cidr", (String.to_json f)));
           Util.option_map v.outside_ip_address
             (fun f -> ("outside_ip_address", (String.to_json f)))])
    let parse xml =
      Some
        {
          outside_ip_address =
            (Util.option_bind (Xml.member "outsideIpAddress" xml)
               String.parse);
          tunnel_inside_cidr =
            (Util.option_bind (Xml.member "tunnelInsideCidr" xml)
               String.parse);
          pre_shared_key =
            (Util.option_bind (Xml.member "preSharedKey" xml) String.parse);
          phase1_lifetime_seconds =
            (Util.option_bind (Xml.member "phase1LifetimeSeconds" xml)
               Integer.parse);
          phase2_lifetime_seconds =
            (Util.option_bind (Xml.member "phase2LifetimeSeconds" xml)
               Integer.parse);
          rekey_margin_time_seconds =
            (Util.option_bind (Xml.member "rekeyMarginTimeSeconds" xml)
               Integer.parse);
          rekey_fuzz_percentage =
            (Util.option_bind (Xml.member "rekeyFuzzPercentage" xml)
               Integer.parse);
          replay_window_size =
            (Util.option_bind (Xml.member "replayWindowSize" xml)
               Integer.parse);
          dpd_timeout_seconds =
            (Util.option_bind (Xml.member "dpdTimeoutSeconds" xml)
               Integer.parse);
          phase1_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "phase1EncryptionAlgorithmSet" xml)
                  Phase1EncryptionAlgorithmsList.parse));
          phase2_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "phase2EncryptionAlgorithmSet" xml)
                  Phase2EncryptionAlgorithmsList.parse));
          phase1_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "phase1IntegrityAlgorithmSet" xml)
                  Phase1IntegrityAlgorithmsList.parse));
          phase2_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "phase2IntegrityAlgorithmSet" xml)
                  Phase2IntegrityAlgorithmsList.parse));
          phase1_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "phase1DHGroupNumberSet" xml)
                  Phase1DHGroupNumbersList.parse));
          phase2_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "phase2DHGroupNumberSet" xml)
                  Phase2DHGroupNumbersList.parse));
          ike_versions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ikeVersionSet" xml)
                  IKEVersionsList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((([] @
                          [Util.option_map v.outside_ip_address
                             (fun f ->
                                Ezxmlm.make_tag "outsideIpAddress"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.tunnel_inside_cidr
                            (fun f ->
                               Ezxmlm.make_tag "tunnelInsideCidr"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.pre_shared_key
                           (fun f ->
                              Ezxmlm.make_tag "preSharedKey"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.phase1_lifetime_seconds
                          (fun f ->
                             Ezxmlm.make_tag "phase1LifetimeSeconds"
                               ([], (Integer.to_xml f)))])
                      @
                      [Util.option_map v.phase2_lifetime_seconds
                         (fun f ->
                            Ezxmlm.make_tag "phase2LifetimeSeconds"
                              ([], (Integer.to_xml f)))])
                     @
                     [Util.option_map v.rekey_margin_time_seconds
                        (fun f ->
                           Ezxmlm.make_tag "rekeyMarginTimeSeconds"
                             ([], (Integer.to_xml f)))])
                    @
                    [Util.option_map v.rekey_fuzz_percentage
                       (fun f ->
                          Ezxmlm.make_tag "rekeyFuzzPercentage"
                            ([], (Integer.to_xml f)))])
                   @
                   [Util.option_map v.replay_window_size
                      (fun f ->
                         Ezxmlm.make_tag "replayWindowSize"
                           ([], (Integer.to_xml f)))])
                  @
                  [Util.option_map v.dpd_timeout_seconds
                     (fun f ->
                        Ezxmlm.make_tag "dpdTimeoutSeconds"
                          ([], (Integer.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "phase1EncryptionAlgorithmSet"
                            ([], (Phase1EncryptionAlgorithmsList.to_xml [x]))))
                    v.phase1_encryption_algorithms))
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "phase2EncryptionAlgorithmSet"
                           ([], (Phase2EncryptionAlgorithmsList.to_xml [x]))))
                   v.phase2_encryption_algorithms))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "phase1IntegrityAlgorithmSet"
                          ([], (Phase1IntegrityAlgorithmsList.to_xml [x]))))
                  v.phase1_integrity_algorithms))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "phase2IntegrityAlgorithmSet"
                         ([], (Phase2IntegrityAlgorithmsList.to_xml [x]))))
                 v.phase2_integrity_algorithms))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "phase1DHGroupNumberSet"
                        ([], (Phase1DHGroupNumbersList.to_xml [x]))))
                v.phase1_d_h_group_numbers))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "phase2DHGroupNumberSet"
                       ([], (Phase2DHGroupNumbersList.to_xml [x]))))
               v.phase2_d_h_group_numbers))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "ikeVersionSet"
                      ([], (IKEVersionsList.to_xml [x])))) v.ike_versions))
  end[@@ocaml.doc "<p>The VPN tunnel options.</p>"]
module VpnState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module VpnStaticRouteSource =
  struct
    type t =
      | Static 
    let str_to_t = [("Static", Static)]
    let t_to_str = [(Static, "Static")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module CidrBlock =
  struct
    type t =
      {
      cidr_block: String.t option [@ocaml.doc "<p>The IPv4 CIDR block.</p>"]}
    [@@ocaml.doc "<p>Describes an IPv4 CIDR block.</p>"]
    let make ?cidr_block  () = { cidr_block }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cidr_block
              (fun f -> Query.Pair ("CidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cidr_block
              (fun f -> ("cidr_block", (String.to_json f)))])
    let parse xml =
      Some
        {
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.cidr_block
              (fun f -> Ezxmlm.make_tag "cidrBlock" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an IPv4 CIDR block.</p>"]
module Ipv6CidrBlock =
  struct
    type t =
      {
      ipv6_cidr_block: String.t option
        [@ocaml.doc "<p>The IPv6 CIDR block.</p>"]}[@@ocaml.doc
                                                     "<p>Describes an IPv6 CIDR block.</p>"]
    let make ?ipv6_cidr_block  () = { ipv6_cidr_block }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block
              (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block
              (fun f -> ("ipv6_cidr_block", (String.to_json f)))])
    let parse xml =
      Some
        {
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "ipv6CidrBlock" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ipv6_cidr_block
              (fun f ->
                 Ezxmlm.make_tag "ipv6CidrBlock" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an IPv6 CIDR block.</p>"]
module IcmpTypeCode =
  struct
    type t =
      {
      code: Integer.t option
        [@ocaml.doc
          "<p>The ICMP code. A value of -1 means all codes for the specified ICMP type.</p>"];
      type_: Integer.t option
        [@ocaml.doc "<p>The ICMP type. A value of -1 means all types.</p>"]}
    [@@ocaml.doc "<p>Describes the ICMP type and code.</p>"]
    let make ?code  ?type_  () = { code; type_ }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> Query.Pair ("Type", (Integer.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.type_ (fun f -> ("type_", (Integer.to_json f)));
           Util.option_map v.code (fun f -> ("code", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) Integer.parse);
          type_ = (Util.option_bind (Xml.member "type" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f -> Ezxmlm.make_tag "code" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.type_
              (fun f -> Ezxmlm.make_tag "type" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the ICMP type and code.</p>"]
module PortRange =
  struct
    type t =
      {
      from: Integer.t option
        [@ocaml.doc "<p>The first port in the range.</p>"];
      to_: Integer.t option [@ocaml.doc "<p>The last port in the range.</p>"]}
    [@@ocaml.doc "<p>Describes a range of ports.</p>"]
    let make ?from  ?to_  () = { from; to_ }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.to_
              (fun f -> Query.Pair ("To", (Integer.to_query f)));
           Util.option_map v.from
             (fun f -> Query.Pair ("From", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.to_ (fun f -> ("to_", (Integer.to_json f)));
           Util.option_map v.from (fun f -> ("from", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          from = (Util.option_bind (Xml.member "from" xml) Integer.parse);
          to_ = (Util.option_bind (Xml.member "to" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.from
               (fun f -> Ezxmlm.make_tag "from" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.to_
              (fun f -> Ezxmlm.make_tag "to" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a range of ports.</p>"]
module RuleAction =
  struct
    type t =
      | Allow 
      | Deny 
    let str_to_t = [("deny", Deny); ("allow", Allow)]
    let t_to_str = [(Deny, "deny"); (Allow, "allow")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module NetworkInterfaceAssociation =
  struct
    type t =
      {
      allocation_id: String.t option [@ocaml.doc "<p>The allocation ID.</p>"];
      association_id: String.t option
        [@ocaml.doc "<p>The association ID.</p>"];
      ip_owner_id: String.t option
        [@ocaml.doc "<p>The ID of the Elastic IP address owner.</p>"];
      public_dns_name: String.t option
        [@ocaml.doc "<p>The public DNS name.</p>"];
      public_ip: String.t option
        [@ocaml.doc
          "<p>The address of the Elastic IP address bound to the network interface.</p>"]}
    [@@ocaml.doc
      "<p>Describes association information for an Elastic IP address (IPv4 only).</p>"]
    let make ?allocation_id  ?association_id  ?ip_owner_id  ?public_dns_name 
      ?public_ip  () =
      {
        allocation_id;
        association_id;
        ip_owner_id;
        public_dns_name;
        public_ip
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.public_dns_name
             (fun f -> Query.Pair ("PublicDnsName", (String.to_query f)));
           Util.option_map v.ip_owner_id
             (fun f -> Query.Pair ("IpOwnerId", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.public_dns_name
             (fun f -> ("public_dns_name", (String.to_json f)));
           Util.option_map v.ip_owner_id
             (fun f -> ("ip_owner_id", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          ip_owner_id =
            (Util.option_bind (Xml.member "ipOwnerId" xml) String.parse);
          public_dns_name =
            (Util.option_bind (Xml.member "publicDnsName" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.allocation_id
                  (fun f ->
                     Ezxmlm.make_tag "allocationId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.association_id
                 (fun f ->
                    Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.ip_owner_id
                (fun f -> Ezxmlm.make_tag "ipOwnerId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.public_dns_name
               (fun f ->
                  Ezxmlm.make_tag "publicDnsName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.public_ip
              (fun f -> Ezxmlm.make_tag "publicIp" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes association information for an Elastic IP address (IPv4 only).</p>"]
module RecurringChargeFrequency =
  struct
    type t =
      | Hourly 
    let str_to_t = [("Hourly", Hourly)]
    let t_to_str = [(Hourly, "Hourly")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ServiceType =
  struct
    type t =
      | Interface 
      | Gateway 
    let str_to_t = [("Gateway", Gateway); ("Interface", Interface)]
    let t_to_str = [(Gateway, "Gateway"); (Interface, "Interface")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ImportInstanceVolumeDetailItem =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc
          "<p>The Availability Zone where the resulting instance will reside.</p>"];
      bytes_converted: Long.t option
        [@ocaml.doc "<p>The number of bytes converted so far.</p>"];
      description: String.t option
        [@ocaml.doc "<p>A description of the task.</p>"];
      image: DiskImageDescription.t option [@ocaml.doc "<p>The image.</p>"];
      status: String.t option
        [@ocaml.doc
          "<p>The status of the import of this particular disk image.</p>"];
      status_message: String.t option
        [@ocaml.doc
          "<p>The status information or errors related to the disk image.</p>"];
      volume: DiskImageVolumeDescription.t option
        [@ocaml.doc "<p>The volume.</p>"]}[@@ocaml.doc
                                            "<p>Describes an import volume task.</p>"]
    let make ?availability_zone  ?bytes_converted  ?description  ?image 
      ?status  ?status_message  ?volume  () =
      {
        availability_zone;
        bytes_converted;
        description;
        image;
        status;
        status_message;
        volume
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f ->
                 Query.Pair
                   ("Volume", (DiskImageVolumeDescription.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.image
             (fun f ->
                Query.Pair ("Image", (DiskImageDescription.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.bytes_converted
             (fun f -> Query.Pair ("BytesConverted", (Long.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f -> ("volume", (DiskImageVolumeDescription.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.image
             (fun f -> ("image", (DiskImageDescription.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.bytes_converted
             (fun f -> ("bytes_converted", (Long.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          bytes_converted =
            (Util.option_bind (Xml.member "bytesConverted" xml) Long.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          image =
            (Util.option_bind (Xml.member "image" xml)
               DiskImageDescription.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          volume =
            (Util.option_bind (Xml.member "volume" xml)
               DiskImageVolumeDescription.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.availability_zone
                    (fun f ->
                       Ezxmlm.make_tag "availabilityZone"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.bytes_converted
                   (fun f ->
                      Ezxmlm.make_tag "bytesConverted" ([], (Long.to_xml f)))])
               @
               [Util.option_map v.description
                  (fun f ->
                     Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
              @
              [Util.option_map v.image
                 (fun f ->
                    Ezxmlm.make_tag "image"
                      ([], (DiskImageDescription.to_xml f)))])
             @
             [Util.option_map v.status
                (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
            @
            [Util.option_map v.status_message
               (fun f ->
                  Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
           @
           [Util.option_map v.volume
              (fun f ->
                 Ezxmlm.make_tag "volume"
                   ([], (DiskImageVolumeDescription.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an import volume task.</p>"]
module TransitGatewayAttachmentResourceType =
  struct
    type t =
      | Vpc 
      | Vpn 
      | Direct_connect_gateway 
      | Tgw_peering 
    let str_to_t =
      [("tgw-peering", Tgw_peering);
      ("direct-connect-gateway", Direct_connect_gateway);
      ("vpn", Vpn);
      ("vpc", Vpc)]
    let t_to_str =
      [(Tgw_peering, "tgw-peering");
      (Direct_connect_gateway, "direct-connect-gateway");
      (Vpn, "vpn");
      (Vpc, "vpc")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module EnableFastSnapshotRestoreStateError =
  struct
    type t =
      {
      code: String.t option [@ocaml.doc "<p>The error code.</p>"];
      message: String.t option [@ocaml.doc "<p>The error message.</p>"]}
    [@@ocaml.doc
      "<p>Describes an error that occurred when enabling fast snapshot restores.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an error that occurred when enabling fast snapshot restores.</p>"]
module RouteOrigin =
  struct
    type t =
      | CreateRouteTable 
      | CreateRoute 
      | EnableVgwRoutePropagation 
    let str_to_t =
      [("EnableVgwRoutePropagation", EnableVgwRoutePropagation);
      ("CreateRoute", CreateRoute);
      ("CreateRouteTable", CreateRouteTable)]
    let t_to_str =
      [(EnableVgwRoutePropagation, "EnableVgwRoutePropagation");
      (CreateRoute, "CreateRoute");
      (CreateRouteTable, "CreateRouteTable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module RouteState =
  struct
    type t =
      | Active 
      | Blackhole 
    let str_to_t = [("blackhole", Blackhole); ("active", Active)]
    let t_to_str = [(Blackhole, "blackhole"); (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module RouteTableAssociationState =
  struct
    type t =
      {
      state: RouteTableAssociationStateCode.t option
        [@ocaml.doc "<p>The state of the association.</p>"];
      status_message: String.t option
        [@ocaml.doc "<p>The status message, if applicable.</p>"]}[@@ocaml.doc
                                                                   "<p>Describes the state of an association between a route table and a subnet or gateway.</p>"]
    let make ?state  ?status_message  () = { state; status_message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (RouteTableAssociationStateCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (RouteTableAssociationStateCode.to_json f)))])
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml)
               RouteTableAssociationStateCode.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.state
               (fun f ->
                  Ezxmlm.make_tag "state"
                    ([], (RouteTableAssociationStateCode.to_xml f)))])
           @
           [Util.option_map v.status_message
              (fun f ->
                 Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the state of an association between a route table and a subnet or gateway.</p>"]
module ElasticGpuSpecificationResponse =
  struct
    type t =
      {
      type_: String.t option [@ocaml.doc "<p>The elastic GPU type.</p>"]}
    [@@ocaml.doc "<p>Describes an elastic GPU.</p>"]
    let make ?type_  () = { type_ }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> Query.Pair ("Type", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.type_ (fun f -> ("type_", (String.to_json f)))])
    let parse xml =
      Some
        { type_ = (Util.option_bind (Xml.member "type" xml) String.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.type_
              (fun f -> Ezxmlm.make_tag "type" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an elastic GPU.</p>"]
module LaunchTemplateBlockDeviceMapping =
  struct
    type t =
      {
      device_name: String.t option [@ocaml.doc "<p>The device name.</p>"];
      virtual_name: String.t option
        [@ocaml.doc "<p>The virtual device name (ephemeralN).</p>"];
      ebs: LaunchTemplateEbsBlockDevice.t option
        [@ocaml.doc
          "<p>Information about the block device for an EBS volume.</p>"];
      no_device: String.t option
        [@ocaml.doc
          "<p>Suppresses the specified device included in the block device mapping of the AMI.</p>"]}
    [@@ocaml.doc "<p>Describes a block device mapping.</p>"]
    let make ?device_name  ?virtual_name  ?ebs  ?no_device  () =
      { device_name; virtual_name; ebs; no_device }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.ebs
             (fun f ->
                Query.Pair ("Ebs", (LaunchTemplateEbsBlockDevice.to_query f)));
           Util.option_map v.virtual_name
             (fun f -> Query.Pair ("VirtualName", (String.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.ebs
             (fun f -> ("ebs", (LaunchTemplateEbsBlockDevice.to_json f)));
           Util.option_map v.virtual_name
             (fun f -> ("virtual_name", (String.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          virtual_name =
            (Util.option_bind (Xml.member "virtualName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "ebs" xml)
               LaunchTemplateEbsBlockDevice.parse);
          no_device =
            (Util.option_bind (Xml.member "noDevice" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.device_name
                 (fun f ->
                    Ezxmlm.make_tag "deviceName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.virtual_name
                (fun f ->
                   Ezxmlm.make_tag "virtualName" ([], (String.to_xml f)))])
            @
            [Util.option_map v.ebs
               (fun f ->
                  Ezxmlm.make_tag "ebs"
                    ([], (LaunchTemplateEbsBlockDevice.to_xml f)))])
           @
           [Util.option_map v.no_device
              (fun f -> Ezxmlm.make_tag "noDevice" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a block device mapping.</p>"]
module LaunchTemplateElasticInferenceAcceleratorResponse =
  struct
    type t =
      {
      type_: String.t option
        [@ocaml.doc
          "<p> The type of elastic inference accelerator. The possible values are eia1.medium, eia1.large, and eia1.xlarge. </p>"];
      count: Integer.t option
        [@ocaml.doc
          "<p> The number of elastic inference accelerators to attach to the instance. </p> <p>Default: 1</p>"]}
    [@@ocaml.doc "<p> Describes an elastic inference accelerator. </p>"]
    let make ?type_  ?count  () = { type_; count }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.count
              (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Util.option_map v.type_ (fun f -> ("type_", (String.to_json f)))])
    let parse xml =
      Some
        {
          type_ = (Util.option_bind (Xml.member "type" xml) String.parse);
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.type_
               (fun f -> Ezxmlm.make_tag "type" ([], (String.to_xml f)))])
           @
           [Util.option_map v.count
              (fun f -> Ezxmlm.make_tag "count" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc "<p> Describes an elastic inference accelerator. </p>"]
module LaunchTemplateSpotMarketOptions =
  struct
    type t =
      {
      max_price: String.t option
        [@ocaml.doc
          "<p>The maximum hourly price you're willing to pay for the Spot Instances.</p>"];
      spot_instance_type: SpotInstanceType.t option
        [@ocaml.doc "<p>The Spot Instance request type.</p>"];
      block_duration_minutes: Integer.t option
        [@ocaml.doc
          "<p>The required duration for the Spot Instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).</p>"];
      valid_until: DateTime.t option
        [@ocaml.doc
          "<p>The end date of the request. For a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached.</p>"];
      instance_interruption_behavior: InstanceInterruptionBehavior.t option
        [@ocaml.doc
          "<p>The behavior when a Spot Instance is interrupted.</p>"]}
    [@@ocaml.doc "<p>The options for Spot Instances.</p>"]
    let make ?max_price  ?spot_instance_type  ?block_duration_minutes 
      ?valid_until  ?instance_interruption_behavior  () =
      {
        max_price;
        spot_instance_type;
        block_duration_minutes;
        valid_until;
        instance_interruption_behavior
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Query.Pair
                   ("InstanceInterruptionBehavior",
                     (InstanceInterruptionBehavior.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.block_duration_minutes
             (fun f ->
                Query.Pair ("BlockDurationMinutes", (Integer.to_query f)));
           Util.option_map v.spot_instance_type
             (fun f ->
                Query.Pair
                  ("SpotInstanceType", (SpotInstanceType.to_query f)));
           Util.option_map v.max_price
             (fun f -> Query.Pair ("MaxPrice", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 ("instance_interruption_behavior",
                   (InstanceInterruptionBehavior.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.block_duration_minutes
             (fun f -> ("block_duration_minutes", (Integer.to_json f)));
           Util.option_map v.spot_instance_type
             (fun f -> ("spot_instance_type", (SpotInstanceType.to_json f)));
           Util.option_map v.max_price
             (fun f -> ("max_price", (String.to_json f)))])
    let parse xml =
      Some
        {
          max_price =
            (Util.option_bind (Xml.member "maxPrice" xml) String.parse);
          spot_instance_type =
            (Util.option_bind (Xml.member "spotInstanceType" xml)
               SpotInstanceType.parse);
          block_duration_minutes =
            (Util.option_bind (Xml.member "blockDurationMinutes" xml)
               Integer.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "instanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.max_price
                  (fun f ->
                     Ezxmlm.make_tag "maxPrice" ([], (String.to_xml f)))])
              @
              [Util.option_map v.spot_instance_type
                 (fun f ->
                    Ezxmlm.make_tag "spotInstanceType"
                      ([], (SpotInstanceType.to_xml f)))])
             @
             [Util.option_map v.block_duration_minutes
                (fun f ->
                   Ezxmlm.make_tag "blockDurationMinutes"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.valid_until
               (fun f ->
                  Ezxmlm.make_tag "validUntil" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Ezxmlm.make_tag "instanceInterruptionBehavior"
                   ([], (InstanceInterruptionBehavior.to_xml f)))])
  end[@@ocaml.doc "<p>The options for Spot Instances.</p>"]
module MarketType =
  struct
    type t =
      | Spot 
    let str_to_t = [("spot", Spot)]
    let t_to_str = [(Spot, "spot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module LaunchTemplateInstanceNetworkInterfaceSpecification =
  struct
    type t =
      {
      associate_public_ip_address: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether to associate a public IPv4 address with eth0 for a new network interface.</p>"];
      delete_on_termination: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the network interface is deleted when the instance is terminated.</p>"];
      description: String.t option
        [@ocaml.doc "<p>A description for the network interface.</p>"];
      device_index: Integer.t option
        [@ocaml.doc
          "<p>The device index for the network interface attachment.</p>"];
      groups: GroupIdStringList.t
        [@ocaml.doc "<p>The IDs of one or more security groups.</p>"];
      interface_type: String.t option
        [@ocaml.doc "<p>The type of network interface.</p>"];
      ipv6_address_count: Integer.t option
        [@ocaml.doc
          "<p>The number of IPv6 addresses for the network interface.</p>"];
      ipv6_addresses: InstanceIpv6AddressList.t
        [@ocaml.doc "<p>The IPv6 addresses for the network interface.</p>"];
      network_interface_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface.</p>"];
      private_ip_address: String.t option
        [@ocaml.doc
          "<p>The primary private IPv4 address of the network interface.</p>"];
      private_ip_addresses: PrivateIpAddressSpecificationList.t
        [@ocaml.doc "<p>One or more private IPv4 addresses.</p>"];
      secondary_private_ip_address_count: Integer.t option
        [@ocaml.doc
          "<p>The number of secondary private IPv4 addresses for the network interface.</p>"];
      subnet_id: String.t option
        [@ocaml.doc "<p>The ID of the subnet for the network interface.</p>"]}
    [@@ocaml.doc "<p>Describes a network interface.</p>"]
    let make ?associate_public_ip_address  ?delete_on_termination 
      ?description  ?device_index  ?(groups= [])  ?interface_type 
      ?ipv6_address_count  ?(ipv6_addresses= [])  ?network_interface_id 
      ?private_ip_address  ?(private_ip_addresses= []) 
      ?secondary_private_ip_address_count  ?subnet_id  () =
      {
        associate_public_ip_address;
        delete_on_termination;
        description;
        device_index;
        groups;
        interface_type;
        ipv6_address_count;
        ipv6_addresses;
        network_interface_id;
        private_ip_address;
        private_ip_addresses;
        secondary_private_ip_address_count;
        subnet_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddressesSet",
                  (PrivateIpAddressSpecificationList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6AddressesSet",
                  (InstanceIpv6AddressList.to_query v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)));
           Util.option_map v.interface_type
             (fun f -> Query.Pair ("InterfaceType", (String.to_query f)));
           Some
             (Query.Pair ("GroupSet", (GroupIdStringList.to_query v.groups)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.associate_public_ip_address
             (fun f ->
                Query.Pair ("AssociatePublicIpAddress", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_addresses",
               (PrivateIpAddressSpecificationList.to_json
                  v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (InstanceIpv6AddressList.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)));
           Util.option_map v.interface_type
             (fun f -> ("interface_type", (String.to_json f)));
           Some ("groups", (GroupIdStringList.to_json v.groups));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.associate_public_ip_address
             (fun f -> ("associate_public_ip_address", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          associate_public_ip_address =
            (Util.option_bind (Xml.member "associatePublicIpAddress" xml)
               Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          device_index =
            (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdStringList.parse));
          interface_type =
            (Util.option_bind (Xml.member "interfaceType" xml) String.parse);
          ipv6_address_count =
            (Util.option_bind (Xml.member "ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6AddressesSet" xml)
                  InstanceIpv6AddressList.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddressesSet" xml)
                  PrivateIpAddressSpecificationList.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "secondaryPrivateIpAddressCount" xml)
               Integer.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.associate_public_ip_address
                          (fun f ->
                             Ezxmlm.make_tag "associatePublicIpAddress"
                               ([], (Boolean.to_xml f)))])
                      @
                      [Util.option_map v.delete_on_termination
                         (fun f ->
                            Ezxmlm.make_tag "deleteOnTermination"
                              ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.description
                        (fun f ->
                           Ezxmlm.make_tag "description"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.device_index
                       (fun f ->
                          Ezxmlm.make_tag "deviceIndex"
                            ([], (Integer.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "groupSet"
                              ([], (GroupIdStringList.to_xml [x])))) v.groups))
                  @
                  [Util.option_map v.interface_type
                     (fun f ->
                        Ezxmlm.make_tag "interfaceType"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.ipv6_address_count
                    (fun f ->
                       Ezxmlm.make_tag "ipv6AddressCount"
                         ([], (Integer.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "ipv6AddressesSet"
                           ([], (InstanceIpv6AddressList.to_xml [x]))))
                   v.ipv6_addresses))
               @
               [Util.option_map v.network_interface_id
                  (fun f ->
                     Ezxmlm.make_tag "networkInterfaceId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.private_ip_address
                 (fun f ->
                    Ezxmlm.make_tag "privateIpAddress"
                      ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "privateIpAddressesSet"
                        ([], (PrivateIpAddressSpecificationList.to_xml [x]))))
                v.private_ip_addresses))
            @
            [Util.option_map v.secondary_private_ip_address_count
               (fun f ->
                  Ezxmlm.make_tag "secondaryPrivateIpAddressCount"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.subnet_id
              (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a network interface.</p>"]
module LaunchTemplateLicenseConfiguration =
  struct
    type t =
      {
      license_configuration_arn: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the license configuration.</p>"]}
    [@@ocaml.doc "<p>Describes a license configuration.</p>"]
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "licenseConfigurationArn" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Ezxmlm.make_tag "licenseConfigurationArn"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a license configuration.</p>"]
module LaunchTemplateTagSpecification =
  struct
    type t =
      {
      resource_type: ResourceType.t option
        [@ocaml.doc "<p>The type of resource.</p>"];
      tags: TagList.t [@ocaml.doc "<p>The tags for the resource.</p>"]}
    [@@ocaml.doc "<p>The tag specification for the launch template.</p>"]
    let make ?resource_type  ?(tags= [])  () = { resource_type; tags }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.resource_type
             (fun f -> Query.Pair ("ResourceType", (ResourceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.resource_type
             (fun f -> ("resource_type", (ResourceType.to_json f)))])
    let parse xml =
      Some
        {
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               ResourceType.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "resourceType"
                    ([], (ResourceType.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>The tag specification for the launch template.</p>"]
module InstanceIpv6AddressRequest =
  struct
    type t =
      {
      ipv6_address: String.t option [@ocaml.doc "<p>The IPv6 address.</p>"]}
    [@@ocaml.doc "<p>Describes an IPv6 address.</p>"]
    let make ?ipv6_address  () = { ipv6_address }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> Query.Pair ("Ipv6Address", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> ("ipv6_address", (String.to_json f)))])
    let parse xml =
      Some
        {
          ipv6_address =
            (Util.option_bind (Xml.member "Ipv6Address" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ipv6_address
              (fun f -> Ezxmlm.make_tag "Ipv6Address" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an IPv6 address.</p>"]
module IpRangeList =
  struct
    type t = IpRange.t list
    let make elems () = elems
    let to_query v = Query.to_query_list IpRange.to_query v
    let to_headers v = Headers.to_headers_list IpRange.to_headers v
    let to_json v = `List (List.map IpRange.to_json v)
    let parse xml =
      Util.option_all (List.map IpRange.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (IpRange.to_xml x))) v
  end
module Ipv6RangeList =
  struct
    type t = Ipv6Range.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Ipv6Range.to_query v
    let to_headers v = Headers.to_headers_list Ipv6Range.to_headers v
    let to_json v = `List (List.map Ipv6Range.to_json v)
    let parse xml =
      Util.option_all (List.map Ipv6Range.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Ipv6Range.to_xml x)))
        v
  end
module PrefixListIdList =
  struct
    type t = PrefixListId.t list
    let make elems () = elems
    let to_query v = Query.to_query_list PrefixListId.to_query v
    let to_headers v = Headers.to_headers_list PrefixListId.to_headers v
    let to_json v = `List (List.map PrefixListId.to_json v)
    let parse xml =
      Util.option_all (List.map PrefixListId.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PrefixListId.to_xml x))) v
  end
module UserIdGroupPairList =
  struct
    type t = UserIdGroupPair.t list
    let make elems () = elems
    let to_query v = Query.to_query_list UserIdGroupPair.to_query v
    let to_headers v = Headers.to_headers_list UserIdGroupPair.to_headers v
    let to_json v = `List (List.map UserIdGroupPair.to_json v)
    let parse xml =
      Util.option_all
        (List.map UserIdGroupPair.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (UserIdGroupPair.to_xml x)))
        v
  end
module AssociatedNetworkType =
  struct
    type t =
      | Vpc 
    let str_to_t = [("vpc", Vpc)]
    let t_to_str = [(Vpc, "vpc")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module CertificateAuthentication =
  struct
    type t =
      {
      client_root_certificate_chain: String.t option
        [@ocaml.doc "<p>The ARN of the client certificate. </p>"]}[@@ocaml.doc
                                                                    "<p>Information about the client certificate used for authentication.</p>"]
    let make ?client_root_certificate_chain  () =
      { client_root_certificate_chain }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_root_certificate_chain
              (fun f ->
                 Query.Pair
                   ("ClientRootCertificateChain", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_root_certificate_chain
              (fun f -> ("client_root_certificate_chain", (String.to_json f)))])
    let parse xml =
      Some
        {
          client_root_certificate_chain =
            (Util.option_bind (Xml.member "clientRootCertificateChain" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.client_root_certificate_chain
              (fun f ->
                 Ezxmlm.make_tag "clientRootCertificateChain"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Information about the client certificate used for authentication.</p>"]
module ClientVpnAuthenticationType =
  struct
    type t =
      | Certificate_authentication 
      | Directory_service_authentication 
    let str_to_t =
      [("directory-service-authentication", Directory_service_authentication);
      ("certificate-authentication", Certificate_authentication)]
    let t_to_str =
      [(Directory_service_authentication, "directory-service-authentication");
      (Certificate_authentication, "certificate-authentication")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module DirectoryServiceAuthentication =
  struct
    type t =
      {
      directory_id: String.t option
        [@ocaml.doc
          "<p>The ID of the Active Directory used for authentication.</p>"]}
    [@@ocaml.doc "<p>Describes an Active Directory.</p>"]
    let make ?directory_id  () = { directory_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.directory_id
              (fun f -> Query.Pair ("DirectoryId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.directory_id
              (fun f -> ("directory_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          directory_id =
            (Util.option_bind (Xml.member "directoryId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.directory_id
              (fun f -> Ezxmlm.make_tag "directoryId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an Active Directory.</p>"]
module Placement =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc
          "<p>The Availability Zone of the instance.</p> <p>If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.</p>"];
      affinity: String.t option
        [@ocaml.doc
          "<p>The affinity setting for the instance on the Dedicated Host. This parameter is not supported for the <a>ImportInstance</a> command.</p>"];
      group_name: String.t option
        [@ocaml.doc
          "<p>The name of the placement group the instance is in.</p>"];
      partition_number: Integer.t option
        [@ocaml.doc
          "<p>The number of the partition the instance is in. Valid only if the placement group strategy is set to <code>partition</code>.</p>"];
      host_id: String.t option
        [@ocaml.doc
          "<p>The ID of the Dedicated Host on which the instance resides. This parameter is not supported for the <a>ImportInstance</a> command.</p>"];
      tenancy: Tenancy.t option
        [@ocaml.doc
          "<p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware. The <code>host</code> tenancy is not supported for the <a>ImportInstance</a> command.</p>"];
      spread_domain: String.t option
        [@ocaml.doc "<p>Reserved for future use.</p>"];
      host_resource_group_arn: String.t option
        [@ocaml.doc
          "<p>The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the <b>Tenancy</b> parameter or set it to <code>host</code>.</p>"]}
    [@@ocaml.doc "<p>Describes the placement of an instance.</p>"]
    let make ?availability_zone  ?affinity  ?group_name  ?partition_number 
      ?host_id  ?tenancy  ?spread_domain  ?host_resource_group_arn  () =
      {
        availability_zone;
        affinity;
        group_name;
        partition_number;
        host_id;
        tenancy;
        spread_domain;
        host_resource_group_arn
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f ->
                 Query.Pair ("HostResourceGroupArn", (String.to_query f)));
           Util.option_map v.spread_domain
             (fun f -> Query.Pair ("SpreadDomain", (String.to_query f)));
           Util.option_map v.tenancy
             (fun f -> Query.Pair ("Tenancy", (Tenancy.to_query f)));
           Util.option_map v.host_id
             (fun f -> Query.Pair ("HostId", (String.to_query f)));
           Util.option_map v.partition_number
             (fun f -> Query.Pair ("PartitionNumber", (Integer.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.affinity
             (fun f -> Query.Pair ("Affinity", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f -> ("host_resource_group_arn", (String.to_json f)));
           Util.option_map v.spread_domain
             (fun f -> ("spread_domain", (String.to_json f)));
           Util.option_map v.tenancy
             (fun f -> ("tenancy", (Tenancy.to_json f)));
           Util.option_map v.host_id
             (fun f -> ("host_id", (String.to_json f)));
           Util.option_map v.partition_number
             (fun f -> ("partition_number", (Integer.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.affinity
             (fun f -> ("affinity", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          affinity =
            (Util.option_bind (Xml.member "affinity" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          partition_number =
            (Util.option_bind (Xml.member "partitionNumber" xml)
               Integer.parse);
          host_id = (Util.option_bind (Xml.member "hostId" xml) String.parse);
          tenancy =
            (Util.option_bind (Xml.member "tenancy" xml) Tenancy.parse);
          spread_domain =
            (Util.option_bind (Xml.member "spreadDomain" xml) String.parse);
          host_resource_group_arn =
            (Util.option_bind (Xml.member "hostResourceGroupArn" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.availability_zone
                     (fun f ->
                        Ezxmlm.make_tag "availabilityZone"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.affinity
                    (fun f ->
                       Ezxmlm.make_tag "affinity" ([], (String.to_xml f)))])
                @
                [Util.option_map v.group_name
                   (fun f ->
                      Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
               @
               [Util.option_map v.partition_number
                  (fun f ->
                     Ezxmlm.make_tag "partitionNumber"
                       ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.host_id
                 (fun f -> Ezxmlm.make_tag "hostId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.tenancy
                (fun f -> Ezxmlm.make_tag "tenancy" ([], (Tenancy.to_xml f)))])
            @
            [Util.option_map v.spread_domain
               (fun f ->
                  Ezxmlm.make_tag "spreadDomain" ([], (String.to_xml f)))])
           @
           [Util.option_map v.host_resource_group_arn
              (fun f ->
                 Ezxmlm.make_tag "hostResourceGroupArn"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the placement of an instance.</p>"]
module InstanceLifecycle =
  struct
    type t =
      | Spot 
      | On_demand 
    let str_to_t = [("on-demand", On_demand); ("spot", Spot)]
    let t_to_str = [(On_demand, "on-demand"); (Spot, "spot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module LaunchTemplateAndOverridesResponse =
  struct
    type t =
      {
      launch_template_specification:
        FleetLaunchTemplateSpecification.t option
        [@ocaml.doc "<p>The launch template.</p>"];
      overrides: FleetLaunchTemplateOverrides.t option
        [@ocaml.doc
          "<p>Any parameters that you specify override the same parameters in the launch template.</p>"]}
    [@@ocaml.doc "<p>Describes a launch template and overrides.</p>"]
    let make ?launch_template_specification  ?overrides  () =
      { launch_template_specification; overrides }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.overrides
              (fun f ->
                 Query.Pair
                   ("Overrides", (FleetLaunchTemplateOverrides.to_query f)));
           Util.option_map v.launch_template_specification
             (fun f ->
                Query.Pair
                  ("LaunchTemplateSpecification",
                    (FleetLaunchTemplateSpecification.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.overrides
              (fun f ->
                 ("overrides", (FleetLaunchTemplateOverrides.to_json f)));
           Util.option_map v.launch_template_specification
             (fun f ->
                ("launch_template_specification",
                  (FleetLaunchTemplateSpecification.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_specification =
            (Util.option_bind (Xml.member "launchTemplateSpecification" xml)
               FleetLaunchTemplateSpecification.parse);
          overrides =
            (Util.option_bind (Xml.member "overrides" xml)
               FleetLaunchTemplateOverrides.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.launch_template_specification
               (fun f ->
                  Ezxmlm.make_tag "launchTemplateSpecification"
                    ([], (FleetLaunchTemplateSpecification.to_xml f)))])
           @
           [Util.option_map v.overrides
              (fun f ->
                 Ezxmlm.make_tag "overrides"
                   ([], (FleetLaunchTemplateOverrides.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a launch template and overrides.</p>"]
module InstanceIdsSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module PlatformValues =
  struct
    type t =
      | Windows 
    let str_to_t = [("Windows", Windows)]
    let t_to_str = [(Windows, "Windows")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module FleetLaunchTemplateOverridesList =
  struct
    type t = FleetLaunchTemplateOverrides.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list FleetLaunchTemplateOverrides.to_query v
    let to_headers v =
      Headers.to_headers_list FleetLaunchTemplateOverrides.to_headers v
    let to_json v = `List (List.map FleetLaunchTemplateOverrides.to_json v)
    let parse xml =
      Util.option_all
        (List.map FleetLaunchTemplateOverrides.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (FleetLaunchTemplateOverrides.to_xml x))) v
  end
module FleetCapacityReservationUsageStrategy =
  struct
    type t =
      | Use_capacity_reservations_first 
    let str_to_t =
      [("use-capacity-reservations-first", Use_capacity_reservations_first)]
    let t_to_str =
      [(Use_capacity_reservations_first, "use-capacity-reservations-first")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module SpotFleetLaunchSpecification =
  struct
    type t =
      {
      security_groups: GroupIdentifierList.t
        [@ocaml.doc
          "<p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>"];
      addressing_type: String.t option [@ocaml.doc "<p>Deprecated.</p>"];
      block_device_mappings: BlockDeviceMappingList.t
        [@ocaml.doc
          "<p>One or more block devices that are mapped to the Spot Instances. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.</p>"];
      ebs_optimized: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p> <p>Default: <code>false</code> </p>"];
      iam_instance_profile: IamInstanceProfileSpecification.t option
        [@ocaml.doc "<p>The IAM instance profile.</p>"];
      image_id: String.t option [@ocaml.doc "<p>The ID of the AMI.</p>"];
      instance_type: InstanceType.t option
        [@ocaml.doc "<p>The instance type.</p>"];
      kernel_id: String.t option [@ocaml.doc "<p>The ID of the kernel.</p>"];
      key_name: String.t option
        [@ocaml.doc "<p>The name of the key pair.</p>"];
      monitoring: SpotFleetMonitoring.t option
        [@ocaml.doc "<p>Enable or disable monitoring for the instances.</p>"];
      network_interfaces: InstanceNetworkInterfaceSpecificationList.t
        [@ocaml.doc
          "<p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p>"];
      placement: SpotPlacement.t option
        [@ocaml.doc "<p>The placement information.</p>"];
      ramdisk_id: String.t option
        [@ocaml.doc
          "<p>The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the AWS Resource Center and search for the kernel ID.</p>"];
      spot_price: String.t option
        [@ocaml.doc
          "<p>The maximum price per unit hour that you are willing to pay for a Spot Instance. If this value is not specified, the default is the Spot price specified for the fleet. To determine the Spot price per unit hour, divide the Spot price by the value of <code>WeightedCapacity</code>.</p>"];
      subnet_id: String.t option
        [@ocaml.doc
          "<p>The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate them using commas; for example, \"subnet-1234abcdeexample1, subnet-0987cdef6example2\".</p>"];
      user_data: String.t option
        [@ocaml.doc
          "<p>The Base64-encoded user data that instances use when starting up.</p>"];
      weighted_capacity: Double.t option
        [@ocaml.doc
          "<p>The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.</p> <p>If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.</p>"];
      tag_specifications: SpotFleetTagSpecificationList.t
        [@ocaml.doc "<p>The tags to apply during creation.</p>"]}[@@ocaml.doc
                                                                   "<p>Describes the launch specification for one or more Spot Instances. If you include On-Demand capacity in your fleet request, you can't use <code>SpotFleetLaunchSpecification</code>; you must use <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_LaunchTemplateConfig.html\">LaunchTemplateConfig</a>.</p>"]
    let make ?(security_groups= [])  ?addressing_type 
      ?(block_device_mappings= [])  ?ebs_optimized  ?iam_instance_profile 
      ?image_id  ?instance_type  ?kernel_id  ?key_name  ?monitoring 
      ?(network_interfaces= [])  ?placement  ?ramdisk_id  ?spot_price 
      ?subnet_id  ?user_data  ?weighted_capacity  ?(tag_specifications= []) 
      () =
      {
        security_groups;
        addressing_type;
        block_device_mappings;
        ebs_optimized;
        iam_instance_profile;
        image_id;
        instance_type;
        kernel_id;
        key_name;
        monitoring;
        network_interfaces;
        placement;
        ramdisk_id;
        spot_price;
        subnet_id;
        user_data;
        weighted_capacity;
        tag_specifications
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecificationSet",
                   (SpotFleetTagSpecificationList.to_query
                      v.tag_specifications)));
           Util.option_map v.weighted_capacity
             (fun f -> Query.Pair ("WeightedCapacity", (Double.to_query f)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (SpotPlacement.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (InstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair ("Monitoring", (SpotFleetMonitoring.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (IamInstanceProfileSpecification.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Util.option_map v.addressing_type
             (fun f -> Query.Pair ("AddressingType", (String.to_query f)));
           Some
             (Query.Pair
                ("GroupSet",
                  (GroupIdentifierList.to_query v.security_groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (SpotFleetTagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.weighted_capacity
             (fun f -> ("weighted_capacity", (Double.to_json f)));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (SpotPlacement.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Util.option_map v.monitoring
             (fun f -> ("monitoring", (SpotFleetMonitoring.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (IamInstanceProfileSpecification.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings));
           Util.option_map v.addressing_type
             (fun f -> ("addressing_type", (String.to_json f)));
           Some
             ("security_groups",
               (GroupIdentifierList.to_json v.security_groups))])
    let parse xml =
      Some
        {
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          addressing_type =
            (Util.option_bind (Xml.member "addressingType" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml)
               SpotFleetMonitoring.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  InstanceNetworkInterfaceSpecificationList.parse));
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               SpotPlacement.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml) String.parse);
          weighted_capacity =
            (Util.option_bind (Xml.member "weightedCapacity" xml)
               Double.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSpecificationSet" xml)
                  SpotFleetTagSpecificationList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((([] @
                            (List.map
                               (fun x ->
                                  Some
                                    (Ezxmlm.make_tag "groupSet"
                                       ([], (GroupIdentifierList.to_xml [x]))))
                               v.security_groups))
                           @
                           [Util.option_map v.addressing_type
                              (fun f ->
                                 Ezxmlm.make_tag "addressingType"
                                   ([], (String.to_xml f)))])
                          @
                          (List.map
                             (fun x ->
                                Some
                                  (Ezxmlm.make_tag "blockDeviceMapping"
                                     ([],
                                       (BlockDeviceMappingList.to_xml [x]))))
                             v.block_device_mappings))
                         @
                         [Util.option_map v.ebs_optimized
                            (fun f ->
                               Ezxmlm.make_tag "ebsOptimized"
                                 ([], (Boolean.to_xml f)))])
                        @
                        [Util.option_map v.iam_instance_profile
                           (fun f ->
                              Ezxmlm.make_tag "iamInstanceProfile"
                                ([],
                                  (IamInstanceProfileSpecification.to_xml f)))])
                       @
                       [Util.option_map v.image_id
                          (fun f ->
                             Ezxmlm.make_tag "imageId"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.instance_type
                         (fun f ->
                            Ezxmlm.make_tag "instanceType"
                              ([], (InstanceType.to_xml f)))])
                     @
                     [Util.option_map v.kernel_id
                        (fun f ->
                           Ezxmlm.make_tag "kernelId" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.key_name
                       (fun f ->
                          Ezxmlm.make_tag "keyName" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.monitoring
                      (fun f ->
                         Ezxmlm.make_tag "monitoring"
                           ([], (SpotFleetMonitoring.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "networkInterfaceSet"
                             ([],
                               (InstanceNetworkInterfaceSpecificationList.to_xml
                                  [x])))) v.network_interfaces))
                 @
                 [Util.option_map v.placement
                    (fun f ->
                       Ezxmlm.make_tag "placement"
                         ([], (SpotPlacement.to_xml f)))])
                @
                [Util.option_map v.ramdisk_id
                   (fun f ->
                      Ezxmlm.make_tag "ramdiskId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.spot_price
                  (fun f ->
                     Ezxmlm.make_tag "spotPrice" ([], (String.to_xml f)))])
              @
              [Util.option_map v.subnet_id
                 (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.user_data
                (fun f -> Ezxmlm.make_tag "userData" ([], (String.to_xml f)))])
            @
            [Util.option_map v.weighted_capacity
               (fun f ->
                  Ezxmlm.make_tag "weightedCapacity" ([], (Double.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "tagSpecificationSet"
                      ([], (SpotFleetTagSpecificationList.to_xml [x]))))
              v.tag_specifications))
  end[@@ocaml.doc
       "<p>Describes the launch specification for one or more Spot Instances. If you include On-Demand capacity in your fleet request, you can't use <code>SpotFleetLaunchSpecification</code>; you must use <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_LaunchTemplateConfig.html\">LaunchTemplateConfig</a>.</p>"]
module LaunchTemplateConfig =
  struct
    type t =
      {
      launch_template_specification:
        FleetLaunchTemplateSpecification.t option
        [@ocaml.doc "<p>The launch template.</p>"];
      overrides: LaunchTemplateOverridesList.t
        [@ocaml.doc
          "<p>Any parameters that you specify override the same parameters in the launch template.</p>"]}
    [@@ocaml.doc "<p>Describes a launch template and overrides.</p>"]
    let make ?launch_template_specification  ?(overrides= [])  () =
      { launch_template_specification; overrides }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Overrides",
                   (LaunchTemplateOverridesList.to_query v.overrides)));
           Util.option_map v.launch_template_specification
             (fun f ->
                Query.Pair
                  ("LaunchTemplateSpecification",
                    (FleetLaunchTemplateSpecification.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("overrides",
                (LaunchTemplateOverridesList.to_json v.overrides));
           Util.option_map v.launch_template_specification
             (fun f ->
                ("launch_template_specification",
                  (FleetLaunchTemplateSpecification.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_specification =
            (Util.option_bind (Xml.member "launchTemplateSpecification" xml)
               FleetLaunchTemplateSpecification.parse);
          overrides =
            (Util.of_option []
               (Util.option_bind (Xml.member "overrides" xml)
                  LaunchTemplateOverridesList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.launch_template_specification
               (fun f ->
                  Ezxmlm.make_tag "launchTemplateSpecification"
                    ([], (FleetLaunchTemplateSpecification.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "overrides"
                      ([], (LaunchTemplateOverridesList.to_xml [x]))))
              v.overrides))
  end[@@ocaml.doc "<p>Describes a launch template and overrides.</p>"]
module ClassicLoadBalancersConfig =
  struct
    type t =
      {
      classic_load_balancers: ClassicLoadBalancers.t
        [@ocaml.doc "<p>One or more Classic Load Balancers.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes the Classic Load Balancers to attach to a Spot Fleet. Spot Fleet registers the running Spot Instances with these Classic Load Balancers.</p>"]
    let make ?(classic_load_balancers= [])  () = { classic_load_balancers }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ClassicLoadBalancers",
                   (ClassicLoadBalancers.to_query v.classic_load_balancers)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("classic_load_balancers",
                (ClassicLoadBalancers.to_json v.classic_load_balancers))])
    let parse xml =
      Some
        {
          classic_load_balancers =
            (Util.of_option []
               (Util.option_bind (Xml.member "classicLoadBalancers" xml)
                  ClassicLoadBalancers.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "classicLoadBalancers"
                      ([], (ClassicLoadBalancers.to_xml [x]))))
              v.classic_load_balancers))
  end[@@ocaml.doc
       "<p>Describes the Classic Load Balancers to attach to a Spot Fleet. Spot Fleet registers the running Spot Instances with these Classic Load Balancers.</p>"]
module TargetGroupsConfig =
  struct
    type t =
      {
      target_groups: TargetGroups.t
        [@ocaml.doc "<p>One or more target groups.</p>"]}[@@ocaml.doc
                                                           "<p>Describes the target groups to attach to a Spot Fleet. Spot Fleet registers the running Spot Instances with these target groups.</p>"]
    let make ?(target_groups= [])  () = { target_groups }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TargetGroups", (TargetGroups.to_query v.target_groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("target_groups", (TargetGroups.to_json v.target_groups))])
    let parse xml =
      Some
        {
          target_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "targetGroups" xml)
                  TargetGroups.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "targetGroups"
                      ([], (TargetGroups.to_xml [x])))) v.target_groups))
  end[@@ocaml.doc
       "<p>Describes the target groups to attach to a Spot Fleet. Spot Fleet registers the running Spot Instances with these target groups.</p>"]
module VolumeStatusDetails =
  struct
    type t =
      {
      name: VolumeStatusName.t option
        [@ocaml.doc "<p>The name of the volume status.</p>"];
      status: String.t option
        [@ocaml.doc "<p>The intended status of the volume status.</p>"]}
    [@@ocaml.doc "<p>Describes a volume status.</p>"]
    let make ?name  ?status  () = { name; status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (VolumeStatusName.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (String.to_json f)));
           Util.option_map v.name
             (fun f -> ("name", (VolumeStatusName.to_json f)))])
    let parse xml =
      Some
        {
          name =
            (Util.option_bind (Xml.member "name" xml) VolumeStatusName.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.name
               (fun f ->
                  Ezxmlm.make_tag "name" ([], (VolumeStatusName.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a volume status.</p>"]
module ArchitectureValues =
  struct
    type t =
      | I386 
      | X86_64 
      | Arm64 
    let str_to_t = [("arm64", Arm64); ("x86_64", X86_64); ("i386", I386)]
    let t_to_str = [(Arm64, "arm64"); (X86_64, "x86_64"); (I386, "i386")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module CapacityReservationSpecificationResponse =
  struct
    type t =
      {
      capacity_reservation_preference: CapacityReservationPreference.t option
        [@ocaml.doc
          "<p>Describes the instance's Capacity Reservation preferences. Possible preferences include:</p> <ul> <li> <p> <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).</p> </li> <li> <p> <code>none</code> - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.</p> </li> </ul>"];
      capacity_reservation_target: CapacityReservationTargetResponse.t option
        [@ocaml.doc
          "<p>Information about the targeted Capacity Reservation.</p>"]}
    [@@ocaml.doc
      "<p>Describes the instance's Capacity Reservation targeting preferences. The action returns the <code>capacityReservationPreference</code> response element if the instance is configured to run in On-Demand capacity, or if it is configured in run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). The action returns the <code>capacityReservationTarget</code> response element if the instance explicily targets a specific Capacity Reservation.</p>"]
    let make ?capacity_reservation_preference  ?capacity_reservation_target 
      () = { capacity_reservation_preference; capacity_reservation_target }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Query.Pair
                   ("CapacityReservationTarget",
                     (CapacityReservationTargetResponse.to_query f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                Query.Pair
                  ("CapacityReservationPreference",
                    (CapacityReservationPreference.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 ("capacity_reservation_target",
                   (CapacityReservationTargetResponse.to_json f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                ("capacity_reservation_preference",
                  (CapacityReservationPreference.to_json f)))])
    let parse xml =
      Some
        {
          capacity_reservation_preference =
            (Util.option_bind
               (Xml.member "capacityReservationPreference" xml)
               CapacityReservationPreference.parse);
          capacity_reservation_target =
            (Util.option_bind (Xml.member "capacityReservationTarget" xml)
               CapacityReservationTargetResponse.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.capacity_reservation_preference
               (fun f ->
                  Ezxmlm.make_tag "capacityReservationPreference"
                    ([], (CapacityReservationPreference.to_xml f)))])
           @
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Ezxmlm.make_tag "capacityReservationTarget"
                   ([], (CapacityReservationTargetResponse.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the instance's Capacity Reservation targeting preferences. The action returns the <code>capacityReservationPreference</code> response element if the instance is configured to run in On-Demand capacity, or if it is configured in run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). The action returns the <code>capacityReservationTarget</code> response element if the instance explicily targets a specific Capacity Reservation.</p>"]
module CpuOptions =
  struct
    type t =
      {
      core_count: Integer.t option
        [@ocaml.doc "<p>The number of CPU cores for the instance.</p>"];
      threads_per_core: Integer.t option
        [@ocaml.doc "<p>The number of threads per CPU core.</p>"]}[@@ocaml.doc
                                                                    "<p>The CPU options for the instance.</p>"]
    let make ?core_count  ?threads_per_core  () =
      { core_count; threads_per_core }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> Query.Pair ("ThreadsPerCore", (Integer.to_query f)));
           Util.option_map v.core_count
             (fun f -> Query.Pair ("CoreCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> ("threads_per_core", (Integer.to_json f)));
           Util.option_map v.core_count
             (fun f -> ("core_count", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          core_count =
            (Util.option_bind (Xml.member "coreCount" xml) Integer.parse);
          threads_per_core =
            (Util.option_bind (Xml.member "threadsPerCore" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.core_count
               (fun f -> Ezxmlm.make_tag "coreCount" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.threads_per_core
              (fun f ->
                 Ezxmlm.make_tag "threadsPerCore" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc "<p>The CPU options for the instance.</p>"]
module DeviceType =
  struct
    type t =
      | Ebs 
      | Instance_store 
    let str_to_t = [("instance-store", Instance_store); ("ebs", Ebs)]
    let t_to_str = [(Instance_store, "instance-store"); (Ebs, "ebs")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ElasticGpuAssociationList =
  struct
    type t = ElasticGpuAssociation.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ElasticGpuAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list ElasticGpuAssociation.to_headers v
    let to_json v = `List (List.map ElasticGpuAssociation.to_json v)
    let parse xml =
      Util.option_all
        (List.map ElasticGpuAssociation.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ElasticGpuAssociation.to_xml x))) v
  end
module ElasticInferenceAcceleratorAssociationList =
  struct
    type t = ElasticInferenceAcceleratorAssociation.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list ElasticInferenceAcceleratorAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list
        ElasticInferenceAcceleratorAssociation.to_headers v
    let to_json v =
      `List (List.map ElasticInferenceAcceleratorAssociation.to_json v)
    let parse xml =
      Util.option_all
        (List.map ElasticInferenceAcceleratorAssociation.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ElasticInferenceAcceleratorAssociation.to_xml x))) v
  end
module HibernationOptions =
  struct
    type t =
      {
      configured: Boolean.t option
        [@ocaml.doc
          "<p>If this parameter is set to <code>true</code>, your instance is enabled for hibernation; otherwise, it is not enabled for hibernation.</p>"]}
    [@@ocaml.doc
      "<p>Indicates whether your instance is configured for hibernation. This parameter is valid only if the instance meets the <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites\">hibernation prerequisites</a>. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html\">Hibernate Your Instance</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"]
    let make ?configured  () = { configured }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> Query.Pair ("Configured", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> ("configured", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          configured =
            (Util.option_bind (Xml.member "configured" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.configured
              (fun f -> Ezxmlm.make_tag "configured" ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc
       "<p>Indicates whether your instance is configured for hibernation. This parameter is valid only if the instance meets the <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites\">hibernation prerequisites</a>. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html\">Hibernate Your Instance</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"]
module HypervisorType =
  struct
    type t =
      | Ovm 
      | Xen 
    let str_to_t = [("xen", Xen); ("ovm", Ovm)]
    let t_to_str = [(Xen, "xen"); (Ovm, "ovm")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module IamInstanceProfile =
  struct
    type t =
      {
      arn: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the instance profile.</p>"];
      id: String.t option
        [@ocaml.doc "<p>The ID of the instance profile.</p>"]}[@@ocaml.doc
                                                                "<p>Describes an IAM instance profile.</p>"]
    let make ?arn  ?id  () = { arn; id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.id
              (fun f -> Query.Pair ("Id", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.id (fun f -> ("id", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "arn" xml) String.parse);
          id = (Util.option_bind (Xml.member "id" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.arn
               (fun f -> Ezxmlm.make_tag "arn" ([], (String.to_xml f)))])
           @
           [Util.option_map v.id
              (fun f -> Ezxmlm.make_tag "id" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an IAM instance profile.</p>"]
module InstanceBlockDeviceMappingList =
  struct
    type t = InstanceBlockDeviceMapping.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list InstanceBlockDeviceMapping.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceBlockDeviceMapping.to_headers v
    let to_json v = `List (List.map InstanceBlockDeviceMapping.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceBlockDeviceMapping.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InstanceBlockDeviceMapping.to_xml x))) v
  end
module InstanceLifecycleType =
  struct
    type t =
      | Spot 
      | Scheduled 
    let str_to_t = [("scheduled", Scheduled); ("spot", Spot)]
    let t_to_str = [(Scheduled, "scheduled"); (Spot, "spot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module InstanceMetadataOptionsResponse =
  struct
    type t =
      {
      state: InstanceMetadataOptionsState.t option
        [@ocaml.doc
          "<p>The state of the metadata option changes.</p> <p> <code>pending</code> - The metadata options are being updated and the instance is not ready to process metadata traffic with the new selection.</p> <p> <code>applied</code> - The metadata options have been successfully applied on the instance.</p>"];
      http_tokens: HttpTokensState.t option
        [@ocaml.doc
          "<p>The state of token usage for your instance metadata requests. If the parameter is not specified in the request, the default state is <code>optional</code>.</p> <p>If the state is <code>optional</code>, you can choose to retrieve instance metadata with or without a signed token header on your request. If you retrieve the IAM role credentials without a token, the version 1.0 role credentials are returned. If you retrieve the IAM role credentials using a valid signed token, the version 2.0 role credentials are returned.</p> <p>If the state is <code>required</code>, you must send a signed token header with any instance metadata retrieval requests. In this state, retrieving the IAM role credential always returns the version 2.0 credentials; the version 1.0 credentials are not available.</p>"];
      http_put_response_hop_limit: Integer.t option
        [@ocaml.doc
          "<p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.</p> <p>Default: 1</p> <p>Possible values: Integers from 1 to 64</p>"];
      http_endpoint: InstanceMetadataEndpointState.t option
        [@ocaml.doc
          "<p>This parameter enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is <code>enabled</code>.</p> <note> <p>If you specify a value of <code>disabled</code>, you will not be able to access your instance metadata.</p> </note>"]}
    [@@ocaml.doc "<p>The metadata options for the instance.</p>"]
    let make ?state  ?http_tokens  ?http_put_response_hop_limit 
      ?http_endpoint  () =
      { state; http_tokens; http_put_response_hop_limit; http_endpoint }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.http_endpoint
              (fun f ->
                 Query.Pair
                   ("HttpEndpoint",
                     (InstanceMetadataEndpointState.to_query f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f ->
                Query.Pair ("HttpPutResponseHopLimit", (Integer.to_query f)));
           Util.option_map v.http_tokens
             (fun f ->
                Query.Pair ("HttpTokens", (HttpTokensState.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (InstanceMetadataOptionsState.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.http_endpoint
              (fun f ->
                 ("http_endpoint", (InstanceMetadataEndpointState.to_json f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f -> ("http_put_response_hop_limit", (Integer.to_json f)));
           Util.option_map v.http_tokens
             (fun f -> ("http_tokens", (HttpTokensState.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (InstanceMetadataOptionsState.to_json f)))])
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml)
               InstanceMetadataOptionsState.parse);
          http_tokens =
            (Util.option_bind (Xml.member "httpTokens" xml)
               HttpTokensState.parse);
          http_put_response_hop_limit =
            (Util.option_bind (Xml.member "httpPutResponseHopLimit" xml)
               Integer.parse);
          http_endpoint =
            (Util.option_bind (Xml.member "httpEndpoint" xml)
               InstanceMetadataEndpointState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.state
                 (fun f ->
                    Ezxmlm.make_tag "state"
                      ([], (InstanceMetadataOptionsState.to_xml f)))])
             @
             [Util.option_map v.http_tokens
                (fun f ->
                   Ezxmlm.make_tag "httpTokens"
                     ([], (HttpTokensState.to_xml f)))])
            @
            [Util.option_map v.http_put_response_hop_limit
               (fun f ->
                  Ezxmlm.make_tag "httpPutResponseHopLimit"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.http_endpoint
              (fun f ->
                 Ezxmlm.make_tag "httpEndpoint"
                   ([], (InstanceMetadataEndpointState.to_xml f)))])
  end[@@ocaml.doc "<p>The metadata options for the instance.</p>"]
module InstanceNetworkInterfaceList =
  struct
    type t = InstanceNetworkInterface.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InstanceNetworkInterface.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceNetworkInterface.to_headers v
    let to_json v = `List (List.map InstanceNetworkInterface.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceNetworkInterface.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstanceNetworkInterface.to_xml x)))
        v
  end
module InstanceState =
  struct
    type t =
      {
      code: Integer.t
        [@ocaml.doc
          "<p>The state of the instance as a 16-bit unsigned integer. </p> <p>The high byte is all of the bits between 2^8 and (2^16)-1, which equals decimal values between 256 and 65,535. These numerical values are used for internal purposes and should be ignored.</p> <p>The low byte is all of the bits between 2^0 and (2^8)-1, which equals decimal values between 0 and 255. </p> <p>The valid values for instance-state-code will all be in the range of the low byte and they are:</p> <ul> <li> <p> <code>0</code> : <code>pending</code> </p> </li> <li> <p> <code>16</code> : <code>running</code> </p> </li> <li> <p> <code>32</code> : <code>shutting-down</code> </p> </li> <li> <p> <code>48</code> : <code>terminated</code> </p> </li> <li> <p> <code>64</code> : <code>stopping</code> </p> </li> <li> <p> <code>80</code> : <code>stopped</code> </p> </li> </ul> <p>You can ignore the high byte value by zeroing out all of the bits above 2^8 or 256 in decimal.</p>"];
      name: InstanceStateName.t
        [@ocaml.doc "<p>The current state of the instance.</p>"]}[@@ocaml.doc
                                                                   "<p>Describes the current state of an instance.</p>"]
    let make ~code  ~name  () = { code; name }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Name", (InstanceStateName.to_query v.name)));
           Some (Query.Pair ("Code", (Integer.to_query v.code)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("name", (InstanceStateName.to_json v.name));
           Some ("code", (Integer.to_json v.code))])
    let parse xml =
      Some
        {
          code =
            (Xml.required "code"
               (Util.option_bind (Xml.member "code" xml) Integer.parse));
          name =
            (Xml.required "name"
               (Util.option_bind (Xml.member "name" xml)
                  InstanceStateName.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "code" ([], (Integer.to_xml v.code)))])
           @
           [Some
              (Ezxmlm.make_tag "name" ([], (InstanceStateName.to_xml v.name)))])
  end[@@ocaml.doc "<p>Describes the current state of an instance.</p>"]
module LicenseList =
  struct
    type t = LicenseConfiguration.t list
    let make elems () = elems
    let to_query v = Query.to_query_list LicenseConfiguration.to_query v
    let to_headers v =
      Headers.to_headers_list LicenseConfiguration.to_headers v
    let to_json v = `List (List.map LicenseConfiguration.to_json v)
    let parse xml =
      Util.option_all
        (List.map LicenseConfiguration.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (LicenseConfiguration.to_xml x))) v
  end
module Monitoring =
  struct
    type t =
      {
      state: MonitoringState.t option
        [@ocaml.doc
          "<p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.</p>"]}
    [@@ocaml.doc "<p>Describes the monitoring of an instance.</p>"]
    let make ?state  () = { state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (MonitoringState.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (MonitoringState.to_json f)))])
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml) MonitoringState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state" ([], (MonitoringState.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the monitoring of an instance.</p>"]
module ProductCodeList =
  struct
    type t = ProductCode.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ProductCode.to_query v
    let to_headers v = Headers.to_headers_list ProductCode.to_headers v
    let to_json v = `List (List.map ProductCode.to_json v)
    let parse xml =
      Util.option_all (List.map ProductCode.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ProductCode.to_xml x))) v
  end
module StateReason =
  struct
    type t =
      {
      code: String.t option
        [@ocaml.doc "<p>The reason code for the state change.</p>"];
      message: String.t option
        [@ocaml.doc
          "<p>The message for the state change.</p> <ul> <li> <p> <code>Server.InsufficientInstanceCapacity</code>: There was insufficient capacity available to satisfy the launch request.</p> </li> <li> <p> <code>Server.InternalError</code>: An internal error caused the instance to terminate during launch.</p> </li> <li> <p> <code>Server.ScheduledStop</code>: The instance was stopped due to a scheduled retirement.</p> </li> <li> <p> <code>Server.SpotInstanceShutdown</code>: The instance was stopped because the number of Spot requests with a maximum price equal to or higher than the Spot price exceeded available capacity or because of an increase in the Spot price.</p> </li> <li> <p> <code>Server.SpotInstanceTermination</code>: The instance was terminated because the number of Spot requests with a maximum price equal to or higher than the Spot price exceeded available capacity or because of an increase in the Spot price.</p> </li> <li> <p> <code>Client.InstanceInitiatedShutdown</code>: The instance was shut down using the <code>shutdown -h</code> command from the instance.</p> </li> <li> <p> <code>Client.InstanceTerminated</code>: The instance was terminated or rebooted during AMI creation.</p> </li> <li> <p> <code>Client.InternalError</code>: A client error caused the instance to terminate during launch.</p> </li> <li> <p> <code>Client.InvalidSnapshot.NotFound</code>: The specified snapshot was not found.</p> </li> <li> <p> <code>Client.UserInitiatedHibernate</code>: Hibernation was initiated on the instance.</p> </li> <li> <p> <code>Client.UserInitiatedShutdown</code>: The instance was shut down using the Amazon EC2 API.</p> </li> <li> <p> <code>Client.VolumeLimitExceeded</code>: The limit on the number of EBS volumes or total storage was exceeded. Decrease usage or request an increase in your account limits.</p> </li> </ul>"]}
    [@@ocaml.doc "<p>Describes a state change.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a state change.</p>"]
module VirtualizationType =
  struct
    type t =
      | Hvm 
      | Paravirtual 
    let str_to_t = [("paravirtual", Paravirtual); ("hvm", Hvm)]
    let t_to_str = [(Paravirtual, "paravirtual"); (Hvm, "hvm")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module VpcCidrBlockState =
  struct
    type t =
      {
      state: VpcCidrBlockStateCode.t option
        [@ocaml.doc "<p>The state of the CIDR block.</p>"];
      status_message: String.t option
        [@ocaml.doc
          "<p>A message about the status of the CIDR block, if applicable.</p>"]}
    [@@ocaml.doc "<p>Describes the state of a CIDR block.</p>"]
    let make ?state  ?status_message  () = { state; status_message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (VpcCidrBlockStateCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (VpcCidrBlockStateCode.to_json f)))])
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml)
               VpcCidrBlockStateCode.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.state
               (fun f ->
                  Ezxmlm.make_tag "state"
                    ([], (VpcCidrBlockStateCode.to_xml f)))])
           @
           [Util.option_map v.status_message
              (fun f ->
                 Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the state of a CIDR block.</p>"]
module SubnetCidrBlockState =
  struct
    type t =
      {
      state: SubnetCidrBlockStateCode.t option
        [@ocaml.doc "<p>The state of a CIDR block.</p>"];
      status_message: String.t option
        [@ocaml.doc
          "<p>A message about the status of the CIDR block, if applicable.</p>"]}
    [@@ocaml.doc "<p>Describes the state of a CIDR block.</p>"]
    let make ?state  ?status_message  () = { state; status_message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (SubnetCidrBlockStateCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (SubnetCidrBlockStateCode.to_json f)))])
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml)
               SubnetCidrBlockStateCode.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.state
               (fun f ->
                  Ezxmlm.make_tag "state"
                    ([], (SubnetCidrBlockStateCode.to_xml f)))])
           @
           [Util.option_map v.status_message
              (fun f ->
                 Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the state of a CIDR block.</p>"]
module UserBucketDetails =
  struct
    type t =
      {
      s3_bucket: String.t option
        [@ocaml.doc
          "<p>The S3 bucket from which the disk image was created.</p>"];
      s3_key: String.t option
        [@ocaml.doc "<p>The file name of the disk image.</p>"]}[@@ocaml.doc
                                                                 "<p>Describes the S3 bucket for the disk image.</p>"]
    let make ?s3_bucket  ?s3_key  () = { s3_bucket; s3_key }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> Query.Pair ("S3Key", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> ("s3_key", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)))])
    let parse xml =
      Some
        {
          s3_bucket =
            (Util.option_bind (Xml.member "s3Bucket" xml) String.parse);
          s3_key = (Util.option_bind (Xml.member "s3Key" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.s3_bucket
               (fun f -> Ezxmlm.make_tag "s3Bucket" ([], (String.to_xml f)))])
           @
           [Util.option_map v.s3_key
              (fun f -> Ezxmlm.make_tag "s3Key" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the S3 bucket for the disk image.</p>"]
module ScheduledInstancesPrivateIpAddressConfig =
  struct
    type t =
      {
      primary: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether this is a primary IPv4 address. Otherwise, this is a secondary IPv4 address.</p>"];
      private_ip_address: String.t option
        [@ocaml.doc "<p>The IPv4 address.</p>"]}[@@ocaml.doc
                                                  "<p>Describes a private IPv4 address for a Scheduled Instance.</p>"]
    let make ?primary  ?private_ip_address  () =
      { primary; private_ip_address }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.primary
             (fun f -> Query.Pair ("Primary", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.primary
             (fun f -> ("primary", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          primary =
            (Util.option_bind (Xml.member "Primary" xml) Boolean.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "PrivateIpAddress" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.primary
               (fun f -> Ezxmlm.make_tag "Primary" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.private_ip_address
              (fun f ->
                 Ezxmlm.make_tag "PrivateIpAddress" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a private IPv4 address for a Scheduled Instance.</p>"]
module ScheduledInstancesIpv6Address =
  struct
    type t =
      {
      ipv6_address: String.t option [@ocaml.doc "<p>The IPv6 address.</p>"]}
    [@@ocaml.doc "<p>Describes an IPv6 address.</p>"]
    let make ?ipv6_address  () = { ipv6_address }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> Query.Pair ("Ipv6Address", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> ("ipv6_address", (String.to_json f)))])
    let parse xml =
      Some
        {
          ipv6_address =
            (Util.option_bind (Xml.member "Ipv6Address" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ipv6_address
              (fun f -> Ezxmlm.make_tag "Ipv6Address" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an IPv6 address.</p>"]
module DhcpConfiguration =
  struct
    type t =
      {
      key: String.t option [@ocaml.doc "<p>The name of a DHCP option.</p>"];
      values: DhcpConfigurationValueList.t
        [@ocaml.doc "<p>One or more values for the DHCP option.</p>"]}
    [@@ocaml.doc "<p>Describes a DHCP configuration option.</p>"]
    let make ?key  ?(values= [])  () = { key; values }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ValueSet", (DhcpConfigurationValueList.to_query v.values)));
           Util.option_map v.key
             (fun f -> Query.Pair ("Key", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (DhcpConfigurationValueList.to_json v.values));
           Util.option_map v.key (fun f -> ("key", (String.to_json f)))])
    let parse xml =
      Some
        {
          key = (Util.option_bind (Xml.member "key" xml) String.parse);
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "valueSet" xml)
                  DhcpConfigurationValueList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.key
               (fun f -> Ezxmlm.make_tag "key" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "valueSet"
                      ([], (DhcpConfigurationValueList.to_xml [x]))))
              v.values))
  end[@@ocaml.doc "<p>Describes a DHCP configuration option.</p>"]
module VpcAttachment =
  struct
    type t =
      {
      state: AttachmentStatus.t option
        [@ocaml.doc "<p>The current state of the attachment.</p>"];
      vpc_id: String.t option [@ocaml.doc "<p>The ID of the VPC.</p>"]}
    [@@ocaml.doc
      "<p>Describes an attachment between a virtual private gateway and a VPC.</p>"]
    let make ?state  ?vpc_id  () = { state; vpc_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (AttachmentStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (AttachmentStatus.to_json f)))])
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml) AttachmentStatus.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.state
               (fun f ->
                  Ezxmlm.make_tag "state" ([], (AttachmentStatus.to_xml f)))])
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an attachment between a virtual private gateway and a VPC.</p>"]
module ReservedInstancesModificationResult =
  struct
    type t =
      {
      reserved_instances_id: String.t option
        [@ocaml.doc
          "<p>The ID for the Reserved Instances that were created as part of the modification request. This field is only available when the modification is fulfilled.</p>"];
      target_configuration: ReservedInstancesConfiguration.t option
        [@ocaml.doc
          "<p>The target Reserved Instances configurations supplied as part of the modification request.</p>"]}
    [@@ocaml.doc "<p>Describes the modification request/s.</p>"]
    let make ?reserved_instances_id  ?target_configuration  () =
      { reserved_instances_id; target_configuration }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.target_configuration
              (fun f ->
                 Query.Pair
                   ("TargetConfiguration",
                     (ReservedInstancesConfiguration.to_query f)));
           Util.option_map v.reserved_instances_id
             (fun f ->
                Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_configuration
              (fun f ->
                 ("target_configuration",
                   (ReservedInstancesConfiguration.to_json f)));
           Util.option_map v.reserved_instances_id
             (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse);
          target_configuration =
            (Util.option_bind (Xml.member "targetConfiguration" xml)
               ReservedInstancesConfiguration.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.reserved_instances_id
               (fun f ->
                  Ezxmlm.make_tag "reservedInstancesId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.target_configuration
              (fun f ->
                 Ezxmlm.make_tag "targetConfiguration"
                   ([], (ReservedInstancesConfiguration.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the modification request/s.</p>"]
module ReservedInstancesId =
  struct
    type t =
      {
      reserved_instances_id: String.t option
        [@ocaml.doc "<p>The ID of the Reserved Instance.</p>"]}[@@ocaml.doc
                                                                 "<p>Describes the ID of a Reserved Instance.</p>"]
    let make ?reserved_instances_id  () = { reserved_instances_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Ezxmlm.make_tag "reservedInstancesId"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the ID of a Reserved Instance.</p>"]
module PermissionGroup =
  struct
    type t =
      | All 
    let str_to_t = [("all", All)]
    let t_to_str = [(All, "all")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module DnsEntry =
  struct
    type t =
      {
      dns_name: String.t option [@ocaml.doc "<p>The DNS name.</p>"];
      hosted_zone_id: String.t option
        [@ocaml.doc "<p>The ID of the private hosted zone.</p>"]}[@@ocaml.doc
                                                                   "<p>Describes a DNS entry.</p>"]
    let make ?dns_name  ?hosted_zone_id  () = { dns_name; hosted_zone_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.hosted_zone_id
              (fun f -> Query.Pair ("HostedZoneId", (String.to_query f)));
           Util.option_map v.dns_name
             (fun f -> Query.Pair ("DnsName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.hosted_zone_id
              (fun f -> ("hosted_zone_id", (String.to_json f)));
           Util.option_map v.dns_name
             (fun f -> ("dns_name", (String.to_json f)))])
    let parse xml =
      Some
        {
          dns_name =
            (Util.option_bind (Xml.member "dnsName" xml) String.parse);
          hosted_zone_id =
            (Util.option_bind (Xml.member "hostedZoneId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dns_name
               (fun f -> Ezxmlm.make_tag "dnsName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.hosted_zone_id
              (fun f ->
                 Ezxmlm.make_tag "hostedZoneId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a DNS entry.</p>"]
module TrafficMirrorFilterRule =
  struct
    type t =
      {
      traffic_mirror_filter_rule_id: String.t option
        [@ocaml.doc "<p>The ID of the Traffic Mirror rule.</p>"];
      traffic_mirror_filter_id: String.t option
        [@ocaml.doc
          "<p>The ID of the Traffic Mirror filter that the rule is associated with.</p>"];
      traffic_direction: TrafficDirection.t option
        [@ocaml.doc
          "<p>The traffic direction assigned to the Traffic Mirror rule.</p>"];
      rule_number: Integer.t option
        [@ocaml.doc "<p>The rule number of the Traffic Mirror rule.</p>"];
      rule_action: TrafficMirrorRuleAction.t option
        [@ocaml.doc "<p>The action assigned to the Traffic Mirror rule.</p>"];
      protocol: Integer.t option
        [@ocaml.doc
          "<p>The protocol assigned to the Traffic Mirror rule.</p>"];
      destination_port_range: TrafficMirrorPortRange.t option
        [@ocaml.doc
          "<p>The destination port range assigned to the Traffic Mirror rule.</p>"];
      source_port_range: TrafficMirrorPortRange.t option
        [@ocaml.doc
          "<p>The source port range assigned to the Traffic Mirror rule.</p>"];
      destination_cidr_block: String.t option
        [@ocaml.doc
          "<p>The destination CIDR block assigned to the Traffic Mirror rule.</p>"];
      source_cidr_block: String.t option
        [@ocaml.doc
          "<p>The source CIDR block assigned to the Traffic Mirror rule.</p>"];
      description: String.t option
        [@ocaml.doc "<p>The description of the Traffic Mirror rule.</p>"]}
    [@@ocaml.doc "<p>Describes the Traffic Mirror rule.</p>"]
    let make ?traffic_mirror_filter_rule_id  ?traffic_mirror_filter_id 
      ?traffic_direction  ?rule_number  ?rule_action  ?protocol 
      ?destination_port_range  ?source_port_range  ?destination_cidr_block 
      ?source_cidr_block  ?description  () =
      {
        traffic_mirror_filter_rule_id;
        traffic_mirror_filter_id;
        traffic_direction;
        rule_number;
        rule_action;
        protocol;
        destination_port_range;
        source_port_range;
        destination_cidr_block;
        source_cidr_block;
        description
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.source_cidr_block
             (fun f -> Query.Pair ("SourceCidrBlock", (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)));
           Util.option_map v.source_port_range
             (fun f ->
                Query.Pair
                  ("SourcePortRange", (TrafficMirrorPortRange.to_query f)));
           Util.option_map v.destination_port_range
             (fun f ->
                Query.Pair
                  ("DestinationPortRange",
                    (TrafficMirrorPortRange.to_query f)));
           Util.option_map v.protocol
             (fun f -> Query.Pair ("Protocol", (Integer.to_query f)));
           Util.option_map v.rule_action
             (fun f ->
                Query.Pair
                  ("RuleAction", (TrafficMirrorRuleAction.to_query f)));
           Util.option_map v.rule_number
             (fun f -> Query.Pair ("RuleNumber", (Integer.to_query f)));
           Util.option_map v.traffic_direction
             (fun f ->
                Query.Pair
                  ("TrafficDirection", (TrafficDirection.to_query f)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f ->
                Query.Pair ("TrafficMirrorFilterId", (String.to_query f)));
           Util.option_map v.traffic_mirror_filter_rule_id
             (fun f ->
                Query.Pair ("TrafficMirrorFilterRuleId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.source_cidr_block
             (fun f -> ("source_cidr_block", (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)));
           Util.option_map v.source_port_range
             (fun f ->
                ("source_port_range", (TrafficMirrorPortRange.to_json f)));
           Util.option_map v.destination_port_range
             (fun f ->
                ("destination_port_range",
                  (TrafficMirrorPortRange.to_json f)));
           Util.option_map v.protocol
             (fun f -> ("protocol", (Integer.to_json f)));
           Util.option_map v.rule_action
             (fun f -> ("rule_action", (TrafficMirrorRuleAction.to_json f)));
           Util.option_map v.rule_number
             (fun f -> ("rule_number", (Integer.to_json f)));
           Util.option_map v.traffic_direction
             (fun f -> ("traffic_direction", (TrafficDirection.to_json f)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f -> ("traffic_mirror_filter_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_filter_rule_id
             (fun f -> ("traffic_mirror_filter_rule_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          traffic_mirror_filter_rule_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterRuleId" xml)
               String.parse);
          traffic_mirror_filter_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterId" xml)
               String.parse);
          traffic_direction =
            (Util.option_bind (Xml.member "trafficDirection" xml)
               TrafficDirection.parse);
          rule_number =
            (Util.option_bind (Xml.member "ruleNumber" xml) Integer.parse);
          rule_action =
            (Util.option_bind (Xml.member "ruleAction" xml)
               TrafficMirrorRuleAction.parse);
          protocol =
            (Util.option_bind (Xml.member "protocol" xml) Integer.parse);
          destination_port_range =
            (Util.option_bind (Xml.member "destinationPortRange" xml)
               TrafficMirrorPortRange.parse);
          source_port_range =
            (Util.option_bind (Xml.member "sourcePortRange" xml)
               TrafficMirrorPortRange.parse);
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          source_cidr_block =
            (Util.option_bind (Xml.member "sourceCidrBlock" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.traffic_mirror_filter_rule_id
                        (fun f ->
                           Ezxmlm.make_tag "trafficMirrorFilterRuleId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.traffic_mirror_filter_id
                       (fun f ->
                          Ezxmlm.make_tag "trafficMirrorFilterId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.traffic_direction
                      (fun f ->
                         Ezxmlm.make_tag "trafficDirection"
                           ([], (TrafficDirection.to_xml f)))])
                  @
                  [Util.option_map v.rule_number
                     (fun f ->
                        Ezxmlm.make_tag "ruleNumber" ([], (Integer.to_xml f)))])
                 @
                 [Util.option_map v.rule_action
                    (fun f ->
                       Ezxmlm.make_tag "ruleAction"
                         ([], (TrafficMirrorRuleAction.to_xml f)))])
                @
                [Util.option_map v.protocol
                   (fun f ->
                      Ezxmlm.make_tag "protocol" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.destination_port_range
                  (fun f ->
                     Ezxmlm.make_tag "destinationPortRange"
                       ([], (TrafficMirrorPortRange.to_xml f)))])
              @
              [Util.option_map v.source_port_range
                 (fun f ->
                    Ezxmlm.make_tag "sourcePortRange"
                      ([], (TrafficMirrorPortRange.to_xml f)))])
             @
             [Util.option_map v.destination_cidr_block
                (fun f ->
                   Ezxmlm.make_tag "destinationCidrBlock"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.source_cidr_block
               (fun f ->
                  Ezxmlm.make_tag "sourceCidrBlock" ([], (String.to_xml f)))])
           @
           [Util.option_map v.description
              (fun f -> Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the Traffic Mirror rule.</p>"]
module TrafficMirrorNetworkService =
  struct
    type t =
      | Amazon_dns 
    let str_to_t = [("amazon-dns", Amazon_dns)]
    let t_to_str = [(Amazon_dns, "amazon-dns")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module AutoAcceptSharedAttachmentsValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module DefaultRouteTableAssociationValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module DefaultRouteTablePropagationValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module DnsSupportValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module MulticastSupportValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module VpnEcmpSupportValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module InstanceCount =
  struct
    type t =
      {
      instance_count: Integer.t option
        [@ocaml.doc
          "<p>The number of listed Reserved Instances in the state specified by the <code>state</code>.</p>"];
      state: ListingState.t option
        [@ocaml.doc "<p>The states of the listed Reserved Instances.</p>"]}
    [@@ocaml.doc "<p>Describes a Reserved Instance listing state.</p>"]
    let make ?instance_count  ?state  () = { instance_count; state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (ListingState.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (ListingState.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) ListingState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_count
               (fun f ->
                  Ezxmlm.make_tag "instanceCount" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f -> Ezxmlm.make_tag "state" ([], (ListingState.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a Reserved Instance listing state.</p>"]
module PriceSchedule =
  struct
    type t =
      {
      active: Boolean.t option
        [@ocaml.doc
          "<p>The current price schedule, as determined by the term remaining for the Reserved Instance in the listing.</p> <p>A specific price schedule is always in effect, but only one price schedule can be active at any time. Take, for example, a Reserved Instance listing that has five months remaining in its term. When you specify price schedules for five months and two months, this means that schedule 1, covering the first three months of the remaining term, will be active during months 5, 4, and 3. Then schedule 2, covering the last two months of the term, will be active for months 2 and 1.</p>"];
      currency_code: CurrencyCodeValues.t option
        [@ocaml.doc
          "<p>The currency for transacting the Reserved Instance resale. At this time, the only supported currency is <code>USD</code>.</p>"];
      price: Double.t option
        [@ocaml.doc "<p>The fixed price for the term.</p>"];
      term: Long.t option
        [@ocaml.doc
          "<p>The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.</p>"]}
    [@@ocaml.doc "<p>Describes the price for a Reserved Instance.</p>"]
    let make ?active  ?currency_code  ?price  ?term  () =
      { active; currency_code; price; term }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.term
              (fun f -> Query.Pair ("Term", (Long.to_query f)));
           Util.option_map v.price
             (fun f -> Query.Pair ("Price", (Double.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.active
             (fun f -> Query.Pair ("Active", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.term (fun f -> ("term", (Long.to_json f)));
           Util.option_map v.price (fun f -> ("price", (Double.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.active
             (fun f -> ("active", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          active = (Util.option_bind (Xml.member "active" xml) Boolean.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          price = (Util.option_bind (Xml.member "price" xml) Double.parse);
          term = (Util.option_bind (Xml.member "term" xml) Long.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.active
                 (fun f -> Ezxmlm.make_tag "active" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.currency_code
                (fun f ->
                   Ezxmlm.make_tag "currencyCode"
                     ([], (CurrencyCodeValues.to_xml f)))])
            @
            [Util.option_map v.price
               (fun f -> Ezxmlm.make_tag "price" ([], (Double.to_xml f)))])
           @
           [Util.option_map v.term
              (fun f -> Ezxmlm.make_tag "term" ([], (Long.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the price for a Reserved Instance.</p>"]
module ClientVpnConnectionStatusCode =
  struct
    type t =
      | Active 
      | Failed_to_terminate 
      | Terminating 
      | Terminated 
    let str_to_t =
      [("terminated", Terminated);
      ("terminating", Terminating);
      ("failed-to-terminate", Failed_to_terminate);
      ("active", Active)]
    let t_to_str =
      [(Terminated, "terminated");
      (Terminating, "terminating");
      (Failed_to_terminate, "failed-to-terminate");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module InstanceStatusEvent =
  struct
    type t =
      {
      instance_event_id: String.t option
        [@ocaml.doc "<p>The ID of the event.</p>"];
      code: EventCode.t option [@ocaml.doc "<p>The event code.</p>"];
      description: String.t option
        [@ocaml.doc
          "<p>A description of the event.</p> <p>After a scheduled event is completed, it can still be described for up to a week. If the event has been completed, this description starts with the following text: [Completed].</p>"];
      not_after: DateTime.t option
        [@ocaml.doc "<p>The latest scheduled end time for the event.</p>"];
      not_before: DateTime.t option
        [@ocaml.doc
          "<p>The earliest scheduled start time for the event.</p>"];
      not_before_deadline: DateTime.t option
        [@ocaml.doc "<p>The deadline for starting the event.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes a scheduled event for an instance.</p>"]
    let make ?instance_event_id  ?code  ?description  ?not_after  ?not_before
       ?not_before_deadline  () =
      {
        instance_event_id;
        code;
        description;
        not_after;
        not_before;
        not_before_deadline
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.not_before_deadline
              (fun f ->
                 Query.Pair ("NotBeforeDeadline", (DateTime.to_query f)));
           Util.option_map v.not_before
             (fun f -> Query.Pair ("NotBefore", (DateTime.to_query f)));
           Util.option_map v.not_after
             (fun f -> Query.Pair ("NotAfter", (DateTime.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (EventCode.to_query f)));
           Util.option_map v.instance_event_id
             (fun f -> Query.Pair ("InstanceEventId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.not_before_deadline
              (fun f -> ("not_before_deadline", (DateTime.to_json f)));
           Util.option_map v.not_before
             (fun f -> ("not_before", (DateTime.to_json f)));
           Util.option_map v.not_after
             (fun f -> ("not_after", (DateTime.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (EventCode.to_json f)));
           Util.option_map v.instance_event_id
             (fun f -> ("instance_event_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          instance_event_id =
            (Util.option_bind (Xml.member "instanceEventId" xml) String.parse);
          code = (Util.option_bind (Xml.member "code" xml) EventCode.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          not_after =
            (Util.option_bind (Xml.member "notAfter" xml) DateTime.parse);
          not_before =
            (Util.option_bind (Xml.member "notBefore" xml) DateTime.parse);
          not_before_deadline =
            (Util.option_bind (Xml.member "notBeforeDeadline" xml)
               DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.instance_event_id
                   (fun f ->
                      Ezxmlm.make_tag "instanceEventId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.code
                  (fun f -> Ezxmlm.make_tag "code" ([], (EventCode.to_xml f)))])
              @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
             @
             [Util.option_map v.not_after
                (fun f ->
                   Ezxmlm.make_tag "notAfter" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.not_before
               (fun f ->
                  Ezxmlm.make_tag "notBefore" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.not_before_deadline
              (fun f ->
                 Ezxmlm.make_tag "notBeforeDeadline"
                   ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a scheduled event for an instance.</p>"]
module InstanceStatusDetailsList =
  struct
    type t = InstanceStatusDetails.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InstanceStatusDetails.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceStatusDetails.to_headers v
    let to_json v = `List (List.map InstanceStatusDetails.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceStatusDetails.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstanceStatusDetails.to_xml x))) v
  end
module SummaryStatus =
  struct
    type t =
      | Ok 
      | Impaired 
      | Insufficient_data 
      | Not_applicable 
      | Initializing 
    let str_to_t =
      [("initializing", Initializing);
      ("not-applicable", Not_applicable);
      ("insufficient-data", Insufficient_data);
      ("impaired", Impaired);
      ("ok", Ok)]
    let t_to_str =
      [(Initializing, "initializing");
      (Not_applicable, "not-applicable");
      (Insufficient_data, "insufficient-data");
      (Impaired, "impaired");
      (Ok, "ok")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module NetworkInterfacePermissionStateCode =
  struct
    type t =
      | Pending 
      | Granted 
      | Revoking 
      | Revoked 
    let str_to_t =
      [("revoked", Revoked);
      ("revoking", Revoking);
      ("granted", Granted);
      ("pending", Pending)]
    let t_to_str =
      [(Revoked, "revoked");
      (Revoking, "revoking");
      (Granted, "granted");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module AvailableInstanceCapacityList =
  struct
    type t = InstanceCapacity.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InstanceCapacity.to_query v
    let to_headers v = Headers.to_headers_list InstanceCapacity.to_headers v
    let to_json v = `List (List.map InstanceCapacity.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceCapacity.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InstanceCapacity.to_xml x)))
        v
  end
module HostInstance =
  struct
    type t =
      {
      instance_id: String.t option
        [@ocaml.doc
          "<p>The ID of instance that is running on the Dedicated Host.</p>"];
      instance_type: String.t option
        [@ocaml.doc
          "<p>The instance type (for example, <code>m3.medium</code>) of the running instance.</p>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account that owns the instance.</p>"]}
    [@@ocaml.doc "<p>Describes an instance running on a Dedicated Host.</p>"]
    let make ?instance_id  ?instance_type  ?owner_id  () =
      { instance_id; instance_type; owner_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.instance_id
                (fun f ->
                   Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.instance_type
               (fun f ->
                  Ezxmlm.make_tag "instanceType" ([], (String.to_xml f)))])
           @
           [Util.option_map v.owner_id
              (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an instance running on a Dedicated Host.</p>"]
module TransitGatewayMulitcastDomainAssociationState =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
    let str_to_t =
      [("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module IdFormat =
  struct
    type t =
      {
      deadline: DateTime.t option
        [@ocaml.doc
          "<p>The date in UTC at which you are permanently switched over to using longer IDs. If a deadline is not yet available for this resource type, this field is not returned.</p>"];
      resource: String.t option [@ocaml.doc "<p>The type of resource.</p>"];
      use_long_ids: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether longer IDs (17-character IDs) are enabled for the resource.</p>"]}
    [@@ocaml.doc "<p>Describes the ID format for a resource.</p>"]
    let make ?deadline  ?resource  ?use_long_ids  () =
      { deadline; resource; use_long_ids }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.use_long_ids
              (fun f -> Query.Pair ("UseLongIds", (Boolean.to_query f)));
           Util.option_map v.resource
             (fun f -> Query.Pair ("Resource", (String.to_query f)));
           Util.option_map v.deadline
             (fun f -> Query.Pair ("Deadline", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.use_long_ids
              (fun f -> ("use_long_ids", (Boolean.to_json f)));
           Util.option_map v.resource
             (fun f -> ("resource", (String.to_json f)));
           Util.option_map v.deadline
             (fun f -> ("deadline", (DateTime.to_json f)))])
    let parse xml =
      Some
        {
          deadline =
            (Util.option_bind (Xml.member "deadline" xml) DateTime.parse);
          resource =
            (Util.option_bind (Xml.member "resource" xml) String.parse);
          use_long_ids =
            (Util.option_bind (Xml.member "useLongIds" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.deadline
                (fun f ->
                   Ezxmlm.make_tag "deadline" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.resource
               (fun f -> Ezxmlm.make_tag "resource" ([], (String.to_xml f)))])
           @
           [Util.option_map v.use_long_ids
              (fun f -> Ezxmlm.make_tag "useLongIds" ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the ID format for a resource.</p>"]
module DeleteFleetErrorCode =
  struct
    type t =
      | FleetIdDoesNotExist 
      | FleetIdMalformed 
      | FleetNotInDeletableState 
      | UnexpectedError 
    let str_to_t =
      [("unexpectedError", UnexpectedError);
      ("fleetNotInDeletableState", FleetNotInDeletableState);
      ("fleetIdMalformed", FleetIdMalformed);
      ("fleetIdDoesNotExist", FleetIdDoesNotExist)]
    let t_to_str =
      [(UnexpectedError, "unexpectedError");
      (FleetNotInDeletableState, "fleetNotInDeletableState");
      (FleetIdMalformed, "fleetIdMalformed");
      (FleetIdDoesNotExist, "fleetIdDoesNotExist")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module DisableFastSnapshotRestoreStateErrorItem =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc "<p>The Availability Zone.</p>"];
      error: DisableFastSnapshotRestoreStateError.t option
        [@ocaml.doc "<p>The error.</p>"]}[@@ocaml.doc
                                           "<p>Contains information about an error that occurred when disabling fast snapshot restores.</p>"]
    let make ?availability_zone  ?error  () = { availability_zone; error }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 Query.Pair
                   ("Error",
                     (DisableFastSnapshotRestoreStateError.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 ("error", (DisableFastSnapshotRestoreStateError.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          error =
            (Util.option_bind (Xml.member "error" xml)
               DisableFastSnapshotRestoreStateError.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.availability_zone
               (fun f ->
                  Ezxmlm.make_tag "availabilityZone" ([], (String.to_xml f)))])
           @
           [Util.option_map v.error
              (fun f ->
                 Ezxmlm.make_tag "error"
                   ([], (DisableFastSnapshotRestoreStateError.to_xml f)))])
  end[@@ocaml.doc
       "<p>Contains information about an error that occurred when disabling fast snapshot restores.</p>"]
module OccurrenceDaySet =
  struct
    type t = Integer.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Integer.to_query v
    let to_headers v = Headers.to_headers_list Integer.to_headers v
    let to_json v = `List (List.map Integer.to_json v)
    let parse xml =
      Util.option_all (List.map Integer.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Integer.to_xml x))) v
  end
module S3Storage =
  struct
    type t =
      {
      a_w_s_access_key_id: String.t option
        [@ocaml.doc
          "<p>The access key ID of the owner of the bucket. Before you specify a value for your access key ID, review and follow the guidance in <a href=\"https://docs.aws.amazon.com/general/latest/gr/aws-access-keys-best-practices.html\">Best Practices for Managing AWS Access Keys</a>.</p>"];
      bucket: String.t option
        [@ocaml.doc
          "<p>The bucket in which to store the AMI. You can specify a bucket that you already own or a new bucket that Amazon EC2 creates on your behalf. If you specify a bucket that belongs to someone else, Amazon EC2 returns an error.</p>"];
      prefix: String.t option
        [@ocaml.doc "<p>The beginning of the file name of the AMI.</p>"];
      upload_policy: Blob.t option
        [@ocaml.doc
          "<p>An Amazon S3 upload policy that gives Amazon EC2 permission to upload items into Amazon S3 on your behalf.</p>"];
      upload_policy_signature: String.t option
        [@ocaml.doc "<p>The signature of the JSON document.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes the storage parameters for S3 and S3 buckets for an instance store-backed AMI.</p>"]
    let make ?a_w_s_access_key_id  ?bucket  ?prefix  ?upload_policy 
      ?upload_policy_signature  () =
      {
        a_w_s_access_key_id;
        bucket;
        prefix;
        upload_policy;
        upload_policy_signature
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.upload_policy_signature
              (fun f ->
                 Query.Pair ("UploadPolicySignature", (String.to_query f)));
           Util.option_map v.upload_policy
             (fun f -> Query.Pair ("UploadPolicy", (Blob.to_query f)));
           Util.option_map v.prefix
             (fun f -> Query.Pair ("Prefix", (String.to_query f)));
           Util.option_map v.bucket
             (fun f -> Query.Pair ("Bucket", (String.to_query f)));
           Util.option_map v.a_w_s_access_key_id
             (fun f -> Query.Pair ("AWSAccessKeyId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.upload_policy_signature
              (fun f -> ("upload_policy_signature", (String.to_json f)));
           Util.option_map v.upload_policy
             (fun f -> ("upload_policy", (Blob.to_json f)));
           Util.option_map v.prefix (fun f -> ("prefix", (String.to_json f)));
           Util.option_map v.bucket (fun f -> ("bucket", (String.to_json f)));
           Util.option_map v.a_w_s_access_key_id
             (fun f -> ("a_w_s_access_key_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          a_w_s_access_key_id =
            (Util.option_bind (Xml.member "AWSAccessKeyId" xml) String.parse);
          bucket = (Util.option_bind (Xml.member "bucket" xml) String.parse);
          prefix = (Util.option_bind (Xml.member "prefix" xml) String.parse);
          upload_policy =
            (Util.option_bind (Xml.member "uploadPolicy" xml) Blob.parse);
          upload_policy_signature =
            (Util.option_bind (Xml.member "uploadPolicySignature" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.a_w_s_access_key_id
                  (fun f ->
                     Ezxmlm.make_tag "AWSAccessKeyId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.bucket
                 (fun f -> Ezxmlm.make_tag "bucket" ([], (String.to_xml f)))])
             @
             [Util.option_map v.prefix
                (fun f -> Ezxmlm.make_tag "prefix" ([], (String.to_xml f)))])
            @
            [Util.option_map v.upload_policy
               (fun f -> Ezxmlm.make_tag "uploadPolicy" ([], (Blob.to_xml f)))])
           @
           [Util.option_map v.upload_policy_signature
              (fun f ->
                 Ezxmlm.make_tag "uploadPolicySignature"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the storage parameters for S3 and S3 buckets for an instance store-backed AMI.</p>"]
module StaleIpPermission =
  struct
    type t =
      {
      from_port: Integer.t option
        [@ocaml.doc
          "<p>The start of the port range for the TCP and UDP protocols, or an ICMP type number. A value of <code>-1</code> indicates all ICMP types. </p>"];
      ip_protocol: String.t option
        [@ocaml.doc
          "<p>The IP protocol name (for <code>tcp</code>, <code>udp</code>, and <code>icmp</code>) or number (see <a href=\"http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml\">Protocol Numbers)</a>.</p>"];
      ip_ranges: IpRanges.t
        [@ocaml.doc
          "<p>The IP ranges. Not applicable for stale security group rules.</p>"];
      prefix_list_ids: PrefixListIdSet.t
        [@ocaml.doc
          "<p>The prefix list IDs for an AWS service. Not applicable for stale security group rules.</p>"];
      to_port: Integer.t option
        [@ocaml.doc
          "<p>The end of the port range for the TCP and UDP protocols, or an ICMP type number. A value of <code>-1</code> indicates all ICMP types. </p>"];
      user_id_group_pairs: UserIdGroupPairSet.t
        [@ocaml.doc
          "<p>The security group pairs. Returns the ID of the referenced security group and VPC, and the ID and status of the VPC peering connection.</p>"]}
    [@@ocaml.doc "<p>Describes a stale rule in a security group.</p>"]
    let make ?from_port  ?ip_protocol  ?(ip_ranges= [])  ?(prefix_list_ids=
      [])  ?to_port  ?(user_id_group_pairs= [])  () =
      {
        from_port;
        ip_protocol;
        ip_ranges;
        prefix_list_ids;
        to_port;
        user_id_group_pairs
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Groups",
                   (UserIdGroupPairSet.to_query v.user_id_group_pairs)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrefixListIds",
                  (PrefixListIdSet.to_query v.prefix_list_ids)));
           Some (Query.Pair ("IpRanges", (IpRanges.to_query v.ip_ranges)));
           Util.option_map v.ip_protocol
             (fun f -> Query.Pair ("IpProtocol", (String.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("user_id_group_pairs",
                (UserIdGroupPairSet.to_json v.user_id_group_pairs));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Some
             ("prefix_list_ids", (PrefixListIdSet.to_json v.prefix_list_ids));
           Some ("ip_ranges", (IpRanges.to_json v.ip_ranges));
           Util.option_map v.ip_protocol
             (fun f -> ("ip_protocol", (String.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          from_port =
            (Util.option_bind (Xml.member "fromPort" xml) Integer.parse);
          ip_protocol =
            (Util.option_bind (Xml.member "ipProtocol" xml) String.parse);
          ip_ranges =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipRanges" xml) IpRanges.parse));
          prefix_list_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "prefixListIds" xml)
                  PrefixListIdSet.parse));
          to_port =
            (Util.option_bind (Xml.member "toPort" xml) Integer.parse);
          user_id_group_pairs =
            (Util.of_option []
               (Util.option_bind (Xml.member "groups" xml)
                  UserIdGroupPairSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.from_port
                   (fun f ->
                      Ezxmlm.make_tag "fromPort" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.ip_protocol
                  (fun f ->
                     Ezxmlm.make_tag "ipProtocol" ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "ipRanges" ([], (IpRanges.to_xml [x]))))
                 v.ip_ranges))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "prefixListIds"
                        ([], (PrefixListIdSet.to_xml [x]))))
                v.prefix_list_ids))
            @
            [Util.option_map v.to_port
               (fun f -> Ezxmlm.make_tag "toPort" ([], (Integer.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "groups"
                      ([], (UserIdGroupPairSet.to_xml [x]))))
              v.user_id_group_pairs))
  end[@@ocaml.doc "<p>Describes a stale rule in a security group.</p>"]
module VolumeAttachment =
  struct
    type t =
      {
      attach_time: DateTime.t option
        [@ocaml.doc "<p>The time stamp when the attachment initiated.</p>"];
      device: String.t option [@ocaml.doc "<p>The device name.</p>"];
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"];
      state: VolumeAttachmentState.t option
        [@ocaml.doc "<p>The attachment state of the volume.</p>"];
      volume_id: String.t option [@ocaml.doc "<p>The ID of the volume.</p>"];
      delete_on_termination: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the EBS volume is deleted on instance termination.</p>"]}
    [@@ocaml.doc "<p>Describes volume attachment details.</p>"]
    let make ?attach_time  ?device  ?instance_id  ?state  ?volume_id 
      ?delete_on_termination  () =
      {
        attach_time;
        device;
        instance_id;
        state;
        volume_id;
        delete_on_termination
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f ->
                 Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("Status", (VolumeAttachmentState.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.device
             (fun f -> Query.Pair ("Device", (String.to_query f)));
           Util.option_map v.attach_time
             (fun f -> Query.Pair ("AttachTime", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (VolumeAttachmentState.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.device (fun f -> ("device", (String.to_json f)));
           Util.option_map v.attach_time
             (fun f -> ("attach_time", (DateTime.to_json f)))])
    let parse xml =
      Some
        {
          attach_time =
            (Util.option_bind (Xml.member "attachTime" xml) DateTime.parse);
          device = (Util.option_bind (Xml.member "device" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "status" xml)
               VolumeAttachmentState.parse);
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.attach_time
                   (fun f ->
                      Ezxmlm.make_tag "attachTime" ([], (DateTime.to_xml f)))])
               @
               [Util.option_map v.device
                  (fun f -> Ezxmlm.make_tag "device" ([], (String.to_xml f)))])
              @
              [Util.option_map v.instance_id
                 (fun f ->
                    Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.state
                (fun f ->
                   Ezxmlm.make_tag "status"
                     ([], (VolumeAttachmentState.to_xml f)))])
            @
            [Util.option_map v.volume_id
               (fun f -> Ezxmlm.make_tag "volumeId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.delete_on_termination
              (fun f ->
                 Ezxmlm.make_tag "deleteOnTermination"
                   ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc "<p>Describes volume attachment details.</p>"]
module IKEVersionsRequestList =
  struct
    type t = IKEVersionsRequestListValue.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list IKEVersionsRequestListValue.to_query v
    let to_headers v =
      Headers.to_headers_list IKEVersionsRequestListValue.to_headers v
    let to_json v = `List (List.map IKEVersionsRequestListValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map IKEVersionsRequestListValue.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (IKEVersionsRequestListValue.to_xml x))) v
  end
module Phase1DHGroupNumbersRequestList =
  struct
    type t = Phase1DHGroupNumbersRequestListValue.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list Phase1DHGroupNumbersRequestListValue.to_query v
    let to_headers v =
      Headers.to_headers_list Phase1DHGroupNumbersRequestListValue.to_headers
        v
    let to_json v =
      `List (List.map Phase1DHGroupNumbersRequestListValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map Phase1DHGroupNumbersRequestListValue.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase1DHGroupNumbersRequestListValue.to_xml x))) v
  end
module Phase1EncryptionAlgorithmsRequestList =
  struct
    type t = Phase1EncryptionAlgorithmsRequestListValue.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list Phase1EncryptionAlgorithmsRequestListValue.to_query
        v
    let to_headers v =
      Headers.to_headers_list
        Phase1EncryptionAlgorithmsRequestListValue.to_headers v
    let to_json v =
      `List (List.map Phase1EncryptionAlgorithmsRequestListValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map Phase1EncryptionAlgorithmsRequestListValue.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase1EncryptionAlgorithmsRequestListValue.to_xml x))) v
  end
module Phase1IntegrityAlgorithmsRequestList =
  struct
    type t = Phase1IntegrityAlgorithmsRequestListValue.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list Phase1IntegrityAlgorithmsRequestListValue.to_query
        v
    let to_headers v =
      Headers.to_headers_list
        Phase1IntegrityAlgorithmsRequestListValue.to_headers v
    let to_json v =
      `List (List.map Phase1IntegrityAlgorithmsRequestListValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map Phase1IntegrityAlgorithmsRequestListValue.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase1IntegrityAlgorithmsRequestListValue.to_xml x))) v
  end
module Phase2DHGroupNumbersRequestList =
  struct
    type t = Phase2DHGroupNumbersRequestListValue.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list Phase2DHGroupNumbersRequestListValue.to_query v
    let to_headers v =
      Headers.to_headers_list Phase2DHGroupNumbersRequestListValue.to_headers
        v
    let to_json v =
      `List (List.map Phase2DHGroupNumbersRequestListValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map Phase2DHGroupNumbersRequestListValue.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase2DHGroupNumbersRequestListValue.to_xml x))) v
  end
module Phase2EncryptionAlgorithmsRequestList =
  struct
    type t = Phase2EncryptionAlgorithmsRequestListValue.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list Phase2EncryptionAlgorithmsRequestListValue.to_query
        v
    let to_headers v =
      Headers.to_headers_list
        Phase2EncryptionAlgorithmsRequestListValue.to_headers v
    let to_json v =
      `List (List.map Phase2EncryptionAlgorithmsRequestListValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map Phase2EncryptionAlgorithmsRequestListValue.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase2EncryptionAlgorithmsRequestListValue.to_xml x))) v
  end
module Phase2IntegrityAlgorithmsRequestList =
  struct
    type t = Phase2IntegrityAlgorithmsRequestListValue.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list Phase2IntegrityAlgorithmsRequestListValue.to_query
        v
    let to_headers v =
      Headers.to_headers_list
        Phase2IntegrityAlgorithmsRequestListValue.to_headers v
    let to_json v =
      `List (List.map Phase2IntegrityAlgorithmsRequestListValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map Phase2IntegrityAlgorithmsRequestListValue.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase2IntegrityAlgorithmsRequestListValue.to_xml x))) v
  end
module EbsEncryptionSupport =
  struct
    type t =
      | Unsupported 
      | Supported 
    let str_to_t = [("supported", Supported); ("unsupported", Unsupported)]
    let t_to_str = [(Supported, "supported"); (Unsupported, "unsupported")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module EbsOptimizedSupport =
  struct
    type t =
      | Unsupported 
      | Supported 
      | Default 
    let str_to_t =
      [("default", Default);
      ("supported", Supported);
      ("unsupported", Unsupported)]
    let t_to_str =
      [(Default, "default");
      (Supported, "supported");
      (Unsupported, "unsupported")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module FpgaDeviceInfoList =
  struct
    type t = FpgaDeviceInfo.t list
    let make elems () = elems
    let to_query v = Query.to_query_list FpgaDeviceInfo.to_query v
    let to_headers v = Headers.to_headers_list FpgaDeviceInfo.to_headers v
    let to_json v = `List (List.map FpgaDeviceInfo.to_json v)
    let parse xml =
      Util.option_all
        (List.map FpgaDeviceInfo.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (FpgaDeviceInfo.to_xml x))) v
  end
module GpuDeviceInfoList =
  struct
    type t = GpuDeviceInfo.t list
    let make elems () = elems
    let to_query v = Query.to_query_list GpuDeviceInfo.to_query v
    let to_headers v = Headers.to_headers_list GpuDeviceInfo.to_headers v
    let to_json v = `List (List.map GpuDeviceInfo.to_json v)
    let parse xml =
      Util.option_all (List.map GpuDeviceInfo.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (GpuDeviceInfo.to_xml x))) v
  end
module InferenceDeviceInfoList =
  struct
    type t = InferenceDeviceInfo.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InferenceDeviceInfo.to_query v
    let to_headers v =
      Headers.to_headers_list InferenceDeviceInfo.to_headers v
    let to_json v = `List (List.map InferenceDeviceInfo.to_json v)
    let parse xml =
      Util.option_all
        (List.map InferenceDeviceInfo.parse (Xml.members "member" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InferenceDeviceInfo.to_xml x))) v
  end
module DiskInfoList =
  struct
    type t = DiskInfo.t list
    let make elems () = elems
    let to_query v = Query.to_query_list DiskInfo.to_query v
    let to_headers v = Headers.to_headers_list DiskInfo.to_headers v
    let to_json v = `List (List.map DiskInfo.to_json v)
    let parse xml =
      Util.option_all (List.map DiskInfo.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (DiskInfo.to_xml x)))
        v
  end
module EnaSupport =
  struct
    type t =
      | Unsupported 
      | Supported 
      | Required 
    let str_to_t =
      [("required", Required);
      ("supported", Supported);
      ("unsupported", Unsupported)]
    let t_to_str =
      [(Required, "required");
      (Supported, "supported");
      (Unsupported, "unsupported")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module PlacementGroupStrategyList =
  struct
    type t = PlacementGroupStrategy.t list
    let make elems () = elems
    let to_query v = Query.to_query_list PlacementGroupStrategy.to_query v
    let to_headers v =
      Headers.to_headers_list PlacementGroupStrategy.to_headers v
    let to_json v = `List (List.map PlacementGroupStrategy.to_json v)
    let parse xml =
      Util.option_all
        (List.map PlacementGroupStrategy.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (PlacementGroupStrategy.to_xml x)))
        v
  end
module ArchitectureTypeList =
  struct
    type t = ArchitectureType.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ArchitectureType.to_query v
    let to_headers v = Headers.to_headers_list ArchitectureType.to_headers v
    let to_json v = `List (List.map ArchitectureType.to_json v)
    let parse xml =
      Util.option_all
        (List.map ArchitectureType.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ArchitectureType.to_xml x)))
        v
  end
module RootDeviceType =
  struct
    type t =
      | Ebs 
      | Instance_store 
    let str_to_t = [("instance-store", Instance_store); ("ebs", Ebs)]
    let t_to_str = [(Instance_store, "instance-store"); (Ebs, "ebs")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module UsageClassType =
  struct
    type t =
      | Spot 
      | On_demand 
    let str_to_t = [("on-demand", On_demand); ("spot", Spot)]
    let t_to_str = [(On_demand, "on-demand"); (Spot, "spot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module CoreCountList =
  struct
    type t = Integer.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Integer.to_query v
    let to_headers v = Headers.to_headers_list Integer.to_headers v
    let to_json v = `List (List.map Integer.to_json v)
    let parse xml =
      Util.option_all (List.map Integer.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Integer.to_xml x))) v
  end
module ThreadsPerCoreList =
  struct
    type t = Integer.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Integer.to_query v
    let to_headers v = Headers.to_headers_list Integer.to_headers v
    let to_json v = `List (List.map Integer.to_json v)
    let parse xml =
      Util.option_all (List.map Integer.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Integer.to_xml x))) v
  end
module ClientVpnRouteStatusCode =
  struct
    type t =
      | Creating 
      | Active 
      | Failed 
      | Deleting 
    let str_to_t =
      [("deleting", Deleting);
      ("failed", Failed);
      ("active", Active);
      ("creating", Creating)]
    let t_to_str =
      [(Deleting, "deleting");
      (Failed, "failed");
      (Active, "active");
      (Creating, "creating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module VgwTelemetry =
  struct
    type t =
      {
      accepted_route_count: Integer.t option
        [@ocaml.doc "<p>The number of accepted routes.</p>"];
      last_status_change: DateTime.t option
        [@ocaml.doc "<p>The date and time of the last change in status.</p>"];
      outside_ip_address: String.t option
        [@ocaml.doc
          "<p>The Internet-routable IP address of the virtual private gateway's outside interface.</p>"];
      status: TelemetryStatus.t option
        [@ocaml.doc "<p>The status of the VPN tunnel.</p>"];
      status_message: String.t option
        [@ocaml.doc "<p>If an error occurs, a description of the error.</p>"];
      certificate_arn: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the VPN tunnel endpoint certificate.</p>"]}
    [@@ocaml.doc "<p>Describes telemetry for a VPN tunnel.</p>"]
    let make ?accepted_route_count  ?last_status_change  ?outside_ip_address 
      ?status  ?status_message  ?certificate_arn  () =
      {
        accepted_route_count;
        last_status_change;
        outside_ip_address;
        status;
        status_message;
        certificate_arn
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.certificate_arn
              (fun f -> Query.Pair ("CertificateArn", (String.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (TelemetryStatus.to_query f)));
           Util.option_map v.outside_ip_address
             (fun f -> Query.Pair ("OutsideIpAddress", (String.to_query f)));
           Util.option_map v.last_status_change
             (fun f -> Query.Pair ("LastStatusChange", (DateTime.to_query f)));
           Util.option_map v.accepted_route_count
             (fun f ->
                Query.Pair ("AcceptedRouteCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.certificate_arn
              (fun f -> ("certificate_arn", (String.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (TelemetryStatus.to_json f)));
           Util.option_map v.outside_ip_address
             (fun f -> ("outside_ip_address", (String.to_json f)));
           Util.option_map v.last_status_change
             (fun f -> ("last_status_change", (DateTime.to_json f)));
           Util.option_map v.accepted_route_count
             (fun f -> ("accepted_route_count", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          accepted_route_count =
            (Util.option_bind (Xml.member "acceptedRouteCount" xml)
               Integer.parse);
          last_status_change =
            (Util.option_bind (Xml.member "lastStatusChange" xml)
               DateTime.parse);
          outside_ip_address =
            (Util.option_bind (Xml.member "outsideIpAddress" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml) TelemetryStatus.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          certificate_arn =
            (Util.option_bind (Xml.member "certificateArn" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.accepted_route_count
                   (fun f ->
                      Ezxmlm.make_tag "acceptedRouteCount"
                        ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.last_status_change
                  (fun f ->
                     Ezxmlm.make_tag "lastStatusChange"
                       ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.outside_ip_address
                 (fun f ->
                    Ezxmlm.make_tag "outsideIpAddress"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.status
                (fun f ->
                   Ezxmlm.make_tag "status" ([], (TelemetryStatus.to_xml f)))])
            @
            [Util.option_map v.status_message
               (fun f ->
                  Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
           @
           [Util.option_map v.certificate_arn
              (fun f ->
                 Ezxmlm.make_tag "certificateArn" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes telemetry for a VPN tunnel.</p>"]
module TunnelOptionsList =
  struct
    type t = TunnelOption.t list
    let make elems () = elems
    let to_query v = Query.to_query_list TunnelOption.to_query v
    let to_headers v = Headers.to_headers_list TunnelOption.to_headers v
    let to_json v = `List (List.map TunnelOption.to_json v)
    let parse xml =
      Util.option_all (List.map TunnelOption.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (TunnelOption.to_xml x))) v
  end
module VpnStaticRoute =
  struct
    type t =
      {
      destination_cidr_block: String.t option
        [@ocaml.doc
          "<p>The CIDR block associated with the local subnet of the customer data center.</p>"];
      source: VpnStaticRouteSource.t option
        [@ocaml.doc "<p>Indicates how the routes were provided.</p>"];
      state: VpnState.t option
        [@ocaml.doc "<p>The current state of the static route.</p>"]}
    [@@ocaml.doc "<p>Describes a static route for a VPN connection.</p>"]
    let make ?destination_cidr_block  ?source  ?state  () =
      { destination_cidr_block; source; state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (VpnState.to_query f)));
           Util.option_map v.source
             (fun f ->
                Query.Pair ("Source", (VpnStaticRouteSource.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (VpnState.to_json f)));
           Util.option_map v.source
             (fun f -> ("source", (VpnStaticRouteSource.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          source =
            (Util.option_bind (Xml.member "source" xml)
               VpnStaticRouteSource.parse);
          state = (Util.option_bind (Xml.member "state" xml) VpnState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.destination_cidr_block
                (fun f ->
                   Ezxmlm.make_tag "destinationCidrBlock"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.source
               (fun f ->
                  Ezxmlm.make_tag "source"
                    ([], (VpnStaticRouteSource.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f -> Ezxmlm.make_tag "state" ([], (VpnState.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a static route for a VPN connection.</p>"]
module AssociationStatusCode =
  struct
    type t =
      | Associating 
      | Associated 
      | Association_failed 
      | Disassociating 
      | Disassociated 
    let str_to_t =
      [("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("association-failed", Association_failed);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Association_failed, "association-failed");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module VpcPeeringConnectionStateReasonCode =
  struct
    type t =
      | Initiating_request 
      | Pending_acceptance 
      | Active 
      | Deleted 
      | Rejected 
      | Failed 
      | Expired 
      | Provisioning 
      | Deleting 
    let str_to_t =
      [("deleting", Deleting);
      ("provisioning", Provisioning);
      ("expired", Expired);
      ("failed", Failed);
      ("rejected", Rejected);
      ("deleted", Deleted);
      ("active", Active);
      ("pending-acceptance", Pending_acceptance);
      ("initiating-request", Initiating_request)]
    let t_to_str =
      [(Deleting, "deleting");
      (Provisioning, "provisioning");
      (Expired, "expired");
      (Failed, "failed");
      (Rejected, "rejected");
      (Deleted, "deleted");
      (Active, "active");
      (Pending_acceptance, "pending-acceptance");
      (Initiating_request, "initiating-request")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module CidrBlockSet =
  struct
    type t = CidrBlock.t list
    let make elems () = elems
    let to_query v = Query.to_query_list CidrBlock.to_query v
    let to_headers v = Headers.to_headers_list CidrBlock.to_headers v
    let to_json v = `List (List.map CidrBlock.to_json v)
    let parse xml =
      Util.option_all (List.map CidrBlock.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (CidrBlock.to_xml x)))
        v
  end
module Ipv6CidrBlockSet =
  struct
    type t = Ipv6CidrBlock.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Ipv6CidrBlock.to_query v
    let to_headers v = Headers.to_headers_list Ipv6CidrBlock.to_headers v
    let to_json v = `List (List.map Ipv6CidrBlock.to_json v)
    let parse xml =
      Util.option_all (List.map Ipv6CidrBlock.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (Ipv6CidrBlock.to_xml x))) v
  end
module VpcPeeringConnectionOptionsDescription =
  struct
    type t =
      {
      allow_dns_resolution_from_remote_vpc: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether a local VPC can resolve public DNS hostnames to private IP addresses when queried from instances in a peer VPC.</p>"];
      allow_egress_from_local_classic_link_to_remote_vpc: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether a local ClassicLink connection can communicate with the peer VPC over the VPC peering connection.</p>"];
      allow_egress_from_local_vpc_to_remote_classic_link: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether a local VPC can communicate with a ClassicLink connection in the peer VPC over the VPC peering connection.</p>"]}
    [@@ocaml.doc "<p>Describes the VPC peering connection options.</p>"]
    let make ?allow_dns_resolution_from_remote_vpc 
      ?allow_egress_from_local_classic_link_to_remote_vpc 
      ?allow_egress_from_local_vpc_to_remote_classic_link  () =
      {
        allow_dns_resolution_from_remote_vpc;
        allow_egress_from_local_classic_link_to_remote_vpc;
        allow_egress_from_local_vpc_to_remote_classic_link
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 Query.Pair
                   ("AllowEgressFromLocalVpcToRemoteClassicLink",
                     (Boolean.to_query f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowEgressFromLocalClassicLinkToRemoteVpc",
                    (Boolean.to_query f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowDnsResolutionFromRemoteVpc", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 ("allow_egress_from_local_vpc_to_remote_classic_link",
                   (Boolean.to_json f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                ("allow_egress_from_local_classic_link_to_remote_vpc",
                  (Boolean.to_json f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                ("allow_dns_resolution_from_remote_vpc", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          allow_dns_resolution_from_remote_vpc =
            (Util.option_bind
               (Xml.member "allowDnsResolutionFromRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_classic_link_to_remote_vpc =
            (Util.option_bind
               (Xml.member "allowEgressFromLocalClassicLinkToRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_vpc_to_remote_classic_link =
            (Util.option_bind
               (Xml.member "allowEgressFromLocalVpcToRemoteClassicLink" xml)
               Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.allow_dns_resolution_from_remote_vpc
                (fun f ->
                   Ezxmlm.make_tag "allowDnsResolutionFromRemoteVpc"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map
               v.allow_egress_from_local_classic_link_to_remote_vpc
               (fun f ->
                  Ezxmlm.make_tag
                    "allowEgressFromLocalClassicLinkToRemoteVpc"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 Ezxmlm.make_tag "allowEgressFromLocalVpcToRemoteClassicLink"
                   ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the VPC peering connection options.</p>"]
module NetworkAclAssociation =
  struct
    type t =
      {
      network_acl_association_id: String.t option
        [@ocaml.doc
          "<p>The ID of the association between a network ACL and a subnet.</p>"];
      network_acl_id: String.t option
        [@ocaml.doc "<p>The ID of the network ACL.</p>"];
      subnet_id: String.t option [@ocaml.doc "<p>The ID of the subnet.</p>"]}
    [@@ocaml.doc
      "<p>Describes an association between a network ACL and a subnet.</p>"]
    let make ?network_acl_association_id  ?network_acl_id  ?subnet_id  () =
      { network_acl_association_id; network_acl_id; subnet_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.network_acl_id
             (fun f -> Query.Pair ("NetworkAclId", (String.to_query f)));
           Util.option_map v.network_acl_association_id
             (fun f ->
                Query.Pair ("NetworkAclAssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.network_acl_id
             (fun f -> ("network_acl_id", (String.to_json f)));
           Util.option_map v.network_acl_association_id
             (fun f -> ("network_acl_association_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          network_acl_association_id =
            (Util.option_bind (Xml.member "networkAclAssociationId" xml)
               String.parse);
          network_acl_id =
            (Util.option_bind (Xml.member "networkAclId" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.network_acl_association_id
                (fun f ->
                   Ezxmlm.make_tag "networkAclAssociationId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.network_acl_id
               (fun f ->
                  Ezxmlm.make_tag "networkAclId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.subnet_id
              (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an association between a network ACL and a subnet.</p>"]
module NetworkAclEntry =
  struct
    type t =
      {
      cidr_block: String.t option
        [@ocaml.doc
          "<p>The IPv4 network range to allow or deny, in CIDR notation.</p>"];
      egress: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the rule is an egress rule (applied to traffic leaving the subnet).</p>"];
      icmp_type_code: IcmpTypeCode.t option
        [@ocaml.doc "<p>ICMP protocol: The ICMP type and code.</p>"];
      ipv6_cidr_block: String.t option
        [@ocaml.doc
          "<p>The IPv6 network range to allow or deny, in CIDR notation.</p>"];
      port_range: PortRange.t option
        [@ocaml.doc
          "<p>TCP or UDP protocols: The range of ports the rule applies to.</p>"];
      protocol: String.t option
        [@ocaml.doc
          "<p>The protocol number. A value of \"-1\" means all protocols.</p>"];
      rule_action: RuleAction.t option
        [@ocaml.doc
          "<p>Indicates whether to allow or deny the traffic that matches the rule.</p>"];
      rule_number: Integer.t option
        [@ocaml.doc
          "<p>The rule number for the entry. ACL entries are processed in ascending order by rule number.</p>"]}
    [@@ocaml.doc "<p>Describes an entry in a network ACL.</p>"]
    let make ?cidr_block  ?egress  ?icmp_type_code  ?ipv6_cidr_block 
      ?port_range  ?protocol  ?rule_action  ?rule_number  () =
      {
        cidr_block;
        egress;
        icmp_type_code;
        ipv6_cidr_block;
        port_range;
        protocol;
        rule_action;
        rule_number
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.rule_number
              (fun f -> Query.Pair ("RuleNumber", (Integer.to_query f)));
           Util.option_map v.rule_action
             (fun f -> Query.Pair ("RuleAction", (RuleAction.to_query f)));
           Util.option_map v.protocol
             (fun f -> Query.Pair ("Protocol", (String.to_query f)));
           Util.option_map v.port_range
             (fun f -> Query.Pair ("PortRange", (PortRange.to_query f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Util.option_map v.icmp_type_code
             (fun f -> Query.Pair ("IcmpTypeCode", (IcmpTypeCode.to_query f)));
           Util.option_map v.egress
             (fun f -> Query.Pair ("Egress", (Boolean.to_query f)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.rule_number
              (fun f -> ("rule_number", (Integer.to_json f)));
           Util.option_map v.rule_action
             (fun f -> ("rule_action", (RuleAction.to_json f)));
           Util.option_map v.protocol
             (fun f -> ("protocol", (String.to_json f)));
           Util.option_map v.port_range
             (fun f -> ("port_range", (PortRange.to_json f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.icmp_type_code
             (fun f -> ("icmp_type_code", (IcmpTypeCode.to_json f)));
           Util.option_map v.egress
             (fun f -> ("egress", (Boolean.to_json f)));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)))])
    let parse xml =
      Some
        {
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse);
          egress = (Util.option_bind (Xml.member "egress" xml) Boolean.parse);
          icmp_type_code =
            (Util.option_bind (Xml.member "icmpTypeCode" xml)
               IcmpTypeCode.parse);
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "ipv6CidrBlock" xml) String.parse);
          port_range =
            (Util.option_bind (Xml.member "portRange" xml) PortRange.parse);
          protocol =
            (Util.option_bind (Xml.member "protocol" xml) String.parse);
          rule_action =
            (Util.option_bind (Xml.member "ruleAction" xml) RuleAction.parse);
          rule_number =
            (Util.option_bind (Xml.member "ruleNumber" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.cidr_block
                     (fun f ->
                        Ezxmlm.make_tag "cidrBlock" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.egress
                    (fun f ->
                       Ezxmlm.make_tag "egress" ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.icmp_type_code
                   (fun f ->
                      Ezxmlm.make_tag "icmpTypeCode"
                        ([], (IcmpTypeCode.to_xml f)))])
               @
               [Util.option_map v.ipv6_cidr_block
                  (fun f ->
                     Ezxmlm.make_tag "ipv6CidrBlock" ([], (String.to_xml f)))])
              @
              [Util.option_map v.port_range
                 (fun f ->
                    Ezxmlm.make_tag "portRange" ([], (PortRange.to_xml f)))])
             @
             [Util.option_map v.protocol
                (fun f -> Ezxmlm.make_tag "protocol" ([], (String.to_xml f)))])
            @
            [Util.option_map v.rule_action
               (fun f ->
                  Ezxmlm.make_tag "ruleAction" ([], (RuleAction.to_xml f)))])
           @
           [Util.option_map v.rule_number
              (fun f -> Ezxmlm.make_tag "ruleNumber" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an entry in a network ACL.</p>"]
module CancelBatchErrorCode =
  struct
    type t =
      | FleetRequestIdDoesNotExist 
      | FleetRequestIdMalformed 
      | FleetRequestNotInCancellableState 
      | UnexpectedError 
    let str_to_t =
      [("unexpectedError", UnexpectedError);
      ("fleetRequestNotInCancellableState",
        FleetRequestNotInCancellableState);
      ("fleetRequestIdMalformed", FleetRequestIdMalformed);
      ("fleetRequestIdDoesNotExist", FleetRequestIdDoesNotExist)]
    let t_to_str =
      [(UnexpectedError, "unexpectedError");
      (FleetRequestNotInCancellableState,
        "fleetRequestNotInCancellableState");
      (FleetRequestIdMalformed, "fleetRequestIdMalformed");
      (FleetRequestIdDoesNotExist, "fleetRequestIdDoesNotExist")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module AccountAttributeValue =
  struct
    type t =
      {
      attribute_value: String.t option
        [@ocaml.doc "<p>The value of the attribute.</p>"]}[@@ocaml.doc
                                                            "<p>Describes a value of an account attribute.</p>"]
    let make ?attribute_value  () = { attribute_value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.attribute_value
              (fun f -> Query.Pair ("AttributeValue", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.attribute_value
              (fun f -> ("attribute_value", (String.to_json f)))])
    let parse xml =
      Some
        {
          attribute_value =
            (Util.option_bind (Xml.member "attributeValue" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.attribute_value
              (fun f ->
                 Ezxmlm.make_tag "attributeValue" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a value of an account attribute.</p>"]
module SecurityGroupIdentifier =
  struct
    type t =
      {
      group_id: String.t option
        [@ocaml.doc "<p>The ID of the security group.</p>"];
      group_name: String.t option
        [@ocaml.doc "<p>The name of the security group.</p>"]}[@@ocaml.doc
                                                                "<p>Describes a security group.</p>"]
    let make ?group_id  ?group_name  () = { group_id; group_name }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.group_id
               (fun f -> Ezxmlm.make_tag "groupId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.group_name
              (fun f -> Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a security group.</p>"]
module TransitGatewayAssociationState =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
    let str_to_t =
      [("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module NetworkInterfaceIpv6Address =
  struct
    type t =
      {
      ipv6_address: String.t option [@ocaml.doc "<p>The IPv6 address.</p>"]}
    [@@ocaml.doc
      "<p>Describes an IPv6 address associated with a network interface.</p>"]
    let make ?ipv6_address  () = { ipv6_address }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> Query.Pair ("Ipv6Address", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> ("ipv6_address", (String.to_json f)))])
    let parse xml =
      Some
        {
          ipv6_address =
            (Util.option_bind (Xml.member "ipv6Address" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ipv6_address
              (fun f -> Ezxmlm.make_tag "ipv6Address" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an IPv6 address associated with a network interface.</p>"]
module NetworkInterfacePrivateIpAddress =
  struct
    type t =
      {
      association: NetworkInterfaceAssociation.t option
        [@ocaml.doc
          "<p>The association information for an Elastic IP address (IPv4) associated with the network interface.</p>"];
      primary: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether this IPv4 address is the primary private IPv4 address of the network interface.</p>"];
      private_dns_name: String.t option
        [@ocaml.doc "<p>The private DNS name.</p>"];
      private_ip_address: String.t option
        [@ocaml.doc "<p>The private IPv4 address.</p>"]}[@@ocaml.doc
                                                          "<p>Describes the private IPv4 address of a network interface.</p>"]
    let make ?association  ?primary  ?private_dns_name  ?private_ip_address 
      () = { association; primary; private_dns_name; private_ip_address }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.primary
             (fun f -> Query.Pair ("Primary", (Boolean.to_query f)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association", (NetworkInterfaceAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.primary
             (fun f -> ("primary", (Boolean.to_json f)));
           Util.option_map v.association
             (fun f ->
                ("association", (NetworkInterfaceAssociation.to_json f)))])
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               NetworkInterfaceAssociation.parse);
          primary =
            (Util.option_bind (Xml.member "primary" xml) Boolean.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.association
                 (fun f ->
                    Ezxmlm.make_tag "association"
                      ([], (NetworkInterfaceAssociation.to_xml f)))])
             @
             [Util.option_map v.primary
                (fun f -> Ezxmlm.make_tag "primary" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.private_dns_name
               (fun f ->
                  Ezxmlm.make_tag "privateDnsName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.private_ip_address
              (fun f ->
                 Ezxmlm.make_tag "privateIpAddress" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the private IPv4 address of a network interface.</p>"]
module RecurringCharge =
  struct
    type t =
      {
      amount: Double.t option
        [@ocaml.doc "<p>The amount of the recurring charge.</p>"];
      frequency: RecurringChargeFrequency.t option
        [@ocaml.doc "<p>The frequency of the recurring charge.</p>"]}
    [@@ocaml.doc "<p>Describes a recurring charge.</p>"]
    let make ?amount  ?frequency  () = { amount; frequency }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.frequency
              (fun f ->
                 Query.Pair
                   ("Frequency", (RecurringChargeFrequency.to_query f)));
           Util.option_map v.amount
             (fun f -> Query.Pair ("Amount", (Double.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.frequency
              (fun f -> ("frequency", (RecurringChargeFrequency.to_json f)));
           Util.option_map v.amount (fun f -> ("amount", (Double.to_json f)))])
    let parse xml =
      Some
        {
          amount = (Util.option_bind (Xml.member "amount" xml) Double.parse);
          frequency =
            (Util.option_bind (Xml.member "frequency" xml)
               RecurringChargeFrequency.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.amount
               (fun f -> Ezxmlm.make_tag "amount" ([], (Double.to_xml f)))])
           @
           [Util.option_map v.frequency
              (fun f ->
                 Ezxmlm.make_tag "frequency"
                   ([], (RecurringChargeFrequency.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a recurring charge.</p>"]
module ServiceTypeDetail =
  struct
    type t =
      {
      service_type: ServiceType.t option
        [@ocaml.doc "<p>The type of service.</p>"]}[@@ocaml.doc
                                                     "<p>Describes the type of service for a VPC endpoint.</p>"]
    let make ?service_type  () = { service_type }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.service_type
              (fun f -> Query.Pair ("ServiceType", (ServiceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.service_type
              (fun f -> ("service_type", (ServiceType.to_json f)))])
    let parse xml =
      Some
        {
          service_type =
            (Util.option_bind (Xml.member "serviceType" xml)
               ServiceType.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.service_type
              (fun f ->
                 Ezxmlm.make_tag "serviceType" ([], (ServiceType.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the type of service for a VPC endpoint.</p>"]
module ImportInstanceVolumeDetailSet =
  struct
    type t = ImportInstanceVolumeDetailItem.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list ImportInstanceVolumeDetailItem.to_query v
    let to_headers v =
      Headers.to_headers_list ImportInstanceVolumeDetailItem.to_headers v
    let to_json v = `List (List.map ImportInstanceVolumeDetailItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map ImportInstanceVolumeDetailItem.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ImportInstanceVolumeDetailItem.to_xml x))) v
  end
module Ipv6SupportValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module TransitGatewayRouteAttachment =
  struct
    type t =
      {
      resource_id: String.t option
        [@ocaml.doc "<p>The ID of the resource.</p>"];
      transit_gateway_attachment_id: String.t option
        [@ocaml.doc "<p>The ID of the attachment.</p>"];
      resource_type: TransitGatewayAttachmentResourceType.t option
        [@ocaml.doc "<p>The resource type.</p>"]}[@@ocaml.doc
                                                   "<p>Describes a route attachment.</p>"]
    let make ?resource_id  ?transit_gateway_attachment_id  ?resource_type  ()
      = { resource_id; transit_gateway_attachment_id; resource_type }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.resource_type
              (fun f ->
                 Query.Pair
                   ("ResourceType",
                     (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.resource_type
              (fun f ->
                 ("resource_type",
                   (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.resource_id
                (fun f ->
                   Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.transit_gateway_attachment_id
               (fun f ->
                  Ezxmlm.make_tag "transitGatewayAttachmentId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.resource_type
              (fun f ->
                 Ezxmlm.make_tag "resourceType"
                   ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a route attachment.</p>"]
module FpgaImageStateCode =
  struct
    type t =
      | Pending 
      | Failed 
      | Available 
      | Unavailable 
    let str_to_t =
      [("unavailable", Unavailable);
      ("available", Available);
      ("failed", Failed);
      ("pending", Pending)]
    let t_to_str =
      [(Unavailable, "unavailable");
      (Available, "available");
      (Failed, "failed");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module EnableFastSnapshotRestoreStateErrorItem =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc "<p>The Availability Zone.</p>"];
      error: EnableFastSnapshotRestoreStateError.t option
        [@ocaml.doc "<p>The error.</p>"]}[@@ocaml.doc
                                           "<p>Contains information about an error that occurred when enabling fast snapshot restores.</p>"]
    let make ?availability_zone  ?error  () = { availability_zone; error }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 Query.Pair
                   ("Error",
                     (EnableFastSnapshotRestoreStateError.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 ("error", (EnableFastSnapshotRestoreStateError.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          error =
            (Util.option_bind (Xml.member "error" xml)
               EnableFastSnapshotRestoreStateError.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.availability_zone
               (fun f ->
                  Ezxmlm.make_tag "availabilityZone" ([], (String.to_xml f)))])
           @
           [Util.option_map v.error
              (fun f ->
                 Ezxmlm.make_tag "error"
                   ([], (EnableFastSnapshotRestoreStateError.to_xml f)))])
  end[@@ocaml.doc
       "<p>Contains information about an error that occurred when enabling fast snapshot restores.</p>"]
module PropagatingVgw =
  struct
    type t =
      {
      gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the virtual private gateway.</p>"]}
    [@@ocaml.doc
      "<p>Describes a virtual private gateway propagating route.</p>"]
    let make ?gateway_id  () = { gateway_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.gateway_id
              (fun f -> Query.Pair ("GatewayId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.gateway_id
              (fun f -> ("gateway_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.gateway_id
              (fun f -> Ezxmlm.make_tag "gatewayId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a virtual private gateway propagating route.</p>"]
module Route =
  struct
    type t =
      {
      destination_cidr_block: String.t option
        [@ocaml.doc
          "<p>The IPv4 CIDR block used for the destination match.</p>"];
      destination_ipv6_cidr_block: String.t option
        [@ocaml.doc
          "<p>The IPv6 CIDR block used for the destination match.</p>"];
      destination_prefix_list_id: String.t option
        [@ocaml.doc "<p>The prefix of the AWS service.</p>"];
      egress_only_internet_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the egress-only internet gateway.</p>"];
      gateway_id: String.t option
        [@ocaml.doc "<p>The ID of a gateway attached to your VPC.</p>"];
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of a NAT instance in your VPC.</p>"];
      instance_owner_id: String.t option
        [@ocaml.doc
          "<p>The AWS account ID of the owner of the instance.</p>"];
      nat_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of a NAT gateway.</p>"];
      transit_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of a transit gateway.</p>"];
      local_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the local gateway.</p>"];
      network_interface_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface.</p>"];
      origin: RouteOrigin.t option
        [@ocaml.doc
          "<p>Describes how the route was created.</p> <ul> <li> <p> <code>CreateRouteTable</code> - The route was automatically created when the route table was created.</p> </li> <li> <p> <code>CreateRoute</code> - The route was manually added to the route table.</p> </li> <li> <p> <code>EnableVgwRoutePropagation</code> - The route was propagated by route propagation.</p> </li> </ul>"];
      state: RouteState.t option
        [@ocaml.doc
          "<p>The state of the route. The <code>blackhole</code> state indicates that the route's target isn't available (for example, the specified gateway isn't attached to the VPC, or the specified NAT instance has been terminated).</p>"];
      vpc_peering_connection_id: String.t option
        [@ocaml.doc "<p>The ID of a VPC peering connection.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes a route in a route table.</p>"]
    let make ?destination_cidr_block  ?destination_ipv6_cidr_block 
      ?destination_prefix_list_id  ?egress_only_internet_gateway_id 
      ?gateway_id  ?instance_id  ?instance_owner_id  ?nat_gateway_id 
      ?transit_gateway_id  ?local_gateway_id  ?network_interface_id  ?origin 
      ?state  ?vpc_peering_connection_id  () =
      {
        destination_cidr_block;
        destination_ipv6_cidr_block;
        destination_prefix_list_id;
        egress_only_internet_gateway_id;
        gateway_id;
        instance_id;
        instance_owner_id;
        nat_gateway_id;
        transit_gateway_id;
        local_gateway_id;
        network_interface_id;
        origin;
        state;
        vpc_peering_connection_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (RouteState.to_query f)));
           Util.option_map v.origin
             (fun f -> Query.Pair ("Origin", (RouteOrigin.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.nat_gateway_id
             (fun f -> Query.Pair ("NatGatewayId", (String.to_query f)));
           Util.option_map v.instance_owner_id
             (fun f -> Query.Pair ("InstanceOwnerId", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.gateway_id
             (fun f -> Query.Pair ("GatewayId", (String.to_query f)));
           Util.option_map v.egress_only_internet_gateway_id
             (fun f ->
                Query.Pair
                  ("EgressOnlyInternetGatewayId", (String.to_query f)));
           Util.option_map v.destination_prefix_list_id
             (fun f ->
                Query.Pair ("DestinationPrefixListId", (String.to_query f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f ->
                Query.Pair ("DestinationIpv6CidrBlock", (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (RouteState.to_json f)));
           Util.option_map v.origin
             (fun f -> ("origin", (RouteOrigin.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.nat_gateway_id
             (fun f -> ("nat_gateway_id", (String.to_json f)));
           Util.option_map v.instance_owner_id
             (fun f -> ("instance_owner_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.gateway_id
             (fun f -> ("gateway_id", (String.to_json f)));
           Util.option_map v.egress_only_internet_gateway_id
             (fun f ->
                ("egress_only_internet_gateway_id", (String.to_json f)));
           Util.option_map v.destination_prefix_list_id
             (fun f -> ("destination_prefix_list_id", (String.to_json f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f -> ("destination_ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          destination_ipv6_cidr_block =
            (Util.option_bind (Xml.member "destinationIpv6CidrBlock" xml)
               String.parse);
          destination_prefix_list_id =
            (Util.option_bind (Xml.member "destinationPrefixListId" xml)
               String.parse);
          egress_only_internet_gateway_id =
            (Util.option_bind (Xml.member "egressOnlyInternetGatewayId" xml)
               String.parse);
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_owner_id =
            (Util.option_bind (Xml.member "instanceOwnerId" xml) String.parse);
          nat_gateway_id =
            (Util.option_bind (Xml.member "natGatewayId" xml) String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          origin =
            (Util.option_bind (Xml.member "origin" xml) RouteOrigin.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) RouteState.parse);
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        [Util.option_map v.destination_cidr_block
                           (fun f ->
                              Ezxmlm.make_tag "destinationCidrBlock"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.destination_ipv6_cidr_block
                          (fun f ->
                             Ezxmlm.make_tag "destinationIpv6CidrBlock"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.destination_prefix_list_id
                         (fun f ->
                            Ezxmlm.make_tag "destinationPrefixListId"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.egress_only_internet_gateway_id
                        (fun f ->
                           Ezxmlm.make_tag "egressOnlyInternetGatewayId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.gateway_id
                       (fun f ->
                          Ezxmlm.make_tag "gatewayId" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.instance_id
                      (fun f ->
                         Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.instance_owner_id
                     (fun f ->
                        Ezxmlm.make_tag "instanceOwnerId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.nat_gateway_id
                    (fun f ->
                       Ezxmlm.make_tag "natGatewayId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.transit_gateway_id
                   (fun f ->
                      Ezxmlm.make_tag "transitGatewayId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.local_gateway_id
                  (fun f ->
                     Ezxmlm.make_tag "localGatewayId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.network_interface_id
                 (fun f ->
                    Ezxmlm.make_tag "networkInterfaceId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.origin
                (fun f ->
                   Ezxmlm.make_tag "origin" ([], (RouteOrigin.to_xml f)))])
            @
            [Util.option_map v.state
               (fun f -> Ezxmlm.make_tag "state" ([], (RouteState.to_xml f)))])
           @
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Ezxmlm.make_tag "vpcPeeringConnectionId"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a route in a route table.</p>"]
module RouteTableAssociation =
  struct
    type t =
      {
      main: Boolean.t option
        [@ocaml.doc "<p>Indicates whether this is the main route table.</p>"];
      route_table_association_id: String.t option
        [@ocaml.doc "<p>The ID of the association.</p>"];
      route_table_id: String.t option
        [@ocaml.doc "<p>The ID of the route table.</p>"];
      subnet_id: String.t option
        [@ocaml.doc
          "<p>The ID of the subnet. A subnet ID is not returned for an implicit association.</p>"];
      gateway_id: String.t option
        [@ocaml.doc
          "<p>The ID of the internet gateway or virtual private gateway.</p>"];
      association_state: RouteTableAssociationState.t option
        [@ocaml.doc "<p>The state of the association.</p>"]}[@@ocaml.doc
                                                              "<p>Describes an association between a route table and a subnet or gateway.</p>"]
    let make ?main  ?route_table_association_id  ?route_table_id  ?subnet_id 
      ?gateway_id  ?association_state  () =
      {
        main;
        route_table_association_id;
        route_table_id;
        subnet_id;
        gateway_id;
        association_state
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 Query.Pair
                   ("AssociationState",
                     (RouteTableAssociationState.to_query f)));
           Util.option_map v.gateway_id
             (fun f -> Query.Pair ("GatewayId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.route_table_id
             (fun f -> Query.Pair ("RouteTableId", (String.to_query f)));
           Util.option_map v.route_table_association_id
             (fun f ->
                Query.Pair ("RouteTableAssociationId", (String.to_query f)));
           Util.option_map v.main
             (fun f -> Query.Pair ("Main", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 ("association_state",
                   (RouteTableAssociationState.to_json f)));
           Util.option_map v.gateway_id
             (fun f -> ("gateway_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.route_table_id
             (fun f -> ("route_table_id", (String.to_json f)));
           Util.option_map v.route_table_association_id
             (fun f -> ("route_table_association_id", (String.to_json f)));
           Util.option_map v.main (fun f -> ("main", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          main = (Util.option_bind (Xml.member "main" xml) Boolean.parse);
          route_table_association_id =
            (Util.option_bind (Xml.member "routeTableAssociationId" xml)
               String.parse);
          route_table_id =
            (Util.option_bind (Xml.member "routeTableId" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse);
          association_state =
            (Util.option_bind (Xml.member "associationState" xml)
               RouteTableAssociationState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.main
                   (fun f -> Ezxmlm.make_tag "main" ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.route_table_association_id
                  (fun f ->
                     Ezxmlm.make_tag "routeTableAssociationId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.route_table_id
                 (fun f ->
                    Ezxmlm.make_tag "routeTableId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.subnet_id
                (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.gateway_id
               (fun f -> Ezxmlm.make_tag "gatewayId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.association_state
              (fun f ->
                 Ezxmlm.make_tag "associationState"
                   ([], (RouteTableAssociationState.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an association between a route table and a subnet or gateway.</p>"]
module CreditSpecification =
  struct
    type t =
      {
      cpu_credits: String.t option
        [@ocaml.doc
          "<p>The credit option for CPU usage of a T2 or T3 instance. Valid values are <code>standard</code> and <code>unlimited</code>.</p>"]}
    [@@ocaml.doc
      "<p>Describes the credit option for CPU usage of a T2 or T3 instance.</p>"]
    let make ?cpu_credits  () = { cpu_credits }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> Query.Pair ("CpuCredits", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> ("cpu_credits", (String.to_json f)))])
    let parse xml =
      Some
        {
          cpu_credits =
            (Util.option_bind (Xml.member "cpuCredits" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.cpu_credits
              (fun f -> Ezxmlm.make_tag "cpuCredits" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the credit option for CPU usage of a T2 or T3 instance.</p>"]
module ElasticGpuSpecificationResponseList =
  struct
    type t = ElasticGpuSpecificationResponse.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list ElasticGpuSpecificationResponse.to_query v
    let to_headers v =
      Headers.to_headers_list ElasticGpuSpecificationResponse.to_headers v
    let to_json v =
      `List (List.map ElasticGpuSpecificationResponse.to_json v)
    let parse xml =
      Util.option_all
        (List.map ElasticGpuSpecificationResponse.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ElasticGpuSpecificationResponse.to_xml x))) v
  end
module LaunchTemplateBlockDeviceMappingList =
  struct
    type t = LaunchTemplateBlockDeviceMapping.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list LaunchTemplateBlockDeviceMapping.to_query v
    let to_headers v =
      Headers.to_headers_list LaunchTemplateBlockDeviceMapping.to_headers v
    let to_json v =
      `List (List.map LaunchTemplateBlockDeviceMapping.to_json v)
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateBlockDeviceMapping.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LaunchTemplateBlockDeviceMapping.to_xml x))) v
  end
module LaunchTemplateCapacityReservationSpecificationResponse =
  struct
    type t =
      {
      capacity_reservation_preference: CapacityReservationPreference.t option
        [@ocaml.doc
          "<p>Indicates the instance's Capacity Reservation preferences. Possible preferences include:</p> <ul> <li> <p> <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).</p> </li> <li> <p> <code>none</code> - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.</p> </li> </ul>"];
      capacity_reservation_target: CapacityReservationTargetResponse.t option
        [@ocaml.doc
          "<p>Information about the target Capacity Reservation.</p>"]}
    [@@ocaml.doc
      "<p>Information about the Capacity Reservation targeting option.</p>"]
    let make ?capacity_reservation_preference  ?capacity_reservation_target 
      () = { capacity_reservation_preference; capacity_reservation_target }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Query.Pair
                   ("CapacityReservationTarget",
                     (CapacityReservationTargetResponse.to_query f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                Query.Pair
                  ("CapacityReservationPreference",
                    (CapacityReservationPreference.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 ("capacity_reservation_target",
                   (CapacityReservationTargetResponse.to_json f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                ("capacity_reservation_preference",
                  (CapacityReservationPreference.to_json f)))])
    let parse xml =
      Some
        {
          capacity_reservation_preference =
            (Util.option_bind
               (Xml.member "capacityReservationPreference" xml)
               CapacityReservationPreference.parse);
          capacity_reservation_target =
            (Util.option_bind (Xml.member "capacityReservationTarget" xml)
               CapacityReservationTargetResponse.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.capacity_reservation_preference
               (fun f ->
                  Ezxmlm.make_tag "capacityReservationPreference"
                    ([], (CapacityReservationPreference.to_xml f)))])
           @
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Ezxmlm.make_tag "capacityReservationTarget"
                   ([], (CapacityReservationTargetResponse.to_xml f)))])
  end[@@ocaml.doc
       "<p>Information about the Capacity Reservation targeting option.</p>"]
module LaunchTemplateCpuOptions =
  struct
    type t =
      {
      core_count: Integer.t option
        [@ocaml.doc "<p>The number of CPU cores for the instance.</p>"];
      threads_per_core: Integer.t option
        [@ocaml.doc "<p>The number of threads per CPU core.</p>"]}[@@ocaml.doc
                                                                    "<p>The CPU options for the instance.</p>"]
    let make ?core_count  ?threads_per_core  () =
      { core_count; threads_per_core }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> Query.Pair ("ThreadsPerCore", (Integer.to_query f)));
           Util.option_map v.core_count
             (fun f -> Query.Pair ("CoreCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> ("threads_per_core", (Integer.to_json f)));
           Util.option_map v.core_count
             (fun f -> ("core_count", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          core_count =
            (Util.option_bind (Xml.member "coreCount" xml) Integer.parse);
          threads_per_core =
            (Util.option_bind (Xml.member "threadsPerCore" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.core_count
               (fun f -> Ezxmlm.make_tag "coreCount" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.threads_per_core
              (fun f ->
                 Ezxmlm.make_tag "threadsPerCore" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc "<p>The CPU options for the instance.</p>"]
module LaunchTemplateElasticInferenceAcceleratorResponseList =
  struct
    type t = LaunchTemplateElasticInferenceAcceleratorResponse.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list
        LaunchTemplateElasticInferenceAcceleratorResponse.to_query v
    let to_headers v =
      Headers.to_headers_list
        LaunchTemplateElasticInferenceAcceleratorResponse.to_headers v
    let to_json v =
      `List
        (List.map LaunchTemplateElasticInferenceAcceleratorResponse.to_json v)
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateElasticInferenceAcceleratorResponse.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([],
               (LaunchTemplateElasticInferenceAcceleratorResponse.to_xml x)))
        v
  end
module LaunchTemplateHibernationOptions =
  struct
    type t =
      {
      configured: Boolean.t option
        [@ocaml.doc
          "<p>If this parameter is set to <code>true</code>, the instance is enabled for hibernation; otherwise, it is not enabled for hibernation.</p>"]}
    [@@ocaml.doc
      "<p>Indicates whether an instance is configured for hibernation.</p>"]
    let make ?configured  () = { configured }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> Query.Pair ("Configured", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> ("configured", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          configured =
            (Util.option_bind (Xml.member "configured" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.configured
              (fun f -> Ezxmlm.make_tag "configured" ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc
       "<p>Indicates whether an instance is configured for hibernation.</p>"]
module LaunchTemplateIamInstanceProfileSpecification =
  struct
    type t =
      {
      arn: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the instance profile.</p>"];
      name: String.t option
        [@ocaml.doc "<p>The name of the instance profile.</p>"]}[@@ocaml.doc
                                                                  "<p>Describes an IAM instance profile.</p>"]
    let make ?arn  ?name  () = { arn; name }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "arn" xml) String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.arn
               (fun f -> Ezxmlm.make_tag "arn" ([], (String.to_xml f)))])
           @
           [Util.option_map v.name
              (fun f -> Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an IAM instance profile.</p>"]
module LaunchTemplateInstanceMarketOptions =
  struct
    type t =
      {
      market_type: MarketType.t option [@ocaml.doc "<p>The market type.</p>"];
      spot_options: LaunchTemplateSpotMarketOptions.t option
        [@ocaml.doc "<p>The options for Spot Instances.</p>"]}[@@ocaml.doc
                                                                "<p>The market (purchasing) option for the instances.</p>"]
    let make ?market_type  ?spot_options  () = { market_type; spot_options }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f ->
                 Query.Pair
                   ("SpotOptions",
                     (LaunchTemplateSpotMarketOptions.to_query f)));
           Util.option_map v.market_type
             (fun f -> Query.Pair ("MarketType", (MarketType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f ->
                 ("spot_options",
                   (LaunchTemplateSpotMarketOptions.to_json f)));
           Util.option_map v.market_type
             (fun f -> ("market_type", (MarketType.to_json f)))])
    let parse xml =
      Some
        {
          market_type =
            (Util.option_bind (Xml.member "marketType" xml) MarketType.parse);
          spot_options =
            (Util.option_bind (Xml.member "spotOptions" xml)
               LaunchTemplateSpotMarketOptions.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.market_type
               (fun f ->
                  Ezxmlm.make_tag "marketType" ([], (MarketType.to_xml f)))])
           @
           [Util.option_map v.spot_options
              (fun f ->
                 Ezxmlm.make_tag "spotOptions"
                   ([], (LaunchTemplateSpotMarketOptions.to_xml f)))])
  end[@@ocaml.doc "<p>The market (purchasing) option for the instances.</p>"]
module LaunchTemplateInstanceNetworkInterfaceSpecificationList =
  struct
    type t = LaunchTemplateInstanceNetworkInterfaceSpecification.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list
        LaunchTemplateInstanceNetworkInterfaceSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list
        LaunchTemplateInstanceNetworkInterfaceSpecification.to_headers v
    let to_json v =
      `List
        (List.map LaunchTemplateInstanceNetworkInterfaceSpecification.to_json
           v)
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateInstanceNetworkInterfaceSpecification.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([],
               (LaunchTemplateInstanceNetworkInterfaceSpecification.to_xml x)))
        v
  end
module LaunchTemplateLicenseList =
  struct
    type t = LaunchTemplateLicenseConfiguration.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list LaunchTemplateLicenseConfiguration.to_query v
    let to_headers v =
      Headers.to_headers_list LaunchTemplateLicenseConfiguration.to_headers v
    let to_json v =
      `List (List.map LaunchTemplateLicenseConfiguration.to_json v)
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateLicenseConfiguration.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LaunchTemplateLicenseConfiguration.to_xml x))) v
  end
module LaunchTemplatePlacement =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc "<p>The Availability Zone of the instance.</p>"];
      affinity: String.t option
        [@ocaml.doc
          "<p>The affinity setting for the instance on the Dedicated Host.</p>"];
      group_name: String.t option
        [@ocaml.doc
          "<p>The name of the placement group for the instance.</p>"];
      host_id: String.t option
        [@ocaml.doc "<p>The ID of the Dedicated Host for the instance.</p>"];
      tenancy: Tenancy.t option
        [@ocaml.doc
          "<p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of <code>dedicated</code> runs on single-tenant hardware. </p>"];
      spread_domain: String.t option
        [@ocaml.doc "<p>Reserved for future use.</p>"];
      host_resource_group_arn: String.t option
        [@ocaml.doc
          "<p>The ARN of the host resource group in which to launch the instances.</p>"]}
    [@@ocaml.doc "<p>Describes the placement of an instance.</p>"]
    let make ?availability_zone  ?affinity  ?group_name  ?host_id  ?tenancy 
      ?spread_domain  ?host_resource_group_arn  () =
      {
        availability_zone;
        affinity;
        group_name;
        host_id;
        tenancy;
        spread_domain;
        host_resource_group_arn
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f ->
                 Query.Pair ("HostResourceGroupArn", (String.to_query f)));
           Util.option_map v.spread_domain
             (fun f -> Query.Pair ("SpreadDomain", (String.to_query f)));
           Util.option_map v.tenancy
             (fun f -> Query.Pair ("Tenancy", (Tenancy.to_query f)));
           Util.option_map v.host_id
             (fun f -> Query.Pair ("HostId", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.affinity
             (fun f -> Query.Pair ("Affinity", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f -> ("host_resource_group_arn", (String.to_json f)));
           Util.option_map v.spread_domain
             (fun f -> ("spread_domain", (String.to_json f)));
           Util.option_map v.tenancy
             (fun f -> ("tenancy", (Tenancy.to_json f)));
           Util.option_map v.host_id
             (fun f -> ("host_id", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.affinity
             (fun f -> ("affinity", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          affinity =
            (Util.option_bind (Xml.member "affinity" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          host_id = (Util.option_bind (Xml.member "hostId" xml) String.parse);
          tenancy =
            (Util.option_bind (Xml.member "tenancy" xml) Tenancy.parse);
          spread_domain =
            (Util.option_bind (Xml.member "spreadDomain" xml) String.parse);
          host_resource_group_arn =
            (Util.option_bind (Xml.member "hostResourceGroupArn" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.availability_zone
                    (fun f ->
                       Ezxmlm.make_tag "availabilityZone"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.affinity
                   (fun f ->
                      Ezxmlm.make_tag "affinity" ([], (String.to_xml f)))])
               @
               [Util.option_map v.group_name
                  (fun f ->
                     Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.host_id
                 (fun f -> Ezxmlm.make_tag "hostId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.tenancy
                (fun f -> Ezxmlm.make_tag "tenancy" ([], (Tenancy.to_xml f)))])
            @
            [Util.option_map v.spread_domain
               (fun f ->
                  Ezxmlm.make_tag "spreadDomain" ([], (String.to_xml f)))])
           @
           [Util.option_map v.host_resource_group_arn
              (fun f ->
                 Ezxmlm.make_tag "hostResourceGroupArn"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the placement of an instance.</p>"]
module LaunchTemplateTagSpecificationList =
  struct
    type t = LaunchTemplateTagSpecification.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list LaunchTemplateTagSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list LaunchTemplateTagSpecification.to_headers v
    let to_json v = `List (List.map LaunchTemplateTagSpecification.to_json v)
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateTagSpecification.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LaunchTemplateTagSpecification.to_xml x))) v
  end
module LaunchTemplatesMonitoring =
  struct
    type t =
      {
      enabled: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.</p>"]}
    [@@ocaml.doc "<p>Describes the monitoring for the instance.</p>"]
    let make ?enabled  () = { enabled }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "enabled" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.enabled
              (fun f -> Ezxmlm.make_tag "enabled" ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the monitoring for the instance.</p>"]
module ShutdownBehavior =
  struct
    type t =
      | Stop 
      | Terminate 
    let str_to_t = [("terminate", Terminate); ("stop", Stop)]
    let t_to_str = [(Terminate, "terminate"); (Stop, "stop")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ValueStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module LaunchTemplateEbsBlockDeviceRequest =
  struct
    type t =
      {
      encrypted: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.</p>"];
      delete_on_termination: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the EBS volume is deleted on instance termination.</p>"];
      iops: Integer.t option
        [@ocaml.doc
          "<p>The number of I/O operations per second (IOPS) that the volume supports. For io1, this represents the number of IOPS that are provisioned for the volume. For gp2, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about General Purpose SSD baseline performance, I/O credits, and bursting, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html\">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Condition: This parameter is required for requests to create io1 volumes; it is not used in requests to create gp2, st1, sc1, or standard volumes.</p>"];
      kms_key_id: String.t option
        [@ocaml.doc
          "<p>The ARN of the symmetric AWS Key Management Service (AWS KMS) CMK used for encryption.</p>"];
      snapshot_id: String.t option
        [@ocaml.doc "<p>The ID of the snapshot.</p>"];
      volume_size: Integer.t option
        [@ocaml.doc
          "<p>The size of the volume, in GiB.</p> <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>"];
      volume_type: VolumeType.t option [@ocaml.doc "<p>The volume type.</p>"]}
    [@@ocaml.doc
      "<p>The parameters for a block device for an EBS volume.</p>"]
    let make ?encrypted  ?delete_on_termination  ?iops  ?kms_key_id 
      ?snapshot_id  ?volume_size  ?volume_type  () =
      {
        encrypted;
        delete_on_termination;
        iops;
        kms_key_id;
        snapshot_id;
        volume_size;
        volume_type
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> Query.Pair ("VolumeType", (VolumeType.to_query f)));
           Util.option_map v.volume_size
             (fun f -> Query.Pair ("VolumeSize", (Integer.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> ("volume_type", (VolumeType.to_json f)));
           Util.option_map v.volume_size
             (fun f -> ("volume_size", (Integer.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          encrypted =
            (Util.option_bind (Xml.member "Encrypted" xml) Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "DeleteOnTermination" xml)
               Boolean.parse);
          iops = (Util.option_bind (Xml.member "Iops" xml) Integer.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "KmsKeyId" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "SnapshotId" xml) String.parse);
          volume_size =
            (Util.option_bind (Xml.member "VolumeSize" xml) Integer.parse);
          volume_type =
            (Util.option_bind (Xml.member "VolumeType" xml) VolumeType.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.encrypted
                    (fun f ->
                       Ezxmlm.make_tag "Encrypted" ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.delete_on_termination
                   (fun f ->
                      Ezxmlm.make_tag "DeleteOnTermination"
                        ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.iops
                  (fun f -> Ezxmlm.make_tag "Iops" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.kms_key_id
                 (fun f -> Ezxmlm.make_tag "KmsKeyId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.snapshot_id
                (fun f ->
                   Ezxmlm.make_tag "SnapshotId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.volume_size
               (fun f ->
                  Ezxmlm.make_tag "VolumeSize" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.volume_type
              (fun f ->
                 Ezxmlm.make_tag "VolumeType" ([], (VolumeType.to_xml f)))])
  end[@@ocaml.doc
       "<p>The parameters for a block device for an EBS volume.</p>"]
module InstanceIpv6AddressListRequest =
  struct
    type t = InstanceIpv6AddressRequest.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list InstanceIpv6AddressRequest.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceIpv6AddressRequest.to_headers v
    let to_json v = `List (List.map InstanceIpv6AddressRequest.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceIpv6AddressRequest.parse
           (Xml.members "InstanceIpv6Address" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InstanceIpv6AddressRequest.to_xml x))) v
  end
module LaunchTemplateErrorCode =
  struct
    type t =
      | LaunchTemplateIdDoesNotExist 
      | LaunchTemplateIdMalformed 
      | LaunchTemplateNameDoesNotExist 
      | LaunchTemplateNameMalformed 
      | LaunchTemplateVersionDoesNotExist 
      | UnexpectedError 
    let str_to_t =
      [("unexpectedError", UnexpectedError);
      ("launchTemplateVersionDoesNotExist",
        LaunchTemplateVersionDoesNotExist);
      ("launchTemplateNameMalformed", LaunchTemplateNameMalformed);
      ("launchTemplateNameDoesNotExist", LaunchTemplateNameDoesNotExist);
      ("launchTemplateIdMalformed", LaunchTemplateIdMalformed);
      ("launchTemplateIdDoesNotExist", LaunchTemplateIdDoesNotExist)]
    let t_to_str =
      [(UnexpectedError, "unexpectedError");
      (LaunchTemplateVersionDoesNotExist,
        "launchTemplateVersionDoesNotExist");
      (LaunchTemplateNameMalformed, "launchTemplateNameMalformed");
      (LaunchTemplateNameDoesNotExist, "launchTemplateNameDoesNotExist");
      (LaunchTemplateIdMalformed, "launchTemplateIdMalformed");
      (LaunchTemplateIdDoesNotExist, "launchTemplateIdDoesNotExist")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module RunInstancesMonitoringEnabled =
  struct
    type t =
      {
      enabled: Boolean.t
        [@ocaml.doc
          "<p>Indicates whether detailed monitoring is enabled. Otherwise, basic monitoring is enabled.</p>"]}
    [@@ocaml.doc "<p>Describes the monitoring of an instance.</p>"]
    let make ~enabled  () = { enabled }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Enabled", (Boolean.to_query v.enabled)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt [Some ("enabled", (Boolean.to_json v.enabled))])
    let parse xml =
      Some
        {
          enabled =
            (Xml.required "enabled"
               (Util.option_bind (Xml.member "enabled" xml) Boolean.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some (Ezxmlm.make_tag "enabled" ([], (Boolean.to_xml v.enabled)))])
  end[@@ocaml.doc "<p>Describes the monitoring of an instance.</p>"]
module DeleteQueuedReservedInstancesErrorCode =
  struct
    type t =
      | Reserved_instances_id_invalid 
      | Reserved_instances_not_in_queued_state 
      | Unexpected_error 
    let str_to_t =
      [("unexpected-error", Unexpected_error);
      ("reserved-instances-not-in-queued-state",
        Reserved_instances_not_in_queued_state);
      ("reserved-instances-id-invalid", Reserved_instances_id_invalid)]
    let t_to_str =
      [(Unexpected_error, "unexpected-error");
      (Reserved_instances_not_in_queued_state,
        "reserved-instances-not-in-queued-state");
      (Reserved_instances_id_invalid, "reserved-instances-id-invalid")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ContainerFormat =
  struct
    type t =
      | Ova 
    let str_to_t = [("ova", Ova)]
    let t_to_str = [(Ova, "ova")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ExportEnvironment =
  struct
    type t =
      | Citrix 
      | Vmware 
      | Microsoft 
    let str_to_t =
      [("microsoft", Microsoft); ("vmware", Vmware); ("citrix", Citrix)]
    let t_to_str =
      [(Microsoft, "microsoft"); (Vmware, "vmware"); (Citrix, "citrix")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module IpPermission =
  struct
    type t =
      {
      from_port: Integer.t option
        [@ocaml.doc
          "<p>The start of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 type number. A value of <code>-1</code> indicates all ICMP/ICMPv6 types. If you specify all ICMP/ICMPv6 types, you must specify all codes.</p>"];
      ip_protocol: String.t
        [@ocaml.doc
          "<p>The IP protocol name (<code>tcp</code>, <code>udp</code>, <code>icmp</code>, <code>icmpv6</code>) or number (see <a href=\"http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml\">Protocol Numbers</a>).</p> <p>[VPC only] Use <code>-1</code> to specify all protocols. When authorizing security group rules, specifying <code>-1</code> or a protocol number other than <code>tcp</code>, <code>udp</code>, <code>icmp</code>, or <code>icmpv6</code> allows traffic on all ports, regardless of any port range you specify. For <code>tcp</code>, <code>udp</code>, and <code>icmp</code>, you must specify a port range. For <code>icmpv6</code>, the port range is optional; if you omit the port range, traffic for all types and codes is allowed.</p>"];
      ip_ranges: IpRangeList.t [@ocaml.doc "<p>The IPv4 ranges.</p>"];
      ipv6_ranges: Ipv6RangeList.t
        [@ocaml.doc "<p>[VPC only] The IPv6 ranges.</p>"];
      prefix_list_ids: PrefixListIdList.t
        [@ocaml.doc
          "<p>[VPC only] The prefix list IDs for an AWS service. With outbound rules, this is the AWS service to access through a VPC endpoint from instances associated with the security group.</p>"];
      to_port: Integer.t option
        [@ocaml.doc
          "<p>The end of port range for the TCP and UDP protocols, or an ICMP/ICMPv6 code. A value of <code>-1</code> indicates all ICMP/ICMPv6 codes. If you specify all ICMP/ICMPv6 types, you must specify all codes.</p>"];
      user_id_group_pairs: UserIdGroupPairList.t
        [@ocaml.doc "<p>The security group and AWS account ID pairs.</p>"]}
    [@@ocaml.doc
      "<p>Describes a set of permissions for a security group rule.</p>"]
    let make ?from_port  ~ip_protocol  ?(ip_ranges= [])  ?(ipv6_ranges= []) 
      ?(prefix_list_ids= [])  ?to_port  ?(user_id_group_pairs= [])  () =
      {
        from_port;
        ip_protocol;
        ip_ranges;
        ipv6_ranges;
        prefix_list_ids;
        to_port;
        user_id_group_pairs
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Groups",
                   (UserIdGroupPairList.to_query v.user_id_group_pairs)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrefixListIds",
                  (PrefixListIdList.to_query v.prefix_list_ids)));
           Some
             (Query.Pair
                ("Ipv6Ranges", (Ipv6RangeList.to_query v.ipv6_ranges)));
           Some (Query.Pair ("IpRanges", (IpRangeList.to_query v.ip_ranges)));
           Some (Query.Pair ("IpProtocol", (String.to_query v.ip_protocol)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("user_id_group_pairs",
                (UserIdGroupPairList.to_json v.user_id_group_pairs));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Some
             ("prefix_list_ids",
               (PrefixListIdList.to_json v.prefix_list_ids));
           Some ("ipv6_ranges", (Ipv6RangeList.to_json v.ipv6_ranges));
           Some ("ip_ranges", (IpRangeList.to_json v.ip_ranges));
           Some ("ip_protocol", (String.to_json v.ip_protocol));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          from_port =
            (Util.option_bind (Xml.member "fromPort" xml) Integer.parse);
          ip_protocol =
            (Xml.required "ipProtocol"
               (Util.option_bind (Xml.member "ipProtocol" xml) String.parse));
          ip_ranges =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipRanges" xml)
                  IpRangeList.parse));
          ipv6_ranges =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6Ranges" xml)
                  Ipv6RangeList.parse));
          prefix_list_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "prefixListIds" xml)
                  PrefixListIdList.parse));
          to_port =
            (Util.option_bind (Xml.member "toPort" xml) Integer.parse);
          user_id_group_pairs =
            (Util.of_option []
               (Util.option_bind (Xml.member "groups" xml)
                  UserIdGroupPairList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.from_port
                    (fun f ->
                       Ezxmlm.make_tag "fromPort" ([], (Integer.to_xml f)))])
                @
                [Some
                   (Ezxmlm.make_tag "ipProtocol"
                      ([], (String.to_xml v.ip_protocol)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "ipRanges"
                          ([], (IpRangeList.to_xml [x])))) v.ip_ranges))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "ipv6Ranges"
                         ([], (Ipv6RangeList.to_xml [x])))) v.ipv6_ranges))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "prefixListIds"
                        ([], (PrefixListIdList.to_xml [x]))))
                v.prefix_list_ids))
            @
            [Util.option_map v.to_port
               (fun f -> Ezxmlm.make_tag "toPort" ([], (Integer.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "groups"
                      ([], (UserIdGroupPairList.to_xml [x]))))
              v.user_id_group_pairs))
  end[@@ocaml.doc
       "<p>Describes a set of permissions for a security group rule.</p>"]
module AssociatedTargetNetwork =
  struct
    type t =
      {
      network_id: String.t option [@ocaml.doc "<p>The ID of the subnet.</p>"];
      network_type: AssociatedNetworkType.t option
        [@ocaml.doc "<p>The target network type.</p>"]}[@@ocaml.doc
                                                         "<p>Describes a target network that is associated with a Client VPN endpoint. A target network is a subnet in a VPC.</p>"]
    let make ?network_id  ?network_type  () = { network_id; network_type }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_type
              (fun f ->
                 Query.Pair
                   ("NetworkType", (AssociatedNetworkType.to_query f)));
           Util.option_map v.network_id
             (fun f -> Query.Pair ("NetworkId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_type
              (fun f -> ("network_type", (AssociatedNetworkType.to_json f)));
           Util.option_map v.network_id
             (fun f -> ("network_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          network_id =
            (Util.option_bind (Xml.member "networkId" xml) String.parse);
          network_type =
            (Util.option_bind (Xml.member "networkType" xml)
               AssociatedNetworkType.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.network_id
               (fun f -> Ezxmlm.make_tag "networkId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.network_type
              (fun f ->
                 Ezxmlm.make_tag "networkType"
                   ([], (AssociatedNetworkType.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a target network that is associated with a Client VPN endpoint. A target network is a subnet in a VPC.</p>"]
module ClientVpnAuthentication =
  struct
    type t =
      {
      type_: ClientVpnAuthenticationType.t option
        [@ocaml.doc "<p>The authentication type used.</p>"];
      active_directory: DirectoryServiceAuthentication.t option
        [@ocaml.doc
          "<p>Information about the Active Directory, if applicable.</p>"];
      mutual_authentication: CertificateAuthentication.t option
        [@ocaml.doc
          "<p>Information about the authentication certificates, if applicable.</p>"]}
    [@@ocaml.doc
      "<p>Describes the authentication methods used by a Client VPN endpoint. Client VPN supports Active Directory and mutual authentication. For more information, see <a href=\"https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/authentication-authrization.html#client-authentication\">Authentication</a> in the <i>AWS Client VPN Administrator Guide</i>.</p>"]
    let make ?type_  ?active_directory  ?mutual_authentication  () =
      { type_; active_directory; mutual_authentication }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.mutual_authentication
              (fun f ->
                 Query.Pair
                   ("MutualAuthentication",
                     (CertificateAuthentication.to_query f)));
           Util.option_map v.active_directory
             (fun f ->
                Query.Pair
                  ("ActiveDirectory",
                    (DirectoryServiceAuthentication.to_query f)));
           Util.option_map v.type_
             (fun f ->
                Query.Pair ("Type", (ClientVpnAuthenticationType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.mutual_authentication
              (fun f ->
                 ("mutual_authentication",
                   (CertificateAuthentication.to_json f)));
           Util.option_map v.active_directory
             (fun f ->
                ("active_directory",
                  (DirectoryServiceAuthentication.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (ClientVpnAuthenticationType.to_json f)))])
    let parse xml =
      Some
        {
          type_ =
            (Util.option_bind (Xml.member "type" xml)
               ClientVpnAuthenticationType.parse);
          active_directory =
            (Util.option_bind (Xml.member "activeDirectory" xml)
               DirectoryServiceAuthentication.parse);
          mutual_authentication =
            (Util.option_bind (Xml.member "mutualAuthentication" xml)
               CertificateAuthentication.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.type_
                (fun f ->
                   Ezxmlm.make_tag "type"
                     ([], (ClientVpnAuthenticationType.to_xml f)))])
            @
            [Util.option_map v.active_directory
               (fun f ->
                  Ezxmlm.make_tag "activeDirectory"
                    ([], (DirectoryServiceAuthentication.to_xml f)))])
           @
           [Util.option_map v.mutual_authentication
              (fun f ->
                 Ezxmlm.make_tag "mutualAuthentication"
                   ([], (CertificateAuthentication.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the authentication methods used by a Client VPN endpoint. Client VPN supports Active Directory and mutual authentication. For more information, see <a href=\"https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/authentication-authrization.html#client-authentication\">Authentication</a> in the <i>AWS Client VPN Administrator Guide</i>.</p>"]
module ClientVpnEndpointStatusCode =
  struct
    type t =
      | Pending_associate 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending-associate", Pending_associate)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending_associate, "pending-associate")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module FleetLaunchTemplateOverridesRequest =
  struct
    type t =
      {
      instance_type: InstanceType.t option
        [@ocaml.doc "<p>The instance type.</p>"];
      max_price: String.t option
        [@ocaml.doc
          "<p>The maximum price per unit hour that you are willing to pay for a Spot Instance.</p>"];
      subnet_id: String.t option
        [@ocaml.doc
          "<p>The ID of the subnet in which to launch the instances.</p>"];
      availability_zone: String.t option
        [@ocaml.doc
          "<p>The Availability Zone in which to launch the instances.</p>"];
      weighted_capacity: Double.t option
        [@ocaml.doc
          "<p>The number of units provided by the specified instance type.</p>"];
      priority: Double.t option
        [@ocaml.doc
          "<p>The priority for the launch template override. If <b>AllocationStrategy</b> is set to <code>prioritized</code>, EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity. The highest priority is launched first. Valid values are whole numbers starting at <code>0</code>. The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority.</p>"];
      placement: Placement.t option
        [@ocaml.doc
          "<p>The location where the instance launched, if applicable.</p>"]}
    [@@ocaml.doc "<p>Describes overrides for a launch template.</p>"]
    let make ?instance_type  ?max_price  ?subnet_id  ?availability_zone 
      ?weighted_capacity  ?priority  ?placement  () =
      {
        instance_type;
        max_price;
        subnet_id;
        availability_zone;
        weighted_capacity;
        priority;
        placement
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.placement
              (fun f -> Query.Pair ("Placement", (Placement.to_query f)));
           Util.option_map v.priority
             (fun f -> Query.Pair ("Priority", (Double.to_query f)));
           Util.option_map v.weighted_capacity
             (fun f -> Query.Pair ("WeightedCapacity", (Double.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.max_price
             (fun f -> Query.Pair ("MaxPrice", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.placement
              (fun f -> ("placement", (Placement.to_json f)));
           Util.option_map v.priority
             (fun f -> ("priority", (Double.to_json f)));
           Util.option_map v.weighted_capacity
             (fun f -> ("weighted_capacity", (Double.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.max_price
             (fun f -> ("max_price", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)))])
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml)
               InstanceType.parse);
          max_price =
            (Util.option_bind (Xml.member "MaxPrice" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "SubnetId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          weighted_capacity =
            (Util.option_bind (Xml.member "WeightedCapacity" xml)
               Double.parse);
          priority =
            (Util.option_bind (Xml.member "Priority" xml) Double.parse);
          placement =
            (Util.option_bind (Xml.member "Placement" xml) Placement.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.instance_type
                    (fun f ->
                       Ezxmlm.make_tag "InstanceType"
                         ([], (InstanceType.to_xml f)))])
                @
                [Util.option_map v.max_price
                   (fun f ->
                      Ezxmlm.make_tag "MaxPrice" ([], (String.to_xml f)))])
               @
               [Util.option_map v.subnet_id
                  (fun f ->
                     Ezxmlm.make_tag "SubnetId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.availability_zone
                 (fun f ->
                    Ezxmlm.make_tag "AvailabilityZone"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.weighted_capacity
                (fun f ->
                   Ezxmlm.make_tag "WeightedCapacity" ([], (Double.to_xml f)))])
            @
            [Util.option_map v.priority
               (fun f -> Ezxmlm.make_tag "Priority" ([], (Double.to_xml f)))])
           @
           [Util.option_map v.placement
              (fun f ->
                 Ezxmlm.make_tag "Placement" ([], (Placement.to_xml f)))])
  end[@@ocaml.doc "<p>Describes overrides for a launch template.</p>"]
module InternetGatewayAttachment =
  struct
    type t =
      {
      state: AttachmentStatus.t
        [@ocaml.doc
          "<p>The current state of the attachment. For an internet gateway, the state is <code>available</code> when attached to a VPC; otherwise, this value is not returned.</p>"];
      vpc_id: String.t [@ocaml.doc "<p>The ID of the VPC.</p>"]}[@@ocaml.doc
                                                                  "<p>Describes the attachment of a VPC to an internet gateway or an egress-only internet gateway.</p>"]
    let make ~state  ~vpc_id  () = { state; vpc_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some (Query.Pair ("State", (AttachmentStatus.to_query v.state)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("state", (AttachmentStatus.to_json v.state))])
    let parse xml =
      Some
        {
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml)
                  AttachmentStatus.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "state"
                  ([], (AttachmentStatus.to_xml v.state)))])
           @ [Some (Ezxmlm.make_tag "vpcId" ([], (String.to_xml v.vpc_id)))])
  end[@@ocaml.doc
       "<p>Describes the attachment of a VPC to an internet gateway or an egress-only internet gateway.</p>"]
module DescribeFleetError =
  struct
    type t =
      {
      launch_template_and_overrides:
        LaunchTemplateAndOverridesResponse.t option
        [@ocaml.doc
          "<p>The launch templates and overrides that were used for launching the instances. The values that you specify in the Overrides replace the values in the launch template.</p>"];
      lifecycle: InstanceLifecycle.t option
        [@ocaml.doc
          "<p>Indicates if the instance that could not be launched was a Spot Instance or On-Demand Instance.</p>"];
      error_code: String.t option
        [@ocaml.doc
          "<p>The error code that indicates why the instance could not be launched. For more information about error codes, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html\">Error Codes</a>.</p>"];
      error_message: String.t option
        [@ocaml.doc
          "<p>The error message that describes why the instance could not be launched. For more information about error messages, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html\">Error Codes</a>.</p>"]}
    [@@ocaml.doc
      "<p>Describes the instances that could not be launched by the fleet.</p>"]
    let make ?launch_template_and_overrides  ?lifecycle  ?error_code 
      ?error_message  () =
      { launch_template_and_overrides; lifecycle; error_code; error_message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.error_message
              (fun f -> Query.Pair ("ErrorMessage", (String.to_query f)));
           Util.option_map v.error_code
             (fun f -> Query.Pair ("ErrorCode", (String.to_query f)));
           Util.option_map v.lifecycle
             (fun f ->
                Query.Pair ("Lifecycle", (InstanceLifecycle.to_query f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                Query.Pair
                  ("LaunchTemplateAndOverrides",
                    (LaunchTemplateAndOverridesResponse.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.error_message
              (fun f -> ("error_message", (String.to_json f)));
           Util.option_map v.error_code
             (fun f -> ("error_code", (String.to_json f)));
           Util.option_map v.lifecycle
             (fun f -> ("lifecycle", (InstanceLifecycle.to_json f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                ("launch_template_and_overrides",
                  (LaunchTemplateAndOverridesResponse.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_and_overrides =
            (Util.option_bind (Xml.member "launchTemplateAndOverrides" xml)
               LaunchTemplateAndOverridesResponse.parse);
          lifecycle =
            (Util.option_bind (Xml.member "lifecycle" xml)
               InstanceLifecycle.parse);
          error_code =
            (Util.option_bind (Xml.member "errorCode" xml) String.parse);
          error_message =
            (Util.option_bind (Xml.member "errorMessage" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.launch_template_and_overrides
                 (fun f ->
                    Ezxmlm.make_tag "launchTemplateAndOverrides"
                      ([], (LaunchTemplateAndOverridesResponse.to_xml f)))])
             @
             [Util.option_map v.lifecycle
                (fun f ->
                   Ezxmlm.make_tag "lifecycle"
                     ([], (InstanceLifecycle.to_xml f)))])
            @
            [Util.option_map v.error_code
               (fun f -> Ezxmlm.make_tag "errorCode" ([], (String.to_xml f)))])
           @
           [Util.option_map v.error_message
              (fun f ->
                 Ezxmlm.make_tag "errorMessage" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the instances that could not be launched by the fleet.</p>"]
module DescribeFleetsInstances =
  struct
    type t =
      {
      launch_template_and_overrides:
        LaunchTemplateAndOverridesResponse.t option
        [@ocaml.doc
          "<p>The launch templates and overrides that were used for launching the instances. The values that you specify in the Overrides replace the values in the launch template.</p>"];
      lifecycle: InstanceLifecycle.t option
        [@ocaml.doc
          "<p>Indicates if the instance that was launched is a Spot Instance or On-Demand Instance.</p>"];
      instance_ids: InstanceIdsSet.t
        [@ocaml.doc "<p>The IDs of the instances.</p>"];
      instance_type: InstanceType.t option
        [@ocaml.doc "<p>The instance type.</p>"];
      platform: PlatformValues.t option
        [@ocaml.doc
          "<p>The value is <code>Windows</code> for Windows instances. Otherwise, the value is blank.</p>"]}
    [@@ocaml.doc
      "<p>Describes the instances that were launched by the fleet.</p>"]
    let make ?launch_template_and_overrides  ?lifecycle  ?(instance_ids= []) 
      ?instance_type  ?platform  () =
      {
        launch_template_and_overrides;
        lifecycle;
        instance_ids;
        instance_type;
        platform
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.platform
              (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Some
             (Query.Pair
                ("InstanceIds", (InstanceIdsSet.to_query v.instance_ids)));
           Util.option_map v.lifecycle
             (fun f ->
                Query.Pair ("Lifecycle", (InstanceLifecycle.to_query f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                Query.Pair
                  ("LaunchTemplateAndOverrides",
                    (LaunchTemplateAndOverridesResponse.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.platform
              (fun f -> ("platform", (PlatformValues.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Some ("instance_ids", (InstanceIdsSet.to_json v.instance_ids));
           Util.option_map v.lifecycle
             (fun f -> ("lifecycle", (InstanceLifecycle.to_json f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                ("launch_template_and_overrides",
                  (LaunchTemplateAndOverridesResponse.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_and_overrides =
            (Util.option_bind (Xml.member "launchTemplateAndOverrides" xml)
               LaunchTemplateAndOverridesResponse.parse);
          lifecycle =
            (Util.option_bind (Xml.member "lifecycle" xml)
               InstanceLifecycle.parse);
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceIds" xml)
                  InstanceIdsSet.parse));
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.launch_template_and_overrides
                  (fun f ->
                     Ezxmlm.make_tag "launchTemplateAndOverrides"
                       ([], (LaunchTemplateAndOverridesResponse.to_xml f)))])
              @
              [Util.option_map v.lifecycle
                 (fun f ->
                    Ezxmlm.make_tag "lifecycle"
                      ([], (InstanceLifecycle.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "instanceIds"
                        ([], (InstanceIdsSet.to_xml [x])))) v.instance_ids))
            @
            [Util.option_map v.instance_type
               (fun f ->
                  Ezxmlm.make_tag "instanceType"
                    ([], (InstanceType.to_xml f)))])
           @
           [Util.option_map v.platform
              (fun f ->
                 Ezxmlm.make_tag "platform" ([], (PlatformValues.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the instances that were launched by the fleet.</p>"]
module FleetLaunchTemplateConfig =
  struct
    type t =
      {
      launch_template_specification:
        FleetLaunchTemplateSpecification.t option
        [@ocaml.doc "<p>The launch template.</p>"];
      overrides: FleetLaunchTemplateOverridesList.t
        [@ocaml.doc
          "<p>Any parameters that you specify override the same parameters in the launch template.</p>"]}
    [@@ocaml.doc "<p>Describes a launch template and overrides.</p>"]
    let make ?launch_template_specification  ?(overrides= [])  () =
      { launch_template_specification; overrides }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Overrides",
                   (FleetLaunchTemplateOverridesList.to_query v.overrides)));
           Util.option_map v.launch_template_specification
             (fun f ->
                Query.Pair
                  ("LaunchTemplateSpecification",
                    (FleetLaunchTemplateSpecification.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("overrides",
                (FleetLaunchTemplateOverridesList.to_json v.overrides));
           Util.option_map v.launch_template_specification
             (fun f ->
                ("launch_template_specification",
                  (FleetLaunchTemplateSpecification.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_specification =
            (Util.option_bind (Xml.member "launchTemplateSpecification" xml)
               FleetLaunchTemplateSpecification.parse);
          overrides =
            (Util.of_option []
               (Util.option_bind (Xml.member "overrides" xml)
                  FleetLaunchTemplateOverridesList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.launch_template_specification
               (fun f ->
                  Ezxmlm.make_tag "launchTemplateSpecification"
                    ([], (FleetLaunchTemplateSpecification.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "overrides"
                      ([], (FleetLaunchTemplateOverridesList.to_xml [x]))))
              v.overrides))
  end[@@ocaml.doc "<p>Describes a launch template and overrides.</p>"]
module CapacityReservationOptions =
  struct
    type t =
      {
      usage_strategy: FleetCapacityReservationUsageStrategy.t option
        [@ocaml.doc
          "<p>Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.</p> <p>If you specify <code>use-capacity-reservations-first</code>, the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy (<code>lowest-price</code> or <code>prioritized</code>) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy (<code>lowest-price</code> or <code>prioritized</code>).</p> <p>If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.</p>"]}
    [@@ocaml.doc
      "<p>Describes the strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.</p> <note> <p>This strategy can only be used if the EC2 Fleet is of type <code>instant</code>.</p> </note> <p>For more information about Capacity Reservations, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html\">On-Demand Capacity Reservations</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. For examples of using Capacity Reservations in an EC2 Fleet, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-examples.html\">EC2 Fleet Example Configurations</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"]
    let make ?usage_strategy  () = { usage_strategy }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.usage_strategy
              (fun f ->
                 Query.Pair
                   ("UsageStrategy",
                     (FleetCapacityReservationUsageStrategy.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.usage_strategy
              (fun f ->
                 ("usage_strategy",
                   (FleetCapacityReservationUsageStrategy.to_json f)))])
    let parse xml =
      Some
        {
          usage_strategy =
            (Util.option_bind (Xml.member "usageStrategy" xml)
               FleetCapacityReservationUsageStrategy.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.usage_strategy
              (fun f ->
                 Ezxmlm.make_tag "usageStrategy"
                   ([], (FleetCapacityReservationUsageStrategy.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.</p> <note> <p>This strategy can only be used if the EC2 Fleet is of type <code>instant</code>.</p> </note> <p>For more information about Capacity Reservations, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html\">On-Demand Capacity Reservations</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. For examples of using Capacity Reservations in an EC2 Fleet, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-examples.html\">EC2 Fleet Example Configurations</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"]
module FleetOnDemandAllocationStrategy =
  struct
    type t =
      | Lowest_price 
      | Prioritized 
    let str_to_t =
      [("prioritized", Prioritized); ("lowest-price", Lowest_price)]
    let t_to_str =
      [(Prioritized, "prioritized"); (Lowest_price, "lowest-price")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module SpotAllocationStrategy =
  struct
    type t =
      | Lowest_price 
      | Diversified 
      | Capacity_optimized 
    let str_to_t =
      [("capacity-optimized", Capacity_optimized);
      ("diversified", Diversified);
      ("lowest-price", Lowest_price)]
    let t_to_str =
      [(Capacity_optimized, "capacity-optimized");
      (Diversified, "diversified");
      (Lowest_price, "lowest-price")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module SpotInstanceInterruptionBehavior =
  struct
    type t =
      | Hibernate 
      | Stop 
      | Terminate 
    let str_to_t =
      [("terminate", Terminate); ("stop", Stop); ("hibernate", Hibernate)]
    let t_to_str =
      [(Terminate, "terminate"); (Stop, "stop"); (Hibernate, "hibernate")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module DefaultTargetCapacityType =
  struct
    type t =
      | Spot 
      | On_demand 
    let str_to_t = [("on-demand", On_demand); ("spot", Spot)]
    let t_to_str = [(On_demand, "on-demand"); (Spot, "spot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module AllocationStrategy =
  struct
    type t =
      | LowestPrice 
      | Diversified 
      | CapacityOptimized 
    let str_to_t =
      [("capacityOptimized", CapacityOptimized);
      ("diversified", Diversified);
      ("lowestPrice", LowestPrice)]
    let t_to_str =
      [(CapacityOptimized, "capacityOptimized");
      (Diversified, "diversified");
      (LowestPrice, "lowestPrice")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ExcessCapacityTerminationPolicy =
  struct
    type t =
      | NoTermination 
      | Default 
    let str_to_t = [("default", Default); ("noTermination", NoTermination)]
    let t_to_str = [(Default, "default"); (NoTermination, "noTermination")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module FleetType =
  struct
    type t =
      | Request 
      | Maintain 
      | Instant 
    let str_to_t =
      [("instant", Instant); ("maintain", Maintain); ("request", Request)]
    let t_to_str =
      [(Instant, "instant"); (Maintain, "maintain"); (Request, "request")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module LaunchSpecsList =
  struct
    type t = SpotFleetLaunchSpecification.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list SpotFleetLaunchSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list SpotFleetLaunchSpecification.to_headers v
    let to_json v = `List (List.map SpotFleetLaunchSpecification.to_json v)
    let parse xml =
      Util.option_all
        (List.map SpotFleetLaunchSpecification.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (SpotFleetLaunchSpecification.to_xml x))) v
  end
module LaunchTemplateConfigList =
  struct
    type t = LaunchTemplateConfig.t list
    let make elems () = elems
    let to_query v = Query.to_query_list LaunchTemplateConfig.to_query v
    let to_headers v =
      Headers.to_headers_list LaunchTemplateConfig.to_headers v
    let to_json v = `List (List.map LaunchTemplateConfig.to_json v)
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateConfig.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (LaunchTemplateConfig.to_xml x))) v
  end
module LoadBalancersConfig =
  struct
    type t =
      {
      classic_load_balancers_config: ClassicLoadBalancersConfig.t option
        [@ocaml.doc "<p>The Classic Load Balancers.</p>"];
      target_groups_config: TargetGroupsConfig.t option
        [@ocaml.doc "<p>The target groups.</p>"]}[@@ocaml.doc
                                                   "<p>Describes the Classic Load Balancers and target groups to attach to a Spot Fleet request.</p>"]
    let make ?classic_load_balancers_config  ?target_groups_config  () =
      { classic_load_balancers_config; target_groups_config }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.target_groups_config
              (fun f ->
                 Query.Pair
                   ("TargetGroupsConfig", (TargetGroupsConfig.to_query f)));
           Util.option_map v.classic_load_balancers_config
             (fun f ->
                Query.Pair
                  ("ClassicLoadBalancersConfig",
                    (ClassicLoadBalancersConfig.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_groups_config
              (fun f ->
                 ("target_groups_config", (TargetGroupsConfig.to_json f)));
           Util.option_map v.classic_load_balancers_config
             (fun f ->
                ("classic_load_balancers_config",
                  (ClassicLoadBalancersConfig.to_json f)))])
    let parse xml =
      Some
        {
          classic_load_balancers_config =
            (Util.option_bind (Xml.member "classicLoadBalancersConfig" xml)
               ClassicLoadBalancersConfig.parse);
          target_groups_config =
            (Util.option_bind (Xml.member "targetGroupsConfig" xml)
               TargetGroupsConfig.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.classic_load_balancers_config
               (fun f ->
                  Ezxmlm.make_tag "classicLoadBalancersConfig"
                    ([], (ClassicLoadBalancersConfig.to_xml f)))])
           @
           [Util.option_map v.target_groups_config
              (fun f ->
                 Ezxmlm.make_tag "targetGroupsConfig"
                   ([], (TargetGroupsConfig.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the Classic Load Balancers and target groups to attach to a Spot Fleet request.</p>"]
module OnDemandAllocationStrategy =
  struct
    type t =
      | LowestPrice 
      | Prioritized 
    let str_to_t =
      [("prioritized", Prioritized); ("lowestPrice", LowestPrice)]
    let t_to_str =
      [(Prioritized, "prioritized"); (LowestPrice, "lowestPrice")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module AvailabilityZoneMessage =
  struct
    type t =
      {
      message: String.t option
        [@ocaml.doc
          "<p>The message about the Availability Zone or Local Zone.</p>"]}
    [@@ocaml.doc
      "<p>Describes a message about an Availability Zone or Local Zone.</p>"]
    let make ?message  () = { message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a message about an Availability Zone or Local Zone.</p>"]
module VolumeStatusAction =
  struct
    type t =
      {
      code: String.t option
        [@ocaml.doc
          "<p>The code identifying the operation, for example, <code>enable-volume-io</code>.</p>"];
      description: String.t option
        [@ocaml.doc "<p>A description of the operation.</p>"];
      event_id: String.t option
        [@ocaml.doc
          "<p>The ID of the event associated with this operation.</p>"];
      event_type: String.t option
        [@ocaml.doc "<p>The event type associated with this operation.</p>"]}
    [@@ocaml.doc "<p>Describes a volume status operation code.</p>"]
    let make ?code  ?description  ?event_id  ?event_type  () =
      { code; description; event_id; event_type }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.event_type
              (fun f -> Query.Pair ("EventType", (String.to_query f)));
           Util.option_map v.event_id
             (fun f -> Query.Pair ("EventId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.event_type
              (fun f -> ("event_type", (String.to_json f)));
           Util.option_map v.event_id
             (fun f -> ("event_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          event_id =
            (Util.option_bind (Xml.member "eventId" xml) String.parse);
          event_type =
            (Util.option_bind (Xml.member "eventType" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.code
                 (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
            @
            [Util.option_map v.event_id
               (fun f -> Ezxmlm.make_tag "eventId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.event_type
              (fun f -> Ezxmlm.make_tag "eventType" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a volume status operation code.</p>"]
module VolumeStatusEvent =
  struct
    type t =
      {
      description: String.t option
        [@ocaml.doc "<p>A description of the event.</p>"];
      event_id: String.t option [@ocaml.doc "<p>The ID of this event.</p>"];
      event_type: String.t option
        [@ocaml.doc "<p>The type of this event.</p>"];
      not_after: DateTime.t option
        [@ocaml.doc "<p>The latest end time of the event.</p>"];
      not_before: DateTime.t option
        [@ocaml.doc "<p>The earliest start time of the event.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes a volume status event.</p>"]
    let make ?description  ?event_id  ?event_type  ?not_after  ?not_before 
      () = { description; event_id; event_type; not_after; not_before }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.not_before
              (fun f -> Query.Pair ("NotBefore", (DateTime.to_query f)));
           Util.option_map v.not_after
             (fun f -> Query.Pair ("NotAfter", (DateTime.to_query f)));
           Util.option_map v.event_type
             (fun f -> Query.Pair ("EventType", (String.to_query f)));
           Util.option_map v.event_id
             (fun f -> Query.Pair ("EventId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.not_before
              (fun f -> ("not_before", (DateTime.to_json f)));
           Util.option_map v.not_after
             (fun f -> ("not_after", (DateTime.to_json f)));
           Util.option_map v.event_type
             (fun f -> ("event_type", (String.to_json f)));
           Util.option_map v.event_id
             (fun f -> ("event_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          event_id =
            (Util.option_bind (Xml.member "eventId" xml) String.parse);
          event_type =
            (Util.option_bind (Xml.member "eventType" xml) String.parse);
          not_after =
            (Util.option_bind (Xml.member "notAfter" xml) DateTime.parse);
          not_before =
            (Util.option_bind (Xml.member "notBefore" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.description
                  (fun f ->
                     Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
              @
              [Util.option_map v.event_id
                 (fun f -> Ezxmlm.make_tag "eventId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.event_type
                (fun f -> Ezxmlm.make_tag "eventType" ([], (String.to_xml f)))])
            @
            [Util.option_map v.not_after
               (fun f -> Ezxmlm.make_tag "notAfter" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.not_before
              (fun f -> Ezxmlm.make_tag "notBefore" ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a volume status event.</p>"]
module VolumeStatusDetailsList =
  struct
    type t = VolumeStatusDetails.t list
    let make elems () = elems
    let to_query v = Query.to_query_list VolumeStatusDetails.to_query v
    let to_headers v =
      Headers.to_headers_list VolumeStatusDetails.to_headers v
    let to_json v = `List (List.map VolumeStatusDetails.to_json v)
    let parse xml =
      Util.option_all
        (List.map VolumeStatusDetails.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (VolumeStatusDetails.to_xml x))) v
  end
module VolumeStatusInfoStatus =
  struct
    type t =
      | Ok 
      | Impaired 
      | Insufficient_data 
    let str_to_t =
      [("insufficient-data", Insufficient_data);
      ("impaired", Impaired);
      ("ok", Ok)]
    let t_to_str =
      [(Insufficient_data, "insufficient-data");
      (Impaired, "impaired");
      (Ok, "ok")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ClientVpnAuthorizationRuleStatusCode =
  struct
    type t =
      | Authorizing 
      | Active 
      | Failed 
      | Revoking 
    let str_to_t =
      [("revoking", Revoking);
      ("failed", Failed);
      ("active", Active);
      ("authorizing", Authorizing)]
    let t_to_str =
      [(Revoking, "revoking");
      (Failed, "failed");
      (Active, "active");
      (Authorizing, "authorizing")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module UnsuccessfulInstanceCreditSpecificationErrorCode =
  struct
    type t =
      | InvalidInstanceID_Malformed 
      | InvalidInstanceID_NotFound 
      | IncorrectInstanceState 
      | InstanceCreditSpecification_NotSupported 
    let str_to_t =
      [("InstanceCreditSpecification.NotSupported",
         InstanceCreditSpecification_NotSupported);
      ("IncorrectInstanceState", IncorrectInstanceState);
      ("InvalidInstanceID.NotFound", InvalidInstanceID_NotFound);
      ("InvalidInstanceID.Malformed", InvalidInstanceID_Malformed)]
    let t_to_str =
      [(InstanceCreditSpecification_NotSupported,
         "InstanceCreditSpecification.NotSupported");
      (IncorrectInstanceState, "IncorrectInstanceState");
      (InvalidInstanceID_NotFound, "InvalidInstanceID.NotFound");
      (InvalidInstanceID_Malformed, "InvalidInstanceID.Malformed")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module PricingDetail =
  struct
    type t =
      {
      count: Integer.t option
        [@ocaml.doc
          "<p>The number of reservations available for the price.</p>"];
      price: Double.t option [@ocaml.doc "<p>The price per instance.</p>"]}
    [@@ocaml.doc "<p>Describes a Reserved Instance offering.</p>"]
    let make ?count  ?price  () = { count; price }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.price
              (fun f -> Query.Pair ("Price", (Double.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.price (fun f -> ("price", (Double.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          price = (Util.option_bind (Xml.member "price" xml) Double.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.count
               (fun f -> Ezxmlm.make_tag "count" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.price
              (fun f -> Ezxmlm.make_tag "price" ([], (Double.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a Reserved Instance offering.</p>"]
module Instance =
  struct
    type t =
      {
      ami_launch_index: Integer.t
        [@ocaml.doc
          "<p>The AMI launch index, which can be used to find this instance in the launch group.</p>"];
      image_id: String.t
        [@ocaml.doc "<p>The ID of the AMI used to launch the instance.</p>"];
      instance_id: String.t [@ocaml.doc "<p>The ID of the instance.</p>"];
      instance_type: InstanceType.t [@ocaml.doc "<p>The instance type.</p>"];
      kernel_id: String.t option
        [@ocaml.doc
          "<p>The kernel associated with this instance, if applicable.</p>"];
      key_name: String.t option
        [@ocaml.doc
          "<p>The name of the key pair, if this instance was launched with an associated key pair.</p>"];
      launch_time: DateTime.t
        [@ocaml.doc "<p>The time the instance was launched.</p>"];
      monitoring: Monitoring.t
        [@ocaml.doc "<p>The monitoring for the instance.</p>"];
      placement: Placement.t
        [@ocaml.doc
          "<p>The location where the instance launched, if applicable.</p>"];
      platform: PlatformValues.t option
        [@ocaml.doc
          "<p>The value is <code>Windows</code> for Windows instances; otherwise blank.</p>"];
      private_dns_name: String.t option
        [@ocaml.doc
          "<p>(IPv4 only) The private DNS hostname name assigned to the instance. This DNS hostname can only be used inside the Amazon EC2 network. This name is not available until the instance enters the <code>running</code> state. </p> <p>[EC2-VPC] The Amazon-provided DNS server resolves Amazon-provided private DNS hostnames if you've enabled DNS resolution and DNS hostnames in your VPC. If you are not using the Amazon-provided DNS server in your VPC, your custom domain name servers must resolve the hostname as appropriate.</p>"];
      private_ip_address: String.t option
        [@ocaml.doc
          "<p>The private IPv4 address assigned to the instance.</p>"];
      product_codes: ProductCodeList.t
        [@ocaml.doc
          "<p>The product codes attached to this instance, if applicable.</p>"];
      public_dns_name: String.t option
        [@ocaml.doc
          "<p>(IPv4 only) The public DNS name assigned to the instance. This name is not available until the instance enters the <code>running</code> state. For EC2-VPC, this name is only available if you've enabled DNS hostnames for your VPC.</p>"];
      public_ip_address: String.t option
        [@ocaml.doc
          "<p>The public IPv4 address assigned to the instance, if applicable.</p>"];
      ramdisk_id: String.t option
        [@ocaml.doc
          "<p>The RAM disk associated with this instance, if applicable.</p>"];
      state: InstanceState.t
        [@ocaml.doc "<p>The current state of the instance.</p>"];
      state_transition_reason: String.t option
        [@ocaml.doc
          "<p>The reason for the most recent state transition. This might be an empty string.</p>"];
      subnet_id: String.t option
        [@ocaml.doc
          "<p>[EC2-VPC] The ID of the subnet in which the instance is running.</p>"];
      vpc_id: String.t option
        [@ocaml.doc
          "<p>[EC2-VPC] The ID of the VPC in which the instance is running.</p>"];
      architecture: ArchitectureValues.t
        [@ocaml.doc "<p>The architecture of the image.</p>"];
      block_device_mappings: InstanceBlockDeviceMappingList.t
        [@ocaml.doc
          "<p>Any block device mapping entries for the instance.</p>"];
      client_token: String.t option
        [@ocaml.doc
          "<p>The idempotency token you provided when you launched the instance, if applicable.</p>"];
      ebs_optimized: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p>"];
      ena_support: Boolean.t option
        [@ocaml.doc
          "<p>Specifies whether enhanced networking with ENA is enabled.</p>"];
      hypervisor: HypervisorType.t
        [@ocaml.doc "<p>The hypervisor type of the instance.</p>"];
      iam_instance_profile: IamInstanceProfile.t option
        [@ocaml.doc
          "<p>The IAM instance profile associated with the instance, if applicable.</p>"];
      instance_lifecycle: InstanceLifecycleType.t option
        [@ocaml.doc
          "<p>Indicates whether this is a Spot Instance or a Scheduled Instance.</p>"];
      elastic_gpu_associations: ElasticGpuAssociationList.t
        [@ocaml.doc "<p>The Elastic GPU associated with the instance.</p>"];
      elastic_inference_accelerator_associations:
        ElasticInferenceAcceleratorAssociationList.t
        [@ocaml.doc
          "<p> The elastic inference accelerator associated with the instance.</p>"];
      network_interfaces: InstanceNetworkInterfaceList.t
        [@ocaml.doc
          "<p>[EC2-VPC] The network interfaces for the instance.</p>"];
      outpost_arn: String.t option
        [@ocaml.doc "<p>The Amazon Resource Name (ARN) of the Outpost.</p>"];
      root_device_name: String.t option
        [@ocaml.doc
          "<p>The device name of the root device volume (for example, <code>/dev/sda1</code>).</p>"];
      root_device_type: DeviceType.t
        [@ocaml.doc
          "<p>The root device type used by the AMI. The AMI can use an EBS volume or an instance store volume.</p>"];
      security_groups: GroupIdentifierList.t
        [@ocaml.doc "<p>The security groups for the instance.</p>"];
      source_dest_check: Boolean.t option
        [@ocaml.doc
          "<p>Specifies whether to enable an instance launched in a VPC to perform NAT. This controls whether source/destination checking is enabled on the instance. A value of <code>true</code> means that checking is enabled, and <code>false</code> means that checking is disabled. The value must be <code>false</code> for the instance to perform NAT. For more information, see <a href=\"https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_NAT_Instance.html\">NAT Instances</a> in the <i>Amazon Virtual Private Cloud User Guide</i>.</p>"];
      spot_instance_request_id: String.t option
        [@ocaml.doc
          "<p>If the request is a Spot Instance request, the ID of the request.</p>"];
      sriov_net_support: String.t option
        [@ocaml.doc
          "<p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>"];
      state_reason: StateReason.t option
        [@ocaml.doc
          "<p>The reason for the most recent state transition.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the instance.</p>"];
      virtualization_type: VirtualizationType.t
        [@ocaml.doc "<p>The virtualization type of the instance.</p>"];
      cpu_options: CpuOptions.t option
        [@ocaml.doc "<p>The CPU options for the instance.</p>"];
      capacity_reservation_id: String.t option
        [@ocaml.doc "<p>The ID of the Capacity Reservation.</p>"];
      capacity_reservation_specification:
        CapacityReservationSpecificationResponse.t option
        [@ocaml.doc
          "<p>Information about the Capacity Reservation targeting option.</p>"];
      hibernation_options: HibernationOptions.t option
        [@ocaml.doc
          "<p>Indicates whether the instance is enabled for hibernation.</p>"];
      licenses: LicenseList.t
        [@ocaml.doc "<p>The license configurations.</p>"];
      metadata_options: InstanceMetadataOptionsResponse.t option
        [@ocaml.doc "<p>The metadata options for the instance.</p>"]}
    [@@ocaml.doc "<p>Describes an instance.</p>"]
    let make ~ami_launch_index  ~image_id  ~instance_id  ~instance_type 
      ?kernel_id  ?key_name  ~launch_time  ~monitoring  ~placement  ?platform
       ?private_dns_name  ?private_ip_address  ?(product_codes= []) 
      ?public_dns_name  ?public_ip_address  ?ramdisk_id  ~state 
      ?state_transition_reason  ?subnet_id  ?vpc_id  ~architecture 
      ?(block_device_mappings= [])  ?client_token  ?ebs_optimized 
      ?ena_support  ~hypervisor  ?iam_instance_profile  ?instance_lifecycle 
      ?(elastic_gpu_associations= []) 
      ?(elastic_inference_accelerator_associations= []) 
      ?(network_interfaces= [])  ?outpost_arn  ?root_device_name 
      ~root_device_type  ?(security_groups= [])  ?source_dest_check 
      ?spot_instance_request_id  ?sriov_net_support  ?state_reason  ?(tags=
      [])  ~virtualization_type  ?cpu_options  ?capacity_reservation_id 
      ?capacity_reservation_specification  ?hibernation_options  ?(licenses=
      [])  ?metadata_options  () =
      {
        ami_launch_index;
        image_id;
        instance_id;
        instance_type;
        kernel_id;
        key_name;
        launch_time;
        monitoring;
        placement;
        platform;
        private_dns_name;
        private_ip_address;
        product_codes;
        public_dns_name;
        public_ip_address;
        ramdisk_id;
        state;
        state_transition_reason;
        subnet_id;
        vpc_id;
        architecture;
        block_device_mappings;
        client_token;
        ebs_optimized;
        ena_support;
        hypervisor;
        iam_instance_profile;
        instance_lifecycle;
        elastic_gpu_associations;
        elastic_inference_accelerator_associations;
        network_interfaces;
        outpost_arn;
        root_device_name;
        root_device_type;
        security_groups;
        source_dest_check;
        spot_instance_request_id;
        sriov_net_support;
        state_reason;
        tags;
        virtualization_type;
        cpu_options;
        capacity_reservation_id;
        capacity_reservation_specification;
        hibernation_options;
        licenses;
        metadata_options
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.metadata_options
              (fun f ->
                 Query.Pair
                   ("MetadataOptions",
                     (InstanceMetadataOptionsResponse.to_query f)));
           Some
             (Query.Pair ("LicenseSet", (LicenseList.to_query v.licenses)));
           Util.option_map v.hibernation_options
             (fun f ->
                Query.Pair
                  ("HibernationOptions", (HibernationOptions.to_query f)));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                Query.Pair
                  ("CapacityReservationSpecification",
                    (CapacityReservationSpecificationResponse.to_query f)));
           Util.option_map v.capacity_reservation_id
             (fun f ->
                Query.Pair ("CapacityReservationId", (String.to_query f)));
           Util.option_map v.cpu_options
             (fun f -> Query.Pair ("CpuOptions", (CpuOptions.to_query f)));
           Some
             (Query.Pair
                ("VirtualizationType",
                  (VirtualizationType.to_query v.virtualization_type)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.state_reason
             (fun f -> Query.Pair ("StateReason", (StateReason.to_query f)));
           Util.option_map v.sriov_net_support
             (fun f -> Query.Pair ("SriovNetSupport", (String.to_query f)));
           Util.option_map v.spot_instance_request_id
             (fun f ->
                Query.Pair ("SpotInstanceRequestId", (String.to_query f)));
           Util.option_map v.source_dest_check
             (fun f -> Query.Pair ("SourceDestCheck", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("GroupSet",
                  (GroupIdentifierList.to_query v.security_groups)));
           Some
             (Query.Pair
                ("RootDeviceType", (DeviceType.to_query v.root_device_type)));
           Util.option_map v.root_device_name
             (fun f -> Query.Pair ("RootDeviceName", (String.to_query f)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (InstanceNetworkInterfaceList.to_query v.network_interfaces)));
           Some
             (Query.Pair
                ("ElasticInferenceAcceleratorAssociationSet",
                  (ElasticInferenceAcceleratorAssociationList.to_query
                     v.elastic_inference_accelerator_associations)));
           Some
             (Query.Pair
                ("ElasticGpuAssociationSet",
                  (ElasticGpuAssociationList.to_query
                     v.elastic_gpu_associations)));
           Util.option_map v.instance_lifecycle
             (fun f ->
                Query.Pair
                  ("InstanceLifecycle", (InstanceLifecycleType.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile", (IamInstanceProfile.to_query f)));
           Some
             (Query.Pair
                ("Hypervisor", (HypervisorType.to_query v.hypervisor)));
           Util.option_map v.ena_support
             (fun f -> Query.Pair ("EnaSupport", (Boolean.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (InstanceBlockDeviceMappingList.to_query
                     v.block_device_mappings)));
           Some
             (Query.Pair
                ("Architecture",
                  (ArchitectureValues.to_query v.architecture)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.state_transition_reason
             (fun f -> Query.Pair ("Reason", (String.to_query f)));
           Some
             (Query.Pair ("InstanceState", (InstanceState.to_query v.state)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.public_ip_address
             (fun f -> Query.Pair ("IpAddress", (String.to_query f)));
           Util.option_map v.public_dns_name
             (fun f -> Query.Pair ("DnsName", (String.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Some (Query.Pair ("Placement", (Placement.to_query v.placement)));
           Some
             (Query.Pair ("Monitoring", (Monitoring.to_query v.monitoring)));
           Some
             (Query.Pair ("LaunchTime", (DateTime.to_query v.launch_time)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceType", (InstanceType.to_query v.instance_type)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Some
             (Query.Pair
                ("AmiLaunchIndex", (Integer.to_query v.ami_launch_index)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.metadata_options
              (fun f ->
                 ("metadata_options",
                   (InstanceMetadataOptionsResponse.to_json f)));
           Some ("licenses", (LicenseList.to_json v.licenses));
           Util.option_map v.hibernation_options
             (fun f ->
                ("hibernation_options", (HibernationOptions.to_json f)));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                ("capacity_reservation_specification",
                  (CapacityReservationSpecificationResponse.to_json f)));
           Util.option_map v.capacity_reservation_id
             (fun f -> ("capacity_reservation_id", (String.to_json f)));
           Util.option_map v.cpu_options
             (fun f -> ("cpu_options", (CpuOptions.to_json f)));
           Some
             ("virtualization_type",
               (VirtualizationType.to_json v.virtualization_type));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.state_reason
             (fun f -> ("state_reason", (StateReason.to_json f)));
           Util.option_map v.sriov_net_support
             (fun f -> ("sriov_net_support", (String.to_json f)));
           Util.option_map v.spot_instance_request_id
             (fun f -> ("spot_instance_request_id", (String.to_json f)));
           Util.option_map v.source_dest_check
             (fun f -> ("source_dest_check", (Boolean.to_json f)));
           Some
             ("security_groups",
               (GroupIdentifierList.to_json v.security_groups));
           Some ("root_device_type", (DeviceType.to_json v.root_device_type));
           Util.option_map v.root_device_name
             (fun f -> ("root_device_name", (String.to_json f)));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceList.to_json v.network_interfaces));
           Some
             ("elastic_inference_accelerator_associations",
               (ElasticInferenceAcceleratorAssociationList.to_json
                  v.elastic_inference_accelerator_associations));
           Some
             ("elastic_gpu_associations",
               (ElasticGpuAssociationList.to_json v.elastic_gpu_associations));
           Util.option_map v.instance_lifecycle
             (fun f ->
                ("instance_lifecycle", (InstanceLifecycleType.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile", (IamInstanceProfile.to_json f)));
           Some ("hypervisor", (HypervisorType.to_json v.hypervisor));
           Util.option_map v.ena_support
             (fun f -> ("ena_support", (Boolean.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some
             ("block_device_mappings",
               (InstanceBlockDeviceMappingList.to_json
                  v.block_device_mappings));
           Some ("architecture", (ArchitectureValues.to_json v.architecture));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.state_transition_reason
             (fun f -> ("state_transition_reason", (String.to_json f)));
           Some ("state", (InstanceState.to_json v.state));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.public_ip_address
             (fun f -> ("public_ip_address", (String.to_json f)));
           Util.option_map v.public_dns_name
             (fun f -> ("public_dns_name", (String.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (PlatformValues.to_json f)));
           Some ("placement", (Placement.to_json v.placement));
           Some ("monitoring", (Monitoring.to_json v.monitoring));
           Some ("launch_time", (DateTime.to_json v.launch_time));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Some ("instance_type", (InstanceType.to_json v.instance_type));
           Some ("instance_id", (String.to_json v.instance_id));
           Some ("image_id", (String.to_json v.image_id));
           Some ("ami_launch_index", (Integer.to_json v.ami_launch_index))])
    let parse xml =
      Some
        {
          ami_launch_index =
            (Xml.required "amiLaunchIndex"
               (Util.option_bind (Xml.member "amiLaunchIndex" xml)
                  Integer.parse));
          image_id =
            (Xml.required "imageId"
               (Util.option_bind (Xml.member "imageId" xml) String.parse));
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          instance_type =
            (Xml.required "instanceType"
               (Util.option_bind (Xml.member "instanceType" xml)
                  InstanceType.parse));
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          launch_time =
            (Xml.required "launchTime"
               (Util.option_bind (Xml.member "launchTime" xml) DateTime.parse));
          monitoring =
            (Xml.required "monitoring"
               (Util.option_bind (Xml.member "monitoring" xml)
                  Monitoring.parse));
          placement =
            (Xml.required "placement"
               (Util.option_bind (Xml.member "placement" xml) Placement.parse));
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          public_dns_name =
            (Util.option_bind (Xml.member "dnsName" xml) String.parse);
          public_ip_address =
            (Util.option_bind (Xml.member "ipAddress" xml) String.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          state =
            (Xml.required "instanceState"
               (Util.option_bind (Xml.member "instanceState" xml)
                  InstanceState.parse));
          state_transition_reason =
            (Util.option_bind (Xml.member "reason" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          architecture =
            (Xml.required "architecture"
               (Util.option_bind (Xml.member "architecture" xml)
                  ArchitectureValues.parse));
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  InstanceBlockDeviceMappingList.parse));
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          ena_support =
            (Util.option_bind (Xml.member "enaSupport" xml) Boolean.parse);
          hypervisor =
            (Xml.required "hypervisor"
               (Util.option_bind (Xml.member "hypervisor" xml)
                  HypervisorType.parse));
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfile.parse);
          instance_lifecycle =
            (Util.option_bind (Xml.member "instanceLifecycle" xml)
               InstanceLifecycleType.parse);
          elastic_gpu_associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "elasticGpuAssociationSet" xml)
                  ElasticGpuAssociationList.parse));
          elastic_inference_accelerator_associations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "elasticInferenceAcceleratorAssociationSet" xml)
                  ElasticInferenceAcceleratorAssociationList.parse));
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  InstanceNetworkInterfaceList.parse));
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          root_device_name =
            (Util.option_bind (Xml.member "rootDeviceName" xml) String.parse);
          root_device_type =
            (Xml.required "rootDeviceType"
               (Util.option_bind (Xml.member "rootDeviceType" xml)
                  DeviceType.parse));
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               Boolean.parse);
          spot_instance_request_id =
            (Util.option_bind (Xml.member "spotInstanceRequestId" xml)
               String.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml) String.parse);
          state_reason =
            (Util.option_bind (Xml.member "stateReason" xml)
               StateReason.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          virtualization_type =
            (Xml.required "virtualizationType"
               (Util.option_bind (Xml.member "virtualizationType" xml)
                  VirtualizationType.parse));
          cpu_options =
            (Util.option_bind (Xml.member "cpuOptions" xml) CpuOptions.parse);
          capacity_reservation_id =
            (Util.option_bind (Xml.member "capacityReservationId" xml)
               String.parse);
          capacity_reservation_specification =
            (Util.option_bind
               (Xml.member "capacityReservationSpecification" xml)
               CapacityReservationSpecificationResponse.parse);
          hibernation_options =
            (Util.option_bind (Xml.member "hibernationOptions" xml)
               HibernationOptions.parse);
          licenses =
            (Util.of_option []
               (Util.option_bind (Xml.member "licenseSet" xml)
                  LicenseList.parse));
          metadata_options =
            (Util.option_bind (Xml.member "metadataOptions" xml)
               InstanceMetadataOptionsResponse.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((((((((((((((((((((((((((((((((([] @
                                                         [Some
                                                            (Ezxmlm.make_tag
                                                               "amiLaunchIndex"
                                                               ([],
                                                                 (Integer.to_xml
                                                                    v.ami_launch_index)))])
                                                        @
                                                        [Some
                                                           (Ezxmlm.make_tag
                                                              "imageId"
                                                              ([],
                                                                (String.to_xml
                                                                   v.image_id)))])
                                                       @
                                                       [Some
                                                          (Ezxmlm.make_tag
                                                             "instanceId"
                                                             ([],
                                                               (String.to_xml
                                                                  v.instance_id)))])
                                                      @
                                                      [Some
                                                         (Ezxmlm.make_tag
                                                            "instanceType"
                                                            ([],
                                                              (InstanceType.to_xml
                                                                 v.instance_type)))])
                                                     @
                                                     [Util.option_map
                                                        v.kernel_id
                                                        (fun f ->
                                                           Ezxmlm.make_tag
                                                             "kernelId"
                                                             ([],
                                                               (String.to_xml
                                                                  f)))])
                                                    @
                                                    [Util.option_map
                                                       v.key_name
                                                       (fun f ->
                                                          Ezxmlm.make_tag
                                                            "keyName"
                                                            ([],
                                                              (String.to_xml
                                                                 f)))])
                                                   @
                                                   [Some
                                                      (Ezxmlm.make_tag
                                                         "launchTime"
                                                         ([],
                                                           (DateTime.to_xml
                                                              v.launch_time)))])
                                                  @
                                                  [Some
                                                     (Ezxmlm.make_tag
                                                        "monitoring"
                                                        ([],
                                                          (Monitoring.to_xml
                                                             v.monitoring)))])
                                                 @
                                                 [Some
                                                    (Ezxmlm.make_tag
                                                       "placement"
                                                       ([],
                                                         (Placement.to_xml
                                                            v.placement)))])
                                                @
                                                [Util.option_map v.platform
                                                   (fun f ->
                                                      Ezxmlm.make_tag
                                                        "platform"
                                                        ([],
                                                          (PlatformValues.to_xml
                                                             f)))])
                                               @
                                               [Util.option_map
                                                  v.private_dns_name
                                                  (fun f ->
                                                     Ezxmlm.make_tag
                                                       "privateDnsName"
                                                       ([],
                                                         (String.to_xml f)))])
                                              @
                                              [Util.option_map
                                                 v.private_ip_address
                                                 (fun f ->
                                                    Ezxmlm.make_tag
                                                      "privateIpAddress"
                                                      ([], (String.to_xml f)))])
                                             @
                                             (List.map
                                                (fun x ->
                                                   Some
                                                     (Ezxmlm.make_tag
                                                        "productCodes"
                                                        ([],
                                                          (ProductCodeList.to_xml
                                                             [x]))))
                                                v.product_codes))
                                            @
                                            [Util.option_map
                                               v.public_dns_name
                                               (fun f ->
                                                  Ezxmlm.make_tag "dnsName"
                                                    ([], (String.to_xml f)))])
                                           @
                                           [Util.option_map
                                              v.public_ip_address
                                              (fun f ->
                                                 Ezxmlm.make_tag "ipAddress"
                                                   ([], (String.to_xml f)))])
                                          @
                                          [Util.option_map v.ramdisk_id
                                             (fun f ->
                                                Ezxmlm.make_tag "ramdiskId"
                                                  ([], (String.to_xml f)))])
                                         @
                                         [Some
                                            (Ezxmlm.make_tag "instanceState"
                                               ([],
                                                 (InstanceState.to_xml
                                                    v.state)))])
                                        @
                                        [Util.option_map
                                           v.state_transition_reason
                                           (fun f ->
                                              Ezxmlm.make_tag "reason"
                                                ([], (String.to_xml f)))])
                                       @
                                       [Util.option_map v.subnet_id
                                          (fun f ->
                                             Ezxmlm.make_tag "subnetId"
                                               ([], (String.to_xml f)))])
                                      @
                                      [Util.option_map v.vpc_id
                                         (fun f ->
                                            Ezxmlm.make_tag "vpcId"
                                              ([], (String.to_xml f)))])
                                     @
                                     [Some
                                        (Ezxmlm.make_tag "architecture"
                                           ([],
                                             (ArchitectureValues.to_xml
                                                v.architecture)))])
                                    @
                                    (List.map
                                       (fun x ->
                                          Some
                                            (Ezxmlm.make_tag
                                               "blockDeviceMapping"
                                               ([],
                                                 (InstanceBlockDeviceMappingList.to_xml
                                                    [x]))))
                                       v.block_device_mappings))
                                   @
                                   [Util.option_map v.client_token
                                      (fun f ->
                                         Ezxmlm.make_tag "clientToken"
                                           ([], (String.to_xml f)))])
                                  @
                                  [Util.option_map v.ebs_optimized
                                     (fun f ->
                                        Ezxmlm.make_tag "ebsOptimized"
                                          ([], (Boolean.to_xml f)))])
                                 @
                                 [Util.option_map v.ena_support
                                    (fun f ->
                                       Ezxmlm.make_tag "enaSupport"
                                         ([], (Boolean.to_xml f)))])
                                @
                                [Some
                                   (Ezxmlm.make_tag "hypervisor"
                                      ([],
                                        (HypervisorType.to_xml v.hypervisor)))])
                               @
                               [Util.option_map v.iam_instance_profile
                                  (fun f ->
                                     Ezxmlm.make_tag "iamInstanceProfile"
                                       ([], (IamInstanceProfile.to_xml f)))])
                              @
                              [Util.option_map v.instance_lifecycle
                                 (fun f ->
                                    Ezxmlm.make_tag "instanceLifecycle"
                                      ([], (InstanceLifecycleType.to_xml f)))])
                             @
                             (List.map
                                (fun x ->
                                   Some
                                     (Ezxmlm.make_tag
                                        "elasticGpuAssociationSet"
                                        ([],
                                          (ElasticGpuAssociationList.to_xml
                                             [x]))))
                                v.elastic_gpu_associations))
                            @
                            (List.map
                               (fun x ->
                                  Some
                                    (Ezxmlm.make_tag
                                       "elasticInferenceAcceleratorAssociationSet"
                                       ([],
                                         (ElasticInferenceAcceleratorAssociationList.to_xml
                                            [x]))))
                               v.elastic_inference_accelerator_associations))
                           @
                           (List.map
                              (fun x ->
                                 Some
                                   (Ezxmlm.make_tag "networkInterfaceSet"
                                      ([],
                                        (InstanceNetworkInterfaceList.to_xml
                                           [x])))) v.network_interfaces))
                          @
                          [Util.option_map v.outpost_arn
                             (fun f ->
                                Ezxmlm.make_tag "outpostArn"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.root_device_name
                            (fun f ->
                               Ezxmlm.make_tag "rootDeviceName"
                                 ([], (String.to_xml f)))])
                        @
                        [Some
                           (Ezxmlm.make_tag "rootDeviceType"
                              ([], (DeviceType.to_xml v.root_device_type)))])
                       @
                       (List.map
                          (fun x ->
                             Some
                               (Ezxmlm.make_tag "groupSet"
                                  ([], (GroupIdentifierList.to_xml [x]))))
                          v.security_groups))
                      @
                      [Util.option_map v.source_dest_check
                         (fun f ->
                            Ezxmlm.make_tag "sourceDestCheck"
                              ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.spot_instance_request_id
                        (fun f ->
                           Ezxmlm.make_tag "spotInstanceRequestId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.sriov_net_support
                       (fun f ->
                          Ezxmlm.make_tag "sriovNetSupport"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.state_reason
                      (fun f ->
                         Ezxmlm.make_tag "stateReason"
                           ([], (StateReason.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "tagSet"
                             ([], (TagList.to_xml [x])))) v.tags))
                 @
                 [Some
                    (Ezxmlm.make_tag "virtualizationType"
                       ([],
                         (VirtualizationType.to_xml v.virtualization_type)))])
                @
                [Util.option_map v.cpu_options
                   (fun f ->
                      Ezxmlm.make_tag "cpuOptions"
                        ([], (CpuOptions.to_xml f)))])
               @
               [Util.option_map v.capacity_reservation_id
                  (fun f ->
                     Ezxmlm.make_tag "capacityReservationId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.capacity_reservation_specification
                 (fun f ->
                    Ezxmlm.make_tag "capacityReservationSpecification"
                      ([],
                        (CapacityReservationSpecificationResponse.to_xml f)))])
             @
             [Util.option_map v.hibernation_options
                (fun f ->
                   Ezxmlm.make_tag "hibernationOptions"
                     ([], (HibernationOptions.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "licenseSet"
                       ([], (LicenseList.to_xml [x])))) v.licenses))
           @
           [Util.option_map v.metadata_options
              (fun f ->
                 Ezxmlm.make_tag "metadataOptions"
                   ([], (InstanceMetadataOptionsResponse.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an instance.</p>"]
module PublicIpv4PoolRange =
  struct
    type t =
      {
      first_address: String.t option
        [@ocaml.doc "<p>The first IP address in the range.</p>"];
      last_address: String.t option
        [@ocaml.doc "<p>The last IP address in the range.</p>"];
      address_count: Integer.t option
        [@ocaml.doc "<p>The number of addresses in the range.</p>"];
      available_address_count: Integer.t option
        [@ocaml.doc "<p>The number of available addresses in the range.</p>"]}
    [@@ocaml.doc
      "<p>Describes an address range of an IPv4 address pool.</p>"]
    let make ?first_address  ?last_address  ?address_count 
      ?available_address_count  () =
      { first_address; last_address; address_count; available_address_count }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.available_address_count
              (fun f ->
                 Query.Pair ("AvailableAddressCount", (Integer.to_query f)));
           Util.option_map v.address_count
             (fun f -> Query.Pair ("AddressCount", (Integer.to_query f)));
           Util.option_map v.last_address
             (fun f -> Query.Pair ("LastAddress", (String.to_query f)));
           Util.option_map v.first_address
             (fun f -> Query.Pair ("FirstAddress", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.available_address_count
              (fun f -> ("available_address_count", (Integer.to_json f)));
           Util.option_map v.address_count
             (fun f -> ("address_count", (Integer.to_json f)));
           Util.option_map v.last_address
             (fun f -> ("last_address", (String.to_json f)));
           Util.option_map v.first_address
             (fun f -> ("first_address", (String.to_json f)))])
    let parse xml =
      Some
        {
          first_address =
            (Util.option_bind (Xml.member "firstAddress" xml) String.parse);
          last_address =
            (Util.option_bind (Xml.member "lastAddress" xml) String.parse);
          address_count =
            (Util.option_bind (Xml.member "addressCount" xml) Integer.parse);
          available_address_count =
            (Util.option_bind (Xml.member "availableAddressCount" xml)
               Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.first_address
                 (fun f ->
                    Ezxmlm.make_tag "firstAddress" ([], (String.to_xml f)))])
             @
             [Util.option_map v.last_address
                (fun f ->
                   Ezxmlm.make_tag "lastAddress" ([], (String.to_xml f)))])
            @
            [Util.option_map v.address_count
               (fun f ->
                  Ezxmlm.make_tag "addressCount" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.available_address_count
              (fun f ->
                 Ezxmlm.make_tag "availableAddressCount"
                   ([], (Integer.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an address range of an IPv4 address pool.</p>"]
module VpcCidrBlockAssociation =
  struct
    type t =
      {
      association_id: String.t option
        [@ocaml.doc "<p>The association ID for the IPv4 CIDR block.</p>"];
      cidr_block: String.t option [@ocaml.doc "<p>The IPv4 CIDR block.</p>"];
      cidr_block_state: VpcCidrBlockState.t option
        [@ocaml.doc "<p>Information about the state of the CIDR block.</p>"]}
    [@@ocaml.doc
      "<p>Describes an IPv4 CIDR block associated with a VPC.</p>"]
    let make ?association_id  ?cidr_block  ?cidr_block_state  () =
      { association_id; cidr_block; cidr_block_state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cidr_block_state
              (fun f ->
                 Query.Pair
                   ("CidrBlockState", (VpcCidrBlockState.to_query f)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cidr_block_state
              (fun f -> ("cidr_block_state", (VpcCidrBlockState.to_json f)));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse);
          cidr_block_state =
            (Util.option_bind (Xml.member "cidrBlockState" xml)
               VpcCidrBlockState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.association_id
                (fun f ->
                   Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.cidr_block
               (fun f -> Ezxmlm.make_tag "cidrBlock" ([], (String.to_xml f)))])
           @
           [Util.option_map v.cidr_block_state
              (fun f ->
                 Ezxmlm.make_tag "cidrBlockState"
                   ([], (VpcCidrBlockState.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an IPv4 CIDR block associated with a VPC.</p>"]
module VpcIpv6CidrBlockAssociation =
  struct
    type t =
      {
      association_id: String.t option
        [@ocaml.doc "<p>The association ID for the IPv6 CIDR block.</p>"];
      ipv6_cidr_block: String.t option
        [@ocaml.doc "<p>The IPv6 CIDR block.</p>"];
      ipv6_cidr_block_state: VpcCidrBlockState.t option
        [@ocaml.doc "<p>Information about the state of the CIDR block.</p>"];
      network_border_group: String.t option
        [@ocaml.doc
          "<p>The name of the location from which we advertise the IPV6 CIDR block.</p>"]}
    [@@ocaml.doc
      "<p>Describes an IPv6 CIDR block associated with a VPC.</p>"]
    let make ?association_id  ?ipv6_cidr_block  ?ipv6_cidr_block_state 
      ?network_border_group  () =
      {
        association_id;
        ipv6_cidr_block;
        ipv6_cidr_block_state;
        network_border_group
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_border_group
              (fun f ->
                 Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.ipv6_cidr_block_state
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockState", (VpcCidrBlockState.to_query f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_border_group
              (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.ipv6_cidr_block_state
             (fun f ->
                ("ipv6_cidr_block_state", (VpcCidrBlockState.to_json f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "ipv6CidrBlock" xml) String.parse);
          ipv6_cidr_block_state =
            (Util.option_bind (Xml.member "ipv6CidrBlockState" xml)
               VpcCidrBlockState.parse);
          network_border_group =
            (Util.option_bind (Xml.member "networkBorderGroup" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.association_id
                 (fun f ->
                    Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.ipv6_cidr_block
                (fun f ->
                   Ezxmlm.make_tag "ipv6CidrBlock" ([], (String.to_xml f)))])
            @
            [Util.option_map v.ipv6_cidr_block_state
               (fun f ->
                  Ezxmlm.make_tag "ipv6CidrBlockState"
                    ([], (VpcCidrBlockState.to_xml f)))])
           @
           [Util.option_map v.network_border_group
              (fun f ->
                 Ezxmlm.make_tag "networkBorderGroup" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an IPv6 CIDR block associated with a VPC.</p>"]
module SubnetIpv6CidrBlockAssociation =
  struct
    type t =
      {
      association_id: String.t option
        [@ocaml.doc "<p>The association ID for the CIDR block.</p>"];
      ipv6_cidr_block: String.t option
        [@ocaml.doc "<p>The IPv6 CIDR block.</p>"];
      ipv6_cidr_block_state: SubnetCidrBlockState.t option
        [@ocaml.doc "<p>Information about the state of the CIDR block.</p>"]}
    [@@ocaml.doc
      "<p>Describes an IPv6 CIDR block associated with a subnet.</p>"]
    let make ?association_id  ?ipv6_cidr_block  ?ipv6_cidr_block_state  () =
      { association_id; ipv6_cidr_block; ipv6_cidr_block_state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block_state
              (fun f ->
                 Query.Pair
                   ("Ipv6CidrBlockState", (SubnetCidrBlockState.to_query f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block_state
              (fun f ->
                 ("ipv6_cidr_block_state", (SubnetCidrBlockState.to_json f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "ipv6CidrBlock" xml) String.parse);
          ipv6_cidr_block_state =
            (Util.option_bind (Xml.member "ipv6CidrBlockState" xml)
               SubnetCidrBlockState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.association_id
                (fun f ->
                   Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.ipv6_cidr_block
               (fun f ->
                  Ezxmlm.make_tag "ipv6CidrBlock" ([], (String.to_xml f)))])
           @
           [Util.option_map v.ipv6_cidr_block_state
              (fun f ->
                 Ezxmlm.make_tag "ipv6CidrBlockState"
                   ([], (SubnetCidrBlockState.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an IPv6 CIDR block associated with a subnet.</p>"]
module ElasticGpuStatus =
  struct
    type t =
      | OK 
      | IMPAIRED 
    let str_to_t = [("IMPAIRED", IMPAIRED); ("OK", OK)]
    let t_to_str = [(IMPAIRED, "IMPAIRED"); (OK, "OK")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ImportImageLicenseConfigurationResponse =
  struct
    type t =
      {
      license_configuration_arn: String.t option
        [@ocaml.doc "<p>The ARN of a license configuration.</p>"]}[@@ocaml.doc
                                                                    "<p> The response information for license configurations.</p>"]
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "licenseConfigurationArn" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Ezxmlm.make_tag "licenseConfigurationArn"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p> The response information for license configurations.</p>"]
module SnapshotDetail =
  struct
    type t =
      {
      description: String.t option
        [@ocaml.doc "<p>A description for the snapshot.</p>"];
      device_name: String.t option
        [@ocaml.doc "<p>The block device mapping for the snapshot.</p>"];
      disk_image_size: Double.t option
        [@ocaml.doc "<p>The size of the disk in the snapshot, in GiB.</p>"];
      format: String.t option
        [@ocaml.doc
          "<p>The format of the disk image from which the snapshot is created.</p>"];
      progress: String.t option
        [@ocaml.doc "<p>The percentage of progress for the task.</p>"];
      snapshot_id: String.t option
        [@ocaml.doc "<p>The snapshot ID of the disk being imported.</p>"];
      status: String.t option
        [@ocaml.doc "<p>A brief status of the snapshot creation.</p>"];
      status_message: String.t option
        [@ocaml.doc
          "<p>A detailed status message for the snapshot creation.</p>"];
      url: String.t option
        [@ocaml.doc "<p>The URL used to access the disk image.</p>"];
      user_bucket: UserBucketDetails.t option
        [@ocaml.doc "<p>The S3 bucket for the disk image.</p>"]}[@@ocaml.doc
                                                                  "<p>Describes the snapshot created from the imported disk.</p>"]
    let make ?description  ?device_name  ?disk_image_size  ?format  ?progress
       ?snapshot_id  ?status  ?status_message  ?url  ?user_bucket  () =
      {
        description;
        device_name;
        disk_image_size;
        format;
        progress;
        snapshot_id;
        status;
        status_message;
        url;
        user_bucket
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f ->
                 Query.Pair ("UserBucket", (UserBucketDetails.to_query f)));
           Util.option_map v.url
             (fun f -> Query.Pair ("Url", (String.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (String.to_query f)));
           Util.option_map v.disk_image_size
             (fun f -> Query.Pair ("DiskImageSize", (Double.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> ("user_bucket", (UserBucketDetails.to_json f)));
           Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.format (fun f -> ("format", (String.to_json f)));
           Util.option_map v.disk_image_size
             (fun f -> ("disk_image_size", (Double.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          disk_image_size =
            (Util.option_bind (Xml.member "diskImageSize" xml) Double.parse);
          format = (Util.option_bind (Xml.member "format" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          url = (Util.option_bind (Xml.member "url" xml) String.parse);
          user_bucket =
            (Util.option_bind (Xml.member "userBucket" xml)
               UserBucketDetails.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.description
                       (fun f ->
                          Ezxmlm.make_tag "description"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.device_name
                      (fun f ->
                         Ezxmlm.make_tag "deviceName" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.disk_image_size
                     (fun f ->
                        Ezxmlm.make_tag "diskImageSize"
                          ([], (Double.to_xml f)))])
                 @
                 [Util.option_map v.format
                    (fun f ->
                       Ezxmlm.make_tag "format" ([], (String.to_xml f)))])
                @
                [Util.option_map v.progress
                   (fun f ->
                      Ezxmlm.make_tag "progress" ([], (String.to_xml f)))])
               @
               [Util.option_map v.snapshot_id
                  (fun f ->
                     Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.status
                 (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
             @
             [Util.option_map v.status_message
                (fun f ->
                   Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
            @
            [Util.option_map v.url
               (fun f -> Ezxmlm.make_tag "url" ([], (String.to_xml f)))])
           @
           [Util.option_map v.user_bucket
              (fun f ->
                 Ezxmlm.make_tag "userBucket"
                   ([], (UserBucketDetails.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the snapshot created from the imported disk.</p>"]
module ScheduledInstancesEbs =
  struct
    type t =
      {
      delete_on_termination: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the volume is deleted on instance termination.</p>"];
      encrypted: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the volume is encrypted. You can attached encrypted volumes only to instances that support them.</p>"];
      iops: Integer.t option
        [@ocaml.doc
          "<p>The number of I/O operations per second (IOPS) that the volume supports. For io1 volumes, this represents the number of IOPS that are provisioned for the volume. For <code>gp2</code> volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information about <code>gp2</code> baseline performance, I/O credits, and bursting, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html\">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Constraint: Range is 100-20000 IOPS for <code>io1</code> volumes and 100-10000 IOPS for <code>gp2</code> volumes.</p> <p>Condition: This parameter is required for requests to create <code>io1</code>volumes; it is not used in requests to create <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>"];
      snapshot_id: String.t option
        [@ocaml.doc "<p>The ID of the snapshot.</p>"];
      volume_size: Integer.t option
        [@ocaml.doc
          "<p>The size of the volume, in GiB.</p> <p>Default: If you're creating the volume from a snapshot and don't specify a volume size, the default is the snapshot size.</p>"];
      volume_type: String.t option
        [@ocaml.doc
          "<p>The volume type. <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, Throughput Optimized HDD for <code>st1</code>, Cold HDD for <code>sc1</code>, or <code>standard</code> for Magnetic.</p> <p>Default: <code>gp2</code> </p>"]}
    [@@ocaml.doc "<p>Describes an EBS volume for a Scheduled Instance.</p>"]
    let make ?delete_on_termination  ?encrypted  ?iops  ?snapshot_id 
      ?volume_size  ?volume_type  () =
      {
        delete_on_termination;
        encrypted;
        iops;
        snapshot_id;
        volume_size;
        volume_type
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> Query.Pair ("VolumeType", (String.to_query f)));
           Util.option_map v.volume_size
             (fun f -> Query.Pair ("VolumeSize", (Integer.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> ("volume_type", (String.to_json f)));
           Util.option_map v.volume_size
             (fun f -> ("volume_size", (Integer.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          delete_on_termination =
            (Util.option_bind (Xml.member "DeleteOnTermination" xml)
               Boolean.parse);
          encrypted =
            (Util.option_bind (Xml.member "Encrypted" xml) Boolean.parse);
          iops = (Util.option_bind (Xml.member "Iops" xml) Integer.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "SnapshotId" xml) String.parse);
          volume_size =
            (Util.option_bind (Xml.member "VolumeSize" xml) Integer.parse);
          volume_type =
            (Util.option_bind (Xml.member "VolumeType" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.delete_on_termination
                   (fun f ->
                      Ezxmlm.make_tag "DeleteOnTermination"
                        ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.encrypted
                  (fun f ->
                     Ezxmlm.make_tag "Encrypted" ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.iops
                 (fun f -> Ezxmlm.make_tag "Iops" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.snapshot_id
                (fun f ->
                   Ezxmlm.make_tag "SnapshotId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.volume_size
               (fun f ->
                  Ezxmlm.make_tag "VolumeSize" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.volume_type
              (fun f -> Ezxmlm.make_tag "VolumeType" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an EBS volume for a Scheduled Instance.</p>"]
module PrivateIpAddressConfigSet =
  struct
    type t = ScheduledInstancesPrivateIpAddressConfig.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list ScheduledInstancesPrivateIpAddressConfig.to_query v
    let to_headers v =
      Headers.to_headers_list
        ScheduledInstancesPrivateIpAddressConfig.to_headers v
    let to_json v =
      `List (List.map ScheduledInstancesPrivateIpAddressConfig.to_json v)
    let parse xml =
      Util.option_all
        (List.map ScheduledInstancesPrivateIpAddressConfig.parse
           (Xml.members "PrivateIpAddressConfigSet" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ScheduledInstancesPrivateIpAddressConfig.to_xml x))) v
  end
module ScheduledInstancesIpv6AddressList =
  struct
    type t = ScheduledInstancesIpv6Address.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list ScheduledInstancesIpv6Address.to_query v
    let to_headers v =
      Headers.to_headers_list ScheduledInstancesIpv6Address.to_headers v
    let to_json v = `List (List.map ScheduledInstancesIpv6Address.to_json v)
    let parse xml =
      Util.option_all
        (List.map ScheduledInstancesIpv6Address.parse
           (Xml.members "Ipv6Address" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ScheduledInstancesIpv6Address.to_xml x))) v
  end
module ScheduledInstancesSecurityGroupIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "SecurityGroupId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module NatGatewayAddress =
  struct
    type t =
      {
      allocation_id: String.t option
        [@ocaml.doc
          "<p>The allocation ID of the Elastic IP address that's associated with the NAT gateway.</p>"];
      network_interface_id: String.t option
        [@ocaml.doc
          "<p>The ID of the network interface associated with the NAT gateway.</p>"];
      private_ip: String.t option
        [@ocaml.doc
          "<p>The private IP address associated with the Elastic IP address.</p>"];
      public_ip: String.t option
        [@ocaml.doc
          "<p>The Elastic IP address associated with the NAT gateway.</p>"]}
    [@@ocaml.doc
      "<p>Describes the IP addresses and network interface associated with a NAT gateway.</p>"]
    let make ?allocation_id  ?network_interface_id  ?private_ip  ?public_ip 
      () = { allocation_id; network_interface_id; private_ip; public_ip }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.private_ip
             (fun f -> Query.Pair ("PrivateIp", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.private_ip
             (fun f -> ("private_ip", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          private_ip =
            (Util.option_bind (Xml.member "privateIp" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.allocation_id
                 (fun f ->
                    Ezxmlm.make_tag "allocationId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.network_interface_id
                (fun f ->
                   Ezxmlm.make_tag "networkInterfaceId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.private_ip
               (fun f -> Ezxmlm.make_tag "privateIp" ([], (String.to_xml f)))])
           @
           [Util.option_map v.public_ip
              (fun f -> Ezxmlm.make_tag "publicIp" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the IP addresses and network interface associated with a NAT gateway.</p>"]
module DhcpConfigurationList =
  struct
    type t = DhcpConfiguration.t list
    let make elems () = elems
    let to_query v = Query.to_query_list DhcpConfiguration.to_query v
    let to_headers v = Headers.to_headers_list DhcpConfiguration.to_headers v
    let to_json v = `List (List.map DhcpConfiguration.to_json v)
    let parse xml =
      Util.option_all
        (List.map DhcpConfiguration.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (DhcpConfiguration.to_xml x)))
        v
  end
module GatewayType =
  struct
    type t =
      | Ipsec_1 
    let str_to_t = [("ipsec.1", Ipsec_1)]
    let t_to_str = [(Ipsec_1, "ipsec.1")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module VpcAttachmentList =
  struct
    type t = VpcAttachment.t list
    let make elems () = elems
    let to_query v = Query.to_query_list VpcAttachment.to_query v
    let to_headers v = Headers.to_headers_list VpcAttachment.to_headers v
    let to_json v = `List (List.map VpcAttachment.to_json v)
    let parse xml =
      Util.option_all (List.map VpcAttachment.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VpcAttachment.to_xml x))) v
  end
module TransitGatewayPropagationState =
  struct
    type t =
      | Enabling 
      | Enabled 
      | Disabling 
      | Disabled 
    let str_to_t =
      [("disabled", Disabled);
      ("disabling", Disabling);
      ("enabled", Enabled);
      ("enabling", Enabling)]
    let t_to_str =
      [(Disabled, "disabled");
      (Disabling, "disabling");
      (Enabled, "enabled");
      (Enabling, "enabling")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module CapacityReservationInstancePlatform =
  struct
    type t =
      | Linux_UNIX 
      | Red_Hat_Enterprise_Linux 
      | SUSE_Linux 
      | Windows 
      | Windows_with_SQL_Server 
      | Windows_with_SQL_Server_Enterprise 
      | Windows_with_SQL_Server_Standard 
      | Windows_with_SQL_Server_Web 
      | Linux_with_SQL_Server_Standard 
      | Linux_with_SQL_Server_Web 
      | Linux_with_SQL_Server_Enterprise 
    let str_to_t =
      [("Linux with SQL Server Enterprise", Linux_with_SQL_Server_Enterprise);
      ("Linux with SQL Server Web", Linux_with_SQL_Server_Web);
      ("Linux with SQL Server Standard", Linux_with_SQL_Server_Standard);
      ("Windows with SQL Server Web", Windows_with_SQL_Server_Web);
      ("Windows with SQL Server Standard", Windows_with_SQL_Server_Standard);
      ("Windows with SQL Server Enterprise",
        Windows_with_SQL_Server_Enterprise);
      ("Windows with SQL Server", Windows_with_SQL_Server);
      ("Windows", Windows);
      ("SUSE Linux", SUSE_Linux);
      ("Red Hat Enterprise Linux", Red_Hat_Enterprise_Linux);
      ("Linux/UNIX", Linux_UNIX)]
    let t_to_str =
      [(Linux_with_SQL_Server_Enterprise, "Linux with SQL Server Enterprise");
      (Linux_with_SQL_Server_Web, "Linux with SQL Server Web");
      (Linux_with_SQL_Server_Standard, "Linux with SQL Server Standard");
      (Windows_with_SQL_Server_Web, "Windows with SQL Server Web");
      (Windows_with_SQL_Server_Standard, "Windows with SQL Server Standard");
      (Windows_with_SQL_Server_Enterprise,
        "Windows with SQL Server Enterprise");
      (Windows_with_SQL_Server, "Windows with SQL Server");
      (Windows, "Windows");
      (SUSE_Linux, "SUSE Linux");
      (Red_Hat_Enterprise_Linux, "Red Hat Enterprise Linux");
      (Linux_UNIX, "Linux/UNIX")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module CapacityReservationState =
  struct
    type t =
      | Active 
      | Expired 
      | Cancelled 
      | Pending 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("pending", Pending);
      ("cancelled", Cancelled);
      ("expired", Expired);
      ("active", Active)]
    let t_to_str =
      [(Failed, "failed");
      (Pending, "pending");
      (Cancelled, "cancelled");
      (Expired, "expired");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module CapacityReservationTenancy =
  struct
    type t =
      | Default 
      | Dedicated 
    let str_to_t = [("dedicated", Dedicated); ("default", Default)]
    let t_to_str = [(Dedicated, "dedicated"); (Default, "default")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module EndDateType =
  struct
    type t =
      | Unlimited 
      | Limited 
    let str_to_t = [("limited", Limited); ("unlimited", Unlimited)]
    let t_to_str = [(Limited, "limited"); (Unlimited, "unlimited")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module InstanceMatchCriteria =
  struct
    type t =
      | Open 
      | Targeted 
    let str_to_t = [("targeted", Targeted); ("open", Open)]
    let t_to_str = [(Targeted, "targeted"); (Open, "open")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ReservedInstancesModificationResultList =
  struct
    type t = ReservedInstancesModificationResult.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list ReservedInstancesModificationResult.to_query v
    let to_headers v =
      Headers.to_headers_list ReservedInstancesModificationResult.to_headers
        v
    let to_json v =
      `List (List.map ReservedInstancesModificationResult.to_json v)
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesModificationResult.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ReservedInstancesModificationResult.to_xml x))) v
  end
module ReservedIntancesIds =
  struct
    type t = ReservedInstancesId.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ReservedInstancesId.to_query v
    let to_headers v =
      Headers.to_headers_list ReservedInstancesId.to_headers v
    let to_json v = `List (List.map ReservedInstancesId.to_json v)
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesId.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ReservedInstancesId.to_xml x))) v
  end
module PlacementGroupState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module PlacementStrategy =
  struct
    type t =
      | Cluster 
      | Spread 
      | Partition 
    let str_to_t =
      [("partition", Partition); ("spread", Spread); ("cluster", Cluster)]
    let t_to_str =
      [(Partition, "partition"); (Spread, "spread"); (Cluster, "cluster")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module EventInformation =
  struct
    type t =
      {
      event_description: String.t option
        [@ocaml.doc "<p>The description of the event.</p>"];
      event_sub_type: String.t option
        [@ocaml.doc
          "<p>The event.</p> <p>The following are the <code>error</code> events:</p> <ul> <li> <p> <code>iamFleetRoleInvalid</code> - The EC2 Fleet or Spot Fleet did not have the required permissions either to launch or terminate an instance.</p> </li> <li> <p> <code>spotFleetRequestConfigurationInvalid</code> - The configuration is not valid. For more information, see the description of the event.</p> </li> <li> <p> <code>spotInstanceCountLimitExceeded</code> - You've reached the limit on the number of Spot Instances that you can launch.</p> </li> </ul> <p>The following are the <code>fleetRequestChange</code> events:</p> <ul> <li> <p> <code>active</code> - The EC2 Fleet or Spot Fleet request has been validated and Amazon EC2 is attempting to maintain the target number of running Spot Instances.</p> </li> <li> <p> <code>cancelled</code> - The EC2 Fleet or Spot Fleet request is canceled and has no running Spot Instances. The EC2 Fleet or Spot Fleet will be deleted two days after its instances were terminated.</p> </li> <li> <p> <code>cancelled_running</code> - The EC2 Fleet or Spot Fleet request is canceled and does not launch additional Spot Instances. Existing Spot Instances continue to run until they are interrupted or terminated.</p> </li> <li> <p> <code>cancelled_terminating</code> - The EC2 Fleet or Spot Fleet request is canceled and its Spot Instances are terminating.</p> </li> <li> <p> <code>expired</code> - The EC2 Fleet or Spot Fleet request has expired. A subsequent event indicates that the instances were terminated, if the request was created with <code>TerminateInstancesWithExpiration</code> set.</p> </li> <li> <p> <code>modify_in_progress</code> - A request to modify the EC2 Fleet or Spot Fleet request was accepted and is in progress.</p> </li> <li> <p> <code>modify_successful</code> - The EC2 Fleet or Spot Fleet request was modified.</p> </li> <li> <p> <code>price_update</code> - The price for a launch configuration was adjusted because it was too high. This change is permanent.</p> </li> <li> <p> <code>submitted</code> - The EC2 Fleet or Spot Fleet request is being evaluated and Amazon EC2 is preparing to launch the target number of Spot Instances.</p> </li> </ul> <p>The following are the <code>instanceChange</code> events:</p> <ul> <li> <p> <code>launched</code> - A request was fulfilled and a new instance was launched.</p> </li> <li> <p> <code>terminated</code> - An instance was terminated by the user.</p> </li> </ul> <p>The following are the <code>Information</code> events:</p> <ul> <li> <p> <code>launchSpecTemporarilyBlacklisted</code> - The configuration is not valid and several attempts to launch instances have failed. For more information, see the description of the event.</p> </li> <li> <p> <code>launchSpecUnusable</code> - The price in a launch specification is not valid because it is below the Spot price or the Spot price is above the On-Demand price.</p> </li> <li> <p> <code>fleetProgressHalted</code> - The price in every launch specification is not valid. A launch specification might become valid if the Spot price changes.</p> </li> </ul>"];
      instance_id: String.t option
        [@ocaml.doc
          "<p>The ID of the instance. This information is available only for <code>instanceChange</code> events.</p>"]}
    [@@ocaml.doc "<p>Describes an EC2 Fleet or Spot Fleet event.</p>"]
    let make ?event_description  ?event_sub_type  ?instance_id  () =
      { event_description; event_sub_type; instance_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.event_sub_type
             (fun f -> Query.Pair ("EventSubType", (String.to_query f)));
           Util.option_map v.event_description
             (fun f -> Query.Pair ("EventDescription", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.event_sub_type
             (fun f -> ("event_sub_type", (String.to_json f)));
           Util.option_map v.event_description
             (fun f -> ("event_description", (String.to_json f)))])
    let parse xml =
      Some
        {
          event_description =
            (Util.option_bind (Xml.member "eventDescription" xml)
               String.parse);
          event_sub_type =
            (Util.option_bind (Xml.member "eventSubType" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.event_description
                (fun f ->
                   Ezxmlm.make_tag "eventDescription" ([], (String.to_xml f)))])
            @
            [Util.option_map v.event_sub_type
               (fun f ->
                  Ezxmlm.make_tag "eventSubType" ([], (String.to_xml f)))])
           @
           [Util.option_map v.instance_id
              (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an EC2 Fleet or Spot Fleet event.</p>"]
module FleetEventType =
  struct
    type t =
      | Instance_change 
      | Fleet_change 
      | Service_error 
    let str_to_t =
      [("service-error", Service_error);
      ("fleet-change", Fleet_change);
      ("instance-change", Instance_change)]
    let t_to_str =
      [(Service_error, "service-error");
      (Fleet_change, "fleet-change");
      (Instance_change, "instance-change")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module PaymentOption =
  struct
    type t =
      | AllUpfront 
      | PartialUpfront 
      | NoUpfront 
    let str_to_t =
      [("NoUpfront", NoUpfront);
      ("PartialUpfront", PartialUpfront);
      ("AllUpfront", AllUpfront)]
    let t_to_str =
      [(NoUpfront, "NoUpfront");
      (PartialUpfront, "PartialUpfront");
      (AllUpfront, "AllUpfront")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ReservationState =
  struct
    type t =
      | Payment_pending 
      | Payment_failed 
      | Active 
      | Retired 
    let str_to_t =
      [("retired", Retired);
      ("active", Active);
      ("payment-failed", Payment_failed);
      ("payment-pending", Payment_pending)]
    let t_to_str =
      [(Retired, "retired");
      (Active, "active");
      (Payment_failed, "payment-failed");
      (Payment_pending, "payment-pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ResponseHostIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module LaunchPermission =
  struct
    type t =
      {
      group: PermissionGroup.t option
        [@ocaml.doc "<p>The name of the group.</p>"];
      user_id: String.t option [@ocaml.doc "<p>The AWS account ID.</p>"]}
    [@@ocaml.doc "<p>Describes a launch permission.</p>"]
    let make ?group  ?user_id  () = { group; user_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> Query.Pair ("UserId", (String.to_query f)));
           Util.option_map v.group
             (fun f -> Query.Pair ("Group", (PermissionGroup.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> ("user_id", (String.to_json f)));
           Util.option_map v.group
             (fun f -> ("group", (PermissionGroup.to_json f)))])
    let parse xml =
      Some
        {
          group =
            (Util.option_bind (Xml.member "group" xml) PermissionGroup.parse);
          user_id = (Util.option_bind (Xml.member "userId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.group
               (fun f ->
                  Ezxmlm.make_tag "group" ([], (PermissionGroup.to_xml f)))])
           @
           [Util.option_map v.user_id
              (fun f -> Ezxmlm.make_tag "userId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a launch permission.</p>"]
module DnsEntrySet =
  struct
    type t = DnsEntry.t list
    let make elems () = elems
    let to_query v = Query.to_query_list DnsEntry.to_query v
    let to_headers v = Headers.to_headers_list DnsEntry.to_headers v
    let to_json v = `List (List.map DnsEntry.to_json v)
    let parse xml =
      Util.option_all (List.map DnsEntry.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (DnsEntry.to_xml x)))
        v
  end
module State =
  struct
    type t =
      | PendingAcceptance 
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
      | Rejected 
      | Failed 
      | Expired 
    let str_to_t =
      [("Expired", Expired);
      ("Failed", Failed);
      ("Rejected", Rejected);
      ("Deleted", Deleted);
      ("Deleting", Deleting);
      ("Available", Available);
      ("Pending", Pending);
      ("PendingAcceptance", PendingAcceptance)]
    let t_to_str =
      [(Expired, "Expired");
      (Failed, "Failed");
      (Rejected, "Rejected");
      (Deleted, "Deleted");
      (Deleting, "Deleting");
      (Available, "Available");
      (Pending, "Pending");
      (PendingAcceptance, "PendingAcceptance")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ExportTaskS3Location =
  struct
    type t =
      {
      s3_bucket: String.t option
        [@ocaml.doc "<p>The destination S3 bucket.</p>"];
      s3_prefix: String.t option
        [@ocaml.doc "<p>The prefix (logical hierarchy) in the bucket.</p>"]}
    [@@ocaml.doc
      "<p>Describes the destination for an export image task.</p>"]
    let make ?s3_bucket  ?s3_prefix  () = { s3_bucket; s3_prefix }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> Query.Pair ("S3Prefix", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> ("s3_prefix", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)))])
    let parse xml =
      Some
        {
          s3_bucket =
            (Util.option_bind (Xml.member "s3Bucket" xml) String.parse);
          s3_prefix =
            (Util.option_bind (Xml.member "s3Prefix" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.s3_bucket
               (fun f -> Ezxmlm.make_tag "s3Bucket" ([], (String.to_xml f)))])
           @
           [Util.option_map v.s3_prefix
              (fun f -> Ezxmlm.make_tag "s3Prefix" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the destination for an export image task.</p>"]
module UnsuccessfulItemError =
  struct
    type t =
      {
      code: String.t option [@ocaml.doc "<p>The error code.</p>"];
      message: String.t option
        [@ocaml.doc "<p>The error message accompanying the error code.</p>"]}
    [@@ocaml.doc
      "<p>Information about the error that occurred. For more information about errors, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html\">Error Codes</a>.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Information about the error that occurred. For more information about errors, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html\">Error Codes</a>.</p>"]
module TrafficMirrorFilterRuleList =
  struct
    type t = TrafficMirrorFilterRule.t list
    let make elems () = elems
    let to_query v = Query.to_query_list TrafficMirrorFilterRule.to_query v
    let to_headers v =
      Headers.to_headers_list TrafficMirrorFilterRule.to_headers v
    let to_json v = `List (List.map TrafficMirrorFilterRule.to_json v)
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorFilterRule.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (TrafficMirrorFilterRule.to_xml x)))
        v
  end
module TrafficMirrorNetworkServiceList =
  struct
    type t = TrafficMirrorNetworkService.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list TrafficMirrorNetworkService.to_query v
    let to_headers v =
      Headers.to_headers_list TrafficMirrorNetworkService.to_headers v
    let to_json v = `List (List.map TrafficMirrorNetworkService.to_json v)
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorNetworkService.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TrafficMirrorNetworkService.to_xml x))) v
  end
module TransitGatewayOptions =
  struct
    type t =
      {
      amazon_side_asn: Long.t option
        [@ocaml.doc
          "<p>A private Autonomous System Number (ASN) for the Amazon side of a BGP session. The range is 64512 to 65534 for 16-bit ASNs and 4200000000 to 4294967294 for 32-bit ASNs.</p>"];
      auto_accept_shared_attachments:
        AutoAcceptSharedAttachmentsValue.t option
        [@ocaml.doc
          "<p>Indicates whether attachment requests are automatically accepted.</p>"];
      default_route_table_association:
        DefaultRouteTableAssociationValue.t option
        [@ocaml.doc
          "<p>Indicates whether resource attachments are automatically associated with the default association route table.</p>"];
      association_default_route_table_id: String.t option
        [@ocaml.doc "<p>The ID of the default association route table.</p>"];
      default_route_table_propagation:
        DefaultRouteTablePropagationValue.t option
        [@ocaml.doc
          "<p>Indicates whether resource attachments automatically propagate routes to the default propagation route table.</p>"];
      propagation_default_route_table_id: String.t option
        [@ocaml.doc "<p>The ID of the default propagation route table.</p>"];
      vpn_ecmp_support: VpnEcmpSupportValue.t option
        [@ocaml.doc
          "<p>Indicates whether Equal Cost Multipath Protocol support is enabled.</p>"];
      dns_support: DnsSupportValue.t option
        [@ocaml.doc "<p>Indicates whether DNS support is enabled.</p>"];
      multicast_support: MulticastSupportValue.t option
        [@ocaml.doc
          "<p>Indicates whether multicast is enabled on the transit gateway</p>"]}
    [@@ocaml.doc "<p>Describes the options for a transit gateway.</p>"]
    let make ?amazon_side_asn  ?auto_accept_shared_attachments 
      ?default_route_table_association  ?association_default_route_table_id 
      ?default_route_table_propagation  ?propagation_default_route_table_id 
      ?vpn_ecmp_support  ?dns_support  ?multicast_support  () =
      {
        amazon_side_asn;
        auto_accept_shared_attachments;
        default_route_table_association;
        association_default_route_table_id;
        default_route_table_propagation;
        propagation_default_route_table_id;
        vpn_ecmp_support;
        dns_support;
        multicast_support
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.multicast_support
              (fun f ->
                 Query.Pair
                   ("MulticastSupport", (MulticastSupportValue.to_query f)));
           Util.option_map v.dns_support
             (fun f ->
                Query.Pair ("DnsSupport", (DnsSupportValue.to_query f)));
           Util.option_map v.vpn_ecmp_support
             (fun f ->
                Query.Pair
                  ("VpnEcmpSupport", (VpnEcmpSupportValue.to_query f)));
           Util.option_map v.propagation_default_route_table_id
             (fun f ->
                Query.Pair
                  ("PropagationDefaultRouteTableId", (String.to_query f)));
           Util.option_map v.default_route_table_propagation
             (fun f ->
                Query.Pair
                  ("DefaultRouteTablePropagation",
                    (DefaultRouteTablePropagationValue.to_query f)));
           Util.option_map v.association_default_route_table_id
             (fun f ->
                Query.Pair
                  ("AssociationDefaultRouteTableId", (String.to_query f)));
           Util.option_map v.default_route_table_association
             (fun f ->
                Query.Pair
                  ("DefaultRouteTableAssociation",
                    (DefaultRouteTableAssociationValue.to_query f)));
           Util.option_map v.auto_accept_shared_attachments
             (fun f ->
                Query.Pair
                  ("AutoAcceptSharedAttachments",
                    (AutoAcceptSharedAttachmentsValue.to_query f)));
           Util.option_map v.amazon_side_asn
             (fun f -> Query.Pair ("AmazonSideAsn", (Long.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.multicast_support
              (fun f ->
                 ("multicast_support", (MulticastSupportValue.to_json f)));
           Util.option_map v.dns_support
             (fun f -> ("dns_support", (DnsSupportValue.to_json f)));
           Util.option_map v.vpn_ecmp_support
             (fun f -> ("vpn_ecmp_support", (VpnEcmpSupportValue.to_json f)));
           Util.option_map v.propagation_default_route_table_id
             (fun f ->
                ("propagation_default_route_table_id", (String.to_json f)));
           Util.option_map v.default_route_table_propagation
             (fun f ->
                ("default_route_table_propagation",
                  (DefaultRouteTablePropagationValue.to_json f)));
           Util.option_map v.association_default_route_table_id
             (fun f ->
                ("association_default_route_table_id", (String.to_json f)));
           Util.option_map v.default_route_table_association
             (fun f ->
                ("default_route_table_association",
                  (DefaultRouteTableAssociationValue.to_json f)));
           Util.option_map v.auto_accept_shared_attachments
             (fun f ->
                ("auto_accept_shared_attachments",
                  (AutoAcceptSharedAttachmentsValue.to_json f)));
           Util.option_map v.amazon_side_asn
             (fun f -> ("amazon_side_asn", (Long.to_json f)))])
    let parse xml =
      Some
        {
          amazon_side_asn =
            (Util.option_bind (Xml.member "amazonSideAsn" xml) Long.parse);
          auto_accept_shared_attachments =
            (Util.option_bind (Xml.member "autoAcceptSharedAttachments" xml)
               AutoAcceptSharedAttachmentsValue.parse);
          default_route_table_association =
            (Util.option_bind (Xml.member "defaultRouteTableAssociation" xml)
               DefaultRouteTableAssociationValue.parse);
          association_default_route_table_id =
            (Util.option_bind
               (Xml.member "associationDefaultRouteTableId" xml) String.parse);
          default_route_table_propagation =
            (Util.option_bind (Xml.member "defaultRouteTablePropagation" xml)
               DefaultRouteTablePropagationValue.parse);
          propagation_default_route_table_id =
            (Util.option_bind
               (Xml.member "propagationDefaultRouteTableId" xml) String.parse);
          vpn_ecmp_support =
            (Util.option_bind (Xml.member "vpnEcmpSupport" xml)
               VpnEcmpSupportValue.parse);
          dns_support =
            (Util.option_bind (Xml.member "dnsSupport" xml)
               DnsSupportValue.parse);
          multicast_support =
            (Util.option_bind (Xml.member "multicastSupport" xml)
               MulticastSupportValue.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.amazon_side_asn
                      (fun f ->
                         Ezxmlm.make_tag "amazonSideAsn"
                           ([], (Long.to_xml f)))])
                  @
                  [Util.option_map v.auto_accept_shared_attachments
                     (fun f ->
                        Ezxmlm.make_tag "autoAcceptSharedAttachments"
                          ([], (AutoAcceptSharedAttachmentsValue.to_xml f)))])
                 @
                 [Util.option_map v.default_route_table_association
                    (fun f ->
                       Ezxmlm.make_tag "defaultRouteTableAssociation"
                         ([], (DefaultRouteTableAssociationValue.to_xml f)))])
                @
                [Util.option_map v.association_default_route_table_id
                   (fun f ->
                      Ezxmlm.make_tag "associationDefaultRouteTableId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.default_route_table_propagation
                  (fun f ->
                     Ezxmlm.make_tag "defaultRouteTablePropagation"
                       ([], (DefaultRouteTablePropagationValue.to_xml f)))])
              @
              [Util.option_map v.propagation_default_route_table_id
                 (fun f ->
                    Ezxmlm.make_tag "propagationDefaultRouteTableId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.vpn_ecmp_support
                (fun f ->
                   Ezxmlm.make_tag "vpnEcmpSupport"
                     ([], (VpnEcmpSupportValue.to_xml f)))])
            @
            [Util.option_map v.dns_support
               (fun f ->
                  Ezxmlm.make_tag "dnsSupport"
                    ([], (DnsSupportValue.to_xml f)))])
           @
           [Util.option_map v.multicast_support
              (fun f ->
                 Ezxmlm.make_tag "multicastSupport"
                   ([], (MulticastSupportValue.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the options for a transit gateway.</p>"]
module TransitGatewayState =
  struct
    type t =
      | Pending 
      | Available 
      | Modifying 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("modifying", Modifying);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Modifying, "modifying");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module CertificateAuthenticationRequest =
  struct
    type t =
      {
      client_root_certificate_chain_arn: String.t option
        [@ocaml.doc
          "<p>The ARN of the client certificate. The certificate must be signed by a certificate authority (CA) and it must be provisioned in AWS Certificate Manager (ACM).</p>"]}
    [@@ocaml.doc
      "<p>Information about the client certificate to be used for authentication.</p>"]
    let make ?client_root_certificate_chain_arn  () =
      { client_root_certificate_chain_arn }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_root_certificate_chain_arn
              (fun f ->
                 Query.Pair
                   ("ClientRootCertificateChainArn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_root_certificate_chain_arn
              (fun f ->
                 ("client_root_certificate_chain_arn", (String.to_json f)))])
    let parse xml =
      Some
        {
          client_root_certificate_chain_arn =
            (Util.option_bind
               (Xml.member "ClientRootCertificateChainArn" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.client_root_certificate_chain_arn
              (fun f ->
                 Ezxmlm.make_tag "ClientRootCertificateChainArn"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Information about the client certificate to be used for authentication.</p>"]
module DirectoryServiceAuthenticationRequest =
  struct
    type t =
      {
      directory_id: String.t option
        [@ocaml.doc
          "<p>The ID of the Active Directory to be used for authentication.</p>"]}
    [@@ocaml.doc
      "<p>Describes the Active Directory to be used for client authentication.</p>"]
    let make ?directory_id  () = { directory_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.directory_id
              (fun f -> Query.Pair ("DirectoryId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.directory_id
              (fun f -> ("directory_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          directory_id =
            (Util.option_bind (Xml.member "DirectoryId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.directory_id
              (fun f -> Ezxmlm.make_tag "DirectoryId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the Active Directory to be used for client authentication.</p>"]
module InstanceCountList =
  struct
    type t = InstanceCount.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InstanceCount.to_query v
    let to_headers v = Headers.to_headers_list InstanceCount.to_headers v
    let to_json v = `List (List.map InstanceCount.to_json v)
    let parse xml =
      Util.option_all (List.map InstanceCount.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InstanceCount.to_xml x))) v
  end
module ListingStatus =
  struct
    type t =
      | Active 
      | Pending 
      | Cancelled 
      | Closed 
    let str_to_t =
      [("closed", Closed);
      ("cancelled", Cancelled);
      ("pending", Pending);
      ("active", Active)]
    let t_to_str =
      [(Closed, "closed");
      (Cancelled, "cancelled");
      (Pending, "pending");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module PriceScheduleList =
  struct
    type t = PriceSchedule.t list
    let make elems () = elems
    let to_query v = Query.to_query_list PriceSchedule.to_query v
    let to_headers v = Headers.to_headers_list PriceSchedule.to_headers v
    let to_json v = `List (List.map PriceSchedule.to_json v)
    let parse xml =
      Util.option_all (List.map PriceSchedule.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PriceSchedule.to_xml x))) v
  end
module ClientVpnConnectionStatus =
  struct
    type t =
      {
      code: ClientVpnConnectionStatusCode.t option
        [@ocaml.doc "<p>The state of the client connection.</p>"];
      message: String.t option
        [@ocaml.doc
          "<p>A message about the status of the client connection, if applicable.</p>"]}
    [@@ocaml.doc "<p>Describes the status of a client connection.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code", (ClientVpnConnectionStatusCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (ClientVpnConnectionStatusCode.to_json f)))])
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               ClientVpnConnectionStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (ClientVpnConnectionStatusCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the status of a client connection.</p>"]
module LocationType =
  struct
    type t =
      | Region 
      | Availability_zone 
      | Availability_zone_id 
    let str_to_t =
      [("availability-zone-id", Availability_zone_id);
      ("availability-zone", Availability_zone);
      ("region", Region)]
    let t_to_str =
      [(Availability_zone_id, "availability-zone-id");
      (Availability_zone, "availability-zone");
      (Region, "region")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module InstanceStatusEventList =
  struct
    type t = InstanceStatusEvent.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InstanceStatusEvent.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceStatusEvent.to_headers v
    let to_json v = `List (List.map InstanceStatusEvent.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceStatusEvent.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstanceStatusEvent.to_xml x))) v
  end
module InstanceStatusSummary =
  struct
    type t =
      {
      details: InstanceStatusDetailsList.t
        [@ocaml.doc
          "<p>The system instance health or application instance health.</p>"];
      status: SummaryStatus.t [@ocaml.doc "<p>The status.</p>"]}[@@ocaml.doc
                                                                  "<p>Describes the status of an instance.</p>"]
    let make ?(details= [])  ~status  () = { details; status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Status", (SummaryStatus.to_query v.status)));
           Some
             (Query.Pair
                ("Details", (InstanceStatusDetailsList.to_query v.details)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("status", (SummaryStatus.to_json v.status));
           Some ("details", (InstanceStatusDetailsList.to_json v.details))])
    let parse xml =
      Some
        {
          details =
            (Util.of_option []
               (Util.option_bind (Xml.member "details" xml)
                  InstanceStatusDetailsList.parse));
          status =
            (Xml.required "status"
               (Util.option_bind (Xml.member "status" xml)
                  SummaryStatus.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "details"
                       ([], (InstanceStatusDetailsList.to_xml [x]))))
               v.details))
           @
           [Some
              (Ezxmlm.make_tag "status" ([], (SummaryStatus.to_xml v.status)))])
  end[@@ocaml.doc "<p>Describes the status of an instance.</p>"]
module ImageState =
  struct
    type t =
      | Pending 
      | Available 
      | Invalid 
      | Deregistered 
      | Transient 
      | Failed 
      | Error 
    let str_to_t =
      [("error", Error);
      ("failed", Failed);
      ("transient", Transient);
      ("deregistered", Deregistered);
      ("invalid", Invalid);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Error, "error");
      (Failed, "failed");
      (Transient, "transient");
      (Deregistered, "deregistered");
      (Invalid, "invalid");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ImageTypeValues =
  struct
    type t =
      | Machine 
      | Kernel 
      | Ramdisk 
    let str_to_t =
      [("ramdisk", Ramdisk); ("kernel", Kernel); ("machine", Machine)]
    let t_to_str =
      [(Ramdisk, "ramdisk"); (Kernel, "kernel"); (Machine, "machine")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module SnapshotTaskDetail =
  struct
    type t =
      {
      description: String.t option
        [@ocaml.doc "<p>The description of the snapshot.</p>"];
      disk_image_size: Double.t option
        [@ocaml.doc "<p>The size of the disk in the snapshot, in GiB.</p>"];
      encrypted: Boolean.t option
        [@ocaml.doc "<p>Indicates whether the snapshot is encrypted.</p>"];
      format: String.t option
        [@ocaml.doc
          "<p>The format of the disk image from which the snapshot is created.</p>"];
      kms_key_id: String.t option
        [@ocaml.doc
          "<p>The identifier for the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to create the encrypted snapshot.</p>"];
      progress: String.t option
        [@ocaml.doc
          "<p>The percentage of completion for the import snapshot task.</p>"];
      snapshot_id: String.t option
        [@ocaml.doc "<p>The snapshot ID of the disk being imported.</p>"];
      status: String.t option
        [@ocaml.doc "<p>A brief status for the import snapshot task.</p>"];
      status_message: String.t option
        [@ocaml.doc
          "<p>A detailed status message for the import snapshot task.</p>"];
      url: String.t option
        [@ocaml.doc
          "<p>The URL of the disk image from which the snapshot is created.</p>"];
      user_bucket: UserBucketDetails.t option
        [@ocaml.doc "<p>The S3 bucket for the disk image.</p>"]}[@@ocaml.doc
                                                                  "<p>Details about the import snapshot task.</p>"]
    let make ?description  ?disk_image_size  ?encrypted  ?format  ?kms_key_id
       ?progress  ?snapshot_id  ?status  ?status_message  ?url  ?user_bucket 
      () =
      {
        description;
        disk_image_size;
        encrypted;
        format;
        kms_key_id;
        progress;
        snapshot_id;
        status;
        status_message;
        url;
        user_bucket
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f ->
                 Query.Pair ("UserBucket", (UserBucketDetails.to_query f)));
           Util.option_map v.url
             (fun f -> Query.Pair ("Url", (String.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.disk_image_size
             (fun f -> Query.Pair ("DiskImageSize", (Double.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> ("user_bucket", (UserBucketDetails.to_json f)));
           Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.format (fun f -> ("format", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.disk_image_size
             (fun f -> ("disk_image_size", (Double.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          disk_image_size =
            (Util.option_bind (Xml.member "diskImageSize" xml) Double.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          format = (Util.option_bind (Xml.member "format" xml) String.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          url = (Util.option_bind (Xml.member "url" xml) String.parse);
          user_bucket =
            (Util.option_bind (Xml.member "userBucket" xml)
               UserBucketDetails.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.description
                        (fun f ->
                           Ezxmlm.make_tag "description"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.disk_image_size
                       (fun f ->
                          Ezxmlm.make_tag "diskImageSize"
                            ([], (Double.to_xml f)))])
                   @
                   [Util.option_map v.encrypted
                      (fun f ->
                         Ezxmlm.make_tag "encrypted" ([], (Boolean.to_xml f)))])
                  @
                  [Util.option_map v.format
                     (fun f ->
                        Ezxmlm.make_tag "format" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.kms_key_id
                    (fun f ->
                       Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.progress
                   (fun f ->
                      Ezxmlm.make_tag "progress" ([], (String.to_xml f)))])
               @
               [Util.option_map v.snapshot_id
                  (fun f ->
                     Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.status
                 (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
             @
             [Util.option_map v.status_message
                (fun f ->
                   Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
            @
            [Util.option_map v.url
               (fun f -> Ezxmlm.make_tag "url" ([], (String.to_xml f)))])
           @
           [Util.option_map v.user_bucket
              (fun f ->
                 Ezxmlm.make_tag "userBucket"
                   ([], (UserBucketDetails.to_xml f)))])
  end[@@ocaml.doc "<p>Details about the import snapshot task.</p>"]
module InterfacePermissionType =
  struct
    type t =
      | INSTANCE_ATTACH 
      | EIP_ASSOCIATE 
    let str_to_t =
      [("EIP-ASSOCIATE", EIP_ASSOCIATE);
      ("INSTANCE-ATTACH", INSTANCE_ATTACH)]
    let t_to_str =
      [(EIP_ASSOCIATE, "EIP-ASSOCIATE");
      (INSTANCE_ATTACH, "INSTANCE-ATTACH")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module NetworkInterfacePermissionState =
  struct
    type t =
      {
      state: NetworkInterfacePermissionStateCode.t option
        [@ocaml.doc "<p>The state of the permission.</p>"];
      status_message: String.t option
        [@ocaml.doc "<p>A status message, if applicable.</p>"]}[@@ocaml.doc
                                                                 "<p>Describes the state of a network interface permission.</p>"]
    let make ?state  ?status_message  () = { state; status_message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (NetworkInterfacePermissionStateCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.state
             (fun f ->
                ("state", (NetworkInterfacePermissionStateCode.to_json f)))])
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml)
               NetworkInterfacePermissionStateCode.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.state
               (fun f ->
                  Ezxmlm.make_tag "state"
                    ([], (NetworkInterfacePermissionStateCode.to_xml f)))])
           @
           [Util.option_map v.status_message
              (fun f ->
                 Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the state of a network interface permission.</p>"]
module AllocationState =
  struct
    type t =
      | Available 
      | Under_assessment 
      | Permanent_failure 
      | Released 
      | Released_permanent_failure 
      | Pending 
    let str_to_t =
      [("pending", Pending);
      ("released-permanent-failure", Released_permanent_failure);
      ("released", Released);
      ("permanent-failure", Permanent_failure);
      ("under-assessment", Under_assessment);
      ("available", Available)]
    let t_to_str =
      [(Pending, "pending");
      (Released_permanent_failure, "released-permanent-failure");
      (Released, "released");
      (Permanent_failure, "permanent-failure");
      (Under_assessment, "under-assessment");
      (Available, "available")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module AllowsMultipleInstanceTypes =
  struct
    type t =
      | On 
      | Off 
    let str_to_t = [("off", Off); ("on", On)]
    let t_to_str = [(Off, "off"); (On, "on")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module AutoPlacement =
  struct
    type t =
      | On 
      | Off 
    let str_to_t = [("off", Off); ("on", On)]
    let t_to_str = [(Off, "off"); (On, "on")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module AvailableCapacity =
  struct
    type t =
      {
      available_instance_capacity: AvailableInstanceCapacityList.t
        [@ocaml.doc
          "<p>The number of instances that can be launched onto the Dedicated Host depending on the host's available capacity. For Dedicated Hosts that support multiple instance types, this parameter represents the number of instances for each instance size that is supported on the host.</p>"];
      available_v_cpus: Integer.t option
        [@ocaml.doc
          "<p>The number of vCPUs available for launching instances onto the Dedicated Host.</p>"]}
    [@@ocaml.doc
      "<p>The capacity information for instances that can be launched onto the Dedicated Host. </p>"]
    let make ?(available_instance_capacity= [])  ?available_v_cpus  () =
      { available_instance_capacity; available_v_cpus }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.available_v_cpus
              (fun f -> Query.Pair ("AvailableVCpus", (Integer.to_query f)));
           Some
             (Query.Pair
                ("AvailableInstanceCapacity",
                  (AvailableInstanceCapacityList.to_query
                     v.available_instance_capacity)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.available_v_cpus
              (fun f -> ("available_v_cpus", (Integer.to_json f)));
           Some
             ("available_instance_capacity",
               (AvailableInstanceCapacityList.to_json
                  v.available_instance_capacity))])
    let parse xml =
      Some
        {
          available_instance_capacity =
            (Util.of_option []
               (Util.option_bind (Xml.member "availableInstanceCapacity" xml)
                  AvailableInstanceCapacityList.parse));
          available_v_cpus =
            (Util.option_bind (Xml.member "availableVCpus" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "availableInstanceCapacity"
                       ([], (AvailableInstanceCapacityList.to_xml [x]))))
               v.available_instance_capacity))
           @
           [Util.option_map v.available_v_cpus
              (fun f ->
                 Ezxmlm.make_tag "availableVCpus" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc
       "<p>The capacity information for instances that can be launched onto the Dedicated Host. </p>"]
module HostInstanceList =
  struct
    type t = HostInstance.t list
    let make elems () = elems
    let to_query v = Query.to_query_list HostInstance.to_query v
    let to_headers v = Headers.to_headers_list HostInstance.to_headers v
    let to_json v = `List (List.map HostInstance.to_json v)
    let parse xml =
      Util.option_all (List.map HostInstance.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (HostInstance.to_xml x))) v
  end
module HostProperties =
  struct
    type t =
      {
      cores: Integer.t option
        [@ocaml.doc "<p>The number of cores on the Dedicated Host.</p>"];
      instance_type: String.t option
        [@ocaml.doc
          "<p>The instance type supported by the Dedicated Host. For example, <code>m5.large</code>. If the host supports multiple instance types, no <b>instanceType</b> is returned.</p>"];
      instance_family: String.t option
        [@ocaml.doc
          "<p>The instance family supported by the Dedicated Host. For example, <code>m5</code>.</p>"];
      sockets: Integer.t option
        [@ocaml.doc "<p>The number of sockets on the Dedicated Host.</p>"];
      total_v_cpus: Integer.t option
        [@ocaml.doc
          "<p>The total number of vCPUs on the Dedicated Host.</p>"]}
    [@@ocaml.doc "<p>Describes the properties of a Dedicated Host.</p>"]
    let make ?cores  ?instance_type  ?instance_family  ?sockets 
      ?total_v_cpus  () =
      { cores; instance_type; instance_family; sockets; total_v_cpus }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_v_cpus
              (fun f -> Query.Pair ("TotalVCpus", (Integer.to_query f)));
           Util.option_map v.sockets
             (fun f -> Query.Pair ("Sockets", (Integer.to_query f)));
           Util.option_map v.instance_family
             (fun f -> Query.Pair ("InstanceFamily", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.cores
             (fun f -> Query.Pair ("Cores", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_v_cpus
              (fun f -> ("total_v_cpus", (Integer.to_json f)));
           Util.option_map v.sockets
             (fun f -> ("sockets", (Integer.to_json f)));
           Util.option_map v.instance_family
             (fun f -> ("instance_family", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.cores (fun f -> ("cores", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          cores = (Util.option_bind (Xml.member "cores" xml) Integer.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          instance_family =
            (Util.option_bind (Xml.member "instanceFamily" xml) String.parse);
          sockets =
            (Util.option_bind (Xml.member "sockets" xml) Integer.parse);
          total_v_cpus =
            (Util.option_bind (Xml.member "totalVCpus" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.cores
                  (fun f -> Ezxmlm.make_tag "cores" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.instance_type
                 (fun f ->
                    Ezxmlm.make_tag "instanceType" ([], (String.to_xml f)))])
             @
             [Util.option_map v.instance_family
                (fun f ->
                   Ezxmlm.make_tag "instanceFamily" ([], (String.to_xml f)))])
            @
            [Util.option_map v.sockets
               (fun f -> Ezxmlm.make_tag "sockets" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.total_v_cpus
              (fun f -> Ezxmlm.make_tag "totalVCpus" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the properties of a Dedicated Host.</p>"]
module HostRecovery =
  struct
    type t =
      | On 
      | Off 
    let str_to_t = [("off", Off); ("on", On)]
    let t_to_str = [(Off, "off"); (On, "on")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module SubnetAssociation =
  struct
    type t =
      {
      subnet_id: String.t option [@ocaml.doc "<p>The ID of the subnet.</p>"];
      state: TransitGatewayMulitcastDomainAssociationState.t option
        [@ocaml.doc "<p>The state of the subnet association.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes the subnet association with the transit gateway multicast domain.</p>"]
    let make ?subnet_id  ?state  () = { subnet_id; state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State",
                     (TransitGatewayMulitcastDomainAssociationState.to_query
                        f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 ("state",
                   (TransitGatewayMulitcastDomainAssociationState.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayMulitcastDomainAssociationState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.subnet_id
               (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([],
                     (TransitGatewayMulitcastDomainAssociationState.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the subnet association with the transit gateway multicast domain.</p>"]
module InstanceHealthStatus =
  struct
    type t =
      | Healthy 
      | Unhealthy 
    let str_to_t = [("unhealthy", Unhealthy); ("healthy", Healthy)]
    let t_to_str = [(Unhealthy, "unhealthy"); (Healthy, "healthy")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module EbsInstanceBlockDeviceSpecification =
  struct
    type t =
      {
      delete_on_termination: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the volume is deleted on instance termination.</p>"];
      volume_id: String.t option
        [@ocaml.doc "<p>The ID of the EBS volume.</p>"]}[@@ocaml.doc
                                                          "<p>Describes information used to set up an EBS volume specified in a block device mapping.</p>"]
    let make ?delete_on_termination  ?volume_id  () =
      { delete_on_termination; volume_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> ("volume_id", (String.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.delete_on_termination
               (fun f ->
                  Ezxmlm.make_tag "deleteOnTermination"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.volume_id
              (fun f -> Ezxmlm.make_tag "volumeId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes information used to set up an EBS volume specified in a block device mapping.</p>"]
module LoadPermission =
  struct
    type t =
      {
      user_id: String.t option [@ocaml.doc "<p>The AWS account ID.</p>"];
      group: PermissionGroup.t option
        [@ocaml.doc "<p>The name of the group.</p>"]}[@@ocaml.doc
                                                       "<p>Describes a load permission.</p>"]
    let make ?user_id  ?group  () = { user_id; group }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group
              (fun f -> Query.Pair ("Group", (PermissionGroup.to_query f)));
           Util.option_map v.user_id
             (fun f -> Query.Pair ("UserId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group
              (fun f -> ("group", (PermissionGroup.to_json f)));
           Util.option_map v.user_id
             (fun f -> ("user_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          user_id = (Util.option_bind (Xml.member "userId" xml) String.parse);
          group =
            (Util.option_bind (Xml.member "group" xml) PermissionGroup.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.user_id
               (fun f -> Ezxmlm.make_tag "userId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.group
              (fun f ->
                 Ezxmlm.make_tag "group" ([], (PermissionGroup.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a load permission.</p>"]
module TransitGatewayMulticastDomainState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module IdFormatList =
  struct
    type t = IdFormat.t list
    let make elems () = elems
    let to_query v = Query.to_query_list IdFormat.to_query v
    let to_headers v = Headers.to_headers_list IdFormat.to_headers v
    let to_json v = `List (List.map IdFormat.to_json v)
    let parse xml =
      Util.option_all (List.map IdFormat.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (IdFormat.to_xml x)))
        v
  end
module PrincipalType =
  struct
    type t =
      | All 
      | Service 
      | OrganizationUnit 
      | Account 
      | User 
      | Role 
    let str_to_t =
      [("Role", Role);
      ("User", User);
      ("Account", Account);
      ("OrganizationUnit", OrganizationUnit);
      ("Service", Service);
      ("All", All)]
    let t_to_str =
      [(Role, "Role");
      (User, "User");
      (Account, "Account");
      (OrganizationUnit, "OrganizationUnit");
      (Service, "Service");
      (All, "All")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ByoipCidrState =
  struct
    type t =
      | Advertised 
      | Deprovisioned 
      | Failed_deprovision 
      | Failed_provision 
      | Pending_deprovision 
      | Pending_provision 
      | Provisioned 
    let str_to_t =
      [("provisioned", Provisioned);
      ("pending-provision", Pending_provision);
      ("pending-deprovision", Pending_deprovision);
      ("failed-provision", Failed_provision);
      ("failed-deprovision", Failed_deprovision);
      ("deprovisioned", Deprovisioned);
      ("advertised", Advertised)]
    let t_to_str =
      [(Provisioned, "provisioned");
      (Pending_provision, "pending-provision");
      (Pending_deprovision, "pending-deprovision");
      (Failed_provision, "failed-provision");
      (Failed_deprovision, "failed-deprovision");
      (Deprovisioned, "deprovisioned");
      (Advertised, "advertised")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module DeleteFleetError =
  struct
    type t =
      {
      code: DeleteFleetErrorCode.t option
        [@ocaml.doc "<p>The error code.</p>"];
      message: String.t option
        [@ocaml.doc "<p>The description for the error code.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes an EC2 Fleet error.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (DeleteFleetErrorCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (DeleteFleetErrorCode.to_json f)))])
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               DeleteFleetErrorCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (DeleteFleetErrorCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an EC2 Fleet error.</p>"]
module FleetStateCode =
  struct
    type t =
      | Submitted 
      | Active 
      | Deleted 
      | Failed 
      | Deleted_running 
      | Deleted_terminating 
      | Modifying 
    let str_to_t =
      [("modifying", Modifying);
      ("deleted_terminating", Deleted_terminating);
      ("deleted_running", Deleted_running);
      ("failed", Failed);
      ("deleted", Deleted);
      ("active", Active);
      ("submitted", Submitted)]
    let t_to_str =
      [(Modifying, "modifying");
      (Deleted_terminating, "deleted_terminating");
      (Deleted_running, "deleted_running");
      (Failed, "failed");
      (Deleted, "deleted");
      (Active, "active");
      (Submitted, "submitted")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module DisableFastSnapshotRestoreStateErrorSet =
  struct
    type t = DisableFastSnapshotRestoreStateErrorItem.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list DisableFastSnapshotRestoreStateErrorItem.to_query v
    let to_headers v =
      Headers.to_headers_list
        DisableFastSnapshotRestoreStateErrorItem.to_headers v
    let to_json v =
      `List (List.map DisableFastSnapshotRestoreStateErrorItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map DisableFastSnapshotRestoreStateErrorItem.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (DisableFastSnapshotRestoreStateErrorItem.to_xml x))) v
  end
module FastSnapshotRestoreStateCode =
  struct
    type t =
      | Enabling 
      | Optimizing 
      | Enabled 
      | Disabling 
      | Disabled 
    let str_to_t =
      [("disabled", Disabled);
      ("disabling", Disabling);
      ("enabled", Enabled);
      ("optimizing", Optimizing);
      ("enabling", Enabling)]
    let t_to_str =
      [(Disabled, "disabled");
      (Disabling, "disabling");
      (Enabled, "enabled");
      (Optimizing, "optimizing");
      (Enabling, "enabling")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ScheduledInstanceRecurrence =
  struct
    type t =
      {
      frequency: String.t option
        [@ocaml.doc
          "<p>The frequency (<code>Daily</code>, <code>Weekly</code>, or <code>Monthly</code>).</p>"];
      interval: Integer.t option
        [@ocaml.doc
          "<p>The interval quantity. The interval unit depends on the value of <code>frequency</code>. For example, every 2 weeks or every 2 months.</p>"];
      occurrence_day_set: OccurrenceDaySet.t
        [@ocaml.doc
          "<p>The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday).</p>"];
      occurrence_relative_to_end: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the occurrence is relative to the end of the specified week or month.</p>"];
      occurrence_unit: String.t option
        [@ocaml.doc
          "<p>The unit for <code>occurrenceDaySet</code> (<code>DayOfWeek</code> or <code>DayOfMonth</code>).</p>"]}
    [@@ocaml.doc
      "<p>Describes the recurring schedule for a Scheduled Instance.</p>"]
    let make ?frequency  ?interval  ?(occurrence_day_set= []) 
      ?occurrence_relative_to_end  ?occurrence_unit  () =
      {
        frequency;
        interval;
        occurrence_day_set;
        occurrence_relative_to_end;
        occurrence_unit
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.occurrence_unit
              (fun f -> Query.Pair ("OccurrenceUnit", (String.to_query f)));
           Util.option_map v.occurrence_relative_to_end
             (fun f ->
                Query.Pair ("OccurrenceRelativeToEnd", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("OccurrenceDaySet",
                  (OccurrenceDaySet.to_query v.occurrence_day_set)));
           Util.option_map v.interval
             (fun f -> Query.Pair ("Interval", (Integer.to_query f)));
           Util.option_map v.frequency
             (fun f -> Query.Pair ("Frequency", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.occurrence_unit
              (fun f -> ("occurrence_unit", (String.to_json f)));
           Util.option_map v.occurrence_relative_to_end
             (fun f -> ("occurrence_relative_to_end", (Boolean.to_json f)));
           Some
             ("occurrence_day_set",
               (OccurrenceDaySet.to_json v.occurrence_day_set));
           Util.option_map v.interval
             (fun f -> ("interval", (Integer.to_json f)));
           Util.option_map v.frequency
             (fun f -> ("frequency", (String.to_json f)))])
    let parse xml =
      Some
        {
          frequency =
            (Util.option_bind (Xml.member "frequency" xml) String.parse);
          interval =
            (Util.option_bind (Xml.member "interval" xml) Integer.parse);
          occurrence_day_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "occurrenceDaySet" xml)
                  OccurrenceDaySet.parse));
          occurrence_relative_to_end =
            (Util.option_bind (Xml.member "occurrenceRelativeToEnd" xml)
               Boolean.parse);
          occurrence_unit =
            (Util.option_bind (Xml.member "occurrenceUnit" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.frequency
                  (fun f ->
                     Ezxmlm.make_tag "frequency" ([], (String.to_xml f)))])
              @
              [Util.option_map v.interval
                 (fun f ->
                    Ezxmlm.make_tag "interval" ([], (Integer.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "occurrenceDaySet"
                        ([], (OccurrenceDaySet.to_xml [x]))))
                v.occurrence_day_set))
            @
            [Util.option_map v.occurrence_relative_to_end
               (fun f ->
                  Ezxmlm.make_tag "occurrenceRelativeToEnd"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.occurrence_unit
              (fun f ->
                 Ezxmlm.make_tag "occurrenceUnit" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the recurring schedule for a Scheduled Instance.</p>"]
module LogDestinationType =
  struct
    type t =
      | Cloud_watch_logs 
      | S3 
    let str_to_t = [("s3", S3); ("cloud-watch-logs", Cloud_watch_logs)]
    let t_to_str = [(S3, "s3"); (Cloud_watch_logs, "cloud-watch-logs")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module TrafficType =
  struct
    type t =
      | ACCEPT 
      | REJECT 
      | ALL 
    let str_to_t = [("ALL", ALL); ("REJECT", REJECT); ("ACCEPT", ACCEPT)]
    let t_to_str = [(ALL, "ALL"); (REJECT, "REJECT"); (ACCEPT, "ACCEPT")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module BundleTaskError =
  struct
    type t =
      {
      code: String.t option [@ocaml.doc "<p>The error code.</p>"];
      message: String.t option [@ocaml.doc "<p>The error message.</p>"]}
    [@@ocaml.doc "<p>Describes an error for <a>BundleInstance</a>.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an error for <a>BundleInstance</a>.</p>"]
module BundleTaskState =
  struct
    type t =
      | Pending 
      | Waiting_for_shutdown 
      | Bundling 
      | Storing 
      | Cancelling 
      | Complete 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("complete", Complete);
      ("cancelling", Cancelling);
      ("storing", Storing);
      ("bundling", Bundling);
      ("waiting-for-shutdown", Waiting_for_shutdown);
      ("pending", Pending)]
    let t_to_str =
      [(Failed, "failed");
      (Complete, "complete");
      (Cancelling, "cancelling");
      (Storing, "storing");
      (Bundling, "bundling");
      (Waiting_for_shutdown, "waiting-for-shutdown");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module Storage =
  struct
    type t =
      {
      s3: S3Storage.t option
        [@ocaml.doc "<p>An Amazon S3 storage location.</p>"]}[@@ocaml.doc
                                                               "<p>Describes the storage location for an instance store-backed AMI.</p>"]
    let make ?s3  () = { s3 }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3
              (fun f -> Query.Pair ("S3", (S3Storage.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3 (fun f -> ("s3", (S3Storage.to_json f)))])
    let parse xml =
      Some { s3 = (Util.option_bind (Xml.member "S3" xml) S3Storage.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.s3
              (fun f -> Ezxmlm.make_tag "S3" ([], (S3Storage.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the storage location for an instance store-backed AMI.</p>"]
module StaleIpPermissionSet =
  struct
    type t = StaleIpPermission.t list
    let make elems () = elems
    let to_query v = Query.to_query_list StaleIpPermission.to_query v
    let to_headers v = Headers.to_headers_list StaleIpPermission.to_headers v
    let to_json v = `List (List.map StaleIpPermission.to_json v)
    let parse xml =
      Util.option_all
        (List.map StaleIpPermission.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (StaleIpPermission.to_xml x)))
        v
  end
module CreateVolumePermission =
  struct
    type t =
      {
      group: PermissionGroup.t option
        [@ocaml.doc
          "<p>The group to be added or removed. The possible value is <code>all</code>.</p>"];
      user_id: String.t option
        [@ocaml.doc "<p>The AWS account ID to be added or removed.</p>"]}
    [@@ocaml.doc
      "<p>Describes the user or group to be added or removed from the list of create volume permissions for a volume.</p>"]
    let make ?group  ?user_id  () = { group; user_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> Query.Pair ("UserId", (String.to_query f)));
           Util.option_map v.group
             (fun f -> Query.Pair ("Group", (PermissionGroup.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> ("user_id", (String.to_json f)));
           Util.option_map v.group
             (fun f -> ("group", (PermissionGroup.to_json f)))])
    let parse xml =
      Some
        {
          group =
            (Util.option_bind (Xml.member "group" xml) PermissionGroup.parse);
          user_id = (Util.option_bind (Xml.member "userId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.group
               (fun f ->
                  Ezxmlm.make_tag "group" ([], (PermissionGroup.to_xml f)))])
           @
           [Util.option_map v.user_id
              (fun f -> Ezxmlm.make_tag "userId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the user or group to be added or removed from the list of create volume permissions for a volume.</p>"]
module VolumeAttachmentList =
  struct
    type t = VolumeAttachment.t list
    let make elems () = elems
    let to_query v = Query.to_query_list VolumeAttachment.to_query v
    let to_headers v = Headers.to_headers_list VolumeAttachment.to_headers v
    let to_json v = `List (List.map VolumeAttachment.to_json v)
    let parse xml =
      Util.option_all
        (List.map VolumeAttachment.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VolumeAttachment.to_xml x)))
        v
  end
module VolumeState =
  struct
    type t =
      | Creating 
      | Available 
      | In_use 
      | Deleting 
      | Deleted 
      | Error 
    let str_to_t =
      [("error", Error);
      ("deleted", Deleted);
      ("deleting", Deleting);
      ("in-use", In_use);
      ("available", Available);
      ("creating", Creating)]
    let t_to_str =
      [(Error, "error");
      (Deleted, "deleted");
      (Deleting, "deleting");
      (In_use, "in-use");
      (Available, "available");
      (Creating, "creating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module VpnTunnelOptionsSpecification =
  struct
    type t =
      {
      tunnel_inside_cidr: String.t option
        [@ocaml.doc
          "<p>The range of inside IP addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. </p> <p>Constraints: A size /30 CIDR block from the <code>169.254.0.0/16</code> range. The following CIDR blocks are reserved and cannot be used:</p> <ul> <li> <p> <code>169.254.0.0/30</code> </p> </li> <li> <p> <code>169.254.1.0/30</code> </p> </li> <li> <p> <code>169.254.2.0/30</code> </p> </li> <li> <p> <code>169.254.3.0/30</code> </p> </li> <li> <p> <code>169.254.4.0/30</code> </p> </li> <li> <p> <code>169.254.5.0/30</code> </p> </li> <li> <p> <code>169.254.169.252/30</code> </p> </li> </ul>"];
      pre_shared_key: String.t option
        [@ocaml.doc
          "<p>The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.</p> <p>Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).</p>"];
      phase1_lifetime_seconds: Integer.t option
        [@ocaml.doc
          "<p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p> <p>Constraints: A value between 900 and 28,800.</p> <p>Default: <code>28800</code> </p>"];
      phase2_lifetime_seconds: Integer.t option
        [@ocaml.doc
          "<p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p> <p>Constraints: A value between 900 and 3,600. The value must be less than the value for <code>Phase1LifetimeSeconds</code>.</p> <p>Default: <code>3600</code> </p>"];
      rekey_margin_time_seconds: Integer.t option
        [@ocaml.doc
          "<p>The margin time, in seconds, before the phase 2 lifetime expires, during which the AWS side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for <code>RekeyFuzzPercentage</code>.</p> <p>Constraints: A value between 60 and half of <code>Phase2LifetimeSeconds</code>.</p> <p>Default: <code>540</code> </p>"];
      rekey_fuzz_percentage: Integer.t option
        [@ocaml.doc
          "<p>The percentage of the rekey window (determined by <code>RekeyMarginTimeSeconds</code>) during which the rekey time is randomly selected.</p> <p>Constraints: A value between 0 and 100.</p> <p>Default: <code>100</code> </p>"];
      replay_window_size: Integer.t option
        [@ocaml.doc
          "<p>The number of packets in an IKE replay window.</p> <p>Constraints: A value between 64 and 2048.</p> <p>Default: <code>1024</code> </p>"];
      d_p_d_timeout_seconds: Integer.t option
        [@ocaml.doc
          "<p>The number of seconds after which a DPD timeout occurs.</p> <p>Constraints: A value between 0 and 30.</p> <p>Default: <code>30</code> </p>"];
      phase1_encryption_algorithms: Phase1EncryptionAlgorithmsRequestList.t
        [@ocaml.doc
          "<p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p> <p>Valid values: <code>AES128</code> | <code>AES256</code> </p>"];
      phase2_encryption_algorithms: Phase2EncryptionAlgorithmsRequestList.t
        [@ocaml.doc
          "<p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p> <p>Valid values: <code>AES128</code> | <code>AES256</code> </p>"];
      phase1_integrity_algorithms: Phase1IntegrityAlgorithmsRequestList.t
        [@ocaml.doc
          "<p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p> <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> </p>"];
      phase2_integrity_algorithms: Phase2IntegrityAlgorithmsRequestList.t
        [@ocaml.doc
          "<p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p> <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> </p>"];
      phase1_d_h_group_numbers: Phase1DHGroupNumbersRequestList.t
        [@ocaml.doc
          "<p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p> <p>Valid values: <code>2</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>22</code> | <code>23</code> | <code>24</code> </p>"];
      phase2_d_h_group_numbers: Phase2DHGroupNumbersRequestList.t
        [@ocaml.doc
          "<p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p> <p>Valid values: <code>2</code> | <code>5</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>22</code> | <code>23</code> | <code>24</code> </p>"];
      i_k_e_versions: IKEVersionsRequestList.t
        [@ocaml.doc
          "<p>The IKE versions that are permitted for the VPN tunnel.</p> <p>Valid values: <code>ikev1</code> | <code>ikev2</code> </p>"]}
    [@@ocaml.doc "<p>The tunnel options for a VPN connection.</p>"]
    let make ?tunnel_inside_cidr  ?pre_shared_key  ?phase1_lifetime_seconds 
      ?phase2_lifetime_seconds  ?rekey_margin_time_seconds 
      ?rekey_fuzz_percentage  ?replay_window_size  ?d_p_d_timeout_seconds 
      ?(phase1_encryption_algorithms= [])  ?(phase2_encryption_algorithms=
      [])  ?(phase1_integrity_algorithms= [])  ?(phase2_integrity_algorithms=
      [])  ?(phase1_d_h_group_numbers= [])  ?(phase2_d_h_group_numbers= []) 
      ?(i_k_e_versions= [])  () =
      {
        tunnel_inside_cidr;
        pre_shared_key;
        phase1_lifetime_seconds;
        phase2_lifetime_seconds;
        rekey_margin_time_seconds;
        rekey_fuzz_percentage;
        replay_window_size;
        d_p_d_timeout_seconds;
        phase1_encryption_algorithms;
        phase2_encryption_algorithms;
        phase1_integrity_algorithms;
        phase2_integrity_algorithms;
        phase1_d_h_group_numbers;
        phase2_d_h_group_numbers;
        i_k_e_versions
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("IKEVersion",
                   (IKEVersionsRequestList.to_query v.i_k_e_versions)));
           Some
             (Query.Pair
                ("Phase2DHGroupNumber",
                  (Phase2DHGroupNumbersRequestList.to_query
                     v.phase2_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase1DHGroupNumber",
                  (Phase1DHGroupNumbersRequestList.to_query
                     v.phase1_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase2IntegrityAlgorithm",
                  (Phase2IntegrityAlgorithmsRequestList.to_query
                     v.phase2_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase1IntegrityAlgorithm",
                  (Phase1IntegrityAlgorithmsRequestList.to_query
                     v.phase1_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase2EncryptionAlgorithm",
                  (Phase2EncryptionAlgorithmsRequestList.to_query
                     v.phase2_encryption_algorithms)));
           Some
             (Query.Pair
                ("Phase1EncryptionAlgorithm",
                  (Phase1EncryptionAlgorithmsRequestList.to_query
                     v.phase1_encryption_algorithms)));
           Util.option_map v.d_p_d_timeout_seconds
             (fun f -> Query.Pair ("DPDTimeoutSeconds", (Integer.to_query f)));
           Util.option_map v.replay_window_size
             (fun f -> Query.Pair ("ReplayWindowSize", (Integer.to_query f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f ->
                Query.Pair ("RekeyFuzzPercentage", (Integer.to_query f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f ->
                Query.Pair ("RekeyMarginTimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase2LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase1LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.pre_shared_key
             (fun f -> Query.Pair ("PreSharedKey", (String.to_query f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> Query.Pair ("TunnelInsideCidr", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("i_k_e_versions",
                (IKEVersionsRequestList.to_json v.i_k_e_versions));
           Some
             ("phase2_d_h_group_numbers",
               (Phase2DHGroupNumbersRequestList.to_json
                  v.phase2_d_h_group_numbers));
           Some
             ("phase1_d_h_group_numbers",
               (Phase1DHGroupNumbersRequestList.to_json
                  v.phase1_d_h_group_numbers));
           Some
             ("phase2_integrity_algorithms",
               (Phase2IntegrityAlgorithmsRequestList.to_json
                  v.phase2_integrity_algorithms));
           Some
             ("phase1_integrity_algorithms",
               (Phase1IntegrityAlgorithmsRequestList.to_json
                  v.phase1_integrity_algorithms));
           Some
             ("phase2_encryption_algorithms",
               (Phase2EncryptionAlgorithmsRequestList.to_json
                  v.phase2_encryption_algorithms));
           Some
             ("phase1_encryption_algorithms",
               (Phase1EncryptionAlgorithmsRequestList.to_json
                  v.phase1_encryption_algorithms));
           Util.option_map v.d_p_d_timeout_seconds
             (fun f -> ("d_p_d_timeout_seconds", (Integer.to_json f)));
           Util.option_map v.replay_window_size
             (fun f -> ("replay_window_size", (Integer.to_json f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f -> ("rekey_fuzz_percentage", (Integer.to_json f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f -> ("rekey_margin_time_seconds", (Integer.to_json f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f -> ("phase2_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f -> ("phase1_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.pre_shared_key
             (fun f -> ("pre_shared_key", (String.to_json f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> ("tunnel_inside_cidr", (String.to_json f)))])
    let parse xml =
      Some
        {
          tunnel_inside_cidr =
            (Util.option_bind (Xml.member "TunnelInsideCidr" xml)
               String.parse);
          pre_shared_key =
            (Util.option_bind (Xml.member "PreSharedKey" xml) String.parse);
          phase1_lifetime_seconds =
            (Util.option_bind (Xml.member "Phase1LifetimeSeconds" xml)
               Integer.parse);
          phase2_lifetime_seconds =
            (Util.option_bind (Xml.member "Phase2LifetimeSeconds" xml)
               Integer.parse);
          rekey_margin_time_seconds =
            (Util.option_bind (Xml.member "RekeyMarginTimeSeconds" xml)
               Integer.parse);
          rekey_fuzz_percentage =
            (Util.option_bind (Xml.member "RekeyFuzzPercentage" xml)
               Integer.parse);
          replay_window_size =
            (Util.option_bind (Xml.member "ReplayWindowSize" xml)
               Integer.parse);
          d_p_d_timeout_seconds =
            (Util.option_bind (Xml.member "DPDTimeoutSeconds" xml)
               Integer.parse);
          phase1_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1EncryptionAlgorithm" xml)
                  Phase1EncryptionAlgorithmsRequestList.parse));
          phase2_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2EncryptionAlgorithm" xml)
                  Phase2EncryptionAlgorithmsRequestList.parse));
          phase1_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1IntegrityAlgorithm" xml)
                  Phase1IntegrityAlgorithmsRequestList.parse));
          phase2_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2IntegrityAlgorithm" xml)
                  Phase2IntegrityAlgorithmsRequestList.parse));
          phase1_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1DHGroupNumber" xml)
                  Phase1DHGroupNumbersRequestList.parse));
          phase2_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2DHGroupNumber" xml)
                  Phase2DHGroupNumbersRequestList.parse));
          i_k_e_versions =
            (Util.of_option []
               (Util.option_bind (Xml.member "IKEVersion" xml)
                  IKEVersionsRequestList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Util.option_map v.tunnel_inside_cidr
                            (fun f ->
                               Ezxmlm.make_tag "TunnelInsideCidr"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.pre_shared_key
                           (fun f ->
                              Ezxmlm.make_tag "PreSharedKey"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.phase1_lifetime_seconds
                          (fun f ->
                             Ezxmlm.make_tag "Phase1LifetimeSeconds"
                               ([], (Integer.to_xml f)))])
                      @
                      [Util.option_map v.phase2_lifetime_seconds
                         (fun f ->
                            Ezxmlm.make_tag "Phase2LifetimeSeconds"
                              ([], (Integer.to_xml f)))])
                     @
                     [Util.option_map v.rekey_margin_time_seconds
                        (fun f ->
                           Ezxmlm.make_tag "RekeyMarginTimeSeconds"
                             ([], (Integer.to_xml f)))])
                    @
                    [Util.option_map v.rekey_fuzz_percentage
                       (fun f ->
                          Ezxmlm.make_tag "RekeyFuzzPercentage"
                            ([], (Integer.to_xml f)))])
                   @
                   [Util.option_map v.replay_window_size
                      (fun f ->
                         Ezxmlm.make_tag "ReplayWindowSize"
                           ([], (Integer.to_xml f)))])
                  @
                  [Util.option_map v.d_p_d_timeout_seconds
                     (fun f ->
                        Ezxmlm.make_tag "DPDTimeoutSeconds"
                          ([], (Integer.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "Phase1EncryptionAlgorithm"
                            ([],
                              (Phase1EncryptionAlgorithmsRequestList.to_xml
                                 [x])))) v.phase1_encryption_algorithms))
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "Phase2EncryptionAlgorithm"
                           ([],
                             (Phase2EncryptionAlgorithmsRequestList.to_xml
                                [x])))) v.phase2_encryption_algorithms))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Phase1IntegrityAlgorithm"
                          ([],
                            (Phase1IntegrityAlgorithmsRequestList.to_xml [x]))))
                  v.phase1_integrity_algorithms))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Phase2IntegrityAlgorithm"
                         ([],
                           (Phase2IntegrityAlgorithmsRequestList.to_xml [x]))))
                 v.phase2_integrity_algorithms))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Phase1DHGroupNumber"
                        ([], (Phase1DHGroupNumbersRequestList.to_xml [x]))))
                v.phase1_d_h_group_numbers))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Phase2DHGroupNumber"
                       ([], (Phase2DHGroupNumbersRequestList.to_xml [x]))))
               v.phase2_d_h_group_numbers))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "IKEVersion"
                      ([], (IKEVersionsRequestList.to_xml [x]))))
              v.i_k_e_versions))
  end[@@ocaml.doc "<p>The tunnel options for a VPN connection.</p>"]
module DomainType =
  struct
    type t =
      | Vpc 
      | Standard 
    let str_to_t = [("standard", Standard); ("vpc", Vpc)]
    let t_to_str = [(Standard, "standard"); (Vpc, "vpc")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module EbsInfo =
  struct
    type t =
      {
      ebs_optimized_support: EbsOptimizedSupport.t option
        [@ocaml.doc
          "<p>Indicates that the instance type is Amazon EBS-optimized. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSOptimized.html\">Amazon EBS-Optimized Instances</a> in <i>Amazon EC2 User Guide for Linux Instances</i>.</p>"];
      encryption_support: EbsEncryptionSupport.t option
        [@ocaml.doc
          "<p>Indicates whether Amazon EBS encryption is supported.</p>"]}
    [@@ocaml.doc
      "<p>Describes the Amazon EBS features supported by the instance type.</p>"]
    let make ?ebs_optimized_support  ?encryption_support  () =
      { ebs_optimized_support; encryption_support }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.encryption_support
              (fun f ->
                 Query.Pair
                   ("EncryptionSupport", (EbsEncryptionSupport.to_query f)));
           Util.option_map v.ebs_optimized_support
             (fun f ->
                Query.Pair
                  ("EbsOptimizedSupport", (EbsOptimizedSupport.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.encryption_support
              (fun f ->
                 ("encryption_support", (EbsEncryptionSupport.to_json f)));
           Util.option_map v.ebs_optimized_support
             (fun f ->
                ("ebs_optimized_support", (EbsOptimizedSupport.to_json f)))])
    let parse xml =
      Some
        {
          ebs_optimized_support =
            (Util.option_bind (Xml.member "ebsOptimizedSupport" xml)
               EbsOptimizedSupport.parse);
          encryption_support =
            (Util.option_bind (Xml.member "encryptionSupport" xml)
               EbsEncryptionSupport.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.ebs_optimized_support
               (fun f ->
                  Ezxmlm.make_tag "ebsOptimizedSupport"
                    ([], (EbsOptimizedSupport.to_xml f)))])
           @
           [Util.option_map v.encryption_support
              (fun f ->
                 Ezxmlm.make_tag "encryptionSupport"
                   ([], (EbsEncryptionSupport.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the Amazon EBS features supported by the instance type.</p>"]
module FpgaInfo =
  struct
    type t =
      {
      fpgas: FpgaDeviceInfoList.t
        [@ocaml.doc "<p>Describes the FPGAs for the instance type.</p>"];
      total_fpga_memory_in_mi_b: Integer.t option
        [@ocaml.doc
          "<p>The total memory of all FPGA accelerators for the instance type.</p>"]}
    [@@ocaml.doc "<p>Describes the FPGAs for the instance type.</p>"]
    let make ?(fpgas= [])  ?total_fpga_memory_in_mi_b  () =
      { fpgas; total_fpga_memory_in_mi_b }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_fpga_memory_in_mi_b
              (fun f ->
                 Query.Pair ("TotalFpgaMemoryInMiB", (Integer.to_query f)));
           Some (Query.Pair ("Fpgas", (FpgaDeviceInfoList.to_query v.fpgas)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_fpga_memory_in_mi_b
              (fun f -> ("total_fpga_memory_in_mi_b", (Integer.to_json f)));
           Some ("fpgas", (FpgaDeviceInfoList.to_json v.fpgas))])
    let parse xml =
      Some
        {
          fpgas =
            (Util.of_option []
               (Util.option_bind (Xml.member "fpgas" xml)
                  FpgaDeviceInfoList.parse));
          total_fpga_memory_in_mi_b =
            (Util.option_bind (Xml.member "totalFpgaMemoryInMiB" xml)
               Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "fpgas"
                       ([], (FpgaDeviceInfoList.to_xml [x])))) v.fpgas))
           @
           [Util.option_map v.total_fpga_memory_in_mi_b
              (fun f ->
                 Ezxmlm.make_tag "totalFpgaMemoryInMiB"
                   ([], (Integer.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the FPGAs for the instance type.</p>"]
module GpuInfo =
  struct
    type t =
      {
      gpus: GpuDeviceInfoList.t
        [@ocaml.doc
          "<p>Describes the GPU accelerators for the instance type.</p>"];
      total_gpu_memory_in_mi_b: Integer.t option
        [@ocaml.doc
          "<p>The total size of the memory for the GPU accelerators for the instance type.</p>"]}
    [@@ocaml.doc
      "<p>Describes the GPU accelerators for the instance type.</p>"]
    let make ?(gpus= [])  ?total_gpu_memory_in_mi_b  () =
      { gpus; total_gpu_memory_in_mi_b }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_gpu_memory_in_mi_b
              (fun f ->
                 Query.Pair ("TotalGpuMemoryInMiB", (Integer.to_query f)));
           Some (Query.Pair ("Gpus", (GpuDeviceInfoList.to_query v.gpus)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_gpu_memory_in_mi_b
              (fun f -> ("total_gpu_memory_in_mi_b", (Integer.to_json f)));
           Some ("gpus", (GpuDeviceInfoList.to_json v.gpus))])
    let parse xml =
      Some
        {
          gpus =
            (Util.of_option []
               (Util.option_bind (Xml.member "gpus" xml)
                  GpuDeviceInfoList.parse));
          total_gpu_memory_in_mi_b =
            (Util.option_bind (Xml.member "totalGpuMemoryInMiB" xml)
               Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "gpus"
                       ([], (GpuDeviceInfoList.to_xml [x])))) v.gpus))
           @
           [Util.option_map v.total_gpu_memory_in_mi_b
              (fun f ->
                 Ezxmlm.make_tag "totalGpuMemoryInMiB"
                   ([], (Integer.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the GPU accelerators for the instance type.</p>"]
module InferenceAcceleratorInfo =
  struct
    type t =
      {
      accelerators: InferenceDeviceInfoList.t
        [@ocaml.doc
          "<p>Describes the Inference accelerators for the instance type.</p>"]}
    [@@ocaml.doc
      "<p>Describes the Inference accelerators for the instance type.</p>"]
    let make ?(accelerators= [])  () = { accelerators }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Accelerators",
                   (InferenceDeviceInfoList.to_query v.accelerators)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("accelerators",
                (InferenceDeviceInfoList.to_json v.accelerators))])
    let parse xml =
      Some
        {
          accelerators =
            (Util.of_option []
               (Util.option_bind (Xml.member "accelerators" xml)
                  InferenceDeviceInfoList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "accelerators"
                      ([], (InferenceDeviceInfoList.to_xml [x]))))
              v.accelerators))
  end[@@ocaml.doc
       "<p>Describes the Inference accelerators for the instance type.</p>"]
module InstanceStorageInfo =
  struct
    type t =
      {
      total_size_in_g_b: Long.t option
        [@ocaml.doc "<p>The total size of the disks, in GB.</p>"];
      disks: DiskInfoList.t
        [@ocaml.doc
          "<p>Array describing the disks that are available for the instance type.</p>"]}
    [@@ocaml.doc
      "<p>Describes the disks that are available for the instance type.</p>"]
    let make ?total_size_in_g_b  ?(disks= [])  () =
      { total_size_in_g_b; disks }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Disks", (DiskInfoList.to_query v.disks)));
           Util.option_map v.total_size_in_g_b
             (fun f -> Query.Pair ("TotalSizeInGB", (Long.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("disks", (DiskInfoList.to_json v.disks));
           Util.option_map v.total_size_in_g_b
             (fun f -> ("total_size_in_g_b", (Long.to_json f)))])
    let parse xml =
      Some
        {
          total_size_in_g_b =
            (Util.option_bind (Xml.member "totalSizeInGB" xml) Long.parse);
          disks =
            (Util.of_option []
               (Util.option_bind (Xml.member "disks" xml) DiskInfoList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.total_size_in_g_b
               (fun f ->
                  Ezxmlm.make_tag "totalSizeInGB" ([], (Long.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "disks" ([], (DiskInfoList.to_xml [x]))))
              v.disks))
  end[@@ocaml.doc
       "<p>Describes the disks that are available for the instance type.</p>"]
module InstanceTypeHypervisor =
  struct
    type t =
      | Nitro 
      | Xen 
    let str_to_t = [("xen", Xen); ("nitro", Nitro)]
    let t_to_str = [(Xen, "xen"); (Nitro, "nitro")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module MemoryInfo =
  struct
    type t =
      {
      size_in_mi_b: Long.t option
        [@ocaml.doc "<p>Size of the memory, in MiB.</p>"]}[@@ocaml.doc
                                                            "<p>Describes the memory for the instance type.</p>"]
    let make ?size_in_mi_b  () = { size_in_mi_b }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> Query.Pair ("SizeInMiB", (Long.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> ("size_in_mi_b", (Long.to_json f)))])
    let parse xml =
      Some
        {
          size_in_mi_b =
            (Util.option_bind (Xml.member "sizeInMiB" xml) Long.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.size_in_mi_b
              (fun f -> Ezxmlm.make_tag "sizeInMiB" ([], (Long.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the memory for the instance type.</p>"]
module NetworkInfo =
  struct
    type t =
      {
      network_performance: String.t option
        [@ocaml.doc "<p>Describes the network performance.</p>"];
      maximum_network_interfaces: Integer.t option
        [@ocaml.doc
          "<p>The maximum number of network interfaces for the instance type.</p>"];
      ipv4_addresses_per_interface: Integer.t option
        [@ocaml.doc
          "<p>The maximum number of IPv4 addresses per network interface.</p>"];
      ipv6_addresses_per_interface: Integer.t option
        [@ocaml.doc
          "<p>The maximum number of IPv6 addresses per network interface.</p>"];
      ipv6_supported: Boolean.t option
        [@ocaml.doc "<p>Indicates whether IPv6 is supported.</p>"];
      ena_support: EnaSupport.t option
        [@ocaml.doc
          "<p>Indicates whether Elastic Network Adapter (ENA) is supported.</p>"]}
    [@@ocaml.doc
      "<p>Describes the networking features of the instance type.</p>"]
    let make ?network_performance  ?maximum_network_interfaces 
      ?ipv4_addresses_per_interface  ?ipv6_addresses_per_interface 
      ?ipv6_supported  ?ena_support  () =
      {
        network_performance;
        maximum_network_interfaces;
        ipv4_addresses_per_interface;
        ipv6_addresses_per_interface;
        ipv6_supported;
        ena_support
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ena_support
              (fun f -> Query.Pair ("EnaSupport", (EnaSupport.to_query f)));
           Util.option_map v.ipv6_supported
             (fun f -> Query.Pair ("Ipv6Supported", (Boolean.to_query f)));
           Util.option_map v.ipv6_addresses_per_interface
             (fun f ->
                Query.Pair
                  ("Ipv6AddressesPerInterface", (Integer.to_query f)));
           Util.option_map v.ipv4_addresses_per_interface
             (fun f ->
                Query.Pair
                  ("Ipv4AddressesPerInterface", (Integer.to_query f)));
           Util.option_map v.maximum_network_interfaces
             (fun f ->
                Query.Pair ("MaximumNetworkInterfaces", (Integer.to_query f)));
           Util.option_map v.network_performance
             (fun f -> Query.Pair ("NetworkPerformance", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ena_support
              (fun f -> ("ena_support", (EnaSupport.to_json f)));
           Util.option_map v.ipv6_supported
             (fun f -> ("ipv6_supported", (Boolean.to_json f)));
           Util.option_map v.ipv6_addresses_per_interface
             (fun f -> ("ipv6_addresses_per_interface", (Integer.to_json f)));
           Util.option_map v.ipv4_addresses_per_interface
             (fun f -> ("ipv4_addresses_per_interface", (Integer.to_json f)));
           Util.option_map v.maximum_network_interfaces
             (fun f -> ("maximum_network_interfaces", (Integer.to_json f)));
           Util.option_map v.network_performance
             (fun f -> ("network_performance", (String.to_json f)))])
    let parse xml =
      Some
        {
          network_performance =
            (Util.option_bind (Xml.member "networkPerformance" xml)
               String.parse);
          maximum_network_interfaces =
            (Util.option_bind (Xml.member "maximumNetworkInterfaces" xml)
               Integer.parse);
          ipv4_addresses_per_interface =
            (Util.option_bind (Xml.member "ipv4AddressesPerInterface" xml)
               Integer.parse);
          ipv6_addresses_per_interface =
            (Util.option_bind (Xml.member "ipv6AddressesPerInterface" xml)
               Integer.parse);
          ipv6_supported =
            (Util.option_bind (Xml.member "ipv6Supported" xml) Boolean.parse);
          ena_support =
            (Util.option_bind (Xml.member "enaSupport" xml) EnaSupport.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.network_performance
                   (fun f ->
                      Ezxmlm.make_tag "networkPerformance"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.maximum_network_interfaces
                  (fun f ->
                     Ezxmlm.make_tag "maximumNetworkInterfaces"
                       ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.ipv4_addresses_per_interface
                 (fun f ->
                    Ezxmlm.make_tag "ipv4AddressesPerInterface"
                      ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.ipv6_addresses_per_interface
                (fun f ->
                   Ezxmlm.make_tag "ipv6AddressesPerInterface"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.ipv6_supported
               (fun f ->
                  Ezxmlm.make_tag "ipv6Supported" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.ena_support
              (fun f ->
                 Ezxmlm.make_tag "enaSupport" ([], (EnaSupport.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the networking features of the instance type.</p>"]
module PlacementGroupInfo =
  struct
    type t =
      {
      supported_strategies: PlacementGroupStrategyList.t
        [@ocaml.doc "<p>A list of supported placement groups types.</p>"]}
    [@@ocaml.doc
      "<p>Describes the placement group support of the instance type.</p>"]
    let make ?(supported_strategies= [])  () = { supported_strategies }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SupportedStrategies",
                   (PlacementGroupStrategyList.to_query
                      v.supported_strategies)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("supported_strategies",
                (PlacementGroupStrategyList.to_json v.supported_strategies))])
    let parse xml =
      Some
        {
          supported_strategies =
            (Util.of_option []
               (Util.option_bind (Xml.member "supportedStrategies" xml)
                  PlacementGroupStrategyList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "supportedStrategies"
                      ([], (PlacementGroupStrategyList.to_xml [x]))))
              v.supported_strategies))
  end[@@ocaml.doc
       "<p>Describes the placement group support of the instance type.</p>"]
module ProcessorInfo =
  struct
    type t =
      {
      supported_architectures: ArchitectureTypeList.t
        [@ocaml.doc
          "<p>A list of architectures supported by the instance type.</p>"];
      sustained_clock_speed_in_ghz: Double.t option
        [@ocaml.doc "<p>The speed of the processor, in GHz.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes the processor used by the instance type.</p>"]
    let make ?(supported_architectures= [])  ?sustained_clock_speed_in_ghz 
      () = { supported_architectures; sustained_clock_speed_in_ghz }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.sustained_clock_speed_in_ghz
              (fun f ->
                 Query.Pair ("SustainedClockSpeedInGhz", (Double.to_query f)));
           Some
             (Query.Pair
                ("SupportedArchitectures",
                  (ArchitectureTypeList.to_query v.supported_architectures)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.sustained_clock_speed_in_ghz
              (fun f -> ("sustained_clock_speed_in_ghz", (Double.to_json f)));
           Some
             ("supported_architectures",
               (ArchitectureTypeList.to_json v.supported_architectures))])
    let parse xml =
      Some
        {
          supported_architectures =
            (Util.of_option []
               (Util.option_bind (Xml.member "supportedArchitectures" xml)
                  ArchitectureTypeList.parse));
          sustained_clock_speed_in_ghz =
            (Util.option_bind (Xml.member "sustainedClockSpeedInGhz" xml)
               Double.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "supportedArchitectures"
                       ([], (ArchitectureTypeList.to_xml [x]))))
               v.supported_architectures))
           @
           [Util.option_map v.sustained_clock_speed_in_ghz
              (fun f ->
                 Ezxmlm.make_tag "sustainedClockSpeedInGhz"
                   ([], (Double.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the processor used by the instance type.</p>"]
module RootDeviceTypeList =
  struct
    type t = RootDeviceType.t list
    let make elems () = elems
    let to_query v = Query.to_query_list RootDeviceType.to_query v
    let to_headers v = Headers.to_headers_list RootDeviceType.to_headers v
    let to_json v = `List (List.map RootDeviceType.to_json v)
    let parse xml =
      Util.option_all
        (List.map RootDeviceType.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (RootDeviceType.to_xml x))) v
  end
module UsageClassTypeList =
  struct
    type t = UsageClassType.t list
    let make elems () = elems
    let to_query v = Query.to_query_list UsageClassType.to_query v
    let to_headers v = Headers.to_headers_list UsageClassType.to_headers v
    let to_json v = `List (List.map UsageClassType.to_json v)
    let parse xml =
      Util.option_all
        (List.map UsageClassType.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (UsageClassType.to_xml x))) v
  end
module VCpuInfo =
  struct
    type t =
      {
      default_v_cpus: Integer.t option
        [@ocaml.doc
          "<p>The default number of vCPUs for the instance type.</p>"];
      default_cores: Integer.t option
        [@ocaml.doc
          "<p>The default number of cores for the instance type.</p>"];
      default_threads_per_core: Integer.t option
        [@ocaml.doc
          "<p>The default number of threads per core for the instance type.</p>"];
      valid_cores: CoreCountList.t
        [@ocaml.doc
          "<p>List of the valid number of cores that can be configured for the instance type.</p>"];
      valid_threads_per_core: ThreadsPerCoreList.t
        [@ocaml.doc
          "<p>List of the valid number of threads per core that can be configured for the instance type. </p>"]}
    [@@ocaml.doc
      "<p>Describes the vCPU configurations for the instance type.</p>"]
    let make ?default_v_cpus  ?default_cores  ?default_threads_per_core 
      ?(valid_cores= [])  ?(valid_threads_per_core= [])  () =
      {
        default_v_cpus;
        default_cores;
        default_threads_per_core;
        valid_cores;
        valid_threads_per_core
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ValidThreadsPerCore",
                   (ThreadsPerCoreList.to_query v.valid_threads_per_core)));
           Some
             (Query.Pair
                ("ValidCores", (CoreCountList.to_query v.valid_cores)));
           Util.option_map v.default_threads_per_core
             (fun f ->
                Query.Pair ("DefaultThreadsPerCore", (Integer.to_query f)));
           Util.option_map v.default_cores
             (fun f -> Query.Pair ("DefaultCores", (Integer.to_query f)));
           Util.option_map v.default_v_cpus
             (fun f -> Query.Pair ("DefaultVCpus", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("valid_threads_per_core",
                (ThreadsPerCoreList.to_json v.valid_threads_per_core));
           Some ("valid_cores", (CoreCountList.to_json v.valid_cores));
           Util.option_map v.default_threads_per_core
             (fun f -> ("default_threads_per_core", (Integer.to_json f)));
           Util.option_map v.default_cores
             (fun f -> ("default_cores", (Integer.to_json f)));
           Util.option_map v.default_v_cpus
             (fun f -> ("default_v_cpus", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          default_v_cpus =
            (Util.option_bind (Xml.member "defaultVCpus" xml) Integer.parse);
          default_cores =
            (Util.option_bind (Xml.member "defaultCores" xml) Integer.parse);
          default_threads_per_core =
            (Util.option_bind (Xml.member "defaultThreadsPerCore" xml)
               Integer.parse);
          valid_cores =
            (Util.of_option []
               (Util.option_bind (Xml.member "validCores" xml)
                  CoreCountList.parse));
          valid_threads_per_core =
            (Util.of_option []
               (Util.option_bind (Xml.member "validThreadsPerCore" xml)
                  ThreadsPerCoreList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.default_v_cpus
                  (fun f ->
                     Ezxmlm.make_tag "defaultVCpus" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.default_cores
                 (fun f ->
                    Ezxmlm.make_tag "defaultCores" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.default_threads_per_core
                (fun f ->
                   Ezxmlm.make_tag "defaultThreadsPerCore"
                     ([], (Integer.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "validCores"
                       ([], (CoreCountList.to_xml [x])))) v.valid_cores))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "validThreadsPerCore"
                      ([], (ThreadsPerCoreList.to_xml [x]))))
              v.valid_threads_per_core))
  end[@@ocaml.doc
       "<p>Describes the vCPU configurations for the instance type.</p>"]
module ClientVpnRouteStatus =
  struct
    type t =
      {
      code: ClientVpnRouteStatusCode.t option
        [@ocaml.doc "<p>The state of the Client VPN endpoint route.</p>"];
      message: String.t option
        [@ocaml.doc
          "<p>A message about the status of the Client VPN endpoint route, if applicable.</p>"]}
    [@@ocaml.doc
      "<p>Describes the state of a Client VPN endpoint route.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair ("Code", (ClientVpnRouteStatusCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (ClientVpnRouteStatusCode.to_json f)))])
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               ClientVpnRouteStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (ClientVpnRouteStatusCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the state of a Client VPN endpoint route.</p>"]
module VgwTelemetryList =
  struct
    type t = VgwTelemetry.t list
    let make elems () = elems
    let to_query v = Query.to_query_list VgwTelemetry.to_query v
    let to_headers v = Headers.to_headers_list VgwTelemetry.to_headers v
    let to_json v = `List (List.map VgwTelemetry.to_json v)
    let parse xml =
      Util.option_all (List.map VgwTelemetry.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VgwTelemetry.to_xml x))) v
  end
module VpnConnectionOptions =
  struct
    type t =
      {
      enable_acceleration: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether acceleration is enabled for the VPN connection.</p>"];
      static_routes_only: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP.</p>"];
      tunnel_options: TunnelOptionsList.t
        [@ocaml.doc "<p>Indicates the VPN tunnel options.</p>"]}[@@ocaml.doc
                                                                  "<p>Describes VPN connection options.</p>"]
    let make ?enable_acceleration  ?static_routes_only  ?(tunnel_options= [])
       () = { enable_acceleration; static_routes_only; tunnel_options }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TunnelOptionSet",
                   (TunnelOptionsList.to_query v.tunnel_options)));
           Util.option_map v.static_routes_only
             (fun f -> Query.Pair ("StaticRoutesOnly", (Boolean.to_query f)));
           Util.option_map v.enable_acceleration
             (fun f ->
                Query.Pair ("EnableAcceleration", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tunnel_options",
                (TunnelOptionsList.to_json v.tunnel_options));
           Util.option_map v.static_routes_only
             (fun f -> ("static_routes_only", (Boolean.to_json f)));
           Util.option_map v.enable_acceleration
             (fun f -> ("enable_acceleration", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          enable_acceleration =
            (Util.option_bind (Xml.member "enableAcceleration" xml)
               Boolean.parse);
          static_routes_only =
            (Util.option_bind (Xml.member "staticRoutesOnly" xml)
               Boolean.parse);
          tunnel_options =
            (Util.of_option []
               (Util.option_bind (Xml.member "tunnelOptionSet" xml)
                  TunnelOptionsList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.enable_acceleration
                (fun f ->
                   Ezxmlm.make_tag "enableAcceleration"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.static_routes_only
               (fun f ->
                  Ezxmlm.make_tag "staticRoutesOnly" ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "tunnelOptionSet"
                      ([], (TunnelOptionsList.to_xml [x])))) v.tunnel_options))
  end[@@ocaml.doc "<p>Describes VPN connection options.</p>"]
module VpnStaticRouteList =
  struct
    type t = VpnStaticRoute.t list
    let make elems () = elems
    let to_query v = Query.to_query_list VpnStaticRoute.to_query v
    let to_headers v = Headers.to_headers_list VpnStaticRoute.to_headers v
    let to_json v = `List (List.map VpnStaticRoute.to_json v)
    let parse xml =
      Util.option_all
        (List.map VpnStaticRoute.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VpnStaticRoute.to_xml x))) v
  end
module AssociationStatus =
  struct
    type t =
      {
      code: AssociationStatusCode.t option
        [@ocaml.doc "<p>The state of the target network association.</p>"];
      message: String.t option
        [@ocaml.doc
          "<p>A message about the status of the target network association, if applicable.</p>"]}
    [@@ocaml.doc
      "<p>Describes the state of a target network association.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair ("Code", (AssociationStatusCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (AssociationStatusCode.to_json f)))])
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               AssociationStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (AssociationStatusCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the state of a target network association.</p>"]
module VpcPeeringConnectionStateReason =
  struct
    type t =
      {
      code: VpcPeeringConnectionStateReasonCode.t option
        [@ocaml.doc "<p>The status of the VPC peering connection.</p>"];
      message: String.t option
        [@ocaml.doc
          "<p>A message that provides more information about the status, if applicable.</p>"]}
    [@@ocaml.doc "<p>Describes the status of a VPC peering connection.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code", (VpcPeeringConnectionStateReasonCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code", (VpcPeeringConnectionStateReasonCode.to_json f)))])
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               VpcPeeringConnectionStateReasonCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (VpcPeeringConnectionStateReasonCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the status of a VPC peering connection.</p>"]
module VpcPeeringConnectionVpcInfo =
  struct
    type t =
      {
      cidr_block: String.t option
        [@ocaml.doc "<p>The IPv4 CIDR block for the VPC.</p>"];
      ipv6_cidr_block_set: Ipv6CidrBlockSet.t
        [@ocaml.doc "<p>The IPv6 CIDR block for the VPC.</p>"];
      cidr_block_set: CidrBlockSet.t
        [@ocaml.doc
          "<p>Information about the IPv4 CIDR blocks for the VPC.</p>"];
      owner_id: String.t option
        [@ocaml.doc "<p>The AWS account ID of the VPC owner.</p>"];
      peering_options: VpcPeeringConnectionOptionsDescription.t option
        [@ocaml.doc
          "<p>Information about the VPC peering connection options for the accepter or requester VPC.</p>"];
      vpc_id: String.t option [@ocaml.doc "<p>The ID of the VPC.</p>"];
      region: String.t option
        [@ocaml.doc "<p>The Region in which the VPC is located.</p>"]}
    [@@ocaml.doc "<p>Describes a VPC in a VPC peering connection.</p>"]
    let make ?cidr_block  ?(ipv6_cidr_block_set= [])  ?(cidr_block_set= []) 
      ?owner_id  ?peering_options  ?vpc_id  ?region  () =
      {
        cidr_block;
        ipv6_cidr_block_set;
        cidr_block_set;
        owner_id;
        peering_options;
        vpc_id;
        region
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.region
              (fun f -> Query.Pair ("Region", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.peering_options
             (fun f ->
                Query.Pair
                  ("PeeringOptions",
                    (VpcPeeringConnectionOptionsDescription.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Some
             (Query.Pair
                ("CidrBlockSet", (CidrBlockSet.to_query v.cidr_block_set)));
           Some
             (Query.Pair
                ("Ipv6CidrBlockSet",
                  (Ipv6CidrBlockSet.to_query v.ipv6_cidr_block_set)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.region
              (fun f -> ("region", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.peering_options
             (fun f ->
                ("peering_options",
                  (VpcPeeringConnectionOptionsDescription.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Some ("cidr_block_set", (CidrBlockSet.to_json v.cidr_block_set));
           Some
             ("ipv6_cidr_block_set",
               (Ipv6CidrBlockSet.to_json v.ipv6_cidr_block_set));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)))])
    let parse xml =
      Some
        {
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse);
          ipv6_cidr_block_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6CidrBlockSet" xml)
                  Ipv6CidrBlockSet.parse));
          cidr_block_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "cidrBlockSet" xml)
                  CidrBlockSet.parse));
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          peering_options =
            (Util.option_bind (Xml.member "peeringOptions" xml)
               VpcPeeringConnectionOptionsDescription.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          region = (Util.option_bind (Xml.member "region" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.cidr_block
                    (fun f ->
                       Ezxmlm.make_tag "cidrBlock" ([], (String.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "ipv6CidrBlockSet"
                           ([], (Ipv6CidrBlockSet.to_xml [x]))))
                   v.ipv6_cidr_block_set))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "cidrBlockSet"
                          ([], (CidrBlockSet.to_xml [x])))) v.cidr_block_set))
              @
              [Util.option_map v.owner_id
                 (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.peering_options
                (fun f ->
                   Ezxmlm.make_tag "peeringOptions"
                     ([], (VpcPeeringConnectionOptionsDescription.to_xml f)))])
            @
            [Util.option_map v.vpc_id
               (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.region
              (fun f -> Ezxmlm.make_tag "region" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a VPC in a VPC peering connection.</p>"]
module NetworkAclAssociationList =
  struct
    type t = NetworkAclAssociation.t list
    let make elems () = elems
    let to_query v = Query.to_query_list NetworkAclAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list NetworkAclAssociation.to_headers v
    let to_json v = `List (List.map NetworkAclAssociation.to_json v)
    let parse xml =
      Util.option_all
        (List.map NetworkAclAssociation.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (NetworkAclAssociation.to_xml x))) v
  end
module NetworkAclEntryList =
  struct
    type t = NetworkAclEntry.t list
    let make elems () = elems
    let to_query v = Query.to_query_list NetworkAclEntry.to_query v
    let to_headers v = Headers.to_headers_list NetworkAclEntry.to_headers v
    let to_json v = `List (List.map NetworkAclEntry.to_json v)
    let parse xml =
      Util.option_all
        (List.map NetworkAclEntry.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (NetworkAclEntry.to_xml x)))
        v
  end
module CancelSpotFleetRequestsError =
  struct
    type t =
      {
      code: CancelBatchErrorCode.t option
        [@ocaml.doc "<p>The error code.</p>"];
      message: String.t option
        [@ocaml.doc "<p>The description for the error code.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes a Spot Fleet error.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (CancelBatchErrorCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (CancelBatchErrorCode.to_json f)))])
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               CancelBatchErrorCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (CancelBatchErrorCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a Spot Fleet error.</p>"]
module BatchState =
  struct
    type t =
      | Submitted 
      | Active 
      | Cancelled 
      | Failed 
      | Cancelled_running 
      | Cancelled_terminating 
      | Modifying 
    let str_to_t =
      [("modifying", Modifying);
      ("cancelled_terminating", Cancelled_terminating);
      ("cancelled_running", Cancelled_running);
      ("failed", Failed);
      ("cancelled", Cancelled);
      ("active", Active);
      ("submitted", Submitted)]
    let t_to_str =
      [(Modifying, "modifying");
      (Cancelled_terminating, "cancelled_terminating");
      (Cancelled_running, "cancelled_running");
      (Failed, "failed");
      (Cancelled, "cancelled");
      (Active, "active");
      (Submitted, "submitted")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module AccountAttributeValueList =
  struct
    type t = AccountAttributeValue.t list
    let make elems () = elems
    let to_query v = Query.to_query_list AccountAttributeValue.to_query v
    let to_headers v =
      Headers.to_headers_list AccountAttributeValue.to_headers v
    let to_json v = `List (List.map AccountAttributeValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map AccountAttributeValue.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (AccountAttributeValue.to_xml x))) v
  end
module DiskImageDetail =
  struct
    type t =
      {
      bytes: Long.t [@ocaml.doc "<p>The size of the disk image, in GiB.</p>"];
      format: DiskImageFormat.t [@ocaml.doc "<p>The disk image format.</p>"];
      import_manifest_url: String.t
        [@ocaml.doc
          "<p>A presigned URL for the import manifest stored in Amazon S3 and presented here as an Amazon S3 presigned URL. For information about creating a presigned URL for an Amazon S3 object, read the \"Query String Request Authentication Alternative\" section of the <a href=\"https://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html\">Authenticating REST Requests</a> topic in the <i>Amazon Simple Storage Service Developer Guide</i>.</p> <p>For information about the import manifest referenced by this API action, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/manifest.html\">VM Import Manifest</a>.</p>"]}
    [@@ocaml.doc "<p>Describes a disk image.</p>"]
    let make ~bytes  ~format  ~import_manifest_url  () =
      { bytes; format; import_manifest_url }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ImportManifestUrl",
                   (String.to_query v.import_manifest_url)));
           Some (Query.Pair ("Format", (DiskImageFormat.to_query v.format)));
           Some (Query.Pair ("Bytes", (Long.to_query v.bytes)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("import_manifest_url", (String.to_json v.import_manifest_url));
           Some ("format", (DiskImageFormat.to_json v.format));
           Some ("bytes", (Long.to_json v.bytes))])
    let parse xml =
      Some
        {
          bytes =
            (Xml.required "bytes"
               (Util.option_bind (Xml.member "bytes" xml) Long.parse));
          format =
            (Xml.required "format"
               (Util.option_bind (Xml.member "format" xml)
                  DiskImageFormat.parse));
          import_manifest_url =
            (Xml.required "importManifestUrl"
               (Util.option_bind (Xml.member "importManifestUrl" xml)
                  String.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @ [Some (Ezxmlm.make_tag "bytes" ([], (Long.to_xml v.bytes)))])
            @
            [Some
               (Ezxmlm.make_tag "format"
                  ([], (DiskImageFormat.to_xml v.format)))])
           @
           [Some
              (Ezxmlm.make_tag "importManifestUrl"
                 ([], (String.to_xml v.import_manifest_url)))])
  end[@@ocaml.doc "<p>Describes a disk image.</p>"]
module VolumeDetail =
  struct
    type t =
      {
      size: Long.t [@ocaml.doc "<p>The size of the volume, in GiB.</p>"]}
    [@@ocaml.doc "<p>Describes an EBS volume.</p>"]
    let make ~size  () = { size }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Size", (Long.to_query v.size)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc (Util.list_filter_opt [Some ("size", (Long.to_json v.size))])
    let parse xml =
      Some
        {
          size =
            (Xml.required "size"
               (Util.option_bind (Xml.member "size" xml) Long.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @ [Some (Ezxmlm.make_tag "size" ([], (Long.to_xml v.size)))])
  end[@@ocaml.doc "<p>Describes an EBS volume.</p>"]
module GroupIdentifierSet =
  struct
    type t = SecurityGroupIdentifier.t list
    let make elems () = elems
    let to_query v = Query.to_query_list SecurityGroupIdentifier.to_query v
    let to_headers v =
      Headers.to_headers_list SecurityGroupIdentifier.to_headers v
    let to_json v = `List (List.map SecurityGroupIdentifier.to_json v)
    let parse xml =
      Util.option_all
        (List.map SecurityGroupIdentifier.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (SecurityGroupIdentifier.to_xml x)))
        v
  end
module VpcEndpointType =
  struct
    type t =
      | Interface 
      | Gateway 
    let str_to_t = [("Gateway", Gateway); ("Interface", Interface)]
    let t_to_str = [(Gateway, "Gateway"); (Interface, "Interface")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module TransitGatewayAttachmentAssociation =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t option
        [@ocaml.doc
          "<p>The ID of the route table for the transit gateway.</p>"];
      state: TransitGatewayAssociationState.t option
        [@ocaml.doc "<p>The state of the association.</p>"]}[@@ocaml.doc
                                                              "<p>Describes an association.</p>"]
    let make ?transit_gateway_route_table_id  ?state  () =
      { transit_gateway_route_table_id; state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayAssociationState.to_query f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayRouteTableId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayAssociationState.to_json f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f -> ("transit_gateway_route_table_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Util.option_bind (Xml.member "transitGatewayRouteTableId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAssociationState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.transit_gateway_route_table_id
               (fun f ->
                  Ezxmlm.make_tag "transitGatewayRouteTableId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (TransitGatewayAssociationState.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an association.</p>"]
module TransitGatewayAttachmentState =
  struct
    type t =
      | Initiating 
      | PendingAcceptance 
      | RollingBack 
      | Pending 
      | Available 
      | Modifying 
      | Deleting 
      | Deleted 
      | Failed 
      | Rejected 
      | Rejecting 
      | Failing 
    let str_to_t =
      [("failing", Failing);
      ("rejecting", Rejecting);
      ("rejected", Rejected);
      ("failed", Failed);
      ("deleted", Deleted);
      ("deleting", Deleting);
      ("modifying", Modifying);
      ("available", Available);
      ("pending", Pending);
      ("rollingBack", RollingBack);
      ("pendingAcceptance", PendingAcceptance);
      ("initiating", Initiating)]
    let t_to_str =
      [(Failing, "failing");
      (Rejecting, "rejecting");
      (Rejected, "rejected");
      (Failed, "failed");
      (Deleted, "deleted");
      (Deleting, "deleting");
      (Modifying, "modifying");
      (Available, "available");
      (Pending, "pending");
      (RollingBack, "rollingBack");
      (PendingAcceptance, "pendingAcceptance");
      (Initiating, "initiating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module SnapshotState =
  struct
    type t =
      | Pending 
      | Completed 
      | Error 
    let str_to_t =
      [("error", Error); ("completed", Completed); ("pending", Pending)]
    let t_to_str =
      [(Error, "error"); (Completed, "completed"); (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module TrafficMirrorTargetType =
  struct
    type t =
      | Network_interface 
      | Network_load_balancer 
    let str_to_t =
      [("network-load-balancer", Network_load_balancer);
      ("network-interface", Network_interface)]
    let t_to_str =
      [(Network_load_balancer, "network-load-balancer");
      (Network_interface, "network-interface")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module VolumeModificationState =
  struct
    type t =
      | Modifying 
      | Optimizing 
      | Completed 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("completed", Completed);
      ("optimizing", Optimizing);
      ("modifying", Modifying)]
    let t_to_str =
      [(Failed, "failed");
      (Completed, "completed");
      (Optimizing, "optimizing");
      (Modifying, "modifying")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module NetworkInterfaceAttachment =
  struct
    type t =
      {
      attach_time: DateTime.t option
        [@ocaml.doc
          "<p>The timestamp indicating when the attachment initiated.</p>"];
      attachment_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface attachment.</p>"];
      delete_on_termination: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the network interface is deleted when the instance is terminated.</p>"];
      device_index: Integer.t option
        [@ocaml.doc
          "<p>The device index of the network interface attachment on the instance.</p>"];
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"];
      instance_owner_id: String.t option
        [@ocaml.doc
          "<p>The AWS account ID of the owner of the instance.</p>"];
      status: AttachmentStatus.t option
        [@ocaml.doc "<p>The attachment state.</p>"]}[@@ocaml.doc
                                                      "<p>Describes a network interface attachment.</p>"]
    let make ?attach_time  ?attachment_id  ?delete_on_termination 
      ?device_index  ?instance_id  ?instance_owner_id  ?status  () =
      {
        attach_time;
        attachment_id;
        delete_on_termination;
        device_index;
        instance_id;
        instance_owner_id;
        status
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (AttachmentStatus.to_query f)));
           Util.option_map v.instance_owner_id
             (fun f -> Query.Pair ("InstanceOwnerId", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attachment_id
             (fun f -> Query.Pair ("AttachmentId", (String.to_query f)));
           Util.option_map v.attach_time
             (fun f -> Query.Pair ("AttachTime", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (AttachmentStatus.to_json f)));
           Util.option_map v.instance_owner_id
             (fun f -> ("instance_owner_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attachment_id
             (fun f -> ("attachment_id", (String.to_json f)));
           Util.option_map v.attach_time
             (fun f -> ("attach_time", (DateTime.to_json f)))])
    let parse xml =
      Some
        {
          attach_time =
            (Util.option_bind (Xml.member "attachTime" xml) DateTime.parse);
          attachment_id =
            (Util.option_bind (Xml.member "attachmentId" xml) String.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          device_index =
            (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_owner_id =
            (Util.option_bind (Xml.member "instanceOwnerId" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AttachmentStatus.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.attach_time
                    (fun f ->
                       Ezxmlm.make_tag "attachTime" ([], (DateTime.to_xml f)))])
                @
                [Util.option_map v.attachment_id
                   (fun f ->
                      Ezxmlm.make_tag "attachmentId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.delete_on_termination
                  (fun f ->
                     Ezxmlm.make_tag "deleteOnTermination"
                       ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.device_index
                 (fun f ->
                    Ezxmlm.make_tag "deviceIndex" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.instance_id
                (fun f ->
                   Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.instance_owner_id
               (fun f ->
                  Ezxmlm.make_tag "instanceOwnerId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status" ([], (AttachmentStatus.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a network interface attachment.</p>"]
module NetworkInterfaceIpv6AddressesList =
  struct
    type t = NetworkInterfaceIpv6Address.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list NetworkInterfaceIpv6Address.to_query v
    let to_headers v =
      Headers.to_headers_list NetworkInterfaceIpv6Address.to_headers v
    let to_json v = `List (List.map NetworkInterfaceIpv6Address.to_json v)
    let parse xml =
      Util.option_all
        (List.map NetworkInterfaceIpv6Address.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (NetworkInterfaceIpv6Address.to_xml x))) v
  end
module NetworkInterfacePrivateIpAddressList =
  struct
    type t = NetworkInterfacePrivateIpAddress.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list NetworkInterfacePrivateIpAddress.to_query v
    let to_headers v =
      Headers.to_headers_list NetworkInterfacePrivateIpAddress.to_headers v
    let to_json v =
      `List (List.map NetworkInterfacePrivateIpAddress.to_json v)
    let parse xml =
      Util.option_all
        (List.map NetworkInterfacePrivateIpAddress.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (NetworkInterfacePrivateIpAddress.to_xml x))) v
  end
module NetworkInterfaceType =
  struct
    type t =
      | Interface 
      | NatGateway 
      | Efa 
    let str_to_t =
      [("efa", Efa); ("natGateway", NatGateway); ("interface", Interface)]
    let t_to_str =
      [(Efa, "efa"); (NatGateway, "natGateway"); (Interface, "interface")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ConnectionNotificationState =
  struct
    type t =
      | Enabled 
      | Disabled 
    let str_to_t = [("Disabled", Disabled); ("Enabled", Enabled)]
    let t_to_str = [(Disabled, "Disabled"); (Enabled, "Enabled")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ConnectionNotificationType =
  struct
    type t =
      | Topic 
    let str_to_t = [("Topic", Topic)]
    let t_to_str = [(Topic, "Topic")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module OfferingClassType =
  struct
    type t =
      | Standard 
      | Convertible 
    let str_to_t = [("convertible", Convertible); ("standard", Standard)]
    let t_to_str = [(Convertible, "convertible"); (Standard, "standard")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module OfferingTypeValues =
  struct
    type t =
      | Heavy_Utilization 
      | Medium_Utilization 
      | Light_Utilization 
      | No_Upfront 
      | Partial_Upfront 
      | All_Upfront 
    let str_to_t =
      [("All Upfront", All_Upfront);
      ("Partial Upfront", Partial_Upfront);
      ("No Upfront", No_Upfront);
      ("Light Utilization", Light_Utilization);
      ("Medium Utilization", Medium_Utilization);
      ("Heavy Utilization", Heavy_Utilization)]
    let t_to_str =
      [(All_Upfront, "All Upfront");
      (Partial_Upfront, "Partial Upfront");
      (No_Upfront, "No Upfront");
      (Light_Utilization, "Light Utilization");
      (Medium_Utilization, "Medium Utilization");
      (Heavy_Utilization, "Heavy Utilization")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module RIProductDescription =
  struct
    type t =
      | Linux_UNIX 
      | Linux_UNIX__Amazon_VPC_ 
      | Windows 
      | Windows__Amazon_VPC_ 
    let str_to_t =
      [("Windows (Amazon VPC)", Windows__Amazon_VPC_);
      ("Windows", Windows);
      ("Linux/UNIX (Amazon VPC)", Linux_UNIX__Amazon_VPC_);
      ("Linux/UNIX", Linux_UNIX)]
    let t_to_str =
      [(Windows__Amazon_VPC_, "Windows (Amazon VPC)");
      (Windows, "Windows");
      (Linux_UNIX__Amazon_VPC_, "Linux/UNIX (Amazon VPC)");
      (Linux_UNIX, "Linux/UNIX")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module RecurringChargesList =
  struct
    type t = RecurringCharge.t list
    let make elems () = elems
    let to_query v = Query.to_query_list RecurringCharge.to_query v
    let to_headers v = Headers.to_headers_list RecurringCharge.to_headers v
    let to_json v = `List (List.map RecurringCharge.to_json v)
    let parse xml =
      Util.option_all
        (List.map RecurringCharge.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (RecurringCharge.to_xml x)))
        v
  end
module ReservedInstanceState =
  struct
    type t =
      | Payment_pending 
      | Active 
      | Payment_failed 
      | Retired 
      | Queued 
      | Queued_deleted 
    let str_to_t =
      [("queued-deleted", Queued_deleted);
      ("queued", Queued);
      ("retired", Retired);
      ("payment-failed", Payment_failed);
      ("active", Active);
      ("payment-pending", Payment_pending)]
    let t_to_str =
      [(Queued_deleted, "queued-deleted");
      (Queued, "queued");
      (Retired, "retired");
      (Payment_failed, "payment-failed");
      (Active, "active");
      (Payment_pending, "payment-pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module PeeringAttachmentStatus =
  struct
    type t =
      {
      code: String.t option [@ocaml.doc "<p>The status code.</p>"];
      message: String.t option
        [@ocaml.doc "<p>The status message, if applicable.</p>"]}[@@ocaml.doc
                                                                   "<p>The status of the transit gateway peering attachment.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>The status of the transit gateway peering attachment.</p>"]
module PeeringTgwInfo =
  struct
    type t =
      {
      transit_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway.</p>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The AWS account ID of the owner of the transit gateway.</p>"];
      region: String.t option
        [@ocaml.doc "<p>The Region of the transit gateway.</p>"]}[@@ocaml.doc
                                                                   "<p>Information about the transit gateway in the peering attachment.</p>"]
    let make ?transit_gateway_id  ?owner_id  ?region  () =
      { transit_gateway_id; owner_id; region }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.region
              (fun f -> Query.Pair ("Region", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.region
              (fun f -> ("region", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          region = (Util.option_bind (Xml.member "region" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.transit_gateway_id
                (fun f ->
                   Ezxmlm.make_tag "transitGatewayId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.owner_id
               (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.region
              (fun f -> Ezxmlm.make_tag "region" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Information about the transit gateway in the peering attachment.</p>"]
module CancelSpotInstanceRequestState =
  struct
    type t =
      | Active 
      | Open 
      | Closed 
      | Cancelled 
      | Completed 
    let str_to_t =
      [("completed", Completed);
      ("cancelled", Cancelled);
      ("closed", Closed);
      ("open", Open);
      ("active", Active)]
    let t_to_str =
      [(Completed, "completed");
      (Cancelled, "cancelled");
      (Closed, "closed");
      (Open, "open");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ServiceState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
      | Failed 
    let str_to_t =
      [("Failed", Failed);
      ("Deleted", Deleted);
      ("Deleting", Deleting);
      ("Available", Available);
      ("Pending", Pending)]
    let t_to_str =
      [(Failed, "Failed");
      (Deleted, "Deleted");
      (Deleting, "Deleting");
      (Available, "Available");
      (Pending, "Pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ServiceTypeDetailSet =
  struct
    type t = ServiceTypeDetail.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ServiceTypeDetail.to_query v
    let to_headers v = Headers.to_headers_list ServiceTypeDetail.to_headers v
    let to_json v = `List (List.map ServiceTypeDetail.to_json v)
    let parse xml =
      Util.option_all
        (List.map ServiceTypeDetail.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ServiceTypeDetail.to_xml x)))
        v
  end
module ConversionTaskState =
  struct
    type t =
      | Active 
      | Cancelling 
      | Cancelled 
      | Completed 
    let str_to_t =
      [("completed", Completed);
      ("cancelled", Cancelled);
      ("cancelling", Cancelling);
      ("active", Active)]
    let t_to_str =
      [(Completed, "completed");
      (Cancelled, "cancelled");
      (Cancelling, "cancelling");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ImportInstanceTaskDetails =
  struct
    type t =
      {
      description: String.t option
        [@ocaml.doc "<p>A description of the task.</p>"];
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"];
      platform: PlatformValues.t option
        [@ocaml.doc "<p>The instance operating system.</p>"];
      volumes: ImportInstanceVolumeDetailSet.t
        [@ocaml.doc "<p>The volumes.</p>"]}[@@ocaml.doc
                                             "<p>Describes an import instance task.</p>"]
    let make ?description  ?instance_id  ?platform  ?(volumes= [])  () =
      { description; instance_id; platform; volumes }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Volumes",
                   (ImportInstanceVolumeDetailSet.to_query v.volumes)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("volumes", (ImportInstanceVolumeDetailSet.to_json v.volumes));
           Util.option_map v.platform
             (fun f -> ("platform", (PlatformValues.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse);
          volumes =
            (Util.of_option []
               (Util.option_bind (Xml.member "volumes" xml)
                  ImportInstanceVolumeDetailSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
             @
             [Util.option_map v.instance_id
                (fun f ->
                   Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.platform
               (fun f ->
                  Ezxmlm.make_tag "platform" ([], (PlatformValues.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "volumes"
                      ([], (ImportInstanceVolumeDetailSet.to_xml [x]))))
              v.volumes))
  end[@@ocaml.doc "<p>Describes an import instance task.</p>"]
module ImportVolumeTaskDetails =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc
          "<p>The Availability Zone where the resulting volume will reside.</p>"];
      bytes_converted: Long.t option
        [@ocaml.doc "<p>The number of bytes converted so far.</p>"];
      description: String.t option
        [@ocaml.doc
          "<p>The description you provided when starting the import volume task.</p>"];
      image: DiskImageDescription.t option [@ocaml.doc "<p>The image.</p>"];
      volume: DiskImageVolumeDescription.t option
        [@ocaml.doc "<p>The volume.</p>"]}[@@ocaml.doc
                                            "<p>Describes an import volume task.</p>"]
    let make ?availability_zone  ?bytes_converted  ?description  ?image 
      ?volume  () =
      { availability_zone; bytes_converted; description; image; volume }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f ->
                 Query.Pair
                   ("Volume", (DiskImageVolumeDescription.to_query f)));
           Util.option_map v.image
             (fun f ->
                Query.Pair ("Image", (DiskImageDescription.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.bytes_converted
             (fun f -> Query.Pair ("BytesConverted", (Long.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f -> ("volume", (DiskImageVolumeDescription.to_json f)));
           Util.option_map v.image
             (fun f -> ("image", (DiskImageDescription.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.bytes_converted
             (fun f -> ("bytes_converted", (Long.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          bytes_converted =
            (Util.option_bind (Xml.member "bytesConverted" xml) Long.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          image =
            (Util.option_bind (Xml.member "image" xml)
               DiskImageDescription.parse);
          volume =
            (Util.option_bind (Xml.member "volume" xml)
               DiskImageVolumeDescription.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.availability_zone
                  (fun f ->
                     Ezxmlm.make_tag "availabilityZone"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.bytes_converted
                 (fun f ->
                    Ezxmlm.make_tag "bytesConverted" ([], (Long.to_xml f)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
            @
            [Util.option_map v.image
               (fun f ->
                  Ezxmlm.make_tag "image"
                    ([], (DiskImageDescription.to_xml f)))])
           @
           [Util.option_map v.volume
              (fun f ->
                 Ezxmlm.make_tag "volume"
                   ([], (DiskImageVolumeDescription.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an import volume task.</p>"]
module TransitGatewayVpcAttachmentOptions =
  struct
    type t =
      {
      dns_support: DnsSupportValue.t option
        [@ocaml.doc "<p>Indicates whether DNS support is enabled.</p>"];
      ipv6_support: Ipv6SupportValue.t option
        [@ocaml.doc "<p>Indicates whether IPv6 support is enabled.</p>"]}
    [@@ocaml.doc "<p>Describes the VPC attachment options.</p>"]
    let make ?dns_support  ?ipv6_support  () = { dns_support; ipv6_support }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_support
              (fun f ->
                 Query.Pair ("Ipv6Support", (Ipv6SupportValue.to_query f)));
           Util.option_map v.dns_support
             (fun f ->
                Query.Pair ("DnsSupport", (DnsSupportValue.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_support
              (fun f -> ("ipv6_support", (Ipv6SupportValue.to_json f)));
           Util.option_map v.dns_support
             (fun f -> ("dns_support", (DnsSupportValue.to_json f)))])
    let parse xml =
      Some
        {
          dns_support =
            (Util.option_bind (Xml.member "dnsSupport" xml)
               DnsSupportValue.parse);
          ipv6_support =
            (Util.option_bind (Xml.member "ipv6Support" xml)
               Ipv6SupportValue.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dns_support
               (fun f ->
                  Ezxmlm.make_tag "dnsSupport"
                    ([], (DnsSupportValue.to_xml f)))])
           @
           [Util.option_map v.ipv6_support
              (fun f ->
                 Ezxmlm.make_tag "ipv6Support"
                   ([], (Ipv6SupportValue.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the VPC attachment options.</p>"]
module ReservationValue =
  struct
    type t =
      {
      hourly_price: String.t option
        [@ocaml.doc "<p>The hourly rate of the reservation.</p>"];
      remaining_total_value: String.t option
        [@ocaml.doc
          "<p>The balance of the total value (the sum of remainingUpfrontValue + hourlyPrice * number of hours remaining).</p>"];
      remaining_upfront_value: String.t option
        [@ocaml.doc "<p>The remaining upfront cost of the reservation.</p>"]}
    [@@ocaml.doc "<p>The cost associated with the Reserved Instance.</p>"]
    let make ?hourly_price  ?remaining_total_value  ?remaining_upfront_value 
      () = { hourly_price; remaining_total_value; remaining_upfront_value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.remaining_upfront_value
              (fun f ->
                 Query.Pair ("RemainingUpfrontValue", (String.to_query f)));
           Util.option_map v.remaining_total_value
             (fun f ->
                Query.Pair ("RemainingTotalValue", (String.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.remaining_upfront_value
              (fun f -> ("remaining_upfront_value", (String.to_json f)));
           Util.option_map v.remaining_total_value
             (fun f -> ("remaining_total_value", (String.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)))])
    let parse xml =
      Some
        {
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          remaining_total_value =
            (Util.option_bind (Xml.member "remainingTotalValue" xml)
               String.parse);
          remaining_upfront_value =
            (Util.option_bind (Xml.member "remainingUpfrontValue" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.hourly_price
                (fun f ->
                   Ezxmlm.make_tag "hourlyPrice" ([], (String.to_xml f)))])
            @
            [Util.option_map v.remaining_total_value
               (fun f ->
                  Ezxmlm.make_tag "remainingTotalValue"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.remaining_upfront_value
              (fun f ->
                 Ezxmlm.make_tag "remainingUpfrontValue"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>The cost associated with the Reserved Instance.</p>"]
module TargetConfiguration =
  struct
    type t =
      {
      instance_count: Integer.t option
        [@ocaml.doc
          "<p>The number of instances the Convertible Reserved Instance offering can be applied to. This parameter is reserved and cannot be specified in a request</p>"];
      offering_id: String.t option
        [@ocaml.doc
          "<p>The ID of the Convertible Reserved Instance offering.</p>"]}
    [@@ocaml.doc
      "<p>Information about the Convertible Reserved Instance offering.</p>"]
    let make ?instance_count  ?offering_id  () =
      { instance_count; offering_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.offering_id
              (fun f -> Query.Pair ("OfferingId", (String.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.offering_id
              (fun f -> ("offering_id", (String.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          offering_id =
            (Util.option_bind (Xml.member "offeringId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_count
               (fun f ->
                  Ezxmlm.make_tag "instanceCount" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.offering_id
              (fun f -> Ezxmlm.make_tag "offeringId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Information about the Convertible Reserved Instance offering.</p>"]
module TransitGatewayRouteAttachmentList =
  struct
    type t = TransitGatewayRouteAttachment.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list TransitGatewayRouteAttachment.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayRouteAttachment.to_headers v
    let to_json v = `List (List.map TransitGatewayRouteAttachment.to_json v)
    let parse xml =
      Util.option_all
        (List.map TransitGatewayRouteAttachment.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayRouteAttachment.to_xml x))) v
  end
module TransitGatewayRouteState =
  struct
    type t =
      | Pending 
      | Active 
      | Blackhole 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("blackhole", Blackhole);
      ("active", Active);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Blackhole, "blackhole");
      (Active, "active");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module TransitGatewayRouteType =
  struct
    type t =
      | Static 
      | Propagated 
    let str_to_t = [("propagated", Propagated); ("static", Static)]
    let t_to_str = [(Propagated, "propagated"); (Static, "static")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module EventType =
  struct
    type t =
      | InstanceChange 
      | FleetRequestChange 
      | Error 
      | Information 
    let str_to_t =
      [("information", Information);
      ("error", Error);
      ("fleetRequestChange", FleetRequestChange);
      ("instanceChange", InstanceChange)]
    let t_to_str =
      [(Information, "information");
      (Error, "error");
      (FleetRequestChange, "fleetRequestChange");
      (InstanceChange, "instanceChange")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module FpgaImageState =
  struct
    type t =
      {
      code: FpgaImageStateCode.t option
        [@ocaml.doc
          "<p>The state. The following are the possible values:</p> <ul> <li> <p> <code>pending</code> - AFI bitstream generation is in progress.</p> </li> <li> <p> <code>available</code> - The AFI is available for use.</p> </li> <li> <p> <code>failed</code> - AFI bitstream generation failed.</p> </li> <li> <p> <code>unavailable</code> - The AFI is no longer available for use.</p> </li> </ul>"];
      message: String.t option
        [@ocaml.doc
          "<p>If the state is <code>failed</code>, this is the error message.</p>"]}
    [@@ocaml.doc
      "<p>Describes the state of the bitstream generation process for an Amazon FPGA image (AFI).</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (FpgaImageStateCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (FpgaImageStateCode.to_json f)))])
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               FpgaImageStateCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code" ([], (FpgaImageStateCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the state of the bitstream generation process for an Amazon FPGA image (AFI).</p>"]
module PciId =
  struct
    type t =
      {
      device_id: String.t option [@ocaml.doc "<p>The ID of the device.</p>"];
      vendor_id: String.t option [@ocaml.doc "<p>The ID of the vendor.</p>"];
      subsystem_id: String.t option
        [@ocaml.doc "<p>The ID of the subsystem.</p>"];
      subsystem_vendor_id: String.t option
        [@ocaml.doc "<p>The ID of the vendor for the subsystem.</p>"]}
    [@@ocaml.doc
      "<p>Describes the data that identifies an Amazon FPGA image (AFI) on the PCI bus.</p>"]
    let make ?device_id  ?vendor_id  ?subsystem_id  ?subsystem_vendor_id  ()
      = { device_id; vendor_id; subsystem_id; subsystem_vendor_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subsystem_vendor_id
              (fun f -> Query.Pair ("SubsystemVendorId", (String.to_query f)));
           Util.option_map v.subsystem_id
             (fun f -> Query.Pair ("SubsystemId", (String.to_query f)));
           Util.option_map v.vendor_id
             (fun f -> Query.Pair ("VendorId", (String.to_query f)));
           Util.option_map v.device_id
             (fun f -> Query.Pair ("DeviceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subsystem_vendor_id
              (fun f -> ("subsystem_vendor_id", (String.to_json f)));
           Util.option_map v.subsystem_id
             (fun f -> ("subsystem_id", (String.to_json f)));
           Util.option_map v.vendor_id
             (fun f -> ("vendor_id", (String.to_json f)));
           Util.option_map v.device_id
             (fun f -> ("device_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          device_id =
            (Util.option_bind (Xml.member "DeviceId" xml) String.parse);
          vendor_id =
            (Util.option_bind (Xml.member "VendorId" xml) String.parse);
          subsystem_id =
            (Util.option_bind (Xml.member "SubsystemId" xml) String.parse);
          subsystem_vendor_id =
            (Util.option_bind (Xml.member "SubsystemVendorId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.device_id
                 (fun f -> Ezxmlm.make_tag "DeviceId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.vendor_id
                (fun f -> Ezxmlm.make_tag "VendorId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.subsystem_id
               (fun f ->
                  Ezxmlm.make_tag "SubsystemId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.subsystem_vendor_id
              (fun f ->
                 Ezxmlm.make_tag "SubsystemVendorId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the data that identifies an Amazon FPGA image (AFI) on the PCI bus.</p>"]
module EnableFastSnapshotRestoreStateErrorSet =
  struct
    type t = EnableFastSnapshotRestoreStateErrorItem.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list EnableFastSnapshotRestoreStateErrorItem.to_query v
    let to_headers v =
      Headers.to_headers_list
        EnableFastSnapshotRestoreStateErrorItem.to_headers v
    let to_json v =
      `List (List.map EnableFastSnapshotRestoreStateErrorItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map EnableFastSnapshotRestoreStateErrorItem.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (EnableFastSnapshotRestoreStateErrorItem.to_xml x))) v
  end
module PropagatingVgwList =
  struct
    type t = PropagatingVgw.t list
    let make elems () = elems
    let to_query v = Query.to_query_list PropagatingVgw.to_query v
    let to_headers v = Headers.to_headers_list PropagatingVgw.to_headers v
    let to_json v = `List (List.map PropagatingVgw.to_json v)
    let parse xml =
      Util.option_all
        (List.map PropagatingVgw.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PropagatingVgw.to_xml x))) v
  end
module RouteList =
  struct
    type t = Route.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Route.to_query v
    let to_headers v = Headers.to_headers_list Route.to_headers v
    let to_json v = `List (List.map Route.to_json v)
    let parse xml =
      Util.option_all (List.map Route.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Route.to_xml x))) v
  end
module RouteTableAssociationList =
  struct
    type t = RouteTableAssociation.t list
    let make elems () = elems
    let to_query v = Query.to_query_list RouteTableAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list RouteTableAssociation.to_headers v
    let to_json v = `List (List.map RouteTableAssociation.to_json v)
    let parse xml =
      Util.option_all
        (List.map RouteTableAssociation.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (RouteTableAssociation.to_xml x))) v
  end
module IamInstanceProfileAssociationState =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
    let str_to_t =
      [("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ResponseLaunchTemplateData =
  struct
    type t =
      {
      kernel_id: String.t option
        [@ocaml.doc "<p>The ID of the kernel, if applicable.</p>"];
      ebs_optimized: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the instance is optimized for Amazon EBS I/O. </p>"];
      iam_instance_profile:
        LaunchTemplateIamInstanceProfileSpecification.t option
        [@ocaml.doc "<p>The IAM instance profile.</p>"];
      block_device_mappings: LaunchTemplateBlockDeviceMappingList.t
        [@ocaml.doc "<p>The block device mappings.</p>"];
      network_interfaces:
        LaunchTemplateInstanceNetworkInterfaceSpecificationList.t
        [@ocaml.doc "<p>The network interfaces.</p>"];
      image_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AMI that was used to launch the instance.</p>"];
      instance_type: InstanceType.t option
        [@ocaml.doc "<p>The instance type.</p>"];
      key_name: String.t option
        [@ocaml.doc "<p>The name of the key pair.</p>"];
      monitoring: LaunchTemplatesMonitoring.t option
        [@ocaml.doc "<p>The monitoring for the instance.</p>"];
      placement: LaunchTemplatePlacement.t option
        [@ocaml.doc "<p>The placement of the instance.</p>"];
      ram_disk_id: String.t option
        [@ocaml.doc "<p>The ID of the RAM disk, if applicable.</p>"];
      disable_api_termination: Boolean.t option
        [@ocaml.doc
          "<p>If set to <code>true</code>, indicates that the instance cannot be terminated using the Amazon EC2 console, command line tool, or API.</p>"];
      instance_initiated_shutdown_behavior: ShutdownBehavior.t option
        [@ocaml.doc
          "<p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p>"];
      user_data: String.t option
        [@ocaml.doc "<p>The user data for the instance. </p>"];
      tag_specifications: LaunchTemplateTagSpecificationList.t
        [@ocaml.doc "<p>The tags.</p>"];
      elastic_gpu_specifications: ElasticGpuSpecificationResponseList.t
        [@ocaml.doc "<p>The elastic GPU specification.</p>"];
      elastic_inference_accelerators:
        LaunchTemplateElasticInferenceAcceleratorResponseList.t
        [@ocaml.doc
          "<p> The elastic inference accelerator for the instance. </p>"];
      security_group_ids: ValueStringList.t
        [@ocaml.doc "<p>The security group IDs.</p>"];
      security_groups: ValueStringList.t
        [@ocaml.doc "<p>The security group names.</p>"];
      instance_market_options: LaunchTemplateInstanceMarketOptions.t option
        [@ocaml.doc
          "<p>The market (purchasing) option for the instances.</p>"];
      credit_specification: CreditSpecification.t option
        [@ocaml.doc
          "<p>The credit option for CPU usage of the instance.</p>"];
      cpu_options: LaunchTemplateCpuOptions.t option
        [@ocaml.doc
          "<p>The CPU options for the instance. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html\">Optimizing CPU Options</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"];
      capacity_reservation_specification:
        LaunchTemplateCapacityReservationSpecificationResponse.t option
        [@ocaml.doc
          "<p>Information about the Capacity Reservation targeting option.</p>"];
      license_specifications: LaunchTemplateLicenseList.t
        [@ocaml.doc "<p>The license configurations.</p>"];
      hibernation_options: LaunchTemplateHibernationOptions.t option
        [@ocaml.doc
          "<p>Indicates whether an instance is configured for hibernation. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html\">Hibernate Your Instance</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"]}
    [@@ocaml.doc "<p>The information for a launch template. </p>"]
    let make ?kernel_id  ?ebs_optimized  ?iam_instance_profile 
      ?(block_device_mappings= [])  ?(network_interfaces= [])  ?image_id 
      ?instance_type  ?key_name  ?monitoring  ?placement  ?ram_disk_id 
      ?disable_api_termination  ?instance_initiated_shutdown_behavior 
      ?user_data  ?(tag_specifications= [])  ?(elastic_gpu_specifications=
      [])  ?(elastic_inference_accelerators= [])  ?(security_group_ids= []) 
      ?(security_groups= [])  ?instance_market_options  ?credit_specification
       ?cpu_options  ?capacity_reservation_specification 
      ?(license_specifications= [])  ?hibernation_options  () =
      {
        kernel_id;
        ebs_optimized;
        iam_instance_profile;
        block_device_mappings;
        network_interfaces;
        image_id;
        instance_type;
        key_name;
        monitoring;
        placement;
        ram_disk_id;
        disable_api_termination;
        instance_initiated_shutdown_behavior;
        user_data;
        tag_specifications;
        elastic_gpu_specifications;
        elastic_inference_accelerators;
        security_group_ids;
        security_groups;
        instance_market_options;
        credit_specification;
        cpu_options;
        capacity_reservation_specification;
        license_specifications;
        hibernation_options
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.hibernation_options
              (fun f ->
                 Query.Pair
                   ("HibernationOptions",
                     (LaunchTemplateHibernationOptions.to_query f)));
           Some
             (Query.Pair
                ("LicenseSet",
                  (LaunchTemplateLicenseList.to_query
                     v.license_specifications)));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                Query.Pair
                  ("CapacityReservationSpecification",
                    (LaunchTemplateCapacityReservationSpecificationResponse.to_query
                       f)));
           Util.option_map v.cpu_options
             (fun f ->
                Query.Pair
                  ("CpuOptions", (LaunchTemplateCpuOptions.to_query f)));
           Util.option_map v.credit_specification
             (fun f ->
                Query.Pair
                  ("CreditSpecification", (CreditSpecification.to_query f)));
           Util.option_map v.instance_market_options
             (fun f ->
                Query.Pair
                  ("InstanceMarketOptions",
                    (LaunchTemplateInstanceMarketOptions.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupSet",
                  (ValueStringList.to_query v.security_groups)));
           Some
             (Query.Pair
                ("SecurityGroupIdSet",
                  (ValueStringList.to_query v.security_group_ids)));
           Some
             (Query.Pair
                ("ElasticInferenceAcceleratorSet",
                  (LaunchTemplateElasticInferenceAcceleratorResponseList.to_query
                     v.elastic_inference_accelerators)));
           Some
             (Query.Pair
                ("ElasticGpuSpecificationSet",
                  (ElasticGpuSpecificationResponseList.to_query
                     v.elastic_gpu_specifications)));
           Some
             (Query.Pair
                ("TagSpecificationSet",
                  (LaunchTemplateTagSpecificationList.to_query
                     v.tag_specifications)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (ShutdownBehavior.to_query f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                Query.Pair ("DisableApiTermination", (Boolean.to_query f)));
           Util.option_map v.ram_disk_id
             (fun f -> Query.Pair ("RamDiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f ->
                Query.Pair
                  ("Placement", (LaunchTemplatePlacement.to_query f)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair
                  ("Monitoring", (LaunchTemplatesMonitoring.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (LaunchTemplateInstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Some
             (Query.Pair
                ("BlockDeviceMappingSet",
                  (LaunchTemplateBlockDeviceMappingList.to_query
                     v.block_device_mappings)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (LaunchTemplateIamInstanceProfileSpecification.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.hibernation_options
              (fun f ->
                 ("hibernation_options",
                   (LaunchTemplateHibernationOptions.to_json f)));
           Some
             ("license_specifications",
               (LaunchTemplateLicenseList.to_json v.license_specifications));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                ("capacity_reservation_specification",
                  (LaunchTemplateCapacityReservationSpecificationResponse.to_json
                     f)));
           Util.option_map v.cpu_options
             (fun f -> ("cpu_options", (LaunchTemplateCpuOptions.to_json f)));
           Util.option_map v.credit_specification
             (fun f ->
                ("credit_specification", (CreditSpecification.to_json f)));
           Util.option_map v.instance_market_options
             (fun f ->
                ("instance_market_options",
                  (LaunchTemplateInstanceMarketOptions.to_json f)));
           Some
             ("security_groups", (ValueStringList.to_json v.security_groups));
           Some
             ("security_group_ids",
               (ValueStringList.to_json v.security_group_ids));
           Some
             ("elastic_inference_accelerators",
               (LaunchTemplateElasticInferenceAcceleratorResponseList.to_json
                  v.elastic_inference_accelerators));
           Some
             ("elastic_gpu_specifications",
               (ElasticGpuSpecificationResponseList.to_json
                  v.elastic_gpu_specifications));
           Some
             ("tag_specifications",
               (LaunchTemplateTagSpecificationList.to_json
                  v.tag_specifications));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (ShutdownBehavior.to_json f)));
           Util.option_map v.disable_api_termination
             (fun f -> ("disable_api_termination", (Boolean.to_json f)));
           Util.option_map v.ram_disk_id
             (fun f -> ("ram_disk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (LaunchTemplatePlacement.to_json f)));
           Util.option_map v.monitoring
             (fun f -> ("monitoring", (LaunchTemplatesMonitoring.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Some
             ("network_interfaces",
               (LaunchTemplateInstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Some
             ("block_device_mappings",
               (LaunchTemplateBlockDeviceMappingList.to_json
                  v.block_device_mappings));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (LaunchTemplateIamInstanceProfileSpecification.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               LaunchTemplateIamInstanceProfileSpecification.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMappingSet" xml)
                  LaunchTemplateBlockDeviceMappingList.parse));
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  LaunchTemplateInstanceNetworkInterfaceSpecificationList.parse));
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml)
               LaunchTemplatesMonitoring.parse);
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               LaunchTemplatePlacement.parse);
          ram_disk_id =
            (Util.option_bind (Xml.member "ramDiskId" xml) String.parse);
          disable_api_termination =
            (Util.option_bind (Xml.member "disableApiTermination" xml)
               Boolean.parse);
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               ShutdownBehavior.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSpecificationSet" xml)
                  LaunchTemplateTagSpecificationList.parse));
          elastic_gpu_specifications =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "elasticGpuSpecificationSet" xml)
                  ElasticGpuSpecificationResponseList.parse));
          elastic_inference_accelerators =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "elasticInferenceAcceleratorSet" xml)
                  LaunchTemplateElasticInferenceAcceleratorResponseList.parse));
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupIdSet" xml)
                  ValueStringList.parse));
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupSet" xml)
                  ValueStringList.parse));
          instance_market_options =
            (Util.option_bind (Xml.member "instanceMarketOptions" xml)
               LaunchTemplateInstanceMarketOptions.parse);
          credit_specification =
            (Util.option_bind (Xml.member "creditSpecification" xml)
               CreditSpecification.parse);
          cpu_options =
            (Util.option_bind (Xml.member "cpuOptions" xml)
               LaunchTemplateCpuOptions.parse);
          capacity_reservation_specification =
            (Util.option_bind
               (Xml.member "capacityReservationSpecification" xml)
               LaunchTemplateCapacityReservationSpecificationResponse.parse);
          license_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "licenseSet" xml)
                  LaunchTemplateLicenseList.parse));
          hibernation_options =
            (Util.option_bind (Xml.member "hibernationOptions" xml)
               LaunchTemplateHibernationOptions.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((((((((((([] @
                                   [Util.option_map v.kernel_id
                                      (fun f ->
                                         Ezxmlm.make_tag "kernelId"
                                           ([], (String.to_xml f)))])
                                  @
                                  [Util.option_map v.ebs_optimized
                                     (fun f ->
                                        Ezxmlm.make_tag "ebsOptimized"
                                          ([], (Boolean.to_xml f)))])
                                 @
                                 [Util.option_map v.iam_instance_profile
                                    (fun f ->
                                       Ezxmlm.make_tag "iamInstanceProfile"
                                         ([],
                                           (LaunchTemplateIamInstanceProfileSpecification.to_xml
                                              f)))])
                                @
                                (List.map
                                   (fun x ->
                                      Some
                                        (Ezxmlm.make_tag
                                           "blockDeviceMappingSet"
                                           ([],
                                             (LaunchTemplateBlockDeviceMappingList.to_xml
                                                [x]))))
                                   v.block_device_mappings))
                               @
                               (List.map
                                  (fun x ->
                                     Some
                                       (Ezxmlm.make_tag "networkInterfaceSet"
                                          ([],
                                            (LaunchTemplateInstanceNetworkInterfaceSpecificationList.to_xml
                                               [x])))) v.network_interfaces))
                              @
                              [Util.option_map v.image_id
                                 (fun f ->
                                    Ezxmlm.make_tag "imageId"
                                      ([], (String.to_xml f)))])
                             @
                             [Util.option_map v.instance_type
                                (fun f ->
                                   Ezxmlm.make_tag "instanceType"
                                     ([], (InstanceType.to_xml f)))])
                            @
                            [Util.option_map v.key_name
                               (fun f ->
                                  Ezxmlm.make_tag "keyName"
                                    ([], (String.to_xml f)))])
                           @
                           [Util.option_map v.monitoring
                              (fun f ->
                                 Ezxmlm.make_tag "monitoring"
                                   ([], (LaunchTemplatesMonitoring.to_xml f)))])
                          @
                          [Util.option_map v.placement
                             (fun f ->
                                Ezxmlm.make_tag "placement"
                                  ([], (LaunchTemplatePlacement.to_xml f)))])
                         @
                         [Util.option_map v.ram_disk_id
                            (fun f ->
                               Ezxmlm.make_tag "ramDiskId"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.disable_api_termination
                           (fun f ->
                              Ezxmlm.make_tag "disableApiTermination"
                                ([], (Boolean.to_xml f)))])
                       @
                       [Util.option_map
                          v.instance_initiated_shutdown_behavior
                          (fun f ->
                             Ezxmlm.make_tag
                               "instanceInitiatedShutdownBehavior"
                               ([], (ShutdownBehavior.to_xml f)))])
                      @
                      [Util.option_map v.user_data
                         (fun f ->
                            Ezxmlm.make_tag "userData"
                              ([], (String.to_xml f)))])
                     @
                     (List.map
                        (fun x ->
                           Some
                             (Ezxmlm.make_tag "tagSpecificationSet"
                                ([],
                                  (LaunchTemplateTagSpecificationList.to_xml
                                     [x])))) v.tag_specifications))
                    @
                    (List.map
                       (fun x ->
                          Some
                            (Ezxmlm.make_tag "elasticGpuSpecificationSet"
                               ([],
                                 (ElasticGpuSpecificationResponseList.to_xml
                                    [x])))) v.elastic_gpu_specifications))
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "elasticInferenceAcceleratorSet"
                              ([],
                                (LaunchTemplateElasticInferenceAcceleratorResponseList.to_xml
                                   [x])))) v.elastic_inference_accelerators))
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "securityGroupIdSet"
                             ([], (ValueStringList.to_xml [x]))))
                     v.security_group_ids))
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "securityGroupSet"
                            ([], (ValueStringList.to_xml [x]))))
                    v.security_groups))
                @
                [Util.option_map v.instance_market_options
                   (fun f ->
                      Ezxmlm.make_tag "instanceMarketOptions"
                        ([], (LaunchTemplateInstanceMarketOptions.to_xml f)))])
               @
               [Util.option_map v.credit_specification
                  (fun f ->
                     Ezxmlm.make_tag "creditSpecification"
                       ([], (CreditSpecification.to_xml f)))])
              @
              [Util.option_map v.cpu_options
                 (fun f ->
                    Ezxmlm.make_tag "cpuOptions"
                      ([], (LaunchTemplateCpuOptions.to_xml f)))])
             @
             [Util.option_map v.capacity_reservation_specification
                (fun f ->
                   Ezxmlm.make_tag "capacityReservationSpecification"
                     ([],
                       (LaunchTemplateCapacityReservationSpecificationResponse.to_xml
                          f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "licenseSet"
                       ([], (LaunchTemplateLicenseList.to_xml [x]))))
               v.license_specifications))
           @
           [Util.option_map v.hibernation_options
              (fun f ->
                 Ezxmlm.make_tag "hibernationOptions"
                   ([], (LaunchTemplateHibernationOptions.to_xml f)))])
  end[@@ocaml.doc "<p>The information for a launch template. </p>"]
module MembershipType =
  struct
    type t =
      | Static 
      | Igmp 
    let str_to_t = [("igmp", Igmp); ("static", Static)]
    let t_to_str = [(Igmp, "igmp"); (Static, "static")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module LocalGatewayVirtualInterfaceIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module MoveStatus =
  struct
    type t =
      | MovingToVpc 
      | RestoringToClassic 
    let str_to_t =
      [("restoringToClassic", RestoringToClassic);
      ("movingToVpc", MovingToVpc)]
    let t_to_str =
      [(RestoringToClassic, "restoringToClassic");
      (MovingToVpc, "movingToVpc")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ElasticGpuSpecification =
  struct
    type t =
      {
      type_: String.t
        [@ocaml.doc
          "<p>The type of Elastic Graphics accelerator. For more information about the values to specify for <code>Type</code>, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-graphics.html#elastic-graphics-basics\">Elastic Graphics Basics</a>, specifically the Elastic Graphics accelerator column, in the <i>Amazon Elastic Compute Cloud User Guide for Windows Instances</i>.</p>"]}
    [@@ocaml.doc
      "<p>A specification for an Elastic Graphics accelerator.</p>"]
    let make ~type_  () = { type_ }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Type", (String.to_query v.type_)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt [Some ("type_", (String.to_json v.type_))])
    let parse xml =
      Some
        {
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) String.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @ [Some (Ezxmlm.make_tag "Type" ([], (String.to_xml v.type_)))])
  end[@@ocaml.doc
       "<p>A specification for an Elastic Graphics accelerator.</p>"]
module LaunchTemplateBlockDeviceMappingRequest =
  struct
    type t =
      {
      device_name: String.t option
        [@ocaml.doc
          "<p>The device name (for example, /dev/sdh or xvdh).</p>"];
      virtual_name: String.t option
        [@ocaml.doc
          "<p>The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.</p>"];
      ebs: LaunchTemplateEbsBlockDeviceRequest.t option
        [@ocaml.doc
          "<p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>"];
      no_device: String.t option
        [@ocaml.doc
          "<p>Suppresses the specified device included in the block device mapping of the AMI.</p>"]}
    [@@ocaml.doc "<p>Describes a block device mapping.</p>"]
    let make ?device_name  ?virtual_name  ?ebs  ?no_device  () =
      { device_name; virtual_name; ebs; no_device }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.ebs
             (fun f ->
                Query.Pair
                  ("Ebs", (LaunchTemplateEbsBlockDeviceRequest.to_query f)));
           Util.option_map v.virtual_name
             (fun f -> Query.Pair ("VirtualName", (String.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.ebs
             (fun f ->
                ("ebs", (LaunchTemplateEbsBlockDeviceRequest.to_json f)));
           Util.option_map v.virtual_name
             (fun f -> ("virtual_name", (String.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "DeviceName" xml) String.parse);
          virtual_name =
            (Util.option_bind (Xml.member "VirtualName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "Ebs" xml)
               LaunchTemplateEbsBlockDeviceRequest.parse);
          no_device =
            (Util.option_bind (Xml.member "NoDevice" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.device_name
                 (fun f ->
                    Ezxmlm.make_tag "DeviceName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.virtual_name
                (fun f ->
                   Ezxmlm.make_tag "VirtualName" ([], (String.to_xml f)))])
            @
            [Util.option_map v.ebs
               (fun f ->
                  Ezxmlm.make_tag "Ebs"
                    ([], (LaunchTemplateEbsBlockDeviceRequest.to_xml f)))])
           @
           [Util.option_map v.no_device
              (fun f -> Ezxmlm.make_tag "NoDevice" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a block device mapping.</p>"]
module CapacityReservationTarget =
  struct
    type t =
      {
      capacity_reservation_id: String.t option
        [@ocaml.doc "<p>The ID of the Capacity Reservation.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes a target Capacity Reservation.</p>"]
    let make ?capacity_reservation_id  () = { capacity_reservation_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_id
              (fun f ->
                 Query.Pair ("CapacityReservationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_id
              (fun f -> ("capacity_reservation_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          capacity_reservation_id =
            (Util.option_bind (Xml.member "CapacityReservationId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.capacity_reservation_id
              (fun f ->
                 Ezxmlm.make_tag "CapacityReservationId"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a target Capacity Reservation.</p>"]
module LaunchTemplateElasticInferenceAccelerator =
  struct
    type t =
      {
      type_: String.t
        [@ocaml.doc
          "<p> The type of elastic inference accelerator. The possible values are eia1.medium, eia1.large, and eia1.xlarge. </p>"];
      count: Integer.t option
        [@ocaml.doc
          "<p> The number of elastic inference accelerators to attach to the instance. </p> <p>Default: 1</p>"]}
    [@@ocaml.doc "<p> Describes an elastic inference accelerator. </p>"]
    let make ~type_  ?count  () = { type_; count }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.count
              (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Some (Query.Pair ("Type", (String.to_query v.type_)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Some ("type_", (String.to_json v.type_))])
    let parse xml =
      Some
        {
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) String.parse));
          count = (Util.option_bind (Xml.member "Count" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Type" ([], (String.to_xml v.type_)))])
           @
           [Util.option_map v.count
              (fun f -> Ezxmlm.make_tag "Count" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc "<p> Describes an elastic inference accelerator. </p>"]
module LaunchTemplateSpotMarketOptionsRequest =
  struct
    type t =
      {
      max_price: String.t option
        [@ocaml.doc
          "<p>The maximum hourly price you're willing to pay for the Spot Instances.</p>"];
      spot_instance_type: SpotInstanceType.t option
        [@ocaml.doc "<p>The Spot Instance request type.</p>"];
      block_duration_minutes: Integer.t option
        [@ocaml.doc
          "<p>The required duration for the Spot Instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).</p>"];
      valid_until: DateTime.t option
        [@ocaml.doc
          "<p>The end date of the request. For a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached. The default end date is 7 days from the current date.</p>"];
      instance_interruption_behavior: InstanceInterruptionBehavior.t option
        [@ocaml.doc
          "<p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>"]}
    [@@ocaml.doc "<p>The options for Spot Instances.</p>"]
    let make ?max_price  ?spot_instance_type  ?block_duration_minutes 
      ?valid_until  ?instance_interruption_behavior  () =
      {
        max_price;
        spot_instance_type;
        block_duration_minutes;
        valid_until;
        instance_interruption_behavior
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Query.Pair
                   ("InstanceInterruptionBehavior",
                     (InstanceInterruptionBehavior.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.block_duration_minutes
             (fun f ->
                Query.Pair ("BlockDurationMinutes", (Integer.to_query f)));
           Util.option_map v.spot_instance_type
             (fun f ->
                Query.Pair
                  ("SpotInstanceType", (SpotInstanceType.to_query f)));
           Util.option_map v.max_price
             (fun f -> Query.Pair ("MaxPrice", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 ("instance_interruption_behavior",
                   (InstanceInterruptionBehavior.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.block_duration_minutes
             (fun f -> ("block_duration_minutes", (Integer.to_json f)));
           Util.option_map v.spot_instance_type
             (fun f -> ("spot_instance_type", (SpotInstanceType.to_json f)));
           Util.option_map v.max_price
             (fun f -> ("max_price", (String.to_json f)))])
    let parse xml =
      Some
        {
          max_price =
            (Util.option_bind (Xml.member "MaxPrice" xml) String.parse);
          spot_instance_type =
            (Util.option_bind (Xml.member "SpotInstanceType" xml)
               SpotInstanceType.parse);
          block_duration_minutes =
            (Util.option_bind (Xml.member "BlockDurationMinutes" xml)
               Integer.parse);
          valid_until =
            (Util.option_bind (Xml.member "ValidUntil" xml) DateTime.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "InstanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.max_price
                  (fun f ->
                     Ezxmlm.make_tag "MaxPrice" ([], (String.to_xml f)))])
              @
              [Util.option_map v.spot_instance_type
                 (fun f ->
                    Ezxmlm.make_tag "SpotInstanceType"
                      ([], (SpotInstanceType.to_xml f)))])
             @
             [Util.option_map v.block_duration_minutes
                (fun f ->
                   Ezxmlm.make_tag "BlockDurationMinutes"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.valid_until
               (fun f ->
                  Ezxmlm.make_tag "ValidUntil" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Ezxmlm.make_tag "InstanceInterruptionBehavior"
                   ([], (InstanceInterruptionBehavior.to_xml f)))])
  end[@@ocaml.doc "<p>The options for Spot Instances.</p>"]
module LaunchTemplateInstanceNetworkInterfaceSpecificationRequest =
  struct
    type t =
      {
      associate_public_ip_address: Boolean.t option
        [@ocaml.doc
          "<p>Associates a public IPv4 address with eth0 for a new network interface.</p>"];
      delete_on_termination: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the network interface is deleted when the instance is terminated.</p>"];
      description: String.t option
        [@ocaml.doc "<p>A description for the network interface.</p>"];
      device_index: Integer.t option
        [@ocaml.doc
          "<p>The device index for the network interface attachment.</p>"];
      groups: SecurityGroupIdStringList.t
        [@ocaml.doc "<p>The IDs of one or more security groups.</p>"];
      interface_type: String.t option
        [@ocaml.doc
          "<p>The type of network interface. To create an Elastic Fabric Adapter (EFA), specify <code>efa</code>. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html\">Elastic Fabric Adapter</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>If you are not creating an EFA, specify <code>interface</code> or omit this parameter.</p> <p>Valid values: <code>interface</code> | <code>efa</code> </p>"];
      ipv6_address_count: Integer.t option
        [@ocaml.doc
          "<p>The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.</p>"];
      ipv6_addresses: InstanceIpv6AddressListRequest.t
        [@ocaml.doc
          "<p>One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.</p>"];
      network_interface_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface.</p>"];
      private_ip_address: String.t option
        [@ocaml.doc
          "<p>The primary private IPv4 address of the network interface.</p>"];
      private_ip_addresses: PrivateIpAddressSpecificationList.t
        [@ocaml.doc "<p>One or more private IPv4 addresses.</p>"];
      secondary_private_ip_address_count: Integer.t option
        [@ocaml.doc
          "<p>The number of secondary private IPv4 addresses to assign to a network interface.</p>"];
      subnet_id: String.t option
        [@ocaml.doc "<p>The ID of the subnet for the network interface.</p>"]}
    [@@ocaml.doc "<p>The parameters for a network interface.</p>"]
    let make ?associate_public_ip_address  ?delete_on_termination 
      ?description  ?device_index  ?(groups= [])  ?interface_type 
      ?ipv6_address_count  ?(ipv6_addresses= [])  ?network_interface_id 
      ?private_ip_address  ?(private_ip_addresses= []) 
      ?secondary_private_ip_address_count  ?subnet_id  () =
      {
        associate_public_ip_address;
        delete_on_termination;
        description;
        device_index;
        groups;
        interface_type;
        ipv6_address_count;
        ipv6_addresses;
        network_interface_id;
        private_ip_address;
        private_ip_addresses;
        secondary_private_ip_address_count;
        subnet_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddresses",
                  (PrivateIpAddressSpecificationList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6Addresses",
                  (InstanceIpv6AddressListRequest.to_query v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)));
           Util.option_map v.interface_type
             (fun f -> Query.Pair ("InterfaceType", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.groups)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.associate_public_ip_address
             (fun f ->
                Query.Pair ("AssociatePublicIpAddress", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_addresses",
               (PrivateIpAddressSpecificationList.to_json
                  v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (InstanceIpv6AddressListRequest.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)));
           Util.option_map v.interface_type
             (fun f -> ("interface_type", (String.to_json f)));
           Some ("groups", (SecurityGroupIdStringList.to_json v.groups));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.associate_public_ip_address
             (fun f -> ("associate_public_ip_address", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          associate_public_ip_address =
            (Util.option_bind (Xml.member "AssociatePublicIpAddress" xml)
               Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "DeleteOnTermination" xml)
               Boolean.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          device_index =
            (Util.option_bind (Xml.member "DeviceIndex" xml) Integer.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          interface_type =
            (Util.option_bind (Xml.member "InterfaceType" xml) String.parse);
          ipv6_address_count =
            (Util.option_bind (Xml.member "Ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "Ipv6Addresses" xml)
                  InstanceIpv6AddressListRequest.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "NetworkInterfaceId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "PrivateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "PrivateIpAddresses" xml)
                  PrivateIpAddressSpecificationList.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "SecondaryPrivateIpAddressCount" xml)
               Integer.parse);
          subnet_id =
            (Util.option_bind (Xml.member "SubnetId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.associate_public_ip_address
                          (fun f ->
                             Ezxmlm.make_tag "AssociatePublicIpAddress"
                               ([], (Boolean.to_xml f)))])
                      @
                      [Util.option_map v.delete_on_termination
                         (fun f ->
                            Ezxmlm.make_tag "DeleteOnTermination"
                              ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.description
                        (fun f ->
                           Ezxmlm.make_tag "Description"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.device_index
                       (fun f ->
                          Ezxmlm.make_tag "DeviceIndex"
                            ([], (Integer.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "SecurityGroupId"
                              ([], (SecurityGroupIdStringList.to_xml [x]))))
                      v.groups))
                  @
                  [Util.option_map v.interface_type
                     (fun f ->
                        Ezxmlm.make_tag "InterfaceType"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.ipv6_address_count
                    (fun f ->
                       Ezxmlm.make_tag "Ipv6AddressCount"
                         ([], (Integer.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "Ipv6Addresses"
                           ([], (InstanceIpv6AddressListRequest.to_xml [x]))))
                   v.ipv6_addresses))
               @
               [Util.option_map v.network_interface_id
                  (fun f ->
                     Ezxmlm.make_tag "NetworkInterfaceId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.private_ip_address
                 (fun f ->
                    Ezxmlm.make_tag "PrivateIpAddress"
                      ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "PrivateIpAddresses"
                        ([], (PrivateIpAddressSpecificationList.to_xml [x]))))
                v.private_ip_addresses))
            @
            [Util.option_map v.secondary_private_ip_address_count
               (fun f ->
                  Ezxmlm.make_tag "SecondaryPrivateIpAddressCount"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.subnet_id
              (fun f -> Ezxmlm.make_tag "SubnetId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>The parameters for a network interface.</p>"]
module LaunchTemplateLicenseConfigurationRequest =
  struct
    type t =
      {
      license_configuration_arn: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the license configuration.</p>"]}
    [@@ocaml.doc "<p>Describes a license configuration.</p>"]
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "LicenseConfigurationArn" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Ezxmlm.make_tag "LicenseConfigurationArn"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a license configuration.</p>"]
module LaunchTemplateTagSpecificationRequest =
  struct
    type t =
      {
      resource_type: ResourceType.t option
        [@ocaml.doc
          "<p>The type of resource to tag. Currently, the resource types that support tagging on creation are <code>instance</code> and <code>volume</code>. To tag a resource after it has been created, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html\">CreateTags</a>.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>The tags to apply to the resource.</p>"]}[@@ocaml.doc
                                                                   "<p>The tags specification for the launch template.</p>"]
    let make ?resource_type  ?(tags= [])  () = { resource_type; tags }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Tag", (TagList.to_query v.tags)));
           Util.option_map v.resource_type
             (fun f -> Query.Pair ("ResourceType", (ResourceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.resource_type
             (fun f -> ("resource_type", (ResourceType.to_json f)))])
    let parse xml =
      Some
        {
          resource_type =
            (Util.option_bind (Xml.member "ResourceType" xml)
               ResourceType.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tag" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "ResourceType"
                    ([], (ResourceType.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "Tag" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>The tags specification for the launch template.</p>"]
module ResponseError =
  struct
    type t =
      {
      code: LaunchTemplateErrorCode.t option
        [@ocaml.doc "<p>The error code.</p>"];
      message: String.t option
        [@ocaml.doc "<p>The error message, if applicable.</p>"]}[@@ocaml.doc
                                                                  "<p>Describes the error that's returned when you cannot delete a launch template version.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair ("Code", (LaunchTemplateErrorCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (LaunchTemplateErrorCode.to_json f)))])
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               LaunchTemplateErrorCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (LaunchTemplateErrorCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the error that's returned when you cannot delete a launch template version.</p>"]
module LaunchSpecification =
  struct
    type t =
      {
      user_data: String.t option
        [@ocaml.doc "<p>The Base64-encoded user data for the instance.</p>"];
      security_groups: GroupIdentifierList.t
        [@ocaml.doc
          "<p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>"];
      addressing_type: String.t option [@ocaml.doc "<p>Deprecated.</p>"];
      block_device_mappings: BlockDeviceMappingList.t
        [@ocaml.doc "<p>One or more block device mapping entries.</p>"];
      ebs_optimized: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p> <p>Default: <code>false</code> </p>"];
      iam_instance_profile: IamInstanceProfileSpecification.t option
        [@ocaml.doc "<p>The IAM instance profile.</p>"];
      image_id: String.t option [@ocaml.doc "<p>The ID of the AMI.</p>"];
      instance_type: InstanceType.t option
        [@ocaml.doc "<p>The instance type.</p>"];
      kernel_id: String.t option [@ocaml.doc "<p>The ID of the kernel.</p>"];
      key_name: String.t option
        [@ocaml.doc "<p>The name of the key pair.</p>"];
      network_interfaces: InstanceNetworkInterfaceSpecificationList.t
        [@ocaml.doc
          "<p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p>"];
      placement: SpotPlacement.t option
        [@ocaml.doc "<p>The placement information for the instance.</p>"];
      ramdisk_id: String.t option
        [@ocaml.doc "<p>The ID of the RAM disk.</p>"];
      subnet_id: String.t option
        [@ocaml.doc
          "<p>The ID of the subnet in which to launch the instance.</p>"];
      monitoring: RunInstancesMonitoringEnabled.t option }[@@ocaml.doc
                                                            "<p>Describes the launch specification for an instance.</p>"]
    let make ?user_data  ?(security_groups= [])  ?addressing_type 
      ?(block_device_mappings= [])  ?ebs_optimized  ?iam_instance_profile 
      ?image_id  ?instance_type  ?kernel_id  ?key_name  ?(network_interfaces=
      [])  ?placement  ?ramdisk_id  ?subnet_id  ?monitoring  () =
      {
        user_data;
        security_groups;
        addressing_type;
        block_device_mappings;
        ebs_optimized;
        iam_instance_profile;
        image_id;
        instance_type;
        kernel_id;
        key_name;
        network_interfaces;
        placement;
        ramdisk_id;
        subnet_id;
        monitoring
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.monitoring
              (fun f ->
                 Query.Pair
                   ("Monitoring", (RunInstancesMonitoringEnabled.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (SpotPlacement.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (InstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (IamInstanceProfileSpecification.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Util.option_map v.addressing_type
             (fun f -> Query.Pair ("AddressingType", (String.to_query f)));
           Some
             (Query.Pair
                ("GroupSet",
                  (GroupIdentifierList.to_query v.security_groups)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.monitoring
              (fun f ->
                 ("monitoring", (RunInstancesMonitoringEnabled.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (SpotPlacement.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (IamInstanceProfileSpecification.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings));
           Util.option_map v.addressing_type
             (fun f -> ("addressing_type", (String.to_json f)));
           Some
             ("security_groups",
               (GroupIdentifierList.to_json v.security_groups));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)))])
    let parse xml =
      Some
        {
          user_data =
            (Util.option_bind (Xml.member "userData" xml) String.parse);
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          addressing_type =
            (Util.option_bind (Xml.member "addressingType" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  InstanceNetworkInterfaceSpecificationList.parse));
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               SpotPlacement.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml)
               RunInstancesMonitoringEnabled.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Util.option_map v.user_data
                            (fun f ->
                               Ezxmlm.make_tag "userData"
                                 ([], (String.to_xml f)))])
                        @
                        (List.map
                           (fun x ->
                              Some
                                (Ezxmlm.make_tag "groupSet"
                                   ([], (GroupIdentifierList.to_xml [x]))))
                           v.security_groups))
                       @
                       [Util.option_map v.addressing_type
                          (fun f ->
                             Ezxmlm.make_tag "addressingType"
                               ([], (String.to_xml f)))])
                      @
                      (List.map
                         (fun x ->
                            Some
                              (Ezxmlm.make_tag "blockDeviceMapping"
                                 ([], (BlockDeviceMappingList.to_xml [x]))))
                         v.block_device_mappings))
                     @
                     [Util.option_map v.ebs_optimized
                        (fun f ->
                           Ezxmlm.make_tag "ebsOptimized"
                             ([], (Boolean.to_xml f)))])
                    @
                    [Util.option_map v.iam_instance_profile
                       (fun f ->
                          Ezxmlm.make_tag "iamInstanceProfile"
                            ([], (IamInstanceProfileSpecification.to_xml f)))])
                   @
                   [Util.option_map v.image_id
                      (fun f ->
                         Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.instance_type
                     (fun f ->
                        Ezxmlm.make_tag "instanceType"
                          ([], (InstanceType.to_xml f)))])
                 @
                 [Util.option_map v.kernel_id
                    (fun f ->
                       Ezxmlm.make_tag "kernelId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.key_name
                   (fun f ->
                      Ezxmlm.make_tag "keyName" ([], (String.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "networkInterfaceSet"
                          ([],
                            (InstanceNetworkInterfaceSpecificationList.to_xml
                               [x])))) v.network_interfaces))
              @
              [Util.option_map v.placement
                 (fun f ->
                    Ezxmlm.make_tag "placement"
                      ([], (SpotPlacement.to_xml f)))])
             @
             [Util.option_map v.ramdisk_id
                (fun f -> Ezxmlm.make_tag "ramdiskId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.subnet_id
               (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.monitoring
              (fun f ->
                 Ezxmlm.make_tag "monitoring"
                   ([], (RunInstancesMonitoringEnabled.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the launch specification for an instance.</p>"]
module SpotInstanceState =
  struct
    type t =
      | Open 
      | Active 
      | Closed 
      | Cancelled 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("cancelled", Cancelled);
      ("closed", Closed);
      ("active", Active);
      ("open", Open)]
    let t_to_str =
      [(Failed, "failed");
      (Cancelled, "cancelled");
      (Closed, "closed");
      (Active, "active");
      (Open, "open")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module SpotInstanceStateFault =
  struct
    type t =
      {
      code: String.t option
        [@ocaml.doc
          "<p>The reason code for the Spot Instance state change.</p>"];
      message: String.t option
        [@ocaml.doc "<p>The message for the Spot Instance state change.</p>"]}
    [@@ocaml.doc "<p>Describes a Spot Instance state change.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a Spot Instance state change.</p>"]
module SpotInstanceStatus =
  struct
    type t =
      {
      code: String.t option
        [@ocaml.doc
          "<p>The status code. For a list of status codes, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html#spot-instance-bid-status-understand\">Spot Status Codes</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>"];
      message: String.t option
        [@ocaml.doc "<p>The description for the status code.</p>"];
      update_time: DateTime.t option
        [@ocaml.doc
          "<p>The date and time of the most recent status update, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>"]}
    [@@ocaml.doc "<p>Describes the status of a Spot Instance request.</p>"]
    let make ?code  ?message  ?update_time  () =
      { code; message; update_time }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.update_time
              (fun f -> Query.Pair ("UpdateTime", (DateTime.to_query f)));
           Util.option_map v.message
             (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.update_time
              (fun f -> ("update_time", (DateTime.to_json f)));
           Util.option_map v.message
             (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse);
          update_time =
            (Util.option_bind (Xml.member "updateTime" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.code
                (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
            @
            [Util.option_map v.message
               (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
           @
           [Util.option_map v.update_time
              (fun f ->
                 Ezxmlm.make_tag "updateTime" ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the status of a Spot Instance request.</p>"]
module DeleteQueuedReservedInstancesError =
  struct
    type t =
      {
      code: DeleteQueuedReservedInstancesErrorCode.t option
        [@ocaml.doc "<p>The error code.</p>"];
      message: String.t option [@ocaml.doc "<p>The error message.</p>"]}
    [@@ocaml.doc
      "<p>Describes the error for a Reserved Instance whose queued purchase could not be deleted.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code",
                    (DeleteQueuedReservedInstancesErrorCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code", (DeleteQueuedReservedInstancesErrorCode.to_json f)))])
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               DeleteQueuedReservedInstancesErrorCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (DeleteQueuedReservedInstancesErrorCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the error for a Reserved Instance whose queued purchase could not be deleted.</p>"]
module ExportTaskState =
  struct
    type t =
      | Active 
      | Cancelling 
      | Cancelled 
      | Completed 
    let str_to_t =
      [("completed", Completed);
      ("cancelled", Cancelled);
      ("cancelling", Cancelling);
      ("active", Active)]
    let t_to_str =
      [(Completed, "completed");
      (Cancelled, "cancelled");
      (Cancelling, "cancelling");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ExportToS3Task =
  struct
    type t =
      {
      container_format: ContainerFormat.t option
        [@ocaml.doc
          "<p>The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is exported.</p>"];
      disk_image_format: DiskImageFormat.t option
        [@ocaml.doc "<p>The format for the exported image.</p>"];
      s3_bucket: String.t option
        [@ocaml.doc
          "<p>The S3 bucket for the destination image. The destination bucket must exist and grant WRITE and READ_ACP permissions to the AWS account <code>vm-import-export@amazon.com</code>.</p>"];
      s3_key: String.t option
        [@ocaml.doc "<p>The encryption key for your S3 bucket.</p>"]}
    [@@ocaml.doc
      "<p>Describes the format and location for an instance export task.</p>"]
    let make ?container_format  ?disk_image_format  ?s3_bucket  ?s3_key  () =
      { container_format; disk_image_format; s3_bucket; s3_key }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> Query.Pair ("S3Key", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)));
           Util.option_map v.disk_image_format
             (fun f ->
                Query.Pair ("DiskImageFormat", (DiskImageFormat.to_query f)));
           Util.option_map v.container_format
             (fun f ->
                Query.Pair ("ContainerFormat", (ContainerFormat.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> ("s3_key", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)));
           Util.option_map v.disk_image_format
             (fun f -> ("disk_image_format", (DiskImageFormat.to_json f)));
           Util.option_map v.container_format
             (fun f -> ("container_format", (ContainerFormat.to_json f)))])
    let parse xml =
      Some
        {
          container_format =
            (Util.option_bind (Xml.member "containerFormat" xml)
               ContainerFormat.parse);
          disk_image_format =
            (Util.option_bind (Xml.member "diskImageFormat" xml)
               DiskImageFormat.parse);
          s3_bucket =
            (Util.option_bind (Xml.member "s3Bucket" xml) String.parse);
          s3_key = (Util.option_bind (Xml.member "s3Key" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.container_format
                 (fun f ->
                    Ezxmlm.make_tag "containerFormat"
                      ([], (ContainerFormat.to_xml f)))])
             @
             [Util.option_map v.disk_image_format
                (fun f ->
                   Ezxmlm.make_tag "diskImageFormat"
                     ([], (DiskImageFormat.to_xml f)))])
            @
            [Util.option_map v.s3_bucket
               (fun f -> Ezxmlm.make_tag "s3Bucket" ([], (String.to_xml f)))])
           @
           [Util.option_map v.s3_key
              (fun f -> Ezxmlm.make_tag "s3Key" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the format and location for an instance export task.</p>"]
module InstanceExportDetails =
  struct
    type t =
      {
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the resource being exported.</p>"];
      target_environment: ExportEnvironment.t option
        [@ocaml.doc "<p>The target virtualization environment.</p>"]}
    [@@ocaml.doc "<p>Describes an instance to export.</p>"]
    let make ?instance_id  ?target_environment  () =
      { instance_id; target_environment }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.target_environment
              (fun f ->
                 Query.Pair
                   ("TargetEnvironment", (ExportEnvironment.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_environment
              (fun f -> ("target_environment", (ExportEnvironment.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          target_environment =
            (Util.option_bind (Xml.member "targetEnvironment" xml)
               ExportEnvironment.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.target_environment
              (fun f ->
                 Ezxmlm.make_tag "targetEnvironment"
                   ([], (ExportEnvironment.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an instance to export.</p>"]
module IpPermissionList =
  struct
    type t = IpPermission.t list
    let make elems () = elems
    let to_query v = Query.to_query_list IpPermission.to_query v
    let to_headers v = Headers.to_headers_list IpPermission.to_headers v
    let to_json v = `List (List.map IpPermission.to_json v)
    let parse xml =
      Util.option_all (List.map IpPermission.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (IpPermission.to_xml x))) v
  end
module AssociatedTargetNetworkSet =
  struct
    type t = AssociatedTargetNetwork.t list
    let make elems () = elems
    let to_query v = Query.to_query_list AssociatedTargetNetwork.to_query v
    let to_headers v =
      Headers.to_headers_list AssociatedTargetNetwork.to_headers v
    let to_json v = `List (List.map AssociatedTargetNetwork.to_json v)
    let parse xml =
      Util.option_all
        (List.map AssociatedTargetNetwork.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (AssociatedTargetNetwork.to_xml x)))
        v
  end
module ClientVpnAuthenticationList =
  struct
    type t = ClientVpnAuthentication.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ClientVpnAuthentication.to_query v
    let to_headers v =
      Headers.to_headers_list ClientVpnAuthentication.to_headers v
    let to_json v = `List (List.map ClientVpnAuthentication.to_json v)
    let parse xml =
      Util.option_all
        (List.map ClientVpnAuthentication.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ClientVpnAuthentication.to_xml x)))
        v
  end
module ClientVpnEndpointStatus =
  struct
    type t =
      {
      code: ClientVpnEndpointStatusCode.t option
        [@ocaml.doc
          "<p>The state of the Client VPN endpoint. Possible states include:</p> <ul> <li> <p> <code>pending-associate</code> - The Client VPN endpoint has been created but no target networks have been associated. The Client VPN endpoint cannot accept connections.</p> </li> <li> <p> <code>available</code> - The Client VPN endpoint has been created and a target network has been associated. The Client VPN endpoint can accept connections.</p> </li> <li> <p> <code>deleting</code> - The Client VPN endpoint is being deleted. The Client VPN endpoint cannot accept connections.</p> </li> <li> <p> <code>deleted</code> - The Client VPN endpoint has been deleted. The Client VPN endpoint cannot accept connections.</p> </li> </ul>"];
      message: String.t option
        [@ocaml.doc
          "<p>A message about the status of the Client VPN endpoint.</p>"]}
    [@@ocaml.doc "<p>Describes the state of a Client VPN endpoint.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair ("Code", (ClientVpnEndpointStatusCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (ClientVpnEndpointStatusCode.to_json f)))])
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               ClientVpnEndpointStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (ClientVpnEndpointStatusCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the state of a Client VPN endpoint.</p>"]
module ConnectionLogResponseOptions =
  struct
    type t =
      {
      enabled: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether client connection logging is enabled for the Client VPN endpoint.</p>"];
      cloudwatch_log_group: String.t option
        [@ocaml.doc
          "<p>The name of the Amazon CloudWatch Logs log group to which connection logging data is published.</p>"];
      cloudwatch_log_stream: String.t option
        [@ocaml.doc
          "<p>The name of the Amazon CloudWatch Logs log stream to which connection logging data is published.</p>"]}
    [@@ocaml.doc
      "<p>Information about the client connection logging options for a Client VPN endpoint.</p>"]
    let make ?enabled  ?cloudwatch_log_group  ?cloudwatch_log_stream  () =
      { enabled; cloudwatch_log_group; cloudwatch_log_stream }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cloudwatch_log_stream
              (fun f ->
                 Query.Pair ("CloudwatchLogStream", (String.to_query f)));
           Util.option_map v.cloudwatch_log_group
             (fun f -> Query.Pair ("CloudwatchLogGroup", (String.to_query f)));
           Util.option_map v.enabled
             (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cloudwatch_log_stream
              (fun f -> ("cloudwatch_log_stream", (String.to_json f)));
           Util.option_map v.cloudwatch_log_group
             (fun f -> ("cloudwatch_log_group", (String.to_json f)));
           Util.option_map v.enabled
             (fun f -> ("enabled", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse);
          cloudwatch_log_group =
            (Util.option_bind (Xml.member "CloudwatchLogGroup" xml)
               String.parse);
          cloudwatch_log_stream =
            (Util.option_bind (Xml.member "CloudwatchLogStream" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.enabled
                (fun f -> Ezxmlm.make_tag "Enabled" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.cloudwatch_log_group
               (fun f ->
                  Ezxmlm.make_tag "CloudwatchLogGroup"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.cloudwatch_log_stream
              (fun f ->
                 Ezxmlm.make_tag "CloudwatchLogStream"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Information about the client connection logging options for a Client VPN endpoint.</p>"]
module TransportProtocol =
  struct
    type t =
      | Tcp 
      | Udp 
    let str_to_t = [("udp", Udp); ("tcp", Tcp)]
    let t_to_str = [(Udp, "udp"); (Tcp, "tcp")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module VpnProtocol =
  struct
    type t =
      | Openvpn 
    let str_to_t = [("openvpn", Openvpn)]
    let t_to_str = [(Openvpn, "openvpn")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module FleetLaunchTemplateOverridesListRequest =
  struct
    type t = FleetLaunchTemplateOverridesRequest.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list FleetLaunchTemplateOverridesRequest.to_query v
    let to_headers v =
      Headers.to_headers_list FleetLaunchTemplateOverridesRequest.to_headers
        v
    let to_json v =
      `List (List.map FleetLaunchTemplateOverridesRequest.to_json v)
    let parse xml =
      Util.option_all
        (List.map FleetLaunchTemplateOverridesRequest.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (FleetLaunchTemplateOverridesRequest.to_xml x))) v
  end
module FleetLaunchTemplateSpecificationRequest =
  struct
    type t =
      {
      launch_template_id: String.t option
        [@ocaml.doc "<p>The ID of the launch template.</p>"];
      launch_template_name: String.t option
        [@ocaml.doc "<p>The name of the launch template.</p>"];
      version: String.t option
        [@ocaml.doc
          "<p>The version number of the launch template. Note: This is a required parameter and will be updated soon. </p>"]}
    [@@ocaml.doc
      "<p>The launch template to use. You must specify either the launch template ID or launch template name in the request. </p>"]
    let make ?launch_template_id  ?launch_template_name  ?version  () =
      { launch_template_id; launch_template_name; version }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> Query.Pair ("Version", (String.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> ("version", (String.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "LaunchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "LaunchTemplateName" xml)
               String.parse);
          version =
            (Util.option_bind (Xml.member "Version" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.launch_template_id
                (fun f ->
                   Ezxmlm.make_tag "LaunchTemplateId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.launch_template_name
               (fun f ->
                  Ezxmlm.make_tag "LaunchTemplateName"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.version
              (fun f -> Ezxmlm.make_tag "Version" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>The launch template to use. You must specify either the launch template ID or launch template name in the request. </p>"]
module InternetGatewayAttachmentList =
  struct
    type t = InternetGatewayAttachment.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InternetGatewayAttachment.to_query v
    let to_headers v =
      Headers.to_headers_list InternetGatewayAttachment.to_headers v
    let to_json v = `List (List.map InternetGatewayAttachment.to_json v)
    let parse xml =
      Util.option_all
        (List.map InternetGatewayAttachment.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InternetGatewayAttachment.to_xml x))) v
  end
module DescribeFleetsErrorSet =
  struct
    type t = DescribeFleetError.t list
    let make elems () = elems
    let to_query v = Query.to_query_list DescribeFleetError.to_query v
    let to_headers v =
      Headers.to_headers_list DescribeFleetError.to_headers v
    let to_json v = `List (List.map DescribeFleetError.to_json v)
    let parse xml =
      Util.option_all
        (List.map DescribeFleetError.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (DescribeFleetError.to_xml x))) v
  end
module DescribeFleetsInstancesSet =
  struct
    type t = DescribeFleetsInstances.t list
    let make elems () = elems
    let to_query v = Query.to_query_list DescribeFleetsInstances.to_query v
    let to_headers v =
      Headers.to_headers_list DescribeFleetsInstances.to_headers v
    let to_json v = `List (List.map DescribeFleetsInstances.to_json v)
    let parse xml =
      Util.option_all
        (List.map DescribeFleetsInstances.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (DescribeFleetsInstances.to_xml x)))
        v
  end
module FleetActivityStatus =
  struct
    type t =
      | Error 
      | Pending_fulfillment 
      | Pending_termination 
      | Fulfilled 
    let str_to_t =
      [("fulfilled", Fulfilled);
      ("pending_termination", Pending_termination);
      ("pending_fulfillment", Pending_fulfillment);
      ("error", Error)]
    let t_to_str =
      [(Fulfilled, "fulfilled");
      (Pending_termination, "pending_termination");
      (Pending_fulfillment, "pending_fulfillment");
      (Error, "error")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module FleetExcessCapacityTerminationPolicy =
  struct
    type t =
      | No_termination 
      | Termination 
    let str_to_t =
      [("termination", Termination); ("no-termination", No_termination)]
    let t_to_str =
      [(Termination, "termination"); (No_termination, "no-termination")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module FleetLaunchTemplateConfigList =
  struct
    type t = FleetLaunchTemplateConfig.t list
    let make elems () = elems
    let to_query v = Query.to_query_list FleetLaunchTemplateConfig.to_query v
    let to_headers v =
      Headers.to_headers_list FleetLaunchTemplateConfig.to_headers v
    let to_json v = `List (List.map FleetLaunchTemplateConfig.to_json v)
    let parse xml =
      Util.option_all
        (List.map FleetLaunchTemplateConfig.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (FleetLaunchTemplateConfig.to_xml x))) v
  end
module OnDemandOptions =
  struct
    type t =
      {
      allocation_strategy: FleetOnDemandAllocationStrategy.t option
        [@ocaml.doc
          "<p>The order of the launch template overrides to use in fulfilling On-Demand capacity. If you specify <code>lowest-price</code>, EC2 Fleet uses price to determine the order, launching the lowest price first. If you specify <code>prioritized</code>, EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first. If you do not specify a value, EC2 Fleet defaults to <code>lowest-price</code>.</p>"];
      capacity_reservation_options: CapacityReservationOptions.t option
        [@ocaml.doc
          "<p>The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity. Supported only for fleets of type <code>instant</code>.</p>"];
      single_instance_type: Boolean.t option
        [@ocaml.doc
          "<p>Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet. Supported only for fleets of type <code>instant</code>.</p>"];
      single_availability_zone: Boolean.t option
        [@ocaml.doc
          "<p>Indicates that the fleet launches all On-Demand Instances into a single Availability Zone. Supported only for fleets of type <code>instant</code>.</p>"];
      min_target_capacity: Integer.t option
        [@ocaml.doc
          "<p>The minimum target capacity for On-Demand Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances.</p>"];
      max_total_price: String.t option
        [@ocaml.doc
          "<p>The maximum amount per hour for On-Demand Instances that you're willing to pay.</p>"]}
    [@@ocaml.doc
      "<p>Describes the configuration of On-Demand Instances in an EC2 Fleet.</p>"]
    let make ?allocation_strategy  ?capacity_reservation_options 
      ?single_instance_type  ?single_availability_zone  ?min_target_capacity 
      ?max_total_price  () =
      {
        allocation_strategy;
        capacity_reservation_options;
        single_instance_type;
        single_availability_zone;
        min_target_capacity;
        max_total_price
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> Query.Pair ("MaxTotalPrice", (String.to_query f)));
           Util.option_map v.min_target_capacity
             (fun f -> Query.Pair ("MinTargetCapacity", (Integer.to_query f)));
           Util.option_map v.single_availability_zone
             (fun f ->
                Query.Pair ("SingleAvailabilityZone", (Boolean.to_query f)));
           Util.option_map v.single_instance_type
             (fun f ->
                Query.Pair ("SingleInstanceType", (Boolean.to_query f)));
           Util.option_map v.capacity_reservation_options
             (fun f ->
                Query.Pair
                  ("CapacityReservationOptions",
                    (CapacityReservationOptions.to_query f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                Query.Pair
                  ("AllocationStrategy",
                    (FleetOnDemandAllocationStrategy.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> ("max_total_price", (String.to_json f)));
           Util.option_map v.min_target_capacity
             (fun f -> ("min_target_capacity", (Integer.to_json f)));
           Util.option_map v.single_availability_zone
             (fun f -> ("single_availability_zone", (Boolean.to_json f)));
           Util.option_map v.single_instance_type
             (fun f -> ("single_instance_type", (Boolean.to_json f)));
           Util.option_map v.capacity_reservation_options
             (fun f ->
                ("capacity_reservation_options",
                  (CapacityReservationOptions.to_json f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                ("allocation_strategy",
                  (FleetOnDemandAllocationStrategy.to_json f)))])
    let parse xml =
      Some
        {
          allocation_strategy =
            (Util.option_bind (Xml.member "allocationStrategy" xml)
               FleetOnDemandAllocationStrategy.parse);
          capacity_reservation_options =
            (Util.option_bind (Xml.member "capacityReservationOptions" xml)
               CapacityReservationOptions.parse);
          single_instance_type =
            (Util.option_bind (Xml.member "singleInstanceType" xml)
               Boolean.parse);
          single_availability_zone =
            (Util.option_bind (Xml.member "singleAvailabilityZone" xml)
               Boolean.parse);
          min_target_capacity =
            (Util.option_bind (Xml.member "minTargetCapacity" xml)
               Integer.parse);
          max_total_price =
            (Util.option_bind (Xml.member "maxTotalPrice" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.allocation_strategy
                   (fun f ->
                      Ezxmlm.make_tag "allocationStrategy"
                        ([], (FleetOnDemandAllocationStrategy.to_xml f)))])
               @
               [Util.option_map v.capacity_reservation_options
                  (fun f ->
                     Ezxmlm.make_tag "capacityReservationOptions"
                       ([], (CapacityReservationOptions.to_xml f)))])
              @
              [Util.option_map v.single_instance_type
                 (fun f ->
                    Ezxmlm.make_tag "singleInstanceType"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.single_availability_zone
                (fun f ->
                   Ezxmlm.make_tag "singleAvailabilityZone"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.min_target_capacity
               (fun f ->
                  Ezxmlm.make_tag "minTargetCapacity"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.max_total_price
              (fun f ->
                 Ezxmlm.make_tag "maxTotalPrice" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the configuration of On-Demand Instances in an EC2 Fleet.</p>"]
module SpotOptions =
  struct
    type t =
      {
      allocation_strategy: SpotAllocationStrategy.t option
        [@ocaml.doc
          "<p>Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.</p> <p>If the allocation strategy is <code>lowest-price</code>, EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.</p> <p>If the allocation strategy is <code>diversified</code>, EC2 Fleet launches instances from all of the Spot Instance pools that you specify.</p> <p>If the allocation strategy is <code>capacity-optimized</code>, EC2 Fleet launches instances from Spot Instance pools with optimal capacity for the number of instances that are launching.</p>"];
      instance_interruption_behavior:
        SpotInstanceInterruptionBehavior.t option
        [@ocaml.doc
          "<p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>"];
      instance_pools_to_use_count: Integer.t option
        [@ocaml.doc
          "<p>The number of Spot pools across which to allocate your target Spot capacity. Valid only when <b>AllocationStrategy</b> is set to <code>lowest-price</code>. EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.</p>"];
      single_instance_type: Boolean.t option
        [@ocaml.doc
          "<p>Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet. Supported only for fleets of type <code>instant</code>.</p>"];
      single_availability_zone: Boolean.t option
        [@ocaml.doc
          "<p>Indicates that the fleet launches all Spot Instances into a single Availability Zone. Supported only for fleets of type <code>instant</code>.</p>"];
      min_target_capacity: Integer.t option
        [@ocaml.doc
          "<p>The minimum target capacity for Spot Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances.</p>"];
      max_total_price: String.t option
        [@ocaml.doc
          "<p>The maximum amount per hour for Spot Instances that you're willing to pay.</p>"]}
    [@@ocaml.doc
      "<p>Describes the configuration of Spot Instances in an EC2 Fleet.</p>"]
    let make ?allocation_strategy  ?instance_interruption_behavior 
      ?instance_pools_to_use_count  ?single_instance_type 
      ?single_availability_zone  ?min_target_capacity  ?max_total_price  () =
      {
        allocation_strategy;
        instance_interruption_behavior;
        instance_pools_to_use_count;
        single_instance_type;
        single_availability_zone;
        min_target_capacity;
        max_total_price
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> Query.Pair ("MaxTotalPrice", (String.to_query f)));
           Util.option_map v.min_target_capacity
             (fun f -> Query.Pair ("MinTargetCapacity", (Integer.to_query f)));
           Util.option_map v.single_availability_zone
             (fun f ->
                Query.Pair ("SingleAvailabilityZone", (Boolean.to_query f)));
           Util.option_map v.single_instance_type
             (fun f ->
                Query.Pair ("SingleInstanceType", (Boolean.to_query f)));
           Util.option_map v.instance_pools_to_use_count
             (fun f ->
                Query.Pair ("InstancePoolsToUseCount", (Integer.to_query f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInterruptionBehavior",
                    (SpotInstanceInterruptionBehavior.to_query f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                Query.Pair
                  ("AllocationStrategy", (SpotAllocationStrategy.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> ("max_total_price", (String.to_json f)));
           Util.option_map v.min_target_capacity
             (fun f -> ("min_target_capacity", (Integer.to_json f)));
           Util.option_map v.single_availability_zone
             (fun f -> ("single_availability_zone", (Boolean.to_json f)));
           Util.option_map v.single_instance_type
             (fun f -> ("single_instance_type", (Boolean.to_json f)));
           Util.option_map v.instance_pools_to_use_count
             (fun f -> ("instance_pools_to_use_count", (Integer.to_json f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                ("instance_interruption_behavior",
                  (SpotInstanceInterruptionBehavior.to_json f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                ("allocation_strategy", (SpotAllocationStrategy.to_json f)))])
    let parse xml =
      Some
        {
          allocation_strategy =
            (Util.option_bind (Xml.member "allocationStrategy" xml)
               SpotAllocationStrategy.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "instanceInterruptionBehavior" xml)
               SpotInstanceInterruptionBehavior.parse);
          instance_pools_to_use_count =
            (Util.option_bind (Xml.member "instancePoolsToUseCount" xml)
               Integer.parse);
          single_instance_type =
            (Util.option_bind (Xml.member "singleInstanceType" xml)
               Boolean.parse);
          single_availability_zone =
            (Util.option_bind (Xml.member "singleAvailabilityZone" xml)
               Boolean.parse);
          min_target_capacity =
            (Util.option_bind (Xml.member "minTargetCapacity" xml)
               Integer.parse);
          max_total_price =
            (Util.option_bind (Xml.member "maxTotalPrice" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.allocation_strategy
                    (fun f ->
                       Ezxmlm.make_tag "allocationStrategy"
                         ([], (SpotAllocationStrategy.to_xml f)))])
                @
                [Util.option_map v.instance_interruption_behavior
                   (fun f ->
                      Ezxmlm.make_tag "instanceInterruptionBehavior"
                        ([], (SpotInstanceInterruptionBehavior.to_xml f)))])
               @
               [Util.option_map v.instance_pools_to_use_count
                  (fun f ->
                     Ezxmlm.make_tag "instancePoolsToUseCount"
                       ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.single_instance_type
                 (fun f ->
                    Ezxmlm.make_tag "singleInstanceType"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.single_availability_zone
                (fun f ->
                   Ezxmlm.make_tag "singleAvailabilityZone"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.min_target_capacity
               (fun f ->
                  Ezxmlm.make_tag "minTargetCapacity"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.max_total_price
              (fun f ->
                 Ezxmlm.make_tag "maxTotalPrice" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the configuration of Spot Instances in an EC2 Fleet.</p>"]
module TargetCapacitySpecification =
  struct
    type t =
      {
      total_target_capacity: Integer.t option
        [@ocaml.doc
          "<p>The number of units to request, filled using <code>DefaultTargetCapacityType</code>.</p>"];
      on_demand_target_capacity: Integer.t option
        [@ocaml.doc
          "<p>The number of On-Demand units to request. If you specify a target capacity for Spot units, you cannot specify a target capacity for On-Demand units.</p>"];
      spot_target_capacity: Integer.t option
        [@ocaml.doc
          "<p>The maximum number of Spot units to launch. If you specify a target capacity for On-Demand units, you cannot specify a target capacity for Spot units.</p>"];
      default_target_capacity_type: DefaultTargetCapacityType.t option
        [@ocaml.doc
          "<p>The default <code>TotalTargetCapacity</code>, which is either <code>Spot</code> or <code>On-Demand</code>.</p>"]}
    [@@ocaml.doc
      "<p>The number of units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>, you can specify a target capacity of 0 and add capacity later.</p> <p>You can use the On-Demand Instance <code>MaxTotalPrice</code> parameter, the Spot Instance <code>MaxTotalPrice</code>, or both to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, EC2 Fleet will launch instances until it reaches the maximum amount that you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasn\226\128\153t met the target capacity. The <code>MaxTotalPrice</code> parameters are located in and </p>"]
    let make ?total_target_capacity  ?on_demand_target_capacity 
      ?spot_target_capacity  ?default_target_capacity_type  () =
      {
        total_target_capacity;
        on_demand_target_capacity;
        spot_target_capacity;
        default_target_capacity_type
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.default_target_capacity_type
              (fun f ->
                 Query.Pair
                   ("DefaultTargetCapacityType",
                     (DefaultTargetCapacityType.to_query f)));
           Util.option_map v.spot_target_capacity
             (fun f ->
                Query.Pair ("SpotTargetCapacity", (Integer.to_query f)));
           Util.option_map v.on_demand_target_capacity
             (fun f ->
                Query.Pair ("OnDemandTargetCapacity", (Integer.to_query f)));
           Util.option_map v.total_target_capacity
             (fun f ->
                Query.Pair ("TotalTargetCapacity", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.default_target_capacity_type
              (fun f ->
                 ("default_target_capacity_type",
                   (DefaultTargetCapacityType.to_json f)));
           Util.option_map v.spot_target_capacity
             (fun f -> ("spot_target_capacity", (Integer.to_json f)));
           Util.option_map v.on_demand_target_capacity
             (fun f -> ("on_demand_target_capacity", (Integer.to_json f)));
           Util.option_map v.total_target_capacity
             (fun f -> ("total_target_capacity", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          total_target_capacity =
            (Util.option_bind (Xml.member "totalTargetCapacity" xml)
               Integer.parse);
          on_demand_target_capacity =
            (Util.option_bind (Xml.member "onDemandTargetCapacity" xml)
               Integer.parse);
          spot_target_capacity =
            (Util.option_bind (Xml.member "spotTargetCapacity" xml)
               Integer.parse);
          default_target_capacity_type =
            (Util.option_bind (Xml.member "defaultTargetCapacityType" xml)
               DefaultTargetCapacityType.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.total_target_capacity
                 (fun f ->
                    Ezxmlm.make_tag "totalTargetCapacity"
                      ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.on_demand_target_capacity
                (fun f ->
                   Ezxmlm.make_tag "onDemandTargetCapacity"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.spot_target_capacity
               (fun f ->
                  Ezxmlm.make_tag "spotTargetCapacity"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.default_target_capacity_type
              (fun f ->
                 Ezxmlm.make_tag "defaultTargetCapacityType"
                   ([], (DefaultTargetCapacityType.to_xml f)))])
  end[@@ocaml.doc
       "<p>The number of units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>, you can specify a target capacity of 0 and add capacity later.</p> <p>You can use the On-Demand Instance <code>MaxTotalPrice</code> parameter, the Spot Instance <code>MaxTotalPrice</code>, or both to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, EC2 Fleet will launch instances until it reaches the maximum amount that you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasn\226\128\153t met the target capacity. The <code>MaxTotalPrice</code> parameters are located in and </p>"]
module ActivityStatus =
  struct
    type t =
      | Error 
      | Pending_fulfillment 
      | Pending_termination 
      | Fulfilled 
    let str_to_t =
      [("fulfilled", Fulfilled);
      ("pending_termination", Pending_termination);
      ("pending_fulfillment", Pending_fulfillment);
      ("error", Error)]
    let t_to_str =
      [(Fulfilled, "fulfilled");
      (Pending_termination, "pending_termination");
      (Pending_fulfillment, "pending_fulfillment");
      (Error, "error")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module SpotFleetRequestConfigData =
  struct
    type t =
      {
      allocation_strategy: AllocationStrategy.t option
        [@ocaml.doc
          "<p>Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet request.</p> <p>If the allocation strategy is <code>lowestPrice</code>, Spot Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.</p> <p>If the allocation strategy is <code>diversified</code>, Spot Fleet launches instances from all the Spot Instance pools that you specify.</p> <p>If the allocation strategy is <code>capacityOptimized</code>, Spot Fleet launches instances from Spot Instance pools with optimal capacity for the number of instances that are launching.</p>"];
      on_demand_allocation_strategy: OnDemandAllocationStrategy.t option
        [@ocaml.doc
          "<p>The order of the launch template overrides to use in fulfilling On-Demand capacity. If you specify <code>lowestPrice</code>, Spot Fleet uses price to determine the order, launching the lowest price first. If you specify <code>prioritized</code>, Spot Fleet uses the priority that you assign to each Spot Fleet launch template override, launching the highest priority first. If you do not specify a value, Spot Fleet defaults to <code>lowestPrice</code>.</p>"];
      client_token: String.t option
        [@ocaml.doc
          "<p>A unique, case-sensitive identifier that you provide to ensure the idempotency of your listings. This helps to avoid duplicate listings. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html\">Ensuring Idempotency</a>.</p>"];
      excess_capacity_termination_policy:
        ExcessCapacityTerminationPolicy.t option
        [@ocaml.doc
          "<p>Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.</p>"];
      fulfilled_capacity: Double.t option
        [@ocaml.doc
          "<p>The number of units fulfilled by this request compared to the set target capacity. You cannot set this value.</p>"];
      on_demand_fulfilled_capacity: Double.t option
        [@ocaml.doc
          "<p>The number of On-Demand units fulfilled by this request compared to the set target On-Demand capacity.</p>"];
      iam_fleet_role: String.t
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants the Spot Fleet the permission to request, launch, terminate, and tag instances on your behalf. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites\">Spot Fleet Prerequisites</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>. Spot Fleet can terminate Spot Instances on your behalf when you cancel its Spot Fleet request using <a>CancelSpotFleetRequests</a> or when the Spot Fleet request expires, if you set <code>TerminateInstancesWithExpiration</code>.</p>"];
      launch_specifications: LaunchSpecsList.t
        [@ocaml.doc
          "<p>The launch specifications for the Spot Fleet request. If you specify <code>LaunchSpecifications</code>, you can't specify <code>LaunchTemplateConfigs</code>. If you include On-Demand capacity in your request, you must use <code>LaunchTemplateConfigs</code>.</p>"];
      launch_template_configs: LaunchTemplateConfigList.t
        [@ocaml.doc
          "<p>The launch template and overrides. If you specify <code>LaunchTemplateConfigs</code>, you can't specify <code>LaunchSpecifications</code>. If you include On-Demand capacity in your request, you must use <code>LaunchTemplateConfigs</code>.</p>"];
      spot_price: String.t option
        [@ocaml.doc
          "<p>The maximum price per unit hour that you are willing to pay for a Spot Instance. The default is the On-Demand price.</p>"];
      target_capacity: Integer.t
        [@ocaml.doc
          "<p>The number of units to request for the Spot Fleet. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>, you can specify a target capacity of 0 and add capacity later.</p>"];
      on_demand_target_capacity: Integer.t option
        [@ocaml.doc
          "<p>The number of On-Demand units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>, you can specify a target capacity of 0 and add capacity later.</p>"];
      on_demand_max_total_price: String.t option
        [@ocaml.doc
          "<p>The maximum amount per hour for On-Demand Instances that you're willing to pay. You can use the <code>onDemandMaxTotalPrice</code> parameter, the <code>spotMaxTotalPrice</code> parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasn\226\128\153t met the target capacity.</p>"];
      spot_max_total_price: String.t option
        [@ocaml.doc
          "<p>The maximum amount per hour for Spot Instances that you're willing to pay. You can use the <code>spotdMaxTotalPrice</code> parameter, the <code>onDemandMaxTotalPrice</code> parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasn\226\128\153t met the target capacity.</p>"];
      terminate_instances_with_expiration: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether running Spot Instances are terminated when the Spot Fleet request expires.</p>"];
      type_: FleetType.t option
        [@ocaml.doc
          "<p>The type of request. Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is <code>request</code>, the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is <code>maintain</code>, the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: <code>maintain</code>. <code>instant</code> is listed but is not used by Spot Fleet.</p>"];
      valid_from: DateTime.t option
        [@ocaml.doc
          "<p>The start date and time of the request, in UTC format (<i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). By default, Amazon EC2 starts fulfilling the request immediately.</p>"];
      valid_until: DateTime.t option
        [@ocaml.doc
          "<p>The end date and time of the request, in UTC format (<i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). After the end date and time, no new Spot Instance requests are placed or able to fulfill the request. If no value is specified, the Spot Fleet request remains until you cancel it.</p>"];
      replace_unhealthy_instances: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether Spot Fleet should replace unhealthy instances.</p>"];
      instance_interruption_behavior: InstanceInterruptionBehavior.t option
        [@ocaml.doc
          "<p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>"];
      load_balancers_config: LoadBalancersConfig.t option
        [@ocaml.doc
          "<p>One or more Classic Load Balancers and target groups to attach to the Spot Fleet request. Spot Fleet registers the running Spot Instances with the specified Classic Load Balancers and target groups.</p> <p>With Network Load Balancers, Spot Fleet cannot register instances that have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.</p>"];
      instance_pools_to_use_count: Integer.t option
        [@ocaml.doc
          "<p>The number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot <b>AllocationStrategy</b> is set to <code>lowest-price</code>. Spot Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.</p>"]}
    [@@ocaml.doc
      "<p>Describes the configuration of a Spot Fleet request.</p>"]
    let make ?allocation_strategy  ?on_demand_allocation_strategy 
      ?client_token  ?excess_capacity_termination_policy  ?fulfilled_capacity
       ?on_demand_fulfilled_capacity  ~iam_fleet_role 
      ?(launch_specifications= [])  ?(launch_template_configs= []) 
      ?spot_price  ~target_capacity  ?on_demand_target_capacity 
      ?on_demand_max_total_price  ?spot_max_total_price 
      ?terminate_instances_with_expiration  ?type_  ?valid_from  ?valid_until
       ?replace_unhealthy_instances  ?instance_interruption_behavior 
      ?load_balancers_config  ?instance_pools_to_use_count  () =
      {
        allocation_strategy;
        on_demand_allocation_strategy;
        client_token;
        excess_capacity_termination_policy;
        fulfilled_capacity;
        on_demand_fulfilled_capacity;
        iam_fleet_role;
        launch_specifications;
        launch_template_configs;
        spot_price;
        target_capacity;
        on_demand_target_capacity;
        on_demand_max_total_price;
        spot_max_total_price;
        terminate_instances_with_expiration;
        type_;
        valid_from;
        valid_until;
        replace_unhealthy_instances;
        instance_interruption_behavior;
        load_balancers_config;
        instance_pools_to_use_count
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_pools_to_use_count
              (fun f ->
                 Query.Pair ("InstancePoolsToUseCount", (Integer.to_query f)));
           Util.option_map v.load_balancers_config
             (fun f ->
                Query.Pair
                  ("LoadBalancersConfig", (LoadBalancersConfig.to_query f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInterruptionBehavior",
                    (InstanceInterruptionBehavior.to_query f)));
           Util.option_map v.replace_unhealthy_instances
             (fun f ->
                Query.Pair
                  ("ReplaceUnhealthyInstances", (Boolean.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.valid_from
             (fun f -> Query.Pair ("ValidFrom", (DateTime.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (FleetType.to_query f)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                Query.Pair
                  ("TerminateInstancesWithExpiration", (Boolean.to_query f)));
           Util.option_map v.spot_max_total_price
             (fun f -> Query.Pair ("SpotMaxTotalPrice", (String.to_query f)));
           Util.option_map v.on_demand_max_total_price
             (fun f ->
                Query.Pair ("OnDemandMaxTotalPrice", (String.to_query f)));
           Util.option_map v.on_demand_target_capacity
             (fun f ->
                Query.Pair ("OnDemandTargetCapacity", (Integer.to_query f)));
           Some
             (Query.Pair
                ("TargetCapacity", (Integer.to_query v.target_capacity)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Some
             (Query.Pair
                ("LaunchTemplateConfigs",
                  (LaunchTemplateConfigList.to_query
                     v.launch_template_configs)));
           Some
             (Query.Pair
                ("LaunchSpecifications",
                  (LaunchSpecsList.to_query v.launch_specifications)));
           Some
             (Query.Pair ("IamFleetRole", (String.to_query v.iam_fleet_role)));
           Util.option_map v.on_demand_fulfilled_capacity
             (fun f ->
                Query.Pair ("OnDemandFulfilledCapacity", (Double.to_query f)));
           Util.option_map v.fulfilled_capacity
             (fun f -> Query.Pair ("FulfilledCapacity", (Double.to_query f)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                Query.Pair
                  ("ExcessCapacityTerminationPolicy",
                    (ExcessCapacityTerminationPolicy.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.on_demand_allocation_strategy
             (fun f ->
                Query.Pair
                  ("OnDemandAllocationStrategy",
                    (OnDemandAllocationStrategy.to_query f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                Query.Pair
                  ("AllocationStrategy", (AllocationStrategy.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_pools_to_use_count
              (fun f -> ("instance_pools_to_use_count", (Integer.to_json f)));
           Util.option_map v.load_balancers_config
             (fun f ->
                ("load_balancers_config", (LoadBalancersConfig.to_json f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                ("instance_interruption_behavior",
                  (InstanceInterruptionBehavior.to_json f)));
           Util.option_map v.replace_unhealthy_instances
             (fun f -> ("replace_unhealthy_instances", (Boolean.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.valid_from
             (fun f -> ("valid_from", (DateTime.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (FleetType.to_json f)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                ("terminate_instances_with_expiration", (Boolean.to_json f)));
           Util.option_map v.spot_max_total_price
             (fun f -> ("spot_max_total_price", (String.to_json f)));
           Util.option_map v.on_demand_max_total_price
             (fun f -> ("on_demand_max_total_price", (String.to_json f)));
           Util.option_map v.on_demand_target_capacity
             (fun f -> ("on_demand_target_capacity", (Integer.to_json f)));
           Some ("target_capacity", (Integer.to_json v.target_capacity));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Some
             ("launch_template_configs",
               (LaunchTemplateConfigList.to_json v.launch_template_configs));
           Some
             ("launch_specifications",
               (LaunchSpecsList.to_json v.launch_specifications));
           Some ("iam_fleet_role", (String.to_json v.iam_fleet_role));
           Util.option_map v.on_demand_fulfilled_capacity
             (fun f -> ("on_demand_fulfilled_capacity", (Double.to_json f)));
           Util.option_map v.fulfilled_capacity
             (fun f -> ("fulfilled_capacity", (Double.to_json f)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                ("excess_capacity_termination_policy",
                  (ExcessCapacityTerminationPolicy.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.on_demand_allocation_strategy
             (fun f ->
                ("on_demand_allocation_strategy",
                  (OnDemandAllocationStrategy.to_json f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                ("allocation_strategy", (AllocationStrategy.to_json f)))])
    let parse xml =
      Some
        {
          allocation_strategy =
            (Util.option_bind (Xml.member "allocationStrategy" xml)
               AllocationStrategy.parse);
          on_demand_allocation_strategy =
            (Util.option_bind (Xml.member "onDemandAllocationStrategy" xml)
               OnDemandAllocationStrategy.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          excess_capacity_termination_policy =
            (Util.option_bind
               (Xml.member "excessCapacityTerminationPolicy" xml)
               ExcessCapacityTerminationPolicy.parse);
          fulfilled_capacity =
            (Util.option_bind (Xml.member "fulfilledCapacity" xml)
               Double.parse);
          on_demand_fulfilled_capacity =
            (Util.option_bind (Xml.member "onDemandFulfilledCapacity" xml)
               Double.parse);
          iam_fleet_role =
            (Xml.required "iamFleetRole"
               (Util.option_bind (Xml.member "iamFleetRole" xml) String.parse));
          launch_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchSpecifications" xml)
                  LaunchSpecsList.parse));
          launch_template_configs =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchTemplateConfigs" xml)
                  LaunchTemplateConfigList.parse));
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          target_capacity =
            (Xml.required "targetCapacity"
               (Util.option_bind (Xml.member "targetCapacity" xml)
                  Integer.parse));
          on_demand_target_capacity =
            (Util.option_bind (Xml.member "onDemandTargetCapacity" xml)
               Integer.parse);
          on_demand_max_total_price =
            (Util.option_bind (Xml.member "onDemandMaxTotalPrice" xml)
               String.parse);
          spot_max_total_price =
            (Util.option_bind (Xml.member "spotMaxTotalPrice" xml)
               String.parse);
          terminate_instances_with_expiration =
            (Util.option_bind
               (Xml.member "terminateInstancesWithExpiration" xml)
               Boolean.parse);
          type_ = (Util.option_bind (Xml.member "type" xml) FleetType.parse);
          valid_from =
            (Util.option_bind (Xml.member "validFrom" xml) DateTime.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          replace_unhealthy_instances =
            (Util.option_bind (Xml.member "replaceUnhealthyInstances" xml)
               Boolean.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "instanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse);
          load_balancers_config =
            (Util.option_bind (Xml.member "loadBalancersConfig" xml)
               LoadBalancersConfig.parse);
          instance_pools_to_use_count =
            (Util.option_bind (Xml.member "instancePoolsToUseCount" xml)
               Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((((((([] @
                                [Util.option_map v.allocation_strategy
                                   (fun f ->
                                      Ezxmlm.make_tag "allocationStrategy"
                                        ([], (AllocationStrategy.to_xml f)))])
                               @
                               [Util.option_map
                                  v.on_demand_allocation_strategy
                                  (fun f ->
                                     Ezxmlm.make_tag
                                       "onDemandAllocationStrategy"
                                       ([],
                                         (OnDemandAllocationStrategy.to_xml f)))])
                              @
                              [Util.option_map v.client_token
                                 (fun f ->
                                    Ezxmlm.make_tag "clientToken"
                                      ([], (String.to_xml f)))])
                             @
                             [Util.option_map
                                v.excess_capacity_termination_policy
                                (fun f ->
                                   Ezxmlm.make_tag
                                     "excessCapacityTerminationPolicy"
                                     ([],
                                       (ExcessCapacityTerminationPolicy.to_xml
                                          f)))])
                            @
                            [Util.option_map v.fulfilled_capacity
                               (fun f ->
                                  Ezxmlm.make_tag "fulfilledCapacity"
                                    ([], (Double.to_xml f)))])
                           @
                           [Util.option_map v.on_demand_fulfilled_capacity
                              (fun f ->
                                 Ezxmlm.make_tag "onDemandFulfilledCapacity"
                                   ([], (Double.to_xml f)))])
                          @
                          [Some
                             (Ezxmlm.make_tag "iamFleetRole"
                                ([], (String.to_xml v.iam_fleet_role)))])
                         @
                         (List.map
                            (fun x ->
                               Some
                                 (Ezxmlm.make_tag "launchSpecifications"
                                    ([], (LaunchSpecsList.to_xml [x]))))
                            v.launch_specifications))
                        @
                        (List.map
                           (fun x ->
                              Some
                                (Ezxmlm.make_tag "launchTemplateConfigs"
                                   ([],
                                     (LaunchTemplateConfigList.to_xml [x]))))
                           v.launch_template_configs))
                       @
                       [Util.option_map v.spot_price
                          (fun f ->
                             Ezxmlm.make_tag "spotPrice"
                               ([], (String.to_xml f)))])
                      @
                      [Some
                         (Ezxmlm.make_tag "targetCapacity"
                            ([], (Integer.to_xml v.target_capacity)))])
                     @
                     [Util.option_map v.on_demand_target_capacity
                        (fun f ->
                           Ezxmlm.make_tag "onDemandTargetCapacity"
                             ([], (Integer.to_xml f)))])
                    @
                    [Util.option_map v.on_demand_max_total_price
                       (fun f ->
                          Ezxmlm.make_tag "onDemandMaxTotalPrice"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.spot_max_total_price
                      (fun f ->
                         Ezxmlm.make_tag "spotMaxTotalPrice"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.terminate_instances_with_expiration
                     (fun f ->
                        Ezxmlm.make_tag "terminateInstancesWithExpiration"
                          ([], (Boolean.to_xml f)))])
                 @
                 [Util.option_map v.type_
                    (fun f ->
                       Ezxmlm.make_tag "type" ([], (FleetType.to_xml f)))])
                @
                [Util.option_map v.valid_from
                   (fun f ->
                      Ezxmlm.make_tag "validFrom" ([], (DateTime.to_xml f)))])
               @
               [Util.option_map v.valid_until
                  (fun f ->
                     Ezxmlm.make_tag "validUntil" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.replace_unhealthy_instances
                 (fun f ->
                    Ezxmlm.make_tag "replaceUnhealthyInstances"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.instance_interruption_behavior
                (fun f ->
                   Ezxmlm.make_tag "instanceInterruptionBehavior"
                     ([], (InstanceInterruptionBehavior.to_xml f)))])
            @
            [Util.option_map v.load_balancers_config
               (fun f ->
                  Ezxmlm.make_tag "loadBalancersConfig"
                    ([], (LoadBalancersConfig.to_xml f)))])
           @
           [Util.option_map v.instance_pools_to_use_count
              (fun f ->
                 Ezxmlm.make_tag "instancePoolsToUseCount"
                   ([], (Integer.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the configuration of a Spot Fleet request.</p>"]
module AvailabilityZoneMessageList =
  struct
    type t = AvailabilityZoneMessage.t list
    let make elems () = elems
    let to_query v = Query.to_query_list AvailabilityZoneMessage.to_query v
    let to_headers v =
      Headers.to_headers_list AvailabilityZoneMessage.to_headers v
    let to_json v = `List (List.map AvailabilityZoneMessage.to_json v)
    let parse xml =
      Util.option_all
        (List.map AvailabilityZoneMessage.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (AvailabilityZoneMessage.to_xml x)))
        v
  end
module AvailabilityZoneOptInStatus =
  struct
    type t =
      | Opt_in_not_required 
      | Opted_in 
      | Not_opted_in 
    let str_to_t =
      [("not-opted-in", Not_opted_in);
      ("opted-in", Opted_in);
      ("opt-in-not-required", Opt_in_not_required)]
    let t_to_str =
      [(Not_opted_in, "not-opted-in");
      (Opted_in, "opted-in");
      (Opt_in_not_required, "opt-in-not-required")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module AvailabilityZoneState =
  struct
    type t =
      | Available 
      | Information 
      | Impaired 
      | Unavailable 
    let str_to_t =
      [("unavailable", Unavailable);
      ("impaired", Impaired);
      ("information", Information);
      ("available", Available)]
    let t_to_str =
      [(Unavailable, "unavailable");
      (Impaired, "impaired");
      (Information, "information");
      (Available, "available")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module VolumeStatusActionsList =
  struct
    type t = VolumeStatusAction.t list
    let make elems () = elems
    let to_query v = Query.to_query_list VolumeStatusAction.to_query v
    let to_headers v =
      Headers.to_headers_list VolumeStatusAction.to_headers v
    let to_json v = `List (List.map VolumeStatusAction.to_json v)
    let parse xml =
      Util.option_all
        (List.map VolumeStatusAction.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (VolumeStatusAction.to_xml x))) v
  end
module VolumeStatusEventsList =
  struct
    type t = VolumeStatusEvent.t list
    let make elems () = elems
    let to_query v = Query.to_query_list VolumeStatusEvent.to_query v
    let to_headers v = Headers.to_headers_list VolumeStatusEvent.to_headers v
    let to_json v = `List (List.map VolumeStatusEvent.to_json v)
    let parse xml =
      Util.option_all
        (List.map VolumeStatusEvent.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VolumeStatusEvent.to_xml x)))
        v
  end
module VolumeStatusInfo =
  struct
    type t =
      {
      details: VolumeStatusDetailsList.t
        [@ocaml.doc "<p>The details of the volume status.</p>"];
      status: VolumeStatusInfoStatus.t option
        [@ocaml.doc "<p>The status of the volume.</p>"]}[@@ocaml.doc
                                                          "<p>Describes the status of a volume.</p>"]
    let make ?(details= [])  ?status  () = { details; status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair ("Status", (VolumeStatusInfoStatus.to_query f)));
           Some
             (Query.Pair
                ("Details", (VolumeStatusDetailsList.to_query v.details)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (VolumeStatusInfoStatus.to_json f)));
           Some ("details", (VolumeStatusDetailsList.to_json v.details))])
    let parse xml =
      Some
        {
          details =
            (Util.of_option []
               (Util.option_bind (Xml.member "details" xml)
                  VolumeStatusDetailsList.parse));
          status =
            (Util.option_bind (Xml.member "status" xml)
               VolumeStatusInfoStatus.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "details"
                       ([], (VolumeStatusDetailsList.to_xml [x])))) v.details))
           @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status"
                   ([], (VolumeStatusInfoStatus.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the status of a volume.</p>"]
module TransitGatewayRouteTableState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ClientVpnAuthorizationRuleStatus =
  struct
    type t =
      {
      code: ClientVpnAuthorizationRuleStatusCode.t option
        [@ocaml.doc "<p>The state of the authorization rule.</p>"];
      message: String.t option
        [@ocaml.doc
          "<p>A message about the status of the authorization rule, if applicable.</p>"]}
    [@@ocaml.doc "<p>Describes the state of an authorization rule.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code", (ClientVpnAuthorizationRuleStatusCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code", (ClientVpnAuthorizationRuleStatusCode.to_json f)))])
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               ClientVpnAuthorizationRuleStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (ClientVpnAuthorizationRuleStatusCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the state of an authorization rule.</p>"]
module UnsuccessfulInstanceCreditSpecificationItemError =
  struct
    type t =
      {
      code: UnsuccessfulInstanceCreditSpecificationErrorCode.t option
        [@ocaml.doc "<p>The error code.</p>"];
      message: String.t option
        [@ocaml.doc "<p>The applicable error message.</p>"]}[@@ocaml.doc
                                                              "<p>Information about the error for the burstable performance instance whose credit option for CPU usage was not modified.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code",
                    (UnsuccessfulInstanceCreditSpecificationErrorCode.to_query
                       f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code",
                  (UnsuccessfulInstanceCreditSpecificationErrorCode.to_json f)))])
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               UnsuccessfulInstanceCreditSpecificationErrorCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([],
                      (UnsuccessfulInstanceCreditSpecificationErrorCode.to_xml
                         f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Information about the error for the burstable performance instance whose credit option for CPU usage was not modified.</p>"]
module PricingDetailsList =
  struct
    type t = PricingDetail.t list
    let make elems () = elems
    let to_query v = Query.to_query_list PricingDetail.to_query v
    let to_headers v = Headers.to_headers_list PricingDetail.to_headers v
    let to_json v = `List (List.map PricingDetail.to_json v)
    let parse xml =
      Util.option_all (List.map PricingDetail.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PricingDetail.to_xml x))) v
  end
module InstanceList =
  struct
    type t = Instance.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Instance.to_query v
    let to_headers v = Headers.to_headers_list Instance.to_headers v
    let to_json v = `List (List.map Instance.to_json v)
    let parse xml =
      Util.option_all (List.map Instance.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Instance.to_xml x)))
        v
  end
module PublicIpv4PoolRangeSet =
  struct
    type t = PublicIpv4PoolRange.t list
    let make elems () = elems
    let to_query v = Query.to_query_list PublicIpv4PoolRange.to_query v
    let to_headers v =
      Headers.to_headers_list PublicIpv4PoolRange.to_headers v
    let to_json v = `List (List.map PublicIpv4PoolRange.to_json v)
    let parse xml =
      Util.option_all
        (List.map PublicIpv4PoolRange.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (PublicIpv4PoolRange.to_xml x))) v
  end
module VpcCidrBlockAssociationSet =
  struct
    type t = VpcCidrBlockAssociation.t list
    let make elems () = elems
    let to_query v = Query.to_query_list VpcCidrBlockAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list VpcCidrBlockAssociation.to_headers v
    let to_json v = `List (List.map VpcCidrBlockAssociation.to_json v)
    let parse xml =
      Util.option_all
        (List.map VpcCidrBlockAssociation.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (VpcCidrBlockAssociation.to_xml x)))
        v
  end
module VpcIpv6CidrBlockAssociationSet =
  struct
    type t = VpcIpv6CidrBlockAssociation.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list VpcIpv6CidrBlockAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list VpcIpv6CidrBlockAssociation.to_headers v
    let to_json v = `List (List.map VpcIpv6CidrBlockAssociation.to_json v)
    let parse xml =
      Util.option_all
        (List.map VpcIpv6CidrBlockAssociation.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (VpcIpv6CidrBlockAssociation.to_xml x))) v
  end
module VpcState =
  struct
    type t =
      | Pending 
      | Available 
    let str_to_t = [("available", Available); ("pending", Pending)]
    let t_to_str = [(Available, "available"); (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module SubnetIpv6CidrBlockAssociationSet =
  struct
    type t = SubnetIpv6CidrBlockAssociation.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list SubnetIpv6CidrBlockAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list SubnetIpv6CidrBlockAssociation.to_headers v
    let to_json v = `List (List.map SubnetIpv6CidrBlockAssociation.to_json v)
    let parse xml =
      Util.option_all
        (List.map SubnetIpv6CidrBlockAssociation.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (SubnetIpv6CidrBlockAssociation.to_xml x))) v
  end
module SubnetState =
  struct
    type t =
      | Pending 
      | Available 
    let str_to_t = [("available", Available); ("pending", Pending)]
    let t_to_str = [(Available, "available"); (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ElasticGpuHealth =
  struct
    type t =
      {
      status: ElasticGpuStatus.t option
        [@ocaml.doc "<p>The health status.</p>"]}[@@ocaml.doc
                                                   "<p>Describes the status of an Elastic Graphics accelerator.</p>"]
    let make ?status  () = { status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (ElasticGpuStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (ElasticGpuStatus.to_json f)))])
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ElasticGpuStatus.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status" ([], (ElasticGpuStatus.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the status of an Elastic Graphics accelerator.</p>"]
module ElasticGpuState =
  struct
    type t =
      | ATTACHED 
    let str_to_t = [("ATTACHED", ATTACHED)]
    let t_to_str = [(ATTACHED, "ATTACHED")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ImportImageLicenseSpecificationListResponse =
  struct
    type t = ImportImageLicenseConfigurationResponse.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list ImportImageLicenseConfigurationResponse.to_query v
    let to_headers v =
      Headers.to_headers_list
        ImportImageLicenseConfigurationResponse.to_headers v
    let to_json v =
      `List (List.map ImportImageLicenseConfigurationResponse.to_json v)
    let parse xml =
      Util.option_all
        (List.map ImportImageLicenseConfigurationResponse.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ImportImageLicenseConfigurationResponse.to_xml x))) v
  end
module SnapshotDetailList =
  struct
    type t = SnapshotDetail.t list
    let make elems () = elems
    let to_query v = Query.to_query_list SnapshotDetail.to_query v
    let to_headers v = Headers.to_headers_list SnapshotDetail.to_headers v
    let to_json v = `List (List.map SnapshotDetail.to_json v)
    let parse xml =
      Util.option_all
        (List.map SnapshotDetail.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (SnapshotDetail.to_xml x))) v
  end
module UserBucket =
  struct
    type t =
      {
      s3_bucket: String.t option
        [@ocaml.doc
          "<p>The name of the S3 bucket where the disk image is located.</p>"];
      s3_key: String.t option
        [@ocaml.doc "<p>The file name of the disk image.</p>"]}[@@ocaml.doc
                                                                 "<p>Describes the S3 bucket for the disk image.</p>"]
    let make ?s3_bucket  ?s3_key  () = { s3_bucket; s3_key }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> Query.Pair ("S3Key", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> ("s3_key", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)))])
    let parse xml =
      Some
        {
          s3_bucket =
            (Util.option_bind (Xml.member "S3Bucket" xml) String.parse);
          s3_key = (Util.option_bind (Xml.member "S3Key" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.s3_bucket
               (fun f -> Ezxmlm.make_tag "S3Bucket" ([], (String.to_xml f)))])
           @
           [Util.option_map v.s3_key
              (fun f -> Ezxmlm.make_tag "S3Key" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the S3 bucket for the disk image.</p>"]
module LocalGatewayRouteState =
  struct
    type t =
      | Pending 
      | Active 
      | Blackhole 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("blackhole", Blackhole);
      ("active", Active);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Blackhole, "blackhole");
      (Active, "active");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module LocalGatewayRouteType =
  struct
    type t =
      | Static 
      | Propagated 
    let str_to_t = [("propagated", Propagated); ("static", Static)]
    let t_to_str = [(Propagated, "propagated"); (Static, "static")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ScheduledInstancesBlockDeviceMapping =
  struct
    type t =
      {
      device_name: String.t option
        [@ocaml.doc
          "<p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>"];
      ebs: ScheduledInstancesEbs.t option
        [@ocaml.doc
          "<p>Parameters used to set up EBS volumes automatically when the instance is launched.</p>"];
      no_device: String.t option
        [@ocaml.doc
          "<p>Suppresses the specified device included in the block device mapping of the AMI.</p>"];
      virtual_name: String.t option
        [@ocaml.doc
          "<p>The virtual device name (<code>ephemeral</code>N). Instance store volumes are numbered starting from 0. An instance type with two available instance store volumes can specify mappings for <code>ephemeral0</code> and <code>ephemeral1</code>. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.</p> <p>Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.</p>"]}
    [@@ocaml.doc
      "<p>Describes a block device mapping for a Scheduled Instance.</p>"]
    let make ?device_name  ?ebs  ?no_device  ?virtual_name  () =
      { device_name; ebs; no_device; virtual_name }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.virtual_name
              (fun f -> Query.Pair ("VirtualName", (String.to_query f)));
           Util.option_map v.no_device
             (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.ebs
             (fun f -> Query.Pair ("Ebs", (ScheduledInstancesEbs.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.virtual_name
              (fun f -> ("virtual_name", (String.to_json f)));
           Util.option_map v.no_device
             (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.ebs
             (fun f -> ("ebs", (ScheduledInstancesEbs.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "DeviceName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "Ebs" xml)
               ScheduledInstancesEbs.parse);
          no_device =
            (Util.option_bind (Xml.member "NoDevice" xml) String.parse);
          virtual_name =
            (Util.option_bind (Xml.member "VirtualName" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.device_name
                 (fun f ->
                    Ezxmlm.make_tag "DeviceName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.ebs
                (fun f ->
                   Ezxmlm.make_tag "Ebs"
                     ([], (ScheduledInstancesEbs.to_xml f)))])
            @
            [Util.option_map v.no_device
               (fun f -> Ezxmlm.make_tag "NoDevice" ([], (String.to_xml f)))])
           @
           [Util.option_map v.virtual_name
              (fun f -> Ezxmlm.make_tag "VirtualName" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a block device mapping for a Scheduled Instance.</p>"]
module ScheduledInstancesNetworkInterface =
  struct
    type t =
      {
      associate_public_ip_address: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether to assign a public IPv4 address to instances launched in a VPC. The public IPv4 address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is <code>true</code>.</p>"];
      delete_on_termination: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether to delete the interface when the instance is terminated.</p>"];
      description: String.t option [@ocaml.doc "<p>The description.</p>"];
      device_index: Integer.t option
        [@ocaml.doc
          "<p>The index of the device for the network interface attachment.</p>"];
      groups: ScheduledInstancesSecurityGroupIdSet.t
        [@ocaml.doc "<p>The IDs of the security groups.</p>"];
      ipv6_address_count: Integer.t option
        [@ocaml.doc
          "<p>The number of IPv6 addresses to assign to the network interface. The IPv6 addresses are automatically selected from the subnet range.</p>"];
      ipv6_addresses: ScheduledInstancesIpv6AddressList.t
        [@ocaml.doc
          "<p>The specific IPv6 addresses from the subnet range.</p>"];
      network_interface_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface.</p>"];
      private_ip_address: String.t option
        [@ocaml.doc
          "<p>The IPv4 address of the network interface within the subnet.</p>"];
      private_ip_address_configs: PrivateIpAddressConfigSet.t
        [@ocaml.doc "<p>The private IPv4 addresses.</p>"];
      secondary_private_ip_address_count: Integer.t option
        [@ocaml.doc "<p>The number of secondary private IPv4 addresses.</p>"];
      subnet_id: String.t option [@ocaml.doc "<p>The ID of the subnet.</p>"]}
    [@@ocaml.doc
      "<p>Describes a network interface for a Scheduled Instance.</p>"]
    let make ?associate_public_ip_address  ?delete_on_termination 
      ?description  ?device_index  ?(groups= [])  ?ipv6_address_count 
      ?(ipv6_addresses= [])  ?network_interface_id  ?private_ip_address 
      ?(private_ip_address_configs= [])  ?secondary_private_ip_address_count 
      ?subnet_id  () =
      {
        associate_public_ip_address;
        delete_on_termination;
        description;
        device_index;
        groups;
        ipv6_address_count;
        ipv6_addresses;
        network_interface_id;
        private_ip_address;
        private_ip_address_configs;
        secondary_private_ip_address_count;
        subnet_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddressConfig",
                  (PrivateIpAddressConfigSet.to_query
                     v.private_ip_address_configs)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6Address",
                  (ScheduledInstancesIpv6AddressList.to_query
                     v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("Group",
                  (ScheduledInstancesSecurityGroupIdSet.to_query v.groups)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.associate_public_ip_address
             (fun f ->
                Query.Pair ("AssociatePublicIpAddress", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_address_configs",
               (PrivateIpAddressConfigSet.to_json
                  v.private_ip_address_configs));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (ScheduledInstancesIpv6AddressList.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)));
           Some
             ("groups",
               (ScheduledInstancesSecurityGroupIdSet.to_json v.groups));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.associate_public_ip_address
             (fun f -> ("associate_public_ip_address", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          associate_public_ip_address =
            (Util.option_bind (Xml.member "AssociatePublicIpAddress" xml)
               Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "DeleteOnTermination" xml)
               Boolean.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          device_index =
            (Util.option_bind (Xml.member "DeviceIndex" xml) Integer.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "Group" xml)
                  ScheduledInstancesSecurityGroupIdSet.parse));
          ipv6_address_count =
            (Util.option_bind (Xml.member "Ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "Ipv6Address" xml)
                  ScheduledInstancesIpv6AddressList.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "NetworkInterfaceId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "PrivateIpAddress" xml)
               String.parse);
          private_ip_address_configs =
            (Util.of_option []
               (Util.option_bind (Xml.member "PrivateIpAddressConfig" xml)
                  PrivateIpAddressConfigSet.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "SecondaryPrivateIpAddressCount" xml)
               Integer.parse);
          subnet_id =
            (Util.option_bind (Xml.member "SubnetId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Util.option_map v.associate_public_ip_address
                         (fun f ->
                            Ezxmlm.make_tag "AssociatePublicIpAddress"
                              ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.delete_on_termination
                        (fun f ->
                           Ezxmlm.make_tag "DeleteOnTermination"
                             ([], (Boolean.to_xml f)))])
                    @
                    [Util.option_map v.description
                       (fun f ->
                          Ezxmlm.make_tag "Description"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.device_index
                      (fun f ->
                         Ezxmlm.make_tag "DeviceIndex"
                           ([], (Integer.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "Group"
                             ([],
                               (ScheduledInstancesSecurityGroupIdSet.to_xml
                                  [x])))) v.groups))
                 @
                 [Util.option_map v.ipv6_address_count
                    (fun f ->
                       Ezxmlm.make_tag "Ipv6AddressCount"
                         ([], (Integer.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "Ipv6Address"
                           ([],
                             (ScheduledInstancesIpv6AddressList.to_xml [x]))))
                   v.ipv6_addresses))
               @
               [Util.option_map v.network_interface_id
                  (fun f ->
                     Ezxmlm.make_tag "NetworkInterfaceId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.private_ip_address
                 (fun f ->
                    Ezxmlm.make_tag "PrivateIpAddress"
                      ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "PrivateIpAddressConfig"
                        ([], (PrivateIpAddressConfigSet.to_xml [x]))))
                v.private_ip_address_configs))
            @
            [Util.option_map v.secondary_private_ip_address_count
               (fun f ->
                  Ezxmlm.make_tag "SecondaryPrivateIpAddressCount"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.subnet_id
              (fun f -> Ezxmlm.make_tag "SubnetId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a network interface for a Scheduled Instance.</p>"]
module NatGatewayAddressList =
  struct
    type t = NatGatewayAddress.t list
    let make elems () = elems
    let to_query v = Query.to_query_list NatGatewayAddress.to_query v
    let to_headers v = Headers.to_headers_list NatGatewayAddress.to_headers v
    let to_json v = `List (List.map NatGatewayAddress.to_json v)
    let parse xml =
      Util.option_all
        (List.map NatGatewayAddress.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (NatGatewayAddress.to_xml x)))
        v
  end
module NatGatewayState =
  struct
    type t =
      | Pending 
      | Failed 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("failed", Failed);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Failed, "failed");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ProvisionedBandwidth =
  struct
    type t =
      {
      provision_time: DateTime.t option
        [@ocaml.doc
          "<p>Reserved. If you need to sustain traffic greater than the <a href=\"https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html\">documented limits</a>, contact us through the <a href=\"https://console.aws.amazon.com/support/home?\">Support Center</a>.</p>"];
      provisioned: String.t option
        [@ocaml.doc
          "<p>Reserved. If you need to sustain traffic greater than the <a href=\"https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html\">documented limits</a>, contact us through the <a href=\"https://console.aws.amazon.com/support/home?\">Support Center</a>.</p>"];
      request_time: DateTime.t option
        [@ocaml.doc
          "<p>Reserved. If you need to sustain traffic greater than the <a href=\"https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html\">documented limits</a>, contact us through the <a href=\"https://console.aws.amazon.com/support/home?\">Support Center</a>.</p>"];
      requested: String.t option
        [@ocaml.doc
          "<p>Reserved. If you need to sustain traffic greater than the <a href=\"https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html\">documented limits</a>, contact us through the <a href=\"https://console.aws.amazon.com/support/home?\">Support Center</a>.</p>"];
      status: String.t option
        [@ocaml.doc
          "<p>Reserved. If you need to sustain traffic greater than the <a href=\"https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html\">documented limits</a>, contact us through the <a href=\"https://console.aws.amazon.com/support/home?\">Support Center</a>.</p>"]}
    [@@ocaml.doc
      "<p>Reserved. If you need to sustain traffic greater than the <a href=\"https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html\">documented limits</a>, contact us through the <a href=\"https://console.aws.amazon.com/support/home?\">Support Center</a>.</p>"]
    let make ?provision_time  ?provisioned  ?request_time  ?requested 
      ?status  () =
      { provision_time; provisioned; request_time; requested; status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.requested
             (fun f -> Query.Pair ("Requested", (String.to_query f)));
           Util.option_map v.request_time
             (fun f -> Query.Pair ("RequestTime", (DateTime.to_query f)));
           Util.option_map v.provisioned
             (fun f -> Query.Pair ("Provisioned", (String.to_query f)));
           Util.option_map v.provision_time
             (fun f -> Query.Pair ("ProvisionTime", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (String.to_json f)));
           Util.option_map v.requested
             (fun f -> ("requested", (String.to_json f)));
           Util.option_map v.request_time
             (fun f -> ("request_time", (DateTime.to_json f)));
           Util.option_map v.provisioned
             (fun f -> ("provisioned", (String.to_json f)));
           Util.option_map v.provision_time
             (fun f -> ("provision_time", (DateTime.to_json f)))])
    let parse xml =
      Some
        {
          provision_time =
            (Util.option_bind (Xml.member "provisionTime" xml) DateTime.parse);
          provisioned =
            (Util.option_bind (Xml.member "provisioned" xml) String.parse);
          request_time =
            (Util.option_bind (Xml.member "requestTime" xml) DateTime.parse);
          requested =
            (Util.option_bind (Xml.member "requested" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.provision_time
                  (fun f ->
                     Ezxmlm.make_tag "provisionTime"
                       ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.provisioned
                 (fun f ->
                    Ezxmlm.make_tag "provisioned" ([], (String.to_xml f)))])
             @
             [Util.option_map v.request_time
                (fun f ->
                   Ezxmlm.make_tag "requestTime" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.requested
               (fun f -> Ezxmlm.make_tag "requested" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Reserved. If you need to sustain traffic greater than the <a href=\"https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html\">documented limits</a>, contact us through the <a href=\"https://console.aws.amazon.com/support/home?\">Support Center</a>.</p>"]
module LoadPermissionRequest =
  struct
    type t =
      {
      group: PermissionGroup.t option
        [@ocaml.doc "<p>The name of the group.</p>"];
      user_id: String.t option [@ocaml.doc "<p>The AWS account ID.</p>"]}
    [@@ocaml.doc "<p>Describes a load permission.</p>"]
    let make ?group  ?user_id  () = { group; user_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> Query.Pair ("UserId", (String.to_query f)));
           Util.option_map v.group
             (fun f -> Query.Pair ("Group", (PermissionGroup.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> ("user_id", (String.to_json f)));
           Util.option_map v.group
             (fun f -> ("group", (PermissionGroup.to_json f)))])
    let parse xml =
      Some
        {
          group =
            (Util.option_bind (Xml.member "Group" xml) PermissionGroup.parse);
          user_id = (Util.option_bind (Xml.member "UserId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.group
               (fun f ->
                  Ezxmlm.make_tag "Group" ([], (PermissionGroup.to_xml f)))])
           @
           [Util.option_map v.user_id
              (fun f -> Ezxmlm.make_tag "UserId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a load permission.</p>"]
module Filter =
  struct
    type t =
      {
      name: String.t
        [@ocaml.doc
          "<p>The name of the filter. Filter names are case-sensitive.</p>"];
      values: ValueStringList.t
        [@ocaml.doc
          "<p>The filter values. Filter values are case-sensitive.</p>"]}
    [@@ocaml.doc
      "<p>A filter name and value pair that is used to return a more specific list of results from a describe operation. Filters can be used to match a set of resources by specific criteria, such as tags, attributes, or IDs. The filters supported by a describe operation are documented with the describe operation. For example:</p> <ul> <li> <p> <a>DescribeAvailabilityZones</a> </p> </li> <li> <p> <a>DescribeImages</a> </p> </li> <li> <p> <a>DescribeInstances</a> </p> </li> <li> <p> <a>DescribeKeyPairs</a> </p> </li> <li> <p> <a>DescribeSecurityGroups</a> </p> </li> <li> <p> <a>DescribeSnapshots</a> </p> </li> <li> <p> <a>DescribeSubnets</a> </p> </li> <li> <p> <a>DescribeTags</a> </p> </li> <li> <p> <a>DescribeVolumes</a> </p> </li> <li> <p> <a>DescribeVpcs</a> </p> </li> </ul>"]
    let make ~name  ?(values= [])  () = { name; values }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Value", (ValueStringList.to_query v.values)));
           Some (Query.Pair ("Name", (String.to_query v.name)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (ValueStringList.to_json v.values));
           Some ("name", (String.to_json v.name))])
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "Value" xml)
                  ValueStringList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Value"
                      ([], (ValueStringList.to_xml [x])))) v.values))
  end[@@ocaml.doc
       "<p>A filter name and value pair that is used to return a more specific list of results from a describe operation. Filters can be used to match a set of resources by specific criteria, such as tags, attributes, or IDs. The filters supported by a describe operation are documented with the describe operation. For example:</p> <ul> <li> <p> <a>DescribeAvailabilityZones</a> </p> </li> <li> <p> <a>DescribeImages</a> </p> </li> <li> <p> <a>DescribeInstances</a> </p> </li> <li> <p> <a>DescribeKeyPairs</a> </p> </li> <li> <p> <a>DescribeSecurityGroups</a> </p> </li> <li> <p> <a>DescribeSnapshots</a> </p> </li> <li> <p> <a>DescribeSubnets</a> </p> </li> <li> <p> <a>DescribeTags</a> </p> </li> <li> <p> <a>DescribeVolumes</a> </p> </li> <li> <p> <a>DescribeVpcs</a> </p> </li> </ul>"]
module TagSpecification =
  struct
    type t =
      {
      resource_type: ResourceType.t option
        [@ocaml.doc
          "<p>The type of resource to tag. Currently, the resource types that support tagging on creation are: <code>capacity-reservation</code> | <code>client-vpn-endpoint</code> | <code>dedicated-host</code> | <code>fleet</code> | <code>fpga-image</code> | <code>instance</code> | <code>key-pair</code> | <code>launch-template</code> | <code>placement-group</code> | <code>snapshot</code> | <code>traffic-mirror-filter</code> | <code>traffic-mirror-session</code> | <code>traffic-mirror-target</code> | <code>transit-gateway</code> | <code>transit-gateway-attachment</code> | <code>transit-gateway-route-table</code> | <code>volume</code>.</p> <p>To tag a resource after it has been created, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html\">CreateTags</a>.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>The tags to apply to the resource.</p>"]}[@@ocaml.doc
                                                                   "<p>The tags to apply to a resource when the resource is being created.</p>"]
    let make ?resource_type  ?(tags= [])  () = { resource_type; tags }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Tag", (TagList.to_query v.tags)));
           Util.option_map v.resource_type
             (fun f -> Query.Pair ("ResourceType", (ResourceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.resource_type
             (fun f -> ("resource_type", (ResourceType.to_json f)))])
    let parse xml =
      Some
        {
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               ResourceType.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tag" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "resourceType"
                    ([], (ResourceType.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "Tag" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc
       "<p>The tags to apply to a resource when the resource is being created.</p>"]
module TagDescription =
  struct
    type t =
      {
      key: String.t [@ocaml.doc "<p>The tag key.</p>"];
      resource_id: String.t [@ocaml.doc "<p>The ID of the resource.</p>"];
      resource_type: ResourceType.t [@ocaml.doc "<p>The resource type.</p>"];
      value: String.t [@ocaml.doc "<p>The tag value.</p>"]}[@@ocaml.doc
                                                             "<p>Describes a tag.</p>"]
    let make ~key  ~resource_id  ~resource_type  ~value  () =
      { key; resource_id; resource_type; value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Value", (String.to_query v.value)));
           Some
             (Query.Pair
                ("ResourceType", (ResourceType.to_query v.resource_type)));
           Some (Query.Pair ("ResourceId", (String.to_query v.resource_id)));
           Some (Query.Pair ("Key", (String.to_query v.key)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("value", (String.to_json v.value));
           Some ("resource_type", (ResourceType.to_json v.resource_type));
           Some ("resource_id", (String.to_json v.resource_id));
           Some ("key", (String.to_json v.key))])
    let parse xml =
      Some
        {
          key =
            (Xml.required "key"
               (Util.option_bind (Xml.member "key" xml) String.parse));
          resource_id =
            (Xml.required "resourceId"
               (Util.option_bind (Xml.member "resourceId" xml) String.parse));
          resource_type =
            (Xml.required "resourceType"
               (Util.option_bind (Xml.member "resourceType" xml)
                  ResourceType.parse));
          value =
            (Xml.required "value"
               (Util.option_bind (Xml.member "value" xml) String.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @ [Some (Ezxmlm.make_tag "key" ([], (String.to_xml v.key)))])
             @
             [Some
                (Ezxmlm.make_tag "resourceId"
                   ([], (String.to_xml v.resource_id)))])
            @
            [Some
               (Ezxmlm.make_tag "resourceType"
                  ([], (ResourceType.to_xml v.resource_type)))])
           @ [Some (Ezxmlm.make_tag "value" ([], (String.to_xml v.value)))])
  end[@@ocaml.doc "<p>Describes a tag.</p>"]
module DhcpOptions =
  struct
    type t =
      {
      dhcp_configurations: DhcpConfigurationList.t
        [@ocaml.doc "<p>One or more DHCP options in the set.</p>"];
      dhcp_options_id: String.t option
        [@ocaml.doc "<p>The ID of the set of DHCP options.</p>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account that owns the DHCP options set.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the DHCP options set.</p>"]}
    [@@ocaml.doc "<p>Describes a set of DHCP options.</p>"]
    let make ?(dhcp_configurations= [])  ?dhcp_options_id  ?owner_id  ?(tags=
      [])  () = { dhcp_configurations; dhcp_options_id; owner_id; tags }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.dhcp_options_id
             (fun f -> Query.Pair ("DhcpOptionsId", (String.to_query f)));
           Some
             (Query.Pair
                ("DhcpConfigurationSet",
                  (DhcpConfigurationList.to_query v.dhcp_configurations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.dhcp_options_id
             (fun f -> ("dhcp_options_id", (String.to_json f)));
           Some
             ("dhcp_configurations",
               (DhcpConfigurationList.to_json v.dhcp_configurations))])
    let parse xml =
      Some
        {
          dhcp_configurations =
            (Util.of_option []
               (Util.option_bind (Xml.member "dhcpConfigurationSet" xml)
                  DhcpConfigurationList.parse));
          dhcp_options_id =
            (Util.option_bind (Xml.member "dhcpOptionsId" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "dhcpConfigurationSet"
                         ([], (DhcpConfigurationList.to_xml [x]))))
                 v.dhcp_configurations))
             @
             [Util.option_map v.dhcp_options_id
                (fun f ->
                   Ezxmlm.make_tag "dhcpOptionsId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.owner_id
               (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a set of DHCP options.</p>"]
module VpnGateway =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc
          "<p>The Availability Zone where the virtual private gateway was created, if applicable. This field may be empty or not returned.</p>"];
      state: VpnState.t option
        [@ocaml.doc
          "<p>The current state of the virtual private gateway.</p>"];
      type_: GatewayType.t option
        [@ocaml.doc
          "<p>The type of VPN connection the virtual private gateway supports.</p>"];
      vpc_attachments: VpcAttachmentList.t
        [@ocaml.doc
          "<p>Any VPCs attached to the virtual private gateway.</p>"];
      vpn_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the virtual private gateway.</p>"];
      amazon_side_asn: Long.t option
        [@ocaml.doc
          "<p>The private Autonomous System Number (ASN) for the Amazon side of a BGP session.</p>"];
      tags: TagList.t
        [@ocaml.doc
          "<p>Any tags assigned to the virtual private gateway.</p>"]}
    [@@ocaml.doc "<p>Describes a virtual private gateway.</p>"]
    let make ?availability_zone  ?state  ?type_  ?(vpc_attachments= []) 
      ?vpn_gateway_id  ?amazon_side_asn  ?(tags= [])  () =
      {
        availability_zone;
        state;
        type_;
        vpc_attachments;
        vpn_gateway_id;
        amazon_side_asn;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.amazon_side_asn
             (fun f -> Query.Pair ("AmazonSideAsn", (Long.to_query f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> Query.Pair ("VpnGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("Attachments",
                  (VpcAttachmentList.to_query v.vpc_attachments)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (GatewayType.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (VpnState.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.amazon_side_asn
             (fun f -> ("amazon_side_asn", (Long.to_json f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> ("vpn_gateway_id", (String.to_json f)));
           Some
             ("vpc_attachments",
               (VpcAttachmentList.to_json v.vpc_attachments));
           Util.option_map v.type_
             (fun f -> ("type_", (GatewayType.to_json f)));
           Util.option_map v.state (fun f -> ("state", (VpnState.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          state = (Util.option_bind (Xml.member "state" xml) VpnState.parse);
          type_ =
            (Util.option_bind (Xml.member "type" xml) GatewayType.parse);
          vpc_attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "attachments" xml)
                  VpcAttachmentList.parse));
          vpn_gateway_id =
            (Util.option_bind (Xml.member "vpnGatewayId" xml) String.parse);
          amazon_side_asn =
            (Util.option_bind (Xml.member "amazonSideAsn" xml) Long.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.availability_zone
                    (fun f ->
                       Ezxmlm.make_tag "availabilityZone"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.state
                   (fun f ->
                      Ezxmlm.make_tag "state" ([], (VpnState.to_xml f)))])
               @
               [Util.option_map v.type_
                  (fun f ->
                     Ezxmlm.make_tag "type" ([], (GatewayType.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "attachments"
                         ([], (VpcAttachmentList.to_xml [x]))))
                 v.vpc_attachments))
             @
             [Util.option_map v.vpn_gateway_id
                (fun f ->
                   Ezxmlm.make_tag "vpnGatewayId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.amazon_side_asn
               (fun f ->
                  Ezxmlm.make_tag "amazonSideAsn" ([], (Long.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a virtual private gateway.</p>"]
module TransitGatewayAttachmentPropagation =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t option
        [@ocaml.doc "<p>The ID of the propagation route table.</p>"];
      state: TransitGatewayPropagationState.t option
        [@ocaml.doc "<p>The state of the propagation route table.</p>"]}
    [@@ocaml.doc "<p>Describes a propagation route table.</p>"]
    let make ?transit_gateway_route_table_id  ?state  () =
      { transit_gateway_route_table_id; state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayPropagationState.to_query f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayRouteTableId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayPropagationState.to_json f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f -> ("transit_gateway_route_table_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Util.option_bind (Xml.member "transitGatewayRouteTableId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayPropagationState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.transit_gateway_route_table_id
               (fun f ->
                  Ezxmlm.make_tag "transitGatewayRouteTableId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (TransitGatewayPropagationState.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a propagation route table.</p>"]
module CapacityReservation =
  struct
    type t =
      {
      capacity_reservation_id: String.t option
        [@ocaml.doc "<p>The ID of the Capacity Reservation.</p>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account that owns the Capacity Reservation.</p>"];
      capacity_reservation_arn: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the Capacity Reservation.</p>"];
      availability_zone_id: String.t option
        [@ocaml.doc
          "<p>The Availability Zone ID of the Capacity Reservation.</p>"];
      instance_type: String.t option
        [@ocaml.doc
          "<p>The type of instance for which the Capacity Reservation reserves capacity.</p>"];
      instance_platform: CapacityReservationInstancePlatform.t option
        [@ocaml.doc
          "<p>The type of operating system for which the Capacity Reservation reserves capacity.</p>"];
      availability_zone: String.t option
        [@ocaml.doc
          "<p>The Availability Zone in which the capacity is reserved.</p>"];
      tenancy: CapacityReservationTenancy.t option
        [@ocaml.doc
          "<p>Indicates the tenancy of the Capacity Reservation. A Capacity Reservation can have one of the following tenancy settings:</p> <ul> <li> <p> <code>default</code> - The Capacity Reservation is created on hardware that is shared with other AWS accounts.</p> </li> <li> <p> <code>dedicated</code> - The Capacity Reservation is created on single-tenant hardware that is dedicated to a single AWS account.</p> </li> </ul>"];
      total_instance_count: Integer.t option
        [@ocaml.doc
          "<p>The total number of instances for which the Capacity Reservation reserves capacity.</p>"];
      available_instance_count: Integer.t option
        [@ocaml.doc
          "<p>The remaining capacity. Indicates the number of instances that can be launched in the Capacity Reservation.</p>"];
      ebs_optimized: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the Capacity Reservation supports EBS-optimized instances. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS- optimized instance.</p>"];
      ephemeral_storage: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the Capacity Reservation supports instances with temporary, block-level storage.</p>"];
      state: CapacityReservationState.t option
        [@ocaml.doc
          "<p>The current state of the Capacity Reservation. A Capacity Reservation can be in one of the following states:</p> <ul> <li> <p> <code>active</code> - The Capacity Reservation is active and the capacity is available for your use.</p> </li> <li> <p> <code>expired</code> - The Capacity Reservation expired automatically at the date and time specified in your request. The reserved capacity is no longer available for your use.</p> </li> <li> <p> <code>cancelled</code> - The Capacity Reservation was manually cancelled. The reserved capacity is no longer available for your use.</p> </li> <li> <p> <code>pending</code> - The Capacity Reservation request was successful but the capacity provisioning is still pending.</p> </li> <li> <p> <code>failed</code> - The Capacity Reservation request has failed. A request might fail due to invalid request parameters, capacity constraints, or instance limit constraints. Failed requests are retained for 60 minutes.</p> </li> </ul>"];
      end_date: DateTime.t option
        [@ocaml.doc
          "<p>The date and time at which the Capacity Reservation expires. When a Capacity Reservation expires, the reserved capacity is released and you can no longer launch instances into it. The Capacity Reservation's state changes to <code>expired</code> when it reaches its end date and time.</p>"];
      end_date_type: EndDateType.t option
        [@ocaml.doc
          "<p>Indicates the way in which the Capacity Reservation ends. A Capacity Reservation can have one of the following end types:</p> <ul> <li> <p> <code>unlimited</code> - The Capacity Reservation remains active until you explicitly cancel it.</p> </li> <li> <p> <code>limited</code> - The Capacity Reservation expires automatically at a specified date and time.</p> </li> </ul>"];
      instance_match_criteria: InstanceMatchCriteria.t option
        [@ocaml.doc
          "<p>Indicates the type of instance launches that the Capacity Reservation accepts. The options include:</p> <ul> <li> <p> <code>open</code> - The Capacity Reservation accepts all instances that have matching attributes (instance type, platform, and Availability Zone). Instances that have matching attributes launch into the Capacity Reservation automatically without specifying any additional parameters.</p> </li> <li> <p> <code>targeted</code> - The Capacity Reservation only accepts instances that have matching attributes (instance type, platform, and Availability Zone), and explicitly target the Capacity Reservation. This ensures that only permitted instances can use the reserved capacity. </p> </li> </ul>"];
      create_date: DateTime.t option
        [@ocaml.doc
          "<p>The date and time at which the Capacity Reservation was created.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the Capacity Reservation.</p>"]}
    [@@ocaml.doc "<p>Describes a Capacity Reservation.</p>"]
    let make ?capacity_reservation_id  ?owner_id  ?capacity_reservation_arn 
      ?availability_zone_id  ?instance_type  ?instance_platform 
      ?availability_zone  ?tenancy  ?total_instance_count 
      ?available_instance_count  ?ebs_optimized  ?ephemeral_storage  ?state 
      ?end_date  ?end_date_type  ?instance_match_criteria  ?create_date 
      ?(tags= [])  () =
      {
        capacity_reservation_id;
        owner_id;
        capacity_reservation_arn;
        availability_zone_id;
        instance_type;
        instance_platform;
        availability_zone;
        tenancy;
        total_instance_count;
        available_instance_count;
        ebs_optimized;
        ephemeral_storage;
        state;
        end_date;
        end_date_type;
        instance_match_criteria;
        create_date;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.create_date
             (fun f -> Query.Pair ("CreateDate", (DateTime.to_query f)));
           Util.option_map v.instance_match_criteria
             (fun f ->
                Query.Pair
                  ("InstanceMatchCriteria",
                    (InstanceMatchCriteria.to_query f)));
           Util.option_map v.end_date_type
             (fun f -> Query.Pair ("EndDateType", (EndDateType.to_query f)));
           Util.option_map v.end_date
             (fun f -> Query.Pair ("EndDate", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (CapacityReservationState.to_query f)));
           Util.option_map v.ephemeral_storage
             (fun f -> Query.Pair ("EphemeralStorage", (Boolean.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.available_instance_count
             (fun f ->
                Query.Pair ("AvailableInstanceCount", (Integer.to_query f)));
           Util.option_map v.total_instance_count
             (fun f ->
                Query.Pair ("TotalInstanceCount", (Integer.to_query f)));
           Util.option_map v.tenancy
             (fun f ->
                Query.Pair
                  ("Tenancy", (CapacityReservationTenancy.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.instance_platform
             (fun f ->
                Query.Pair
                  ("InstancePlatform",
                    (CapacityReservationInstancePlatform.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.availability_zone_id
             (fun f -> Query.Pair ("AvailabilityZoneId", (String.to_query f)));
           Util.option_map v.capacity_reservation_arn
             (fun f ->
                Query.Pair ("CapacityReservationArn", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.capacity_reservation_id
             (fun f ->
                Query.Pair ("CapacityReservationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.create_date
             (fun f -> ("create_date", (DateTime.to_json f)));
           Util.option_map v.instance_match_criteria
             (fun f ->
                ("instance_match_criteria",
                  (InstanceMatchCriteria.to_json f)));
           Util.option_map v.end_date_type
             (fun f -> ("end_date_type", (EndDateType.to_json f)));
           Util.option_map v.end_date
             (fun f -> ("end_date", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (CapacityReservationState.to_json f)));
           Util.option_map v.ephemeral_storage
             (fun f -> ("ephemeral_storage", (Boolean.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.available_instance_count
             (fun f -> ("available_instance_count", (Integer.to_json f)));
           Util.option_map v.total_instance_count
             (fun f -> ("total_instance_count", (Integer.to_json f)));
           Util.option_map v.tenancy
             (fun f -> ("tenancy", (CapacityReservationTenancy.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.instance_platform
             (fun f ->
                ("instance_platform",
                  (CapacityReservationInstancePlatform.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.availability_zone_id
             (fun f -> ("availability_zone_id", (String.to_json f)));
           Util.option_map v.capacity_reservation_arn
             (fun f -> ("capacity_reservation_arn", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.capacity_reservation_id
             (fun f -> ("capacity_reservation_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          capacity_reservation_id =
            (Util.option_bind (Xml.member "capacityReservationId" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          capacity_reservation_arn =
            (Util.option_bind (Xml.member "capacityReservationArn" xml)
               String.parse);
          availability_zone_id =
            (Util.option_bind (Xml.member "availabilityZoneId" xml)
               String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          instance_platform =
            (Util.option_bind (Xml.member "instancePlatform" xml)
               CapacityReservationInstancePlatform.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          tenancy =
            (Util.option_bind (Xml.member "tenancy" xml)
               CapacityReservationTenancy.parse);
          total_instance_count =
            (Util.option_bind (Xml.member "totalInstanceCount" xml)
               Integer.parse);
          available_instance_count =
            (Util.option_bind (Xml.member "availableInstanceCount" xml)
               Integer.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          ephemeral_storage =
            (Util.option_bind (Xml.member "ephemeralStorage" xml)
               Boolean.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               CapacityReservationState.parse);
          end_date =
            (Util.option_bind (Xml.member "endDate" xml) DateTime.parse);
          end_date_type =
            (Util.option_bind (Xml.member "endDateType" xml)
               EndDateType.parse);
          instance_match_criteria =
            (Util.option_bind (Xml.member "instanceMatchCriteria" xml)
               InstanceMatchCriteria.parse);
          create_date =
            (Util.option_bind (Xml.member "createDate" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((([] @
                            [Util.option_map v.capacity_reservation_id
                               (fun f ->
                                  Ezxmlm.make_tag "capacityReservationId"
                                    ([], (String.to_xml f)))])
                           @
                           [Util.option_map v.owner_id
                              (fun f ->
                                 Ezxmlm.make_tag "ownerId"
                                   ([], (String.to_xml f)))])
                          @
                          [Util.option_map v.capacity_reservation_arn
                             (fun f ->
                                Ezxmlm.make_tag "capacityReservationArn"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.availability_zone_id
                            (fun f ->
                               Ezxmlm.make_tag "availabilityZoneId"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.instance_type
                           (fun f ->
                              Ezxmlm.make_tag "instanceType"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.instance_platform
                          (fun f ->
                             Ezxmlm.make_tag "instancePlatform"
                               ([],
                                 (CapacityReservationInstancePlatform.to_xml
                                    f)))])
                      @
                      [Util.option_map v.availability_zone
                         (fun f ->
                            Ezxmlm.make_tag "availabilityZone"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.tenancy
                        (fun f ->
                           Ezxmlm.make_tag "tenancy"
                             ([], (CapacityReservationTenancy.to_xml f)))])
                    @
                    [Util.option_map v.total_instance_count
                       (fun f ->
                          Ezxmlm.make_tag "totalInstanceCount"
                            ([], (Integer.to_xml f)))])
                   @
                   [Util.option_map v.available_instance_count
                      (fun f ->
                         Ezxmlm.make_tag "availableInstanceCount"
                           ([], (Integer.to_xml f)))])
                  @
                  [Util.option_map v.ebs_optimized
                     (fun f ->
                        Ezxmlm.make_tag "ebsOptimized"
                          ([], (Boolean.to_xml f)))])
                 @
                 [Util.option_map v.ephemeral_storage
                    (fun f ->
                       Ezxmlm.make_tag "ephemeralStorage"
                         ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.state
                   (fun f ->
                      Ezxmlm.make_tag "state"
                        ([], (CapacityReservationState.to_xml f)))])
               @
               [Util.option_map v.end_date
                  (fun f ->
                     Ezxmlm.make_tag "endDate" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.end_date_type
                 (fun f ->
                    Ezxmlm.make_tag "endDateType"
                      ([], (EndDateType.to_xml f)))])
             @
             [Util.option_map v.instance_match_criteria
                (fun f ->
                   Ezxmlm.make_tag "instanceMatchCriteria"
                     ([], (InstanceMatchCriteria.to_xml f)))])
            @
            [Util.option_map v.create_date
               (fun f ->
                  Ezxmlm.make_tag "createDate" ([], (DateTime.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a Capacity Reservation.</p>"]
module ReservedInstancesModification =
  struct
    type t =
      {
      client_token: String.t option
        [@ocaml.doc
          "<p>A unique, case-sensitive key supplied by the client to ensure that the request is idempotent. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html\">Ensuring Idempotency</a>.</p>"];
      create_date: DateTime.t option
        [@ocaml.doc
          "<p>The time when the modification request was created.</p>"];
      effective_date: DateTime.t option
        [@ocaml.doc
          "<p>The time for the modification to become effective.</p>"];
      modification_results: ReservedInstancesModificationResultList.t
        [@ocaml.doc
          "<p>Contains target configurations along with their corresponding new Reserved Instance IDs.</p>"];
      reserved_instances_ids: ReservedIntancesIds.t
        [@ocaml.doc "<p>The IDs of one or more Reserved Instances.</p>"];
      reserved_instances_modification_id: String.t option
        [@ocaml.doc
          "<p>A unique ID for the Reserved Instance modification.</p>"];
      status: String.t option
        [@ocaml.doc
          "<p>The status of the Reserved Instances modification request.</p>"];
      status_message: String.t option
        [@ocaml.doc "<p>The reason for the status.</p>"];
      update_date: DateTime.t option
        [@ocaml.doc
          "<p>The time when the modification request was last updated.</p>"]}
    [@@ocaml.doc "<p>Describes a Reserved Instance modification.</p>"]
    let make ?client_token  ?create_date  ?effective_date 
      ?(modification_results= [])  ?(reserved_instances_ids= []) 
      ?reserved_instances_modification_id  ?status  ?status_message 
      ?update_date  () =
      {
        client_token;
        create_date;
        effective_date;
        modification_results;
        reserved_instances_ids;
        reserved_instances_modification_id;
        status;
        status_message;
        update_date
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.update_date
              (fun f -> Query.Pair ("UpdateDate", (DateTime.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.reserved_instances_modification_id
             (fun f ->
                Query.Pair
                  ("ReservedInstancesModificationId", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesSet",
                  (ReservedIntancesIds.to_query v.reserved_instances_ids)));
           Some
             (Query.Pair
                ("ModificationResultSet",
                  (ReservedInstancesModificationResultList.to_query
                     v.modification_results)));
           Util.option_map v.effective_date
             (fun f -> Query.Pair ("EffectiveDate", (DateTime.to_query f)));
           Util.option_map v.create_date
             (fun f -> Query.Pair ("CreateDate", (DateTime.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.update_date
              (fun f -> ("update_date", (DateTime.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.reserved_instances_modification_id
             (fun f ->
                ("reserved_instances_modification_id", (String.to_json f)));
           Some
             ("reserved_instances_ids",
               (ReservedIntancesIds.to_json v.reserved_instances_ids));
           Some
             ("modification_results",
               (ReservedInstancesModificationResultList.to_json
                  v.modification_results));
           Util.option_map v.effective_date
             (fun f -> ("effective_date", (DateTime.to_json f)));
           Util.option_map v.create_date
             (fun f -> ("create_date", (DateTime.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          create_date =
            (Util.option_bind (Xml.member "createDate" xml) DateTime.parse);
          effective_date =
            (Util.option_bind (Xml.member "effectiveDate" xml) DateTime.parse);
          modification_results =
            (Util.of_option []
               (Util.option_bind (Xml.member "modificationResultSet" xml)
                  ReservedInstancesModificationResultList.parse));
          reserved_instances_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "reservedInstancesSet" xml)
                  ReservedIntancesIds.parse));
          reserved_instances_modification_id =
            (Util.option_bind
               (Xml.member "reservedInstancesModificationId" xml)
               String.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          update_date =
            (Util.option_bind (Xml.member "updateDate" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.client_token
                      (fun f ->
                         Ezxmlm.make_tag "clientToken"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.create_date
                     (fun f ->
                        Ezxmlm.make_tag "createDate"
                          ([], (DateTime.to_xml f)))])
                 @
                 [Util.option_map v.effective_date
                    (fun f ->
                       Ezxmlm.make_tag "effectiveDate"
                         ([], (DateTime.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "modificationResultSet"
                           ([],
                             (ReservedInstancesModificationResultList.to_xml
                                [x])))) v.modification_results))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "reservedInstancesSet"
                          ([], (ReservedIntancesIds.to_xml [x]))))
                  v.reserved_instances_ids))
              @
              [Util.option_map v.reserved_instances_modification_id
                 (fun f ->
                    Ezxmlm.make_tag "reservedInstancesModificationId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.status
                (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
            @
            [Util.option_map v.status_message
               (fun f ->
                  Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
           @
           [Util.option_map v.update_date
              (fun f ->
                 Ezxmlm.make_tag "updateDate" ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a Reserved Instance modification.</p>"]
module PlacementGroup =
  struct
    type t =
      {
      group_name: String.t option
        [@ocaml.doc "<p>The name of the placement group.</p>"];
      state: PlacementGroupState.t option
        [@ocaml.doc "<p>The state of the placement group.</p>"];
      strategy: PlacementStrategy.t option
        [@ocaml.doc "<p>The placement strategy.</p>"];
      partition_count: Integer.t option
        [@ocaml.doc
          "<p>The number of partitions. Valid only if <b>strategy</b> is set to <code>partition</code>.</p>"];
      group_id: String.t option
        [@ocaml.doc "<p>The ID of the placement group.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags applied to the placement group.</p>"]}
    [@@ocaml.doc "<p>Describes a placement group.</p>"]
    let make ?group_name  ?state  ?strategy  ?partition_count  ?group_id 
      ?(tags= [])  () =
      { group_name; state; strategy; partition_count; group_id; tags }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.partition_count
             (fun f -> Query.Pair ("PartitionCount", (Integer.to_query f)));
           Util.option_map v.strategy
             (fun f ->
                Query.Pair ("Strategy", (PlacementStrategy.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (PlacementGroupState.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.partition_count
             (fun f -> ("partition_count", (Integer.to_json f)));
           Util.option_map v.strategy
             (fun f -> ("strategy", (PlacementStrategy.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (PlacementGroupState.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)))])
    let parse xml =
      Some
        {
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               PlacementGroupState.parse);
          strategy =
            (Util.option_bind (Xml.member "strategy" xml)
               PlacementStrategy.parse);
          partition_count =
            (Util.option_bind (Xml.member "partitionCount" xml) Integer.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.group_name
                   (fun f ->
                      Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
               @
               [Util.option_map v.state
                  (fun f ->
                     Ezxmlm.make_tag "state"
                       ([], (PlacementGroupState.to_xml f)))])
              @
              [Util.option_map v.strategy
                 (fun f ->
                    Ezxmlm.make_tag "strategy"
                      ([], (PlacementStrategy.to_xml f)))])
             @
             [Util.option_map v.partition_count
                (fun f ->
                   Ezxmlm.make_tag "partitionCount" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.group_id
               (fun f -> Ezxmlm.make_tag "groupId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a placement group.</p>"]
module TransitGatewayRouteTablePropagation =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option
        [@ocaml.doc "<p>The ID of the attachment.</p>"];
      resource_id: String.t option
        [@ocaml.doc "<p>The ID of the resource.</p>"];
      resource_type: TransitGatewayAttachmentResourceType.t option
        [@ocaml.doc "<p>The type of resource.</p>"];
      state: TransitGatewayPropagationState.t option
        [@ocaml.doc "<p>The state of the resource.</p>"]}[@@ocaml.doc
                                                           "<p>Describes a route table propagation.</p>"]
    let make ?transit_gateway_attachment_id  ?resource_id  ?resource_type 
      ?state  () =
      { transit_gateway_attachment_id; resource_id; resource_type; state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayPropagationState.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayPropagationState.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayPropagationState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.transit_gateway_attachment_id
                 (fun f ->
                    Ezxmlm.make_tag "transitGatewayAttachmentId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.resource_id
                (fun f ->
                   Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "resourceType"
                    ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (TransitGatewayPropagationState.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a route table propagation.</p>"]
module KeyPairInfo =
  struct
    type t =
      {
      key_pair_id: String.t option
        [@ocaml.doc "<p>The ID of the key pair.</p>"];
      key_fingerprint: String.t option
        [@ocaml.doc
          "<p>If you used <a>CreateKeyPair</a> to create the key pair, this is the SHA-1 digest of the DER encoded private key. If you used <a>ImportKeyPair</a> to provide AWS the public key, this is the MD5 public key fingerprint as specified in section 4 of RFC4716.</p>"];
      key_name: String.t option
        [@ocaml.doc "<p>The name of the key pair.</p>"];
      tags: TagList.t [@ocaml.doc "<p>Any tags applied to the key pair.</p>"]}
    [@@ocaml.doc "<p>Describes a key pair.</p>"]
    let make ?key_pair_id  ?key_fingerprint  ?key_name  ?(tags= [])  () =
      { key_pair_id; key_fingerprint; key_name; tags }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.key_fingerprint
             (fun f -> Query.Pair ("KeyFingerprint", (String.to_query f)));
           Util.option_map v.key_pair_id
             (fun f -> Query.Pair ("KeyPairId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.key_fingerprint
             (fun f -> ("key_fingerprint", (String.to_json f)));
           Util.option_map v.key_pair_id
             (fun f -> ("key_pair_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          key_pair_id =
            (Util.option_bind (Xml.member "keyPairId" xml) String.parse);
          key_fingerprint =
            (Util.option_bind (Xml.member "keyFingerprint" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.key_pair_id
                 (fun f ->
                    Ezxmlm.make_tag "keyPairId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.key_fingerprint
                (fun f ->
                   Ezxmlm.make_tag "keyFingerprint" ([], (String.to_xml f)))])
            @
            [Util.option_map v.key_name
               (fun f -> Ezxmlm.make_tag "keyName" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a key pair.</p>"]
module HistoryRecordEntry =
  struct
    type t =
      {
      event_information: EventInformation.t option
        [@ocaml.doc "<p>Information about the event.</p>"];
      event_type: FleetEventType.t option
        [@ocaml.doc "<p>The event type.</p>"];
      timestamp: DateTime.t option
        [@ocaml.doc
          "<p>The date and time of the event, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>"]}
    [@@ocaml.doc "<p>Describes an event in the history of an EC2 Fleet.</p>"]
    let make ?event_information  ?event_type  ?timestamp  () =
      { event_information; event_type; timestamp }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.event_type
             (fun f -> Query.Pair ("EventType", (FleetEventType.to_query f)));
           Util.option_map v.event_information
             (fun f ->
                Query.Pair
                  ("EventInformation", (EventInformation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.event_type
             (fun f -> ("event_type", (FleetEventType.to_json f)));
           Util.option_map v.event_information
             (fun f -> ("event_information", (EventInformation.to_json f)))])
    let parse xml =
      Some
        {
          event_information =
            (Util.option_bind (Xml.member "eventInformation" xml)
               EventInformation.parse);
          event_type =
            (Util.option_bind (Xml.member "eventType" xml)
               FleetEventType.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.event_information
                (fun f ->
                   Ezxmlm.make_tag "eventInformation"
                     ([], (EventInformation.to_xml f)))])
            @
            [Util.option_map v.event_type
               (fun f ->
                  Ezxmlm.make_tag "eventType" ([], (FleetEventType.to_xml f)))])
           @
           [Util.option_map v.timestamp
              (fun f -> Ezxmlm.make_tag "timestamp" ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an event in the history of an EC2 Fleet.</p>"]
module HostReservation =
  struct
    type t =
      {
      count: Integer.t option
        [@ocaml.doc
          "<p>The number of Dedicated Hosts the reservation is associated with.</p>"];
      currency_code: CurrencyCodeValues.t option
        [@ocaml.doc
          "<p>The currency in which the <code>upfrontPrice</code> and <code>hourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>"];
      duration: Integer.t option
        [@ocaml.doc
          "<p>The length of the reservation's term, specified in seconds. Can be <code>31536000 (1 year)</code> | <code>94608000 (3 years)</code>.</p>"];
      end_: DateTime.t option
        [@ocaml.doc "<p>The date and time that the reservation ends.</p>"];
      host_id_set: ResponseHostIdSet.t
        [@ocaml.doc
          "<p>The IDs of the Dedicated Hosts associated with the reservation.</p>"];
      host_reservation_id: String.t option
        [@ocaml.doc
          "<p>The ID of the reservation that specifies the associated Dedicated Hosts.</p>"];
      hourly_price: String.t option
        [@ocaml.doc "<p>The hourly price of the reservation.</p>"];
      instance_family: String.t option
        [@ocaml.doc
          "<p>The instance family of the Dedicated Host Reservation. The instance family on the Dedicated Host must be the same in order for it to benefit from the reservation.</p>"];
      offering_id: String.t option
        [@ocaml.doc
          "<p>The ID of the reservation. This remains the same regardless of which Dedicated Hosts are associated with it.</p>"];
      payment_option: PaymentOption.t option
        [@ocaml.doc
          "<p>The payment option selected for this reservation.</p>"];
      start: DateTime.t option
        [@ocaml.doc "<p>The date and time that the reservation started.</p>"];
      state: ReservationState.t option
        [@ocaml.doc "<p>The state of the reservation.</p>"];
      upfront_price: String.t option
        [@ocaml.doc "<p>The upfront price of the reservation.</p>"];
      tags: TagList.t
        [@ocaml.doc
          "<p>Any tags assigned to the Dedicated Host Reservation.</p>"]}
    [@@ocaml.doc
      "<p>Details about the Dedicated Host Reservation and associated Dedicated Hosts.</p>"]
    let make ?count  ?currency_code  ?duration  ?end_  ?(host_id_set= []) 
      ?host_reservation_id  ?hourly_price  ?instance_family  ?offering_id 
      ?payment_option  ?start  ?state  ?upfront_price  ?(tags= [])  () =
      {
        count;
        currency_code;
        duration;
        end_;
        host_id_set;
        host_reservation_id;
        hourly_price;
        instance_family;
        offering_id;
        payment_option;
        start;
        state;
        upfront_price;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.upfront_price
             (fun f -> Query.Pair ("UpfrontPrice", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (ReservationState.to_query f)));
           Util.option_map v.start
             (fun f -> Query.Pair ("Start", (DateTime.to_query f)));
           Util.option_map v.payment_option
             (fun f ->
                Query.Pair ("PaymentOption", (PaymentOption.to_query f)));
           Util.option_map v.offering_id
             (fun f -> Query.Pair ("OfferingId", (String.to_query f)));
           Util.option_map v.instance_family
             (fun f -> Query.Pair ("InstanceFamily", (String.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)));
           Util.option_map v.host_reservation_id
             (fun f -> Query.Pair ("HostReservationId", (String.to_query f)));
           Some
             (Query.Pair
                ("HostIdSet", (ResponseHostIdSet.to_query v.host_id_set)));
           Util.option_map v.end_
             (fun f -> Query.Pair ("End", (DateTime.to_query f)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Integer.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.upfront_price
             (fun f -> ("upfront_price", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (ReservationState.to_json f)));
           Util.option_map v.start (fun f -> ("start", (DateTime.to_json f)));
           Util.option_map v.payment_option
             (fun f -> ("payment_option", (PaymentOption.to_json f)));
           Util.option_map v.offering_id
             (fun f -> ("offering_id", (String.to_json f)));
           Util.option_map v.instance_family
             (fun f -> ("instance_family", (String.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)));
           Util.option_map v.host_reservation_id
             (fun f -> ("host_reservation_id", (String.to_json f)));
           Some ("host_id_set", (ResponseHostIdSet.to_json v.host_id_set));
           Util.option_map v.end_ (fun f -> ("end_", (DateTime.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Integer.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Integer.parse);
          end_ = (Util.option_bind (Xml.member "end" xml) DateTime.parse);
          host_id_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostIdSet" xml)
                  ResponseHostIdSet.parse));
          host_reservation_id =
            (Util.option_bind (Xml.member "hostReservationId" xml)
               String.parse);
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          instance_family =
            (Util.option_bind (Xml.member "instanceFamily" xml) String.parse);
          offering_id =
            (Util.option_bind (Xml.member "offeringId" xml) String.parse);
          payment_option =
            (Util.option_bind (Xml.member "paymentOption" xml)
               PaymentOption.parse);
          start = (Util.option_bind (Xml.member "start" xml) DateTime.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) ReservationState.parse);
          upfront_price =
            (Util.option_bind (Xml.member "upfrontPrice" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        [Util.option_map v.count
                           (fun f ->
                              Ezxmlm.make_tag "count"
                                ([], (Integer.to_xml f)))])
                       @
                       [Util.option_map v.currency_code
                          (fun f ->
                             Ezxmlm.make_tag "currencyCode"
                               ([], (CurrencyCodeValues.to_xml f)))])
                      @
                      [Util.option_map v.duration
                         (fun f ->
                            Ezxmlm.make_tag "duration"
                              ([], (Integer.to_xml f)))])
                     @
                     [Util.option_map v.end_
                        (fun f ->
                           Ezxmlm.make_tag "end" ([], (DateTime.to_xml f)))])
                    @
                    (List.map
                       (fun x ->
                          Some
                            (Ezxmlm.make_tag "hostIdSet"
                               ([], (ResponseHostIdSet.to_xml [x]))))
                       v.host_id_set))
                   @
                   [Util.option_map v.host_reservation_id
                      (fun f ->
                         Ezxmlm.make_tag "hostReservationId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.hourly_price
                     (fun f ->
                        Ezxmlm.make_tag "hourlyPrice" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.instance_family
                    (fun f ->
                       Ezxmlm.make_tag "instanceFamily"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.offering_id
                   (fun f ->
                      Ezxmlm.make_tag "offeringId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.payment_option
                  (fun f ->
                     Ezxmlm.make_tag "paymentOption"
                       ([], (PaymentOption.to_xml f)))])
              @
              [Util.option_map v.start
                 (fun f -> Ezxmlm.make_tag "start" ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.state
                (fun f ->
                   Ezxmlm.make_tag "state" ([], (ReservationState.to_xml f)))])
            @
            [Util.option_map v.upfront_price
               (fun f ->
                  Ezxmlm.make_tag "upfrontPrice" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc
       "<p>Details about the Dedicated Host Reservation and associated Dedicated Hosts.</p>"]
module LaunchPermissionList =
  struct
    type t = LaunchPermission.t list
    let make elems () = elems
    let to_query v = Query.to_query_list LaunchPermission.to_query v
    let to_headers v = Headers.to_headers_list LaunchPermission.to_headers v
    let to_json v = `List (List.map LaunchPermission.to_json v)
    let parse xml =
      Util.option_all
        (List.map LaunchPermission.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (LaunchPermission.to_xml x)))
        v
  end
module VpcEndpointConnection =
  struct
    type t =
      {
      service_id: String.t option
        [@ocaml.doc
          "<p>The ID of the service to which the endpoint is connected.</p>"];
      vpc_endpoint_id: String.t option
        [@ocaml.doc "<p>The ID of the VPC endpoint.</p>"];
      vpc_endpoint_owner: String.t option
        [@ocaml.doc
          "<p>The AWS account ID of the owner of the VPC endpoint.</p>"];
      vpc_endpoint_state: State.t option
        [@ocaml.doc "<p>The state of the VPC endpoint.</p>"];
      creation_timestamp: DateTime.t option
        [@ocaml.doc "<p>The date and time the VPC endpoint was created.</p>"];
      dns_entries: DnsEntrySet.t
        [@ocaml.doc "<p>The DNS entries for the VPC endpoint.</p>"];
      network_load_balancer_arns: ValueStringList.t
        [@ocaml.doc
          "<p>The Amazon Resource Names (ARNs) of the network load balancers for the service.</p>"]}
    [@@ocaml.doc "<p>Describes a VPC endpoint connection to a service.</p>"]
    let make ?service_id  ?vpc_endpoint_id  ?vpc_endpoint_owner 
      ?vpc_endpoint_state  ?creation_timestamp  ?(dns_entries= []) 
      ?(network_load_balancer_arns= [])  () =
      {
        service_id;
        vpc_endpoint_id;
        vpc_endpoint_owner;
        vpc_endpoint_state;
        creation_timestamp;
        dns_entries;
        network_load_balancer_arns
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkLoadBalancerArnSet",
                   (ValueStringList.to_query v.network_load_balancer_arns)));
           Some
             (Query.Pair
                ("DnsEntrySet", (DnsEntrySet.to_query v.dns_entries)));
           Util.option_map v.creation_timestamp
             (fun f ->
                Query.Pair ("CreationTimestamp", (DateTime.to_query f)));
           Util.option_map v.vpc_endpoint_state
             (fun f -> Query.Pair ("VpcEndpointState", (State.to_query f)));
           Util.option_map v.vpc_endpoint_owner
             (fun f -> Query.Pair ("VpcEndpointOwner", (String.to_query f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> Query.Pair ("VpcEndpointId", (String.to_query f)));
           Util.option_map v.service_id
             (fun f -> Query.Pair ("ServiceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("network_load_balancer_arns",
                (ValueStringList.to_json v.network_load_balancer_arns));
           Some ("dns_entries", (DnsEntrySet.to_json v.dns_entries));
           Util.option_map v.creation_timestamp
             (fun f -> ("creation_timestamp", (DateTime.to_json f)));
           Util.option_map v.vpc_endpoint_state
             (fun f -> ("vpc_endpoint_state", (State.to_json f)));
           Util.option_map v.vpc_endpoint_owner
             (fun f -> ("vpc_endpoint_owner", (String.to_json f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> ("vpc_endpoint_id", (String.to_json f)));
           Util.option_map v.service_id
             (fun f -> ("service_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          service_id =
            (Util.option_bind (Xml.member "serviceId" xml) String.parse);
          vpc_endpoint_id =
            (Util.option_bind (Xml.member "vpcEndpointId" xml) String.parse);
          vpc_endpoint_owner =
            (Util.option_bind (Xml.member "vpcEndpointOwner" xml)
               String.parse);
          vpc_endpoint_state =
            (Util.option_bind (Xml.member "vpcEndpointState" xml) State.parse);
          creation_timestamp =
            (Util.option_bind (Xml.member "creationTimestamp" xml)
               DateTime.parse);
          dns_entries =
            (Util.of_option []
               (Util.option_bind (Xml.member "dnsEntrySet" xml)
                  DnsEntrySet.parse));
          network_load_balancer_arns =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkLoadBalancerArnSet" xml)
                  ValueStringList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.service_id
                    (fun f ->
                       Ezxmlm.make_tag "serviceId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.vpc_endpoint_id
                   (fun f ->
                      Ezxmlm.make_tag "vpcEndpointId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.vpc_endpoint_owner
                  (fun f ->
                     Ezxmlm.make_tag "vpcEndpointOwner"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.vpc_endpoint_state
                 (fun f ->
                    Ezxmlm.make_tag "vpcEndpointState" ([], (State.to_xml f)))])
             @
             [Util.option_map v.creation_timestamp
                (fun f ->
                   Ezxmlm.make_tag "creationTimestamp"
                     ([], (DateTime.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "dnsEntrySet"
                       ([], (DnsEntrySet.to_xml [x])))) v.dns_entries))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "networkLoadBalancerArnSet"
                      ([], (ValueStringList.to_xml [x]))))
              v.network_load_balancer_arns))
  end[@@ocaml.doc "<p>Describes a VPC endpoint connection to a service.</p>"]
module ExportImageTask =
  struct
    type t =
      {
      description: String.t option
        [@ocaml.doc "<p>A description of the image being exported.</p>"];
      export_image_task_id: String.t option
        [@ocaml.doc "<p>The ID of the export image task.</p>"];
      image_id: String.t option [@ocaml.doc "<p>The ID of the image.</p>"];
      progress: String.t option
        [@ocaml.doc "<p>The percent complete of the export image task.</p>"];
      s3_export_location: ExportTaskS3Location.t option
        [@ocaml.doc "<p>Information about the destination S3 bucket.</p>"];
      status: String.t option
        [@ocaml.doc
          "<p>The status of the export image task. The possible values are <code>active</code>, <code>completed</code>, <code>deleting</code>, and <code>deleted</code>.</p>"];
      status_message: String.t option
        [@ocaml.doc "<p>The status message for the export image task.</p>"]}
    [@@ocaml.doc "<p>Describes an export image task.</p>"]
    let make ?description  ?export_image_task_id  ?image_id  ?progress 
      ?s3_export_location  ?status  ?status_message  () =
      {
        description;
        export_image_task_id;
        image_id;
        progress;
        s3_export_location;
        status;
        status_message
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.s3_export_location
             (fun f ->
                Query.Pair
                  ("S3ExportLocation", (ExportTaskS3Location.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.export_image_task_id
             (fun f -> Query.Pair ("ExportImageTaskId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.s3_export_location
             (fun f ->
                ("s3_export_location", (ExportTaskS3Location.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.export_image_task_id
             (fun f -> ("export_image_task_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          export_image_task_id =
            (Util.option_bind (Xml.member "exportImageTaskId" xml)
               String.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          s3_export_location =
            (Util.option_bind (Xml.member "s3ExportLocation" xml)
               ExportTaskS3Location.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.description
                    (fun f ->
                       Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
                @
                [Util.option_map v.export_image_task_id
                   (fun f ->
                      Ezxmlm.make_tag "exportImageTaskId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.image_id
                  (fun f -> Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.progress
                 (fun f -> Ezxmlm.make_tag "progress" ([], (String.to_xml f)))])
             @
             [Util.option_map v.s3_export_location
                (fun f ->
                   Ezxmlm.make_tag "s3ExportLocation"
                     ([], (ExportTaskS3Location.to_xml f)))])
            @
            [Util.option_map v.status
               (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status_message
              (fun f ->
                 Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an export image task.</p>"]
module UnsuccessfulItem =
  struct
    type t =
      {
      error: UnsuccessfulItemError.t option
        [@ocaml.doc "<p>Information about the error.</p>"];
      resource_id: String.t option
        [@ocaml.doc "<p>The ID of the resource.</p>"]}[@@ocaml.doc
                                                        "<p>Information about items that were not successfully processed in a batch call.</p>"]
    let make ?error  ?resource_id  () = { error; resource_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.resource_id
              (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.error
             (fun f ->
                Query.Pair ("Error", (UnsuccessfulItemError.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.resource_id
              (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.error
             (fun f -> ("error", (UnsuccessfulItemError.to_json f)))])
    let parse xml =
      Some
        {
          error =
            (Util.option_bind (Xml.member "error" xml)
               UnsuccessfulItemError.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.error
               (fun f ->
                  Ezxmlm.make_tag "error"
                    ([], (UnsuccessfulItemError.to_xml f)))])
           @
           [Util.option_map v.resource_id
              (fun f -> Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Information about items that were not successfully processed in a batch call.</p>"]
module TrafficMirrorFilter =
  struct
    type t =
      {
      traffic_mirror_filter_id: String.t option
        [@ocaml.doc "<p>The ID of the Traffic Mirror filter.</p>"];
      ingress_filter_rules: TrafficMirrorFilterRuleList.t
        [@ocaml.doc
          "<p>Information about the ingress rules that are associated with the Traffic Mirror filter.</p>"];
      egress_filter_rules: TrafficMirrorFilterRuleList.t
        [@ocaml.doc
          "<p>Information about the egress rules that are associated with the Traffic Mirror filter.</p>"];
      network_services: TrafficMirrorNetworkServiceList.t
        [@ocaml.doc
          "<p>The network service traffic that is associated with the Traffic Mirror filter.</p>"];
      description: String.t option
        [@ocaml.doc "<p>The description of the Traffic Mirror filter.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>The tags assigned to the Traffic Mirror filter.</p>"]}
    [@@ocaml.doc "<p>Describes the Traffic Mirror filter.</p>"]
    let make ?traffic_mirror_filter_id  ?(ingress_filter_rules= []) 
      ?(egress_filter_rules= [])  ?(network_services= [])  ?description 
      ?(tags= [])  () =
      {
        traffic_mirror_filter_id;
        ingress_filter_rules;
        egress_filter_rules;
        network_services;
        description;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkServiceSet",
                  (TrafficMirrorNetworkServiceList.to_query
                     v.network_services)));
           Some
             (Query.Pair
                ("EgressFilterRuleSet",
                  (TrafficMirrorFilterRuleList.to_query v.egress_filter_rules)));
           Some
             (Query.Pair
                ("IngressFilterRuleSet",
                  (TrafficMirrorFilterRuleList.to_query
                     v.ingress_filter_rules)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f ->
                Query.Pair ("TrafficMirrorFilterId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some
             ("network_services",
               (TrafficMirrorNetworkServiceList.to_json v.network_services));
           Some
             ("egress_filter_rules",
               (TrafficMirrorFilterRuleList.to_json v.egress_filter_rules));
           Some
             ("ingress_filter_rules",
               (TrafficMirrorFilterRuleList.to_json v.ingress_filter_rules));
           Util.option_map v.traffic_mirror_filter_id
             (fun f -> ("traffic_mirror_filter_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          traffic_mirror_filter_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterId" xml)
               String.parse);
          ingress_filter_rules =
            (Util.of_option []
               (Util.option_bind (Xml.member "ingressFilterRuleSet" xml)
                  TrafficMirrorFilterRuleList.parse));
          egress_filter_rules =
            (Util.of_option []
               (Util.option_bind (Xml.member "egressFilterRuleSet" xml)
                  TrafficMirrorFilterRuleList.parse));
          network_services =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkServiceSet" xml)
                  TrafficMirrorNetworkServiceList.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.traffic_mirror_filter_id
                   (fun f ->
                      Ezxmlm.make_tag "trafficMirrorFilterId"
                        ([], (String.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "ingressFilterRuleSet"
                          ([], (TrafficMirrorFilterRuleList.to_xml [x]))))
                  v.ingress_filter_rules))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "egressFilterRuleSet"
                         ([], (TrafficMirrorFilterRuleList.to_xml [x]))))
                 v.egress_filter_rules))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "networkServiceSet"
                        ([], (TrafficMirrorNetworkServiceList.to_xml [x]))))
                v.network_services))
            @
            [Util.option_map v.description
               (fun f ->
                  Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes the Traffic Mirror filter.</p>"]
module TransitGateway =
  struct
    type t =
      {
      transit_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway.</p>"];
      transit_gateway_arn: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the transit gateway.</p>"];
      state: TransitGatewayState.t option
        [@ocaml.doc "<p>The state of the transit gateway.</p>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account ID that owns the transit gateway.</p>"];
      description: String.t option
        [@ocaml.doc "<p>The description of the transit gateway.</p>"];
      creation_time: DateTime.t option
        [@ocaml.doc "<p>The creation time.</p>"];
      options: TransitGatewayOptions.t option
        [@ocaml.doc "<p>The transit gateway options.</p>"];
      tags: TagList.t [@ocaml.doc "<p>The tags for the transit gateway.</p>"]}
    [@@ocaml.doc "<p>Describes a transit gateway.</p>"]
    let make ?transit_gateway_id  ?transit_gateway_arn  ?state  ?owner_id 
      ?description  ?creation_time  ?options  ?(tags= [])  () =
      {
        transit_gateway_id;
        transit_gateway_arn;
        state;
        owner_id;
        description;
        creation_time;
        options;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.options
             (fun f ->
                Query.Pair ("Options", (TransitGatewayOptions.to_query f)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (TransitGatewayState.to_query f)));
           Util.option_map v.transit_gateway_arn
             (fun f -> Query.Pair ("TransitGatewayArn", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.options
             (fun f -> ("options", (TransitGatewayOptions.to_json f)));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (TransitGatewayState.to_json f)));
           Util.option_map v.transit_gateway_arn
             (fun f -> ("transit_gateway_arn", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          transit_gateway_arn =
            (Util.option_bind (Xml.member "transitGatewayArn" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayState.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          options =
            (Util.option_bind (Xml.member "options" xml)
               TransitGatewayOptions.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.transit_gateway_id
                     (fun f ->
                        Ezxmlm.make_tag "transitGatewayId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.transit_gateway_arn
                    (fun f ->
                       Ezxmlm.make_tag "transitGatewayArn"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.state
                   (fun f ->
                      Ezxmlm.make_tag "state"
                        ([], (TransitGatewayState.to_xml f)))])
               @
               [Util.option_map v.owner_id
                  (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
             @
             [Util.option_map v.creation_time
                (fun f ->
                   Ezxmlm.make_tag "creationTime" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.options
               (fun f ->
                  Ezxmlm.make_tag "options"
                    ([], (TransitGatewayOptions.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a transit gateway.</p>"]
module ClientVpnAuthenticationRequest =
  struct
    type t =
      {
      type_: ClientVpnAuthenticationType.t option
        [@ocaml.doc
          "<p>The type of client authentication to be used. Specify <code>certificate-authentication</code> to use certificate-based authentication, or <code>directory-service-authentication</code> to use Active Directory authentication.</p>"];
      active_directory: DirectoryServiceAuthenticationRequest.t option
        [@ocaml.doc
          "<p>Information about the Active Directory to be used, if applicable. You must provide this information if <b>Type</b> is <code>directory-service-authentication</code>.</p>"];
      mutual_authentication: CertificateAuthenticationRequest.t option
        [@ocaml.doc
          "<p>Information about the authentication certificates to be used, if applicable. You must provide this information if <b>Type</b> is <code>certificate-authentication</code>.</p>"]}
    [@@ocaml.doc
      "<p>Describes the authentication method to be used by a Client VPN endpoint. Client VPN supports Active Directory and mutual authentication. For more information, see <a href=\"https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/authentication-authrization.html#client-authentication\">Authentication</a> in the <i>AWS Client VPN Administrator Guide</i>.</p>"]
    let make ?type_  ?active_directory  ?mutual_authentication  () =
      { type_; active_directory; mutual_authentication }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.mutual_authentication
              (fun f ->
                 Query.Pair
                   ("MutualAuthentication",
                     (CertificateAuthenticationRequest.to_query f)));
           Util.option_map v.active_directory
             (fun f ->
                Query.Pair
                  ("ActiveDirectory",
                    (DirectoryServiceAuthenticationRequest.to_query f)));
           Util.option_map v.type_
             (fun f ->
                Query.Pair ("Type", (ClientVpnAuthenticationType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.mutual_authentication
              (fun f ->
                 ("mutual_authentication",
                   (CertificateAuthenticationRequest.to_json f)));
           Util.option_map v.active_directory
             (fun f ->
                ("active_directory",
                  (DirectoryServiceAuthenticationRequest.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (ClientVpnAuthenticationType.to_json f)))])
    let parse xml =
      Some
        {
          type_ =
            (Util.option_bind (Xml.member "Type" xml)
               ClientVpnAuthenticationType.parse);
          active_directory =
            (Util.option_bind (Xml.member "ActiveDirectory" xml)
               DirectoryServiceAuthenticationRequest.parse);
          mutual_authentication =
            (Util.option_bind (Xml.member "MutualAuthentication" xml)
               CertificateAuthenticationRequest.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.type_
                (fun f ->
                   Ezxmlm.make_tag "Type"
                     ([], (ClientVpnAuthenticationType.to_xml f)))])
            @
            [Util.option_map v.active_directory
               (fun f ->
                  Ezxmlm.make_tag "ActiveDirectory"
                    ([], (DirectoryServiceAuthenticationRequest.to_xml f)))])
           @
           [Util.option_map v.mutual_authentication
              (fun f ->
                 Ezxmlm.make_tag "MutualAuthentication"
                   ([], (CertificateAuthenticationRequest.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the authentication method to be used by a Client VPN endpoint. Client VPN supports Active Directory and mutual authentication. For more information, see <a href=\"https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/authentication-authrization.html#client-authentication\">Authentication</a> in the <i>AWS Client VPN Administrator Guide</i>.</p>"]
module ClassicLinkDnsSupport =
  struct
    type t =
      {
      classic_link_dns_supported: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether ClassicLink DNS support is enabled for the VPC.</p>"];
      vpc_id: String.t option [@ocaml.doc "<p>The ID of the VPC.</p>"]}
    [@@ocaml.doc
      "<p>Describes the ClassicLink DNS support status of a VPC.</p>"]
    let make ?classic_link_dns_supported  ?vpc_id  () =
      { classic_link_dns_supported; vpc_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.classic_link_dns_supported
             (fun f ->
                Query.Pair ("ClassicLinkDnsSupported", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.classic_link_dns_supported
             (fun f -> ("classic_link_dns_supported", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          classic_link_dns_supported =
            (Util.option_bind (Xml.member "classicLinkDnsSupported" xml)
               Boolean.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.classic_link_dns_supported
               (fun f ->
                  Ezxmlm.make_tag "classicLinkDnsSupported"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the ClassicLink DNS support status of a VPC.</p>"]
module ReservedInstancesListing =
  struct
    type t =
      {
      client_token: String.t option
        [@ocaml.doc
          "<p>A unique, case-sensitive key supplied by the client to ensure that the request is idempotent. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html\">Ensuring Idempotency</a>.</p>"];
      create_date: DateTime.t option
        [@ocaml.doc "<p>The time the listing was created.</p>"];
      instance_counts: InstanceCountList.t
        [@ocaml.doc "<p>The number of instances in this state.</p>"];
      price_schedules: PriceScheduleList.t
        [@ocaml.doc "<p>The price of the Reserved Instance listing.</p>"];
      reserved_instances_id: String.t option
        [@ocaml.doc "<p>The ID of the Reserved Instance.</p>"];
      reserved_instances_listing_id: String.t option
        [@ocaml.doc "<p>The ID of the Reserved Instance listing.</p>"];
      status: ListingStatus.t option
        [@ocaml.doc "<p>The status of the Reserved Instance listing.</p>"];
      status_message: String.t option
        [@ocaml.doc
          "<p>The reason for the current status of the Reserved Instance listing. The response can be blank.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the resource.</p>"];
      update_date: DateTime.t option
        [@ocaml.doc "<p>The last modified timestamp of the listing.</p>"]}
    [@@ocaml.doc "<p>Describes a Reserved Instance listing.</p>"]
    let make ?client_token  ?create_date  ?(instance_counts= []) 
      ?(price_schedules= [])  ?reserved_instances_id 
      ?reserved_instances_listing_id  ?status  ?status_message  ?(tags= []) 
      ?update_date  () =
      {
        client_token;
        create_date;
        instance_counts;
        price_schedules;
        reserved_instances_id;
        reserved_instances_listing_id;
        status;
        status_message;
        tags;
        update_date
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.update_date
              (fun f -> Query.Pair ("UpdateDate", (DateTime.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (ListingStatus.to_query f)));
           Util.option_map v.reserved_instances_listing_id
             (fun f ->
                Query.Pair
                  ("ReservedInstancesListingId", (String.to_query f)));
           Util.option_map v.reserved_instances_id
             (fun f ->
                Query.Pair ("ReservedInstancesId", (String.to_query f)));
           Some
             (Query.Pair
                ("PriceSchedules",
                  (PriceScheduleList.to_query v.price_schedules)));
           Some
             (Query.Pair
                ("InstanceCounts",
                  (InstanceCountList.to_query v.instance_counts)));
           Util.option_map v.create_date
             (fun f -> Query.Pair ("CreateDate", (DateTime.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.update_date
              (fun f -> ("update_date", (DateTime.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ListingStatus.to_json f)));
           Util.option_map v.reserved_instances_listing_id
             (fun f -> ("reserved_instances_listing_id", (String.to_json f)));
           Util.option_map v.reserved_instances_id
             (fun f -> ("reserved_instances_id", (String.to_json f)));
           Some
             ("price_schedules",
               (PriceScheduleList.to_json v.price_schedules));
           Some
             ("instance_counts",
               (InstanceCountList.to_json v.instance_counts));
           Util.option_map v.create_date
             (fun f -> ("create_date", (DateTime.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          create_date =
            (Util.option_bind (Xml.member "createDate" xml) DateTime.parse);
          instance_counts =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceCounts" xml)
                  InstanceCountList.parse));
          price_schedules =
            (Util.of_option []
               (Util.option_bind (Xml.member "priceSchedules" xml)
                  PriceScheduleList.parse));
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse);
          reserved_instances_listing_id =
            (Util.option_bind (Xml.member "reservedInstancesListingId" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml) ListingStatus.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          update_date =
            (Util.option_bind (Xml.member "updateDate" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.client_token
                       (fun f ->
                          Ezxmlm.make_tag "clientToken"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.create_date
                      (fun f ->
                         Ezxmlm.make_tag "createDate"
                           ([], (DateTime.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "instanceCounts"
                             ([], (InstanceCountList.to_xml [x]))))
                     v.instance_counts))
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "priceSchedules"
                            ([], (PriceScheduleList.to_xml [x]))))
                    v.price_schedules))
                @
                [Util.option_map v.reserved_instances_id
                   (fun f ->
                      Ezxmlm.make_tag "reservedInstancesId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.reserved_instances_listing_id
                  (fun f ->
                     Ezxmlm.make_tag "reservedInstancesListingId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.status
                 (fun f ->
                    Ezxmlm.make_tag "status" ([], (ListingStatus.to_xml f)))])
             @
             [Util.option_map v.status_message
                (fun f ->
                   Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           [Util.option_map v.update_date
              (fun f ->
                 Ezxmlm.make_tag "updateDate" ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a Reserved Instance listing.</p>"]
module InstanceStateChange =
  struct
    type t =
      {
      current_state: InstanceState.t option
        [@ocaml.doc "<p>The current state of the instance.</p>"];
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"];
      previous_state: InstanceState.t option
        [@ocaml.doc "<p>The previous state of the instance.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes an instance state change.</p>"]
    let make ?current_state  ?instance_id  ?previous_state  () =
      { current_state; instance_id; previous_state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.previous_state
              (fun f ->
                 Query.Pair ("PreviousState", (InstanceState.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.current_state
             (fun f ->
                Query.Pair ("CurrentState", (InstanceState.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.previous_state
              (fun f -> ("previous_state", (InstanceState.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.current_state
             (fun f -> ("current_state", (InstanceState.to_json f)))])
    let parse xml =
      Some
        {
          current_state =
            (Util.option_bind (Xml.member "currentState" xml)
               InstanceState.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          previous_state =
            (Util.option_bind (Xml.member "previousState" xml)
               InstanceState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.current_state
                (fun f ->
                   Ezxmlm.make_tag "currentState"
                     ([], (InstanceState.to_xml f)))])
            @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.previous_state
              (fun f ->
                 Ezxmlm.make_tag "previousState"
                   ([], (InstanceState.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an instance state change.</p>"]
module ClientCertificateRevocationListStatusCode =
  struct
    type t =
      | Pending 
      | Active 
    let str_to_t = [("active", Active); ("pending", Pending)]
    let t_to_str = [(Active, "active"); (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module TerminateConnectionStatus =
  struct
    type t =
      {
      connection_id: String.t option
        [@ocaml.doc "<p>The ID of the client connection.</p>"];
      previous_status: ClientVpnConnectionStatus.t option
        [@ocaml.doc "<p>The state of the client connection.</p>"];
      current_status: ClientVpnConnectionStatus.t option
        [@ocaml.doc
          "<p>A message about the status of the client connection, if applicable.</p>"]}
    [@@ocaml.doc
      "<p>Information about a terminated Client VPN endpoint client connection.</p>"]
    let make ?connection_id  ?previous_status  ?current_status  () =
      { connection_id; previous_status; current_status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.current_status
              (fun f ->
                 Query.Pair
                   ("CurrentStatus", (ClientVpnConnectionStatus.to_query f)));
           Util.option_map v.previous_status
             (fun f ->
                Query.Pair
                  ("PreviousStatus", (ClientVpnConnectionStatus.to_query f)));
           Util.option_map v.connection_id
             (fun f -> Query.Pair ("ConnectionId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.current_status
              (fun f ->
                 ("current_status", (ClientVpnConnectionStatus.to_json f)));
           Util.option_map v.previous_status
             (fun f ->
                ("previous_status", (ClientVpnConnectionStatus.to_json f)));
           Util.option_map v.connection_id
             (fun f -> ("connection_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          connection_id =
            (Util.option_bind (Xml.member "connectionId" xml) String.parse);
          previous_status =
            (Util.option_bind (Xml.member "previousStatus" xml)
               ClientVpnConnectionStatus.parse);
          current_status =
            (Util.option_bind (Xml.member "currentStatus" xml)
               ClientVpnConnectionStatus.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.connection_id
                (fun f ->
                   Ezxmlm.make_tag "connectionId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.previous_status
               (fun f ->
                  Ezxmlm.make_tag "previousStatus"
                    ([], (ClientVpnConnectionStatus.to_xml f)))])
           @
           [Util.option_map v.current_status
              (fun f ->
                 Ezxmlm.make_tag "currentStatus"
                   ([], (ClientVpnConnectionStatus.to_xml f)))])
  end[@@ocaml.doc
       "<p>Information about a terminated Client VPN endpoint client connection.</p>"]
module InstanceTypeOffering =
  struct
    type t =
      {
      instance_type: InstanceType.t option
        [@ocaml.doc
          "<p>The instance type. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html\">Instance Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"];
      location_type: LocationType.t option
        [@ocaml.doc "<p>The location type.</p>"];
      location: String.t option
        [@ocaml.doc
          "<p>The identifier for the location. This depends on the location type. For example, if the location type is <code>region</code>, the location is the Region code (for example, <code>us-east-2</code>.)</p>"]}
    [@@ocaml.doc "<p>The instance types offered.</p>"]
    let make ?instance_type  ?location_type  ?location  () =
      { instance_type; location_type; location }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.location
              (fun f -> Query.Pair ("Location", (String.to_query f)));
           Util.option_map v.location_type
             (fun f -> Query.Pair ("LocationType", (LocationType.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.location
              (fun f -> ("location", (String.to_json f)));
           Util.option_map v.location_type
             (fun f -> ("location_type", (LocationType.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)))])
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          location_type =
            (Util.option_bind (Xml.member "locationType" xml)
               LocationType.parse);
          location =
            (Util.option_bind (Xml.member "location" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.instance_type
                (fun f ->
                   Ezxmlm.make_tag "instanceType"
                     ([], (InstanceType.to_xml f)))])
            @
            [Util.option_map v.location_type
               (fun f ->
                  Ezxmlm.make_tag "locationType"
                    ([], (LocationType.to_xml f)))])
           @
           [Util.option_map v.location
              (fun f -> Ezxmlm.make_tag "location" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>The instance types offered.</p>"]
module InstanceStatus =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc "<p>The Availability Zone of the instance.</p>"];
      outpost_arn: String.t option
        [@ocaml.doc "<p>The Amazon Resource Name (ARN) of the Outpost.</p>"];
      events: InstanceStatusEventList.t
        [@ocaml.doc
          "<p>Any scheduled events associated with the instance.</p>"];
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"];
      instance_state: InstanceState.t option
        [@ocaml.doc
          "<p>The intended state of the instance. <a>DescribeInstanceStatus</a> requires that an instance be in the <code>running</code> state.</p>"];
      instance_status: InstanceStatusSummary.t option
        [@ocaml.doc
          "<p>Reports impaired functionality that stems from issues internal to the instance, such as impaired reachability.</p>"];
      system_status: InstanceStatusSummary.t option
        [@ocaml.doc
          "<p>Reports impaired functionality that stems from issues related to the systems that support an instance, such as hardware failures and network connectivity problems.</p>"]}
    [@@ocaml.doc "<p>Describes the status of an instance.</p>"]
    let make ?availability_zone  ?outpost_arn  ?(events= [])  ?instance_id 
      ?instance_state  ?instance_status  ?system_status  () =
      {
        availability_zone;
        outpost_arn;
        events;
        instance_id;
        instance_state;
        instance_status;
        system_status
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.system_status
              (fun f ->
                 Query.Pair
                   ("SystemStatus", (InstanceStatusSummary.to_query f)));
           Util.option_map v.instance_status
             (fun f ->
                Query.Pair
                  ("InstanceStatus", (InstanceStatusSummary.to_query f)));
           Util.option_map v.instance_state
             (fun f ->
                Query.Pair ("InstanceState", (InstanceState.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Some
             (Query.Pair
                ("EventsSet", (InstanceStatusEventList.to_query v.events)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.system_status
              (fun f -> ("system_status", (InstanceStatusSummary.to_json f)));
           Util.option_map v.instance_status
             (fun f -> ("instance_status", (InstanceStatusSummary.to_json f)));
           Util.option_map v.instance_state
             (fun f -> ("instance_state", (InstanceState.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Some ("events", (InstanceStatusEventList.to_json v.events));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          events =
            (Util.of_option []
               (Util.option_bind (Xml.member "eventsSet" xml)
                  InstanceStatusEventList.parse));
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_state =
            (Util.option_bind (Xml.member "instanceState" xml)
               InstanceState.parse);
          instance_status =
            (Util.option_bind (Xml.member "instanceStatus" xml)
               InstanceStatusSummary.parse);
          system_status =
            (Util.option_bind (Xml.member "systemStatus" xml)
               InstanceStatusSummary.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.availability_zone
                    (fun f ->
                       Ezxmlm.make_tag "availabilityZone"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.outpost_arn
                   (fun f ->
                      Ezxmlm.make_tag "outpostArn" ([], (String.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "eventsSet"
                          ([], (InstanceStatusEventList.to_xml [x]))))
                  v.events))
              @
              [Util.option_map v.instance_id
                 (fun f ->
                    Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.instance_state
                (fun f ->
                   Ezxmlm.make_tag "instanceState"
                     ([], (InstanceState.to_xml f)))])
            @
            [Util.option_map v.instance_status
               (fun f ->
                  Ezxmlm.make_tag "instanceStatus"
                    ([], (InstanceStatusSummary.to_xml f)))])
           @
           [Util.option_map v.system_status
              (fun f ->
                 Ezxmlm.make_tag "systemStatus"
                   ([], (InstanceStatusSummary.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the status of an instance.</p>"]
module Image =
  struct
    type t =
      {
      architecture: ArchitectureValues.t
        [@ocaml.doc "<p>The architecture of the image.</p>"];
      creation_date: String.t option
        [@ocaml.doc "<p>The date and time the image was created.</p>"];
      image_id: String.t [@ocaml.doc "<p>The ID of the AMI.</p>"];
      image_location: String.t [@ocaml.doc "<p>The location of the AMI.</p>"];
      image_type: ImageTypeValues.t [@ocaml.doc "<p>The type of image.</p>"];
      public: Boolean.t
        [@ocaml.doc
          "<p>Indicates whether the image has public launch permissions. The value is <code>true</code> if this image has public launch permissions or <code>false</code> if it has only implicit and explicit launch permissions.</p>"];
      kernel_id: String.t option
        [@ocaml.doc
          "<p>The kernel associated with the image, if any. Only applicable for machine images.</p>"];
      owner_id: String.t
        [@ocaml.doc "<p>The AWS account ID of the image owner.</p>"];
      platform: PlatformValues.t option
        [@ocaml.doc
          "<p>This value is set to <code>windows</code> for Windows AMIs; otherwise, it is blank.</p>"];
      product_codes: ProductCodeList.t
        [@ocaml.doc "<p>Any product codes associated with the AMI.</p>"];
      ramdisk_id: String.t option
        [@ocaml.doc
          "<p>The RAM disk associated with the image, if any. Only applicable for machine images.</p>"];
      state: ImageState.t
        [@ocaml.doc
          "<p>The current state of the AMI. If the state is <code>available</code>, the image is successfully registered and can be used to launch an instance.</p>"];
      block_device_mappings: BlockDeviceMappingList.t
        [@ocaml.doc "<p>Any block device mapping entries.</p>"];
      description: String.t option
        [@ocaml.doc
          "<p>The description of the AMI that was provided during image creation.</p>"];
      ena_support: Boolean.t option
        [@ocaml.doc
          "<p>Specifies whether enhanced networking with ENA is enabled.</p>"];
      hypervisor: HypervisorType.t
        [@ocaml.doc "<p>The hypervisor type of the image.</p>"];
      image_owner_alias: String.t option
        [@ocaml.doc
          "<p>The AWS account alias (for example, <code>amazon</code>, <code>self</code>) or the AWS account ID of the AMI owner.</p>"];
      name: String.t option
        [@ocaml.doc
          "<p>The name of the AMI that was provided during image creation.</p>"];
      root_device_name: String.t option
        [@ocaml.doc
          "<p>The device name of the root device volume (for example, <code>/dev/sda1</code>).</p>"];
      root_device_type: DeviceType.t
        [@ocaml.doc
          "<p>The type of root device used by the AMI. The AMI can use an EBS volume or an instance store volume.</p>"];
      sriov_net_support: String.t option
        [@ocaml.doc
          "<p>Specifies whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>"];
      state_reason: StateReason.t option
        [@ocaml.doc "<p>The reason for the state change.</p>"];
      tags: TagList.t [@ocaml.doc "<p>Any tags assigned to the image.</p>"];
      virtualization_type: VirtualizationType.t
        [@ocaml.doc "<p>The type of virtualization of the AMI.</p>"]}
    [@@ocaml.doc "<p>Describes an image.</p>"]
    let make ~architecture  ?creation_date  ~image_id  ~image_location 
      ~image_type  ~public  ?kernel_id  ~owner_id  ?platform 
      ?(product_codes= [])  ?ramdisk_id  ~state  ?(block_device_mappings= [])
       ?description  ?ena_support  ~hypervisor  ?image_owner_alias  ?name 
      ?root_device_name  ~root_device_type  ?sriov_net_support  ?state_reason
       ?(tags= [])  ~virtualization_type  () =
      {
        architecture;
        creation_date;
        image_id;
        image_location;
        image_type;
        public;
        kernel_id;
        owner_id;
        platform;
        product_codes;
        ramdisk_id;
        state;
        block_device_mappings;
        description;
        ena_support;
        hypervisor;
        image_owner_alias;
        name;
        root_device_name;
        root_device_type;
        sriov_net_support;
        state_reason;
        tags;
        virtualization_type
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VirtualizationType",
                   (VirtualizationType.to_query v.virtualization_type)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.state_reason
             (fun f -> Query.Pair ("StateReason", (StateReason.to_query f)));
           Util.option_map v.sriov_net_support
             (fun f -> Query.Pair ("SriovNetSupport", (String.to_query f)));
           Some
             (Query.Pair
                ("RootDeviceType", (DeviceType.to_query v.root_device_type)));
           Util.option_map v.root_device_name
             (fun f -> Query.Pair ("RootDeviceName", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.image_owner_alias
             (fun f -> Query.Pair ("ImageOwnerAlias", (String.to_query f)));
           Some
             (Query.Pair
                ("Hypervisor", (HypervisorType.to_query v.hypervisor)));
           Util.option_map v.ena_support
             (fun f -> Query.Pair ("EnaSupport", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Some (Query.Pair ("ImageState", (ImageState.to_query v.state)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Some (Query.Pair ("ImageOwnerId", (String.to_query v.owner_id)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Some (Query.Pair ("IsPublic", (Boolean.to_query v.public)));
           Some
             (Query.Pair
                ("ImageType", (ImageTypeValues.to_query v.image_type)));
           Some
             (Query.Pair
                ("ImageLocation", (String.to_query v.image_location)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Util.option_map v.creation_date
             (fun f -> Query.Pair ("CreationDate", (String.to_query f)));
           Some
             (Query.Pair
                ("Architecture",
                  (ArchitectureValues.to_query v.architecture)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("virtualization_type",
                (VirtualizationType.to_json v.virtualization_type));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.state_reason
             (fun f -> ("state_reason", (StateReason.to_json f)));
           Util.option_map v.sriov_net_support
             (fun f -> ("sriov_net_support", (String.to_json f)));
           Some ("root_device_type", (DeviceType.to_json v.root_device_type));
           Util.option_map v.root_device_name
             (fun f -> ("root_device_name", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.image_owner_alias
             (fun f -> ("image_owner_alias", (String.to_json f)));
           Some ("hypervisor", (HypervisorType.to_json v.hypervisor));
           Util.option_map v.ena_support
             (fun f -> ("ena_support", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings));
           Some ("state", (ImageState.to_json v.state));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Util.option_map v.platform
             (fun f -> ("platform", (PlatformValues.to_json f)));
           Some ("owner_id", (String.to_json v.owner_id));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Some ("public", (Boolean.to_json v.public));
           Some ("image_type", (ImageTypeValues.to_json v.image_type));
           Some ("image_location", (String.to_json v.image_location));
           Some ("image_id", (String.to_json v.image_id));
           Util.option_map v.creation_date
             (fun f -> ("creation_date", (String.to_json f)));
           Some ("architecture", (ArchitectureValues.to_json v.architecture))])
    let parse xml =
      Some
        {
          architecture =
            (Xml.required "architecture"
               (Util.option_bind (Xml.member "architecture" xml)
                  ArchitectureValues.parse));
          creation_date =
            (Util.option_bind (Xml.member "creationDate" xml) String.parse);
          image_id =
            (Xml.required "imageId"
               (Util.option_bind (Xml.member "imageId" xml) String.parse));
          image_location =
            (Xml.required "imageLocation"
               (Util.option_bind (Xml.member "imageLocation" xml)
                  String.parse));
          image_type =
            (Xml.required "imageType"
               (Util.option_bind (Xml.member "imageType" xml)
                  ImageTypeValues.parse));
          public =
            (Xml.required "isPublic"
               (Util.option_bind (Xml.member "isPublic" xml) Boolean.parse));
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          owner_id =
            (Xml.required "imageOwnerId"
               (Util.option_bind (Xml.member "imageOwnerId" xml) String.parse));
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          state =
            (Xml.required "imageState"
               (Util.option_bind (Xml.member "imageState" xml)
                  ImageState.parse));
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          ena_support =
            (Util.option_bind (Xml.member "enaSupport" xml) Boolean.parse);
          hypervisor =
            (Xml.required "hypervisor"
               (Util.option_bind (Xml.member "hypervisor" xml)
                  HypervisorType.parse));
          image_owner_alias =
            (Util.option_bind (Xml.member "imageOwnerAlias" xml) String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          root_device_name =
            (Util.option_bind (Xml.member "rootDeviceName" xml) String.parse);
          root_device_type =
            (Xml.required "rootDeviceType"
               (Util.option_bind (Xml.member "rootDeviceType" xml)
                  DeviceType.parse));
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml) String.parse);
          state_reason =
            (Util.option_bind (Xml.member "stateReason" xml)
               StateReason.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          virtualization_type =
            (Xml.required "virtualizationType"
               (Util.option_bind (Xml.member "virtualizationType" xml)
                  VirtualizationType.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((((((((([] @
                                  [Some
                                     (Ezxmlm.make_tag "architecture"
                                        ([],
                                          (ArchitectureValues.to_xml
                                             v.architecture)))])
                                 @
                                 [Util.option_map v.creation_date
                                    (fun f ->
                                       Ezxmlm.make_tag "creationDate"
                                         ([], (String.to_xml f)))])
                                @
                                [Some
                                   (Ezxmlm.make_tag "imageId"
                                      ([], (String.to_xml v.image_id)))])
                               @
                               [Some
                                  (Ezxmlm.make_tag "imageLocation"
                                     ([], (String.to_xml v.image_location)))])
                              @
                              [Some
                                 (Ezxmlm.make_tag "imageType"
                                    ([],
                                      (ImageTypeValues.to_xml v.image_type)))])
                             @
                             [Some
                                (Ezxmlm.make_tag "isPublic"
                                   ([], (Boolean.to_xml v.public)))])
                            @
                            [Util.option_map v.kernel_id
                               (fun f ->
                                  Ezxmlm.make_tag "kernelId"
                                    ([], (String.to_xml f)))])
                           @
                           [Some
                              (Ezxmlm.make_tag "imageOwnerId"
                                 ([], (String.to_xml v.owner_id)))])
                          @
                          [Util.option_map v.platform
                             (fun f ->
                                Ezxmlm.make_tag "platform"
                                  ([], (PlatformValues.to_xml f)))])
                         @
                         (List.map
                            (fun x ->
                               Some
                                 (Ezxmlm.make_tag "productCodes"
                                    ([], (ProductCodeList.to_xml [x]))))
                            v.product_codes))
                        @
                        [Util.option_map v.ramdisk_id
                           (fun f ->
                              Ezxmlm.make_tag "ramdiskId"
                                ([], (String.to_xml f)))])
                       @
                       [Some
                          (Ezxmlm.make_tag "imageState"
                             ([], (ImageState.to_xml v.state)))])
                      @
                      (List.map
                         (fun x ->
                            Some
                              (Ezxmlm.make_tag "blockDeviceMapping"
                                 ([], (BlockDeviceMappingList.to_xml [x]))))
                         v.block_device_mappings))
                     @
                     [Util.option_map v.description
                        (fun f ->
                           Ezxmlm.make_tag "description"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.ena_support
                       (fun f ->
                          Ezxmlm.make_tag "enaSupport"
                            ([], (Boolean.to_xml f)))])
                   @
                   [Some
                      (Ezxmlm.make_tag "hypervisor"
                         ([], (HypervisorType.to_xml v.hypervisor)))])
                  @
                  [Util.option_map v.image_owner_alias
                     (fun f ->
                        Ezxmlm.make_tag "imageOwnerAlias"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.name
                    (fun f -> Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
                @
                [Util.option_map v.root_device_name
                   (fun f ->
                      Ezxmlm.make_tag "rootDeviceName"
                        ([], (String.to_xml f)))])
               @
               [Some
                  (Ezxmlm.make_tag "rootDeviceType"
                     ([], (DeviceType.to_xml v.root_device_type)))])
              @
              [Util.option_map v.sriov_net_support
                 (fun f ->
                    Ezxmlm.make_tag "sriovNetSupport" ([], (String.to_xml f)))])
             @
             [Util.option_map v.state_reason
                (fun f ->
                   Ezxmlm.make_tag "stateReason" ([], (StateReason.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           [Some
              (Ezxmlm.make_tag "virtualizationType"
                 ([], (VirtualizationType.to_xml v.virtualization_type)))])
  end[@@ocaml.doc "<p>Describes an image.</p>"]
module PriceScheduleSpecification =
  struct
    type t =
      {
      currency_code: CurrencyCodeValues.t option
        [@ocaml.doc
          "<p>The currency for transacting the Reserved Instance resale. At this time, the only supported currency is <code>USD</code>.</p>"];
      price: Double.t option
        [@ocaml.doc "<p>The fixed price for the term.</p>"];
      term: Long.t option
        [@ocaml.doc
          "<p>The number of months remaining in the reservation. For example, 2 is the second to the last month before the capacity reservation expires.</p>"]}
    [@@ocaml.doc "<p>Describes the price for a Reserved Instance.</p>"]
    let make ?currency_code  ?price  ?term  () =
      { currency_code; price; term }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.term
              (fun f -> Query.Pair ("Term", (Long.to_query f)));
           Util.option_map v.price
             (fun f -> Query.Pair ("Price", (Double.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.term (fun f -> ("term", (Long.to_json f)));
           Util.option_map v.price (fun f -> ("price", (Double.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)))])
    let parse xml =
      Some
        {
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          price = (Util.option_bind (Xml.member "price" xml) Double.parse);
          term = (Util.option_bind (Xml.member "term" xml) Long.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.currency_code
                (fun f ->
                   Ezxmlm.make_tag "currencyCode"
                     ([], (CurrencyCodeValues.to_xml f)))])
            @
            [Util.option_map v.price
               (fun f -> Ezxmlm.make_tag "price" ([], (Double.to_xml f)))])
           @
           [Util.option_map v.term
              (fun f -> Ezxmlm.make_tag "term" ([], (Long.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the price for a Reserved Instance.</p>"]
module ImportSnapshotTask =
  struct
    type t =
      {
      description: String.t option
        [@ocaml.doc "<p>A description of the import snapshot task.</p>"];
      import_task_id: String.t option
        [@ocaml.doc "<p>The ID of the import snapshot task.</p>"];
      snapshot_task_detail: SnapshotTaskDetail.t option
        [@ocaml.doc "<p>Describes an import snapshot task.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags applied to the import snapshot task.</p>"]}
    [@@ocaml.doc "<p>Describes an import snapshot task.</p>"]
    let make ?description  ?import_task_id  ?snapshot_task_detail  ?(tags=
      [])  () = { description; import_task_id; snapshot_task_detail; tags }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.snapshot_task_detail
             (fun f ->
                Query.Pair
                  ("SnapshotTaskDetail", (SnapshotTaskDetail.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.snapshot_task_detail
             (fun f ->
                ("snapshot_task_detail", (SnapshotTaskDetail.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          snapshot_task_detail =
            (Util.option_bind (Xml.member "snapshotTaskDetail" xml)
               SnapshotTaskDetail.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
             @
             [Util.option_map v.import_task_id
                (fun f ->
                   Ezxmlm.make_tag "importTaskId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.snapshot_task_detail
               (fun f ->
                  Ezxmlm.make_tag "snapshotTaskDetail"
                    ([], (SnapshotTaskDetail.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes an import snapshot task.</p>"]
module NetworkInterfacePermission =
  struct
    type t =
      {
      network_interface_permission_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface permission.</p>"];
      network_interface_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface.</p>"];
      aws_account_id: String.t option
        [@ocaml.doc "<p>The AWS account ID.</p>"];
      aws_service: String.t option [@ocaml.doc "<p>The AWS service.</p>"];
      permission: InterfacePermissionType.t option
        [@ocaml.doc "<p>The type of permission.</p>"];
      permission_state: NetworkInterfacePermissionState.t option
        [@ocaml.doc "<p>Information about the state of the permission.</p>"]}
    [@@ocaml.doc "<p>Describes a permission for a network interface.</p>"]
    let make ?network_interface_permission_id  ?network_interface_id 
      ?aws_account_id  ?aws_service  ?permission  ?permission_state  () =
      {
        network_interface_permission_id;
        network_interface_id;
        aws_account_id;
        aws_service;
        permission;
        permission_state
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.permission_state
              (fun f ->
                 Query.Pair
                   ("PermissionState",
                     (NetworkInterfacePermissionState.to_query f)));
           Util.option_map v.permission
             (fun f ->
                Query.Pair
                  ("Permission", (InterfacePermissionType.to_query f)));
           Util.option_map v.aws_service
             (fun f -> Query.Pair ("AwsService", (String.to_query f)));
           Util.option_map v.aws_account_id
             (fun f -> Query.Pair ("AwsAccountId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.network_interface_permission_id
             (fun f ->
                Query.Pair
                  ("NetworkInterfacePermissionId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.permission_state
              (fun f ->
                 ("permission_state",
                   (NetworkInterfacePermissionState.to_json f)));
           Util.option_map v.permission
             (fun f -> ("permission", (InterfacePermissionType.to_json f)));
           Util.option_map v.aws_service
             (fun f -> ("aws_service", (String.to_json f)));
           Util.option_map v.aws_account_id
             (fun f -> ("aws_account_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.network_interface_permission_id
             (fun f ->
                ("network_interface_permission_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          network_interface_permission_id =
            (Util.option_bind (Xml.member "networkInterfacePermissionId" xml)
               String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          aws_account_id =
            (Util.option_bind (Xml.member "awsAccountId" xml) String.parse);
          aws_service =
            (Util.option_bind (Xml.member "awsService" xml) String.parse);
          permission =
            (Util.option_bind (Xml.member "permission" xml)
               InterfacePermissionType.parse);
          permission_state =
            (Util.option_bind (Xml.member "permissionState" xml)
               NetworkInterfacePermissionState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.network_interface_permission_id
                   (fun f ->
                      Ezxmlm.make_tag "networkInterfacePermissionId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.network_interface_id
                  (fun f ->
                     Ezxmlm.make_tag "networkInterfaceId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.aws_account_id
                 (fun f ->
                    Ezxmlm.make_tag "awsAccountId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.aws_service
                (fun f ->
                   Ezxmlm.make_tag "awsService" ([], (String.to_xml f)))])
            @
            [Util.option_map v.permission
               (fun f ->
                  Ezxmlm.make_tag "permission"
                    ([], (InterfacePermissionType.to_xml f)))])
           @
           [Util.option_map v.permission_state
              (fun f ->
                 Ezxmlm.make_tag "permissionState"
                   ([], (NetworkInterfacePermissionState.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a permission for a network interface.</p>"]
module Host =
  struct
    type t =
      {
      auto_placement: AutoPlacement.t option
        [@ocaml.doc "<p>Whether auto-placement is on or off.</p>"];
      availability_zone: String.t option
        [@ocaml.doc "<p>The Availability Zone of the Dedicated Host.</p>"];
      available_capacity: AvailableCapacity.t option
        [@ocaml.doc
          "<p>Information about the instances running on the Dedicated Host.</p>"];
      client_token: String.t option
        [@ocaml.doc
          "<p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html\">How to Ensure Idempotency</a>.</p>"];
      host_id: String.t option
        [@ocaml.doc "<p>The ID of the Dedicated Host.</p>"];
      host_properties: HostProperties.t option
        [@ocaml.doc
          "<p>The hardware specifications of the Dedicated Host.</p>"];
      host_reservation_id: String.t option
        [@ocaml.doc
          "<p>The reservation ID of the Dedicated Host. This returns a <code>null</code> response if the Dedicated Host doesn't have an associated reservation.</p>"];
      instances: HostInstanceList.t
        [@ocaml.doc
          "<p>The IDs and instance type that are currently running on the Dedicated Host.</p>"];
      state: AllocationState.t option
        [@ocaml.doc "<p>The Dedicated Host's state.</p>"];
      allocation_time: DateTime.t option
        [@ocaml.doc "<p>The time that the Dedicated Host was allocated.</p>"];
      release_time: DateTime.t option
        [@ocaml.doc "<p>The time that the Dedicated Host was released.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the Dedicated Host.</p>"];
      host_recovery: HostRecovery.t option
        [@ocaml.doc
          "<p>Indicates whether host recovery is enabled or disabled for the Dedicated Host.</p>"];
      allows_multiple_instance_types: AllowsMultipleInstanceTypes.t option
        [@ocaml.doc
          "<p>Indicates whether the Dedicated Host supports multiple instance types of the same instance family, or a specific instance type only. <code>one</code> indicates that the Dedicated Host supports multiple instance types in the instance family. <code>off</code> indicates that the Dedicated Host supports a single instance type only.</p>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account that owns the Dedicated Host.</p>"];
      availability_zone_id: String.t option
        [@ocaml.doc
          "<p>The ID of the Availability Zone in which the Dedicated Host is allocated.</p>"];
      member_of_service_linked_resource_group: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the Dedicated Host is in a host resource group. If <b>memberOfServiceLinkedResourceGroup</b> is <code>true</code>, the host is in a host resource group; otherwise, it is not.</p>"]}
    [@@ocaml.doc "<p>Describes the properties of the Dedicated Host.</p>"]
    let make ?auto_placement  ?availability_zone  ?available_capacity 
      ?client_token  ?host_id  ?host_properties  ?host_reservation_id 
      ?(instances= [])  ?state  ?allocation_time  ?release_time  ?(tags= []) 
      ?host_recovery  ?allows_multiple_instance_types  ?owner_id 
      ?availability_zone_id  ?member_of_service_linked_resource_group  () =
      {
        auto_placement;
        availability_zone;
        available_capacity;
        client_token;
        host_id;
        host_properties;
        host_reservation_id;
        instances;
        state;
        allocation_time;
        release_time;
        tags;
        host_recovery;
        allows_multiple_instance_types;
        owner_id;
        availability_zone_id;
        member_of_service_linked_resource_group
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.member_of_service_linked_resource_group
              (fun f ->
                 Query.Pair
                   ("MemberOfServiceLinkedResourceGroup",
                     (Boolean.to_query f)));
           Util.option_map v.availability_zone_id
             (fun f -> Query.Pair ("AvailabilityZoneId", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.allows_multiple_instance_types
             (fun f ->
                Query.Pair
                  ("AllowsMultipleInstanceTypes",
                    (AllowsMultipleInstanceTypes.to_query f)));
           Util.option_map v.host_recovery
             (fun f -> Query.Pair ("HostRecovery", (HostRecovery.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.release_time
             (fun f -> Query.Pair ("ReleaseTime", (DateTime.to_query f)));
           Util.option_map v.allocation_time
             (fun f -> Query.Pair ("AllocationTime", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (AllocationState.to_query f)));
           Some
             (Query.Pair
                ("Instances", (HostInstanceList.to_query v.instances)));
           Util.option_map v.host_reservation_id
             (fun f -> Query.Pair ("HostReservationId", (String.to_query f)));
           Util.option_map v.host_properties
             (fun f ->
                Query.Pair ("HostProperties", (HostProperties.to_query f)));
           Util.option_map v.host_id
             (fun f -> Query.Pair ("HostId", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.available_capacity
             (fun f ->
                Query.Pair
                  ("AvailableCapacity", (AvailableCapacity.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.auto_placement
             (fun f ->
                Query.Pair ("AutoPlacement", (AutoPlacement.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.member_of_service_linked_resource_group
              (fun f ->
                 ("member_of_service_linked_resource_group",
                   (Boolean.to_json f)));
           Util.option_map v.availability_zone_id
             (fun f -> ("availability_zone_id", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.allows_multiple_instance_types
             (fun f ->
                ("allows_multiple_instance_types",
                  (AllowsMultipleInstanceTypes.to_json f)));
           Util.option_map v.host_recovery
             (fun f -> ("host_recovery", (HostRecovery.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.release_time
             (fun f -> ("release_time", (DateTime.to_json f)));
           Util.option_map v.allocation_time
             (fun f -> ("allocation_time", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (AllocationState.to_json f)));
           Some ("instances", (HostInstanceList.to_json v.instances));
           Util.option_map v.host_reservation_id
             (fun f -> ("host_reservation_id", (String.to_json f)));
           Util.option_map v.host_properties
             (fun f -> ("host_properties", (HostProperties.to_json f)));
           Util.option_map v.host_id
             (fun f -> ("host_id", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.available_capacity
             (fun f -> ("available_capacity", (AvailableCapacity.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.auto_placement
             (fun f -> ("auto_placement", (AutoPlacement.to_json f)))])
    let parse xml =
      Some
        {
          auto_placement =
            (Util.option_bind (Xml.member "autoPlacement" xml)
               AutoPlacement.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          available_capacity =
            (Util.option_bind (Xml.member "availableCapacity" xml)
               AvailableCapacity.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          host_id = (Util.option_bind (Xml.member "hostId" xml) String.parse);
          host_properties =
            (Util.option_bind (Xml.member "hostProperties" xml)
               HostProperties.parse);
          host_reservation_id =
            (Util.option_bind (Xml.member "hostReservationId" xml)
               String.parse);
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instances" xml)
                  HostInstanceList.parse));
          state =
            (Util.option_bind (Xml.member "state" xml) AllocationState.parse);
          allocation_time =
            (Util.option_bind (Xml.member "allocationTime" xml)
               DateTime.parse);
          release_time =
            (Util.option_bind (Xml.member "releaseTime" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          host_recovery =
            (Util.option_bind (Xml.member "hostRecovery" xml)
               HostRecovery.parse);
          allows_multiple_instance_types =
            (Util.option_bind (Xml.member "allowsMultipleInstanceTypes" xml)
               AllowsMultipleInstanceTypes.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          availability_zone_id =
            (Util.option_bind (Xml.member "availabilityZoneId" xml)
               String.parse);
          member_of_service_linked_resource_group =
            (Util.option_bind
               (Xml.member "memberOfServiceLinkedResourceGroup" xml)
               Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((([] @
                           [Util.option_map v.auto_placement
                              (fun f ->
                                 Ezxmlm.make_tag "autoPlacement"
                                   ([], (AutoPlacement.to_xml f)))])
                          @
                          [Util.option_map v.availability_zone
                             (fun f ->
                                Ezxmlm.make_tag "availabilityZone"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.available_capacity
                            (fun f ->
                               Ezxmlm.make_tag "availableCapacity"
                                 ([], (AvailableCapacity.to_xml f)))])
                        @
                        [Util.option_map v.client_token
                           (fun f ->
                              Ezxmlm.make_tag "clientToken"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.host_id
                          (fun f ->
                             Ezxmlm.make_tag "hostId" ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.host_properties
                         (fun f ->
                            Ezxmlm.make_tag "hostProperties"
                              ([], (HostProperties.to_xml f)))])
                     @
                     [Util.option_map v.host_reservation_id
                        (fun f ->
                           Ezxmlm.make_tag "hostReservationId"
                             ([], (String.to_xml f)))])
                    @
                    (List.map
                       (fun x ->
                          Some
                            (Ezxmlm.make_tag "instances"
                               ([], (HostInstanceList.to_xml [x]))))
                       v.instances))
                   @
                   [Util.option_map v.state
                      (fun f ->
                         Ezxmlm.make_tag "state"
                           ([], (AllocationState.to_xml f)))])
                  @
                  [Util.option_map v.allocation_time
                     (fun f ->
                        Ezxmlm.make_tag "allocationTime"
                          ([], (DateTime.to_xml f)))])
                 @
                 [Util.option_map v.release_time
                    (fun f ->
                       Ezxmlm.make_tag "releaseTime"
                         ([], (DateTime.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
                   v.tags))
               @
               [Util.option_map v.host_recovery
                  (fun f ->
                     Ezxmlm.make_tag "hostRecovery"
                       ([], (HostRecovery.to_xml f)))])
              @
              [Util.option_map v.allows_multiple_instance_types
                 (fun f ->
                    Ezxmlm.make_tag "allowsMultipleInstanceTypes"
                      ([], (AllowsMultipleInstanceTypes.to_xml f)))])
             @
             [Util.option_map v.owner_id
                (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.availability_zone_id
               (fun f ->
                  Ezxmlm.make_tag "availabilityZoneId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.member_of_service_linked_resource_group
              (fun f ->
                 Ezxmlm.make_tag "memberOfServiceLinkedResourceGroup"
                   ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the properties of the Dedicated Host.</p>"]
module SubnetAssociationList =
  struct
    type t = SubnetAssociation.t list
    let make elems () = elems
    let to_query v = Query.to_query_list SubnetAssociation.to_query v
    let to_headers v = Headers.to_headers_list SubnetAssociation.to_headers v
    let to_json v = `List (List.map SubnetAssociation.to_json v)
    let parse xml =
      Util.option_all
        (List.map SubnetAssociation.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (SubnetAssociation.to_xml x)))
        v
  end
module LaunchTemplate =
  struct
    type t =
      {
      launch_template_id: String.t option
        [@ocaml.doc "<p>The ID of the launch template.</p>"];
      launch_template_name: String.t option
        [@ocaml.doc "<p>The name of the launch template.</p>"];
      create_time: DateTime.t option
        [@ocaml.doc "<p>The time launch template was created.</p>"];
      created_by: String.t option
        [@ocaml.doc
          "<p>The principal that created the launch template. </p>"];
      default_version_number: Long.t option
        [@ocaml.doc
          "<p>The version number of the default version of the launch template.</p>"];
      latest_version_number: Long.t option
        [@ocaml.doc
          "<p>The version number of the latest version of the launch template.</p>"];
      tags: TagList.t [@ocaml.doc "<p>The tags for the launch template.</p>"]}
    [@@ocaml.doc "<p>Describes a launch template.</p>"]
    let make ?launch_template_id  ?launch_template_name  ?create_time 
      ?created_by  ?default_version_number  ?latest_version_number  ?(tags=
      [])  () =
      {
        launch_template_id;
        launch_template_name;
        create_time;
        created_by;
        default_version_number;
        latest_version_number;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.latest_version_number
             (fun f -> Query.Pair ("LatestVersionNumber", (Long.to_query f)));
           Util.option_map v.default_version_number
             (fun f -> Query.Pair ("DefaultVersionNumber", (Long.to_query f)));
           Util.option_map v.created_by
             (fun f -> Query.Pair ("CreatedBy", (String.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.latest_version_number
             (fun f -> ("latest_version_number", (Long.to_json f)));
           Util.option_map v.default_version_number
             (fun f -> ("default_version_number", (Long.to_json f)));
           Util.option_map v.created_by
             (fun f -> ("created_by", (String.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "launchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "launchTemplateName" xml)
               String.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          created_by =
            (Util.option_bind (Xml.member "createdBy" xml) String.parse);
          default_version_number =
            (Util.option_bind (Xml.member "defaultVersionNumber" xml)
               Long.parse);
          latest_version_number =
            (Util.option_bind (Xml.member "latestVersionNumber" xml)
               Long.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.launch_template_id
                    (fun f ->
                       Ezxmlm.make_tag "launchTemplateId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.launch_template_name
                   (fun f ->
                      Ezxmlm.make_tag "launchTemplateName"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.create_time
                  (fun f ->
                     Ezxmlm.make_tag "createTime" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.created_by
                 (fun f ->
                    Ezxmlm.make_tag "createdBy" ([], (String.to_xml f)))])
             @
             [Util.option_map v.default_version_number
                (fun f ->
                   Ezxmlm.make_tag "defaultVersionNumber"
                     ([], (Long.to_xml f)))])
            @
            [Util.option_map v.latest_version_number
               (fun f ->
                  Ezxmlm.make_tag "latestVersionNumber" ([], (Long.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a launch template.</p>"]
module PrefixList =
  struct
    type t =
      {
      cidrs: ValueStringList.t
        [@ocaml.doc "<p>The IP address range of the AWS service.</p>"];
      prefix_list_id: String.t option
        [@ocaml.doc "<p>The ID of the prefix.</p>"];
      prefix_list_name: String.t option
        [@ocaml.doc "<p>The name of the prefix.</p>"]}[@@ocaml.doc
                                                        "<p>Describes prefixes for AWS services.</p>"]
    let make ?(cidrs= [])  ?prefix_list_id  ?prefix_list_name  () =
      { cidrs; prefix_list_id; prefix_list_name }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.prefix_list_name
              (fun f -> Query.Pair ("PrefixListName", (String.to_query f)));
           Util.option_map v.prefix_list_id
             (fun f -> Query.Pair ("PrefixListId", (String.to_query f)));
           Some (Query.Pair ("CidrSet", (ValueStringList.to_query v.cidrs)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.prefix_list_name
              (fun f -> ("prefix_list_name", (String.to_json f)));
           Util.option_map v.prefix_list_id
             (fun f -> ("prefix_list_id", (String.to_json f)));
           Some ("cidrs", (ValueStringList.to_json v.cidrs))])
    let parse xml =
      Some
        {
          cidrs =
            (Util.of_option []
               (Util.option_bind (Xml.member "cidrSet" xml)
                  ValueStringList.parse));
          prefix_list_id =
            (Util.option_bind (Xml.member "prefixListId" xml) String.parse);
          prefix_list_name =
            (Util.option_bind (Xml.member "prefixListName" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "cidrSet"
                        ([], (ValueStringList.to_xml [x])))) v.cidrs))
            @
            [Util.option_map v.prefix_list_id
               (fun f ->
                  Ezxmlm.make_tag "prefixListId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.prefix_list_name
              (fun f ->
                 Ezxmlm.make_tag "prefixListName" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes prefixes for AWS services.</p>"]
module UnlimitedSupportedInstanceFamily =
  struct
    type t =
      | T2 
      | T3 
      | T3a 
    let str_to_t = [("t3a", T3a); ("t3", T3); ("t2", T2)]
    let t_to_str = [(T3a, "t3a"); (T3, "t3"); (T2, "t2")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ActiveInstance =
  struct
    type t =
      {
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"];
      instance_type: String.t option [@ocaml.doc "<p>The instance type.</p>"];
      spot_instance_request_id: String.t option
        [@ocaml.doc "<p>The ID of the Spot Instance request.</p>"];
      instance_health: InstanceHealthStatus.t option
        [@ocaml.doc
          "<p>The health status of the instance. If the status of either the instance status check or the system status check is <code>impaired</code>, the health status of the instance is <code>unhealthy</code>. Otherwise, the health status is <code>healthy</code>.</p>"]}
    [@@ocaml.doc "<p>Describes a running instance in a Spot Fleet.</p>"]
    let make ?instance_id  ?instance_type  ?spot_instance_request_id 
      ?instance_health  () =
      { instance_id; instance_type; spot_instance_request_id; instance_health
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_health
              (fun f ->
                 Query.Pair
                   ("InstanceHealth", (InstanceHealthStatus.to_query f)));
           Util.option_map v.spot_instance_request_id
             (fun f ->
                Query.Pair ("SpotInstanceRequestId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_health
              (fun f -> ("instance_health", (InstanceHealthStatus.to_json f)));
           Util.option_map v.spot_instance_request_id
             (fun f -> ("spot_instance_request_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          spot_instance_request_id =
            (Util.option_bind (Xml.member "spotInstanceRequestId" xml)
               String.parse);
          instance_health =
            (Util.option_bind (Xml.member "instanceHealth" xml)
               InstanceHealthStatus.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.instance_id
                 (fun f ->
                    Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.instance_type
                (fun f ->
                   Ezxmlm.make_tag "instanceType" ([], (String.to_xml f)))])
            @
            [Util.option_map v.spot_instance_request_id
               (fun f ->
                  Ezxmlm.make_tag "spotInstanceRequestId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.instance_health
              (fun f ->
                 Ezxmlm.make_tag "instanceHealth"
                   ([], (InstanceHealthStatus.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a running instance in a Spot Fleet.</p>"]
module InstanceBlockDeviceMappingSpecification =
  struct
    type t =
      {
      device_name: String.t option
        [@ocaml.doc
          "<p>The device name (for example, <code>/dev/sdh</code> or <code>xvdh</code>).</p>"];
      ebs: EbsInstanceBlockDeviceSpecification.t option
        [@ocaml.doc
          "<p>Parameters used to automatically set up EBS volumes when the instance is launched.</p>"];
      no_device: String.t option
        [@ocaml.doc
          "<p>suppress the specified device included in the block device mapping.</p>"];
      virtual_name: String.t option
        [@ocaml.doc "<p>The virtual device name.</p>"]}[@@ocaml.doc
                                                         "<p>Describes a block device mapping entry.</p>"]
    let make ?device_name  ?ebs  ?no_device  ?virtual_name  () =
      { device_name; ebs; no_device; virtual_name }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.virtual_name
              (fun f -> Query.Pair ("VirtualName", (String.to_query f)));
           Util.option_map v.no_device
             (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.ebs
             (fun f ->
                Query.Pair
                  ("Ebs", (EbsInstanceBlockDeviceSpecification.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.virtual_name
              (fun f -> ("virtual_name", (String.to_json f)));
           Util.option_map v.no_device
             (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.ebs
             (fun f ->
                ("ebs", (EbsInstanceBlockDeviceSpecification.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "ebs" xml)
               EbsInstanceBlockDeviceSpecification.parse);
          no_device =
            (Util.option_bind (Xml.member "noDevice" xml) String.parse);
          virtual_name =
            (Util.option_bind (Xml.member "virtualName" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.device_name
                 (fun f ->
                    Ezxmlm.make_tag "deviceName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.ebs
                (fun f ->
                   Ezxmlm.make_tag "ebs"
                     ([], (EbsInstanceBlockDeviceSpecification.to_xml f)))])
            @
            [Util.option_map v.no_device
               (fun f -> Ezxmlm.make_tag "noDevice" ([], (String.to_xml f)))])
           @
           [Util.option_map v.virtual_name
              (fun f -> Ezxmlm.make_tag "virtualName" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a block device mapping entry.</p>"]
module LoadPermissionList =
  struct
    type t = LoadPermission.t list
    let make elems () = elems
    let to_query v = Query.to_query_list LoadPermission.to_query v
    let to_headers v = Headers.to_headers_list LoadPermission.to_headers v
    let to_json v = `List (List.map LoadPermission.to_json v)
    let parse xml =
      Util.option_all
        (List.map LoadPermission.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (LoadPermission.to_xml x))) v
  end
module TransitGatewayMulticastDomain =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway multicast domain.</p>"];
      transit_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway.</p>"];
      state: TransitGatewayMulticastDomainState.t option
        [@ocaml.doc
          "<p>The state of the transit gateway multicast domain.</p>"];
      creation_time: DateTime.t option
        [@ocaml.doc
          "<p>The time the transit gateway multicast domain was created.</p>"];
      tags: TagList.t
        [@ocaml.doc
          "<p>The tags for the transit gateway multicast domain.</p>"]}
    [@@ocaml.doc "<p>Describes the transit gateway multicast domain.</p>"]
    let make ?transit_gateway_multicast_domain_id  ?transit_gateway_id 
      ?state  ?creation_time  ?(tags= [])  () =
      {
        transit_gateway_multicast_domain_id;
        transit_gateway_id;
        state;
        creation_time;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (TransitGatewayMulticastDomainState.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f ->
                ("state", (TransitGatewayMulticastDomainState.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayMulticastDomainState.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.transit_gateway_multicast_domain_id
                  (fun f ->
                     Ezxmlm.make_tag "transitGatewayMulticastDomainId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.transit_gateway_id
                 (fun f ->
                    Ezxmlm.make_tag "transitGatewayId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.state
                (fun f ->
                   Ezxmlm.make_tag "state"
                     ([], (TransitGatewayMulticastDomainState.to_xml f)))])
            @
            [Util.option_map v.creation_time
               (fun f ->
                  Ezxmlm.make_tag "creationTime" ([], (DateTime.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes the transit gateway multicast domain.</p>"]
module PrincipalIdFormat =
  struct
    type t =
      {
      arn: String.t option
        [@ocaml.doc "<p>PrincipalIdFormatARN description</p>"];
      statuses: IdFormatList.t
        [@ocaml.doc "<p>PrincipalIdFormatStatuses description</p>"]}[@@ocaml.doc
                                                                    "<p>PrincipalIdFormat description</p>"]
    let make ?arn  ?(statuses= [])  () = { arn; statuses }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("StatusSet", (IdFormatList.to_query v.statuses)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("statuses", (IdFormatList.to_json v.statuses));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "arn" xml) String.parse);
          statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "statusSet" xml)
                  IdFormatList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.arn
               (fun f -> Ezxmlm.make_tag "arn" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "statusSet"
                      ([], (IdFormatList.to_xml [x])))) v.statuses))
  end[@@ocaml.doc "<p>PrincipalIdFormat description</p>"]
module AllowedPrincipal =
  struct
    type t =
      {
      principal_type: PrincipalType.t option
        [@ocaml.doc "<p>The type of principal.</p>"];
      principal: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the principal.</p>"]}
    [@@ocaml.doc "<p>Describes a principal.</p>"]
    let make ?principal_type  ?principal  () = { principal_type; principal }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.principal
              (fun f -> Query.Pair ("Principal", (String.to_query f)));
           Util.option_map v.principal_type
             (fun f ->
                Query.Pair ("PrincipalType", (PrincipalType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.principal
              (fun f -> ("principal", (String.to_json f)));
           Util.option_map v.principal_type
             (fun f -> ("principal_type", (PrincipalType.to_json f)))])
    let parse xml =
      Some
        {
          principal_type =
            (Util.option_bind (Xml.member "principalType" xml)
               PrincipalType.parse);
          principal =
            (Util.option_bind (Xml.member "principal" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.principal_type
               (fun f ->
                  Ezxmlm.make_tag "principalType"
                    ([], (PrincipalType.to_xml f)))])
           @
           [Util.option_map v.principal
              (fun f -> Ezxmlm.make_tag "principal" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a principal.</p>"]
module ByoipCidr =
  struct
    type t =
      {
      cidr: String.t option
        [@ocaml.doc
          "<p>The public IPv4 address range, in CIDR notation.</p>"];
      description: String.t option
        [@ocaml.doc "<p>The description of the address range.</p>"];
      status_message: String.t option
        [@ocaml.doc
          "<p>Upon success, contains the ID of the address pool. Otherwise, contains an error message.</p>"];
      state: ByoipCidrState.t option
        [@ocaml.doc "<p>The state of the address pool.</p>"]}[@@ocaml.doc
                                                               "<p>Information about an address range that is provisioned for use with your AWS resources through bring your own IP addresses (BYOIP).</p>"]
    let make ?cidr  ?description  ?status_message  ?state  () =
      { cidr; description; status_message; state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (ByoipCidrState.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.cidr
             (fun f -> Query.Pair ("Cidr", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (ByoipCidrState.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.cidr (fun f -> ("cidr", (String.to_json f)))])
    let parse xml =
      Some
        {
          cidr = (Util.option_bind (Xml.member "cidr" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) ByoipCidrState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.cidr
                 (fun f -> Ezxmlm.make_tag "cidr" ([], (String.to_xml f)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
            @
            [Util.option_map v.status_message
               (fun f ->
                  Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state" ([], (ByoipCidrState.to_xml f)))])
  end[@@ocaml.doc
       "<p>Information about an address range that is provisioned for use with your AWS resources through bring your own IP addresses (BYOIP).</p>"]
module CoipPool =
  struct
    type t =
      {
      pool_id: String.t option
        [@ocaml.doc "<p>The ID of the address pool.</p>"];
      pool_cidrs: ValueStringList.t
        [@ocaml.doc "<p>The address ranges of the address pool.</p>"];
      local_gateway_route_table_id: String.t option
        [@ocaml.doc "<p>The ID of the local gateway route table.</p>"];
      tags: TagList.t [@ocaml.doc "<p>The tags.</p>"]}[@@ocaml.doc
                                                        "<p>Describes a customer-owned address pool.</p>"]
    let make ?pool_id  ?(pool_cidrs= [])  ?local_gateway_route_table_id 
      ?(tags= [])  () =
      { pool_id; pool_cidrs; local_gateway_route_table_id; tags }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.local_gateway_route_table_id
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)));
           Some
             (Query.Pair
                ("PoolCidrSet", (ValueStringList.to_query v.pool_cidrs)));
           Util.option_map v.pool_id
             (fun f -> Query.Pair ("PoolId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.local_gateway_route_table_id
             (fun f -> ("local_gateway_route_table_id", (String.to_json f)));
           Some ("pool_cidrs", (ValueStringList.to_json v.pool_cidrs));
           Util.option_map v.pool_id
             (fun f -> ("pool_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          pool_id = (Util.option_bind (Xml.member "poolId" xml) String.parse);
          pool_cidrs =
            (Util.of_option []
               (Util.option_bind (Xml.member "poolCidrSet" xml)
                  ValueStringList.parse));
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.pool_id
                 (fun f -> Ezxmlm.make_tag "poolId" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "poolCidrSet"
                        ([], (ValueStringList.to_xml [x])))) v.pool_cidrs))
            @
            [Util.option_map v.local_gateway_route_table_id
               (fun f ->
                  Ezxmlm.make_tag "localGatewayRouteTableId"
                    ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a customer-owned address pool.</p>"]
module DatafeedSubscriptionState =
  struct
    type t =
      | Active 
      | Inactive 
    let str_to_t = [("Inactive", Inactive); ("Active", Active)]
    let t_to_str = [(Inactive, "Inactive"); (Active, "Active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module DeleteFleetErrorItem =
  struct
    type t =
      {
      error: DeleteFleetError.t option [@ocaml.doc "<p>The error.</p>"];
      fleet_id: String.t option
        [@ocaml.doc "<p>The ID of the EC2 Fleet.</p>"]}[@@ocaml.doc
                                                         "<p>Describes an EC2 Fleet that was not successfully deleted.</p>"]
    let make ?error  ?fleet_id  () = { error; fleet_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> Query.Pair ("FleetId", (String.to_query f)));
           Util.option_map v.error
             (fun f -> Query.Pair ("Error", (DeleteFleetError.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> ("fleet_id", (String.to_json f)));
           Util.option_map v.error
             (fun f -> ("error", (DeleteFleetError.to_json f)))])
    let parse xml =
      Some
        {
          error =
            (Util.option_bind (Xml.member "error" xml) DeleteFleetError.parse);
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.error
               (fun f ->
                  Ezxmlm.make_tag "error" ([], (DeleteFleetError.to_xml f)))])
           @
           [Util.option_map v.fleet_id
              (fun f -> Ezxmlm.make_tag "fleetId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an EC2 Fleet that was not successfully deleted.</p>"]
module DeleteFleetSuccessItem =
  struct
    type t =
      {
      current_fleet_state: FleetStateCode.t option
        [@ocaml.doc "<p>The current state of the EC2 Fleet.</p>"];
      previous_fleet_state: FleetStateCode.t option
        [@ocaml.doc "<p>The previous state of the EC2 Fleet.</p>"];
      fleet_id: String.t option
        [@ocaml.doc "<p>The ID of the EC2 Fleet.</p>"]}[@@ocaml.doc
                                                         "<p>Describes an EC2 Fleet that was successfully deleted.</p>"]
    let make ?current_fleet_state  ?previous_fleet_state  ?fleet_id  () =
      { current_fleet_state; previous_fleet_state; fleet_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> Query.Pair ("FleetId", (String.to_query f)));
           Util.option_map v.previous_fleet_state
             (fun f ->
                Query.Pair
                  ("PreviousFleetState", (FleetStateCode.to_query f)));
           Util.option_map v.current_fleet_state
             (fun f ->
                Query.Pair ("CurrentFleetState", (FleetStateCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> ("fleet_id", (String.to_json f)));
           Util.option_map v.previous_fleet_state
             (fun f -> ("previous_fleet_state", (FleetStateCode.to_json f)));
           Util.option_map v.current_fleet_state
             (fun f -> ("current_fleet_state", (FleetStateCode.to_json f)))])
    let parse xml =
      Some
        {
          current_fleet_state =
            (Util.option_bind (Xml.member "currentFleetState" xml)
               FleetStateCode.parse);
          previous_fleet_state =
            (Util.option_bind (Xml.member "previousFleetState" xml)
               FleetStateCode.parse);
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.current_fleet_state
                (fun f ->
                   Ezxmlm.make_tag "currentFleetState"
                     ([], (FleetStateCode.to_xml f)))])
            @
            [Util.option_map v.previous_fleet_state
               (fun f ->
                  Ezxmlm.make_tag "previousFleetState"
                    ([], (FleetStateCode.to_xml f)))])
           @
           [Util.option_map v.fleet_id
              (fun f -> Ezxmlm.make_tag "fleetId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an EC2 Fleet that was successfully deleted.</p>"]
module DisableFastSnapshotRestoreErrorItem =
  struct
    type t =
      {
      snapshot_id: String.t option
        [@ocaml.doc "<p>The ID of the snapshot.</p>"];
      fast_snapshot_restore_state_errors:
        DisableFastSnapshotRestoreStateErrorSet.t
        [@ocaml.doc "<p>The errors.</p>"]}[@@ocaml.doc
                                            "<p>Contains information about the errors that occurred when disabling fast snapshot restores.</p>"]
    let make ?snapshot_id  ?(fast_snapshot_restore_state_errors= [])  () =
      { snapshot_id; fast_snapshot_restore_state_errors }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FastSnapshotRestoreStateErrorSet",
                   (DisableFastSnapshotRestoreStateErrorSet.to_query
                      v.fast_snapshot_restore_state_errors)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("fast_snapshot_restore_state_errors",
                (DisableFastSnapshotRestoreStateErrorSet.to_json
                   v.fast_snapshot_restore_state_errors));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          fast_snapshot_restore_state_errors =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "fastSnapshotRestoreStateErrorSet" xml)
                  DisableFastSnapshotRestoreStateErrorSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.snapshot_id
               (fun f -> Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "fastSnapshotRestoreStateErrorSet"
                      ([],
                        (DisableFastSnapshotRestoreStateErrorSet.to_xml [x]))))
              v.fast_snapshot_restore_state_errors))
  end[@@ocaml.doc
       "<p>Contains information about the errors that occurred when disabling fast snapshot restores.</p>"]
module DisableFastSnapshotRestoreSuccessItem =
  struct
    type t =
      {
      snapshot_id: String.t option
        [@ocaml.doc "<p>The ID of the snapshot.</p>"];
      availability_zone: String.t option
        [@ocaml.doc "<p>The Availability Zone.</p>"];
      state: FastSnapshotRestoreStateCode.t option
        [@ocaml.doc
          "<p>The state of fast snapshot restores for the snapshot.</p>"];
      state_transition_reason: String.t option
        [@ocaml.doc
          "<p>The reason for the state transition. The possible values are as follows:</p> <ul> <li> <p> <code>Client.UserInitiated</code> - The state successfully transitioned to <code>enabling</code> or <code>disabling</code>.</p> </li> <li> <p> <code>Client.UserInitiated - Lifecycle state transition</code> - The state successfully transitioned to <code>optimizing</code>, <code>enabled</code>, or <code>disabled</code>.</p> </li> </ul>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account that owns the snapshot.</p>"];
      owner_alias: String.t option
        [@ocaml.doc "<p>The alias of the snapshot owner.</p>"];
      enabling_time: DateTime.t option
        [@ocaml.doc
          "<p>The time at which fast snapshot restores entered the <code>enabling</code> state.</p>"];
      optimizing_time: DateTime.t option
        [@ocaml.doc
          "<p>The time at which fast snapshot restores entered the <code>optimizing</code> state.</p>"];
      enabled_time: DateTime.t option
        [@ocaml.doc
          "<p>The time at which fast snapshot restores entered the <code>enabled</code> state.</p>"];
      disabling_time: DateTime.t option
        [@ocaml.doc
          "<p>The time at which fast snapshot restores entered the <code>disabling</code> state.</p>"];
      disabled_time: DateTime.t option
        [@ocaml.doc
          "<p>The time at which fast snapshot restores entered the <code>disabled</code> state.</p>"]}
    [@@ocaml.doc
      "<p>Describes fast snapshot restores that were successfully disabled.</p>"]
    let make ?snapshot_id  ?availability_zone  ?state 
      ?state_transition_reason  ?owner_id  ?owner_alias  ?enabling_time 
      ?optimizing_time  ?enabled_time  ?disabling_time  ?disabled_time  () =
      {
        snapshot_id;
        availability_zone;
        state;
        state_transition_reason;
        owner_id;
        owner_alias;
        enabling_time;
        optimizing_time;
        enabled_time;
        disabling_time;
        disabled_time
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> Query.Pair ("DisabledTime", (DateTime.to_query f)));
           Util.option_map v.disabling_time
             (fun f -> Query.Pair ("DisablingTime", (DateTime.to_query f)));
           Util.option_map v.enabled_time
             (fun f -> Query.Pair ("EnabledTime", (DateTime.to_query f)));
           Util.option_map v.optimizing_time
             (fun f -> Query.Pair ("OptimizingTime", (DateTime.to_query f)));
           Util.option_map v.enabling_time
             (fun f -> Query.Pair ("EnablingTime", (DateTime.to_query f)));
           Util.option_map v.owner_alias
             (fun f -> Query.Pair ("OwnerAlias", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.state_transition_reason
             (fun f ->
                Query.Pair ("StateTransitionReason", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (FastSnapshotRestoreStateCode.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> ("disabled_time", (DateTime.to_json f)));
           Util.option_map v.disabling_time
             (fun f -> ("disabling_time", (DateTime.to_json f)));
           Util.option_map v.enabled_time
             (fun f -> ("enabled_time", (DateTime.to_json f)));
           Util.option_map v.optimizing_time
             (fun f -> ("optimizing_time", (DateTime.to_json f)));
           Util.option_map v.enabling_time
             (fun f -> ("enabling_time", (DateTime.to_json f)));
           Util.option_map v.owner_alias
             (fun f -> ("owner_alias", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.state_transition_reason
             (fun f -> ("state_transition_reason", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (FastSnapshotRestoreStateCode.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               FastSnapshotRestoreStateCode.parse);
          state_transition_reason =
            (Util.option_bind (Xml.member "stateTransitionReason" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          owner_alias =
            (Util.option_bind (Xml.member "ownerAlias" xml) String.parse);
          enabling_time =
            (Util.option_bind (Xml.member "enablingTime" xml) DateTime.parse);
          optimizing_time =
            (Util.option_bind (Xml.member "optimizingTime" xml)
               DateTime.parse);
          enabled_time =
            (Util.option_bind (Xml.member "enabledTime" xml) DateTime.parse);
          disabling_time =
            (Util.option_bind (Xml.member "disablingTime" xml) DateTime.parse);
          disabled_time =
            (Util.option_bind (Xml.member "disabledTime" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.snapshot_id
                        (fun f ->
                           Ezxmlm.make_tag "snapshotId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.availability_zone
                       (fun f ->
                          Ezxmlm.make_tag "availabilityZone"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.state
                      (fun f ->
                         Ezxmlm.make_tag "state"
                           ([], (FastSnapshotRestoreStateCode.to_xml f)))])
                  @
                  [Util.option_map v.state_transition_reason
                     (fun f ->
                        Ezxmlm.make_tag "stateTransitionReason"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.owner_id
                    (fun f ->
                       Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.owner_alias
                   (fun f ->
                      Ezxmlm.make_tag "ownerAlias" ([], (String.to_xml f)))])
               @
               [Util.option_map v.enabling_time
                  (fun f ->
                     Ezxmlm.make_tag "enablingTime" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.optimizing_time
                 (fun f ->
                    Ezxmlm.make_tag "optimizingTime"
                      ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.enabled_time
                (fun f ->
                   Ezxmlm.make_tag "enabledTime" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.disabling_time
               (fun f ->
                  Ezxmlm.make_tag "disablingTime" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.disabled_time
              (fun f ->
                 Ezxmlm.make_tag "disabledTime" ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes fast snapshot restores that were successfully disabled.</p>"]
module ScheduledInstance =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc "<p>The Availability Zone.</p>"];
      create_date: DateTime.t option
        [@ocaml.doc
          "<p>The date when the Scheduled Instance was purchased.</p>"];
      hourly_price: String.t option
        [@ocaml.doc "<p>The hourly price for a single instance.</p>"];
      instance_count: Integer.t option
        [@ocaml.doc "<p>The number of instances.</p>"];
      instance_type: String.t option [@ocaml.doc "<p>The instance type.</p>"];
      network_platform: String.t option
        [@ocaml.doc
          "<p>The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p>"];
      next_slot_start_time: DateTime.t option
        [@ocaml.doc "<p>The time for the next schedule to start.</p>"];
      platform: String.t option
        [@ocaml.doc
          "<p>The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p>"];
      previous_slot_end_time: DateTime.t option
        [@ocaml.doc
          "<p>The time that the previous schedule ended or will end.</p>"];
      recurrence: ScheduledInstanceRecurrence.t option
        [@ocaml.doc "<p>The schedule recurrence.</p>"];
      scheduled_instance_id: String.t option
        [@ocaml.doc "<p>The Scheduled Instance ID.</p>"];
      slot_duration_in_hours: Integer.t option
        [@ocaml.doc "<p>The number of hours in the schedule.</p>"];
      term_end_date: DateTime.t option
        [@ocaml.doc "<p>The end date for the Scheduled Instance.</p>"];
      term_start_date: DateTime.t option
        [@ocaml.doc "<p>The start date for the Scheduled Instance.</p>"];
      total_scheduled_instance_hours: Integer.t option
        [@ocaml.doc
          "<p>The total number of hours for a single instance for the entire term.</p>"]}
    [@@ocaml.doc "<p>Describes a Scheduled Instance.</p>"]
    let make ?availability_zone  ?create_date  ?hourly_price  ?instance_count
       ?instance_type  ?network_platform  ?next_slot_start_time  ?platform 
      ?previous_slot_end_time  ?recurrence  ?scheduled_instance_id 
      ?slot_duration_in_hours  ?term_end_date  ?term_start_date 
      ?total_scheduled_instance_hours  () =
      {
        availability_zone;
        create_date;
        hourly_price;
        instance_count;
        instance_type;
        network_platform;
        next_slot_start_time;
        platform;
        previous_slot_end_time;
        recurrence;
        scheduled_instance_id;
        slot_duration_in_hours;
        term_end_date;
        term_start_date;
        total_scheduled_instance_hours
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_scheduled_instance_hours
              (fun f ->
                 Query.Pair
                   ("TotalScheduledInstanceHours", (Integer.to_query f)));
           Util.option_map v.term_start_date
             (fun f -> Query.Pair ("TermStartDate", (DateTime.to_query f)));
           Util.option_map v.term_end_date
             (fun f -> Query.Pair ("TermEndDate", (DateTime.to_query f)));
           Util.option_map v.slot_duration_in_hours
             (fun f ->
                Query.Pair ("SlotDurationInHours", (Integer.to_query f)));
           Util.option_map v.scheduled_instance_id
             (fun f ->
                Query.Pair ("ScheduledInstanceId", (String.to_query f)));
           Util.option_map v.recurrence
             (fun f ->
                Query.Pair
                  ("Recurrence", (ScheduledInstanceRecurrence.to_query f)));
           Util.option_map v.previous_slot_end_time
             (fun f ->
                Query.Pair ("PreviousSlotEndTime", (DateTime.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.next_slot_start_time
             (fun f ->
                Query.Pair ("NextSlotStartTime", (DateTime.to_query f)));
           Util.option_map v.network_platform
             (fun f -> Query.Pair ("NetworkPlatform", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)));
           Util.option_map v.create_date
             (fun f -> Query.Pair ("CreateDate", (DateTime.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_scheduled_instance_hours
              (fun f ->
                 ("total_scheduled_instance_hours", (Integer.to_json f)));
           Util.option_map v.term_start_date
             (fun f -> ("term_start_date", (DateTime.to_json f)));
           Util.option_map v.term_end_date
             (fun f -> ("term_end_date", (DateTime.to_json f)));
           Util.option_map v.slot_duration_in_hours
             (fun f -> ("slot_duration_in_hours", (Integer.to_json f)));
           Util.option_map v.scheduled_instance_id
             (fun f -> ("scheduled_instance_id", (String.to_json f)));
           Util.option_map v.recurrence
             (fun f ->
                ("recurrence", (ScheduledInstanceRecurrence.to_json f)));
           Util.option_map v.previous_slot_end_time
             (fun f -> ("previous_slot_end_time", (DateTime.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.next_slot_start_time
             (fun f -> ("next_slot_start_time", (DateTime.to_json f)));
           Util.option_map v.network_platform
             (fun f -> ("network_platform", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)));
           Util.option_map v.create_date
             (fun f -> ("create_date", (DateTime.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          create_date =
            (Util.option_bind (Xml.member "createDate" xml) DateTime.parse);
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          network_platform =
            (Util.option_bind (Xml.member "networkPlatform" xml) String.parse);
          next_slot_start_time =
            (Util.option_bind (Xml.member "nextSlotStartTime" xml)
               DateTime.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          previous_slot_end_time =
            (Util.option_bind (Xml.member "previousSlotEndTime" xml)
               DateTime.parse);
          recurrence =
            (Util.option_bind (Xml.member "recurrence" xml)
               ScheduledInstanceRecurrence.parse);
          scheduled_instance_id =
            (Util.option_bind (Xml.member "scheduledInstanceId" xml)
               String.parse);
          slot_duration_in_hours =
            (Util.option_bind (Xml.member "slotDurationInHours" xml)
               Integer.parse);
          term_end_date =
            (Util.option_bind (Xml.member "termEndDate" xml) DateTime.parse);
          term_start_date =
            (Util.option_bind (Xml.member "termStartDate" xml) DateTime.parse);
          total_scheduled_instance_hours =
            (Util.option_bind (Xml.member "totalScheduledInstanceHours" xml)
               Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Util.option_map v.availability_zone
                            (fun f ->
                               Ezxmlm.make_tag "availabilityZone"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.create_date
                           (fun f ->
                              Ezxmlm.make_tag "createDate"
                                ([], (DateTime.to_xml f)))])
                       @
                       [Util.option_map v.hourly_price
                          (fun f ->
                             Ezxmlm.make_tag "hourlyPrice"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.instance_count
                         (fun f ->
                            Ezxmlm.make_tag "instanceCount"
                              ([], (Integer.to_xml f)))])
                     @
                     [Util.option_map v.instance_type
                        (fun f ->
                           Ezxmlm.make_tag "instanceType"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.network_platform
                       (fun f ->
                          Ezxmlm.make_tag "networkPlatform"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.next_slot_start_time
                      (fun f ->
                         Ezxmlm.make_tag "nextSlotStartTime"
                           ([], (DateTime.to_xml f)))])
                  @
                  [Util.option_map v.platform
                     (fun f ->
                        Ezxmlm.make_tag "platform" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.previous_slot_end_time
                    (fun f ->
                       Ezxmlm.make_tag "previousSlotEndTime"
                         ([], (DateTime.to_xml f)))])
                @
                [Util.option_map v.recurrence
                   (fun f ->
                      Ezxmlm.make_tag "recurrence"
                        ([], (ScheduledInstanceRecurrence.to_xml f)))])
               @
               [Util.option_map v.scheduled_instance_id
                  (fun f ->
                     Ezxmlm.make_tag "scheduledInstanceId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.slot_duration_in_hours
                 (fun f ->
                    Ezxmlm.make_tag "slotDurationInHours"
                      ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.term_end_date
                (fun f ->
                   Ezxmlm.make_tag "termEndDate" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.term_start_date
               (fun f ->
                  Ezxmlm.make_tag "termStartDate" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.total_scheduled_instance_hours
              (fun f ->
                 Ezxmlm.make_tag "totalScheduledInstanceHours"
                   ([], (Integer.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a Scheduled Instance.</p>"]
module FlowLog =
  struct
    type t =
      {
      creation_time: DateTime.t option
        [@ocaml.doc "<p>The date and time the flow log was created.</p>"];
      deliver_logs_error_message: String.t option
        [@ocaml.doc
          "<p>Information about the error that occurred. <code>Rate limited</code> indicates that CloudWatch Logs throttling has been applied for one or more network interfaces, or that you've reached the limit on the number of log groups that you can create. <code>Access error</code> indicates that the IAM role associated with the flow log does not have sufficient permissions to publish to CloudWatch Logs. <code>Unknown error</code> indicates an internal error.</p>"];
      deliver_logs_permission_arn: String.t option
        [@ocaml.doc
          "<p>The ARN of the IAM role that posts logs to CloudWatch Logs.</p>"];
      deliver_logs_status: String.t option
        [@ocaml.doc
          "<p>The status of the logs delivery (<code>SUCCESS</code> | <code>FAILED</code>).</p>"];
      flow_log_id: String.t option [@ocaml.doc "<p>The flow log ID.</p>"];
      flow_log_status: String.t option
        [@ocaml.doc
          "<p>The status of the flow log (<code>ACTIVE</code>).</p>"];
      log_group_name: String.t option
        [@ocaml.doc "<p>The name of the flow log group.</p>"];
      resource_id: String.t option
        [@ocaml.doc
          "<p>The ID of the resource on which the flow log was created.</p>"];
      traffic_type: TrafficType.t option
        [@ocaml.doc "<p>The type of traffic captured for the flow log.</p>"];
      log_destination_type: LogDestinationType.t option
        [@ocaml.doc
          "<p>Specifies the type of destination to which the flow log data is published. Flow log data can be published to CloudWatch Logs or Amazon S3.</p>"];
      log_destination: String.t option
        [@ocaml.doc
          "<p>Specifies the destination to which the flow log data is published. Flow log data can be published to an CloudWatch Logs log group or an Amazon S3 bucket. If the flow log publishes to CloudWatch Logs, this element indicates the Amazon Resource Name (ARN) of the CloudWatch Logs log group to which the data is published. If the flow log publishes to Amazon S3, this element indicates the ARN of the Amazon S3 bucket to which the data is published.</p>"];
      log_format: String.t option
        [@ocaml.doc "<p>The format of the flow log record.</p>"]}[@@ocaml.doc
                                                                   "<p>Describes a flow log.</p>"]
    let make ?creation_time  ?deliver_logs_error_message 
      ?deliver_logs_permission_arn  ?deliver_logs_status  ?flow_log_id 
      ?flow_log_status  ?log_group_name  ?resource_id  ?traffic_type 
      ?log_destination_type  ?log_destination  ?log_format  () =
      {
        creation_time;
        deliver_logs_error_message;
        deliver_logs_permission_arn;
        deliver_logs_status;
        flow_log_id;
        flow_log_status;
        log_group_name;
        resource_id;
        traffic_type;
        log_destination_type;
        log_destination;
        log_format
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.log_format
              (fun f -> Query.Pair ("LogFormat", (String.to_query f)));
           Util.option_map v.log_destination
             (fun f -> Query.Pair ("LogDestination", (String.to_query f)));
           Util.option_map v.log_destination_type
             (fun f ->
                Query.Pair
                  ("LogDestinationType", (LogDestinationType.to_query f)));
           Util.option_map v.traffic_type
             (fun f -> Query.Pair ("TrafficType", (TrafficType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.log_group_name
             (fun f -> Query.Pair ("LogGroupName", (String.to_query f)));
           Util.option_map v.flow_log_status
             (fun f -> Query.Pair ("FlowLogStatus", (String.to_query f)));
           Util.option_map v.flow_log_id
             (fun f -> Query.Pair ("FlowLogId", (String.to_query f)));
           Util.option_map v.deliver_logs_status
             (fun f -> Query.Pair ("DeliverLogsStatus", (String.to_query f)));
           Util.option_map v.deliver_logs_permission_arn
             (fun f ->
                Query.Pair ("DeliverLogsPermissionArn", (String.to_query f)));
           Util.option_map v.deliver_logs_error_message
             (fun f ->
                Query.Pair ("DeliverLogsErrorMessage", (String.to_query f)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.log_format
              (fun f -> ("log_format", (String.to_json f)));
           Util.option_map v.log_destination
             (fun f -> ("log_destination", (String.to_json f)));
           Util.option_map v.log_destination_type
             (fun f ->
                ("log_destination_type", (LogDestinationType.to_json f)));
           Util.option_map v.traffic_type
             (fun f -> ("traffic_type", (TrafficType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.log_group_name
             (fun f -> ("log_group_name", (String.to_json f)));
           Util.option_map v.flow_log_status
             (fun f -> ("flow_log_status", (String.to_json f)));
           Util.option_map v.flow_log_id
             (fun f -> ("flow_log_id", (String.to_json f)));
           Util.option_map v.deliver_logs_status
             (fun f -> ("deliver_logs_status", (String.to_json f)));
           Util.option_map v.deliver_logs_permission_arn
             (fun f -> ("deliver_logs_permission_arn", (String.to_json f)));
           Util.option_map v.deliver_logs_error_message
             (fun f -> ("deliver_logs_error_message", (String.to_json f)));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)))])
    let parse xml =
      Some
        {
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          deliver_logs_error_message =
            (Util.option_bind (Xml.member "deliverLogsErrorMessage" xml)
               String.parse);
          deliver_logs_permission_arn =
            (Util.option_bind (Xml.member "deliverLogsPermissionArn" xml)
               String.parse);
          deliver_logs_status =
            (Util.option_bind (Xml.member "deliverLogsStatus" xml)
               String.parse);
          flow_log_id =
            (Util.option_bind (Xml.member "flowLogId" xml) String.parse);
          flow_log_status =
            (Util.option_bind (Xml.member "flowLogStatus" xml) String.parse);
          log_group_name =
            (Util.option_bind (Xml.member "logGroupName" xml) String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          traffic_type =
            (Util.option_bind (Xml.member "trafficType" xml)
               TrafficType.parse);
          log_destination_type =
            (Util.option_bind (Xml.member "logDestinationType" xml)
               LogDestinationType.parse);
          log_destination =
            (Util.option_bind (Xml.member "logDestination" xml) String.parse);
          log_format =
            (Util.option_bind (Xml.member "logFormat" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Util.option_map v.creation_time
                         (fun f ->
                            Ezxmlm.make_tag "creationTime"
                              ([], (DateTime.to_xml f)))])
                     @
                     [Util.option_map v.deliver_logs_error_message
                        (fun f ->
                           Ezxmlm.make_tag "deliverLogsErrorMessage"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.deliver_logs_permission_arn
                       (fun f ->
                          Ezxmlm.make_tag "deliverLogsPermissionArn"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.deliver_logs_status
                      (fun f ->
                         Ezxmlm.make_tag "deliverLogsStatus"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.flow_log_id
                     (fun f ->
                        Ezxmlm.make_tag "flowLogId" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.flow_log_status
                    (fun f ->
                       Ezxmlm.make_tag "flowLogStatus"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.log_group_name
                   (fun f ->
                      Ezxmlm.make_tag "logGroupName" ([], (String.to_xml f)))])
               @
               [Util.option_map v.resource_id
                  (fun f ->
                     Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.traffic_type
                 (fun f ->
                    Ezxmlm.make_tag "trafficType"
                      ([], (TrafficType.to_xml f)))])
             @
             [Util.option_map v.log_destination_type
                (fun f ->
                   Ezxmlm.make_tag "logDestinationType"
                     ([], (LogDestinationType.to_xml f)))])
            @
            [Util.option_map v.log_destination
               (fun f ->
                  Ezxmlm.make_tag "logDestination" ([], (String.to_xml f)))])
           @
           [Util.option_map v.log_format
              (fun f -> Ezxmlm.make_tag "logFormat" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a flow log.</p>"]
module BundleTask =
  struct
    type t =
      {
      bundle_id: String.t [@ocaml.doc "<p>The ID of the bundle task.</p>"];
      bundle_task_error: BundleTaskError.t option
        [@ocaml.doc "<p>If the task fails, a description of the error.</p>"];
      instance_id: String.t
        [@ocaml.doc
          "<p>The ID of the instance associated with this bundle task.</p>"];
      progress: String.t
        [@ocaml.doc
          "<p>The level of task completion, as a percent (for example, 20%).</p>"];
      start_time: DateTime.t
        [@ocaml.doc "<p>The time this task started.</p>"];
      state: BundleTaskState.t [@ocaml.doc "<p>The state of the task.</p>"];
      storage: Storage.t
        [@ocaml.doc "<p>The Amazon S3 storage locations.</p>"];
      update_time: DateTime.t
        [@ocaml.doc
          "<p>The time of the most recent update for the task.</p>"]}
    [@@ocaml.doc "<p>Describes a bundle task.</p>"]
    let make ~bundle_id  ?bundle_task_error  ~instance_id  ~progress 
      ~start_time  ~state  ~storage  ~update_time  () =
      {
        bundle_id;
        bundle_task_error;
        instance_id;
        progress;
        start_time;
        state;
        storage;
        update_time
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("UpdateTime", (DateTime.to_query v.update_time)));
           Some (Query.Pair ("Storage", (Storage.to_query v.storage)));
           Some (Query.Pair ("State", (BundleTaskState.to_query v.state)));
           Some (Query.Pair ("StartTime", (DateTime.to_query v.start_time)));
           Some (Query.Pair ("Progress", (String.to_query v.progress)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.bundle_task_error
             (fun f -> Query.Pair ("Error", (BundleTaskError.to_query f)));
           Some (Query.Pair ("BundleId", (String.to_query v.bundle_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("update_time", (DateTime.to_json v.update_time));
           Some ("storage", (Storage.to_json v.storage));
           Some ("state", (BundleTaskState.to_json v.state));
           Some ("start_time", (DateTime.to_json v.start_time));
           Some ("progress", (String.to_json v.progress));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.bundle_task_error
             (fun f -> ("bundle_task_error", (BundleTaskError.to_json f)));
           Some ("bundle_id", (String.to_json v.bundle_id))])
    let parse xml =
      Some
        {
          bundle_id =
            (Xml.required "bundleId"
               (Util.option_bind (Xml.member "bundleId" xml) String.parse));
          bundle_task_error =
            (Util.option_bind (Xml.member "error" xml) BundleTaskError.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          progress =
            (Xml.required "progress"
               (Util.option_bind (Xml.member "progress" xml) String.parse));
          start_time =
            (Xml.required "startTime"
               (Util.option_bind (Xml.member "startTime" xml) DateTime.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml)
                  BundleTaskState.parse));
          storage =
            (Xml.required "storage"
               (Util.option_bind (Xml.member "storage" xml) Storage.parse));
          update_time =
            (Xml.required "updateTime"
               (Util.option_bind (Xml.member "updateTime" xml) DateTime.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Some
                     (Ezxmlm.make_tag "bundleId"
                        ([], (String.to_xml v.bundle_id)))])
                 @
                 [Util.option_map v.bundle_task_error
                    (fun f ->
                       Ezxmlm.make_tag "error"
                         ([], (BundleTaskError.to_xml f)))])
                @
                [Some
                   (Ezxmlm.make_tag "instanceId"
                      ([], (String.to_xml v.instance_id)))])
               @
               [Some
                  (Ezxmlm.make_tag "progress"
                     ([], (String.to_xml v.progress)))])
              @
              [Some
                 (Ezxmlm.make_tag "startTime"
                    ([], (DateTime.to_xml v.start_time)))])
             @
             [Some
                (Ezxmlm.make_tag "state"
                   ([], (BundleTaskState.to_xml v.state)))])
            @
            [Some
               (Ezxmlm.make_tag "storage" ([], (Storage.to_xml v.storage)))])
           @
           [Some
              (Ezxmlm.make_tag "updateTime"
                 ([], (DateTime.to_xml v.update_time)))])
  end[@@ocaml.doc "<p>Describes a bundle task.</p>"]
module InstanceCreditSpecification =
  struct
    type t =
      {
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"];
      cpu_credits: String.t option
        [@ocaml.doc
          "<p>The credit option for CPU usage of the instance. Valid values are <code>standard</code> and <code>unlimited</code>.</p>"]}
    [@@ocaml.doc
      "<p>Describes the credit option for CPU usage of a burstable performance instance. </p>"]
    let make ?instance_id  ?cpu_credits  () = { instance_id; cpu_credits }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> Query.Pair ("CpuCredits", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> ("cpu_credits", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          cpu_credits =
            (Util.option_bind (Xml.member "cpuCredits" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.cpu_credits
              (fun f -> Ezxmlm.make_tag "cpuCredits" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the credit option for CPU usage of a burstable performance instance. </p>"]
module CoipAddressUsage =
  struct
    type t =
      {
      allocation_id: String.t option
        [@ocaml.doc "<p>The allocation ID of the address.</p>"];
      aws_account_id: String.t option
        [@ocaml.doc "<p>The AWS account ID.</p>"];
      aws_service: String.t option [@ocaml.doc "<p>The AWS service.</p>"];
      co_ip: String.t option
        [@ocaml.doc "<p>The customer-owned IP address.</p>"]}[@@ocaml.doc
                                                               "<p>Describes address usage for a customer-owned address pool.</p>"]
    let make ?allocation_id  ?aws_account_id  ?aws_service  ?co_ip  () =
      { allocation_id; aws_account_id; aws_service; co_ip }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.co_ip
              (fun f -> Query.Pair ("CoIp", (String.to_query f)));
           Util.option_map v.aws_service
             (fun f -> Query.Pair ("AwsService", (String.to_query f)));
           Util.option_map v.aws_account_id
             (fun f -> Query.Pair ("AwsAccountId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.co_ip (fun f -> ("co_ip", (String.to_json f)));
           Util.option_map v.aws_service
             (fun f -> ("aws_service", (String.to_json f)));
           Util.option_map v.aws_account_id
             (fun f -> ("aws_account_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          aws_account_id =
            (Util.option_bind (Xml.member "awsAccountId" xml) String.parse);
          aws_service =
            (Util.option_bind (Xml.member "awsService" xml) String.parse);
          co_ip = (Util.option_bind (Xml.member "coIp" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.allocation_id
                 (fun f ->
                    Ezxmlm.make_tag "allocationId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.aws_account_id
                (fun f ->
                   Ezxmlm.make_tag "awsAccountId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.aws_service
               (fun f -> Ezxmlm.make_tag "awsService" ([], (String.to_xml f)))])
           @
           [Util.option_map v.co_ip
              (fun f -> Ezxmlm.make_tag "coIp" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes address usage for a customer-owned address pool.</p>"]
module TargetConfigurationRequest =
  struct
    type t =
      {
      instance_count: Integer.t option
        [@ocaml.doc
          "<p>The number of instances the Covertible Reserved Instance offering can be applied to. This parameter is reserved and cannot be specified in a request</p>"];
      offering_id: String.t
        [@ocaml.doc "<p>The Convertible Reserved Instance offering ID.</p>"]}
    [@@ocaml.doc "<p>Details about the target configuration.</p>"]
    let make ?instance_count  ~offering_id  () =
      { instance_count; offering_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("OfferingId", (String.to_query v.offering_id)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("offering_id", (String.to_json v.offering_id));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          instance_count =
            (Util.option_bind (Xml.member "InstanceCount" xml) Integer.parse);
          offering_id =
            (Xml.required "OfferingId"
               (Util.option_bind (Xml.member "OfferingId" xml) String.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_count
               (fun f ->
                  Ezxmlm.make_tag "InstanceCount" ([], (Integer.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "OfferingId"
                 ([], (String.to_xml v.offering_id)))])
  end[@@ocaml.doc "<p>Details about the target configuration.</p>"]
module StaleSecurityGroup =
  struct
    type t =
      {
      description: String.t option
        [@ocaml.doc "<p>The description of the security group.</p>"];
      group_id: String.t option
        [@ocaml.doc "<p>The ID of the security group.</p>"];
      group_name: String.t option
        [@ocaml.doc "<p>The name of the security group.</p>"];
      stale_ip_permissions: StaleIpPermissionSet.t
        [@ocaml.doc
          "<p>Information about the stale inbound rules in the security group.</p>"];
      stale_ip_permissions_egress: StaleIpPermissionSet.t
        [@ocaml.doc
          "<p>Information about the stale outbound rules in the security group.</p>"];
      vpc_id: String.t option
        [@ocaml.doc "<p>The ID of the VPC for the security group.</p>"]}
    [@@ocaml.doc
      "<p>Describes a stale security group (a security group that contains stale rules).</p>"]
    let make ?description  ?group_id  ?group_name  ?(stale_ip_permissions=
      [])  ?(stale_ip_permissions_egress= [])  ?vpc_id  () =
      {
        description;
        group_id;
        group_name;
        stale_ip_permissions;
        stale_ip_permissions_egress;
        vpc_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some
             (Query.Pair
                ("StaleIpPermissionsEgress",
                  (StaleIpPermissionSet.to_query
                     v.stale_ip_permissions_egress)));
           Some
             (Query.Pair
                ("StaleIpPermissions",
                  (StaleIpPermissionSet.to_query v.stale_ip_permissions)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Some
             ("stale_ip_permissions_egress",
               (StaleIpPermissionSet.to_json v.stale_ip_permissions_egress));
           Some
             ("stale_ip_permissions",
               (StaleIpPermissionSet.to_json v.stale_ip_permissions));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          stale_ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "staleIpPermissions" xml)
                  StaleIpPermissionSet.parse));
          stale_ip_permissions_egress =
            (Util.of_option []
               (Util.option_bind (Xml.member "staleIpPermissionsEgress" xml)
                  StaleIpPermissionSet.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.description
                   (fun f ->
                      Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
               @
               [Util.option_map v.group_id
                  (fun f -> Ezxmlm.make_tag "groupId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.group_name
                 (fun f ->
                    Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "staleIpPermissions"
                        ([], (StaleIpPermissionSet.to_xml [x]))))
                v.stale_ip_permissions))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "staleIpPermissionsEgress"
                       ([], (StaleIpPermissionSet.to_xml [x]))))
               v.stale_ip_permissions_egress))
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a stale security group (a security group that contains stale rules).</p>"]
module SecurityGroupReference =
  struct
    type t =
      {
      group_id: String.t option
        [@ocaml.doc "<p>The ID of your security group.</p>"];
      referencing_vpc_id: String.t option
        [@ocaml.doc
          "<p>The ID of the VPC with the referencing security group.</p>"];
      vpc_peering_connection_id: String.t option
        [@ocaml.doc "<p>The ID of the VPC peering connection.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes a VPC with a security group that references your security group.</p>"]
    let make ?group_id  ?referencing_vpc_id  ?vpc_peering_connection_id  () =
      { group_id; referencing_vpc_id; vpc_peering_connection_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Util.option_map v.referencing_vpc_id
             (fun f -> Query.Pair ("ReferencingVpcId", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Util.option_map v.referencing_vpc_id
             (fun f -> ("referencing_vpc_id", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          referencing_vpc_id =
            (Util.option_bind (Xml.member "referencingVpcId" xml)
               String.parse);
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.group_id
                (fun f -> Ezxmlm.make_tag "groupId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.referencing_vpc_id
               (fun f ->
                  Ezxmlm.make_tag "referencingVpcId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Ezxmlm.make_tag "vpcPeeringConnectionId"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a VPC with a security group that references your security group.</p>"]
module AssignedPrivateIpAddress =
  struct
    type t =
      {
      private_ip_address: String.t option
        [@ocaml.doc
          "<p>The private IP address assigned to the network interface.</p>"]}
    [@@ocaml.doc
      "<p>Describes the private IP addresses assigned to a network interface.</p>"]
    let make ?private_ip_address  () = { private_ip_address }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)))])
    let parse xml =
      Some
        {
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.private_ip_address
              (fun f ->
                 Ezxmlm.make_tag "privateIpAddress" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the private IP addresses assigned to a network interface.</p>"]
module LocalGatewayRouteTableVpcAssociation =
  struct
    type t =
      {
      local_gateway_route_table_vpc_association_id: String.t option
        [@ocaml.doc "<p>The ID of the association.</p>"];
      local_gateway_route_table_id: String.t option
        [@ocaml.doc "<p>The ID of the local gateway route table.</p>"];
      local_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the local gateway.</p>"];
      vpc_id: String.t option [@ocaml.doc "<p>The ID of the VPC.</p>"];
      state: String.t option
        [@ocaml.doc "<p>The state of the association.</p>"]}[@@ocaml.doc
                                                              "<p>Describes an association between a local gateway route table and a VPC.</p>"]
    let make ?local_gateway_route_table_vpc_association_id 
      ?local_gateway_route_table_id  ?local_gateway_id  ?vpc_id  ?state  () =
      {
        local_gateway_route_table_vpc_association_id;
        local_gateway_route_table_id;
        local_gateway_id;
        vpc_id;
        state
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_vpc_association_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayRouteTableVpcAssociationId",
                    (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f -> ("local_gateway_route_table_id", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_vpc_association_id
             (fun f ->
                ("local_gateway_route_table_vpc_association_id",
                  (String.to_json f)))])
    let parse xml =
      Some
        {
          local_gateway_route_table_vpc_association_id =
            (Util.option_bind
               (Xml.member "localGatewayRouteTableVpcAssociationId" xml)
               String.parse);
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map
                  v.local_gateway_route_table_vpc_association_id
                  (fun f ->
                     Ezxmlm.make_tag "localGatewayRouteTableVpcAssociationId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.local_gateway_route_table_id
                 (fun f ->
                    Ezxmlm.make_tag "localGatewayRouteTableId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.local_gateway_id
                (fun f ->
                   Ezxmlm.make_tag "localGatewayId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.vpc_id
               (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f -> Ezxmlm.make_tag "state" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an association between a local gateway route table and a VPC.</p>"]
module CreateVolumePermissionList =
  struct
    type t = CreateVolumePermission.t list
    let make elems () = elems
    let to_query v = Query.to_query_list CreateVolumePermission.to_query v
    let to_headers v =
      Headers.to_headers_list CreateVolumePermission.to_headers v
    let to_json v = `List (List.map CreateVolumePermission.to_json v)
    let parse xml =
      Util.option_all
        (List.map CreateVolumePermission.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (CreateVolumePermission.to_xml x)))
        v
  end
module Volume =
  struct
    type t =
      {
      attachments: VolumeAttachmentList.t
        [@ocaml.doc "<p>Information about the volume attachments.</p>"];
      availability_zone: String.t
        [@ocaml.doc "<p>The Availability Zone for the volume.</p>"];
      create_time: DateTime.t
        [@ocaml.doc
          "<p>The time stamp when volume creation was initiated.</p>"];
      encrypted: Boolean.t
        [@ocaml.doc "<p>Indicates whether the volume is encrypted.</p>"];
      kms_key_id: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the volume.</p>"];
      outpost_arn: String.t option
        [@ocaml.doc "<p>The Amazon Resource Name (ARN) of the Outpost.</p>"];
      size: Integer.t [@ocaml.doc "<p>The size of the volume, in GiBs.</p>"];
      snapshot_id: String.t
        [@ocaml.doc
          "<p>The snapshot from which the volume was created, if applicable.</p>"];
      state: VolumeState.t [@ocaml.doc "<p>The volume state.</p>"];
      volume_id: String.t [@ocaml.doc "<p>The ID of the volume.</p>"];
      iops: Integer.t option
        [@ocaml.doc
          "<p>The number of I/O operations per second (IOPS) that the volume supports. For Provisioned IOPS SSD volumes, this represents the number of IOPS that are provisioned for the volume. For General Purpose SSD volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html\">Amazon EBS Volume Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> <p>Constraints: Range is 100-16,000 IOPS for <code>gp2</code> volumes and 100 to 64,000IOPS for <code>io1</code> volumes, in most Regions. The maximum IOPS for <code>io1</code> of 64,000 is guaranteed only on <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances\">Nitro-based instances</a>. Other instance families guarantee performance up to 32,000 IOPS.</p> <p>Condition: This parameter is required for requests to create <code>io1</code> volumes; it is not used in requests to create <code>gp2</code>, <code>st1</code>, <code>sc1</code>, or <code>standard</code> volumes.</p>"];
      tags: TagList.t [@ocaml.doc "<p>Any tags assigned to the volume.</p>"];
      volume_type: VolumeType.t
        [@ocaml.doc
          "<p>The volume type. This can be <code>gp2</code> for General Purpose SSD, <code>io1</code> for Provisioned IOPS SSD, <code>st1</code> for Throughput Optimized HDD, <code>sc1</code> for Cold HDD, or <code>standard</code> for Magnetic volumes.</p>"];
      fast_restored: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the volume was created using fast snapshot restore.</p>"]}
    [@@ocaml.doc "<p>Describes a volume.</p>"]
    let make ?(attachments= [])  ~availability_zone  ~create_time  ~encrypted
       ?kms_key_id  ?outpost_arn  ~size  ~snapshot_id  ~state  ~volume_id 
      ?iops  ?(tags= [])  ~volume_type  ?fast_restored  () =
      {
        attachments;
        availability_zone;
        create_time;
        encrypted;
        kms_key_id;
        outpost_arn;
        size;
        snapshot_id;
        state;
        volume_id;
        iops;
        tags;
        volume_type;
        fast_restored
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fast_restored
              (fun f -> Query.Pair ("FastRestored", (Boolean.to_query f)));
           Some
             (Query.Pair ("VolumeType", (VolumeType.to_query v.volume_type)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Some (Query.Pair ("Status", (VolumeState.to_query v.state)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Some (Query.Pair ("Size", (Integer.to_query v.size)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Some (Query.Pair ("Encrypted", (Boolean.to_query v.encrypted)));
           Some
             (Query.Pair ("CreateTime", (DateTime.to_query v.create_time)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)));
           Some
             (Query.Pair
                ("AttachmentSet",
                  (VolumeAttachmentList.to_query v.attachments)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fast_restored
              (fun f -> ("fast_restored", (Boolean.to_json f)));
           Some ("volume_type", (VolumeType.to_json v.volume_type));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Some ("state", (VolumeState.to_json v.state));
           Some ("snapshot_id", (String.to_json v.snapshot_id));
           Some ("size", (Integer.to_json v.size));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Some ("encrypted", (Boolean.to_json v.encrypted));
           Some ("create_time", (DateTime.to_json v.create_time));
           Some ("availability_zone", (String.to_json v.availability_zone));
           Some ("attachments", (VolumeAttachmentList.to_json v.attachments))])
    let parse xml =
      Some
        {
          attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "attachmentSet" xml)
                  VolumeAttachmentList.parse));
          availability_zone =
            (Xml.required "availabilityZone"
               (Util.option_bind (Xml.member "availabilityZone" xml)
                  String.parse));
          create_time =
            (Xml.required "createTime"
               (Util.option_bind (Xml.member "createTime" xml) DateTime.parse));
          encrypted =
            (Xml.required "encrypted"
               (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse));
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          size =
            (Xml.required "size"
               (Util.option_bind (Xml.member "size" xml) Integer.parse));
          snapshot_id =
            (Xml.required "snapshotId"
               (Util.option_bind (Xml.member "snapshotId" xml) String.parse));
          state =
            (Xml.required "status"
               (Util.option_bind (Xml.member "status" xml) VolumeState.parse));
          volume_id =
            (Xml.required "volumeId"
               (Util.option_bind (Xml.member "volumeId" xml) String.parse));
          iops = (Util.option_bind (Xml.member "iops" xml) Integer.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          volume_type =
            (Xml.required "volumeType"
               (Util.option_bind (Xml.member "volumeType" xml)
                  VolumeType.parse));
          fast_restored =
            (Util.option_bind (Xml.member "fastRestored" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        (List.map
                           (fun x ->
                              Some
                                (Ezxmlm.make_tag "attachmentSet"
                                   ([], (VolumeAttachmentList.to_xml [x]))))
                           v.attachments))
                       @
                       [Some
                          (Ezxmlm.make_tag "availabilityZone"
                             ([], (String.to_xml v.availability_zone)))])
                      @
                      [Some
                         (Ezxmlm.make_tag "createTime"
                            ([], (DateTime.to_xml v.create_time)))])
                     @
                     [Some
                        (Ezxmlm.make_tag "encrypted"
                           ([], (Boolean.to_xml v.encrypted)))])
                    @
                    [Util.option_map v.kms_key_id
                       (fun f ->
                          Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.outpost_arn
                      (fun f ->
                         Ezxmlm.make_tag "outpostArn" ([], (String.to_xml f)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "size" ([], (Integer.to_xml v.size)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "snapshotId"
                       ([], (String.to_xml v.snapshot_id)))])
                @
                [Some
                   (Ezxmlm.make_tag "status"
                      ([], (VolumeState.to_xml v.state)))])
               @
               [Some
                  (Ezxmlm.make_tag "volumeId"
                     ([], (String.to_xml v.volume_id)))])
              @
              [Util.option_map v.iops
                 (fun f -> Ezxmlm.make_tag "iops" ([], (Integer.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
                v.tags))
            @
            [Some
               (Ezxmlm.make_tag "volumeType"
                  ([], (VolumeType.to_xml v.volume_type)))])
           @
           [Util.option_map v.fast_restored
              (fun f ->
                 Ezxmlm.make_tag "fastRestored" ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a volume.</p>"]
module ClientVpnConnection =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option
        [@ocaml.doc
          "<p>The ID of the Client VPN endpoint to which the client is connected.</p>"];
      timestamp: String.t option
        [@ocaml.doc "<p>The current date and time.</p>"];
      connection_id: String.t option
        [@ocaml.doc "<p>The ID of the client connection.</p>"];
      username: String.t option
        [@ocaml.doc
          "<p>The username of the client who established the client connection. This information is only provided if Active Directory client authentication is used.</p>"];
      connection_established_time: String.t option
        [@ocaml.doc
          "<p>The date and time the client connection was established.</p>"];
      ingress_bytes: String.t option
        [@ocaml.doc "<p>The number of bytes sent by the client.</p>"];
      egress_bytes: String.t option
        [@ocaml.doc "<p>The number of bytes received by the client.</p>"];
      ingress_packets: String.t option
        [@ocaml.doc "<p>The number of packets sent by the client.</p>"];
      egress_packets: String.t option
        [@ocaml.doc "<p>The number of packets received by the client.</p>"];
      client_ip: String.t option
        [@ocaml.doc "<p>The IP address of the client.</p>"];
      common_name: String.t option
        [@ocaml.doc
          "<p>The common name associated with the client. This is either the name of the client certificate, or the Active Directory user name.</p>"];
      status: ClientVpnConnectionStatus.t option
        [@ocaml.doc "<p>The current state of the client connection.</p>"];
      connection_end_time: String.t option
        [@ocaml.doc
          "<p>The date and time the client connection was terminated.</p>"]}
    [@@ocaml.doc "<p>Describes a client connection.</p>"]
    let make ?client_vpn_endpoint_id  ?timestamp  ?connection_id  ?username 
      ?connection_established_time  ?ingress_bytes  ?egress_bytes 
      ?ingress_packets  ?egress_packets  ?client_ip  ?common_name  ?status 
      ?connection_end_time  () =
      {
        client_vpn_endpoint_id;
        timestamp;
        connection_id;
        username;
        connection_established_time;
        ingress_bytes;
        egress_bytes;
        ingress_packets;
        egress_packets;
        client_ip;
        common_name;
        status;
        connection_end_time
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.connection_end_time
              (fun f -> Query.Pair ("ConnectionEndTime", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (ClientVpnConnectionStatus.to_query f)));
           Util.option_map v.common_name
             (fun f -> Query.Pair ("CommonName", (String.to_query f)));
           Util.option_map v.client_ip
             (fun f -> Query.Pair ("ClientIp", (String.to_query f)));
           Util.option_map v.egress_packets
             (fun f -> Query.Pair ("EgressPackets", (String.to_query f)));
           Util.option_map v.ingress_packets
             (fun f -> Query.Pair ("IngressPackets", (String.to_query f)));
           Util.option_map v.egress_bytes
             (fun f -> Query.Pair ("EgressBytes", (String.to_query f)));
           Util.option_map v.ingress_bytes
             (fun f -> Query.Pair ("IngressBytes", (String.to_query f)));
           Util.option_map v.connection_established_time
             (fun f ->
                Query.Pair ("ConnectionEstablishedTime", (String.to_query f)));
           Util.option_map v.username
             (fun f -> Query.Pair ("Username", (String.to_query f)));
           Util.option_map v.connection_id
             (fun f -> Query.Pair ("ConnectionId", (String.to_query f)));
           Util.option_map v.timestamp
             (fun f -> Query.Pair ("Timestamp", (String.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.connection_end_time
              (fun f -> ("connection_end_time", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ClientVpnConnectionStatus.to_json f)));
           Util.option_map v.common_name
             (fun f -> ("common_name", (String.to_json f)));
           Util.option_map v.client_ip
             (fun f -> ("client_ip", (String.to_json f)));
           Util.option_map v.egress_packets
             (fun f -> ("egress_packets", (String.to_json f)));
           Util.option_map v.ingress_packets
             (fun f -> ("ingress_packets", (String.to_json f)));
           Util.option_map v.egress_bytes
             (fun f -> ("egress_bytes", (String.to_json f)));
           Util.option_map v.ingress_bytes
             (fun f -> ("ingress_bytes", (String.to_json f)));
           Util.option_map v.connection_established_time
             (fun f -> ("connection_established_time", (String.to_json f)));
           Util.option_map v.username
             (fun f -> ("username", (String.to_json f)));
           Util.option_map v.connection_id
             (fun f -> ("connection_id", (String.to_json f)));
           Util.option_map v.timestamp
             (fun f -> ("timestamp", (String.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) String.parse);
          connection_id =
            (Util.option_bind (Xml.member "connectionId" xml) String.parse);
          username =
            (Util.option_bind (Xml.member "username" xml) String.parse);
          connection_established_time =
            (Util.option_bind (Xml.member "connectionEstablishedTime" xml)
               String.parse);
          ingress_bytes =
            (Util.option_bind (Xml.member "ingressBytes" xml) String.parse);
          egress_bytes =
            (Util.option_bind (Xml.member "egressBytes" xml) String.parse);
          ingress_packets =
            (Util.option_bind (Xml.member "ingressPackets" xml) String.parse);
          egress_packets =
            (Util.option_bind (Xml.member "egressPackets" xml) String.parse);
          client_ip =
            (Util.option_bind (Xml.member "clientIp" xml) String.parse);
          common_name =
            (Util.option_bind (Xml.member "commonName" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnConnectionStatus.parse);
          connection_end_time =
            (Util.option_bind (Xml.member "connectionEndTime" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.client_vpn_endpoint_id
                          (fun f ->
                             Ezxmlm.make_tag "clientVpnEndpointId"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.timestamp
                         (fun f ->
                            Ezxmlm.make_tag "timestamp"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.connection_id
                        (fun f ->
                           Ezxmlm.make_tag "connectionId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.username
                       (fun f ->
                          Ezxmlm.make_tag "username" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.connection_established_time
                      (fun f ->
                         Ezxmlm.make_tag "connectionEstablishedTime"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.ingress_bytes
                     (fun f ->
                        Ezxmlm.make_tag "ingressBytes"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.egress_bytes
                    (fun f ->
                       Ezxmlm.make_tag "egressBytes" ([], (String.to_xml f)))])
                @
                [Util.option_map v.ingress_packets
                   (fun f ->
                      Ezxmlm.make_tag "ingressPackets"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.egress_packets
                  (fun f ->
                     Ezxmlm.make_tag "egressPackets" ([], (String.to_xml f)))])
              @
              [Util.option_map v.client_ip
                 (fun f -> Ezxmlm.make_tag "clientIp" ([], (String.to_xml f)))])
             @
             [Util.option_map v.common_name
                (fun f ->
                   Ezxmlm.make_tag "commonName" ([], (String.to_xml f)))])
            @
            [Util.option_map v.status
               (fun f ->
                  Ezxmlm.make_tag "status"
                    ([], (ClientVpnConnectionStatus.to_xml f)))])
           @
           [Util.option_map v.connection_end_time
              (fun f ->
                 Ezxmlm.make_tag "connectionEndTime" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a client connection.</p>"]
module LocalGatewayRouteTable =
  struct
    type t =
      {
      local_gateway_route_table_id: String.t option
        [@ocaml.doc "<p>The ID of the local gateway route table.</p>"];
      local_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the local gateway.</p>"];
      outpost_arn: String.t option
        [@ocaml.doc "<p>The Amazon Resource Name (ARN) of the Outpost.</p>"];
      state: String.t option
        [@ocaml.doc "<p>The state of the local gateway route table.</p>"]}
    [@@ocaml.doc "<p>Describes a local gateway route table.</p>"]
    let make ?local_gateway_route_table_id  ?local_gateway_id  ?outpost_arn 
      ?state  () =
      { local_gateway_route_table_id; local_gateway_id; outpost_arn; state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (String.to_query f)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f -> ("local_gateway_route_table_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.local_gateway_route_table_id
                 (fun f ->
                    Ezxmlm.make_tag "localGatewayRouteTableId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.local_gateway_id
                (fun f ->
                   Ezxmlm.make_tag "localGatewayId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.outpost_arn
               (fun f -> Ezxmlm.make_tag "outpostArn" ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f -> Ezxmlm.make_tag "state" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a local gateway route table.</p>"]
module Region =
  struct
    type t =
      {
      endpoint: String.t option
        [@ocaml.doc "<p>The Region service endpoint.</p>"];
      region_name: String.t option
        [@ocaml.doc "<p>The name of the Region.</p>"];
      opt_in_status: String.t option
        [@ocaml.doc
          "<p>The Region opt-in status. The possible values are <code>opt-in-not-required</code>, <code>opted-in</code>, and <code>not-opted-in</code>.</p>"]}
    [@@ocaml.doc "<p>Describes a Region.</p>"]
    let make ?endpoint  ?region_name  ?opt_in_status  () =
      { endpoint; region_name; opt_in_status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.opt_in_status
              (fun f -> Query.Pair ("OptInStatus", (String.to_query f)));
           Util.option_map v.region_name
             (fun f -> Query.Pair ("RegionName", (String.to_query f)));
           Util.option_map v.endpoint
             (fun f -> Query.Pair ("RegionEndpoint", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.opt_in_status
              (fun f -> ("opt_in_status", (String.to_json f)));
           Util.option_map v.region_name
             (fun f -> ("region_name", (String.to_json f)));
           Util.option_map v.endpoint
             (fun f -> ("endpoint", (String.to_json f)))])
    let parse xml =
      Some
        {
          endpoint =
            (Util.option_bind (Xml.member "regionEndpoint" xml) String.parse);
          region_name =
            (Util.option_bind (Xml.member "regionName" xml) String.parse);
          opt_in_status =
            (Util.option_bind (Xml.member "optInStatus" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.endpoint
                (fun f ->
                   Ezxmlm.make_tag "regionEndpoint" ([], (String.to_xml f)))])
            @
            [Util.option_map v.region_name
               (fun f -> Ezxmlm.make_tag "regionName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.opt_in_status
              (fun f -> Ezxmlm.make_tag "optInStatus" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a Region.</p>"]
module VpnTunnelOptionsSpecificationsList =
  struct
    type t = VpnTunnelOptionsSpecification.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list VpnTunnelOptionsSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list VpnTunnelOptionsSpecification.to_headers v
    let to_json v = `List (List.map VpnTunnelOptionsSpecification.to_json v)
    let parse xml =
      Util.option_all
        (List.map VpnTunnelOptionsSpecification.parse
           (Xml.members "member" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (VpnTunnelOptionsSpecification.to_xml x))) v
  end
module Address =
  struct
    type t =
      {
      instance_id: String.t option
        [@ocaml.doc
          "<p>The ID of the instance that the address is associated with (if any).</p>"];
      public_ip: String.t option
        [@ocaml.doc "<p>The Elastic IP address.</p>"];
      allocation_id: String.t option
        [@ocaml.doc
          "<p>The ID representing the allocation of the address for use with EC2-VPC.</p>"];
      association_id: String.t option
        [@ocaml.doc
          "<p>The ID representing the association of the address with an instance in a VPC.</p>"];
      domain: DomainType.t option
        [@ocaml.doc
          "<p>Indicates whether this Elastic IP address is for use with instances in EC2-Classic (<code>standard</code>) or instances in a VPC (<code>vpc</code>).</p>"];
      network_interface_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface.</p>"];
      network_interface_owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account that owns the network interface.</p>"];
      private_ip_address: String.t option
        [@ocaml.doc
          "<p>The private IP address associated with the Elastic IP address.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the Elastic IP address.</p>"];
      public_ipv4_pool: String.t option
        [@ocaml.doc "<p>The ID of an address pool.</p>"];
      network_border_group: String.t option
        [@ocaml.doc
          "<p>The name of the location from which the IP address is advertised.</p>"];
      customer_owned_ip: String.t option
        [@ocaml.doc "<p>The customer-owned IP address.</p>"];
      customer_owned_ipv4_pool: String.t option
        [@ocaml.doc "<p>The ID of the customer-owned address pool.</p>"]}
    [@@ocaml.doc "<p>Describes an Elastic IP address.</p>"]
    let make ?instance_id  ?public_ip  ?allocation_id  ?association_id 
      ?domain  ?network_interface_id  ?network_interface_owner_id 
      ?private_ip_address  ?(tags= [])  ?public_ipv4_pool 
      ?network_border_group  ?customer_owned_ip  ?customer_owned_ipv4_pool 
      () =
      {
        instance_id;
        public_ip;
        allocation_id;
        association_id;
        domain;
        network_interface_id;
        network_interface_owner_id;
        private_ip_address;
        tags;
        public_ipv4_pool;
        network_border_group;
        customer_owned_ip;
        customer_owned_ipv4_pool
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.customer_owned_ipv4_pool
              (fun f ->
                 Query.Pair ("CustomerOwnedIpv4Pool", (String.to_query f)));
           Util.option_map v.customer_owned_ip
             (fun f -> Query.Pair ("CustomerOwnedIp", (String.to_query f)));
           Util.option_map v.network_border_group
             (fun f -> Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.public_ipv4_pool
             (fun f -> Query.Pair ("PublicIpv4Pool", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_owner_id
             (fun f ->
                Query.Pair ("NetworkInterfaceOwnerId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.domain
             (fun f -> Query.Pair ("Domain", (DomainType.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.customer_owned_ipv4_pool
              (fun f -> ("customer_owned_ipv4_pool", (String.to_json f)));
           Util.option_map v.customer_owned_ip
             (fun f -> ("customer_owned_ip", (String.to_json f)));
           Util.option_map v.network_border_group
             (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.public_ipv4_pool
             (fun f -> ("public_ipv4_pool", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_owner_id
             (fun f -> ("network_interface_owner_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.domain
             (fun f -> ("domain", (DomainType.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse);
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          domain =
            (Util.option_bind (Xml.member "domain" xml) DomainType.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          network_interface_owner_id =
            (Util.option_bind (Xml.member "networkInterfaceOwnerId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          public_ipv4_pool =
            (Util.option_bind (Xml.member "publicIpv4Pool" xml) String.parse);
          network_border_group =
            (Util.option_bind (Xml.member "networkBorderGroup" xml)
               String.parse);
          customer_owned_ip =
            (Util.option_bind (Xml.member "customerOwnedIp" xml) String.parse);
          customer_owned_ipv4_pool =
            (Util.option_bind (Xml.member "customerOwnedIpv4Pool" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.instance_id
                          (fun f ->
                             Ezxmlm.make_tag "instanceId"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.public_ip
                         (fun f ->
                            Ezxmlm.make_tag "publicIp"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.allocation_id
                        (fun f ->
                           Ezxmlm.make_tag "allocationId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.association_id
                       (fun f ->
                          Ezxmlm.make_tag "associationId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.domain
                      (fun f ->
                         Ezxmlm.make_tag "domain" ([], (DomainType.to_xml f)))])
                  @
                  [Util.option_map v.network_interface_id
                     (fun f ->
                        Ezxmlm.make_tag "networkInterfaceId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.network_interface_owner_id
                    (fun f ->
                       Ezxmlm.make_tag "networkInterfaceOwnerId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.private_ip_address
                   (fun f ->
                      Ezxmlm.make_tag "privateIpAddress"
                        ([], (String.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
                  v.tags))
              @
              [Util.option_map v.public_ipv4_pool
                 (fun f ->
                    Ezxmlm.make_tag "publicIpv4Pool" ([], (String.to_xml f)))])
             @
             [Util.option_map v.network_border_group
                (fun f ->
                   Ezxmlm.make_tag "networkBorderGroup"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.customer_owned_ip
               (fun f ->
                  Ezxmlm.make_tag "customerOwnedIp" ([], (String.to_xml f)))])
           @
           [Util.option_map v.customer_owned_ipv4_pool
              (fun f ->
                 Ezxmlm.make_tag "customerOwnedIpv4Pool"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an Elastic IP address.</p>"]
module InstanceTypeInfo =
  struct
    type t =
      {
      instance_type: InstanceType.t option
        [@ocaml.doc
          "<p>The instance type. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html\">Instance Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"];
      current_generation: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the instance type is a current generation.</p>"];
      free_tier_eligible: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the instance type is eligible for the free tier.</p>"];
      supported_usage_classes: UsageClassTypeList.t
        [@ocaml.doc
          "<p>Indicates whether the instance type is offered for spot or On-Demand.</p>"];
      supported_root_device_types: RootDeviceTypeList.t
        [@ocaml.doc "<p>Indicates the supported root device types.</p>"];
      bare_metal: Boolean.t option
        [@ocaml.doc "<p>Indicates whether the instance is bare metal.</p>"];
      hypervisor: InstanceTypeHypervisor.t option
        [@ocaml.doc
          "<p>Indicates the hypervisor used for the instance type.</p>"];
      processor_info: ProcessorInfo.t option
        [@ocaml.doc "<p>Describes the processor.</p>"];
      v_cpu_info: VCpuInfo.t option
        [@ocaml.doc
          "<p>Describes the vCPU configurations for the instance type.</p>"];
      memory_info: MemoryInfo.t option
        [@ocaml.doc "<p>Describes the memory for the instance type.</p>"];
      instance_storage_supported: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether instance storage is supported.</p>"];
      instance_storage_info: InstanceStorageInfo.t option
        [@ocaml.doc "<p>Describes the disks for the instance type.</p>"];
      ebs_info: EbsInfo.t option
        [@ocaml.doc
          "<p>Describes the Amazon EBS settings for the instance type.</p>"];
      network_info: NetworkInfo.t option
        [@ocaml.doc
          "<p>Describes the network settings for the instance type.</p>"];
      gpu_info: GpuInfo.t option
        [@ocaml.doc
          "<p>Describes the GPU accelerator settings for the instance type.</p>"];
      fpga_info: FpgaInfo.t option
        [@ocaml.doc
          "<p>Describes the FPGA accelerator settings for the instance type.</p>"];
      placement_group_info: PlacementGroupInfo.t option
        [@ocaml.doc
          "<p>Describes the placement group settings for the instance type.</p>"];
      inference_accelerator_info: InferenceAcceleratorInfo.t option
        [@ocaml.doc
          "<p>Describes the Inference accelerator settings for the instance type.</p>"];
      hibernation_supported: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether On-Demand hibernation is supported.</p>"];
      burstable_performance_supported: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the instance type is a burstable performance instance type.</p>"];
      dedicated_hosts_supported: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether Dedicated Hosts are supported on the instance type.</p>"];
      auto_recovery_supported: Boolean.t option
        [@ocaml.doc "<p>Indicates whether auto recovery is supported.</p>"]}
    [@@ocaml.doc "<p>Describes the instance type.</p>"]
    let make ?instance_type  ?current_generation  ?free_tier_eligible 
      ?(supported_usage_classes= [])  ?(supported_root_device_types= []) 
      ?bare_metal  ?hypervisor  ?processor_info  ?v_cpu_info  ?memory_info 
      ?instance_storage_supported  ?instance_storage_info  ?ebs_info 
      ?network_info  ?gpu_info  ?fpga_info  ?placement_group_info 
      ?inference_accelerator_info  ?hibernation_supported 
      ?burstable_performance_supported  ?dedicated_hosts_supported 
      ?auto_recovery_supported  () =
      {
        instance_type;
        current_generation;
        free_tier_eligible;
        supported_usage_classes;
        supported_root_device_types;
        bare_metal;
        hypervisor;
        processor_info;
        v_cpu_info;
        memory_info;
        instance_storage_supported;
        instance_storage_info;
        ebs_info;
        network_info;
        gpu_info;
        fpga_info;
        placement_group_info;
        inference_accelerator_info;
        hibernation_supported;
        burstable_performance_supported;
        dedicated_hosts_supported;
        auto_recovery_supported
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.auto_recovery_supported
              (fun f ->
                 Query.Pair ("AutoRecoverySupported", (Boolean.to_query f)));
           Util.option_map v.dedicated_hosts_supported
             (fun f ->
                Query.Pair ("DedicatedHostsSupported", (Boolean.to_query f)));
           Util.option_map v.burstable_performance_supported
             (fun f ->
                Query.Pair
                  ("BurstablePerformanceSupported", (Boolean.to_query f)));
           Util.option_map v.hibernation_supported
             (fun f ->
                Query.Pair ("HibernationSupported", (Boolean.to_query f)));
           Util.option_map v.inference_accelerator_info
             (fun f ->
                Query.Pair
                  ("InferenceAcceleratorInfo",
                    (InferenceAcceleratorInfo.to_query f)));
           Util.option_map v.placement_group_info
             (fun f ->
                Query.Pair
                  ("PlacementGroupInfo", (PlacementGroupInfo.to_query f)));
           Util.option_map v.fpga_info
             (fun f -> Query.Pair ("FpgaInfo", (FpgaInfo.to_query f)));
           Util.option_map v.gpu_info
             (fun f -> Query.Pair ("GpuInfo", (GpuInfo.to_query f)));
           Util.option_map v.network_info
             (fun f -> Query.Pair ("NetworkInfo", (NetworkInfo.to_query f)));
           Util.option_map v.ebs_info
             (fun f -> Query.Pair ("EbsInfo", (EbsInfo.to_query f)));
           Util.option_map v.instance_storage_info
             (fun f ->
                Query.Pair
                  ("InstanceStorageInfo", (InstanceStorageInfo.to_query f)));
           Util.option_map v.instance_storage_supported
             (fun f ->
                Query.Pair ("InstanceStorageSupported", (Boolean.to_query f)));
           Util.option_map v.memory_info
             (fun f -> Query.Pair ("MemoryInfo", (MemoryInfo.to_query f)));
           Util.option_map v.v_cpu_info
             (fun f -> Query.Pair ("VCpuInfo", (VCpuInfo.to_query f)));
           Util.option_map v.processor_info
             (fun f ->
                Query.Pair ("ProcessorInfo", (ProcessorInfo.to_query f)));
           Util.option_map v.hypervisor
             (fun f ->
                Query.Pair
                  ("Hypervisor", (InstanceTypeHypervisor.to_query f)));
           Util.option_map v.bare_metal
             (fun f -> Query.Pair ("BareMetal", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SupportedRootDeviceTypes",
                  (RootDeviceTypeList.to_query v.supported_root_device_types)));
           Some
             (Query.Pair
                ("SupportedUsageClasses",
                  (UsageClassTypeList.to_query v.supported_usage_classes)));
           Util.option_map v.free_tier_eligible
             (fun f -> Query.Pair ("FreeTierEligible", (Boolean.to_query f)));
           Util.option_map v.current_generation
             (fun f -> Query.Pair ("CurrentGeneration", (Boolean.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.auto_recovery_supported
              (fun f -> ("auto_recovery_supported", (Boolean.to_json f)));
           Util.option_map v.dedicated_hosts_supported
             (fun f -> ("dedicated_hosts_supported", (Boolean.to_json f)));
           Util.option_map v.burstable_performance_supported
             (fun f ->
                ("burstable_performance_supported", (Boolean.to_json f)));
           Util.option_map v.hibernation_supported
             (fun f -> ("hibernation_supported", (Boolean.to_json f)));
           Util.option_map v.inference_accelerator_info
             (fun f ->
                ("inference_accelerator_info",
                  (InferenceAcceleratorInfo.to_json f)));
           Util.option_map v.placement_group_info
             (fun f ->
                ("placement_group_info", (PlacementGroupInfo.to_json f)));
           Util.option_map v.fpga_info
             (fun f -> ("fpga_info", (FpgaInfo.to_json f)));
           Util.option_map v.gpu_info
             (fun f -> ("gpu_info", (GpuInfo.to_json f)));
           Util.option_map v.network_info
             (fun f -> ("network_info", (NetworkInfo.to_json f)));
           Util.option_map v.ebs_info
             (fun f -> ("ebs_info", (EbsInfo.to_json f)));
           Util.option_map v.instance_storage_info
             (fun f ->
                ("instance_storage_info", (InstanceStorageInfo.to_json f)));
           Util.option_map v.instance_storage_supported
             (fun f -> ("instance_storage_supported", (Boolean.to_json f)));
           Util.option_map v.memory_info
             (fun f -> ("memory_info", (MemoryInfo.to_json f)));
           Util.option_map v.v_cpu_info
             (fun f -> ("v_cpu_info", (VCpuInfo.to_json f)));
           Util.option_map v.processor_info
             (fun f -> ("processor_info", (ProcessorInfo.to_json f)));
           Util.option_map v.hypervisor
             (fun f -> ("hypervisor", (InstanceTypeHypervisor.to_json f)));
           Util.option_map v.bare_metal
             (fun f -> ("bare_metal", (Boolean.to_json f)));
           Some
             ("supported_root_device_types",
               (RootDeviceTypeList.to_json v.supported_root_device_types));
           Some
             ("supported_usage_classes",
               (UsageClassTypeList.to_json v.supported_usage_classes));
           Util.option_map v.free_tier_eligible
             (fun f -> ("free_tier_eligible", (Boolean.to_json f)));
           Util.option_map v.current_generation
             (fun f -> ("current_generation", (Boolean.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)))])
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          current_generation =
            (Util.option_bind (Xml.member "currentGeneration" xml)
               Boolean.parse);
          free_tier_eligible =
            (Util.option_bind (Xml.member "freeTierEligible" xml)
               Boolean.parse);
          supported_usage_classes =
            (Util.of_option []
               (Util.option_bind (Xml.member "supportedUsageClasses" xml)
                  UsageClassTypeList.parse));
          supported_root_device_types =
            (Util.of_option []
               (Util.option_bind (Xml.member "supportedRootDeviceTypes" xml)
                  RootDeviceTypeList.parse));
          bare_metal =
            (Util.option_bind (Xml.member "bareMetal" xml) Boolean.parse);
          hypervisor =
            (Util.option_bind (Xml.member "hypervisor" xml)
               InstanceTypeHypervisor.parse);
          processor_info =
            (Util.option_bind (Xml.member "processorInfo" xml)
               ProcessorInfo.parse);
          v_cpu_info =
            (Util.option_bind (Xml.member "vCpuInfo" xml) VCpuInfo.parse);
          memory_info =
            (Util.option_bind (Xml.member "memoryInfo" xml) MemoryInfo.parse);
          instance_storage_supported =
            (Util.option_bind (Xml.member "instanceStorageSupported" xml)
               Boolean.parse);
          instance_storage_info =
            (Util.option_bind (Xml.member "instanceStorageInfo" xml)
               InstanceStorageInfo.parse);
          ebs_info =
            (Util.option_bind (Xml.member "ebsInfo" xml) EbsInfo.parse);
          network_info =
            (Util.option_bind (Xml.member "networkInfo" xml)
               NetworkInfo.parse);
          gpu_info =
            (Util.option_bind (Xml.member "gpuInfo" xml) GpuInfo.parse);
          fpga_info =
            (Util.option_bind (Xml.member "fpgaInfo" xml) FpgaInfo.parse);
          placement_group_info =
            (Util.option_bind (Xml.member "placementGroupInfo" xml)
               PlacementGroupInfo.parse);
          inference_accelerator_info =
            (Util.option_bind (Xml.member "inferenceAcceleratorInfo" xml)
               InferenceAcceleratorInfo.parse);
          hibernation_supported =
            (Util.option_bind (Xml.member "hibernationSupported" xml)
               Boolean.parse);
          burstable_performance_supported =
            (Util.option_bind
               (Xml.member "burstablePerformanceSupported" xml) Boolean.parse);
          dedicated_hosts_supported =
            (Util.option_bind (Xml.member "dedicatedHostsSupported" xml)
               Boolean.parse);
          auto_recovery_supported =
            (Util.option_bind (Xml.member "autoRecoverySupported" xml)
               Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((((((([] @
                                [Util.option_map v.instance_type
                                   (fun f ->
                                      Ezxmlm.make_tag "instanceType"
                                        ([], (InstanceType.to_xml f)))])
                               @
                               [Util.option_map v.current_generation
                                  (fun f ->
                                     Ezxmlm.make_tag "currentGeneration"
                                       ([], (Boolean.to_xml f)))])
                              @
                              [Util.option_map v.free_tier_eligible
                                 (fun f ->
                                    Ezxmlm.make_tag "freeTierEligible"
                                      ([], (Boolean.to_xml f)))])
                             @
                             (List.map
                                (fun x ->
                                   Some
                                     (Ezxmlm.make_tag "supportedUsageClasses"
                                        ([], (UsageClassTypeList.to_xml [x]))))
                                v.supported_usage_classes))
                            @
                            (List.map
                               (fun x ->
                                  Some
                                    (Ezxmlm.make_tag
                                       "supportedRootDeviceTypes"
                                       ([], (RootDeviceTypeList.to_xml [x]))))
                               v.supported_root_device_types))
                           @
                           [Util.option_map v.bare_metal
                              (fun f ->
                                 Ezxmlm.make_tag "bareMetal"
                                   ([], (Boolean.to_xml f)))])
                          @
                          [Util.option_map v.hypervisor
                             (fun f ->
                                Ezxmlm.make_tag "hypervisor"
                                  ([], (InstanceTypeHypervisor.to_xml f)))])
                         @
                         [Util.option_map v.processor_info
                            (fun f ->
                               Ezxmlm.make_tag "processorInfo"
                                 ([], (ProcessorInfo.to_xml f)))])
                        @
                        [Util.option_map v.v_cpu_info
                           (fun f ->
                              Ezxmlm.make_tag "vCpuInfo"
                                ([], (VCpuInfo.to_xml f)))])
                       @
                       [Util.option_map v.memory_info
                          (fun f ->
                             Ezxmlm.make_tag "memoryInfo"
                               ([], (MemoryInfo.to_xml f)))])
                      @
                      [Util.option_map v.instance_storage_supported
                         (fun f ->
                            Ezxmlm.make_tag "instanceStorageSupported"
                              ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.instance_storage_info
                        (fun f ->
                           Ezxmlm.make_tag "instanceStorageInfo"
                             ([], (InstanceStorageInfo.to_xml f)))])
                    @
                    [Util.option_map v.ebs_info
                       (fun f ->
                          Ezxmlm.make_tag "ebsInfo" ([], (EbsInfo.to_xml f)))])
                   @
                   [Util.option_map v.network_info
                      (fun f ->
                         Ezxmlm.make_tag "networkInfo"
                           ([], (NetworkInfo.to_xml f)))])
                  @
                  [Util.option_map v.gpu_info
                     (fun f ->
                        Ezxmlm.make_tag "gpuInfo" ([], (GpuInfo.to_xml f)))])
                 @
                 [Util.option_map v.fpga_info
                    (fun f ->
                       Ezxmlm.make_tag "fpgaInfo" ([], (FpgaInfo.to_xml f)))])
                @
                [Util.option_map v.placement_group_info
                   (fun f ->
                      Ezxmlm.make_tag "placementGroupInfo"
                        ([], (PlacementGroupInfo.to_xml f)))])
               @
               [Util.option_map v.inference_accelerator_info
                  (fun f ->
                     Ezxmlm.make_tag "inferenceAcceleratorInfo"
                       ([], (InferenceAcceleratorInfo.to_xml f)))])
              @
              [Util.option_map v.hibernation_supported
                 (fun f ->
                    Ezxmlm.make_tag "hibernationSupported"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.burstable_performance_supported
                (fun f ->
                   Ezxmlm.make_tag "burstablePerformanceSupported"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.dedicated_hosts_supported
               (fun f ->
                  Ezxmlm.make_tag "dedicatedHostsSupported"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.auto_recovery_supported
              (fun f ->
                 Ezxmlm.make_tag "autoRecoverySupported"
                   ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the instance type.</p>"]
module ClientVpnRoute =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option
        [@ocaml.doc
          "<p>The ID of the Client VPN endpoint with which the route is associated.</p>"];
      destination_cidr: String.t option
        [@ocaml.doc
          "<p>The IPv4 address range, in CIDR notation, of the route destination.</p>"];
      target_subnet: String.t option
        [@ocaml.doc
          "<p>The ID of the subnet through which traffic is routed.</p>"];
      type_: String.t option [@ocaml.doc "<p>The route type.</p>"];
      origin: String.t option
        [@ocaml.doc
          "<p>Indicates how the route was associated with the Client VPN endpoint. <code>associate</code> indicates that the route was automatically added when the target network was associated with the Client VPN endpoint. <code>add-route</code> indicates that the route was manually added using the <b>CreateClientVpnRoute</b> action.</p>"];
      status: ClientVpnRouteStatus.t option
        [@ocaml.doc "<p>The current state of the route.</p>"];
      description: String.t option
        [@ocaml.doc "<p>A brief description of the route.</p>"]}[@@ocaml.doc
                                                                  "<p>Information about a Client VPN endpoint route.</p>"]
    let make ?client_vpn_endpoint_id  ?destination_cidr  ?target_subnet 
      ?type_  ?origin  ?status  ?description  () =
      {
        client_vpn_endpoint_id;
        destination_cidr;
        target_subnet;
        type_;
        origin;
        status;
        description
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (ClientVpnRouteStatus.to_query f)));
           Util.option_map v.origin
             (fun f -> Query.Pair ("Origin", (String.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (String.to_query f)));
           Util.option_map v.target_subnet
             (fun f -> Query.Pair ("TargetSubnet", (String.to_query f)));
           Util.option_map v.destination_cidr
             (fun f -> Query.Pair ("DestinationCidr", (String.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ClientVpnRouteStatus.to_json f)));
           Util.option_map v.origin (fun f -> ("origin", (String.to_json f)));
           Util.option_map v.type_ (fun f -> ("type_", (String.to_json f)));
           Util.option_map v.target_subnet
             (fun f -> ("target_subnet", (String.to_json f)));
           Util.option_map v.destination_cidr
             (fun f -> ("destination_cidr", (String.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          destination_cidr =
            (Util.option_bind (Xml.member "destinationCidr" xml) String.parse);
          target_subnet =
            (Util.option_bind (Xml.member "targetSubnet" xml) String.parse);
          type_ = (Util.option_bind (Xml.member "type" xml) String.parse);
          origin = (Util.option_bind (Xml.member "origin" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnRouteStatus.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.client_vpn_endpoint_id
                    (fun f ->
                       Ezxmlm.make_tag "clientVpnEndpointId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.destination_cidr
                   (fun f ->
                      Ezxmlm.make_tag "destinationCidr"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.target_subnet
                  (fun f ->
                     Ezxmlm.make_tag "targetSubnet" ([], (String.to_xml f)))])
              @
              [Util.option_map v.type_
                 (fun f -> Ezxmlm.make_tag "type" ([], (String.to_xml f)))])
             @
             [Util.option_map v.origin
                (fun f -> Ezxmlm.make_tag "origin" ([], (String.to_xml f)))])
            @
            [Util.option_map v.status
               (fun f ->
                  Ezxmlm.make_tag "status"
                    ([], (ClientVpnRouteStatus.to_xml f)))])
           @
           [Util.option_map v.description
              (fun f -> Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Information about a Client VPN endpoint route.</p>"]
module VpnConnection =
  struct
    type t =
      {
      customer_gateway_configuration: String.t option
        [@ocaml.doc
          "<p>The configuration information for the VPN connection's customer gateway (in the native XML format). This element is always present in the <a>CreateVpnConnection</a> response; however, it's present in the <a>DescribeVpnConnections</a> response only if the VPN connection is in the <code>pending</code> or <code>available</code> state.</p>"];
      customer_gateway_id: String.t
        [@ocaml.doc
          "<p>The ID of the customer gateway at your end of the VPN connection.</p>"];
      category: String.t option
        [@ocaml.doc
          "<p>The category of the VPN connection. A value of <code>VPN</code> indicates an AWS VPN connection. A value of <code>VPN-Classic</code> indicates an AWS Classic VPN connection.</p>"];
      state: VpnState.t
        [@ocaml.doc "<p>The current state of the VPN connection.</p>"];
      type_: GatewayType.t [@ocaml.doc "<p>The type of VPN connection.</p>"];
      vpn_connection_id: String.t
        [@ocaml.doc "<p>The ID of the VPN connection.</p>"];
      vpn_gateway_id: String.t option
        [@ocaml.doc
          "<p>The ID of the virtual private gateway at the AWS side of the VPN connection.</p>"];
      transit_gateway_id: String.t option
        [@ocaml.doc
          "<p>The ID of the transit gateway associated with the VPN connection.</p>"];
      options: VpnConnectionOptions.t option
        [@ocaml.doc "<p>The VPN connection options.</p>"];
      routes: VpnStaticRouteList.t
        [@ocaml.doc
          "<p>The static routes associated with the VPN connection.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the VPN connection.</p>"];
      vgw_telemetry: VgwTelemetryList.t
        [@ocaml.doc "<p>Information about the VPN tunnel.</p>"]}[@@ocaml.doc
                                                                  "<p>Describes a VPN connection.</p>"]
    let make ?customer_gateway_configuration  ~customer_gateway_id  ?category
       ~state  ~type_  ~vpn_connection_id  ?vpn_gateway_id 
      ?transit_gateway_id  ?options  ?(routes= [])  ?(tags= []) 
      ?(vgw_telemetry= [])  () =
      {
        customer_gateway_configuration;
        customer_gateway_id;
        category;
        state;
        type_;
        vpn_connection_id;
        vpn_gateway_id;
        transit_gateway_id;
        options;
        routes;
        tags;
        vgw_telemetry
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VgwTelemetry",
                   (VgwTelemetryList.to_query v.vgw_telemetry)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair ("Routes", (VpnStaticRouteList.to_query v.routes)));
           Util.option_map v.options
             (fun f ->
                Query.Pair ("Options", (VpnConnectionOptions.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> Query.Pair ("VpnGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("VpnConnectionId", (String.to_query v.vpn_connection_id)));
           Some (Query.Pair ("Type", (GatewayType.to_query v.type_)));
           Some (Query.Pair ("State", (VpnState.to_query v.state)));
           Util.option_map v.category
             (fun f -> Query.Pair ("Category", (String.to_query f)));
           Some
             (Query.Pair
                ("CustomerGatewayId",
                  (String.to_query v.customer_gateway_id)));
           Util.option_map v.customer_gateway_configuration
             (fun f ->
                Query.Pair
                  ("CustomerGatewayConfiguration", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vgw_telemetry", (VgwTelemetryList.to_json v.vgw_telemetry));
           Some ("tags", (TagList.to_json v.tags));
           Some ("routes", (VpnStaticRouteList.to_json v.routes));
           Util.option_map v.options
             (fun f -> ("options", (VpnConnectionOptions.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> ("vpn_gateway_id", (String.to_json f)));
           Some ("vpn_connection_id", (String.to_json v.vpn_connection_id));
           Some ("type_", (GatewayType.to_json v.type_));
           Some ("state", (VpnState.to_json v.state));
           Util.option_map v.category
             (fun f -> ("category", (String.to_json f)));
           Some
             ("customer_gateway_id", (String.to_json v.customer_gateway_id));
           Util.option_map v.customer_gateway_configuration
             (fun f -> ("customer_gateway_configuration", (String.to_json f)))])
    let parse xml =
      Some
        {
          customer_gateway_configuration =
            (Util.option_bind (Xml.member "customerGatewayConfiguration" xml)
               String.parse);
          customer_gateway_id =
            (Xml.required "customerGatewayId"
               (Util.option_bind (Xml.member "customerGatewayId" xml)
                  String.parse));
          category =
            (Util.option_bind (Xml.member "category" xml) String.parse);
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml) VpnState.parse));
          type_ =
            (Xml.required "type"
               (Util.option_bind (Xml.member "type" xml) GatewayType.parse));
          vpn_connection_id =
            (Xml.required "vpnConnectionId"
               (Util.option_bind (Xml.member "vpnConnectionId" xml)
                  String.parse));
          vpn_gateway_id =
            (Util.option_bind (Xml.member "vpnGatewayId" xml) String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          options =
            (Util.option_bind (Xml.member "options" xml)
               VpnConnectionOptions.parse);
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routes" xml)
                  VpnStaticRouteList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vgw_telemetry =
            (Util.of_option []
               (Util.option_bind (Xml.member "vgwTelemetry" xml)
                  VgwTelemetryList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Util.option_map v.customer_gateway_configuration
                         (fun f ->
                            Ezxmlm.make_tag "customerGatewayConfiguration"
                              ([], (String.to_xml f)))])
                     @
                     [Some
                        (Ezxmlm.make_tag "customerGatewayId"
                           ([], (String.to_xml v.customer_gateway_id)))])
                    @
                    [Util.option_map v.category
                       (fun f ->
                          Ezxmlm.make_tag "category" ([], (String.to_xml f)))])
                   @
                   [Some
                      (Ezxmlm.make_tag "state"
                         ([], (VpnState.to_xml v.state)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "type"
                        ([], (GatewayType.to_xml v.type_)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "vpnConnectionId"
                       ([], (String.to_xml v.vpn_connection_id)))])
                @
                [Util.option_map v.vpn_gateway_id
                   (fun f ->
                      Ezxmlm.make_tag "vpnGatewayId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.transit_gateway_id
                  (fun f ->
                     Ezxmlm.make_tag "transitGatewayId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.options
                 (fun f ->
                    Ezxmlm.make_tag "options"
                      ([], (VpnConnectionOptions.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "routes"
                        ([], (VpnStaticRouteList.to_xml [x])))) v.routes))
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "vgwTelemetry"
                      ([], (VgwTelemetryList.to_xml [x])))) v.vgw_telemetry))
  end[@@ocaml.doc "<p>Describes a VPN connection.</p>"]
module TargetNetwork =
  struct
    type t =
      {
      association_id: String.t option
        [@ocaml.doc "<p>The ID of the association.</p>"];
      vpc_id: String.t option
        [@ocaml.doc
          "<p>The ID of the VPC in which the target network (subnet) is located.</p>"];
      target_network_id: String.t option
        [@ocaml.doc
          "<p>The ID of the subnet specified as the target network.</p>"];
      client_vpn_endpoint_id: String.t option
        [@ocaml.doc
          "<p>The ID of the Client VPN endpoint with which the target network is associated.</p>"];
      status: AssociationStatus.t option
        [@ocaml.doc
          "<p>The current state of the target network association.</p>"];
      security_groups: ValueStringList.t
        [@ocaml.doc
          "<p>The IDs of the security groups applied to the target network association.</p>"]}
    [@@ocaml.doc
      "<p>Describes a target network associated with a Client VPN endpoint.</p>"]
    let make ?association_id  ?vpc_id  ?target_network_id 
      ?client_vpn_endpoint_id  ?status  ?(security_groups= [])  () =
      {
        association_id;
        vpc_id;
        target_network_id;
        client_vpn_endpoint_id;
        status;
        security_groups
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SecurityGroups",
                   (ValueStringList.to_query v.security_groups)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (AssociationStatus.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)));
           Util.option_map v.target_network_id
             (fun f -> Query.Pair ("TargetNetworkId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("security_groups",
                (ValueStringList.to_json v.security_groups));
           Util.option_map v.status
             (fun f -> ("status", (AssociationStatus.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)));
           Util.option_map v.target_network_id
             (fun f -> ("target_network_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          target_network_id =
            (Util.option_bind (Xml.member "targetNetworkId" xml) String.parse);
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AssociationStatus.parse);
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroups" xml)
                  ValueStringList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.association_id
                   (fun f ->
                      Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.vpc_id
                  (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.target_network_id
                 (fun f ->
                    Ezxmlm.make_tag "targetNetworkId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.client_vpn_endpoint_id
                (fun f ->
                   Ezxmlm.make_tag "clientVpnEndpointId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.status
               (fun f ->
                  Ezxmlm.make_tag "status" ([], (AssociationStatus.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "securityGroups"
                      ([], (ValueStringList.to_xml [x])))) v.security_groups))
  end[@@ocaml.doc
       "<p>Describes a target network associated with a Client VPN endpoint.</p>"]
module VpcPeeringConnection =
  struct
    type t =
      {
      accepter_vpc_info: VpcPeeringConnectionVpcInfo.t option
        [@ocaml.doc
          "<p>Information about the accepter VPC. CIDR block information is only returned when describing an active VPC peering connection.</p>"];
      expiration_time: DateTime.t option
        [@ocaml.doc
          "<p>The time that an unaccepted VPC peering connection will expire.</p>"];
      requester_vpc_info: VpcPeeringConnectionVpcInfo.t option
        [@ocaml.doc
          "<p>Information about the requester VPC. CIDR block information is only returned when describing an active VPC peering connection.</p>"];
      status: VpcPeeringConnectionStateReason.t option
        [@ocaml.doc "<p>The status of the VPC peering connection.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the resource.</p>"];
      vpc_peering_connection_id: String.t option
        [@ocaml.doc "<p>The ID of the VPC peering connection.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes a VPC peering connection.</p>"]
    let make ?accepter_vpc_info  ?expiration_time  ?requester_vpc_info 
      ?status  ?(tags= [])  ?vpc_peering_connection_id  () =
      {
        accepter_vpc_info;
        expiration_time;
        requester_vpc_info;
        status;
        tags;
        vpc_peering_connection_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status
             (fun f ->
                Query.Pair
                  ("Status", (VpcPeeringConnectionStateReason.to_query f)));
           Util.option_map v.requester_vpc_info
             (fun f ->
                Query.Pair
                  ("RequesterVpcInfo",
                    (VpcPeeringConnectionVpcInfo.to_query f)));
           Util.option_map v.expiration_time
             (fun f -> Query.Pair ("ExpirationTime", (DateTime.to_query f)));
           Util.option_map v.accepter_vpc_info
             (fun f ->
                Query.Pair
                  ("AccepterVpcInfo",
                    (VpcPeeringConnectionVpcInfo.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status
             (fun f ->
                ("status", (VpcPeeringConnectionStateReason.to_json f)));
           Util.option_map v.requester_vpc_info
             (fun f ->
                ("requester_vpc_info",
                  (VpcPeeringConnectionVpcInfo.to_json f)));
           Util.option_map v.expiration_time
             (fun f -> ("expiration_time", (DateTime.to_json f)));
           Util.option_map v.accepter_vpc_info
             (fun f ->
                ("accepter_vpc_info",
                  (VpcPeeringConnectionVpcInfo.to_json f)))])
    let parse xml =
      Some
        {
          accepter_vpc_info =
            (Util.option_bind (Xml.member "accepterVpcInfo" xml)
               VpcPeeringConnectionVpcInfo.parse);
          expiration_time =
            (Util.option_bind (Xml.member "expirationTime" xml)
               DateTime.parse);
          requester_vpc_info =
            (Util.option_bind (Xml.member "requesterVpcInfo" xml)
               VpcPeeringConnectionVpcInfo.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               VpcPeeringConnectionStateReason.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.accepter_vpc_info
                   (fun f ->
                      Ezxmlm.make_tag "accepterVpcInfo"
                        ([], (VpcPeeringConnectionVpcInfo.to_xml f)))])
               @
               [Util.option_map v.expiration_time
                  (fun f ->
                     Ezxmlm.make_tag "expirationTime"
                       ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.requester_vpc_info
                 (fun f ->
                    Ezxmlm.make_tag "requesterVpcInfo"
                      ([], (VpcPeeringConnectionVpcInfo.to_xml f)))])
             @
             [Util.option_map v.status
                (fun f ->
                   Ezxmlm.make_tag "status"
                     ([], (VpcPeeringConnectionStateReason.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Ezxmlm.make_tag "vpcPeeringConnectionId"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a VPC peering connection.</p>"]
module NetworkAcl =
  struct
    type t =
      {
      associations: NetworkAclAssociationList.t
        [@ocaml.doc
          "<p>Any associations between the network ACL and one or more subnets</p>"];
      entries: NetworkAclEntryList.t
        [@ocaml.doc "<p>One or more entries (rules) in the network ACL.</p>"];
      is_default: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether this is the default network ACL for the VPC.</p>"];
      network_acl_id: String.t option
        [@ocaml.doc "<p>The ID of the network ACL.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the network ACL.</p>"];
      vpc_id: String.t option
        [@ocaml.doc "<p>The ID of the VPC for the network ACL.</p>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account that owns the network ACL.</p>"]}
    [@@ocaml.doc "<p>Describes a network ACL.</p>"]
    let make ?(associations= [])  ?(entries= [])  ?is_default 
      ?network_acl_id  ?(tags= [])  ?vpc_id  ?owner_id  () =
      {
        associations;
        entries;
        is_default;
        network_acl_id;
        tags;
        vpc_id;
        owner_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.network_acl_id
             (fun f -> Query.Pair ("NetworkAclId", (String.to_query f)));
           Util.option_map v.is_default
             (fun f -> Query.Pair ("Default", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("EntrySet", (NetworkAclEntryList.to_query v.entries)));
           Some
             (Query.Pair
                ("AssociationSet",
                  (NetworkAclAssociationList.to_query v.associations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.network_acl_id
             (fun f -> ("network_acl_id", (String.to_json f)));
           Util.option_map v.is_default
             (fun f -> ("is_default", (Boolean.to_json f)));
           Some ("entries", (NetworkAclEntryList.to_json v.entries));
           Some
             ("associations",
               (NetworkAclAssociationList.to_json v.associations))])
    let parse xml =
      Some
        {
          associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "associationSet" xml)
                  NetworkAclAssociationList.parse));
          entries =
            (Util.of_option []
               (Util.option_bind (Xml.member "entrySet" xml)
                  NetworkAclEntryList.parse));
          is_default =
            (Util.option_bind (Xml.member "default" xml) Boolean.parse);
          network_acl_id =
            (Util.option_bind (Xml.member "networkAclId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "associationSet"
                            ([], (NetworkAclAssociationList.to_xml [x]))))
                    v.associations))
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "entrySet"
                           ([], (NetworkAclEntryList.to_xml [x])))) v.entries))
               @
               [Util.option_map v.is_default
                  (fun f ->
                     Ezxmlm.make_tag "default" ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.network_acl_id
                 (fun f ->
                    Ezxmlm.make_tag "networkAclId" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
                v.tags))
            @
            [Util.option_map v.vpc_id
               (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.owner_id
              (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a network ACL.</p>"]
module LocalGatewayRouteTableVirtualInterfaceGroupAssociation =
  struct
    type t =
      {
      local_gateway_route_table_virtual_interface_group_association_id:
        String.t option [@ocaml.doc "<p>The ID of the association.</p>"];
      local_gateway_virtual_interface_group_id: String.t option
        [@ocaml.doc "<p>The ID of the virtual interface group.</p>"];
      local_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the local gateway.</p>"];
      local_gateway_route_table_id: String.t option
        [@ocaml.doc "<p>The ID of the local gateway route table.</p>"];
      state: String.t option
        [@ocaml.doc "<p>The state of the association.</p>"]}[@@ocaml.doc
                                                              "<p>Describes an association between a local gateway route table and a virtual interface group.</p>"]
    let make
      ?local_gateway_route_table_virtual_interface_group_association_id 
      ?local_gateway_virtual_interface_group_id  ?local_gateway_id 
      ?local_gateway_route_table_id  ?state  () =
      {
        local_gateway_route_table_virtual_interface_group_association_id;
        local_gateway_virtual_interface_group_id;
        local_gateway_id;
        local_gateway_route_table_id;
        state
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayVirtualInterfaceGroupId",
                    (String.to_query f)));
           Util.option_map
             v.local_gateway_route_table_virtual_interface_group_association_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayRouteTableVirtualInterfaceGroupAssociationId",
                    (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f -> ("local_gateway_route_table_id", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                ("local_gateway_virtual_interface_group_id",
                  (String.to_json f)));
           Util.option_map
             v.local_gateway_route_table_virtual_interface_group_association_id
             (fun f ->
                ("local_gateway_route_table_virtual_interface_group_association_id",
                  (String.to_json f)))])
    let parse xml =
      Some
        {
          local_gateway_route_table_virtual_interface_group_association_id =
            (Util.option_bind
               (Xml.member
                  "localGatewayRouteTableVirtualInterfaceGroupAssociationId"
                  xml) String.parse);
          local_gateway_virtual_interface_group_id =
            (Util.option_bind
               (Xml.member "localGatewayVirtualInterfaceGroupId" xml)
               String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse);
          state = (Util.option_bind (Xml.member "state" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map
                  v.local_gateway_route_table_virtual_interface_group_association_id
                  (fun f ->
                     Ezxmlm.make_tag
                       "localGatewayRouteTableVirtualInterfaceGroupAssociationId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.local_gateway_virtual_interface_group_id
                 (fun f ->
                    Ezxmlm.make_tag "localGatewayVirtualInterfaceGroupId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.local_gateway_id
                (fun f ->
                   Ezxmlm.make_tag "localGatewayId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.local_gateway_route_table_id
               (fun f ->
                  Ezxmlm.make_tag "localGatewayRouteTableId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f -> Ezxmlm.make_tag "state" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an association between a local gateway route table and a virtual interface group.</p>"]
module CancelSpotFleetRequestsErrorItem =
  struct
    type t =
      {
      error: CancelSpotFleetRequestsError.t option
        [@ocaml.doc "<p>The error.</p>"];
      spot_fleet_request_id: String.t option
        [@ocaml.doc "<p>The ID of the Spot Fleet request.</p>"]}[@@ocaml.doc
                                                                  "<p>Describes a Spot Fleet request that was not successfully canceled.</p>"]
    let make ?error  ?spot_fleet_request_id  () =
      { error; spot_fleet_request_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Query.Pair ("SpotFleetRequestId", (String.to_query f)));
           Util.option_map v.error
             (fun f ->
                Query.Pair
                  ("Error", (CancelSpotFleetRequestsError.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f -> ("spot_fleet_request_id", (String.to_json f)));
           Util.option_map v.error
             (fun f -> ("error", (CancelSpotFleetRequestsError.to_json f)))])
    let parse xml =
      Some
        {
          error =
            (Util.option_bind (Xml.member "error" xml)
               CancelSpotFleetRequestsError.parse);
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.error
               (fun f ->
                  Ezxmlm.make_tag "error"
                    ([], (CancelSpotFleetRequestsError.to_xml f)))])
           @
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Ezxmlm.make_tag "spotFleetRequestId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a Spot Fleet request that was not successfully canceled.</p>"]
module CancelSpotFleetRequestsSuccessItem =
  struct
    type t =
      {
      current_spot_fleet_request_state: BatchState.t option
        [@ocaml.doc "<p>The current state of the Spot Fleet request.</p>"];
      previous_spot_fleet_request_state: BatchState.t option
        [@ocaml.doc "<p>The previous state of the Spot Fleet request.</p>"];
      spot_fleet_request_id: String.t option
        [@ocaml.doc "<p>The ID of the Spot Fleet request.</p>"]}[@@ocaml.doc
                                                                  "<p>Describes a Spot Fleet request that was successfully canceled.</p>"]
    let make ?current_spot_fleet_request_state 
      ?previous_spot_fleet_request_state  ?spot_fleet_request_id  () =
      {
        current_spot_fleet_request_state;
        previous_spot_fleet_request_state;
        spot_fleet_request_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Query.Pair ("SpotFleetRequestId", (String.to_query f)));
           Util.option_map v.previous_spot_fleet_request_state
             (fun f ->
                Query.Pair
                  ("PreviousSpotFleetRequestState", (BatchState.to_query f)));
           Util.option_map v.current_spot_fleet_request_state
             (fun f ->
                Query.Pair
                  ("CurrentSpotFleetRequestState", (BatchState.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f -> ("spot_fleet_request_id", (String.to_json f)));
           Util.option_map v.previous_spot_fleet_request_state
             (fun f ->
                ("previous_spot_fleet_request_state", (BatchState.to_json f)));
           Util.option_map v.current_spot_fleet_request_state
             (fun f ->
                ("current_spot_fleet_request_state", (BatchState.to_json f)))])
    let parse xml =
      Some
        {
          current_spot_fleet_request_state =
            (Util.option_bind (Xml.member "currentSpotFleetRequestState" xml)
               BatchState.parse);
          previous_spot_fleet_request_state =
            (Util.option_bind
               (Xml.member "previousSpotFleetRequestState" xml)
               BatchState.parse);
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.current_spot_fleet_request_state
                (fun f ->
                   Ezxmlm.make_tag "currentSpotFleetRequestState"
                     ([], (BatchState.to_xml f)))])
            @
            [Util.option_map v.previous_spot_fleet_request_state
               (fun f ->
                  Ezxmlm.make_tag "previousSpotFleetRequestState"
                    ([], (BatchState.to_xml f)))])
           @
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Ezxmlm.make_tag "spotFleetRequestId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a Spot Fleet request that was successfully canceled.</p>"]
module AccountAttribute =
  struct
    type t =
      {
      attribute_name: String.t option
        [@ocaml.doc "<p>The name of the account attribute.</p>"];
      attribute_values: AccountAttributeValueList.t
        [@ocaml.doc "<p>The values for the account attribute.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes an account attribute.</p>"]
    let make ?attribute_name  ?(attribute_values= [])  () =
      { attribute_name; attribute_values }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AttributeValueSet",
                   (AccountAttributeValueList.to_query v.attribute_values)));
           Util.option_map v.attribute_name
             (fun f -> Query.Pair ("AttributeName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("attribute_values",
                (AccountAttributeValueList.to_json v.attribute_values));
           Util.option_map v.attribute_name
             (fun f -> ("attribute_name", (String.to_json f)))])
    let parse xml =
      Some
        {
          attribute_name =
            (Util.option_bind (Xml.member "attributeName" xml) String.parse);
          attribute_values =
            (Util.of_option []
               (Util.option_bind (Xml.member "attributeValueSet" xml)
                  AccountAttributeValueList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.attribute_name
               (fun f ->
                  Ezxmlm.make_tag "attributeName" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "attributeValueSet"
                      ([], (AccountAttributeValueList.to_xml [x]))))
              v.attribute_values))
  end[@@ocaml.doc "<p>Describes an account attribute.</p>"]
module DiskImage =
  struct
    type t =
      {
      description: String.t option
        [@ocaml.doc "<p>A description of the disk image.</p>"];
      image: DiskImageDetail.t option
        [@ocaml.doc "<p>Information about the disk image.</p>"];
      volume: VolumeDetail.t option
        [@ocaml.doc "<p>Information about the volume.</p>"]}[@@ocaml.doc
                                                              "<p>Describes a disk image.</p>"]
    let make ?description  ?image  ?volume  () =
      { description; image; volume }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f -> Query.Pair ("Volume", (VolumeDetail.to_query f)));
           Util.option_map v.image
             (fun f -> Query.Pair ("Image", (DiskImageDetail.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f -> ("volume", (VolumeDetail.to_json f)));
           Util.option_map v.image
             (fun f -> ("image", (DiskImageDetail.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          image =
            (Util.option_bind (Xml.member "Image" xml) DiskImageDetail.parse);
          volume =
            (Util.option_bind (Xml.member "Volume" xml) VolumeDetail.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
            @
            [Util.option_map v.image
               (fun f ->
                  Ezxmlm.make_tag "Image" ([], (DiskImageDetail.to_xml f)))])
           @
           [Util.option_map v.volume
              (fun f ->
                 Ezxmlm.make_tag "Volume" ([], (VolumeDetail.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a disk image.</p>"]
module SecurityGroupStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "SecurityGroup" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module UserData =
  struct
    type t =
      {
      data: String.t option
        [@ocaml.doc
          "<p>The user data. If you are using an AWS SDK or command line tool, Base64-encoding is performed for you, and you can load the text from a file. Otherwise, you must provide Base64-encoded text.</p>"]}
    [@@ocaml.doc "<p>Describes the user data for an instance.</p>"]
    let make ?data  () = { data }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.data
              (fun f -> Query.Pair ("Data", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.data (fun f -> ("data", (String.to_json f)))])
    let parse xml =
      Some { data = (Util.option_bind (Xml.member "data" xml) String.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.data
              (fun f -> Ezxmlm.make_tag "data" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the user data for an instance.</p>"]
module VpcEndpoint =
  struct
    type t =
      {
      vpc_endpoint_id: String.t option
        [@ocaml.doc "<p>The ID of the VPC endpoint.</p>"];
      vpc_endpoint_type: VpcEndpointType.t option
        [@ocaml.doc "<p>The type of endpoint.</p>"];
      vpc_id: String.t option
        [@ocaml.doc
          "<p>The ID of the VPC to which the endpoint is associated.</p>"];
      service_name: String.t option
        [@ocaml.doc
          "<p>The name of the service to which the endpoint is associated.</p>"];
      state: State.t option
        [@ocaml.doc "<p>The state of the VPC endpoint.</p>"];
      policy_document: String.t option
        [@ocaml.doc
          "<p>The policy document associated with the endpoint, if applicable.</p>"];
      route_table_ids: ValueStringList.t
        [@ocaml.doc
          "<p>(Gateway endpoint) One or more route tables associated with the endpoint.</p>"];
      subnet_ids: ValueStringList.t
        [@ocaml.doc
          "<p>(Interface endpoint) One or more subnets in which the endpoint is located.</p>"];
      groups: GroupIdentifierSet.t
        [@ocaml.doc
          "<p>(Interface endpoint) Information about the security groups associated with the network interface.</p>"];
      private_dns_enabled: Boolean.t option
        [@ocaml.doc
          "<p>(Interface endpoint) Indicates whether the VPC is associated with a private hosted zone.</p>"];
      requester_managed: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the VPC endpoint is being managed by its service.</p>"];
      network_interface_ids: ValueStringList.t
        [@ocaml.doc
          "<p>(Interface endpoint) One or more network interfaces for the endpoint.</p>"];
      dns_entries: DnsEntrySet.t
        [@ocaml.doc
          "<p>(Interface endpoint) The DNS entries for the endpoint.</p>"];
      creation_timestamp: DateTime.t option
        [@ocaml.doc "<p>The date and time the VPC endpoint was created.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the VPC endpoint.</p>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account that owns the VPC endpoint.</p>"]}
    [@@ocaml.doc "<p>Describes a VPC endpoint.</p>"]
    let make ?vpc_endpoint_id  ?vpc_endpoint_type  ?vpc_id  ?service_name 
      ?state  ?policy_document  ?(route_table_ids= [])  ?(subnet_ids= []) 
      ?(groups= [])  ?private_dns_enabled  ?requester_managed 
      ?(network_interface_ids= [])  ?(dns_entries= [])  ?creation_timestamp 
      ?(tags= [])  ?owner_id  () =
      {
        vpc_endpoint_id;
        vpc_endpoint_type;
        vpc_id;
        service_name;
        state;
        policy_document;
        route_table_ids;
        subnet_ids;
        groups;
        private_dns_enabled;
        requester_managed;
        network_interface_ids;
        dns_entries;
        creation_timestamp;
        tags;
        owner_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.creation_timestamp
             (fun f ->
                Query.Pair ("CreationTimestamp", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("DnsEntrySet", (DnsEntrySet.to_query v.dns_entries)));
           Some
             (Query.Pair
                ("NetworkInterfaceIdSet",
                  (ValueStringList.to_query v.network_interface_ids)));
           Util.option_map v.requester_managed
             (fun f -> Query.Pair ("RequesterManaged", (Boolean.to_query f)));
           Util.option_map v.private_dns_enabled
             (fun f -> Query.Pair ("PrivateDnsEnabled", (Boolean.to_query f)));
           Some
             (Query.Pair ("GroupSet", (GroupIdentifierSet.to_query v.groups)));
           Some
             (Query.Pair
                ("SubnetIdSet", (ValueStringList.to_query v.subnet_ids)));
           Some
             (Query.Pair
                ("RouteTableIdSet",
                  (ValueStringList.to_query v.route_table_ids)));
           Util.option_map v.policy_document
             (fun f -> Query.Pair ("PolicyDocument", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (State.to_query f)));
           Util.option_map v.service_name
             (fun f -> Query.Pair ("ServiceName", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.vpc_endpoint_type
             (fun f ->
                Query.Pair ("VpcEndpointType", (VpcEndpointType.to_query f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> Query.Pair ("VpcEndpointId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> ("owner_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.creation_timestamp
             (fun f -> ("creation_timestamp", (DateTime.to_json f)));
           Some ("dns_entries", (DnsEntrySet.to_json v.dns_entries));
           Some
             ("network_interface_ids",
               (ValueStringList.to_json v.network_interface_ids));
           Util.option_map v.requester_managed
             (fun f -> ("requester_managed", (Boolean.to_json f)));
           Util.option_map v.private_dns_enabled
             (fun f -> ("private_dns_enabled", (Boolean.to_json f)));
           Some ("groups", (GroupIdentifierSet.to_json v.groups));
           Some ("subnet_ids", (ValueStringList.to_json v.subnet_ids));
           Some
             ("route_table_ids", (ValueStringList.to_json v.route_table_ids));
           Util.option_map v.policy_document
             (fun f -> ("policy_document", (String.to_json f)));
           Util.option_map v.state (fun f -> ("state", (State.to_json f)));
           Util.option_map v.service_name
             (fun f -> ("service_name", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.vpc_endpoint_type
             (fun f -> ("vpc_endpoint_type", (VpcEndpointType.to_json f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> ("vpc_endpoint_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          vpc_endpoint_id =
            (Util.option_bind (Xml.member "vpcEndpointId" xml) String.parse);
          vpc_endpoint_type =
            (Util.option_bind (Xml.member "vpcEndpointType" xml)
               VpcEndpointType.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          service_name =
            (Util.option_bind (Xml.member "serviceName" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) State.parse);
          policy_document =
            (Util.option_bind (Xml.member "policyDocument" xml) String.parse);
          route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeTableIdSet" xml)
                  ValueStringList.parse));
          subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "subnetIdSet" xml)
                  ValueStringList.parse));
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierSet.parse));
          private_dns_enabled =
            (Util.option_bind (Xml.member "privateDnsEnabled" xml)
               Boolean.parse);
          requester_managed =
            (Util.option_bind (Xml.member "requesterManaged" xml)
               Boolean.parse);
          network_interface_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceIdSet" xml)
                  ValueStringList.parse));
          dns_entries =
            (Util.of_option []
               (Util.option_bind (Xml.member "dnsEntrySet" xml)
                  DnsEntrySet.parse));
          creation_timestamp =
            (Util.option_bind (Xml.member "creationTimestamp" xml)
               DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((([] @
                          [Util.option_map v.vpc_endpoint_id
                             (fun f ->
                                Ezxmlm.make_tag "vpcEndpointId"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.vpc_endpoint_type
                            (fun f ->
                               Ezxmlm.make_tag "vpcEndpointType"
                                 ([], (VpcEndpointType.to_xml f)))])
                        @
                        [Util.option_map v.vpc_id
                           (fun f ->
                              Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.service_name
                          (fun f ->
                             Ezxmlm.make_tag "serviceName"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.state
                         (fun f ->
                            Ezxmlm.make_tag "state" ([], (State.to_xml f)))])
                     @
                     [Util.option_map v.policy_document
                        (fun f ->
                           Ezxmlm.make_tag "policyDocument"
                             ([], (String.to_xml f)))])
                    @
                    (List.map
                       (fun x ->
                          Some
                            (Ezxmlm.make_tag "routeTableIdSet"
                               ([], (ValueStringList.to_xml [x]))))
                       v.route_table_ids))
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "subnetIdSet"
                              ([], (ValueStringList.to_xml [x]))))
                      v.subnet_ids))
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "groupSet"
                             ([], (GroupIdentifierSet.to_xml [x])))) v.groups))
                 @
                 [Util.option_map v.private_dns_enabled
                    (fun f ->
                       Ezxmlm.make_tag "privateDnsEnabled"
                         ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.requester_managed
                   (fun f ->
                      Ezxmlm.make_tag "requesterManaged"
                        ([], (Boolean.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "networkInterfaceIdSet"
                          ([], (ValueStringList.to_xml [x]))))
                  v.network_interface_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "dnsEntrySet"
                         ([], (DnsEntrySet.to_xml [x])))) v.dns_entries))
             @
             [Util.option_map v.creation_timestamp
                (fun f ->
                   Ezxmlm.make_tag "creationTimestamp"
                     ([], (DateTime.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           [Util.option_map v.owner_id
              (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a VPC endpoint.</p>"]
module ClassicLinkInstance =
  struct
    type t =
      {
      groups: GroupIdentifierList.t
        [@ocaml.doc "<p>A list of security groups.</p>"];
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the instance.</p>"];
      vpc_id: String.t option [@ocaml.doc "<p>The ID of the VPC.</p>"]}
    [@@ocaml.doc "<p>Describes a linked EC2-Classic instance.</p>"]
    let make ?(groups= [])  ?instance_id  ?(tags= [])  ?vpc_id  () =
      { groups; instance_id; tags; vpc_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Some ("groups", (GroupIdentifierList.to_json v.groups))])
    let parse xml =
      Some
        {
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "groupSet"
                         ([], (GroupIdentifierList.to_xml [x])))) v.groups))
             @
             [Util.option_map v.instance_id
                (fun f ->
                   Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a linked EC2-Classic instance.</p>"]
module Purchase =
  struct
    type t =
      {
      currency_code: CurrencyCodeValues.t option
        [@ocaml.doc
          "<p>The currency in which the <code>UpfrontPrice</code> and <code>HourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>"];
      duration: Integer.t option
        [@ocaml.doc
          "<p>The duration of the reservation's term in seconds.</p>"];
      host_id_set: ResponseHostIdSet.t
        [@ocaml.doc
          "<p>The IDs of the Dedicated Hosts associated with the reservation.</p>"];
      host_reservation_id: String.t option
        [@ocaml.doc "<p>The ID of the reservation.</p>"];
      hourly_price: String.t option
        [@ocaml.doc "<p>The hourly price of the reservation per hour.</p>"];
      instance_family: String.t option
        [@ocaml.doc
          "<p>The instance family on the Dedicated Host that the reservation can be associated with.</p>"];
      payment_option: PaymentOption.t option
        [@ocaml.doc "<p>The payment option for the reservation.</p>"];
      upfront_price: String.t option
        [@ocaml.doc "<p>The upfront price of the reservation.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes the result of the purchase.</p>"]
    let make ?currency_code  ?duration  ?(host_id_set= []) 
      ?host_reservation_id  ?hourly_price  ?instance_family  ?payment_option 
      ?upfront_price  () =
      {
        currency_code;
        duration;
        host_id_set;
        host_reservation_id;
        hourly_price;
        instance_family;
        payment_option;
        upfront_price
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.upfront_price
              (fun f -> Query.Pair ("UpfrontPrice", (String.to_query f)));
           Util.option_map v.payment_option
             (fun f ->
                Query.Pair ("PaymentOption", (PaymentOption.to_query f)));
           Util.option_map v.instance_family
             (fun f -> Query.Pair ("InstanceFamily", (String.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)));
           Util.option_map v.host_reservation_id
             (fun f -> Query.Pair ("HostReservationId", (String.to_query f)));
           Some
             (Query.Pair
                ("HostIdSet", (ResponseHostIdSet.to_query v.host_id_set)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Integer.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.upfront_price
              (fun f -> ("upfront_price", (String.to_json f)));
           Util.option_map v.payment_option
             (fun f -> ("payment_option", (PaymentOption.to_json f)));
           Util.option_map v.instance_family
             (fun f -> ("instance_family", (String.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)));
           Util.option_map v.host_reservation_id
             (fun f -> ("host_reservation_id", (String.to_json f)));
           Some ("host_id_set", (ResponseHostIdSet.to_json v.host_id_set));
           Util.option_map v.duration
             (fun f -> ("duration", (Integer.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)))])
    let parse xml =
      Some
        {
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Integer.parse);
          host_id_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostIdSet" xml)
                  ResponseHostIdSet.parse));
          host_reservation_id =
            (Util.option_bind (Xml.member "hostReservationId" xml)
               String.parse);
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          instance_family =
            (Util.option_bind (Xml.member "instanceFamily" xml) String.parse);
          payment_option =
            (Util.option_bind (Xml.member "paymentOption" xml)
               PaymentOption.parse);
          upfront_price =
            (Util.option_bind (Xml.member "upfrontPrice" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.currency_code
                     (fun f ->
                        Ezxmlm.make_tag "currencyCode"
                          ([], (CurrencyCodeValues.to_xml f)))])
                 @
                 [Util.option_map v.duration
                    (fun f ->
                       Ezxmlm.make_tag "duration" ([], (Integer.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "hostIdSet"
                           ([], (ResponseHostIdSet.to_xml [x]))))
                   v.host_id_set))
               @
               [Util.option_map v.host_reservation_id
                  (fun f ->
                     Ezxmlm.make_tag "hostReservationId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.hourly_price
                 (fun f ->
                    Ezxmlm.make_tag "hourlyPrice" ([], (String.to_xml f)))])
             @
             [Util.option_map v.instance_family
                (fun f ->
                   Ezxmlm.make_tag "instanceFamily" ([], (String.to_xml f)))])
            @
            [Util.option_map v.payment_option
               (fun f ->
                  Ezxmlm.make_tag "paymentOption"
                    ([], (PaymentOption.to_xml f)))])
           @
           [Util.option_map v.upfront_price
              (fun f ->
                 Ezxmlm.make_tag "upfrontPrice" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the result of the purchase.</p>"]
module TransitGatewayAttachment =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option
        [@ocaml.doc "<p>The ID of the attachment.</p>"];
      transit_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway.</p>"];
      transit_gateway_owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account that owns the transit gateway.</p>"];
      resource_owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account that owns the resource.</p>"];
      resource_type: TransitGatewayAttachmentResourceType.t option
        [@ocaml.doc "<p>The resource type.</p>"];
      resource_id: String.t option
        [@ocaml.doc "<p>The ID of the resource.</p>"];
      state: TransitGatewayAttachmentState.t option
        [@ocaml.doc "<p>The attachment state.</p>"];
      association: TransitGatewayAttachmentAssociation.t option
        [@ocaml.doc "<p>The association.</p>"];
      creation_time: DateTime.t option
        [@ocaml.doc "<p>The creation time.</p>"];
      tags: TagList.t [@ocaml.doc "<p>The tags for the attachment.</p>"]}
    [@@ocaml.doc
      "<p>Describes an attachment between a resource and a transit gateway.</p>"]
    let make ?transit_gateway_attachment_id  ?transit_gateway_id 
      ?transit_gateway_owner_id  ?resource_owner_id  ?resource_type 
      ?resource_id  ?state  ?association  ?creation_time  ?(tags= [])  () =
      {
        transit_gateway_attachment_id;
        transit_gateway_id;
        transit_gateway_owner_id;
        resource_owner_id;
        resource_type;
        resource_id;
        state;
        association;
        creation_time;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association",
                    (TransitGatewayAttachmentAssociation.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (TransitGatewayAttachmentState.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_owner_id
             (fun f -> Query.Pair ("ResourceOwnerId", (String.to_query f)));
           Util.option_map v.transit_gateway_owner_id
             (fun f ->
                Query.Pair ("TransitGatewayOwnerId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Util.option_map v.association
             (fun f ->
                ("association",
                  (TransitGatewayAttachmentAssociation.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (TransitGatewayAttachmentState.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_owner_id
             (fun f -> ("resource_owner_id", (String.to_json f)));
           Util.option_map v.transit_gateway_owner_id
             (fun f -> ("transit_gateway_owner_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          transit_gateway_owner_id =
            (Util.option_bind (Xml.member "transitGatewayOwnerId" xml)
               String.parse);
          resource_owner_id =
            (Util.option_bind (Xml.member "resourceOwnerId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAttachmentState.parse);
          association =
            (Util.option_bind (Xml.member "association" xml)
               TransitGatewayAttachmentAssociation.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.transit_gateway_attachment_id
                       (fun f ->
                          Ezxmlm.make_tag "transitGatewayAttachmentId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.transit_gateway_id
                      (fun f ->
                         Ezxmlm.make_tag "transitGatewayId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.transit_gateway_owner_id
                     (fun f ->
                        Ezxmlm.make_tag "transitGatewayOwnerId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.resource_owner_id
                    (fun f ->
                       Ezxmlm.make_tag "resourceOwnerId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.resource_type
                   (fun f ->
                      Ezxmlm.make_tag "resourceType"
                        ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
               @
               [Util.option_map v.resource_id
                  (fun f ->
                     Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.state
                 (fun f ->
                    Ezxmlm.make_tag "state"
                      ([], (TransitGatewayAttachmentState.to_xml f)))])
             @
             [Util.option_map v.association
                (fun f ->
                   Ezxmlm.make_tag "association"
                     ([], (TransitGatewayAttachmentAssociation.to_xml f)))])
            @
            [Util.option_map v.creation_time
               (fun f ->
                  Ezxmlm.make_tag "creationTime" ([], (DateTime.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc
       "<p>Describes an attachment between a resource and a transit gateway.</p>"]
module Snapshot =
  struct
    type t =
      {
      data_encryption_key_id: String.t option
        [@ocaml.doc
          "<p>The data encryption key identifier for the snapshot. This value is a unique identifier that corresponds to the data encryption key that was used to encrypt the original volume or snapshot copy. Because data encryption keys are inherited by volumes created from snapshots, and vice versa, if snapshots share the same data encryption key identifier, then they belong to the same volume/snapshot lineage. This parameter is only returned by <a>DescribeSnapshots</a>.</p>"];
      description: String.t
        [@ocaml.doc "<p>The description for the snapshot.</p>"];
      encrypted: Boolean.t
        [@ocaml.doc "<p>Indicates whether the snapshot is encrypted.</p>"];
      kms_key_id: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to protect the volume encryption key for the parent volume.</p>"];
      owner_id: String.t
        [@ocaml.doc "<p>The AWS account ID of the EBS snapshot owner.</p>"];
      progress: String.t
        [@ocaml.doc "<p>The progress of the snapshot, as a percentage.</p>"];
      snapshot_id: String.t
        [@ocaml.doc
          "<p>The ID of the snapshot. Each snapshot receives a unique identifier when it is created.</p>"];
      start_time: DateTime.t
        [@ocaml.doc "<p>The time stamp when the snapshot was initiated.</p>"];
      state: SnapshotState.t [@ocaml.doc "<p>The snapshot state.</p>"];
      state_message: String.t option
        [@ocaml.doc
          "<p>Encrypted Amazon EBS snapshots are copied asynchronously. If a snapshot copy operation fails (for example, if the proper AWS Key Management Service (AWS KMS) permissions are not obtained) this field displays error state details to help you diagnose why the error occurred. This parameter is only returned by <a>DescribeSnapshots</a>.</p>"];
      volume_id: String.t
        [@ocaml.doc
          "<p>The ID of the volume that was used to create the snapshot. Snapshots created by the <a>CopySnapshot</a> action have an arbitrary volume ID that should not be used for any purpose.</p>"];
      volume_size: Integer.t
        [@ocaml.doc "<p>The size of the volume, in GiB.</p>"];
      owner_alias: String.t option
        [@ocaml.doc
          "<p> Value from an Amazon-maintained list (<code>amazon</code> | <code>self</code> | <code>all</code> | <code>aws-marketplace</code> | <code>microsoft</code>) of snapshot owners. Not to be confused with the user-configured AWS account alias, which is set from the IAM console. </p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the snapshot.</p>"]}[@@ocaml.doc
                                                                   "<p>Describes a snapshot.</p>"]
    let make ?data_encryption_key_id  ~description  ~encrypted  ?kms_key_id 
      ~owner_id  ~progress  ~snapshot_id  ~start_time  ~state  ?state_message
       ~volume_id  ~volume_size  ?owner_alias  ?(tags= [])  () =
      {
        data_encryption_key_id;
        description;
        encrypted;
        kms_key_id;
        owner_id;
        progress;
        snapshot_id;
        start_time;
        state;
        state_message;
        volume_id;
        volume_size;
        owner_alias;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.owner_alias
             (fun f -> Query.Pair ("OwnerAlias", (String.to_query f)));
           Some (Query.Pair ("VolumeSize", (Integer.to_query v.volume_size)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.state_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Some (Query.Pair ("Status", (SnapshotState.to_query v.state)));
           Some (Query.Pair ("StartTime", (DateTime.to_query v.start_time)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Some (Query.Pair ("Progress", (String.to_query v.progress)));
           Some (Query.Pair ("OwnerId", (String.to_query v.owner_id)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Some (Query.Pair ("Encrypted", (Boolean.to_query v.encrypted)));
           Some (Query.Pair ("Description", (String.to_query v.description)));
           Util.option_map v.data_encryption_key_id
             (fun f ->
                Query.Pair ("DataEncryptionKeyId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.owner_alias
             (fun f -> ("owner_alias", (String.to_json f)));
           Some ("volume_size", (Integer.to_json v.volume_size));
           Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.state_message
             (fun f -> ("state_message", (String.to_json f)));
           Some ("state", (SnapshotState.to_json v.state));
           Some ("start_time", (DateTime.to_json v.start_time));
           Some ("snapshot_id", (String.to_json v.snapshot_id));
           Some ("progress", (String.to_json v.progress));
           Some ("owner_id", (String.to_json v.owner_id));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Some ("encrypted", (Boolean.to_json v.encrypted));
           Some ("description", (String.to_json v.description));
           Util.option_map v.data_encryption_key_id
             (fun f -> ("data_encryption_key_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          data_encryption_key_id =
            (Util.option_bind (Xml.member "dataEncryptionKeyId" xml)
               String.parse);
          description =
            (Xml.required "description"
               (Util.option_bind (Xml.member "description" xml) String.parse));
          encrypted =
            (Xml.required "encrypted"
               (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse));
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          owner_id =
            (Xml.required "ownerId"
               (Util.option_bind (Xml.member "ownerId" xml) String.parse));
          progress =
            (Xml.required "progress"
               (Util.option_bind (Xml.member "progress" xml) String.parse));
          snapshot_id =
            (Xml.required "snapshotId"
               (Util.option_bind (Xml.member "snapshotId" xml) String.parse));
          start_time =
            (Xml.required "startTime"
               (Util.option_bind (Xml.member "startTime" xml) DateTime.parse));
          state =
            (Xml.required "status"
               (Util.option_bind (Xml.member "status" xml)
                  SnapshotState.parse));
          state_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          volume_id =
            (Xml.required "volumeId"
               (Util.option_bind (Xml.member "volumeId" xml) String.parse));
          volume_size =
            (Xml.required "volumeSize"
               (Util.option_bind (Xml.member "volumeSize" xml) Integer.parse));
          owner_alias =
            (Util.option_bind (Xml.member "ownerAlias" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        [Util.option_map v.data_encryption_key_id
                           (fun f ->
                              Ezxmlm.make_tag "dataEncryptionKeyId"
                                ([], (String.to_xml f)))])
                       @
                       [Some
                          (Ezxmlm.make_tag "description"
                             ([], (String.to_xml v.description)))])
                      @
                      [Some
                         (Ezxmlm.make_tag "encrypted"
                            ([], (Boolean.to_xml v.encrypted)))])
                     @
                     [Util.option_map v.kms_key_id
                        (fun f ->
                           Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
                    @
                    [Some
                       (Ezxmlm.make_tag "ownerId"
                          ([], (String.to_xml v.owner_id)))])
                   @
                   [Some
                      (Ezxmlm.make_tag "progress"
                         ([], (String.to_xml v.progress)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "snapshotId"
                        ([], (String.to_xml v.snapshot_id)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "startTime"
                       ([], (DateTime.to_xml v.start_time)))])
                @
                [Some
                   (Ezxmlm.make_tag "status"
                      ([], (SnapshotState.to_xml v.state)))])
               @
               [Util.option_map v.state_message
                  (fun f ->
                     Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
              @
              [Some
                 (Ezxmlm.make_tag "volumeId"
                    ([], (String.to_xml v.volume_id)))])
             @
             [Some
                (Ezxmlm.make_tag "volumeSize"
                   ([], (Integer.to_xml v.volume_size)))])
            @
            [Util.option_map v.owner_alias
               (fun f -> Ezxmlm.make_tag "ownerAlias" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a snapshot.</p>"]
module CreateFleetError =
  struct
    type t =
      {
      launch_template_and_overrides:
        LaunchTemplateAndOverridesResponse.t option
        [@ocaml.doc
          "<p>The launch templates and overrides that were used for launching the instances. The values that you specify in the Overrides replace the values in the launch template.</p>"];
      lifecycle: InstanceLifecycle.t option
        [@ocaml.doc
          "<p>Indicates if the instance that could not be launched was a Spot Instance or On-Demand Instance.</p>"];
      error_code: String.t option
        [@ocaml.doc
          "<p>The error code that indicates why the instance could not be launched. For more information about error codes, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html\">Error Codes</a>.</p>"];
      error_message: String.t option
        [@ocaml.doc
          "<p>The error message that describes why the instance could not be launched. For more information about error messages, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/errors-overview.html.html\">Error Codes</a>.</p>"]}
    [@@ocaml.doc
      "<p>Describes the instances that could not be launched by the fleet.</p>"]
    let make ?launch_template_and_overrides  ?lifecycle  ?error_code 
      ?error_message  () =
      { launch_template_and_overrides; lifecycle; error_code; error_message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.error_message
              (fun f -> Query.Pair ("ErrorMessage", (String.to_query f)));
           Util.option_map v.error_code
             (fun f -> Query.Pair ("ErrorCode", (String.to_query f)));
           Util.option_map v.lifecycle
             (fun f ->
                Query.Pair ("Lifecycle", (InstanceLifecycle.to_query f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                Query.Pair
                  ("LaunchTemplateAndOverrides",
                    (LaunchTemplateAndOverridesResponse.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.error_message
              (fun f -> ("error_message", (String.to_json f)));
           Util.option_map v.error_code
             (fun f -> ("error_code", (String.to_json f)));
           Util.option_map v.lifecycle
             (fun f -> ("lifecycle", (InstanceLifecycle.to_json f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                ("launch_template_and_overrides",
                  (LaunchTemplateAndOverridesResponse.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_and_overrides =
            (Util.option_bind (Xml.member "launchTemplateAndOverrides" xml)
               LaunchTemplateAndOverridesResponse.parse);
          lifecycle =
            (Util.option_bind (Xml.member "lifecycle" xml)
               InstanceLifecycle.parse);
          error_code =
            (Util.option_bind (Xml.member "errorCode" xml) String.parse);
          error_message =
            (Util.option_bind (Xml.member "errorMessage" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.launch_template_and_overrides
                 (fun f ->
                    Ezxmlm.make_tag "launchTemplateAndOverrides"
                      ([], (LaunchTemplateAndOverridesResponse.to_xml f)))])
             @
             [Util.option_map v.lifecycle
                (fun f ->
                   Ezxmlm.make_tag "lifecycle"
                     ([], (InstanceLifecycle.to_xml f)))])
            @
            [Util.option_map v.error_code
               (fun f -> Ezxmlm.make_tag "errorCode" ([], (String.to_xml f)))])
           @
           [Util.option_map v.error_message
              (fun f ->
                 Ezxmlm.make_tag "errorMessage" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the instances that could not be launched by the fleet.</p>"]
module CreateFleetInstance =
  struct
    type t =
      {
      launch_template_and_overrides:
        LaunchTemplateAndOverridesResponse.t option
        [@ocaml.doc
          "<p>The launch templates and overrides that were used for launching the instances. The values that you specify in the Overrides replace the values in the launch template.</p>"];
      lifecycle: InstanceLifecycle.t option
        [@ocaml.doc
          "<p>Indicates if the instance that was launched is a Spot Instance or On-Demand Instance.</p>"];
      instance_ids: InstanceIdsSet.t
        [@ocaml.doc "<p>The IDs of the instances.</p>"];
      instance_type: InstanceType.t option
        [@ocaml.doc "<p>The instance type.</p>"];
      platform: PlatformValues.t option
        [@ocaml.doc
          "<p>The value is <code>Windows</code> for Windows instances. Otherwise, the value is blank.</p>"]}
    [@@ocaml.doc
      "<p>Describes the instances that were launched by the fleet.</p>"]
    let make ?launch_template_and_overrides  ?lifecycle  ?(instance_ids= []) 
      ?instance_type  ?platform  () =
      {
        launch_template_and_overrides;
        lifecycle;
        instance_ids;
        instance_type;
        platform
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.platform
              (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Some
             (Query.Pair
                ("InstanceIds", (InstanceIdsSet.to_query v.instance_ids)));
           Util.option_map v.lifecycle
             (fun f ->
                Query.Pair ("Lifecycle", (InstanceLifecycle.to_query f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                Query.Pair
                  ("LaunchTemplateAndOverrides",
                    (LaunchTemplateAndOverridesResponse.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.platform
              (fun f -> ("platform", (PlatformValues.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Some ("instance_ids", (InstanceIdsSet.to_json v.instance_ids));
           Util.option_map v.lifecycle
             (fun f -> ("lifecycle", (InstanceLifecycle.to_json f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                ("launch_template_and_overrides",
                  (LaunchTemplateAndOverridesResponse.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_and_overrides =
            (Util.option_bind (Xml.member "launchTemplateAndOverrides" xml)
               LaunchTemplateAndOverridesResponse.parse);
          lifecycle =
            (Util.option_bind (Xml.member "lifecycle" xml)
               InstanceLifecycle.parse);
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceIds" xml)
                  InstanceIdsSet.parse));
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.launch_template_and_overrides
                  (fun f ->
                     Ezxmlm.make_tag "launchTemplateAndOverrides"
                       ([], (LaunchTemplateAndOverridesResponse.to_xml f)))])
              @
              [Util.option_map v.lifecycle
                 (fun f ->
                    Ezxmlm.make_tag "lifecycle"
                      ([], (InstanceLifecycle.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "instanceIds"
                        ([], (InstanceIdsSet.to_xml [x])))) v.instance_ids))
            @
            [Util.option_map v.instance_type
               (fun f ->
                  Ezxmlm.make_tag "instanceType"
                    ([], (InstanceType.to_xml f)))])
           @
           [Util.option_map v.platform
              (fun f ->
                 Ezxmlm.make_tag "platform" ([], (PlatformValues.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the instances that were launched by the fleet.</p>"]
module SnapshotInfo =
  struct
    type t =
      {
      description: String.t option
        [@ocaml.doc
          "<p>Description specified by the CreateSnapshotRequest that has been applied to all snapshots.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Tags associated with this snapshot.</p>"];
      encrypted: Boolean.t option
        [@ocaml.doc "<p>Indicates whether the snapshot is encrypted.</p>"];
      volume_id: String.t option
        [@ocaml.doc
          "<p>Source volume from which this snapshot was created.</p>"];
      state: SnapshotState.t option
        [@ocaml.doc "<p>Current state of the snapshot.</p>"];
      volume_size: Integer.t option
        [@ocaml.doc
          "<p>Size of the volume from which this snapshot was created.</p>"];
      start_time: DateTime.t option
        [@ocaml.doc
          "<p>Time this snapshot was started. This is the same for all snapshots initiated by the same request.</p>"];
      progress: String.t option
        [@ocaml.doc
          "<p>Progress this snapshot has made towards completing.</p>"];
      owner_id: String.t option
        [@ocaml.doc "<p>Account id used when creating this snapshot.</p>"];
      snapshot_id: String.t option
        [@ocaml.doc
          "<p>Snapshot id that can be used to describe this snapshot.</p>"]}
    [@@ocaml.doc "<p>Information about a snapshot.</p>"]
    let make ?description  ?(tags= [])  ?encrypted  ?volume_id  ?state 
      ?volume_size  ?start_time  ?progress  ?owner_id  ?snapshot_id  () =
      {
        description;
        tags;
        encrypted;
        volume_id;
        state;
        volume_size;
        start_time;
        progress;
        owner_id;
        snapshot_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.snapshot_id
              (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.start_time
             (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Util.option_map v.volume_size
             (fun f -> Query.Pair ("VolumeSize", (Integer.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (SnapshotState.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.snapshot_id
              (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.start_time
             (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.volume_size
             (fun f -> ("volume_size", (Integer.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (SnapshotState.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) SnapshotState.parse);
          volume_size =
            (Util.option_bind (Xml.member "volumeSize" xml) Integer.parse);
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.description
                       (fun f ->
                          Ezxmlm.make_tag "description"
                            ([], (String.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "tagSet"
                              ([], (TagList.to_xml [x])))) v.tags))
                  @
                  [Util.option_map v.encrypted
                     (fun f ->
                        Ezxmlm.make_tag "encrypted" ([], (Boolean.to_xml f)))])
                 @
                 [Util.option_map v.volume_id
                    (fun f ->
                       Ezxmlm.make_tag "volumeId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.state
                   (fun f ->
                      Ezxmlm.make_tag "state" ([], (SnapshotState.to_xml f)))])
               @
               [Util.option_map v.volume_size
                  (fun f ->
                     Ezxmlm.make_tag "volumeSize" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.start_time
                 (fun f ->
                    Ezxmlm.make_tag "startTime" ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.progress
                (fun f -> Ezxmlm.make_tag "progress" ([], (String.to_xml f)))])
            @
            [Util.option_map v.owner_id
               (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.snapshot_id
              (fun f -> Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Information about a snapshot.</p>"]
module TrafficMirrorTarget =
  struct
    type t =
      {
      traffic_mirror_target_id: String.t option
        [@ocaml.doc "<p>The ID of the Traffic Mirror target.</p>"];
      network_interface_id: String.t option
        [@ocaml.doc
          "<p>The network interface ID that is attached to the target.</p>"];
      network_load_balancer_arn: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the Network Load Balancer.</p>"];
      type_: TrafficMirrorTargetType.t option
        [@ocaml.doc "<p>The type of Traffic Mirror target.</p>"];
      description: String.t option
        [@ocaml.doc "<p>Information about the Traffic Mirror target.</p>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the account that owns the Traffic Mirror target.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>The tags assigned to the Traffic Mirror target.</p>"]}
    [@@ocaml.doc "<p>Describes a Traffic Mirror target.</p>"]
    let make ?traffic_mirror_target_id  ?network_interface_id 
      ?network_load_balancer_arn  ?type_  ?description  ?owner_id  ?(tags=
      [])  () =
      {
        traffic_mirror_target_id;
        network_interface_id;
        network_load_balancer_arn;
        type_;
        description;
        owner_id;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.type_
             (fun f ->
                Query.Pair ("Type", (TrafficMirrorTargetType.to_query f)));
           Util.option_map v.network_load_balancer_arn
             (fun f ->
                Query.Pair ("NetworkLoadBalancerArn", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.traffic_mirror_target_id
             (fun f ->
                Query.Pair ("TrafficMirrorTargetId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (TrafficMirrorTargetType.to_json f)));
           Util.option_map v.network_load_balancer_arn
             (fun f -> ("network_load_balancer_arn", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_target_id
             (fun f -> ("traffic_mirror_target_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          traffic_mirror_target_id =
            (Util.option_bind (Xml.member "trafficMirrorTargetId" xml)
               String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          network_load_balancer_arn =
            (Util.option_bind (Xml.member "networkLoadBalancerArn" xml)
               String.parse);
          type_ =
            (Util.option_bind (Xml.member "type" xml)
               TrafficMirrorTargetType.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.traffic_mirror_target_id
                    (fun f ->
                       Ezxmlm.make_tag "trafficMirrorTargetId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.network_interface_id
                   (fun f ->
                      Ezxmlm.make_tag "networkInterfaceId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.network_load_balancer_arn
                  (fun f ->
                     Ezxmlm.make_tag "networkLoadBalancerArn"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.type_
                 (fun f ->
                    Ezxmlm.make_tag "type"
                      ([], (TrafficMirrorTargetType.to_xml f)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
            @
            [Util.option_map v.owner_id
               (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a Traffic Mirror target.</p>"]
module TrafficMirrorFilterRuleField =
  struct
    type t =
      | Destination_port_range 
      | Source_port_range 
      | Protocol 
      | Description 
    let str_to_t =
      [("description", Description);
      ("protocol", Protocol);
      ("source-port-range", Source_port_range);
      ("destination-port-range", Destination_port_range)]
    let t_to_str =
      [(Description, "description");
      (Protocol, "protocol");
      (Source_port_range, "source-port-range");
      (Destination_port_range, "destination-port-range")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module VolumeModification =
  struct
    type t =
      {
      volume_id: String.t option [@ocaml.doc "<p>The ID of the volume.</p>"];
      modification_state: VolumeModificationState.t option
        [@ocaml.doc
          "<p>The current modification state. The modification state is null for unmodified volumes.</p>"];
      status_message: String.t option
        [@ocaml.doc
          "<p>A status message about the modification progress or failure.</p>"];
      target_size: Integer.t option
        [@ocaml.doc "<p>The target size of the volume, in GiB.</p>"];
      target_iops: Integer.t option
        [@ocaml.doc "<p>The target IOPS rate of the volume.</p>"];
      target_volume_type: VolumeType.t option
        [@ocaml.doc "<p>The target EBS volume type of the volume.</p>"];
      original_size: Integer.t option
        [@ocaml.doc "<p>The original size of the volume.</p>"];
      original_iops: Integer.t option
        [@ocaml.doc "<p>The original IOPS rate of the volume.</p>"];
      original_volume_type: VolumeType.t option
        [@ocaml.doc "<p>The original EBS volume type of the volume.</p>"];
      progress: Long.t option
        [@ocaml.doc
          "<p>The modification progress, from 0 to 100 percent complete.</p>"];
      start_time: DateTime.t option
        [@ocaml.doc "<p>The modification start time.</p>"];
      end_time: DateTime.t option
        [@ocaml.doc "<p>The modification completion or failure time.</p>"]}
    [@@ocaml.doc
      "<p>Describes the modification status of an EBS volume.</p> <p>If the volume has never been modified, some element values will be null.</p>"]
    let make ?volume_id  ?modification_state  ?status_message  ?target_size 
      ?target_iops  ?target_volume_type  ?original_size  ?original_iops 
      ?original_volume_type  ?progress  ?start_time  ?end_time  () =
      {
        volume_id;
        modification_state;
        status_message;
        target_size;
        target_iops;
        target_volume_type;
        original_size;
        original_iops;
        original_volume_type;
        progress;
        start_time;
        end_time
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.end_time
              (fun f -> Query.Pair ("EndTime", (DateTime.to_query f)));
           Util.option_map v.start_time
             (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (Long.to_query f)));
           Util.option_map v.original_volume_type
             (fun f ->
                Query.Pair ("OriginalVolumeType", (VolumeType.to_query f)));
           Util.option_map v.original_iops
             (fun f -> Query.Pair ("OriginalIops", (Integer.to_query f)));
           Util.option_map v.original_size
             (fun f -> Query.Pair ("OriginalSize", (Integer.to_query f)));
           Util.option_map v.target_volume_type
             (fun f ->
                Query.Pair ("TargetVolumeType", (VolumeType.to_query f)));
           Util.option_map v.target_iops
             (fun f -> Query.Pair ("TargetIops", (Integer.to_query f)));
           Util.option_map v.target_size
             (fun f -> Query.Pair ("TargetSize", (Integer.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.modification_state
             (fun f ->
                Query.Pair
                  ("ModificationState", (VolumeModificationState.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.end_time
              (fun f -> ("end_time", (DateTime.to_json f)));
           Util.option_map v.start_time
             (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (Long.to_json f)));
           Util.option_map v.original_volume_type
             (fun f -> ("original_volume_type", (VolumeType.to_json f)));
           Util.option_map v.original_iops
             (fun f -> ("original_iops", (Integer.to_json f)));
           Util.option_map v.original_size
             (fun f -> ("original_size", (Integer.to_json f)));
           Util.option_map v.target_volume_type
             (fun f -> ("target_volume_type", (VolumeType.to_json f)));
           Util.option_map v.target_iops
             (fun f -> ("target_iops", (Integer.to_json f)));
           Util.option_map v.target_size
             (fun f -> ("target_size", (Integer.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.modification_state
             (fun f ->
                ("modification_state", (VolumeModificationState.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          modification_state =
            (Util.option_bind (Xml.member "modificationState" xml)
               VolumeModificationState.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          target_size =
            (Util.option_bind (Xml.member "targetSize" xml) Integer.parse);
          target_iops =
            (Util.option_bind (Xml.member "targetIops" xml) Integer.parse);
          target_volume_type =
            (Util.option_bind (Xml.member "targetVolumeType" xml)
               VolumeType.parse);
          original_size =
            (Util.option_bind (Xml.member "originalSize" xml) Integer.parse);
          original_iops =
            (Util.option_bind (Xml.member "originalIops" xml) Integer.parse);
          original_volume_type =
            (Util.option_bind (Xml.member "originalVolumeType" xml)
               VolumeType.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) Long.parse);
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse);
          end_time =
            (Util.option_bind (Xml.member "endTime" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Util.option_map v.volume_id
                         (fun f ->
                            Ezxmlm.make_tag "volumeId"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.modification_state
                        (fun f ->
                           Ezxmlm.make_tag "modificationState"
                             ([], (VolumeModificationState.to_xml f)))])
                    @
                    [Util.option_map v.status_message
                       (fun f ->
                          Ezxmlm.make_tag "statusMessage"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.target_size
                      (fun f ->
                         Ezxmlm.make_tag "targetSize"
                           ([], (Integer.to_xml f)))])
                  @
                  [Util.option_map v.target_iops
                     (fun f ->
                        Ezxmlm.make_tag "targetIops" ([], (Integer.to_xml f)))])
                 @
                 [Util.option_map v.target_volume_type
                    (fun f ->
                       Ezxmlm.make_tag "targetVolumeType"
                         ([], (VolumeType.to_xml f)))])
                @
                [Util.option_map v.original_size
                   (fun f ->
                      Ezxmlm.make_tag "originalSize" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.original_iops
                  (fun f ->
                     Ezxmlm.make_tag "originalIops" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.original_volume_type
                 (fun f ->
                    Ezxmlm.make_tag "originalVolumeType"
                      ([], (VolumeType.to_xml f)))])
             @
             [Util.option_map v.progress
                (fun f -> Ezxmlm.make_tag "progress" ([], (Long.to_xml f)))])
            @
            [Util.option_map v.start_time
               (fun f ->
                  Ezxmlm.make_tag "startTime" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.end_time
              (fun f -> Ezxmlm.make_tag "endTime" ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the modification status of an EBS volume.</p> <p>If the volume has never been modified, some element values will be null.</p>"]
module NewDhcpConfiguration =
  struct
    type t = {
      key: String.t option ;
      values: ValueStringList.t }
    let make ?key  ?(values= [])  () = { key; values }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Value", (ValueStringList.to_query v.values)));
           Util.option_map v.key
             (fun f -> Query.Pair ("Key", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (ValueStringList.to_json v.values));
           Util.option_map v.key (fun f -> ("key", (String.to_json f)))])
    let parse xml =
      Some
        {
          key = (Util.option_bind (Xml.member "key" xml) String.parse);
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "Value" xml)
                  ValueStringList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.key
               (fun f -> Ezxmlm.make_tag "key" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Value"
                      ([], (ValueStringList.to_xml [x])))) v.values))
  end
module NetworkInterface =
  struct
    type t =
      {
      association: NetworkInterfaceAssociation.t option
        [@ocaml.doc
          "<p>The association information for an Elastic IP address (IPv4) associated with the network interface.</p>"];
      attachment: NetworkInterfaceAttachment.t option
        [@ocaml.doc "<p>The network interface attachment.</p>"];
      availability_zone: String.t option
        [@ocaml.doc "<p>The Availability Zone.</p>"];
      description: String.t option [@ocaml.doc "<p>A description.</p>"];
      groups: GroupIdentifierList.t
        [@ocaml.doc "<p>Any security groups for the network interface.</p>"];
      interface_type: NetworkInterfaceType.t option
        [@ocaml.doc "<p>The type of network interface.</p>"];
      ipv6_addresses: NetworkInterfaceIpv6AddressesList.t
        [@ocaml.doc
          "<p>The IPv6 addresses associated with the network interface.</p>"];
      mac_address: String.t option [@ocaml.doc "<p>The MAC address.</p>"];
      network_interface_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface.</p>"];
      outpost_arn: String.t option
        [@ocaml.doc "<p>The Amazon Resource Name (ARN) of the Outpost.</p>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The AWS account ID of the owner of the network interface.</p>"];
      private_dns_name: String.t option
        [@ocaml.doc "<p>The private DNS name.</p>"];
      private_ip_address: String.t option
        [@ocaml.doc
          "<p>The IPv4 address of the network interface within the subnet.</p>"];
      private_ip_addresses: NetworkInterfacePrivateIpAddressList.t
        [@ocaml.doc
          "<p>The private IPv4 addresses associated with the network interface.</p>"];
      requester_id: String.t option
        [@ocaml.doc
          "<p>The ID of the entity that launched the instance on your behalf (for example, AWS Management Console or Auto Scaling).</p>"];
      requester_managed: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the network interface is being managed by AWS.</p>"];
      source_dest_check: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether traffic to or from the instance is validated.</p>"];
      status: NetworkInterfaceStatus.t option
        [@ocaml.doc "<p>The status of the network interface.</p>"];
      subnet_id: String.t option [@ocaml.doc "<p>The ID of the subnet.</p>"];
      tag_set: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the network interface.</p>"];
      vpc_id: String.t option [@ocaml.doc "<p>The ID of the VPC.</p>"]}
    [@@ocaml.doc "<p>Describes a network interface.</p>"]
    let make ?association  ?attachment  ?availability_zone  ?description 
      ?(groups= [])  ?interface_type  ?(ipv6_addresses= [])  ?mac_address 
      ?network_interface_id  ?outpost_arn  ?owner_id  ?private_dns_name 
      ?private_ip_address  ?(private_ip_addresses= [])  ?requester_id 
      ?requester_managed  ?source_dest_check  ?status  ?subnet_id  ?(tag_set=
      [])  ?vpc_id  () =
      {
        association;
        attachment;
        availability_zone;
        description;
        groups;
        interface_type;
        ipv6_addresses;
        mac_address;
        network_interface_id;
        outpost_arn;
        owner_id;
        private_dns_name;
        private_ip_address;
        private_ip_addresses;
        requester_id;
        requester_managed;
        source_dest_check;
        status;
        subnet_id;
        tag_set;
        vpc_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tag_set)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (NetworkInterfaceStatus.to_query f)));
           Util.option_map v.source_dest_check
             (fun f -> Query.Pair ("SourceDestCheck", (Boolean.to_query f)));
           Util.option_map v.requester_managed
             (fun f -> Query.Pair ("RequesterManaged", (Boolean.to_query f)));
           Util.option_map v.requester_id
             (fun f -> Query.Pair ("RequesterId", (String.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddressesSet",
                  (NetworkInterfacePrivateIpAddressList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.mac_address
             (fun f -> Query.Pair ("MacAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6AddressesSet",
                  (NetworkInterfaceIpv6AddressesList.to_query
                     v.ipv6_addresses)));
           Util.option_map v.interface_type
             (fun f ->
                Query.Pair
                  ("InterfaceType", (NetworkInterfaceType.to_query f)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.attachment
             (fun f ->
                Query.Pair
                  ("Attachment", (NetworkInterfaceAttachment.to_query f)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association", (NetworkInterfaceAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tag_set", (TagList.to_json v.tag_set));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (NetworkInterfaceStatus.to_json f)));
           Util.option_map v.source_dest_check
             (fun f -> ("source_dest_check", (Boolean.to_json f)));
           Util.option_map v.requester_managed
             (fun f -> ("requester_managed", (Boolean.to_json f)));
           Util.option_map v.requester_id
             (fun f -> ("requester_id", (String.to_json f)));
           Some
             ("private_ip_addresses",
               (NetworkInterfacePrivateIpAddressList.to_json
                  v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.mac_address
             (fun f -> ("mac_address", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (NetworkInterfaceIpv6AddressesList.to_json v.ipv6_addresses));
           Util.option_map v.interface_type
             (fun f -> ("interface_type", (NetworkInterfaceType.to_json f)));
           Some ("groups", (GroupIdentifierList.to_json v.groups));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.attachment
             (fun f -> ("attachment", (NetworkInterfaceAttachment.to_json f)));
           Util.option_map v.association
             (fun f ->
                ("association", (NetworkInterfaceAssociation.to_json f)))])
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               NetworkInterfaceAssociation.parse);
          attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               NetworkInterfaceAttachment.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          interface_type =
            (Util.option_bind (Xml.member "interfaceType" xml)
               NetworkInterfaceType.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6AddressesSet" xml)
                  NetworkInterfaceIpv6AddressesList.parse));
          mac_address =
            (Util.option_bind (Xml.member "macAddress" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddressesSet" xml)
                  NetworkInterfacePrivateIpAddressList.parse));
          requester_id =
            (Util.option_bind (Xml.member "requesterId" xml) String.parse);
          requester_managed =
            (Util.option_bind (Xml.member "requesterManaged" xml)
               Boolean.parse);
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               Boolean.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               NetworkInterfaceStatus.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          tag_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((((((([] @
                               [Util.option_map v.association
                                  (fun f ->
                                     Ezxmlm.make_tag "association"
                                       ([],
                                         (NetworkInterfaceAssociation.to_xml
                                            f)))])
                              @
                              [Util.option_map v.attachment
                                 (fun f ->
                                    Ezxmlm.make_tag "attachment"
                                      ([],
                                        (NetworkInterfaceAttachment.to_xml f)))])
                             @
                             [Util.option_map v.availability_zone
                                (fun f ->
                                   Ezxmlm.make_tag "availabilityZone"
                                     ([], (String.to_xml f)))])
                            @
                            [Util.option_map v.description
                               (fun f ->
                                  Ezxmlm.make_tag "description"
                                    ([], (String.to_xml f)))])
                           @
                           (List.map
                              (fun x ->
                                 Some
                                   (Ezxmlm.make_tag "groupSet"
                                      ([], (GroupIdentifierList.to_xml [x]))))
                              v.groups))
                          @
                          [Util.option_map v.interface_type
                             (fun f ->
                                Ezxmlm.make_tag "interfaceType"
                                  ([], (NetworkInterfaceType.to_xml f)))])
                         @
                         (List.map
                            (fun x ->
                               Some
                                 (Ezxmlm.make_tag "ipv6AddressesSet"
                                    ([],
                                      (NetworkInterfaceIpv6AddressesList.to_xml
                                         [x])))) v.ipv6_addresses))
                        @
                        [Util.option_map v.mac_address
                           (fun f ->
                              Ezxmlm.make_tag "macAddress"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.network_interface_id
                          (fun f ->
                             Ezxmlm.make_tag "networkInterfaceId"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.outpost_arn
                         (fun f ->
                            Ezxmlm.make_tag "outpostArn"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.owner_id
                        (fun f ->
                           Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.private_dns_name
                       (fun f ->
                          Ezxmlm.make_tag "privateDnsName"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.private_ip_address
                      (fun f ->
                         Ezxmlm.make_tag "privateIpAddress"
                           ([], (String.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "privateIpAddressesSet"
                             ([],
                               (NetworkInterfacePrivateIpAddressList.to_xml
                                  [x])))) v.private_ip_addresses))
                 @
                 [Util.option_map v.requester_id
                    (fun f ->
                       Ezxmlm.make_tag "requesterId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.requester_managed
                   (fun f ->
                      Ezxmlm.make_tag "requesterManaged"
                        ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.source_dest_check
                  (fun f ->
                     Ezxmlm.make_tag "sourceDestCheck"
                       ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.status
                 (fun f ->
                    Ezxmlm.make_tag "status"
                      ([], (NetworkInterfaceStatus.to_xml f)))])
             @
             [Util.option_map v.subnet_id
                (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tag_set))
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a network interface.</p>"]
module ConnectionNotification =
  struct
    type t =
      {
      connection_notification_id: String.t option
        [@ocaml.doc "<p>The ID of the notification.</p>"];
      service_id: String.t option
        [@ocaml.doc "<p>The ID of the endpoint service.</p>"];
      vpc_endpoint_id: String.t option
        [@ocaml.doc "<p>The ID of the VPC endpoint.</p>"];
      connection_notification_type: ConnectionNotificationType.t option
        [@ocaml.doc "<p>The type of notification.</p>"];
      connection_notification_arn: String.t option
        [@ocaml.doc "<p>The ARN of the SNS topic for the notification.</p>"];
      connection_events: ValueStringList.t
        [@ocaml.doc
          "<p>The events for the notification. Valid values are <code>Accept</code>, <code>Connect</code>, <code>Delete</code>, and <code>Reject</code>.</p>"];
      connection_notification_state: ConnectionNotificationState.t option
        [@ocaml.doc "<p>The state of the notification.</p>"]}[@@ocaml.doc
                                                               "<p>Describes a connection notification for a VPC endpoint or VPC endpoint service.</p>"]
    let make ?connection_notification_id  ?service_id  ?vpc_endpoint_id 
      ?connection_notification_type  ?connection_notification_arn 
      ?(connection_events= [])  ?connection_notification_state  () =
      {
        connection_notification_id;
        service_id;
        vpc_endpoint_id;
        connection_notification_type;
        connection_notification_arn;
        connection_events;
        connection_notification_state
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.connection_notification_state
              (fun f ->
                 Query.Pair
                   ("ConnectionNotificationState",
                     (ConnectionNotificationState.to_query f)));
           Some
             (Query.Pair
                ("ConnectionEvents",
                  (ValueStringList.to_query v.connection_events)));
           Util.option_map v.connection_notification_arn
             (fun f ->
                Query.Pair ("ConnectionNotificationArn", (String.to_query f)));
           Util.option_map v.connection_notification_type
             (fun f ->
                Query.Pair
                  ("ConnectionNotificationType",
                    (ConnectionNotificationType.to_query f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> Query.Pair ("VpcEndpointId", (String.to_query f)));
           Util.option_map v.service_id
             (fun f -> Query.Pair ("ServiceId", (String.to_query f)));
           Util.option_map v.connection_notification_id
             (fun f ->
                Query.Pair ("ConnectionNotificationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.connection_notification_state
              (fun f ->
                 ("connection_notification_state",
                   (ConnectionNotificationState.to_json f)));
           Some
             ("connection_events",
               (ValueStringList.to_json v.connection_events));
           Util.option_map v.connection_notification_arn
             (fun f -> ("connection_notification_arn", (String.to_json f)));
           Util.option_map v.connection_notification_type
             (fun f ->
                ("connection_notification_type",
                  (ConnectionNotificationType.to_json f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> ("vpc_endpoint_id", (String.to_json f)));
           Util.option_map v.service_id
             (fun f -> ("service_id", (String.to_json f)));
           Util.option_map v.connection_notification_id
             (fun f -> ("connection_notification_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          connection_notification_id =
            (Util.option_bind (Xml.member "connectionNotificationId" xml)
               String.parse);
          service_id =
            (Util.option_bind (Xml.member "serviceId" xml) String.parse);
          vpc_endpoint_id =
            (Util.option_bind (Xml.member "vpcEndpointId" xml) String.parse);
          connection_notification_type =
            (Util.option_bind (Xml.member "connectionNotificationType" xml)
               ConnectionNotificationType.parse);
          connection_notification_arn =
            (Util.option_bind (Xml.member "connectionNotificationArn" xml)
               String.parse);
          connection_events =
            (Util.of_option []
               (Util.option_bind (Xml.member "connectionEvents" xml)
                  ValueStringList.parse));
          connection_notification_state =
            (Util.option_bind (Xml.member "connectionNotificationState" xml)
               ConnectionNotificationState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.connection_notification_id
                    (fun f ->
                       Ezxmlm.make_tag "connectionNotificationId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.service_id
                   (fun f ->
                      Ezxmlm.make_tag "serviceId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.vpc_endpoint_id
                  (fun f ->
                     Ezxmlm.make_tag "vpcEndpointId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.connection_notification_type
                 (fun f ->
                    Ezxmlm.make_tag "connectionNotificationType"
                      ([], (ConnectionNotificationType.to_xml f)))])
             @
             [Util.option_map v.connection_notification_arn
                (fun f ->
                   Ezxmlm.make_tag "connectionNotificationArn"
                     ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "connectionEvents"
                       ([], (ValueStringList.to_xml [x]))))
               v.connection_events))
           @
           [Util.option_map v.connection_notification_state
              (fun f ->
                 Ezxmlm.make_tag "connectionNotificationState"
                   ([], (ConnectionNotificationState.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a connection notification for a VPC endpoint or VPC endpoint service.</p>"]
module ReservedInstances =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc
          "<p>The Availability Zone in which the Reserved Instance can be used.</p>"];
      duration: Long.t option
        [@ocaml.doc
          "<p>The duration of the Reserved Instance, in seconds.</p>"];
      end_: DateTime.t option
        [@ocaml.doc "<p>The time when the Reserved Instance expires.</p>"];
      fixed_price: Float.t option
        [@ocaml.doc "<p>The purchase price of the Reserved Instance.</p>"];
      instance_count: Integer.t option
        [@ocaml.doc "<p>The number of reservations purchased.</p>"];
      instance_type: InstanceType.t option
        [@ocaml.doc
          "<p>The instance type on which the Reserved Instance can be used.</p>"];
      product_description: RIProductDescription.t option
        [@ocaml.doc
          "<p>The Reserved Instance product platform description.</p>"];
      reserved_instances_id: String.t option
        [@ocaml.doc "<p>The ID of the Reserved Instance.</p>"];
      start: DateTime.t option
        [@ocaml.doc
          "<p>The date and time the Reserved Instance started.</p>"];
      state: ReservedInstanceState.t option
        [@ocaml.doc "<p>The state of the Reserved Instance purchase.</p>"];
      usage_price: Float.t option
        [@ocaml.doc
          "<p>The usage price of the Reserved Instance, per hour.</p>"];
      currency_code: CurrencyCodeValues.t option
        [@ocaml.doc
          "<p>The currency of the Reserved Instance. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is <code>USD</code>.</p>"];
      instance_tenancy: Tenancy.t option
        [@ocaml.doc "<p>The tenancy of the instance.</p>"];
      offering_class: OfferingClassType.t option
        [@ocaml.doc "<p>The offering class of the Reserved Instance.</p>"];
      offering_type: OfferingTypeValues.t option
        [@ocaml.doc "<p>The Reserved Instance offering type.</p>"];
      recurring_charges: RecurringChargesList.t
        [@ocaml.doc
          "<p>The recurring charge tag assigned to the resource.</p>"];
      scope: Scope.t option
        [@ocaml.doc "<p>The scope of the Reserved Instance.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the resource.</p>"]}[@@ocaml.doc
                                                                   "<p>Describes a Reserved Instance.</p>"]
    let make ?availability_zone  ?duration  ?end_  ?fixed_price 
      ?instance_count  ?instance_type  ?product_description 
      ?reserved_instances_id  ?start  ?state  ?usage_price  ?currency_code 
      ?instance_tenancy  ?offering_class  ?offering_type 
      ?(recurring_charges= [])  ?scope  ?(tags= [])  () =
      {
        availability_zone;
        duration;
        end_;
        fixed_price;
        instance_count;
        instance_type;
        product_description;
        reserved_instances_id;
        start;
        state;
        usage_price;
        currency_code;
        instance_tenancy;
        offering_class;
        offering_type;
        recurring_charges;
        scope;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.scope
             (fun f -> Query.Pair ("Scope", (Scope.to_query f)));
           Some
             (Query.Pair
                ("RecurringCharges",
                  (RecurringChargesList.to_query v.recurring_charges)));
           Util.option_map v.offering_type
             (fun f ->
                Query.Pair ("OfferingType", (OfferingTypeValues.to_query f)));
           Util.option_map v.offering_class
             (fun f ->
                Query.Pair ("OfferingClass", (OfferingClassType.to_query f)));
           Util.option_map v.instance_tenancy
             (fun f -> Query.Pair ("InstanceTenancy", (Tenancy.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.usage_price
             (fun f -> Query.Pair ("UsagePrice", (Float.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (ReservedInstanceState.to_query f)));
           Util.option_map v.start
             (fun f -> Query.Pair ("Start", (DateTime.to_query f)));
           Util.option_map v.reserved_instances_id
             (fun f ->
                Query.Pair ("ReservedInstancesId", (String.to_query f)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.fixed_price
             (fun f -> Query.Pair ("FixedPrice", (Float.to_query f)));
           Util.option_map v.end_
             (fun f -> Query.Pair ("End", (DateTime.to_query f)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Long.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.scope (fun f -> ("scope", (Scope.to_json f)));
           Some
             ("recurring_charges",
               (RecurringChargesList.to_json v.recurring_charges));
           Util.option_map v.offering_type
             (fun f -> ("offering_type", (OfferingTypeValues.to_json f)));
           Util.option_map v.offering_class
             (fun f -> ("offering_class", (OfferingClassType.to_json f)));
           Util.option_map v.instance_tenancy
             (fun f -> ("instance_tenancy", (Tenancy.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.usage_price
             (fun f -> ("usage_price", (Float.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (ReservedInstanceState.to_json f)));
           Util.option_map v.start (fun f -> ("start", (DateTime.to_json f)));
           Util.option_map v.reserved_instances_id
             (fun f -> ("reserved_instances_id", (String.to_json f)));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.fixed_price
             (fun f -> ("fixed_price", (Float.to_json f)));
           Util.option_map v.end_ (fun f -> ("end_", (DateTime.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Long.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Long.parse);
          end_ = (Util.option_bind (Xml.member "end" xml) DateTime.parse);
          fixed_price =
            (Util.option_bind (Xml.member "fixedPrice" xml) Float.parse);
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          product_description =
            (Util.option_bind (Xml.member "productDescription" xml)
               RIProductDescription.parse);
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse);
          start = (Util.option_bind (Xml.member "start" xml) DateTime.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               ReservedInstanceState.parse);
          usage_price =
            (Util.option_bind (Xml.member "usagePrice" xml) Float.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          instance_tenancy =
            (Util.option_bind (Xml.member "instanceTenancy" xml)
               Tenancy.parse);
          offering_class =
            (Util.option_bind (Xml.member "offeringClass" xml)
               OfferingClassType.parse);
          offering_type =
            (Util.option_bind (Xml.member "offeringType" xml)
               OfferingTypeValues.parse);
          recurring_charges =
            (Util.of_option []
               (Util.option_bind (Xml.member "recurringCharges" xml)
                  RecurringChargesList.parse));
          scope = (Util.option_bind (Xml.member "scope" xml) Scope.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((([] @
                            [Util.option_map v.availability_zone
                               (fun f ->
                                  Ezxmlm.make_tag "availabilityZone"
                                    ([], (String.to_xml f)))])
                           @
                           [Util.option_map v.duration
                              (fun f ->
                                 Ezxmlm.make_tag "duration"
                                   ([], (Long.to_xml f)))])
                          @
                          [Util.option_map v.end_
                             (fun f ->
                                Ezxmlm.make_tag "end"
                                  ([], (DateTime.to_xml f)))])
                         @
                         [Util.option_map v.fixed_price
                            (fun f ->
                               Ezxmlm.make_tag "fixedPrice"
                                 ([], (Float.to_xml f)))])
                        @
                        [Util.option_map v.instance_count
                           (fun f ->
                              Ezxmlm.make_tag "instanceCount"
                                ([], (Integer.to_xml f)))])
                       @
                       [Util.option_map v.instance_type
                          (fun f ->
                             Ezxmlm.make_tag "instanceType"
                               ([], (InstanceType.to_xml f)))])
                      @
                      [Util.option_map v.product_description
                         (fun f ->
                            Ezxmlm.make_tag "productDescription"
                              ([], (RIProductDescription.to_xml f)))])
                     @
                     [Util.option_map v.reserved_instances_id
                        (fun f ->
                           Ezxmlm.make_tag "reservedInstancesId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.start
                       (fun f ->
                          Ezxmlm.make_tag "start" ([], (DateTime.to_xml f)))])
                   @
                   [Util.option_map v.state
                      (fun f ->
                         Ezxmlm.make_tag "state"
                           ([], (ReservedInstanceState.to_xml f)))])
                  @
                  [Util.option_map v.usage_price
                     (fun f ->
                        Ezxmlm.make_tag "usagePrice" ([], (Float.to_xml f)))])
                 @
                 [Util.option_map v.currency_code
                    (fun f ->
                       Ezxmlm.make_tag "currencyCode"
                         ([], (CurrencyCodeValues.to_xml f)))])
                @
                [Util.option_map v.instance_tenancy
                   (fun f ->
                      Ezxmlm.make_tag "instanceTenancy"
                        ([], (Tenancy.to_xml f)))])
               @
               [Util.option_map v.offering_class
                  (fun f ->
                     Ezxmlm.make_tag "offeringClass"
                       ([], (OfferingClassType.to_xml f)))])
              @
              [Util.option_map v.offering_type
                 (fun f ->
                    Ezxmlm.make_tag "offeringType"
                      ([], (OfferingTypeValues.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "recurringCharges"
                        ([], (RecurringChargesList.to_xml [x]))))
                v.recurring_charges))
            @
            [Util.option_map v.scope
               (fun f -> Ezxmlm.make_tag "scope" ([], (Scope.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a Reserved Instance.</p>"]
module TransitGatewayPeeringAttachment =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option
        [@ocaml.doc
          "<p>The ID of the transit gateway peering attachment.</p>"];
      requester_tgw_info: PeeringTgwInfo.t option
        [@ocaml.doc
          "<p>Information about the requester transit gateway.</p>"];
      accepter_tgw_info: PeeringTgwInfo.t option
        [@ocaml.doc "<p>Information about the accepter transit gateway.</p>"];
      status: PeeringAttachmentStatus.t option
        [@ocaml.doc
          "<p>The status of the transit gateway peering attachment.</p>"];
      state: TransitGatewayAttachmentState.t option
        [@ocaml.doc
          "<p>The state of the transit gateway peering attachment.</p>"];
      creation_time: DateTime.t option
        [@ocaml.doc
          "<p>The time the transit gateway peering attachment was created.</p>"];
      tags: TagList.t
        [@ocaml.doc
          "<p>The tags for the transit gateway peering attachment.</p>"]}
    [@@ocaml.doc "<p>Describes the transit gateway peering attachment.</p>"]
    let make ?transit_gateway_attachment_id  ?requester_tgw_info 
      ?accepter_tgw_info  ?status  ?state  ?creation_time  ?(tags= [])  () =
      {
        transit_gateway_attachment_id;
        requester_tgw_info;
        accepter_tgw_info;
        status;
        state;
        creation_time;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (TransitGatewayAttachmentState.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (PeeringAttachmentStatus.to_query f)));
           Util.option_map v.accepter_tgw_info
             (fun f ->
                Query.Pair ("AccepterTgwInfo", (PeeringTgwInfo.to_query f)));
           Util.option_map v.requester_tgw_info
             (fun f ->
                Query.Pair ("RequesterTgwInfo", (PeeringTgwInfo.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (TransitGatewayAttachmentState.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (PeeringAttachmentStatus.to_json f)));
           Util.option_map v.accepter_tgw_info
             (fun f -> ("accepter_tgw_info", (PeeringTgwInfo.to_json f)));
           Util.option_map v.requester_tgw_info
             (fun f -> ("requester_tgw_info", (PeeringTgwInfo.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          requester_tgw_info =
            (Util.option_bind (Xml.member "requesterTgwInfo" xml)
               PeeringTgwInfo.parse);
          accepter_tgw_info =
            (Util.option_bind (Xml.member "accepterTgwInfo" xml)
               PeeringTgwInfo.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               PeeringAttachmentStatus.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAttachmentState.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.transit_gateway_attachment_id
                    (fun f ->
                       Ezxmlm.make_tag "transitGatewayAttachmentId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.requester_tgw_info
                   (fun f ->
                      Ezxmlm.make_tag "requesterTgwInfo"
                        ([], (PeeringTgwInfo.to_xml f)))])
               @
               [Util.option_map v.accepter_tgw_info
                  (fun f ->
                     Ezxmlm.make_tag "accepterTgwInfo"
                       ([], (PeeringTgwInfo.to_xml f)))])
              @
              [Util.option_map v.status
                 (fun f ->
                    Ezxmlm.make_tag "status"
                      ([], (PeeringAttachmentStatus.to_xml f)))])
             @
             [Util.option_map v.state
                (fun f ->
                   Ezxmlm.make_tag "state"
                     ([], (TransitGatewayAttachmentState.to_xml f)))])
            @
            [Util.option_map v.creation_time
               (fun f ->
                  Ezxmlm.make_tag "creationTime" ([], (DateTime.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes the transit gateway peering attachment.</p>"]
module CancelledSpotInstanceRequest =
  struct
    type t =
      {
      spot_instance_request_id: String.t option
        [@ocaml.doc "<p>The ID of the Spot Instance request.</p>"];
      state: CancelSpotInstanceRequestState.t option
        [@ocaml.doc "<p>The state of the Spot Instance request.</p>"]}
    [@@ocaml.doc "<p>Describes a request to cancel a Spot Instance.</p>"]
    let make ?spot_instance_request_id  ?state  () =
      { spot_instance_request_id; state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (CancelSpotInstanceRequestState.to_query f)));
           Util.option_map v.spot_instance_request_id
             (fun f ->
                Query.Pair ("SpotInstanceRequestId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (CancelSpotInstanceRequestState.to_json f)));
           Util.option_map v.spot_instance_request_id
             (fun f -> ("spot_instance_request_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          spot_instance_request_id =
            (Util.option_bind (Xml.member "spotInstanceRequestId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               CancelSpotInstanceRequestState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.spot_instance_request_id
               (fun f ->
                  Ezxmlm.make_tag "spotInstanceRequestId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (CancelSpotInstanceRequestState.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a request to cancel a Spot Instance.</p>"]
module ServiceConfiguration =
  struct
    type t =
      {
      service_type: ServiceTypeDetailSet.t
        [@ocaml.doc "<p>The type of service.</p>"];
      service_id: String.t option
        [@ocaml.doc "<p>The ID of the service.</p>"];
      service_name: String.t option
        [@ocaml.doc "<p>The name of the service.</p>"];
      service_state: ServiceState.t option
        [@ocaml.doc "<p>The service state.</p>"];
      availability_zones: ValueStringList.t
        [@ocaml.doc
          "<p>In the Availability Zones in which the service is available.</p>"];
      acceptance_required: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether requests from other AWS accounts to create an endpoint to the service must first be accepted.</p>"];
      manages_vpc_endpoints: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the service manages it's VPC endpoints. Management of the service VPC endpoints using the VPC endpoint API is restricted.</p>"];
      network_load_balancer_arns: ValueStringList.t
        [@ocaml.doc
          "<p>The Amazon Resource Names (ARNs) of the Network Load Balancers for the service.</p>"];
      base_endpoint_dns_names: ValueStringList.t
        [@ocaml.doc "<p>The DNS names for the service.</p>"];
      private_dns_name: String.t option
        [@ocaml.doc "<p>The private DNS name for the service.</p>"];
      tags: TagList.t [@ocaml.doc "<p>Any tags assigned to the service.</p>"]}
    [@@ocaml.doc
      "<p>Describes a service configuration for a VPC endpoint service.</p>"]
    let make ?(service_type= [])  ?service_id  ?service_name  ?service_state 
      ?(availability_zones= [])  ?acceptance_required  ?manages_vpc_endpoints
       ?(network_load_balancer_arns= [])  ?(base_endpoint_dns_names= []) 
      ?private_dns_name  ?(tags= [])  () =
      {
        service_type;
        service_id;
        service_name;
        service_state;
        availability_zones;
        acceptance_required;
        manages_vpc_endpoints;
        network_load_balancer_arns;
        base_endpoint_dns_names;
        private_dns_name;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Some
             (Query.Pair
                ("BaseEndpointDnsNameSet",
                  (ValueStringList.to_query v.base_endpoint_dns_names)));
           Some
             (Query.Pair
                ("NetworkLoadBalancerArnSet",
                  (ValueStringList.to_query v.network_load_balancer_arns)));
           Util.option_map v.manages_vpc_endpoints
             (fun f ->
                Query.Pair ("ManagesVpcEndpoints", (Boolean.to_query f)));
           Util.option_map v.acceptance_required
             (fun f ->
                Query.Pair ("AcceptanceRequired", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZoneSet",
                  (ValueStringList.to_query v.availability_zones)));
           Util.option_map v.service_state
             (fun f -> Query.Pair ("ServiceState", (ServiceState.to_query f)));
           Util.option_map v.service_name
             (fun f -> Query.Pair ("ServiceName", (String.to_query f)));
           Util.option_map v.service_id
             (fun f -> Query.Pair ("ServiceId", (String.to_query f)));
           Some
             (Query.Pair
                ("ServiceType",
                  (ServiceTypeDetailSet.to_query v.service_type)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Some
             ("base_endpoint_dns_names",
               (ValueStringList.to_json v.base_endpoint_dns_names));
           Some
             ("network_load_balancer_arns",
               (ValueStringList.to_json v.network_load_balancer_arns));
           Util.option_map v.manages_vpc_endpoints
             (fun f -> ("manages_vpc_endpoints", (Boolean.to_json f)));
           Util.option_map v.acceptance_required
             (fun f -> ("acceptance_required", (Boolean.to_json f)));
           Some
             ("availability_zones",
               (ValueStringList.to_json v.availability_zones));
           Util.option_map v.service_state
             (fun f -> ("service_state", (ServiceState.to_json f)));
           Util.option_map v.service_name
             (fun f -> ("service_name", (String.to_json f)));
           Util.option_map v.service_id
             (fun f -> ("service_id", (String.to_json f)));
           Some
             ("service_type", (ServiceTypeDetailSet.to_json v.service_type))])
    let parse xml =
      Some
        {
          service_type =
            (Util.of_option []
               (Util.option_bind (Xml.member "serviceType" xml)
                  ServiceTypeDetailSet.parse));
          service_id =
            (Util.option_bind (Xml.member "serviceId" xml) String.parse);
          service_name =
            (Util.option_bind (Xml.member "serviceName" xml) String.parse);
          service_state =
            (Util.option_bind (Xml.member "serviceState" xml)
               ServiceState.parse);
          availability_zones =
            (Util.of_option []
               (Util.option_bind (Xml.member "availabilityZoneSet" xml)
                  ValueStringList.parse));
          acceptance_required =
            (Util.option_bind (Xml.member "acceptanceRequired" xml)
               Boolean.parse);
          manages_vpc_endpoints =
            (Util.option_bind (Xml.member "managesVpcEndpoints" xml)
               Boolean.parse);
          network_load_balancer_arns =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkLoadBalancerArnSet" xml)
                  ValueStringList.parse));
          base_endpoint_dns_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "baseEndpointDnsNameSet" xml)
                  ValueStringList.parse));
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     (List.map
                        (fun x ->
                           Some
                             (Ezxmlm.make_tag "serviceType"
                                ([], (ServiceTypeDetailSet.to_xml [x]))))
                        v.service_type))
                    @
                    [Util.option_map v.service_id
                       (fun f ->
                          Ezxmlm.make_tag "serviceId" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.service_name
                      (fun f ->
                         Ezxmlm.make_tag "serviceName"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.service_state
                     (fun f ->
                        Ezxmlm.make_tag "serviceState"
                          ([], (ServiceState.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "availabilityZoneSet"
                            ([], (ValueStringList.to_xml [x]))))
                    v.availability_zones))
                @
                [Util.option_map v.acceptance_required
                   (fun f ->
                      Ezxmlm.make_tag "acceptanceRequired"
                        ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.manages_vpc_endpoints
                  (fun f ->
                     Ezxmlm.make_tag "managesVpcEndpoints"
                       ([], (Boolean.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "networkLoadBalancerArnSet"
                         ([], (ValueStringList.to_xml [x]))))
                 v.network_load_balancer_arns))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "baseEndpointDnsNameSet"
                        ([], (ValueStringList.to_xml [x]))))
                v.base_endpoint_dns_names))
            @
            [Util.option_map v.private_dns_name
               (fun f ->
                  Ezxmlm.make_tag "privateDnsName" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc
       "<p>Describes a service configuration for a VPC endpoint service.</p>"]
module ConversionTask =
  struct
    type t =
      {
      conversion_task_id: String.t option
        [@ocaml.doc "<p>The ID of the conversion task.</p>"];
      expiration_time: String.t option
        [@ocaml.doc
          "<p>The time when the task expires. If the upload isn't complete before the expiration time, we automatically cancel the task.</p>"];
      import_instance: ImportInstanceTaskDetails.t option
        [@ocaml.doc
          "<p>If the task is for importing an instance, this contains information about the import instance task.</p>"];
      import_volume: ImportVolumeTaskDetails.t option
        [@ocaml.doc
          "<p>If the task is for importing a volume, this contains information about the import volume task.</p>"];
      state: ConversionTaskState.t option
        [@ocaml.doc "<p>The state of the conversion task.</p>"];
      status_message: String.t option
        [@ocaml.doc
          "<p>The status message related to the conversion task.</p>"];
      tags: TagList.t [@ocaml.doc "<p>Any tags assigned to the task.</p>"]}
    [@@ocaml.doc "<p>Describes a conversion task.</p>"]
    let make ?conversion_task_id  ?expiration_time  ?import_instance 
      ?import_volume  ?state  ?status_message  ?(tags= [])  () =
      {
        conversion_task_id;
        expiration_time;
        import_instance;
        import_volume;
        state;
        status_message;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (ConversionTaskState.to_query f)));
           Util.option_map v.import_volume
             (fun f ->
                Query.Pair
                  ("ImportVolume", (ImportVolumeTaskDetails.to_query f)));
           Util.option_map v.import_instance
             (fun f ->
                Query.Pair
                  ("ImportInstance", (ImportInstanceTaskDetails.to_query f)));
           Util.option_map v.expiration_time
             (fun f -> Query.Pair ("ExpirationTime", (String.to_query f)));
           Util.option_map v.conversion_task_id
             (fun f -> Query.Pair ("ConversionTaskId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (ConversionTaskState.to_json f)));
           Util.option_map v.import_volume
             (fun f -> ("import_volume", (ImportVolumeTaskDetails.to_json f)));
           Util.option_map v.import_instance
             (fun f ->
                ("import_instance", (ImportInstanceTaskDetails.to_json f)));
           Util.option_map v.expiration_time
             (fun f -> ("expiration_time", (String.to_json f)));
           Util.option_map v.conversion_task_id
             (fun f -> ("conversion_task_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          conversion_task_id =
            (Util.option_bind (Xml.member "conversionTaskId" xml)
               String.parse);
          expiration_time =
            (Util.option_bind (Xml.member "expirationTime" xml) String.parse);
          import_instance =
            (Util.option_bind (Xml.member "importInstance" xml)
               ImportInstanceTaskDetails.parse);
          import_volume =
            (Util.option_bind (Xml.member "importVolume" xml)
               ImportVolumeTaskDetails.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               ConversionTaskState.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.conversion_task_id
                    (fun f ->
                       Ezxmlm.make_tag "conversionTaskId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.expiration_time
                   (fun f ->
                      Ezxmlm.make_tag "expirationTime"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.import_instance
                  (fun f ->
                     Ezxmlm.make_tag "importInstance"
                       ([], (ImportInstanceTaskDetails.to_xml f)))])
              @
              [Util.option_map v.import_volume
                 (fun f ->
                    Ezxmlm.make_tag "importVolume"
                      ([], (ImportVolumeTaskDetails.to_xml f)))])
             @
             [Util.option_map v.state
                (fun f ->
                   Ezxmlm.make_tag "state"
                     ([], (ConversionTaskState.to_xml f)))])
            @
            [Util.option_map v.status_message
               (fun f ->
                  Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a conversion task.</p>"]
module TransitGatewayVpcAttachment =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option
        [@ocaml.doc "<p>The ID of the attachment.</p>"];
      transit_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway.</p>"];
      vpc_id: String.t option [@ocaml.doc "<p>The ID of the VPC.</p>"];
      vpc_owner_id: String.t option
        [@ocaml.doc "<p>The ID of the AWS account that owns the VPC.</p>"];
      state: TransitGatewayAttachmentState.t option
        [@ocaml.doc "<p>The state of the VPC attachment.</p>"];
      subnet_ids: ValueStringList.t
        [@ocaml.doc "<p>The IDs of the subnets.</p>"];
      creation_time: DateTime.t option
        [@ocaml.doc "<p>The creation time.</p>"];
      options: TransitGatewayVpcAttachmentOptions.t option
        [@ocaml.doc "<p>The VPC attachment options.</p>"];
      tags: TagList.t [@ocaml.doc "<p>The tags for the VPC attachment.</p>"]}
    [@@ocaml.doc "<p>Describes a VPC attachment.</p>"]
    let make ?transit_gateway_attachment_id  ?transit_gateway_id  ?vpc_id 
      ?vpc_owner_id  ?state  ?(subnet_ids= [])  ?creation_time  ?options 
      ?(tags= [])  () =
      {
        transit_gateway_attachment_id;
        transit_gateway_id;
        vpc_id;
        vpc_owner_id;
        state;
        subnet_ids;
        creation_time;
        options;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.options
             (fun f ->
                Query.Pair
                  ("Options",
                    (TransitGatewayVpcAttachmentOptions.to_query f)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("SubnetIds", (ValueStringList.to_query v.subnet_ids)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (TransitGatewayAttachmentState.to_query f)));
           Util.option_map v.vpc_owner_id
             (fun f -> Query.Pair ("VpcOwnerId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.options
             (fun f ->
                ("options", (TransitGatewayVpcAttachmentOptions.to_json f)));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Some ("subnet_ids", (ValueStringList.to_json v.subnet_ids));
           Util.option_map v.state
             (fun f -> ("state", (TransitGatewayAttachmentState.to_json f)));
           Util.option_map v.vpc_owner_id
             (fun f -> ("vpc_owner_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          vpc_owner_id =
            (Util.option_bind (Xml.member "vpcOwnerId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAttachmentState.parse);
          subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "subnetIds" xml)
                  ValueStringList.parse));
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          options =
            (Util.option_bind (Xml.member "options" xml)
               TransitGatewayVpcAttachmentOptions.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.transit_gateway_attachment_id
                      (fun f ->
                         Ezxmlm.make_tag "transitGatewayAttachmentId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.transit_gateway_id
                     (fun f ->
                        Ezxmlm.make_tag "transitGatewayId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.vpc_id
                    (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.vpc_owner_id
                   (fun f ->
                      Ezxmlm.make_tag "vpcOwnerId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.state
                  (fun f ->
                     Ezxmlm.make_tag "state"
                       ([], (TransitGatewayAttachmentState.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "subnetIds"
                         ([], (ValueStringList.to_xml [x])))) v.subnet_ids))
             @
             [Util.option_map v.creation_time
                (fun f ->
                   Ezxmlm.make_tag "creationTime" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.options
               (fun f ->
                  Ezxmlm.make_tag "options"
                    ([], (TransitGatewayVpcAttachmentOptions.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a VPC attachment.</p>"]
module ReservedInstanceReservationValue =
  struct
    type t =
      {
      reservation_value: ReservationValue.t option
        [@ocaml.doc
          "<p>The total value of the Convertible Reserved Instance that you are exchanging.</p>"];
      reserved_instance_id: String.t option
        [@ocaml.doc
          "<p>The ID of the Convertible Reserved Instance that you are exchanging.</p>"]}
    [@@ocaml.doc
      "<p>The total value of the Convertible Reserved Instance.</p>"]
    let make ?reservation_value  ?reserved_instance_id  () =
      { reservation_value; reserved_instance_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instance_id
              (fun f ->
                 Query.Pair ("ReservedInstanceId", (String.to_query f)));
           Util.option_map v.reservation_value
             (fun f ->
                Query.Pair
                  ("ReservationValue", (ReservationValue.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instance_id
              (fun f -> ("reserved_instance_id", (String.to_json f)));
           Util.option_map v.reservation_value
             (fun f -> ("reservation_value", (ReservationValue.to_json f)))])
    let parse xml =
      Some
        {
          reservation_value =
            (Util.option_bind (Xml.member "reservationValue" xml)
               ReservationValue.parse);
          reserved_instance_id =
            (Util.option_bind (Xml.member "reservedInstanceId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.reservation_value
               (fun f ->
                  Ezxmlm.make_tag "reservationValue"
                    ([], (ReservationValue.to_xml f)))])
           @
           [Util.option_map v.reserved_instance_id
              (fun f ->
                 Ezxmlm.make_tag "reservedInstanceId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>The total value of the Convertible Reserved Instance.</p>"]
module TargetReservationValue =
  struct
    type t =
      {
      reservation_value: ReservationValue.t option
        [@ocaml.doc
          "<p>The total value of the Convertible Reserved Instances that make up the exchange. This is the sum of the list value, remaining upfront price, and additional upfront cost of the exchange.</p>"];
      target_configuration: TargetConfiguration.t option
        [@ocaml.doc
          "<p>The configuration of the Convertible Reserved Instances that make up the exchange.</p>"]}
    [@@ocaml.doc
      "<p>The total value of the new Convertible Reserved Instances.</p>"]
    let make ?reservation_value  ?target_configuration  () =
      { reservation_value; target_configuration }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.target_configuration
              (fun f ->
                 Query.Pair
                   ("TargetConfiguration", (TargetConfiguration.to_query f)));
           Util.option_map v.reservation_value
             (fun f ->
                Query.Pair
                  ("ReservationValue", (ReservationValue.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_configuration
              (fun f ->
                 ("target_configuration", (TargetConfiguration.to_json f)));
           Util.option_map v.reservation_value
             (fun f -> ("reservation_value", (ReservationValue.to_json f)))])
    let parse xml =
      Some
        {
          reservation_value =
            (Util.option_bind (Xml.member "reservationValue" xml)
               ReservationValue.parse);
          target_configuration =
            (Util.option_bind (Xml.member "targetConfiguration" xml)
               TargetConfiguration.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.reservation_value
               (fun f ->
                  Ezxmlm.make_tag "reservationValue"
                    ([], (ReservationValue.to_xml f)))])
           @
           [Util.option_map v.target_configuration
              (fun f ->
                 Ezxmlm.make_tag "targetConfiguration"
                   ([], (TargetConfiguration.to_xml f)))])
  end[@@ocaml.doc
       "<p>The total value of the new Convertible Reserved Instances.</p>"]
module TransitGatewayRoute =
  struct
    type t =
      {
      destination_cidr_block: String.t option
        [@ocaml.doc "<p>The CIDR block used for destination matches.</p>"];
      transit_gateway_attachments: TransitGatewayRouteAttachmentList.t
        [@ocaml.doc "<p>The attachments.</p>"];
      type_: TransitGatewayRouteType.t option
        [@ocaml.doc "<p>The route type.</p>"];
      state: TransitGatewayRouteState.t option
        [@ocaml.doc "<p>The state of the route.</p>"]}[@@ocaml.doc
                                                        "<p>Describes a route for a transit gateway route table.</p>"]
    let make ?destination_cidr_block  ?(transit_gateway_attachments= []) 
      ?type_  ?state  () =
      { destination_cidr_block; transit_gateway_attachments; type_; state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair ("State", (TransitGatewayRouteState.to_query f)));
           Util.option_map v.type_
             (fun f ->
                Query.Pair ("Type", (TransitGatewayRouteType.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachments",
                  (TransitGatewayRouteAttachmentList.to_query
                     v.transit_gateway_attachments)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayRouteState.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (TransitGatewayRouteType.to_json f)));
           Some
             ("transit_gateway_attachments",
               (TransitGatewayRouteAttachmentList.to_json
                  v.transit_gateway_attachments));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          transit_gateway_attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "transitGatewayAttachments" xml)
                  TransitGatewayRouteAttachmentList.parse));
          type_ =
            (Util.option_bind (Xml.member "type" xml)
               TransitGatewayRouteType.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayRouteState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.destination_cidr_block
                 (fun f ->
                    Ezxmlm.make_tag "destinationCidrBlock"
                      ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "transitGatewayAttachments"
                        ([], (TransitGatewayRouteAttachmentList.to_xml [x]))))
                v.transit_gateway_attachments))
            @
            [Util.option_map v.type_
               (fun f ->
                  Ezxmlm.make_tag "type"
                    ([], (TransitGatewayRouteType.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (TransitGatewayRouteState.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a route for a transit gateway route table.</p>"]
module HistoryRecord =
  struct
    type t =
      {
      event_information: EventInformation.t option
        [@ocaml.doc "<p>Information about the event.</p>"];
      event_type: EventType.t option
        [@ocaml.doc
          "<p>The event type.</p> <ul> <li> <p> <code>error</code> - An error with the Spot Fleet request.</p> </li> <li> <p> <code>fleetRequestChange</code> - A change in the status or configuration of the Spot Fleet request.</p> </li> <li> <p> <code>instanceChange</code> - An instance was launched or terminated.</p> </li> <li> <p> <code>Information</code> - An informational event.</p> </li> </ul>"];
      timestamp: DateTime.t option
        [@ocaml.doc
          "<p>The date and time of the event, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>"]}
    [@@ocaml.doc
      "<p>Describes an event in the history of the Spot Fleet request.</p>"]
    let make ?event_information  ?event_type  ?timestamp  () =
      { event_information; event_type; timestamp }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.event_type
             (fun f -> Query.Pair ("EventType", (EventType.to_query f)));
           Util.option_map v.event_information
             (fun f ->
                Query.Pair
                  ("EventInformation", (EventInformation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.event_type
             (fun f -> ("event_type", (EventType.to_json f)));
           Util.option_map v.event_information
             (fun f -> ("event_information", (EventInformation.to_json f)))])
    let parse xml =
      Some
        {
          event_information =
            (Util.option_bind (Xml.member "eventInformation" xml)
               EventInformation.parse);
          event_type =
            (Util.option_bind (Xml.member "eventType" xml) EventType.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.event_information
                (fun f ->
                   Ezxmlm.make_tag "eventInformation"
                     ([], (EventInformation.to_xml f)))])
            @
            [Util.option_map v.event_type
               (fun f ->
                  Ezxmlm.make_tag "eventType" ([], (EventType.to_xml f)))])
           @
           [Util.option_map v.timestamp
              (fun f -> Ezxmlm.make_tag "timestamp" ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an event in the history of the Spot Fleet request.</p>"]
module FpgaImage =
  struct
    type t =
      {
      fpga_image_id: String.t option
        [@ocaml.doc "<p>The FPGA image identifier (AFI ID).</p>"];
      fpga_image_global_id: String.t option
        [@ocaml.doc "<p>The global FPGA image identifier (AGFI ID).</p>"];
      name: String.t option [@ocaml.doc "<p>The name of the AFI.</p>"];
      description: String.t option
        [@ocaml.doc "<p>The description of the AFI.</p>"];
      shell_version: String.t option
        [@ocaml.doc
          "<p>The version of the AWS Shell that was used to create the bitstream.</p>"];
      pci_id: PciId.t option
        [@ocaml.doc "<p>Information about the PCI bus.</p>"];
      state: FpgaImageState.t option
        [@ocaml.doc "<p>Information about the state of the AFI.</p>"];
      create_time: DateTime.t option
        [@ocaml.doc "<p>The date and time the AFI was created.</p>"];
      update_time: DateTime.t option
        [@ocaml.doc "<p>The time of the most recent update to the AFI.</p>"];
      owner_id: String.t option
        [@ocaml.doc "<p>The AWS account ID of the AFI owner.</p>"];
      owner_alias: String.t option
        [@ocaml.doc
          "<p>The alias of the AFI owner. Possible values include <code>self</code>, <code>amazon</code>, and <code>aws-marketplace</code>.</p>"];
      product_codes: ProductCodeList.t
        [@ocaml.doc "<p>The product codes for the AFI.</p>"];
      tags: TagList.t [@ocaml.doc "<p>Any tags assigned to the AFI.</p>"];
      public: Boolean.t option
        [@ocaml.doc "<p>Indicates whether the AFI is public.</p>"];
      data_retention_support: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether data retention support is enabled for the AFI.</p>"]}
    [@@ocaml.doc "<p>Describes an Amazon FPGA image (AFI).</p>"]
    let make ?fpga_image_id  ?fpga_image_global_id  ?name  ?description 
      ?shell_version  ?pci_id  ?state  ?create_time  ?update_time  ?owner_id 
      ?owner_alias  ?(product_codes= [])  ?(tags= [])  ?public 
      ?data_retention_support  () =
      {
        fpga_image_id;
        fpga_image_global_id;
        name;
        description;
        shell_version;
        pci_id;
        state;
        create_time;
        update_time;
        owner_id;
        owner_alias;
        product_codes;
        tags;
        public;
        data_retention_support
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.data_retention_support
              (fun f ->
                 Query.Pair ("DataRetentionSupport", (Boolean.to_query f)));
           Util.option_map v.public
             (fun f -> Query.Pair ("Public", (Boolean.to_query f)));
           Some (Query.Pair ("Tags", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Util.option_map v.owner_alias
             (fun f -> Query.Pair ("OwnerAlias", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.update_time
             (fun f -> Query.Pair ("UpdateTime", (DateTime.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (FpgaImageState.to_query f)));
           Util.option_map v.pci_id
             (fun f -> Query.Pair ("PciId", (PciId.to_query f)));
           Util.option_map v.shell_version
             (fun f -> Query.Pair ("ShellVersion", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.fpga_image_global_id
             (fun f -> Query.Pair ("FpgaImageGlobalId", (String.to_query f)));
           Util.option_map v.fpga_image_id
             (fun f -> Query.Pair ("FpgaImageId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.data_retention_support
              (fun f -> ("data_retention_support", (Boolean.to_json f)));
           Util.option_map v.public
             (fun f -> ("public", (Boolean.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Util.option_map v.owner_alias
             (fun f -> ("owner_alias", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.update_time
             (fun f -> ("update_time", (DateTime.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (FpgaImageState.to_json f)));
           Util.option_map v.pci_id (fun f -> ("pci_id", (PciId.to_json f)));
           Util.option_map v.shell_version
             (fun f -> ("shell_version", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.fpga_image_global_id
             (fun f -> ("fpga_image_global_id", (String.to_json f)));
           Util.option_map v.fpga_image_id
             (fun f -> ("fpga_image_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          fpga_image_id =
            (Util.option_bind (Xml.member "fpgaImageId" xml) String.parse);
          fpga_image_global_id =
            (Util.option_bind (Xml.member "fpgaImageGlobalId" xml)
               String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          shell_version =
            (Util.option_bind (Xml.member "shellVersion" xml) String.parse);
          pci_id = (Util.option_bind (Xml.member "pciId" xml) PciId.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) FpgaImageState.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          update_time =
            (Util.option_bind (Xml.member "updateTime" xml) DateTime.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          owner_alias =
            (Util.option_bind (Xml.member "ownerAlias" xml) String.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tags" xml) TagList.parse));
          public = (Util.option_bind (Xml.member "public" xml) Boolean.parse);
          data_retention_support =
            (Util.option_bind (Xml.member "dataRetentionSupport" xml)
               Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Util.option_map v.fpga_image_id
                            (fun f ->
                               Ezxmlm.make_tag "fpgaImageId"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.fpga_image_global_id
                           (fun f ->
                              Ezxmlm.make_tag "fpgaImageGlobalId"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.name
                          (fun f ->
                             Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.description
                         (fun f ->
                            Ezxmlm.make_tag "description"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.shell_version
                        (fun f ->
                           Ezxmlm.make_tag "shellVersion"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.pci_id
                       (fun f ->
                          Ezxmlm.make_tag "pciId" ([], (PciId.to_xml f)))])
                   @
                   [Util.option_map v.state
                      (fun f ->
                         Ezxmlm.make_tag "state"
                           ([], (FpgaImageState.to_xml f)))])
                  @
                  [Util.option_map v.create_time
                     (fun f ->
                        Ezxmlm.make_tag "createTime"
                          ([], (DateTime.to_xml f)))])
                 @
                 [Util.option_map v.update_time
                    (fun f ->
                       Ezxmlm.make_tag "updateTime" ([], (DateTime.to_xml f)))])
                @
                [Util.option_map v.owner_id
                   (fun f ->
                      Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.owner_alias
                  (fun f ->
                     Ezxmlm.make_tag "ownerAlias" ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "productCodes"
                         ([], (ProductCodeList.to_xml [x])))) v.product_codes))
             @
             (List.map
                (fun x ->
                   Some (Ezxmlm.make_tag "tags" ([], (TagList.to_xml [x]))))
                v.tags))
            @
            [Util.option_map v.public
               (fun f -> Ezxmlm.make_tag "public" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.data_retention_support
              (fun f ->
                 Ezxmlm.make_tag "dataRetentionSupport"
                   ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an Amazon FPGA image (AFI).</p>"]
module EnableFastSnapshotRestoreErrorItem =
  struct
    type t =
      {
      snapshot_id: String.t option
        [@ocaml.doc "<p>The ID of the snapshot.</p>"];
      fast_snapshot_restore_state_errors:
        EnableFastSnapshotRestoreStateErrorSet.t
        [@ocaml.doc "<p>The errors.</p>"]}[@@ocaml.doc
                                            "<p>Contains information about the errors that occurred when enabling fast snapshot restores.</p>"]
    let make ?snapshot_id  ?(fast_snapshot_restore_state_errors= [])  () =
      { snapshot_id; fast_snapshot_restore_state_errors }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FastSnapshotRestoreStateErrorSet",
                   (EnableFastSnapshotRestoreStateErrorSet.to_query
                      v.fast_snapshot_restore_state_errors)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("fast_snapshot_restore_state_errors",
                (EnableFastSnapshotRestoreStateErrorSet.to_json
                   v.fast_snapshot_restore_state_errors));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          fast_snapshot_restore_state_errors =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "fastSnapshotRestoreStateErrorSet" xml)
                  EnableFastSnapshotRestoreStateErrorSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.snapshot_id
               (fun f -> Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "fastSnapshotRestoreStateErrorSet"
                      ([],
                        (EnableFastSnapshotRestoreStateErrorSet.to_xml [x]))))
              v.fast_snapshot_restore_state_errors))
  end[@@ocaml.doc
       "<p>Contains information about the errors that occurred when enabling fast snapshot restores.</p>"]
module EnableFastSnapshotRestoreSuccessItem =
  struct
    type t =
      {
      snapshot_id: String.t option
        [@ocaml.doc "<p>The ID of the snapshot.</p>"];
      availability_zone: String.t option
        [@ocaml.doc "<p>The Availability Zone.</p>"];
      state: FastSnapshotRestoreStateCode.t option
        [@ocaml.doc "<p>The state of fast snapshot restores.</p>"];
      state_transition_reason: String.t option
        [@ocaml.doc
          "<p>The reason for the state transition. The possible values are as follows:</p> <ul> <li> <p> <code>Client.UserInitiated</code> - The state successfully transitioned to <code>enabling</code> or <code>disabling</code>.</p> </li> <li> <p> <code>Client.UserInitiated - Lifecycle state transition</code> - The state successfully transitioned to <code>optimizing</code>, <code>enabled</code>, or <code>disabled</code>.</p> </li> </ul>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account that owns the snapshot.</p>"];
      owner_alias: String.t option
        [@ocaml.doc "<p>The alias of the snapshot owner.</p>"];
      enabling_time: DateTime.t option
        [@ocaml.doc
          "<p>The time at which fast snapshot restores entered the <code>enabling</code> state.</p>"];
      optimizing_time: DateTime.t option
        [@ocaml.doc
          "<p>The time at which fast snapshot restores entered the <code>optimizing</code> state.</p>"];
      enabled_time: DateTime.t option
        [@ocaml.doc
          "<p>The time at which fast snapshot restores entered the <code>enabled</code> state.</p>"];
      disabling_time: DateTime.t option
        [@ocaml.doc
          "<p>The time at which fast snapshot restores entered the <code>disabling</code> state.</p>"];
      disabled_time: DateTime.t option
        [@ocaml.doc
          "<p>The time at which fast snapshot restores entered the <code>disabled</code> state.</p>"]}
    [@@ocaml.doc
      "<p>Describes fast snapshot restores that were successfully enabled.</p>"]
    let make ?snapshot_id  ?availability_zone  ?state 
      ?state_transition_reason  ?owner_id  ?owner_alias  ?enabling_time 
      ?optimizing_time  ?enabled_time  ?disabling_time  ?disabled_time  () =
      {
        snapshot_id;
        availability_zone;
        state;
        state_transition_reason;
        owner_id;
        owner_alias;
        enabling_time;
        optimizing_time;
        enabled_time;
        disabling_time;
        disabled_time
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> Query.Pair ("DisabledTime", (DateTime.to_query f)));
           Util.option_map v.disabling_time
             (fun f -> Query.Pair ("DisablingTime", (DateTime.to_query f)));
           Util.option_map v.enabled_time
             (fun f -> Query.Pair ("EnabledTime", (DateTime.to_query f)));
           Util.option_map v.optimizing_time
             (fun f -> Query.Pair ("OptimizingTime", (DateTime.to_query f)));
           Util.option_map v.enabling_time
             (fun f -> Query.Pair ("EnablingTime", (DateTime.to_query f)));
           Util.option_map v.owner_alias
             (fun f -> Query.Pair ("OwnerAlias", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.state_transition_reason
             (fun f ->
                Query.Pair ("StateTransitionReason", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (FastSnapshotRestoreStateCode.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> ("disabled_time", (DateTime.to_json f)));
           Util.option_map v.disabling_time
             (fun f -> ("disabling_time", (DateTime.to_json f)));
           Util.option_map v.enabled_time
             (fun f -> ("enabled_time", (DateTime.to_json f)));
           Util.option_map v.optimizing_time
             (fun f -> ("optimizing_time", (DateTime.to_json f)));
           Util.option_map v.enabling_time
             (fun f -> ("enabling_time", (DateTime.to_json f)));
           Util.option_map v.owner_alias
             (fun f -> ("owner_alias", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.state_transition_reason
             (fun f -> ("state_transition_reason", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (FastSnapshotRestoreStateCode.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               FastSnapshotRestoreStateCode.parse);
          state_transition_reason =
            (Util.option_bind (Xml.member "stateTransitionReason" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          owner_alias =
            (Util.option_bind (Xml.member "ownerAlias" xml) String.parse);
          enabling_time =
            (Util.option_bind (Xml.member "enablingTime" xml) DateTime.parse);
          optimizing_time =
            (Util.option_bind (Xml.member "optimizingTime" xml)
               DateTime.parse);
          enabled_time =
            (Util.option_bind (Xml.member "enabledTime" xml) DateTime.parse);
          disabling_time =
            (Util.option_bind (Xml.member "disablingTime" xml) DateTime.parse);
          disabled_time =
            (Util.option_bind (Xml.member "disabledTime" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.snapshot_id
                        (fun f ->
                           Ezxmlm.make_tag "snapshotId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.availability_zone
                       (fun f ->
                          Ezxmlm.make_tag "availabilityZone"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.state
                      (fun f ->
                         Ezxmlm.make_tag "state"
                           ([], (FastSnapshotRestoreStateCode.to_xml f)))])
                  @
                  [Util.option_map v.state_transition_reason
                     (fun f ->
                        Ezxmlm.make_tag "stateTransitionReason"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.owner_id
                    (fun f ->
                       Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.owner_alias
                   (fun f ->
                      Ezxmlm.make_tag "ownerAlias" ([], (String.to_xml f)))])
               @
               [Util.option_map v.enabling_time
                  (fun f ->
                     Ezxmlm.make_tag "enablingTime" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.optimizing_time
                 (fun f ->
                    Ezxmlm.make_tag "optimizingTime"
                      ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.enabled_time
                (fun f ->
                   Ezxmlm.make_tag "enabledTime" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.disabling_time
               (fun f ->
                  Ezxmlm.make_tag "disablingTime" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.disabled_time
              (fun f ->
                 Ezxmlm.make_tag "disabledTime" ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes fast snapshot restores that were successfully enabled.</p>"]
module RouteTable =
  struct
    type t =
      {
      associations: RouteTableAssociationList.t
        [@ocaml.doc
          "<p>The associations between the route table and one or more subnets or a gateway.</p>"];
      propagating_vgws: PropagatingVgwList.t
        [@ocaml.doc
          "<p>Any virtual private gateway (VGW) propagating routes.</p>"];
      route_table_id: String.t option
        [@ocaml.doc "<p>The ID of the route table.</p>"];
      routes: RouteList.t
        [@ocaml.doc "<p>The routes in the route table.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the route table.</p>"];
      vpc_id: String.t option [@ocaml.doc "<p>The ID of the VPC.</p>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account that owns the route table.</p>"]}
    [@@ocaml.doc "<p>Describes a route table.</p>"]
    let make ?(associations= [])  ?(propagating_vgws= [])  ?route_table_id 
      ?(routes= [])  ?(tags= [])  ?vpc_id  ?owner_id  () =
      {
        associations;
        propagating_vgws;
        route_table_id;
        routes;
        tags;
        vpc_id;
        owner_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some (Query.Pair ("RouteSet", (RouteList.to_query v.routes)));
           Util.option_map v.route_table_id
             (fun f -> Query.Pair ("RouteTableId", (String.to_query f)));
           Some
             (Query.Pair
                ("PropagatingVgwSet",
                  (PropagatingVgwList.to_query v.propagating_vgws)));
           Some
             (Query.Pair
                ("AssociationSet",
                  (RouteTableAssociationList.to_query v.associations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Some ("routes", (RouteList.to_json v.routes));
           Util.option_map v.route_table_id
             (fun f -> ("route_table_id", (String.to_json f)));
           Some
             ("propagating_vgws",
               (PropagatingVgwList.to_json v.propagating_vgws));
           Some
             ("associations",
               (RouteTableAssociationList.to_json v.associations))])
    let parse xml =
      Some
        {
          associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "associationSet" xml)
                  RouteTableAssociationList.parse));
          propagating_vgws =
            (Util.of_option []
               (Util.option_bind (Xml.member "propagatingVgwSet" xml)
                  PropagatingVgwList.parse));
          route_table_id =
            (Util.option_bind (Xml.member "routeTableId" xml) String.parse);
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeSet" xml) RouteList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "associationSet"
                            ([], (RouteTableAssociationList.to_xml [x]))))
                    v.associations))
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "propagatingVgwSet"
                           ([], (PropagatingVgwList.to_xml [x]))))
                   v.propagating_vgws))
               @
               [Util.option_map v.route_table_id
                  (fun f ->
                     Ezxmlm.make_tag "routeTableId" ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "routeSet"
                         ([], (RouteList.to_xml [x])))) v.routes))
             @
             (List.map
                (fun x ->
                   Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
                v.tags))
            @
            [Util.option_map v.vpc_id
               (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.owner_id
              (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a route table.</p>"]
module IamInstanceProfileAssociation =
  struct
    type t =
      {
      association_id: String.t option
        [@ocaml.doc "<p>The ID of the association.</p>"];
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"];
      iam_instance_profile: IamInstanceProfile.t option
        [@ocaml.doc "<p>The IAM instance profile.</p>"];
      state: IamInstanceProfileAssociationState.t option
        [@ocaml.doc "<p>The state of the association.</p>"];
      timestamp: DateTime.t option
        [@ocaml.doc
          "<p>The time the IAM instance profile was associated with the instance.</p>"]}
    [@@ocaml.doc
      "<p>Describes an association between an IAM instance profile and an instance.</p>"]
    let make ?association_id  ?instance_id  ?iam_instance_profile  ?state 
      ?timestamp  () =
      { association_id; instance_id; iam_instance_profile; state; timestamp }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (IamInstanceProfileAssociationState.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile", (IamInstanceProfile.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f ->
                ("state", (IamInstanceProfileAssociationState.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile", (IamInstanceProfile.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfile.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               IamInstanceProfileAssociationState.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.association_id
                  (fun f ->
                     Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.instance_id
                 (fun f ->
                    Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.iam_instance_profile
                (fun f ->
                   Ezxmlm.make_tag "iamInstanceProfile"
                     ([], (IamInstanceProfile.to_xml f)))])
            @
            [Util.option_map v.state
               (fun f ->
                  Ezxmlm.make_tag "state"
                    ([], (IamInstanceProfileAssociationState.to_xml f)))])
           @
           [Util.option_map v.timestamp
              (fun f -> Ezxmlm.make_tag "timestamp" ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an association between an IAM instance profile and an instance.</p>"]
module LaunchTemplateVersion =
  struct
    type t =
      {
      launch_template_id: String.t option
        [@ocaml.doc "<p>The ID of the launch template.</p>"];
      launch_template_name: String.t option
        [@ocaml.doc "<p>The name of the launch template.</p>"];
      version_number: Long.t option [@ocaml.doc "<p>The version number.</p>"];
      version_description: String.t option
        [@ocaml.doc "<p>The description for the version.</p>"];
      create_time: DateTime.t option
        [@ocaml.doc "<p>The time the version was created.</p>"];
      created_by: String.t option
        [@ocaml.doc "<p>The principal that created the version.</p>"];
      default_version: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the version is the default version.</p>"];
      launch_template_data: ResponseLaunchTemplateData.t option
        [@ocaml.doc "<p>Information about the launch template.</p>"]}
    [@@ocaml.doc "<p>Describes a launch template version.</p>"]
    let make ?launch_template_id  ?launch_template_name  ?version_number 
      ?version_description  ?create_time  ?created_by  ?default_version 
      ?launch_template_data  () =
      {
        launch_template_id;
        launch_template_name;
        version_number;
        version_description;
        create_time;
        created_by;
        default_version;
        launch_template_data
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template_data
              (fun f ->
                 Query.Pair
                   ("LaunchTemplateData",
                     (ResponseLaunchTemplateData.to_query f)));
           Util.option_map v.default_version
             (fun f -> Query.Pair ("DefaultVersion", (Boolean.to_query f)));
           Util.option_map v.created_by
             (fun f -> Query.Pair ("CreatedBy", (String.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.version_description
             (fun f -> Query.Pair ("VersionDescription", (String.to_query f)));
           Util.option_map v.version_number
             (fun f -> Query.Pair ("VersionNumber", (Long.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template_data
              (fun f ->
                 ("launch_template_data",
                   (ResponseLaunchTemplateData.to_json f)));
           Util.option_map v.default_version
             (fun f -> ("default_version", (Boolean.to_json f)));
           Util.option_map v.created_by
             (fun f -> ("created_by", (String.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.version_description
             (fun f -> ("version_description", (String.to_json f)));
           Util.option_map v.version_number
             (fun f -> ("version_number", (Long.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "launchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "launchTemplateName" xml)
               String.parse);
          version_number =
            (Util.option_bind (Xml.member "versionNumber" xml) Long.parse);
          version_description =
            (Util.option_bind (Xml.member "versionDescription" xml)
               String.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          created_by =
            (Util.option_bind (Xml.member "createdBy" xml) String.parse);
          default_version =
            (Util.option_bind (Xml.member "defaultVersion" xml) Boolean.parse);
          launch_template_data =
            (Util.option_bind (Xml.member "launchTemplateData" xml)
               ResponseLaunchTemplateData.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.launch_template_id
                     (fun f ->
                        Ezxmlm.make_tag "launchTemplateId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.launch_template_name
                    (fun f ->
                       Ezxmlm.make_tag "launchTemplateName"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.version_number
                   (fun f ->
                      Ezxmlm.make_tag "versionNumber" ([], (Long.to_xml f)))])
               @
               [Util.option_map v.version_description
                  (fun f ->
                     Ezxmlm.make_tag "versionDescription"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.create_time
                 (fun f ->
                    Ezxmlm.make_tag "createTime" ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.created_by
                (fun f -> Ezxmlm.make_tag "createdBy" ([], (String.to_xml f)))])
            @
            [Util.option_map v.default_version
               (fun f ->
                  Ezxmlm.make_tag "defaultVersion" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.launch_template_data
              (fun f ->
                 Ezxmlm.make_tag "launchTemplateData"
                   ([], (ResponseLaunchTemplateData.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a launch template version.</p>"]
module TransitGatewayMulticastGroup =
  struct
    type t =
      {
      group_ip_address: String.t option
        [@ocaml.doc
          "<p>The IP address assigned to the transit gateway multicast group.</p>"];
      transit_gateway_attachment_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway attachment.</p>"];
      subnet_id: String.t option [@ocaml.doc "<p>The ID of the subnet.</p>"];
      resource_id: String.t option
        [@ocaml.doc "<p>The ID of the resource.</p>"];
      resource_type: TransitGatewayAttachmentResourceType.t option
        [@ocaml.doc
          "<p>The type of resource, for example a VPC attachment.</p>"];
      network_interface_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway attachment.</p>"];
      group_member: Boolean.t option
        [@ocaml.doc
          "<p>Indicates that the resource is a transit gateway multicast group member.</p>"];
      group_source: Boolean.t option
        [@ocaml.doc
          "<p>Indicates that the resource is a transit gateway multicast group member.</p>"];
      member_type: MembershipType.t option
        [@ocaml.doc
          "<p>The member type (for example, <code>static</code>).</p>"];
      source_type: MembershipType.t option
        [@ocaml.doc "<p>The source type.</p>"]}[@@ocaml.doc
                                                 "<p>Describes the transit gateway multicast group resources.</p>"]
    let make ?group_ip_address  ?transit_gateway_attachment_id  ?subnet_id 
      ?resource_id  ?resource_type  ?network_interface_id  ?group_member 
      ?group_source  ?member_type  ?source_type  () =
      {
        group_ip_address;
        transit_gateway_attachment_id;
        subnet_id;
        resource_id;
        resource_type;
        network_interface_id;
        group_member;
        group_source;
        member_type;
        source_type
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.source_type
              (fun f ->
                 Query.Pair ("SourceType", (MembershipType.to_query f)));
           Util.option_map v.member_type
             (fun f -> Query.Pair ("MemberType", (MembershipType.to_query f)));
           Util.option_map v.group_source
             (fun f -> Query.Pair ("GroupSource", (Boolean.to_query f)));
           Util.option_map v.group_member
             (fun f -> Query.Pair ("GroupMember", (Boolean.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Util.option_map v.group_ip_address
             (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.source_type
              (fun f -> ("source_type", (MembershipType.to_json f)));
           Util.option_map v.member_type
             (fun f -> ("member_type", (MembershipType.to_json f)));
           Util.option_map v.group_source
             (fun f -> ("group_source", (Boolean.to_json f)));
           Util.option_map v.group_member
             (fun f -> ("group_member", (Boolean.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Util.option_map v.group_ip_address
             (fun f -> ("group_ip_address", (String.to_json f)))])
    let parse xml =
      Some
        {
          group_ip_address =
            (Util.option_bind (Xml.member "groupIpAddress" xml) String.parse);
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          group_member =
            (Util.option_bind (Xml.member "groupMember" xml) Boolean.parse);
          group_source =
            (Util.option_bind (Xml.member "groupSource" xml) Boolean.parse);
          member_type =
            (Util.option_bind (Xml.member "memberType" xml)
               MembershipType.parse);
          source_type =
            (Util.option_bind (Xml.member "sourceType" xml)
               MembershipType.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.group_ip_address
                       (fun f ->
                          Ezxmlm.make_tag "groupIpAddress"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.transit_gateway_attachment_id
                      (fun f ->
                         Ezxmlm.make_tag "transitGatewayAttachmentId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.subnet_id
                     (fun f ->
                        Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.resource_id
                    (fun f ->
                       Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.resource_type
                   (fun f ->
                      Ezxmlm.make_tag "resourceType"
                        ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
               @
               [Util.option_map v.network_interface_id
                  (fun f ->
                     Ezxmlm.make_tag "networkInterfaceId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.group_member
                 (fun f ->
                    Ezxmlm.make_tag "groupMember" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.group_source
                (fun f ->
                   Ezxmlm.make_tag "groupSource" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.member_type
               (fun f ->
                  Ezxmlm.make_tag "memberType"
                    ([], (MembershipType.to_xml f)))])
           @
           [Util.option_map v.source_type
              (fun f ->
                 Ezxmlm.make_tag "sourceType" ([], (MembershipType.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the transit gateway multicast group resources.</p>"]
module LocalGatewayVirtualInterface =
  struct
    type t =
      {
      local_gateway_virtual_interface_id: String.t option
        [@ocaml.doc "<p>The ID of the virtual interface.</p>"];
      local_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the local gateway.</p>"];
      vlan: Integer.t option [@ocaml.doc "<p>The ID of the VLAN.</p>"];
      local_address: String.t option [@ocaml.doc "<p>The local address.</p>"];
      peer_address: String.t option [@ocaml.doc "<p>The peer address.</p>"];
      local_bgp_asn: Integer.t option
        [@ocaml.doc
          "<p>The Border Gateway Protocol (BGP) Autonomous System Number (ASN) of the local gateway.</p>"];
      peer_bgp_asn: Integer.t option [@ocaml.doc "<p>The peer BGP ASN.</p>"]}
    [@@ocaml.doc "<p>Describes a local gateway virtual interface.</p>"]
    let make ?local_gateway_virtual_interface_id  ?local_gateway_id  ?vlan 
      ?local_address  ?peer_address  ?local_bgp_asn  ?peer_bgp_asn  () =
      {
        local_gateway_virtual_interface_id;
        local_gateway_id;
        vlan;
        local_address;
        peer_address;
        local_bgp_asn;
        peer_bgp_asn
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.peer_bgp_asn
              (fun f -> Query.Pair ("PeerBgpAsn", (Integer.to_query f)));
           Util.option_map v.local_bgp_asn
             (fun f -> Query.Pair ("LocalBgpAsn", (Integer.to_query f)));
           Util.option_map v.peer_address
             (fun f -> Query.Pair ("PeerAddress", (String.to_query f)));
           Util.option_map v.local_address
             (fun f -> Query.Pair ("LocalAddress", (String.to_query f)));
           Util.option_map v.vlan
             (fun f -> Query.Pair ("Vlan", (Integer.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.local_gateway_virtual_interface_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayVirtualInterfaceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.peer_bgp_asn
              (fun f -> ("peer_bgp_asn", (Integer.to_json f)));
           Util.option_map v.local_bgp_asn
             (fun f -> ("local_bgp_asn", (Integer.to_json f)));
           Util.option_map v.peer_address
             (fun f -> ("peer_address", (String.to_json f)));
           Util.option_map v.local_address
             (fun f -> ("local_address", (String.to_json f)));
           Util.option_map v.vlan (fun f -> ("vlan", (Integer.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.local_gateway_virtual_interface_id
             (fun f ->
                ("local_gateway_virtual_interface_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          local_gateway_virtual_interface_id =
            (Util.option_bind
               (Xml.member "localGatewayVirtualInterfaceId" xml) String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          vlan = (Util.option_bind (Xml.member "vlan" xml) Integer.parse);
          local_address =
            (Util.option_bind (Xml.member "localAddress" xml) String.parse);
          peer_address =
            (Util.option_bind (Xml.member "peerAddress" xml) String.parse);
          local_bgp_asn =
            (Util.option_bind (Xml.member "localBgpAsn" xml) Integer.parse);
          peer_bgp_asn =
            (Util.option_bind (Xml.member "peerBgpAsn" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.local_gateway_virtual_interface_id
                    (fun f ->
                       Ezxmlm.make_tag "localGatewayVirtualInterfaceId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.local_gateway_id
                   (fun f ->
                      Ezxmlm.make_tag "localGatewayId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.vlan
                  (fun f -> Ezxmlm.make_tag "vlan" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.local_address
                 (fun f ->
                    Ezxmlm.make_tag "localAddress" ([], (String.to_xml f)))])
             @
             [Util.option_map v.peer_address
                (fun f ->
                   Ezxmlm.make_tag "peerAddress" ([], (String.to_xml f)))])
            @
            [Util.option_map v.local_bgp_asn
               (fun f ->
                  Ezxmlm.make_tag "localBgpAsn" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.peer_bgp_asn
              (fun f -> Ezxmlm.make_tag "peerBgpAsn" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a local gateway virtual interface.</p>"]
module ElasticInferenceAccelerator =
  struct
    type t =
      {
      type_: String.t
        [@ocaml.doc
          "<p> The type of elastic inference accelerator. The possible values are <code>eia1.medium</code>, <code>eia1.large</code>, and <code>eia1.xlarge</code>. </p>"];
      count: Integer.t option
        [@ocaml.doc
          "<p> The number of elastic inference accelerators to attach to the instance. </p> <p>Default: 1</p>"]}
    [@@ocaml.doc "<p> Describes an elastic inference accelerator. </p>"]
    let make ~type_  ?count  () = { type_; count }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.count
              (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Some (Query.Pair ("Type", (String.to_query v.type_)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Some ("type_", (String.to_json v.type_))])
    let parse xml =
      Some
        {
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) String.parse));
          count = (Util.option_bind (Xml.member "Count" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Type" ([], (String.to_xml v.type_)))])
           @
           [Util.option_map v.count
              (fun f -> Ezxmlm.make_tag "Count" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc "<p> Describes an elastic inference accelerator. </p>"]
module SpotMarketOptions =
  struct
    type t =
      {
      max_price: String.t option
        [@ocaml.doc
          "<p>The maximum hourly price you're willing to pay for the Spot Instances. The default is the On-Demand price.</p>"];
      spot_instance_type: SpotInstanceType.t option
        [@ocaml.doc
          "<p>The Spot Instance request type. For <a>RunInstances</a>, persistent Spot Instance requests are only supported when <b>InstanceInterruptionBehavior</b> is set to either <code>hibernate</code> or <code>stop</code>.</p>"];
      block_duration_minutes: Integer.t option
        [@ocaml.doc
          "<p>The required duration for the Spot Instances (also known as Spot blocks), in minutes. This value must be a multiple of 60 (60, 120, 180, 240, 300, or 360).</p>"];
      valid_until: DateTime.t option
        [@ocaml.doc
          "<p>The end date of the request. For a one-time request, the request remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date and time is reached. The default end date is 7 days from the current date.</p>"];
      instance_interruption_behavior: InstanceInterruptionBehavior.t option
        [@ocaml.doc
          "<p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>"]}
    [@@ocaml.doc "<p>The options for Spot Instances.</p>"]
    let make ?max_price  ?spot_instance_type  ?block_duration_minutes 
      ?valid_until  ?instance_interruption_behavior  () =
      {
        max_price;
        spot_instance_type;
        block_duration_minutes;
        valid_until;
        instance_interruption_behavior
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Query.Pair
                   ("InstanceInterruptionBehavior",
                     (InstanceInterruptionBehavior.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.block_duration_minutes
             (fun f ->
                Query.Pair ("BlockDurationMinutes", (Integer.to_query f)));
           Util.option_map v.spot_instance_type
             (fun f ->
                Query.Pair
                  ("SpotInstanceType", (SpotInstanceType.to_query f)));
           Util.option_map v.max_price
             (fun f -> Query.Pair ("MaxPrice", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 ("instance_interruption_behavior",
                   (InstanceInterruptionBehavior.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.block_duration_minutes
             (fun f -> ("block_duration_minutes", (Integer.to_json f)));
           Util.option_map v.spot_instance_type
             (fun f -> ("spot_instance_type", (SpotInstanceType.to_json f)));
           Util.option_map v.max_price
             (fun f -> ("max_price", (String.to_json f)))])
    let parse xml =
      Some
        {
          max_price =
            (Util.option_bind (Xml.member "MaxPrice" xml) String.parse);
          spot_instance_type =
            (Util.option_bind (Xml.member "SpotInstanceType" xml)
               SpotInstanceType.parse);
          block_duration_minutes =
            (Util.option_bind (Xml.member "BlockDurationMinutes" xml)
               Integer.parse);
          valid_until =
            (Util.option_bind (Xml.member "ValidUntil" xml) DateTime.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "InstanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.max_price
                  (fun f ->
                     Ezxmlm.make_tag "MaxPrice" ([], (String.to_xml f)))])
              @
              [Util.option_map v.spot_instance_type
                 (fun f ->
                    Ezxmlm.make_tag "SpotInstanceType"
                      ([], (SpotInstanceType.to_xml f)))])
             @
             [Util.option_map v.block_duration_minutes
                (fun f ->
                   Ezxmlm.make_tag "BlockDurationMinutes"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.valid_until
               (fun f ->
                  Ezxmlm.make_tag "ValidUntil" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Ezxmlm.make_tag "InstanceInterruptionBehavior"
                   ([], (InstanceInterruptionBehavior.to_xml f)))])
  end[@@ocaml.doc "<p>The options for Spot Instances.</p>"]
module LicenseConfigurationRequest =
  struct
    type t =
      {
      license_configuration_arn: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the license configuration.</p>"]}
    [@@ocaml.doc "<p>Describes a license configuration.</p>"]
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "LicenseConfigurationArn" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Ezxmlm.make_tag "LicenseConfigurationArn"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a license configuration.</p>"]
module LocalGatewayVirtualInterfaceGroup =
  struct
    type t =
      {
      local_gateway_virtual_interface_group_id: String.t option
        [@ocaml.doc "<p>The ID of the virtual interface group.</p>"];
      local_gateway_virtual_interface_ids:
        LocalGatewayVirtualInterfaceIdSet.t
        [@ocaml.doc "<p>The IDs of the virtual interfaces.</p>"];
      local_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the local gateway.</p>"]}[@@ocaml.doc
                                                             "<p>Describes a local gateway virtual interface group.</p>"]
    let make ?local_gateway_virtual_interface_group_id 
      ?(local_gateway_virtual_interface_ids= [])  ?local_gateway_id  () =
      {
        local_gateway_virtual_interface_group_id;
        local_gateway_virtual_interface_ids;
        local_gateway_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_id
              (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayVirtualInterfaceIdSet",
                  (LocalGatewayVirtualInterfaceIdSet.to_query
                     v.local_gateway_virtual_interface_ids)));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayVirtualInterfaceGroupId",
                    (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_id
              (fun f -> ("local_gateway_id", (String.to_json f)));
           Some
             ("local_gateway_virtual_interface_ids",
               (LocalGatewayVirtualInterfaceIdSet.to_json
                  v.local_gateway_virtual_interface_ids));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                ("local_gateway_virtual_interface_group_id",
                  (String.to_json f)))])
    let parse xml =
      Some
        {
          local_gateway_virtual_interface_group_id =
            (Util.option_bind
               (Xml.member "localGatewayVirtualInterfaceGroupId" xml)
               String.parse);
          local_gateway_virtual_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "localGatewayVirtualInterfaceIdSet" xml)
                  LocalGatewayVirtualInterfaceIdSet.parse));
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.local_gateway_virtual_interface_group_id
                (fun f ->
                   Ezxmlm.make_tag "localGatewayVirtualInterfaceGroupId"
                     ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "localGatewayVirtualInterfaceIdSet"
                       ([], (LocalGatewayVirtualInterfaceIdSet.to_xml [x]))))
               v.local_gateway_virtual_interface_ids))
           @
           [Util.option_map v.local_gateway_id
              (fun f ->
                 Ezxmlm.make_tag "localGatewayId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a local gateway virtual interface group.</p>"]
module MovingAddressStatus =
  struct
    type t =
      {
      move_status: MoveStatus.t option
        [@ocaml.doc
          "<p>The status of the Elastic IP address that's being moved to the EC2-VPC platform, or restored to the EC2-Classic platform.</p>"];
      public_ip: String.t option
        [@ocaml.doc "<p>The Elastic IP address.</p>"]}[@@ocaml.doc
                                                        "<p>Describes the status of a moving Elastic IP address.</p>"]
    let make ?move_status  ?public_ip  () = { move_status; public_ip }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.move_status
             (fun f -> Query.Pair ("MoveStatus", (MoveStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.move_status
             (fun f -> ("move_status", (MoveStatus.to_json f)))])
    let parse xml =
      Some
        {
          move_status =
            (Util.option_bind (Xml.member "moveStatus" xml) MoveStatus.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.move_status
               (fun f ->
                  Ezxmlm.make_tag "moveStatus" ([], (MoveStatus.to_xml f)))])
           @
           [Util.option_map v.public_ip
              (fun f -> Ezxmlm.make_tag "publicIp" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the status of a moving Elastic IP address.</p>"]
module CreditSpecificationRequest =
  struct
    type t =
      {
      cpu_credits: String.t
        [@ocaml.doc
          "<p>The credit option for CPU usage of a T2 or T3 instance. Valid values are <code>standard</code> and <code>unlimited</code>.</p>"]}
    [@@ocaml.doc
      "<p>The credit option for CPU usage of a T2 or T3 instance.</p>"]
    let make ~cpu_credits  () = { cpu_credits }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("CpuCredits", (String.to_query v.cpu_credits)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("cpu_credits", (String.to_json v.cpu_credits))])
    let parse xml =
      Some
        {
          cpu_credits =
            (Xml.required "CpuCredits"
               (Util.option_bind (Xml.member "CpuCredits" xml) String.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "CpuCredits"
                 ([], (String.to_xml v.cpu_credits)))])
  end[@@ocaml.doc
       "<p>The credit option for CPU usage of a T2 or T3 instance.</p>"]
module ElasticGpuSpecificationList =
  struct
    type t = ElasticGpuSpecification.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ElasticGpuSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list ElasticGpuSpecification.to_headers v
    let to_json v = `List (List.map ElasticGpuSpecification.to_json v)
    let parse xml =
      Util.option_all
        (List.map ElasticGpuSpecification.parse
           (Xml.members "ElasticGpuSpecification" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ElasticGpuSpecification.to_xml x)))
        v
  end
module LaunchTemplateBlockDeviceMappingRequestList =
  struct
    type t = LaunchTemplateBlockDeviceMappingRequest.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list LaunchTemplateBlockDeviceMappingRequest.to_query v
    let to_headers v =
      Headers.to_headers_list
        LaunchTemplateBlockDeviceMappingRequest.to_headers v
    let to_json v =
      `List (List.map LaunchTemplateBlockDeviceMappingRequest.to_json v)
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateBlockDeviceMappingRequest.parse
           (Xml.members "BlockDeviceMapping" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LaunchTemplateBlockDeviceMappingRequest.to_xml x))) v
  end
module LaunchTemplateCapacityReservationSpecificationRequest =
  struct
    type t =
      {
      capacity_reservation_preference: CapacityReservationPreference.t option
        [@ocaml.doc
          "<p>Indicates the instance's Capacity Reservation preferences. Possible preferences include:</p> <ul> <li> <p> <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).</p> </li> <li> <p> <code>none</code> - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.</p> </li> </ul>"];
      capacity_reservation_target: CapacityReservationTarget.t option
        [@ocaml.doc
          "<p>Information about the target Capacity Reservation.</p>"]}
    [@@ocaml.doc
      "<p>Describes an instance's Capacity Reservation targeting option. You can specify only one option at a time. Use the <code>CapacityReservationPreference</code> parameter to configure the instance to run in On-Demand capacity or to run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). Use the <code>CapacityReservationTarget</code> parameter to explicitly target a specific Capacity Reservation.</p>"]
    let make ?capacity_reservation_preference  ?capacity_reservation_target 
      () = { capacity_reservation_preference; capacity_reservation_target }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Query.Pair
                   ("CapacityReservationTarget",
                     (CapacityReservationTarget.to_query f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                Query.Pair
                  ("CapacityReservationPreference",
                    (CapacityReservationPreference.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 ("capacity_reservation_target",
                   (CapacityReservationTarget.to_json f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                ("capacity_reservation_preference",
                  (CapacityReservationPreference.to_json f)))])
    let parse xml =
      Some
        {
          capacity_reservation_preference =
            (Util.option_bind
               (Xml.member "CapacityReservationPreference" xml)
               CapacityReservationPreference.parse);
          capacity_reservation_target =
            (Util.option_bind (Xml.member "CapacityReservationTarget" xml)
               CapacityReservationTarget.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.capacity_reservation_preference
               (fun f ->
                  Ezxmlm.make_tag "CapacityReservationPreference"
                    ([], (CapacityReservationPreference.to_xml f)))])
           @
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Ezxmlm.make_tag "CapacityReservationTarget"
                   ([], (CapacityReservationTarget.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an instance's Capacity Reservation targeting option. You can specify only one option at a time. Use the <code>CapacityReservationPreference</code> parameter to configure the instance to run in On-Demand capacity or to run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). Use the <code>CapacityReservationTarget</code> parameter to explicitly target a specific Capacity Reservation.</p>"]
module LaunchTemplateCpuOptionsRequest =
  struct
    type t =
      {
      core_count: Integer.t option
        [@ocaml.doc "<p>The number of CPU cores for the instance.</p>"];
      threads_per_core: Integer.t option
        [@ocaml.doc
          "<p>The number of threads per CPU core. To disable multithreading for the instance, specify a value of 1. Otherwise, specify the default value of 2.</p>"]}
    [@@ocaml.doc
      "<p>The CPU options for the instance. Both the core count and threads per core must be specified in the request.</p>"]
    let make ?core_count  ?threads_per_core  () =
      { core_count; threads_per_core }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> Query.Pair ("ThreadsPerCore", (Integer.to_query f)));
           Util.option_map v.core_count
             (fun f -> Query.Pair ("CoreCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> ("threads_per_core", (Integer.to_json f)));
           Util.option_map v.core_count
             (fun f -> ("core_count", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          core_count =
            (Util.option_bind (Xml.member "CoreCount" xml) Integer.parse);
          threads_per_core =
            (Util.option_bind (Xml.member "ThreadsPerCore" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.core_count
               (fun f -> Ezxmlm.make_tag "CoreCount" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.threads_per_core
              (fun f ->
                 Ezxmlm.make_tag "ThreadsPerCore" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc
       "<p>The CPU options for the instance. Both the core count and threads per core must be specified in the request.</p>"]
module LaunchTemplateElasticInferenceAcceleratorList =
  struct
    type t = LaunchTemplateElasticInferenceAccelerator.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list LaunchTemplateElasticInferenceAccelerator.to_query
        v
    let to_headers v =
      Headers.to_headers_list
        LaunchTemplateElasticInferenceAccelerator.to_headers v
    let to_json v =
      `List (List.map LaunchTemplateElasticInferenceAccelerator.to_json v)
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateElasticInferenceAccelerator.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LaunchTemplateElasticInferenceAccelerator.to_xml x))) v
  end
module LaunchTemplateHibernationOptionsRequest =
  struct
    type t =
      {
      configured: Boolean.t option
        [@ocaml.doc
          "<p>If you set this parameter to <code>true</code>, the instance is enabled for hibernation.</p> <p>Default: <code>false</code> </p>"]}
    [@@ocaml.doc
      "<p>Indicates whether the instance is configured for hibernation. This parameter is valid only if the instance meets the <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites\">hibernation prerequisites</a>.</p>"]
    let make ?configured  () = { configured }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> Query.Pair ("Configured", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> ("configured", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          configured =
            (Util.option_bind (Xml.member "Configured" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.configured
              (fun f -> Ezxmlm.make_tag "Configured" ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc
       "<p>Indicates whether the instance is configured for hibernation. This parameter is valid only if the instance meets the <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites\">hibernation prerequisites</a>.</p>"]
module LaunchTemplateIamInstanceProfileSpecificationRequest =
  struct
    type t =
      {
      arn: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the instance profile.</p>"];
      name: String.t option
        [@ocaml.doc "<p>The name of the instance profile.</p>"]}[@@ocaml.doc
                                                                  "<p>An IAM instance profile.</p>"]
    let make ?arn  ?name  () = { arn; name }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "Arn" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.arn
               (fun f -> Ezxmlm.make_tag "Arn" ([], (String.to_xml f)))])
           @
           [Util.option_map v.name
              (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>An IAM instance profile.</p>"]
module LaunchTemplateInstanceMarketOptionsRequest =
  struct
    type t =
      {
      market_type: MarketType.t option [@ocaml.doc "<p>The market type.</p>"];
      spot_options: LaunchTemplateSpotMarketOptionsRequest.t option
        [@ocaml.doc "<p>The options for Spot Instances.</p>"]}[@@ocaml.doc
                                                                "<p>The market (purchasing) option for the instances.</p>"]
    let make ?market_type  ?spot_options  () = { market_type; spot_options }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f ->
                 Query.Pair
                   ("SpotOptions",
                     (LaunchTemplateSpotMarketOptionsRequest.to_query f)));
           Util.option_map v.market_type
             (fun f -> Query.Pair ("MarketType", (MarketType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f ->
                 ("spot_options",
                   (LaunchTemplateSpotMarketOptionsRequest.to_json f)));
           Util.option_map v.market_type
             (fun f -> ("market_type", (MarketType.to_json f)))])
    let parse xml =
      Some
        {
          market_type =
            (Util.option_bind (Xml.member "MarketType" xml) MarketType.parse);
          spot_options =
            (Util.option_bind (Xml.member "SpotOptions" xml)
               LaunchTemplateSpotMarketOptionsRequest.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.market_type
               (fun f ->
                  Ezxmlm.make_tag "MarketType" ([], (MarketType.to_xml f)))])
           @
           [Util.option_map v.spot_options
              (fun f ->
                 Ezxmlm.make_tag "SpotOptions"
                   ([], (LaunchTemplateSpotMarketOptionsRequest.to_xml f)))])
  end[@@ocaml.doc "<p>The market (purchasing) option for the instances.</p>"]
module LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList =
  struct
    type t =
      LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list
        LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.to_query v
    let to_headers v =
      Headers.to_headers_list
        LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.to_headers
        v
    let to_json v =
      `List
        (List.map
           LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.to_json
           v)
    let parse xml =
      Util.option_all
        (List.map
           LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.parse
           (Xml.members "InstanceNetworkInterfaceSpecification" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([],
               (LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.to_xml
                  x))) v
  end
module LaunchTemplateLicenseSpecificationListRequest =
  struct
    type t = LaunchTemplateLicenseConfigurationRequest.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list LaunchTemplateLicenseConfigurationRequest.to_query
        v
    let to_headers v =
      Headers.to_headers_list
        LaunchTemplateLicenseConfigurationRequest.to_headers v
    let to_json v =
      `List (List.map LaunchTemplateLicenseConfigurationRequest.to_json v)
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateLicenseConfigurationRequest.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LaunchTemplateLicenseConfigurationRequest.to_xml x))) v
  end
module LaunchTemplatePlacementRequest =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc "<p>The Availability Zone for the instance.</p>"];
      affinity: String.t option
        [@ocaml.doc
          "<p>The affinity setting for an instance on a Dedicated Host.</p>"];
      group_name: String.t option
        [@ocaml.doc
          "<p>The name of the placement group for the instance.</p>"];
      host_id: String.t option
        [@ocaml.doc "<p>The ID of the Dedicated Host for the instance.</p>"];
      tenancy: Tenancy.t option
        [@ocaml.doc
          "<p>The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware.</p>"];
      spread_domain: String.t option
        [@ocaml.doc "<p>Reserved for future use.</p>"];
      host_resource_group_arn: String.t option
        [@ocaml.doc
          "<p>The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the <b>Tenancy</b> parameter or set it to <code>host</code>.</p>"]}
    [@@ocaml.doc "<p>Describes the placement of an instance.</p>"]
    let make ?availability_zone  ?affinity  ?group_name  ?host_id  ?tenancy 
      ?spread_domain  ?host_resource_group_arn  () =
      {
        availability_zone;
        affinity;
        group_name;
        host_id;
        tenancy;
        spread_domain;
        host_resource_group_arn
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f ->
                 Query.Pair ("HostResourceGroupArn", (String.to_query f)));
           Util.option_map v.spread_domain
             (fun f -> Query.Pair ("SpreadDomain", (String.to_query f)));
           Util.option_map v.tenancy
             (fun f -> Query.Pair ("Tenancy", (Tenancy.to_query f)));
           Util.option_map v.host_id
             (fun f -> Query.Pair ("HostId", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.affinity
             (fun f -> Query.Pair ("Affinity", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f -> ("host_resource_group_arn", (String.to_json f)));
           Util.option_map v.spread_domain
             (fun f -> ("spread_domain", (String.to_json f)));
           Util.option_map v.tenancy
             (fun f -> ("tenancy", (Tenancy.to_json f)));
           Util.option_map v.host_id
             (fun f -> ("host_id", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.affinity
             (fun f -> ("affinity", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          affinity =
            (Util.option_bind (Xml.member "Affinity" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          host_id = (Util.option_bind (Xml.member "HostId" xml) String.parse);
          tenancy =
            (Util.option_bind (Xml.member "Tenancy" xml) Tenancy.parse);
          spread_domain =
            (Util.option_bind (Xml.member "SpreadDomain" xml) String.parse);
          host_resource_group_arn =
            (Util.option_bind (Xml.member "HostResourceGroupArn" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.availability_zone
                    (fun f ->
                       Ezxmlm.make_tag "AvailabilityZone"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.affinity
                   (fun f ->
                      Ezxmlm.make_tag "Affinity" ([], (String.to_xml f)))])
               @
               [Util.option_map v.group_name
                  (fun f ->
                     Ezxmlm.make_tag "GroupName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.host_id
                 (fun f -> Ezxmlm.make_tag "HostId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.tenancy
                (fun f -> Ezxmlm.make_tag "Tenancy" ([], (Tenancy.to_xml f)))])
            @
            [Util.option_map v.spread_domain
               (fun f ->
                  Ezxmlm.make_tag "SpreadDomain" ([], (String.to_xml f)))])
           @
           [Util.option_map v.host_resource_group_arn
              (fun f ->
                 Ezxmlm.make_tag "HostResourceGroupArn"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the placement of an instance.</p>"]
module LaunchTemplateTagSpecificationRequestList =
  struct
    type t = LaunchTemplateTagSpecificationRequest.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list LaunchTemplateTagSpecificationRequest.to_query v
    let to_headers v =
      Headers.to_headers_list
        LaunchTemplateTagSpecificationRequest.to_headers v
    let to_json v =
      `List (List.map LaunchTemplateTagSpecificationRequest.to_json v)
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateTagSpecificationRequest.parse
           (Xml.members "LaunchTemplateTagSpecificationRequest" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LaunchTemplateTagSpecificationRequest.to_xml x))) v
  end
module LaunchTemplatesMonitoringRequest =
  struct
    type t =
      {
      enabled: Boolean.t option
        [@ocaml.doc
          "<p>Specify <code>true</code> to enable detailed monitoring. Otherwise, basic monitoring is enabled.</p>"]}
    [@@ocaml.doc "<p>Describes the monitoring for the instance.</p>"]
    let make ?enabled  () = { enabled }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.enabled
              (fun f -> Ezxmlm.make_tag "Enabled" ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the monitoring for the instance.</p>"]
module TrafficMirrorSession =
  struct
    type t =
      {
      traffic_mirror_session_id: String.t option
        [@ocaml.doc "<p>The ID for the Traffic Mirror session.</p>"];
      traffic_mirror_target_id: String.t option
        [@ocaml.doc "<p>The ID of the Traffic Mirror target.</p>"];
      traffic_mirror_filter_id: String.t option
        [@ocaml.doc "<p>The ID of the Traffic Mirror filter.</p>"];
      network_interface_id: String.t option
        [@ocaml.doc
          "<p>The ID of the Traffic Mirror session's network interface.</p>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the account that owns the Traffic Mirror session.</p>"];
      packet_length: Integer.t option
        [@ocaml.doc
          "<p>The number of bytes in each packet to mirror. These are the bytes after the VXLAN header. To mirror a subset, set this to the length (in bytes) to mirror. For example, if you set this value to 100, then the first 100 bytes that meet the filter criteria are copied to the target. Do not specify this parameter when you want to mirror the entire packet</p>"];
      session_number: Integer.t option
        [@ocaml.doc
          "<p>The session number determines the order in which sessions are evaluated when an interface is used by multiple sessions. The first session with a matching filter is the one that mirrors the packets.</p> <p>Valid values are 1-32766.</p>"];
      virtual_network_id: Integer.t option
        [@ocaml.doc
          "<p>The virtual network ID associated with the Traffic Mirror session.</p>"];
      description: String.t option
        [@ocaml.doc "<p>The description of the Traffic Mirror session.</p>"];
      tags: TagList.t
        [@ocaml.doc
          "<p>The tags assigned to the Traffic Mirror session.</p>"]}
    [@@ocaml.doc "<p>Describes a Traffic Mirror session.</p>"]
    let make ?traffic_mirror_session_id  ?traffic_mirror_target_id 
      ?traffic_mirror_filter_id  ?network_interface_id  ?owner_id 
      ?packet_length  ?session_number  ?virtual_network_id  ?description 
      ?(tags= [])  () =
      {
        traffic_mirror_session_id;
        traffic_mirror_target_id;
        traffic_mirror_filter_id;
        network_interface_id;
        owner_id;
        packet_length;
        session_number;
        virtual_network_id;
        description;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.virtual_network_id
             (fun f -> Query.Pair ("VirtualNetworkId", (Integer.to_query f)));
           Util.option_map v.session_number
             (fun f -> Query.Pair ("SessionNumber", (Integer.to_query f)));
           Util.option_map v.packet_length
             (fun f -> Query.Pair ("PacketLength", (Integer.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f ->
                Query.Pair ("TrafficMirrorFilterId", (String.to_query f)));
           Util.option_map v.traffic_mirror_target_id
             (fun f ->
                Query.Pair ("TrafficMirrorTargetId", (String.to_query f)));
           Util.option_map v.traffic_mirror_session_id
             (fun f ->
                Query.Pair ("TrafficMirrorSessionId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.virtual_network_id
             (fun f -> ("virtual_network_id", (Integer.to_json f)));
           Util.option_map v.session_number
             (fun f -> ("session_number", (Integer.to_json f)));
           Util.option_map v.packet_length
             (fun f -> ("packet_length", (Integer.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f -> ("traffic_mirror_filter_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_target_id
             (fun f -> ("traffic_mirror_target_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_session_id
             (fun f -> ("traffic_mirror_session_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          traffic_mirror_session_id =
            (Util.option_bind (Xml.member "trafficMirrorSessionId" xml)
               String.parse);
          traffic_mirror_target_id =
            (Util.option_bind (Xml.member "trafficMirrorTargetId" xml)
               String.parse);
          traffic_mirror_filter_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterId" xml)
               String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          packet_length =
            (Util.option_bind (Xml.member "packetLength" xml) Integer.parse);
          session_number =
            (Util.option_bind (Xml.member "sessionNumber" xml) Integer.parse);
          virtual_network_id =
            (Util.option_bind (Xml.member "virtualNetworkId" xml)
               Integer.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.traffic_mirror_session_id
                       (fun f ->
                          Ezxmlm.make_tag "trafficMirrorSessionId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.traffic_mirror_target_id
                      (fun f ->
                         Ezxmlm.make_tag "trafficMirrorTargetId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.traffic_mirror_filter_id
                     (fun f ->
                        Ezxmlm.make_tag "trafficMirrorFilterId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.network_interface_id
                    (fun f ->
                       Ezxmlm.make_tag "networkInterfaceId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.owner_id
                   (fun f ->
                      Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.packet_length
                  (fun f ->
                     Ezxmlm.make_tag "packetLength" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.session_number
                 (fun f ->
                    Ezxmlm.make_tag "sessionNumber" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.virtual_network_id
                (fun f ->
                   Ezxmlm.make_tag "virtualNetworkId"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.description
               (fun f ->
                  Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a Traffic Mirror session.</p>"]
module DeleteLaunchTemplateVersionsResponseErrorItem =
  struct
    type t =
      {
      launch_template_id: String.t option
        [@ocaml.doc "<p>The ID of the launch template.</p>"];
      launch_template_name: String.t option
        [@ocaml.doc "<p>The name of the launch template.</p>"];
      version_number: Long.t option
        [@ocaml.doc "<p>The version number of the launch template.</p>"];
      response_error: ResponseError.t option
        [@ocaml.doc "<p>Information about the error.</p>"]}[@@ocaml.doc
                                                             "<p>Describes a launch template version that could not be deleted.</p>"]
    let make ?launch_template_id  ?launch_template_name  ?version_number 
      ?response_error  () =
      {
        launch_template_id;
        launch_template_name;
        version_number;
        response_error
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.response_error
              (fun f ->
                 Query.Pair ("ResponseError", (ResponseError.to_query f)));
           Util.option_map v.version_number
             (fun f -> Query.Pair ("VersionNumber", (Long.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.response_error
              (fun f -> ("response_error", (ResponseError.to_json f)));
           Util.option_map v.version_number
             (fun f -> ("version_number", (Long.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "launchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "launchTemplateName" xml)
               String.parse);
          version_number =
            (Util.option_bind (Xml.member "versionNumber" xml) Long.parse);
          response_error =
            (Util.option_bind (Xml.member "responseError" xml)
               ResponseError.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.launch_template_id
                 (fun f ->
                    Ezxmlm.make_tag "launchTemplateId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.launch_template_name
                (fun f ->
                   Ezxmlm.make_tag "launchTemplateName"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.version_number
               (fun f ->
                  Ezxmlm.make_tag "versionNumber" ([], (Long.to_xml f)))])
           @
           [Util.option_map v.response_error
              (fun f ->
                 Ezxmlm.make_tag "responseError"
                   ([], (ResponseError.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a launch template version that could not be deleted.</p>"]
module DeleteLaunchTemplateVersionsResponseSuccessItem =
  struct
    type t =
      {
      launch_template_id: String.t option
        [@ocaml.doc "<p>The ID of the launch template.</p>"];
      launch_template_name: String.t option
        [@ocaml.doc "<p>The name of the launch template.</p>"];
      version_number: Long.t option
        [@ocaml.doc "<p>The version number of the launch template.</p>"]}
    [@@ocaml.doc
      "<p>Describes a launch template version that was successfully deleted.</p>"]
    let make ?launch_template_id  ?launch_template_name  ?version_number  ()
      = { launch_template_id; launch_template_name; version_number }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.version_number
              (fun f -> Query.Pair ("VersionNumber", (Long.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.version_number
              (fun f -> ("version_number", (Long.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "launchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "launchTemplateName" xml)
               String.parse);
          version_number =
            (Util.option_bind (Xml.member "versionNumber" xml) Long.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.launch_template_id
                (fun f ->
                   Ezxmlm.make_tag "launchTemplateId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.launch_template_name
               (fun f ->
                  Ezxmlm.make_tag "launchTemplateName"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.version_number
              (fun f -> Ezxmlm.make_tag "versionNumber" ([], (Long.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a launch template version that was successfully deleted.</p>"]
module SpotInstanceRequest =
  struct
    type t =
      {
      actual_block_hourly_price: String.t option
        [@ocaml.doc
          "<p>If you specified a duration and your Spot Instance request was fulfilled, this is the fixed hourly price in effect for the Spot Instance while it runs.</p>"];
      availability_zone_group: String.t option
        [@ocaml.doc
          "<p>The Availability Zone group. If you specify the same Availability Zone group for all Spot Instance requests, all Spot Instances are launched in the same Availability Zone.</p>"];
      block_duration_minutes: Integer.t option
        [@ocaml.doc "<p>The duration for the Spot Instance, in minutes.</p>"];
      create_time: DateTime.t option
        [@ocaml.doc
          "<p>The date and time when the Spot Instance request was created, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>"];
      fault: SpotInstanceStateFault.t option
        [@ocaml.doc
          "<p>The fault codes for the Spot Instance request, if any.</p>"];
      instance_id: String.t option
        [@ocaml.doc
          "<p>The instance ID, if an instance has been launched to fulfill the Spot Instance request.</p>"];
      launch_group: String.t option
        [@ocaml.doc
          "<p>The instance launch group. Launch groups are Spot Instances that launch together and terminate together.</p>"];
      launch_specification: LaunchSpecification.t option
        [@ocaml.doc "<p>Additional information for launching instances.</p>"];
      launched_availability_zone: String.t option
        [@ocaml.doc
          "<p>The Availability Zone in which the request is launched.</p>"];
      product_description: RIProductDescription.t option
        [@ocaml.doc
          "<p>The product description associated with the Spot Instance.</p>"];
      spot_instance_request_id: String.t option
        [@ocaml.doc "<p>The ID of the Spot Instance request.</p>"];
      spot_price: String.t option
        [@ocaml.doc
          "<p>The maximum price per hour that you are willing to pay for a Spot Instance.</p>"];
      state: SpotInstanceState.t option
        [@ocaml.doc
          "<p>The state of the Spot Instance request. Spot status information helps track your Spot Instance requests. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-bid-status.html\">Spot Status</a> in the <i>Amazon EC2 User Guide for Linux Instances</i>.</p>"];
      status: SpotInstanceStatus.t option
        [@ocaml.doc
          "<p>The status code and status message describing the Spot Instance request.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the resource.</p>"];
      type_: SpotInstanceType.t option
        [@ocaml.doc "<p>The Spot Instance request type.</p>"];
      valid_from: DateTime.t option
        [@ocaml.doc
          "<p>The start date of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). The request becomes active at this date and time.</p>"];
      valid_until: DateTime.t option
        [@ocaml.doc
          "<p>The end date of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). If this is a one-time request, it remains active until all instances launch, the request is canceled, or this date is reached. If the request is persistent, it remains active until it is canceled or this date is reached. The default end date is 7 days from the current date.</p>"];
      instance_interruption_behavior: InstanceInterruptionBehavior.t option
        [@ocaml.doc
          "<p>The behavior when a Spot Instance is interrupted.</p>"]}
    [@@ocaml.doc "<p>Describes a Spot Instance request.</p>"]
    let make ?actual_block_hourly_price  ?availability_zone_group 
      ?block_duration_minutes  ?create_time  ?fault  ?instance_id 
      ?launch_group  ?launch_specification  ?launched_availability_zone 
      ?product_description  ?spot_instance_request_id  ?spot_price  ?state 
      ?status  ?(tags= [])  ?type_  ?valid_from  ?valid_until 
      ?instance_interruption_behavior  () =
      {
        actual_block_hourly_price;
        availability_zone_group;
        block_duration_minutes;
        create_time;
        fault;
        instance_id;
        launch_group;
        launch_specification;
        launched_availability_zone;
        product_description;
        spot_instance_request_id;
        spot_price;
        state;
        status;
        tags;
        type_;
        valid_from;
        valid_until;
        instance_interruption_behavior
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Query.Pair
                   ("InstanceInterruptionBehavior",
                     (InstanceInterruptionBehavior.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.valid_from
             (fun f -> Query.Pair ("ValidFrom", (DateTime.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (SpotInstanceType.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (SpotInstanceStatus.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (SpotInstanceState.to_query f)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.spot_instance_request_id
             (fun f ->
                Query.Pair ("SpotInstanceRequestId", (String.to_query f)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.launched_availability_zone
             (fun f ->
                Query.Pair ("LaunchedAvailabilityZone", (String.to_query f)));
           Util.option_map v.launch_specification
             (fun f ->
                Query.Pair
                  ("LaunchSpecification", (LaunchSpecification.to_query f)));
           Util.option_map v.launch_group
             (fun f -> Query.Pair ("LaunchGroup", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.fault
             (fun f ->
                Query.Pair ("Fault", (SpotInstanceStateFault.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.block_duration_minutes
             (fun f ->
                Query.Pair ("BlockDurationMinutes", (Integer.to_query f)));
           Util.option_map v.availability_zone_group
             (fun f ->
                Query.Pair ("AvailabilityZoneGroup", (String.to_query f)));
           Util.option_map v.actual_block_hourly_price
             (fun f ->
                Query.Pair ("ActualBlockHourlyPrice", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 ("instance_interruption_behavior",
                   (InstanceInterruptionBehavior.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.valid_from
             (fun f -> ("valid_from", (DateTime.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (SpotInstanceType.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status
             (fun f -> ("status", (SpotInstanceStatus.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (SpotInstanceState.to_json f)));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.spot_instance_request_id
             (fun f -> ("spot_instance_request_id", (String.to_json f)));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.launched_availability_zone
             (fun f -> ("launched_availability_zone", (String.to_json f)));
           Util.option_map v.launch_specification
             (fun f ->
                ("launch_specification", (LaunchSpecification.to_json f)));
           Util.option_map v.launch_group
             (fun f -> ("launch_group", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.fault
             (fun f -> ("fault", (SpotInstanceStateFault.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.block_duration_minutes
             (fun f -> ("block_duration_minutes", (Integer.to_json f)));
           Util.option_map v.availability_zone_group
             (fun f -> ("availability_zone_group", (String.to_json f)));
           Util.option_map v.actual_block_hourly_price
             (fun f -> ("actual_block_hourly_price", (String.to_json f)))])
    let parse xml =
      Some
        {
          actual_block_hourly_price =
            (Util.option_bind (Xml.member "actualBlockHourlyPrice" xml)
               String.parse);
          availability_zone_group =
            (Util.option_bind (Xml.member "availabilityZoneGroup" xml)
               String.parse);
          block_duration_minutes =
            (Util.option_bind (Xml.member "blockDurationMinutes" xml)
               Integer.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          fault =
            (Util.option_bind (Xml.member "fault" xml)
               SpotInstanceStateFault.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          launch_group =
            (Util.option_bind (Xml.member "launchGroup" xml) String.parse);
          launch_specification =
            (Util.option_bind (Xml.member "launchSpecification" xml)
               LaunchSpecification.parse);
          launched_availability_zone =
            (Util.option_bind (Xml.member "launchedAvailabilityZone" xml)
               String.parse);
          product_description =
            (Util.option_bind (Xml.member "productDescription" xml)
               RIProductDescription.parse);
          spot_instance_request_id =
            (Util.option_bind (Xml.member "spotInstanceRequestId" xml)
               String.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               SpotInstanceState.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               SpotInstanceStatus.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          type_ =
            (Util.option_bind (Xml.member "type" xml) SpotInstanceType.parse);
          valid_from =
            (Util.option_bind (Xml.member "validFrom" xml) DateTime.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "instanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((((([] @
                             [Util.option_map v.actual_block_hourly_price
                                (fun f ->
                                   Ezxmlm.make_tag "actualBlockHourlyPrice"
                                     ([], (String.to_xml f)))])
                            @
                            [Util.option_map v.availability_zone_group
                               (fun f ->
                                  Ezxmlm.make_tag "availabilityZoneGroup"
                                    ([], (String.to_xml f)))])
                           @
                           [Util.option_map v.block_duration_minutes
                              (fun f ->
                                 Ezxmlm.make_tag "blockDurationMinutes"
                                   ([], (Integer.to_xml f)))])
                          @
                          [Util.option_map v.create_time
                             (fun f ->
                                Ezxmlm.make_tag "createTime"
                                  ([], (DateTime.to_xml f)))])
                         @
                         [Util.option_map v.fault
                            (fun f ->
                               Ezxmlm.make_tag "fault"
                                 ([], (SpotInstanceStateFault.to_xml f)))])
                        @
                        [Util.option_map v.instance_id
                           (fun f ->
                              Ezxmlm.make_tag "instanceId"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.launch_group
                          (fun f ->
                             Ezxmlm.make_tag "launchGroup"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.launch_specification
                         (fun f ->
                            Ezxmlm.make_tag "launchSpecification"
                              ([], (LaunchSpecification.to_xml f)))])
                     @
                     [Util.option_map v.launched_availability_zone
                        (fun f ->
                           Ezxmlm.make_tag "launchedAvailabilityZone"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.product_description
                       (fun f ->
                          Ezxmlm.make_tag "productDescription"
                            ([], (RIProductDescription.to_xml f)))])
                   @
                   [Util.option_map v.spot_instance_request_id
                      (fun f ->
                         Ezxmlm.make_tag "spotInstanceRequestId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.spot_price
                     (fun f ->
                        Ezxmlm.make_tag "spotPrice" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.state
                    (fun f ->
                       Ezxmlm.make_tag "state"
                         ([], (SpotInstanceState.to_xml f)))])
                @
                [Util.option_map v.status
                   (fun f ->
                      Ezxmlm.make_tag "status"
                        ([], (SpotInstanceStatus.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
                  v.tags))
              @
              [Util.option_map v.type_
                 (fun f ->
                    Ezxmlm.make_tag "type" ([], (SpotInstanceType.to_xml f)))])
             @
             [Util.option_map v.valid_from
                (fun f ->
                   Ezxmlm.make_tag "validFrom" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.valid_until
               (fun f ->
                  Ezxmlm.make_tag "validUntil" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Ezxmlm.make_tag "instanceInterruptionBehavior"
                   ([], (InstanceInterruptionBehavior.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a Spot Instance request.</p>"]
module FailedQueuedPurchaseDeletion =
  struct
    type t =
      {
      error: DeleteQueuedReservedInstancesError.t option
        [@ocaml.doc "<p>The error.</p>"];
      reserved_instances_id: String.t option
        [@ocaml.doc "<p>The ID of the Reserved Instance.</p>"]}[@@ocaml.doc
                                                                 "<p>Describes a Reserved Instance whose queued purchase was not deleted.</p>"]
    let make ?error  ?reserved_instances_id  () =
      { error; reserved_instances_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Query.Pair ("ReservedInstancesId", (String.to_query f)));
           Util.option_map v.error
             (fun f ->
                Query.Pair
                  ("Error", (DeleteQueuedReservedInstancesError.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f -> ("reserved_instances_id", (String.to_json f)));
           Util.option_map v.error
             (fun f ->
                ("error", (DeleteQueuedReservedInstancesError.to_json f)))])
    let parse xml =
      Some
        {
          error =
            (Util.option_bind (Xml.member "error" xml)
               DeleteQueuedReservedInstancesError.parse);
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.error
               (fun f ->
                  Ezxmlm.make_tag "error"
                    ([], (DeleteQueuedReservedInstancesError.to_xml f)))])
           @
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Ezxmlm.make_tag "reservedInstancesId"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a Reserved Instance whose queued purchase was not deleted.</p>"]
module SuccessfulQueuedPurchaseDeletion =
  struct
    type t =
      {
      reserved_instances_id: String.t option
        [@ocaml.doc "<p>The ID of the Reserved Instance.</p>"]}[@@ocaml.doc
                                                                 "<p>Describes a Reserved Instance whose queued purchase was successfully deleted.</p>"]
    let make ?reserved_instances_id  () = { reserved_instances_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Ezxmlm.make_tag "reservedInstancesId"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a Reserved Instance whose queued purchase was successfully deleted.</p>"]
module ExportTask =
  struct
    type t =
      {
      description: String.t
        [@ocaml.doc "<p>A description of the resource being exported.</p>"];
      export_task_id: String.t
        [@ocaml.doc "<p>The ID of the export task.</p>"];
      export_to_s3_task: ExportToS3Task.t
        [@ocaml.doc "<p>Information about the export task.</p>"];
      instance_export_details: InstanceExportDetails.t
        [@ocaml.doc "<p>Information about the instance to export.</p>"];
      state: ExportTaskState.t
        [@ocaml.doc "<p>The state of the export task.</p>"];
      status_message: String.t
        [@ocaml.doc "<p>The status message related to the export task.</p>"];
      tags: TagList.t }[@@ocaml.doc
                         "<p>Describes an instance export task.</p>"]
    let make ~description  ~export_task_id  ~export_to_s3_task 
      ~instance_export_details  ~state  ~status_message  ?(tags= [])  () =
      {
        description;
        export_task_id;
        export_to_s3_task;
        instance_export_details;
        state;
        status_message;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("StatusMessage", (String.to_query v.status_message)));
           Some (Query.Pair ("State", (ExportTaskState.to_query v.state)));
           Some
             (Query.Pair
                ("InstanceExport",
                  (InstanceExportDetails.to_query v.instance_export_details)));
           Some
             (Query.Pair
                ("ExportToS3", (ExportToS3Task.to_query v.export_to_s3_task)));
           Some
             (Query.Pair ("ExportTaskId", (String.to_query v.export_task_id)));
           Some (Query.Pair ("Description", (String.to_query v.description)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some ("status_message", (String.to_json v.status_message));
           Some ("state", (ExportTaskState.to_json v.state));
           Some
             ("instance_export_details",
               (InstanceExportDetails.to_json v.instance_export_details));
           Some
             ("export_to_s3_task",
               (ExportToS3Task.to_json v.export_to_s3_task));
           Some ("export_task_id", (String.to_json v.export_task_id));
           Some ("description", (String.to_json v.description))])
    let parse xml =
      Some
        {
          description =
            (Xml.required "description"
               (Util.option_bind (Xml.member "description" xml) String.parse));
          export_task_id =
            (Xml.required "exportTaskId"
               (Util.option_bind (Xml.member "exportTaskId" xml) String.parse));
          export_to_s3_task =
            (Xml.required "exportToS3"
               (Util.option_bind (Xml.member "exportToS3" xml)
                  ExportToS3Task.parse));
          instance_export_details =
            (Xml.required "instanceExport"
               (Util.option_bind (Xml.member "instanceExport" xml)
                  InstanceExportDetails.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml)
                  ExportTaskState.parse));
          status_message =
            (Xml.required "statusMessage"
               (Util.option_bind (Xml.member "statusMessage" xml)
                  String.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Some
                    (Ezxmlm.make_tag "description"
                       ([], (String.to_xml v.description)))])
                @
                [Some
                   (Ezxmlm.make_tag "exportTaskId"
                      ([], (String.to_xml v.export_task_id)))])
               @
               [Some
                  (Ezxmlm.make_tag "exportToS3"
                     ([], (ExportToS3Task.to_xml v.export_to_s3_task)))])
              @
              [Some
                 (Ezxmlm.make_tag "instanceExport"
                    ([],
                      (InstanceExportDetails.to_xml v.instance_export_details)))])
             @
             [Some
                (Ezxmlm.make_tag "state"
                   ([], (ExportTaskState.to_xml v.state)))])
            @
            [Some
               (Ezxmlm.make_tag "statusMessage"
                  ([], (String.to_xml v.status_message)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes an instance export task.</p>"]
module InstanceMonitoring =
  struct
    type t =
      {
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"];
      monitoring: Monitoring.t option
        [@ocaml.doc "<p>The monitoring for the instance.</p>"]}[@@ocaml.doc
                                                                 "<p>Describes the monitoring of an instance.</p>"]
    let make ?instance_id  ?monitoring  () = { instance_id; monitoring }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.monitoring
              (fun f -> Query.Pair ("Monitoring", (Monitoring.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.monitoring
              (fun f -> ("monitoring", (Monitoring.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml) Monitoring.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.monitoring
              (fun f ->
                 Ezxmlm.make_tag "monitoring" ([], (Monitoring.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the monitoring of an instance.</p>"]
module SecurityGroup =
  struct
    type t =
      {
      description: String.t
        [@ocaml.doc "<p>A description of the security group.</p>"];
      group_name: String.t
        [@ocaml.doc "<p>The name of the security group.</p>"];
      ip_permissions: IpPermissionList.t
        [@ocaml.doc
          "<p>The inbound rules associated with the security group.</p>"];
      owner_id: String.t
        [@ocaml.doc
          "<p>The AWS account ID of the owner of the security group.</p>"];
      group_id: String.t [@ocaml.doc "<p>The ID of the security group.</p>"];
      ip_permissions_egress: IpPermissionList.t
        [@ocaml.doc
          "<p>[VPC only] The outbound rules associated with the security group.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the security group.</p>"];
      vpc_id: String.t option
        [@ocaml.doc
          "<p>[VPC only] The ID of the VPC for the security group.</p>"]}
    [@@ocaml.doc "<p>Describes a security group</p>"]
    let make ~description  ~group_name  ?(ip_permissions= [])  ~owner_id 
      ~group_id  ?(ip_permissions_egress= [])  ?(tags= [])  ?vpc_id  () =
      {
        description;
        group_name;
        ip_permissions;
        owner_id;
        group_id;
        ip_permissions_egress;
        tags;
        vpc_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("IpPermissionsEgress",
                  (IpPermissionList.to_query v.ip_permissions_egress)));
           Some (Query.Pair ("GroupId", (String.to_query v.group_id)));
           Some (Query.Pair ("OwnerId", (String.to_query v.owner_id)));
           Some
             (Query.Pair
                ("IpPermissions",
                  (IpPermissionList.to_query v.ip_permissions)));
           Some (Query.Pair ("GroupName", (String.to_query v.group_name)));
           Some
             (Query.Pair
                ("GroupDescription", (String.to_query v.description)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Some
             ("ip_permissions_egress",
               (IpPermissionList.to_json v.ip_permissions_egress));
           Some ("group_id", (String.to_json v.group_id));
           Some ("owner_id", (String.to_json v.owner_id));
           Some
             ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Some ("group_name", (String.to_json v.group_name));
           Some ("description", (String.to_json v.description))])
    let parse xml =
      Some
        {
          description =
            (Xml.required "groupDescription"
               (Util.option_bind (Xml.member "groupDescription" xml)
                  String.parse));
          group_name =
            (Xml.required "groupName"
               (Util.option_bind (Xml.member "groupName" xml) String.parse));
          ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipPermissions" xml)
                  IpPermissionList.parse));
          owner_id =
            (Xml.required "ownerId"
               (Util.option_bind (Xml.member "ownerId" xml) String.parse));
          group_id =
            (Xml.required "groupId"
               (Util.option_bind (Xml.member "groupId" xml) String.parse));
          ip_permissions_egress =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipPermissionsEgress" xml)
                  IpPermissionList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Some
                     (Ezxmlm.make_tag "groupDescription"
                        ([], (String.to_xml v.description)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "groupName"
                       ([], (String.to_xml v.group_name)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "ipPermissions"
                           ([], (IpPermissionList.to_xml [x]))))
                   v.ip_permissions))
               @
               [Some
                  (Ezxmlm.make_tag "ownerId" ([], (String.to_xml v.owner_id)))])
              @
              [Some
                 (Ezxmlm.make_tag "groupId" ([], (String.to_xml v.group_id)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "ipPermissionsEgress"
                        ([], (IpPermissionList.to_xml [x]))))
                v.ip_permissions_egress))
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a security group</p>"]
module ServiceDetail =
  struct
    type t =
      {
      service_name: String.t option
        [@ocaml.doc "<p>The Amazon Resource Name (ARN) of the service.</p>"];
      service_id: String.t option
        [@ocaml.doc "<p>The ID of the endpoint service.</p>"];
      service_type: ServiceTypeDetailSet.t
        [@ocaml.doc "<p>The type of service.</p>"];
      availability_zones: ValueStringList.t
        [@ocaml.doc
          "<p>The Availability Zones in which the service is available.</p>"];
      owner: String.t option
        [@ocaml.doc "<p>The AWS account ID of the service owner.</p>"];
      base_endpoint_dns_names: ValueStringList.t
        [@ocaml.doc "<p>The DNS names for the service.</p>"];
      private_dns_name: String.t option
        [@ocaml.doc "<p>The private DNS name for the service.</p>"];
      vpc_endpoint_policy_supported: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the service supports endpoint policies.</p>"];
      acceptance_required: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether VPC endpoint connection requests to the service must be accepted by the service owner.</p>"];
      manages_vpc_endpoints: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the service manages it's VPC endpoints. Management of the service VPC endpoints using the VPC endpoint API is restricted.</p>"];
      tags: TagList.t [@ocaml.doc "<p>Any tags assigned to the service.</p>"]}
    [@@ocaml.doc "<p>Describes a VPC endpoint service.</p>"]
    let make ?service_name  ?service_id  ?(service_type= []) 
      ?(availability_zones= [])  ?owner  ?(base_endpoint_dns_names= []) 
      ?private_dns_name  ?vpc_endpoint_policy_supported  ?acceptance_required
       ?manages_vpc_endpoints  ?(tags= [])  () =
      {
        service_name;
        service_id;
        service_type;
        availability_zones;
        owner;
        base_endpoint_dns_names;
        private_dns_name;
        vpc_endpoint_policy_supported;
        acceptance_required;
        manages_vpc_endpoints;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.manages_vpc_endpoints
             (fun f ->
                Query.Pair ("ManagesVpcEndpoints", (Boolean.to_query f)));
           Util.option_map v.acceptance_required
             (fun f ->
                Query.Pair ("AcceptanceRequired", (Boolean.to_query f)));
           Util.option_map v.vpc_endpoint_policy_supported
             (fun f ->
                Query.Pair
                  ("VpcEndpointPolicySupported", (Boolean.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Some
             (Query.Pair
                ("BaseEndpointDnsNameSet",
                  (ValueStringList.to_query v.base_endpoint_dns_names)));
           Util.option_map v.owner
             (fun f -> Query.Pair ("Owner", (String.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZoneSet",
                  (ValueStringList.to_query v.availability_zones)));
           Some
             (Query.Pair
                ("ServiceType",
                  (ServiceTypeDetailSet.to_query v.service_type)));
           Util.option_map v.service_id
             (fun f -> Query.Pair ("ServiceId", (String.to_query f)));
           Util.option_map v.service_name
             (fun f -> Query.Pair ("ServiceName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.manages_vpc_endpoints
             (fun f -> ("manages_vpc_endpoints", (Boolean.to_json f)));
           Util.option_map v.acceptance_required
             (fun f -> ("acceptance_required", (Boolean.to_json f)));
           Util.option_map v.vpc_endpoint_policy_supported
             (fun f -> ("vpc_endpoint_policy_supported", (Boolean.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Some
             ("base_endpoint_dns_names",
               (ValueStringList.to_json v.base_endpoint_dns_names));
           Util.option_map v.owner (fun f -> ("owner", (String.to_json f)));
           Some
             ("availability_zones",
               (ValueStringList.to_json v.availability_zones));
           Some
             ("service_type", (ServiceTypeDetailSet.to_json v.service_type));
           Util.option_map v.service_id
             (fun f -> ("service_id", (String.to_json f)));
           Util.option_map v.service_name
             (fun f -> ("service_name", (String.to_json f)))])
    let parse xml =
      Some
        {
          service_name =
            (Util.option_bind (Xml.member "serviceName" xml) String.parse);
          service_id =
            (Util.option_bind (Xml.member "serviceId" xml) String.parse);
          service_type =
            (Util.of_option []
               (Util.option_bind (Xml.member "serviceType" xml)
                  ServiceTypeDetailSet.parse));
          availability_zones =
            (Util.of_option []
               (Util.option_bind (Xml.member "availabilityZoneSet" xml)
                  ValueStringList.parse));
          owner = (Util.option_bind (Xml.member "owner" xml) String.parse);
          base_endpoint_dns_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "baseEndpointDnsNameSet" xml)
                  ValueStringList.parse));
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          vpc_endpoint_policy_supported =
            (Util.option_bind (Xml.member "vpcEndpointPolicySupported" xml)
               Boolean.parse);
          acceptance_required =
            (Util.option_bind (Xml.member "acceptanceRequired" xml)
               Boolean.parse);
          manages_vpc_endpoints =
            (Util.option_bind (Xml.member "managesVpcEndpoints" xml)
               Boolean.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.service_name
                        (fun f ->
                           Ezxmlm.make_tag "serviceName"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.service_id
                       (fun f ->
                          Ezxmlm.make_tag "serviceId" ([], (String.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "serviceType"
                              ([], (ServiceTypeDetailSet.to_xml [x]))))
                      v.service_type))
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "availabilityZoneSet"
                             ([], (ValueStringList.to_xml [x]))))
                     v.availability_zones))
                 @
                 [Util.option_map v.owner
                    (fun f -> Ezxmlm.make_tag "owner" ([], (String.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "baseEndpointDnsNameSet"
                           ([], (ValueStringList.to_xml [x]))))
                   v.base_endpoint_dns_names))
               @
               [Util.option_map v.private_dns_name
                  (fun f ->
                     Ezxmlm.make_tag "privateDnsName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.vpc_endpoint_policy_supported
                 (fun f ->
                    Ezxmlm.make_tag "vpcEndpointPolicySupported"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.acceptance_required
                (fun f ->
                   Ezxmlm.make_tag "acceptanceRequired"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.manages_vpc_endpoints
               (fun f ->
                  Ezxmlm.make_tag "managesVpcEndpoints"
                    ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a VPC endpoint service.</p>"]
module ClientVpnEndpoint =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option
        [@ocaml.doc "<p>The ID of the Client VPN endpoint.</p>"];
      description: String.t option
        [@ocaml.doc "<p>A brief description of the endpoint.</p>"];
      status: ClientVpnEndpointStatus.t option
        [@ocaml.doc "<p>The current state of the Client VPN endpoint.</p>"];
      creation_time: String.t option
        [@ocaml.doc
          "<p>The date and time the Client VPN endpoint was created.</p>"];
      deletion_time: String.t option
        [@ocaml.doc
          "<p>The date and time the Client VPN endpoint was deleted, if applicable.</p>"];
      dns_name: String.t option
        [@ocaml.doc
          "<p>The DNS name to be used by clients when connecting to the Client VPN endpoint.</p>"];
      client_cidr_block: String.t option
        [@ocaml.doc
          "<p>The IPv4 address range, in CIDR notation, from which client IP addresses are assigned.</p>"];
      dns_servers: ValueStringList.t
        [@ocaml.doc
          "<p>Information about the DNS servers to be used for DNS resolution. </p>"];
      split_tunnel: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether split-tunnel is enabled in the AWS Client VPN endpoint.</p> <p>For information about split-tunnel VPN endpoints, see <a href=\"https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/split-tunnel-vpn.html\">Split-Tunnel AWS Client VPN Endpoint</a> in the <i>AWS Client VPN Administrator Guide</i>.</p>"];
      vpn_protocol: VpnProtocol.t option
        [@ocaml.doc "<p>The protocol used by the VPN session.</p>"];
      transport_protocol: TransportProtocol.t option
        [@ocaml.doc
          "<p>The transport protocol used by the Client VPN endpoint.</p>"];
      associated_target_networks: AssociatedTargetNetworkSet.t
        [@ocaml.doc
          "<p>Information about the associated target networks. A target network is a subnet in a VPC.</p>"];
      server_certificate_arn: String.t option
        [@ocaml.doc "<p>The ARN of the server certificate.</p>"];
      authentication_options: ClientVpnAuthenticationList.t
        [@ocaml.doc
          "<p>Information about the authentication method used by the Client VPN endpoint.</p>"];
      connection_log_options: ConnectionLogResponseOptions.t option
        [@ocaml.doc
          "<p>Information about the client connection logging options for the Client VPN endpoint.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the Client VPN endpoint.</p>"]}
    [@@ocaml.doc "<p>Describes a Client VPN endpoint.</p>"]
    let make ?client_vpn_endpoint_id  ?description  ?status  ?creation_time 
      ?deletion_time  ?dns_name  ?client_cidr_block  ?(dns_servers= []) 
      ?split_tunnel  ?vpn_protocol  ?transport_protocol 
      ?(associated_target_networks= [])  ?server_certificate_arn 
      ?(authentication_options= [])  ?connection_log_options  ?(tags= [])  ()
      =
      {
        client_vpn_endpoint_id;
        description;
        status;
        creation_time;
        deletion_time;
        dns_name;
        client_cidr_block;
        dns_servers;
        split_tunnel;
        vpn_protocol;
        transport_protocol;
        associated_target_networks;
        server_certificate_arn;
        authentication_options;
        connection_log_options;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.connection_log_options
             (fun f ->
                Query.Pair
                  ("ConnectionLogOptions",
                    (ConnectionLogResponseOptions.to_query f)));
           Some
             (Query.Pair
                ("AuthenticationOptions",
                  (ClientVpnAuthenticationList.to_query
                     v.authentication_options)));
           Util.option_map v.server_certificate_arn
             (fun f ->
                Query.Pair ("ServerCertificateArn", (String.to_query f)));
           Some
             (Query.Pair
                ("AssociatedTargetNetwork",
                  (AssociatedTargetNetworkSet.to_query
                     v.associated_target_networks)));
           Util.option_map v.transport_protocol
             (fun f ->
                Query.Pair
                  ("TransportProtocol", (TransportProtocol.to_query f)));
           Util.option_map v.vpn_protocol
             (fun f -> Query.Pair ("VpnProtocol", (VpnProtocol.to_query f)));
           Util.option_map v.split_tunnel
             (fun f -> Query.Pair ("SplitTunnel", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("DnsServer", (ValueStringList.to_query v.dns_servers)));
           Util.option_map v.client_cidr_block
             (fun f -> Query.Pair ("ClientCidrBlock", (String.to_query f)));
           Util.option_map v.dns_name
             (fun f -> Query.Pair ("DnsName", (String.to_query f)));
           Util.option_map v.deletion_time
             (fun f -> Query.Pair ("DeletionTime", (String.to_query f)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (ClientVpnEndpointStatus.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.connection_log_options
             (fun f ->
                ("connection_log_options",
                  (ConnectionLogResponseOptions.to_json f)));
           Some
             ("authentication_options",
               (ClientVpnAuthenticationList.to_json v.authentication_options));
           Util.option_map v.server_certificate_arn
             (fun f -> ("server_certificate_arn", (String.to_json f)));
           Some
             ("associated_target_networks",
               (AssociatedTargetNetworkSet.to_json
                  v.associated_target_networks));
           Util.option_map v.transport_protocol
             (fun f -> ("transport_protocol", (TransportProtocol.to_json f)));
           Util.option_map v.vpn_protocol
             (fun f -> ("vpn_protocol", (VpnProtocol.to_json f)));
           Util.option_map v.split_tunnel
             (fun f -> ("split_tunnel", (Boolean.to_json f)));
           Some ("dns_servers", (ValueStringList.to_json v.dns_servers));
           Util.option_map v.client_cidr_block
             (fun f -> ("client_cidr_block", (String.to_json f)));
           Util.option_map v.dns_name
             (fun f -> ("dns_name", (String.to_json f)));
           Util.option_map v.deletion_time
             (fun f -> ("deletion_time", (String.to_json f)));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ClientVpnEndpointStatus.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnEndpointStatus.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) String.parse);
          deletion_time =
            (Util.option_bind (Xml.member "deletionTime" xml) String.parse);
          dns_name =
            (Util.option_bind (Xml.member "dnsName" xml) String.parse);
          client_cidr_block =
            (Util.option_bind (Xml.member "clientCidrBlock" xml) String.parse);
          dns_servers =
            (Util.of_option []
               (Util.option_bind (Xml.member "dnsServer" xml)
                  ValueStringList.parse));
          split_tunnel =
            (Util.option_bind (Xml.member "splitTunnel" xml) Boolean.parse);
          vpn_protocol =
            (Util.option_bind (Xml.member "vpnProtocol" xml)
               VpnProtocol.parse);
          transport_protocol =
            (Util.option_bind (Xml.member "transportProtocol" xml)
               TransportProtocol.parse);
          associated_target_networks =
            (Util.of_option []
               (Util.option_bind (Xml.member "associatedTargetNetwork" xml)
                  AssociatedTargetNetworkSet.parse));
          server_certificate_arn =
            (Util.option_bind (Xml.member "serverCertificateArn" xml)
               String.parse);
          authentication_options =
            (Util.of_option []
               (Util.option_bind (Xml.member "authenticationOptions" xml)
                  ClientVpnAuthenticationList.parse));
          connection_log_options =
            (Util.option_bind (Xml.member "connectionLogOptions" xml)
               ConnectionLogResponseOptions.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((([] @
                          [Util.option_map v.client_vpn_endpoint_id
                             (fun f ->
                                Ezxmlm.make_tag "clientVpnEndpointId"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.description
                            (fun f ->
                               Ezxmlm.make_tag "description"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.status
                           (fun f ->
                              Ezxmlm.make_tag "status"
                                ([], (ClientVpnEndpointStatus.to_xml f)))])
                       @
                       [Util.option_map v.creation_time
                          (fun f ->
                             Ezxmlm.make_tag "creationTime"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.deletion_time
                         (fun f ->
                            Ezxmlm.make_tag "deletionTime"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.dns_name
                        (fun f ->
                           Ezxmlm.make_tag "dnsName" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.client_cidr_block
                       (fun f ->
                          Ezxmlm.make_tag "clientCidrBlock"
                            ([], (String.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "dnsServer"
                              ([], (ValueStringList.to_xml [x]))))
                      v.dns_servers))
                  @
                  [Util.option_map v.split_tunnel
                     (fun f ->
                        Ezxmlm.make_tag "splitTunnel"
                          ([], (Boolean.to_xml f)))])
                 @
                 [Util.option_map v.vpn_protocol
                    (fun f ->
                       Ezxmlm.make_tag "vpnProtocol"
                         ([], (VpnProtocol.to_xml f)))])
                @
                [Util.option_map v.transport_protocol
                   (fun f ->
                      Ezxmlm.make_tag "transportProtocol"
                        ([], (TransportProtocol.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "associatedTargetNetwork"
                          ([], (AssociatedTargetNetworkSet.to_xml [x]))))
                  v.associated_target_networks))
              @
              [Util.option_map v.server_certificate_arn
                 (fun f ->
                    Ezxmlm.make_tag "serverCertificateArn"
                      ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "authenticationOptions"
                        ([], (ClientVpnAuthenticationList.to_xml [x]))))
                v.authentication_options))
            @
            [Util.option_map v.connection_log_options
               (fun f ->
                  Ezxmlm.make_tag "connectionLogOptions"
                    ([], (ConnectionLogResponseOptions.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a Client VPN endpoint.</p>"]
module FleetLaunchTemplateConfigRequest =
  struct
    type t =
      {
      launch_template_specification:
        FleetLaunchTemplateSpecificationRequest.t option
        [@ocaml.doc
          "<p>The launch template to use. You must specify either the launch template ID or launch template name in the request. </p>"];
      overrides: FleetLaunchTemplateOverridesListRequest.t
        [@ocaml.doc
          "<p>Any parameters that you specify override the same parameters in the launch template.</p>"]}
    [@@ocaml.doc "<p>Describes a launch template and overrides.</p>"]
    let make ?launch_template_specification  ?(overrides= [])  () =
      { launch_template_specification; overrides }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Overrides",
                   (FleetLaunchTemplateOverridesListRequest.to_query
                      v.overrides)));
           Util.option_map v.launch_template_specification
             (fun f ->
                Query.Pair
                  ("LaunchTemplateSpecification",
                    (FleetLaunchTemplateSpecificationRequest.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("overrides",
                (FleetLaunchTemplateOverridesListRequest.to_json v.overrides));
           Util.option_map v.launch_template_specification
             (fun f ->
                ("launch_template_specification",
                  (FleetLaunchTemplateSpecificationRequest.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_specification =
            (Util.option_bind (Xml.member "LaunchTemplateSpecification" xml)
               FleetLaunchTemplateSpecificationRequest.parse);
          overrides =
            (Util.of_option []
               (Util.option_bind (Xml.member "Overrides" xml)
                  FleetLaunchTemplateOverridesListRequest.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.launch_template_specification
               (fun f ->
                  Ezxmlm.make_tag "LaunchTemplateSpecification"
                    ([], (FleetLaunchTemplateSpecificationRequest.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Overrides"
                      ([],
                        (FleetLaunchTemplateOverridesListRequest.to_xml [x]))))
              v.overrides))
  end[@@ocaml.doc "<p>Describes a launch template and overrides.</p>"]
module CapacityReservationOptionsRequest =
  struct
    type t =
      {
      usage_strategy: FleetCapacityReservationUsageStrategy.t option
        [@ocaml.doc
          "<p>Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.</p> <p>If you specify <code>use-capacity-reservations-first</code>, the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy (<code>lowest-price</code> or <code>prioritized</code>) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy (<code>lowest-price</code> or <code>prioritized</code>).</p> <p>If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.</p>"]}
    [@@ocaml.doc
      "<p>Describes the strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.</p> <note> <p>This strategy can only be used if the EC2 Fleet is of type <code>instant</code>.</p> </note> <p>For more information about Capacity Reservations, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html\">On-Demand Capacity Reservations</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. For examples of using Capacity Reservations in an EC2 Fleet, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-examples.html\">EC2 Fleet Example Configurations</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"]
    let make ?usage_strategy  () = { usage_strategy }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.usage_strategy
              (fun f ->
                 Query.Pair
                   ("UsageStrategy",
                     (FleetCapacityReservationUsageStrategy.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.usage_strategy
              (fun f ->
                 ("usage_strategy",
                   (FleetCapacityReservationUsageStrategy.to_json f)))])
    let parse xml =
      Some
        {
          usage_strategy =
            (Util.option_bind (Xml.member "UsageStrategy" xml)
               FleetCapacityReservationUsageStrategy.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.usage_strategy
              (fun f ->
                 Ezxmlm.make_tag "UsageStrategy"
                   ([], (FleetCapacityReservationUsageStrategy.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.</p> <note> <p>This strategy can only be used if the EC2 Fleet is of type <code>instant</code>.</p> </note> <p>For more information about Capacity Reservations, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-capacity-reservations.html\">On-Demand Capacity Reservations</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>. For examples of using Capacity Reservations in an EC2 Fleet, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-examples.html\">EC2 Fleet Example Configurations</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"]
module InternetGateway =
  struct
    type t =
      {
      attachments: InternetGatewayAttachmentList.t
        [@ocaml.doc "<p>Any VPCs attached to the internet gateway.</p>"];
      internet_gateway_id: String.t
        [@ocaml.doc "<p>The ID of the internet gateway.</p>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account that owns the internet gateway.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the internet gateway.</p>"]}
    [@@ocaml.doc "<p>Describes an internet gateway.</p>"]
    let make ?(attachments= [])  ~internet_gateway_id  ?owner_id  ?(tags= [])
       () = { attachments; internet_gateway_id; owner_id; tags }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Some
             (Query.Pair
                ("InternetGatewayId",
                  (String.to_query v.internet_gateway_id)));
           Some
             (Query.Pair
                ("AttachmentSet",
                  (InternetGatewayAttachmentList.to_query v.attachments)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Some
             ("internet_gateway_id", (String.to_json v.internet_gateway_id));
           Some
             ("attachments",
               (InternetGatewayAttachmentList.to_json v.attachments))])
    let parse xml =
      Some
        {
          attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "attachmentSet" xml)
                  InternetGatewayAttachmentList.parse));
          internet_gateway_id =
            (Xml.required "internetGatewayId"
               (Util.option_bind (Xml.member "internetGatewayId" xml)
                  String.parse));
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "attachmentSet"
                         ([], (InternetGatewayAttachmentList.to_xml [x]))))
                 v.attachments))
             @
             [Some
                (Ezxmlm.make_tag "internetGatewayId"
                   ([], (String.to_xml v.internet_gateway_id)))])
            @
            [Util.option_map v.owner_id
               (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes an internet gateway.</p>"]
module AccountAttributeName =
  struct
    type t =
      | Supported_platforms 
      | Default_vpc 
    let str_to_t =
      [("default-vpc", Default_vpc);
      ("supported-platforms", Supported_platforms)]
    let t_to_str =
      [(Default_vpc, "default-vpc");
      (Supported_platforms, "supported-platforms")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module FleetData =
  struct
    type t =
      {
      activity_status: FleetActivityStatus.t option
        [@ocaml.doc
          "<p>The progress of the EC2 Fleet. If there is an error, the status is <code>error</code>. After all requests are placed, the status is <code>pending_fulfillment</code>. If the size of the EC2 Fleet is equal to or greater than its target capacity, the status is <code>fulfilled</code>. If the size of the EC2 Fleet is decreased, the status is <code>pending_termination</code> while instances are terminating.</p>"];
      create_time: DateTime.t option
        [@ocaml.doc "<p>The creation date and time of the EC2 Fleet.</p>"];
      fleet_id: String.t option
        [@ocaml.doc "<p>The ID of the EC2 Fleet.</p>"];
      fleet_state: FleetStateCode.t option
        [@ocaml.doc "<p>The state of the EC2 Fleet.</p>"];
      client_token: String.t option
        [@ocaml.doc
          "<p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html\">Ensuring Idempotency</a>.</p> <p>Constraints: Maximum 64 ASCII characters</p>"];
      excess_capacity_termination_policy:
        FleetExcessCapacityTerminationPolicy.t option
        [@ocaml.doc
          "<p>Indicates whether running instances should be terminated if the target capacity of the EC2 Fleet is decreased below the current size of the EC2 Fleet.</p>"];
      fulfilled_capacity: Double.t option
        [@ocaml.doc
          "<p>The number of units fulfilled by this request compared to the set target capacity.</p>"];
      fulfilled_on_demand_capacity: Double.t option
        [@ocaml.doc
          "<p>The number of units fulfilled by this request compared to the set target On-Demand capacity.</p>"];
      launch_template_configs: FleetLaunchTemplateConfigList.t
        [@ocaml.doc "<p>The launch template and overrides.</p>"];
      target_capacity_specification: TargetCapacitySpecification.t option
        [@ocaml.doc
          "<p>The number of units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>, you can specify a target capacity of 0 and add capacity later.</p>"];
      terminate_instances_with_expiration: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether running instances should be terminated when the EC2 Fleet expires. </p>"];
      type_: FleetType.t option
        [@ocaml.doc
          "<p>The type of request. Indicates whether the EC2 Fleet only <code>requests</code> the target capacity, or also attempts to <code>maintain</code> it. If you request a certain target capacity, EC2 Fleet only places the required requests; it does not attempt to replenish instances if capacity is diminished, and it does not submit requests in alternative capacity pools if capacity is unavailable. To maintain a certain target capacity, EC2 Fleet places the required requests to meet this target capacity. It also automatically replenishes any interrupted Spot Instances. Default: <code>maintain</code>.</p>"];
      valid_from: DateTime.t option
        [@ocaml.doc
          "<p>The start date and time of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). The default is to start fulfilling the request immediately. </p>"];
      valid_until: DateTime.t option
        [@ocaml.doc
          "<p>The end date and time of the request, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). At this point, no new instance requests are placed or able to fulfill the request. The default end date is 7 days from the current date. </p>"];
      replace_unhealthy_instances: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether EC2 Fleet should replace unhealthy instances.</p>"];
      spot_options: SpotOptions.t option
        [@ocaml.doc
          "<p>The configuration of Spot Instances in an EC2 Fleet.</p>"];
      on_demand_options: OnDemandOptions.t option
        [@ocaml.doc
          "<p>The allocation strategy of On-Demand Instances in an EC2 Fleet.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>The tags for an EC2 Fleet resource.</p>"];
      errors: DescribeFleetsErrorSet.t
        [@ocaml.doc
          "<p>Information about the instances that could not be launched by the fleet. Valid only when <b>Type</b> is set to <code>instant</code>.</p>"];
      instances: DescribeFleetsInstancesSet.t
        [@ocaml.doc
          "<p>Information about the instances that were launched by the fleet. Valid only when <b>Type</b> is set to <code>instant</code>.</p>"]}
    [@@ocaml.doc "<p>Describes an EC2 Fleet.</p>"]
    let make ?activity_status  ?create_time  ?fleet_id  ?fleet_state 
      ?client_token  ?excess_capacity_termination_policy  ?fulfilled_capacity
       ?fulfilled_on_demand_capacity  ?(launch_template_configs= []) 
      ?target_capacity_specification  ?terminate_instances_with_expiration 
      ?type_  ?valid_from  ?valid_until  ?replace_unhealthy_instances 
      ?spot_options  ?on_demand_options  ?(tags= [])  ?(errors= []) 
      ?(instances= [])  () =
      {
        activity_status;
        create_time;
        fleet_id;
        fleet_state;
        client_token;
        excess_capacity_termination_policy;
        fulfilled_capacity;
        fulfilled_on_demand_capacity;
        launch_template_configs;
        target_capacity_specification;
        terminate_instances_with_expiration;
        type_;
        valid_from;
        valid_until;
        replace_unhealthy_instances;
        spot_options;
        on_demand_options;
        tags;
        errors;
        instances
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FleetInstanceSet",
                   (DescribeFleetsInstancesSet.to_query v.instances)));
           Some
             (Query.Pair
                ("ErrorSet", (DescribeFleetsErrorSet.to_query v.errors)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.on_demand_options
             (fun f ->
                Query.Pair ("OnDemandOptions", (OnDemandOptions.to_query f)));
           Util.option_map v.spot_options
             (fun f -> Query.Pair ("SpotOptions", (SpotOptions.to_query f)));
           Util.option_map v.replace_unhealthy_instances
             (fun f ->
                Query.Pair
                  ("ReplaceUnhealthyInstances", (Boolean.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.valid_from
             (fun f -> Query.Pair ("ValidFrom", (DateTime.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (FleetType.to_query f)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                Query.Pair
                  ("TerminateInstancesWithExpiration", (Boolean.to_query f)));
           Util.option_map v.target_capacity_specification
             (fun f ->
                Query.Pair
                  ("TargetCapacitySpecification",
                    (TargetCapacitySpecification.to_query f)));
           Some
             (Query.Pair
                ("LaunchTemplateConfigs",
                  (FleetLaunchTemplateConfigList.to_query
                     v.launch_template_configs)));
           Util.option_map v.fulfilled_on_demand_capacity
             (fun f ->
                Query.Pair ("FulfilledOnDemandCapacity", (Double.to_query f)));
           Util.option_map v.fulfilled_capacity
             (fun f -> Query.Pair ("FulfilledCapacity", (Double.to_query f)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                Query.Pair
                  ("ExcessCapacityTerminationPolicy",
                    (FleetExcessCapacityTerminationPolicy.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.fleet_state
             (fun f -> Query.Pair ("FleetState", (FleetStateCode.to_query f)));
           Util.option_map v.fleet_id
             (fun f -> Query.Pair ("FleetId", (String.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.activity_status
             (fun f ->
                Query.Pair
                  ("ActivityStatus", (FleetActivityStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instances", (DescribeFleetsInstancesSet.to_json v.instances));
           Some ("errors", (DescribeFleetsErrorSet.to_json v.errors));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.on_demand_options
             (fun f -> ("on_demand_options", (OnDemandOptions.to_json f)));
           Util.option_map v.spot_options
             (fun f -> ("spot_options", (SpotOptions.to_json f)));
           Util.option_map v.replace_unhealthy_instances
             (fun f -> ("replace_unhealthy_instances", (Boolean.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.valid_from
             (fun f -> ("valid_from", (DateTime.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (FleetType.to_json f)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                ("terminate_instances_with_expiration", (Boolean.to_json f)));
           Util.option_map v.target_capacity_specification
             (fun f ->
                ("target_capacity_specification",
                  (TargetCapacitySpecification.to_json f)));
           Some
             ("launch_template_configs",
               (FleetLaunchTemplateConfigList.to_json
                  v.launch_template_configs));
           Util.option_map v.fulfilled_on_demand_capacity
             (fun f -> ("fulfilled_on_demand_capacity", (Double.to_json f)));
           Util.option_map v.fulfilled_capacity
             (fun f -> ("fulfilled_capacity", (Double.to_json f)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                ("excess_capacity_termination_policy",
                  (FleetExcessCapacityTerminationPolicy.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.fleet_state
             (fun f -> ("fleet_state", (FleetStateCode.to_json f)));
           Util.option_map v.fleet_id
             (fun f -> ("fleet_id", (String.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.activity_status
             (fun f -> ("activity_status", (FleetActivityStatus.to_json f)))])
    let parse xml =
      Some
        {
          activity_status =
            (Util.option_bind (Xml.member "activityStatus" xml)
               FleetActivityStatus.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse);
          fleet_state =
            (Util.option_bind (Xml.member "fleetState" xml)
               FleetStateCode.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          excess_capacity_termination_policy =
            (Util.option_bind
               (Xml.member "excessCapacityTerminationPolicy" xml)
               FleetExcessCapacityTerminationPolicy.parse);
          fulfilled_capacity =
            (Util.option_bind (Xml.member "fulfilledCapacity" xml)
               Double.parse);
          fulfilled_on_demand_capacity =
            (Util.option_bind (Xml.member "fulfilledOnDemandCapacity" xml)
               Double.parse);
          launch_template_configs =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchTemplateConfigs" xml)
                  FleetLaunchTemplateConfigList.parse));
          target_capacity_specification =
            (Util.option_bind (Xml.member "targetCapacitySpecification" xml)
               TargetCapacitySpecification.parse);
          terminate_instances_with_expiration =
            (Util.option_bind
               (Xml.member "terminateInstancesWithExpiration" xml)
               Boolean.parse);
          type_ = (Util.option_bind (Xml.member "type" xml) FleetType.parse);
          valid_from =
            (Util.option_bind (Xml.member "validFrom" xml) DateTime.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          replace_unhealthy_instances =
            (Util.option_bind (Xml.member "replaceUnhealthyInstances" xml)
               Boolean.parse);
          spot_options =
            (Util.option_bind (Xml.member "spotOptions" xml)
               SpotOptions.parse);
          on_demand_options =
            (Util.option_bind (Xml.member "onDemandOptions" xml)
               OnDemandOptions.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          errors =
            (Util.of_option []
               (Util.option_bind (Xml.member "errorSet" xml)
                  DescribeFleetsErrorSet.parse));
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "fleetInstanceSet" xml)
                  DescribeFleetsInstancesSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((((([] @
                              [Util.option_map v.activity_status
                                 (fun f ->
                                    Ezxmlm.make_tag "activityStatus"
                                      ([], (FleetActivityStatus.to_xml f)))])
                             @
                             [Util.option_map v.create_time
                                (fun f ->
                                   Ezxmlm.make_tag "createTime"
                                     ([], (DateTime.to_xml f)))])
                            @
                            [Util.option_map v.fleet_id
                               (fun f ->
                                  Ezxmlm.make_tag "fleetId"
                                    ([], (String.to_xml f)))])
                           @
                           [Util.option_map v.fleet_state
                              (fun f ->
                                 Ezxmlm.make_tag "fleetState"
                                   ([], (FleetStateCode.to_xml f)))])
                          @
                          [Util.option_map v.client_token
                             (fun f ->
                                Ezxmlm.make_tag "clientToken"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map
                            v.excess_capacity_termination_policy
                            (fun f ->
                               Ezxmlm.make_tag
                                 "excessCapacityTerminationPolicy"
                                 ([],
                                   (FleetExcessCapacityTerminationPolicy.to_xml
                                      f)))])
                        @
                        [Util.option_map v.fulfilled_capacity
                           (fun f ->
                              Ezxmlm.make_tag "fulfilledCapacity"
                                ([], (Double.to_xml f)))])
                       @
                       [Util.option_map v.fulfilled_on_demand_capacity
                          (fun f ->
                             Ezxmlm.make_tag "fulfilledOnDemandCapacity"
                               ([], (Double.to_xml f)))])
                      @
                      (List.map
                         (fun x ->
                            Some
                              (Ezxmlm.make_tag "launchTemplateConfigs"
                                 ([],
                                   (FleetLaunchTemplateConfigList.to_xml [x]))))
                         v.launch_template_configs))
                     @
                     [Util.option_map v.target_capacity_specification
                        (fun f ->
                           Ezxmlm.make_tag "targetCapacitySpecification"
                             ([], (TargetCapacitySpecification.to_xml f)))])
                    @
                    [Util.option_map v.terminate_instances_with_expiration
                       (fun f ->
                          Ezxmlm.make_tag "terminateInstancesWithExpiration"
                            ([], (Boolean.to_xml f)))])
                   @
                   [Util.option_map v.type_
                      (fun f ->
                         Ezxmlm.make_tag "type" ([], (FleetType.to_xml f)))])
                  @
                  [Util.option_map v.valid_from
                     (fun f ->
                        Ezxmlm.make_tag "validFrom" ([], (DateTime.to_xml f)))])
                 @
                 [Util.option_map v.valid_until
                    (fun f ->
                       Ezxmlm.make_tag "validUntil" ([], (DateTime.to_xml f)))])
                @
                [Util.option_map v.replace_unhealthy_instances
                   (fun f ->
                      Ezxmlm.make_tag "replaceUnhealthyInstances"
                        ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.spot_options
                  (fun f ->
                     Ezxmlm.make_tag "spotOptions"
                       ([], (SpotOptions.to_xml f)))])
              @
              [Util.option_map v.on_demand_options
                 (fun f ->
                    Ezxmlm.make_tag "onDemandOptions"
                      ([], (OnDemandOptions.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
                v.tags))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "errorSet"
                       ([], (DescribeFleetsErrorSet.to_xml [x])))) v.errors))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "fleetInstanceSet"
                      ([], (DescribeFleetsInstancesSet.to_xml [x]))))
              v.instances))
  end[@@ocaml.doc "<p>Describes an EC2 Fleet.</p>"]
module SpotFleetRequestConfig =
  struct
    type t =
      {
      activity_status: ActivityStatus.t option
        [@ocaml.doc
          "<p>The progress of the Spot Fleet request. If there is an error, the status is <code>error</code>. After all requests are placed, the status is <code>pending_fulfillment</code>. If the size of the fleet is equal to or greater than its target capacity, the status is <code>fulfilled</code>. If the size of the fleet is decreased, the status is <code>pending_termination</code> while Spot Instances are terminating.</p>"];
      create_time: DateTime.t option
        [@ocaml.doc "<p>The creation date and time of the request.</p>"];
      spot_fleet_request_config: SpotFleetRequestConfigData.t option
        [@ocaml.doc "<p>The configuration of the Spot Fleet request.</p>"];
      spot_fleet_request_id: String.t option
        [@ocaml.doc "<p>The ID of the Spot Fleet request.</p>"];
      spot_fleet_request_state: BatchState.t option
        [@ocaml.doc "<p>The state of the Spot Fleet request.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes a Spot Fleet request.</p>"]
    let make ?activity_status  ?create_time  ?spot_fleet_request_config 
      ?spot_fleet_request_id  ?spot_fleet_request_state  () =
      {
        activity_status;
        create_time;
        spot_fleet_request_config;
        spot_fleet_request_id;
        spot_fleet_request_state
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_state
              (fun f ->
                 Query.Pair
                   ("SpotFleetRequestState", (BatchState.to_query f)));
           Util.option_map v.spot_fleet_request_id
             (fun f -> Query.Pair ("SpotFleetRequestId", (String.to_query f)));
           Util.option_map v.spot_fleet_request_config
             (fun f ->
                Query.Pair
                  ("SpotFleetRequestConfig",
                    (SpotFleetRequestConfigData.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.activity_status
             (fun f ->
                Query.Pair ("ActivityStatus", (ActivityStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_state
              (fun f -> ("spot_fleet_request_state", (BatchState.to_json f)));
           Util.option_map v.spot_fleet_request_id
             (fun f -> ("spot_fleet_request_id", (String.to_json f)));
           Util.option_map v.spot_fleet_request_config
             (fun f ->
                ("spot_fleet_request_config",
                  (SpotFleetRequestConfigData.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.activity_status
             (fun f -> ("activity_status", (ActivityStatus.to_json f)))])
    let parse xml =
      Some
        {
          activity_status =
            (Util.option_bind (Xml.member "activityStatus" xml)
               ActivityStatus.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          spot_fleet_request_config =
            (Util.option_bind (Xml.member "spotFleetRequestConfig" xml)
               SpotFleetRequestConfigData.parse);
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse);
          spot_fleet_request_state =
            (Util.option_bind (Xml.member "spotFleetRequestState" xml)
               BatchState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.activity_status
                  (fun f ->
                     Ezxmlm.make_tag "activityStatus"
                       ([], (ActivityStatus.to_xml f)))])
              @
              [Util.option_map v.create_time
                 (fun f ->
                    Ezxmlm.make_tag "createTime" ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.spot_fleet_request_config
                (fun f ->
                   Ezxmlm.make_tag "spotFleetRequestConfig"
                     ([], (SpotFleetRequestConfigData.to_xml f)))])
            @
            [Util.option_map v.spot_fleet_request_id
               (fun f ->
                  Ezxmlm.make_tag "spotFleetRequestId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.spot_fleet_request_state
              (fun f ->
                 Ezxmlm.make_tag "spotFleetRequestState"
                   ([], (BatchState.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a Spot Fleet request.</p>"]
module PurchaseRequest =
  struct
    type t =
      {
      instance_count: Integer.t
        [@ocaml.doc "<p>The number of instances.</p>"];
      purchase_token: String.t [@ocaml.doc "<p>The purchase token.</p>"]}
    [@@ocaml.doc
      "<p>Describes a request to purchase Scheduled Instances.</p>"]
    let make ~instance_count  ~purchase_token  () =
      { instance_count; purchase_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PurchaseToken", (String.to_query v.purchase_token)));
           Some
             (Query.Pair
                ("InstanceCount", (Integer.to_query v.instance_count)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("purchase_token", (String.to_json v.purchase_token));
           Some ("instance_count", (Integer.to_json v.instance_count))])
    let parse xml =
      Some
        {
          instance_count =
            (Xml.required "InstanceCount"
               (Util.option_bind (Xml.member "InstanceCount" xml)
                  Integer.parse));
          purchase_token =
            (Xml.required "PurchaseToken"
               (Util.option_bind (Xml.member "PurchaseToken" xml)
                  String.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "InstanceCount"
                  ([], (Integer.to_xml v.instance_count)))])
           @
           [Some
              (Ezxmlm.make_tag "PurchaseToken"
                 ([], (String.to_xml v.purchase_token)))])
  end[@@ocaml.doc
       "<p>Describes a request to purchase Scheduled Instances.</p>"]
module AvailabilityZone =
  struct
    type t =
      {
      state: AvailabilityZoneState.t option
        [@ocaml.doc
          "<p>The state of the Availability Zone or Local Zone.</p>"];
      opt_in_status: AvailabilityZoneOptInStatus.t option
        [@ocaml.doc
          "<p> For Availability Zones, this parameter always has the value of <code>opt-in-not-required</code>.</p> <p>For Local Zones, this parameter is the opt in status. The possible values are <code>opted-in</code>, and <code>not-opted-in</code>.</p>"];
      messages: AvailabilityZoneMessageList.t
        [@ocaml.doc
          "<p>Any messages about the Availability Zone or Local Zone.</p>"];
      region_name: String.t option
        [@ocaml.doc "<p>The name of the Region.</p>"];
      zone_name: String.t option
        [@ocaml.doc
          "<p>The name of the Availability Zone or Local Zone.</p>"];
      zone_id: String.t option
        [@ocaml.doc "<p>The ID of the Availability Zone or Local Zone.</p>"];
      group_name: String.t option
        [@ocaml.doc
          "<p> For Availability Zones, this parameter has the same value as the Region name.</p> <p>For Local Zones, the name of the associated group, for example <code>us-west-2-lax-1</code>.</p>"];
      network_border_group: String.t option
        [@ocaml.doc
          "<p>The name of the location from which the address is advertised.</p>"]}
    [@@ocaml.doc "<p>Describes an Availability Zone or Local Zone.</p>"]
    let make ?state  ?opt_in_status  ?(messages= [])  ?region_name 
      ?zone_name  ?zone_id  ?group_name  ?network_border_group  () =
      {
        state;
        opt_in_status;
        messages;
        region_name;
        zone_name;
        zone_id;
        group_name;
        network_border_group
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_border_group
              (fun f ->
                 Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.zone_id
             (fun f -> Query.Pair ("ZoneId", (String.to_query f)));
           Util.option_map v.zone_name
             (fun f -> Query.Pair ("ZoneName", (String.to_query f)));
           Util.option_map v.region_name
             (fun f -> Query.Pair ("RegionName", (String.to_query f)));
           Some
             (Query.Pair
                ("MessageSet",
                  (AvailabilityZoneMessageList.to_query v.messages)));
           Util.option_map v.opt_in_status
             (fun f ->
                Query.Pair
                  ("OptInStatus", (AvailabilityZoneOptInStatus.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("ZoneState", (AvailabilityZoneState.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_border_group
              (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.zone_id
             (fun f -> ("zone_id", (String.to_json f)));
           Util.option_map v.zone_name
             (fun f -> ("zone_name", (String.to_json f)));
           Util.option_map v.region_name
             (fun f -> ("region_name", (String.to_json f)));
           Some
             ("messages", (AvailabilityZoneMessageList.to_json v.messages));
           Util.option_map v.opt_in_status
             (fun f ->
                ("opt_in_status", (AvailabilityZoneOptInStatus.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (AvailabilityZoneState.to_json f)))])
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "zoneState" xml)
               AvailabilityZoneState.parse);
          opt_in_status =
            (Util.option_bind (Xml.member "optInStatus" xml)
               AvailabilityZoneOptInStatus.parse);
          messages =
            (Util.of_option []
               (Util.option_bind (Xml.member "messageSet" xml)
                  AvailabilityZoneMessageList.parse));
          region_name =
            (Util.option_bind (Xml.member "regionName" xml) String.parse);
          zone_name =
            (Util.option_bind (Xml.member "zoneName" xml) String.parse);
          zone_id = (Util.option_bind (Xml.member "zoneId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          network_border_group =
            (Util.option_bind (Xml.member "networkBorderGroup" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.state
                     (fun f ->
                        Ezxmlm.make_tag "zoneState"
                          ([], (AvailabilityZoneState.to_xml f)))])
                 @
                 [Util.option_map v.opt_in_status
                    (fun f ->
                       Ezxmlm.make_tag "optInStatus"
                         ([], (AvailabilityZoneOptInStatus.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "messageSet"
                           ([], (AvailabilityZoneMessageList.to_xml [x]))))
                   v.messages))
               @
               [Util.option_map v.region_name
                  (fun f ->
                     Ezxmlm.make_tag "regionName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.zone_name
                 (fun f -> Ezxmlm.make_tag "zoneName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.zone_id
                (fun f -> Ezxmlm.make_tag "zoneId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.group_name
               (fun f -> Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.network_border_group
              (fun f ->
                 Ezxmlm.make_tag "networkBorderGroup" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an Availability Zone or Local Zone.</p>"]
module CustomerGateway =
  struct
    type t =
      {
      bgp_asn: String.t
        [@ocaml.doc
          "<p>The customer gateway's Border Gateway Protocol (BGP) Autonomous System Number (ASN).</p>"];
      customer_gateway_id: String.t
        [@ocaml.doc "<p>The ID of the customer gateway.</p>"];
      ip_address: String.t
        [@ocaml.doc
          "<p>The Internet-routable IP address of the customer gateway's outside interface.</p>"];
      certificate_arn: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) for the customer gateway certificate.</p>"];
      state: String.t
        [@ocaml.doc
          "<p>The current state of the customer gateway (<code>pending | available | deleting | deleted</code>).</p>"];
      type_: String.t
        [@ocaml.doc
          "<p>The type of VPN connection the customer gateway supports (<code>ipsec.1</code>).</p>"];
      device_name: String.t option
        [@ocaml.doc "<p>The name of customer gateway device.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the customer gateway.</p>"]}
    [@@ocaml.doc "<p>Describes a customer gateway.</p>"]
    let make ~bgp_asn  ~customer_gateway_id  ~ip_address  ?certificate_arn 
      ~state  ~type_  ?device_name  ?(tags= [])  () =
      {
        bgp_asn;
        customer_gateway_id;
        ip_address;
        certificate_arn;
        state;
        type_;
        device_name;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)));
           Some (Query.Pair ("Type", (String.to_query v.type_)));
           Some (Query.Pair ("State", (String.to_query v.state)));
           Util.option_map v.certificate_arn
             (fun f -> Query.Pair ("CertificateArn", (String.to_query f)));
           Some (Query.Pair ("IpAddress", (String.to_query v.ip_address)));
           Some
             (Query.Pair
                ("CustomerGatewayId",
                  (String.to_query v.customer_gateway_id)));
           Some (Query.Pair ("BgpAsn", (String.to_query v.bgp_asn)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)));
           Some ("type_", (String.to_json v.type_));
           Some ("state", (String.to_json v.state));
           Util.option_map v.certificate_arn
             (fun f -> ("certificate_arn", (String.to_json f)));
           Some ("ip_address", (String.to_json v.ip_address));
           Some
             ("customer_gateway_id", (String.to_json v.customer_gateway_id));
           Some ("bgp_asn", (String.to_json v.bgp_asn))])
    let parse xml =
      Some
        {
          bgp_asn =
            (Xml.required "bgpAsn"
               (Util.option_bind (Xml.member "bgpAsn" xml) String.parse));
          customer_gateway_id =
            (Xml.required "customerGatewayId"
               (Util.option_bind (Xml.member "customerGatewayId" xml)
                  String.parse));
          ip_address =
            (Xml.required "ipAddress"
               (Util.option_bind (Xml.member "ipAddress" xml) String.parse));
          certificate_arn =
            (Util.option_bind (Xml.member "certificateArn" xml) String.parse);
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml) String.parse));
          type_ =
            (Xml.required "type"
               (Util.option_bind (Xml.member "type" xml) String.parse));
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Some
                     (Ezxmlm.make_tag "bgpAsn"
                        ([], (String.to_xml v.bgp_asn)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "customerGatewayId"
                       ([], (String.to_xml v.customer_gateway_id)))])
                @
                [Some
                   (Ezxmlm.make_tag "ipAddress"
                      ([], (String.to_xml v.ip_address)))])
               @
               [Util.option_map v.certificate_arn
                  (fun f ->
                     Ezxmlm.make_tag "certificateArn" ([], (String.to_xml f)))])
              @
              [Some (Ezxmlm.make_tag "state" ([], (String.to_xml v.state)))])
             @ [Some (Ezxmlm.make_tag "type" ([], (String.to_xml v.type_)))])
            @
            [Util.option_map v.device_name
               (fun f -> Ezxmlm.make_tag "deviceName" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a customer gateway.</p>"]
module VolumeStatusItem =
  struct
    type t =
      {
      actions: VolumeStatusActionsList.t
        [@ocaml.doc "<p>The details of the operation.</p>"];
      availability_zone: String.t option
        [@ocaml.doc "<p>The Availability Zone of the volume.</p>"];
      outpost_arn: String.t option
        [@ocaml.doc "<p>The Amazon Resource Name (ARN) of the Outpost.</p>"];
      events: VolumeStatusEventsList.t
        [@ocaml.doc "<p>A list of events associated with the volume.</p>"];
      volume_id: String.t option [@ocaml.doc "<p>The volume ID.</p>"];
      volume_status: VolumeStatusInfo.t option
        [@ocaml.doc "<p>The volume status.</p>"]}[@@ocaml.doc
                                                   "<p>Describes the volume status.</p>"]
    let make ?(actions= [])  ?availability_zone  ?outpost_arn  ?(events= []) 
      ?volume_id  ?volume_status  () =
      {
        actions;
        availability_zone;
        outpost_arn;
        events;
        volume_id;
        volume_status
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_status
              (fun f ->
                 Query.Pair ("VolumeStatus", (VolumeStatusInfo.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Some
             (Query.Pair
                ("EventsSet", (VolumeStatusEventsList.to_query v.events)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Some
             (Query.Pair
                ("ActionsSet", (VolumeStatusActionsList.to_query v.actions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_status
              (fun f -> ("volume_status", (VolumeStatusInfo.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)));
           Some ("events", (VolumeStatusEventsList.to_json v.events));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Some ("actions", (VolumeStatusActionsList.to_json v.actions))])
    let parse xml =
      Some
        {
          actions =
            (Util.of_option []
               (Util.option_bind (Xml.member "actionsSet" xml)
                  VolumeStatusActionsList.parse));
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          events =
            (Util.of_option []
               (Util.option_bind (Xml.member "eventsSet" xml)
                  VolumeStatusEventsList.parse));
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          volume_status =
            (Util.option_bind (Xml.member "volumeStatus" xml)
               VolumeStatusInfo.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "actionsSet"
                           ([], (VolumeStatusActionsList.to_xml [x]))))
                   v.actions))
               @
               [Util.option_map v.availability_zone
                  (fun f ->
                     Ezxmlm.make_tag "availabilityZone"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.outpost_arn
                 (fun f ->
                    Ezxmlm.make_tag "outpostArn" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "eventsSet"
                        ([], (VolumeStatusEventsList.to_xml [x])))) v.events))
            @
            [Util.option_map v.volume_id
               (fun f -> Ezxmlm.make_tag "volumeId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.volume_status
              (fun f ->
                 Ezxmlm.make_tag "volumeStatus"
                   ([], (VolumeStatusInfo.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the volume status.</p>"]
module TransitGatewayRouteTableAssociation =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option
        [@ocaml.doc "<p>The ID of the attachment.</p>"];
      resource_id: String.t option
        [@ocaml.doc "<p>The ID of the resource.</p>"];
      resource_type: TransitGatewayAttachmentResourceType.t option
        [@ocaml.doc "<p>The resource type.</p>"];
      state: TransitGatewayAssociationState.t option
        [@ocaml.doc "<p>The state of the association.</p>"]}[@@ocaml.doc
                                                              "<p>Describes an association between a route table and a resource attachment.</p>"]
    let make ?transit_gateway_attachment_id  ?resource_id  ?resource_type 
      ?state  () =
      { transit_gateway_attachment_id; resource_id; resource_type; state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayAssociationState.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayAssociationState.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAssociationState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.transit_gateway_attachment_id
                 (fun f ->
                    Ezxmlm.make_tag "transitGatewayAttachmentId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.resource_id
                (fun f ->
                   Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "resourceType"
                    ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (TransitGatewayAssociationState.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an association between a route table and a resource attachment.</p>"]
module HostOffering =
  struct
    type t =
      {
      currency_code: CurrencyCodeValues.t option
        [@ocaml.doc "<p>The currency of the offering.</p>"];
      duration: Integer.t option
        [@ocaml.doc "<p>The duration of the offering (in seconds).</p>"];
      hourly_price: String.t option
        [@ocaml.doc "<p>The hourly price of the offering.</p>"];
      instance_family: String.t option
        [@ocaml.doc "<p>The instance family of the offering.</p>"];
      offering_id: String.t option
        [@ocaml.doc "<p>The ID of the offering.</p>"];
      payment_option: PaymentOption.t option
        [@ocaml.doc "<p>The available payment option.</p>"];
      upfront_price: String.t option
        [@ocaml.doc
          "<p>The upfront price of the offering. Does not apply to No Upfront offerings.</p>"]}
    [@@ocaml.doc
      "<p>Details about the Dedicated Host Reservation offering.</p>"]
    let make ?currency_code  ?duration  ?hourly_price  ?instance_family 
      ?offering_id  ?payment_option  ?upfront_price  () =
      {
        currency_code;
        duration;
        hourly_price;
        instance_family;
        offering_id;
        payment_option;
        upfront_price
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.upfront_price
              (fun f -> Query.Pair ("UpfrontPrice", (String.to_query f)));
           Util.option_map v.payment_option
             (fun f ->
                Query.Pair ("PaymentOption", (PaymentOption.to_query f)));
           Util.option_map v.offering_id
             (fun f -> Query.Pair ("OfferingId", (String.to_query f)));
           Util.option_map v.instance_family
             (fun f -> Query.Pair ("InstanceFamily", (String.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Integer.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.upfront_price
              (fun f -> ("upfront_price", (String.to_json f)));
           Util.option_map v.payment_option
             (fun f -> ("payment_option", (PaymentOption.to_json f)));
           Util.option_map v.offering_id
             (fun f -> ("offering_id", (String.to_json f)));
           Util.option_map v.instance_family
             (fun f -> ("instance_family", (String.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Integer.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)))])
    let parse xml =
      Some
        {
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Integer.parse);
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          instance_family =
            (Util.option_bind (Xml.member "instanceFamily" xml) String.parse);
          offering_id =
            (Util.option_bind (Xml.member "offeringId" xml) String.parse);
          payment_option =
            (Util.option_bind (Xml.member "paymentOption" xml)
               PaymentOption.parse);
          upfront_price =
            (Util.option_bind (Xml.member "upfrontPrice" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.currency_code
                    (fun f ->
                       Ezxmlm.make_tag "currencyCode"
                         ([], (CurrencyCodeValues.to_xml f)))])
                @
                [Util.option_map v.duration
                   (fun f ->
                      Ezxmlm.make_tag "duration" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.hourly_price
                  (fun f ->
                     Ezxmlm.make_tag "hourlyPrice" ([], (String.to_xml f)))])
              @
              [Util.option_map v.instance_family
                 (fun f ->
                    Ezxmlm.make_tag "instanceFamily" ([], (String.to_xml f)))])
             @
             [Util.option_map v.offering_id
                (fun f ->
                   Ezxmlm.make_tag "offeringId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.payment_option
               (fun f ->
                  Ezxmlm.make_tag "paymentOption"
                    ([], (PaymentOption.to_xml f)))])
           @
           [Util.option_map v.upfront_price
              (fun f ->
                 Ezxmlm.make_tag "upfrontPrice" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Details about the Dedicated Host Reservation offering.</p>"]
module TransitGatewayRouteTable =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway route table.</p>"];
      transit_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway.</p>"];
      state: TransitGatewayRouteTableState.t option
        [@ocaml.doc "<p>The state of the transit gateway route table.</p>"];
      default_association_route_table: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether this is the default association route table for the transit gateway.</p>"];
      default_propagation_route_table: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether this is the default propagation route table for the transit gateway.</p>"];
      creation_time: DateTime.t option
        [@ocaml.doc "<p>The creation time.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags assigned to the route table.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes a transit gateway route table.</p>"]
    let make ?transit_gateway_route_table_id  ?transit_gateway_id  ?state 
      ?default_association_route_table  ?default_propagation_route_table 
      ?creation_time  ?(tags= [])  () =
      {
        transit_gateway_route_table_id;
        transit_gateway_id;
        state;
        default_association_route_table;
        default_propagation_route_table;
        creation_time;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Util.option_map v.default_propagation_route_table
             (fun f ->
                Query.Pair
                  ("DefaultPropagationRouteTable", (Boolean.to_query f)));
           Util.option_map v.default_association_route_table
             (fun f ->
                Query.Pair
                  ("DefaultAssociationRouteTable", (Boolean.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (TransitGatewayRouteTableState.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayRouteTableId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Util.option_map v.default_propagation_route_table
             (fun f ->
                ("default_propagation_route_table", (Boolean.to_json f)));
           Util.option_map v.default_association_route_table
             (fun f ->
                ("default_association_route_table", (Boolean.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (TransitGatewayRouteTableState.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f -> ("transit_gateway_route_table_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Util.option_bind (Xml.member "transitGatewayRouteTableId" xml)
               String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayRouteTableState.parse);
          default_association_route_table =
            (Util.option_bind (Xml.member "defaultAssociationRouteTable" xml)
               Boolean.parse);
          default_propagation_route_table =
            (Util.option_bind (Xml.member "defaultPropagationRouteTable" xml)
               Boolean.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.transit_gateway_route_table_id
                    (fun f ->
                       Ezxmlm.make_tag "transitGatewayRouteTableId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.transit_gateway_id
                   (fun f ->
                      Ezxmlm.make_tag "transitGatewayId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.state
                  (fun f ->
                     Ezxmlm.make_tag "state"
                       ([], (TransitGatewayRouteTableState.to_xml f)))])
              @
              [Util.option_map v.default_association_route_table
                 (fun f ->
                    Ezxmlm.make_tag "defaultAssociationRouteTable"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.default_propagation_route_table
                (fun f ->
                   Ezxmlm.make_tag "defaultPropagationRouteTable"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.creation_time
               (fun f ->
                  Ezxmlm.make_tag "creationTime" ([], (DateTime.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a transit gateway route table.</p>"]
module AuthorizationRule =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option
        [@ocaml.doc
          "<p>The ID of the Client VPN endpoint with which the authorization rule is associated.</p>"];
      description: String.t option
        [@ocaml.doc "<p>A brief description of the authorization rule.</p>"];
      group_id: String.t option
        [@ocaml.doc
          "<p>The ID of the Active Directory group to which the authorization rule grants access.</p>"];
      access_all: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the authorization rule grants access to all clients.</p>"];
      destination_cidr: String.t option
        [@ocaml.doc
          "<p>The IPv4 address range, in CIDR notation, of the network to which the authorization rule applies.</p>"];
      status: ClientVpnAuthorizationRuleStatus.t option
        [@ocaml.doc "<p>The current state of the authorization rule.</p>"]}
    [@@ocaml.doc "<p>Information about an authorization rule.</p>"]
    let make ?client_vpn_endpoint_id  ?description  ?group_id  ?access_all 
      ?destination_cidr  ?status  () =
      {
        client_vpn_endpoint_id;
        description;
        group_id;
        access_all;
        destination_cidr;
        status
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair
                   ("Status", (ClientVpnAuthorizationRuleStatus.to_query f)));
           Util.option_map v.destination_cidr
             (fun f -> Query.Pair ("DestinationCidr", (String.to_query f)));
           Util.option_map v.access_all
             (fun f -> Query.Pair ("AccessAll", (Boolean.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 ("status", (ClientVpnAuthorizationRuleStatus.to_json f)));
           Util.option_map v.destination_cidr
             (fun f -> ("destination_cidr", (String.to_json f)));
           Util.option_map v.access_all
             (fun f -> ("access_all", (Boolean.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          access_all =
            (Util.option_bind (Xml.member "accessAll" xml) Boolean.parse);
          destination_cidr =
            (Util.option_bind (Xml.member "destinationCidr" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnAuthorizationRuleStatus.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.client_vpn_endpoint_id
                   (fun f ->
                      Ezxmlm.make_tag "clientVpnEndpointId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.description
                  (fun f ->
                     Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
              @
              [Util.option_map v.group_id
                 (fun f -> Ezxmlm.make_tag "groupId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.access_all
                (fun f ->
                   Ezxmlm.make_tag "accessAll" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.destination_cidr
               (fun f ->
                  Ezxmlm.make_tag "destinationCidr" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status"
                   ([], (ClientVpnAuthorizationRuleStatus.to_xml f)))])
  end[@@ocaml.doc "<p>Information about an authorization rule.</p>"]
module TransitGatewayMulticastDomainAssociation =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway attachment.</p>"];
      resource_id: String.t option
        [@ocaml.doc "<p>The ID of the resource.</p>"];
      resource_type: TransitGatewayAttachmentResourceType.t option
        [@ocaml.doc
          "<p>The type of resource, for example a VPC attachment.</p>"];
      subnet: SubnetAssociation.t option
        [@ocaml.doc
          "<p>The subnet associated with the transit gateway multicast domain.</p>"]}
    [@@ocaml.doc
      "<p>Describes the resources associated with the transit gateway multicast domain.</p>"]
    let make ?transit_gateway_attachment_id  ?resource_id  ?resource_type 
      ?subnet  () =
      { transit_gateway_attachment_id; resource_id; resource_type; subnet }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> Query.Pair ("Subnet", (SubnetAssociation.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> ("subnet", (SubnetAssociation.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          subnet =
            (Util.option_bind (Xml.member "subnet" xml)
               SubnetAssociation.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.transit_gateway_attachment_id
                 (fun f ->
                    Ezxmlm.make_tag "transitGatewayAttachmentId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.resource_id
                (fun f ->
                   Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "resourceType"
                    ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
           @
           [Util.option_map v.subnet
              (fun f ->
                 Ezxmlm.make_tag "subnet" ([], (SubnetAssociation.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the resources associated with the transit gateway multicast domain.</p>"]
module TrafficMirrorSessionField =
  struct
    type t =
      | Packet_length 
      | Description 
      | Virtual_network_id 
    let str_to_t =
      [("virtual-network-id", Virtual_network_id);
      ("description", Description);
      ("packet-length", Packet_length)]
    let t_to_str =
      [(Virtual_network_id, "virtual-network-id");
      (Description, "description");
      (Packet_length, "packet-length")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module SuccessfulInstanceCreditSpecificationItem =
  struct
    type t =
      {
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"]}[@@ocaml.doc
                                                        "<p>Describes the burstable performance instance whose credit option for CPU usage was successfully modified.</p>"]
    let make ?instance_id  () = { instance_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> ("instance_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.instance_id
              (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the burstable performance instance whose credit option for CPU usage was successfully modified.</p>"]
module UnsuccessfulInstanceCreditSpecificationItem =
  struct
    type t =
      {
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"];
      error: UnsuccessfulInstanceCreditSpecificationItemError.t option
        [@ocaml.doc
          "<p>The applicable error for the burstable performance instance whose credit option for CPU usage was not modified.</p>"]}
    [@@ocaml.doc
      "<p>Describes the burstable performance instance whose credit option for CPU usage was not modified.</p>"]
    let make ?instance_id  ?error  () = { instance_id; error }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 Query.Pair
                   ("Error",
                     (UnsuccessfulInstanceCreditSpecificationItemError.to_query
                        f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 ("error",
                   (UnsuccessfulInstanceCreditSpecificationItemError.to_json
                      f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          error =
            (Util.option_bind (Xml.member "error" xml)
               UnsuccessfulInstanceCreditSpecificationItemError.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.error
              (fun f ->
                 Ezxmlm.make_tag "error"
                   ([],
                     (UnsuccessfulInstanceCreditSpecificationItemError.to_xml
                        f)))])
  end[@@ocaml.doc
       "<p>Describes the burstable performance instance whose credit option for CPU usage was not modified.</p>"]
module ReservedInstancesOffering =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc
          "<p>The Availability Zone in which the Reserved Instance can be used.</p>"];
      duration: Long.t option
        [@ocaml.doc
          "<p>The duration of the Reserved Instance, in seconds.</p>"];
      fixed_price: Float.t option
        [@ocaml.doc "<p>The purchase price of the Reserved Instance.</p>"];
      instance_type: InstanceType.t option
        [@ocaml.doc
          "<p>The instance type on which the Reserved Instance can be used.</p>"];
      product_description: RIProductDescription.t option
        [@ocaml.doc
          "<p>The Reserved Instance product platform description.</p>"];
      reserved_instances_offering_id: String.t option
        [@ocaml.doc
          "<p>The ID of the Reserved Instance offering. This is the offering ID used in <a>GetReservedInstancesExchangeQuote</a> to confirm that an exchange can be made.</p>"];
      usage_price: Float.t option
        [@ocaml.doc
          "<p>The usage price of the Reserved Instance, per hour.</p>"];
      currency_code: CurrencyCodeValues.t option
        [@ocaml.doc
          "<p>The currency of the Reserved Instance offering you are purchasing. It's specified using ISO 4217 standard currency codes. At this time, the only supported currency is <code>USD</code>.</p>"];
      instance_tenancy: Tenancy.t option
        [@ocaml.doc "<p>The tenancy of the instance.</p>"];
      marketplace: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the offering is available through the Reserved Instance Marketplace (resale) or AWS. If it's a Reserved Instance Marketplace offering, this is <code>true</code>.</p>"];
      offering_class: OfferingClassType.t option
        [@ocaml.doc
          "<p>If <code>convertible</code> it can be exchanged for Reserved Instances of the same or higher monetary value, with different configurations. If <code>standard</code>, it is not possible to perform an exchange.</p>"];
      offering_type: OfferingTypeValues.t option
        [@ocaml.doc "<p>The Reserved Instance offering type.</p>"];
      pricing_details: PricingDetailsList.t
        [@ocaml.doc
          "<p>The pricing details of the Reserved Instance offering.</p>"];
      recurring_charges: RecurringChargesList.t
        [@ocaml.doc
          "<p>The recurring charge tag assigned to the resource.</p>"];
      scope: Scope.t option
        [@ocaml.doc
          "<p>Whether the Reserved Instance is applied to instances in a Region or an Availability Zone.</p>"]}
    [@@ocaml.doc "<p>Describes a Reserved Instance offering.</p>"]
    let make ?availability_zone  ?duration  ?fixed_price  ?instance_type 
      ?product_description  ?reserved_instances_offering_id  ?usage_price 
      ?currency_code  ?instance_tenancy  ?marketplace  ?offering_class 
      ?offering_type  ?(pricing_details= [])  ?(recurring_charges= []) 
      ?scope  () =
      {
        availability_zone;
        duration;
        fixed_price;
        instance_type;
        product_description;
        reserved_instances_offering_id;
        usage_price;
        currency_code;
        instance_tenancy;
        marketplace;
        offering_class;
        offering_type;
        pricing_details;
        recurring_charges;
        scope
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.scope
              (fun f -> Query.Pair ("Scope", (Scope.to_query f)));
           Some
             (Query.Pair
                ("RecurringCharges",
                  (RecurringChargesList.to_query v.recurring_charges)));
           Some
             (Query.Pair
                ("PricingDetailsSet",
                  (PricingDetailsList.to_query v.pricing_details)));
           Util.option_map v.offering_type
             (fun f ->
                Query.Pair ("OfferingType", (OfferingTypeValues.to_query f)));
           Util.option_map v.offering_class
             (fun f ->
                Query.Pair ("OfferingClass", (OfferingClassType.to_query f)));
           Util.option_map v.marketplace
             (fun f -> Query.Pair ("Marketplace", (Boolean.to_query f)));
           Util.option_map v.instance_tenancy
             (fun f -> Query.Pair ("InstanceTenancy", (Tenancy.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.usage_price
             (fun f -> Query.Pair ("UsagePrice", (Float.to_query f)));
           Util.option_map v.reserved_instances_offering_id
             (fun f ->
                Query.Pair
                  ("ReservedInstancesOfferingId", (String.to_query f)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.fixed_price
             (fun f -> Query.Pair ("FixedPrice", (Float.to_query f)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Long.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.scope (fun f -> ("scope", (Scope.to_json f)));
           Some
             ("recurring_charges",
               (RecurringChargesList.to_json v.recurring_charges));
           Some
             ("pricing_details",
               (PricingDetailsList.to_json v.pricing_details));
           Util.option_map v.offering_type
             (fun f -> ("offering_type", (OfferingTypeValues.to_json f)));
           Util.option_map v.offering_class
             (fun f -> ("offering_class", (OfferingClassType.to_json f)));
           Util.option_map v.marketplace
             (fun f -> ("marketplace", (Boolean.to_json f)));
           Util.option_map v.instance_tenancy
             (fun f -> ("instance_tenancy", (Tenancy.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.usage_price
             (fun f -> ("usage_price", (Float.to_json f)));
           Util.option_map v.reserved_instances_offering_id
             (fun f -> ("reserved_instances_offering_id", (String.to_json f)));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.fixed_price
             (fun f -> ("fixed_price", (Float.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Long.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Long.parse);
          fixed_price =
            (Util.option_bind (Xml.member "fixedPrice" xml) Float.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          product_description =
            (Util.option_bind (Xml.member "productDescription" xml)
               RIProductDescription.parse);
          reserved_instances_offering_id =
            (Util.option_bind (Xml.member "reservedInstancesOfferingId" xml)
               String.parse);
          usage_price =
            (Util.option_bind (Xml.member "usagePrice" xml) Float.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          instance_tenancy =
            (Util.option_bind (Xml.member "instanceTenancy" xml)
               Tenancy.parse);
          marketplace =
            (Util.option_bind (Xml.member "marketplace" xml) Boolean.parse);
          offering_class =
            (Util.option_bind (Xml.member "offeringClass" xml)
               OfferingClassType.parse);
          offering_type =
            (Util.option_bind (Xml.member "offeringType" xml)
               OfferingTypeValues.parse);
          pricing_details =
            (Util.of_option []
               (Util.option_bind (Xml.member "pricingDetailsSet" xml)
                  PricingDetailsList.parse));
          recurring_charges =
            (Util.of_option []
               (Util.option_bind (Xml.member "recurringCharges" xml)
                  RecurringChargesList.parse));
          scope = (Util.option_bind (Xml.member "scope" xml) Scope.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Util.option_map v.availability_zone
                            (fun f ->
                               Ezxmlm.make_tag "availabilityZone"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.duration
                           (fun f ->
                              Ezxmlm.make_tag "duration"
                                ([], (Long.to_xml f)))])
                       @
                       [Util.option_map v.fixed_price
                          (fun f ->
                             Ezxmlm.make_tag "fixedPrice"
                               ([], (Float.to_xml f)))])
                      @
                      [Util.option_map v.instance_type
                         (fun f ->
                            Ezxmlm.make_tag "instanceType"
                              ([], (InstanceType.to_xml f)))])
                     @
                     [Util.option_map v.product_description
                        (fun f ->
                           Ezxmlm.make_tag "productDescription"
                             ([], (RIProductDescription.to_xml f)))])
                    @
                    [Util.option_map v.reserved_instances_offering_id
                       (fun f ->
                          Ezxmlm.make_tag "reservedInstancesOfferingId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.usage_price
                      (fun f ->
                         Ezxmlm.make_tag "usagePrice" ([], (Float.to_xml f)))])
                  @
                  [Util.option_map v.currency_code
                     (fun f ->
                        Ezxmlm.make_tag "currencyCode"
                          ([], (CurrencyCodeValues.to_xml f)))])
                 @
                 [Util.option_map v.instance_tenancy
                    (fun f ->
                       Ezxmlm.make_tag "instanceTenancy"
                         ([], (Tenancy.to_xml f)))])
                @
                [Util.option_map v.marketplace
                   (fun f ->
                      Ezxmlm.make_tag "marketplace" ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.offering_class
                  (fun f ->
                     Ezxmlm.make_tag "offeringClass"
                       ([], (OfferingClassType.to_xml f)))])
              @
              [Util.option_map v.offering_type
                 (fun f ->
                    Ezxmlm.make_tag "offeringType"
                      ([], (OfferingTypeValues.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "pricingDetailsSet"
                        ([], (PricingDetailsList.to_xml [x]))))
                v.pricing_details))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "recurringCharges"
                       ([], (RecurringChargesList.to_xml [x]))))
               v.recurring_charges))
           @
           [Util.option_map v.scope
              (fun f -> Ezxmlm.make_tag "scope" ([], (Scope.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a Reserved Instance offering.</p>"]
module ScheduledInstanceAvailability =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc "<p>The Availability Zone.</p>"];
      available_instance_count: Integer.t option
        [@ocaml.doc "<p>The number of available instances.</p>"];
      first_slot_start_time: DateTime.t option
        [@ocaml.doc
          "<p>The time period for the first schedule to start.</p>"];
      hourly_price: String.t option
        [@ocaml.doc "<p>The hourly price for a single instance.</p>"];
      instance_type: String.t option
        [@ocaml.doc
          "<p>The instance type. You can specify one of the C3, C4, M4, or R3 instance types.</p>"];
      max_term_duration_in_days: Integer.t option
        [@ocaml.doc
          "<p>The maximum term. The only possible value is 365 days.</p>"];
      min_term_duration_in_days: Integer.t option
        [@ocaml.doc
          "<p>The minimum term. The only possible value is 365 days.</p>"];
      network_platform: String.t option
        [@ocaml.doc
          "<p>The network platform (<code>EC2-Classic</code> or <code>EC2-VPC</code>).</p>"];
      platform: String.t option
        [@ocaml.doc
          "<p>The platform (<code>Linux/UNIX</code> or <code>Windows</code>).</p>"];
      purchase_token: String.t option
        [@ocaml.doc
          "<p>The purchase token. This token expires in two hours.</p>"];
      recurrence: ScheduledInstanceRecurrence.t option
        [@ocaml.doc "<p>The schedule recurrence.</p>"];
      slot_duration_in_hours: Integer.t option
        [@ocaml.doc "<p>The number of hours in the schedule.</p>"];
      total_scheduled_instance_hours: Integer.t option
        [@ocaml.doc
          "<p>The total number of hours for a single instance for the entire term.</p>"]}
    [@@ocaml.doc
      "<p>Describes a schedule that is available for your Scheduled Instances.</p>"]
    let make ?availability_zone  ?available_instance_count 
      ?first_slot_start_time  ?hourly_price  ?instance_type 
      ?max_term_duration_in_days  ?min_term_duration_in_days 
      ?network_platform  ?platform  ?purchase_token  ?recurrence 
      ?slot_duration_in_hours  ?total_scheduled_instance_hours  () =
      {
        availability_zone;
        available_instance_count;
        first_slot_start_time;
        hourly_price;
        instance_type;
        max_term_duration_in_days;
        min_term_duration_in_days;
        network_platform;
        platform;
        purchase_token;
        recurrence;
        slot_duration_in_hours;
        total_scheduled_instance_hours
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_scheduled_instance_hours
              (fun f ->
                 Query.Pair
                   ("TotalScheduledInstanceHours", (Integer.to_query f)));
           Util.option_map v.slot_duration_in_hours
             (fun f ->
                Query.Pair ("SlotDurationInHours", (Integer.to_query f)));
           Util.option_map v.recurrence
             (fun f ->
                Query.Pair
                  ("Recurrence", (ScheduledInstanceRecurrence.to_query f)));
           Util.option_map v.purchase_token
             (fun f -> Query.Pair ("PurchaseToken", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.network_platform
             (fun f -> Query.Pair ("NetworkPlatform", (String.to_query f)));
           Util.option_map v.min_term_duration_in_days
             (fun f ->
                Query.Pair ("MinTermDurationInDays", (Integer.to_query f)));
           Util.option_map v.max_term_duration_in_days
             (fun f ->
                Query.Pair ("MaxTermDurationInDays", (Integer.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)));
           Util.option_map v.first_slot_start_time
             (fun f ->
                Query.Pair ("FirstSlotStartTime", (DateTime.to_query f)));
           Util.option_map v.available_instance_count
             (fun f ->
                Query.Pair ("AvailableInstanceCount", (Integer.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_scheduled_instance_hours
              (fun f ->
                 ("total_scheduled_instance_hours", (Integer.to_json f)));
           Util.option_map v.slot_duration_in_hours
             (fun f -> ("slot_duration_in_hours", (Integer.to_json f)));
           Util.option_map v.recurrence
             (fun f ->
                ("recurrence", (ScheduledInstanceRecurrence.to_json f)));
           Util.option_map v.purchase_token
             (fun f -> ("purchase_token", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.network_platform
             (fun f -> ("network_platform", (String.to_json f)));
           Util.option_map v.min_term_duration_in_days
             (fun f -> ("min_term_duration_in_days", (Integer.to_json f)));
           Util.option_map v.max_term_duration_in_days
             (fun f -> ("max_term_duration_in_days", (Integer.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)));
           Util.option_map v.first_slot_start_time
             (fun f -> ("first_slot_start_time", (DateTime.to_json f)));
           Util.option_map v.available_instance_count
             (fun f -> ("available_instance_count", (Integer.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          available_instance_count =
            (Util.option_bind (Xml.member "availableInstanceCount" xml)
               Integer.parse);
          first_slot_start_time =
            (Util.option_bind (Xml.member "firstSlotStartTime" xml)
               DateTime.parse);
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          max_term_duration_in_days =
            (Util.option_bind (Xml.member "maxTermDurationInDays" xml)
               Integer.parse);
          min_term_duration_in_days =
            (Util.option_bind (Xml.member "minTermDurationInDays" xml)
               Integer.parse);
          network_platform =
            (Util.option_bind (Xml.member "networkPlatform" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          purchase_token =
            (Util.option_bind (Xml.member "purchaseToken" xml) String.parse);
          recurrence =
            (Util.option_bind (Xml.member "recurrence" xml)
               ScheduledInstanceRecurrence.parse);
          slot_duration_in_hours =
            (Util.option_bind (Xml.member "slotDurationInHours" xml)
               Integer.parse);
          total_scheduled_instance_hours =
            (Util.option_bind (Xml.member "totalScheduledInstanceHours" xml)
               Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.availability_zone
                          (fun f ->
                             Ezxmlm.make_tag "availabilityZone"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.available_instance_count
                         (fun f ->
                            Ezxmlm.make_tag "availableInstanceCount"
                              ([], (Integer.to_xml f)))])
                     @
                     [Util.option_map v.first_slot_start_time
                        (fun f ->
                           Ezxmlm.make_tag "firstSlotStartTime"
                             ([], (DateTime.to_xml f)))])
                    @
                    [Util.option_map v.hourly_price
                       (fun f ->
                          Ezxmlm.make_tag "hourlyPrice"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.instance_type
                      (fun f ->
                         Ezxmlm.make_tag "instanceType"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.max_term_duration_in_days
                     (fun f ->
                        Ezxmlm.make_tag "maxTermDurationInDays"
                          ([], (Integer.to_xml f)))])
                 @
                 [Util.option_map v.min_term_duration_in_days
                    (fun f ->
                       Ezxmlm.make_tag "minTermDurationInDays"
                         ([], (Integer.to_xml f)))])
                @
                [Util.option_map v.network_platform
                   (fun f ->
                      Ezxmlm.make_tag "networkPlatform"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.platform
                  (fun f ->
                     Ezxmlm.make_tag "platform" ([], (String.to_xml f)))])
              @
              [Util.option_map v.purchase_token
                 (fun f ->
                    Ezxmlm.make_tag "purchaseToken" ([], (String.to_xml f)))])
             @
             [Util.option_map v.recurrence
                (fun f ->
                   Ezxmlm.make_tag "recurrence"
                     ([], (ScheduledInstanceRecurrence.to_xml f)))])
            @
            [Util.option_map v.slot_duration_in_hours
               (fun f ->
                  Ezxmlm.make_tag "slotDurationInHours"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.total_scheduled_instance_hours
              (fun f ->
                 Ezxmlm.make_tag "totalScheduledInstanceHours"
                   ([], (Integer.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a schedule that is available for your Scheduled Instances.</p>"]
module Reservation =
  struct
    type t =
      {
      groups: GroupIdentifierList.t
        [@ocaml.doc "<p>[EC2-Classic only] The security groups.</p>"];
      instances: InstanceList.t [@ocaml.doc "<p>The instances.</p>"];
      owner_id: String.t
        [@ocaml.doc
          "<p>The ID of the AWS account that owns the reservation.</p>"];
      requester_id: String.t option
        [@ocaml.doc
          "<p>The ID of the requester that launched the instances on your behalf (for example, AWS Management Console or Auto Scaling).</p>"];
      reservation_id: String.t
        [@ocaml.doc "<p>The ID of the reservation.</p>"]}[@@ocaml.doc
                                                           "<p>Describes a reservation.</p>"]
    let make ?(groups= [])  ?(instances= [])  ~owner_id  ?requester_id 
      ~reservation_id  () =
      { groups; instances; owner_id; requester_id; reservation_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservationId", (String.to_query v.reservation_id)));
           Util.option_map v.requester_id
             (fun f -> Query.Pair ("RequesterId", (String.to_query f)));
           Some (Query.Pair ("OwnerId", (String.to_query v.owner_id)));
           Some
             (Query.Pair
                ("InstancesSet", (InstanceList.to_query v.instances)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("reservation_id", (String.to_json v.reservation_id));
           Util.option_map v.requester_id
             (fun f -> ("requester_id", (String.to_json f)));
           Some ("owner_id", (String.to_json v.owner_id));
           Some ("instances", (InstanceList.to_json v.instances));
           Some ("groups", (GroupIdentifierList.to_json v.groups))])
    let parse xml =
      Some
        {
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceList.parse));
          owner_id =
            (Xml.required "ownerId"
               (Util.option_bind (Xml.member "ownerId" xml) String.parse));
          requester_id =
            (Util.option_bind (Xml.member "requesterId" xml) String.parse);
          reservation_id =
            (Xml.required "reservationId"
               (Util.option_bind (Xml.member "reservationId" xml)
                  String.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "groupSet"
                          ([], (GroupIdentifierList.to_xml [x])))) v.groups))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "instancesSet"
                         ([], (InstanceList.to_xml [x])))) v.instances))
             @
             [Some
                (Ezxmlm.make_tag "ownerId" ([], (String.to_xml v.owner_id)))])
            @
            [Util.option_map v.requester_id
               (fun f ->
                  Ezxmlm.make_tag "requesterId" ([], (String.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "reservationId"
                 ([], (String.to_xml v.reservation_id)))])
  end[@@ocaml.doc "<p>Describes a reservation.</p>"]
module PublicIpv4Pool =
  struct
    type t =
      {
      pool_id: String.t option
        [@ocaml.doc "<p>The ID of the IPv4 address pool.</p>"];
      description: String.t option
        [@ocaml.doc "<p>A description of the address pool.</p>"];
      pool_address_ranges: PublicIpv4PoolRangeSet.t
        [@ocaml.doc "<p>The address ranges.</p>"];
      total_address_count: Integer.t option
        [@ocaml.doc "<p>The total number of addresses.</p>"];
      total_available_address_count: Integer.t option
        [@ocaml.doc "<p>The total number of available addresses.</p>"]}
    [@@ocaml.doc "<p>Describes an address pool.</p>"]
    let make ?pool_id  ?description  ?(pool_address_ranges= []) 
      ?total_address_count  ?total_available_address_count  () =
      {
        pool_id;
        description;
        pool_address_ranges;
        total_address_count;
        total_available_address_count
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_available_address_count
              (fun f ->
                 Query.Pair
                   ("TotalAvailableAddressCount", (Integer.to_query f)));
           Util.option_map v.total_address_count
             (fun f -> Query.Pair ("TotalAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PoolAddressRangeSet",
                  (PublicIpv4PoolRangeSet.to_query v.pool_address_ranges)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.pool_id
             (fun f -> Query.Pair ("PoolId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_available_address_count
              (fun f ->
                 ("total_available_address_count", (Integer.to_json f)));
           Util.option_map v.total_address_count
             (fun f -> ("total_address_count", (Integer.to_json f)));
           Some
             ("pool_address_ranges",
               (PublicIpv4PoolRangeSet.to_json v.pool_address_ranges));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.pool_id
             (fun f -> ("pool_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          pool_id = (Util.option_bind (Xml.member "poolId" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          pool_address_ranges =
            (Util.of_option []
               (Util.option_bind (Xml.member "poolAddressRangeSet" xml)
                  PublicIpv4PoolRangeSet.parse));
          total_address_count =
            (Util.option_bind (Xml.member "totalAddressCount" xml)
               Integer.parse);
          total_available_address_count =
            (Util.option_bind (Xml.member "totalAvailableAddressCount" xml)
               Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.pool_id
                  (fun f -> Ezxmlm.make_tag "poolId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "poolAddressRangeSet"
                        ([], (PublicIpv4PoolRangeSet.to_xml [x]))))
                v.pool_address_ranges))
            @
            [Util.option_map v.total_address_count
               (fun f ->
                  Ezxmlm.make_tag "totalAddressCount"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.total_available_address_count
              (fun f ->
                 Ezxmlm.make_tag "totalAvailableAddressCount"
                   ([], (Integer.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an address pool.</p>"]
module Vpc =
  struct
    type t =
      {
      cidr_block: String.t
        [@ocaml.doc "<p>The primary IPv4 CIDR block for the VPC.</p>"];
      dhcp_options_id: String.t
        [@ocaml.doc
          "<p>The ID of the set of DHCP options you've associated with the VPC (or <code>default</code> if the default options are associated with the VPC).</p>"];
      state: VpcState.t [@ocaml.doc "<p>The current state of the VPC.</p>"];
      vpc_id: String.t [@ocaml.doc "<p>The ID of the VPC.</p>"];
      owner_id: String.t option
        [@ocaml.doc "<p>The ID of the AWS account that owns the VPC.</p>"];
      instance_tenancy: Tenancy.t
        [@ocaml.doc
          "<p>The allowed tenancy of instances launched into the VPC.</p>"];
      ipv6_cidr_block_association_set: VpcIpv6CidrBlockAssociationSet.t
        [@ocaml.doc
          "<p>Information about the IPv6 CIDR blocks associated with the VPC.</p>"];
      cidr_block_association_set: VpcCidrBlockAssociationSet.t
        [@ocaml.doc
          "<p>Information about the IPv4 CIDR blocks associated with the VPC.</p>"];
      is_default: Boolean.t
        [@ocaml.doc "<p>Indicates whether the VPC is the default VPC.</p>"];
      tags: TagList.t [@ocaml.doc "<p>Any tags assigned to the VPC.</p>"]}
    [@@ocaml.doc "<p>Describes a VPC.</p>"]
    let make ~cidr_block  ~dhcp_options_id  ~state  ~vpc_id  ?owner_id 
      ~instance_tenancy  ?(ipv6_cidr_block_association_set= []) 
      ?(cidr_block_association_set= [])  ~is_default  ?(tags= [])  () =
      {
        cidr_block;
        dhcp_options_id;
        state;
        vpc_id;
        owner_id;
        instance_tenancy;
        ipv6_cidr_block_association_set;
        cidr_block_association_set;
        is_default;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some (Query.Pair ("IsDefault", (Boolean.to_query v.is_default)));
           Some
             (Query.Pair
                ("CidrBlockAssociationSet",
                  (VpcCidrBlockAssociationSet.to_query
                     v.cidr_block_association_set)));
           Some
             (Query.Pair
                ("Ipv6CidrBlockAssociationSet",
                  (VpcIpv6CidrBlockAssociationSet.to_query
                     v.ipv6_cidr_block_association_set)));
           Some
             (Query.Pair
                ("InstanceTenancy", (Tenancy.to_query v.instance_tenancy)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some (Query.Pair ("State", (VpcState.to_query v.state)));
           Some
             (Query.Pair
                ("DhcpOptionsId", (String.to_query v.dhcp_options_id)));
           Some (Query.Pair ("CidrBlock", (String.to_query v.cidr_block)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some ("is_default", (Boolean.to_json v.is_default));
           Some
             ("cidr_block_association_set",
               (VpcCidrBlockAssociationSet.to_json
                  v.cidr_block_association_set));
           Some
             ("ipv6_cidr_block_association_set",
               (VpcIpv6CidrBlockAssociationSet.to_json
                  v.ipv6_cidr_block_association_set));
           Some ("instance_tenancy", (Tenancy.to_json v.instance_tenancy));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("state", (VpcState.to_json v.state));
           Some ("dhcp_options_id", (String.to_json v.dhcp_options_id));
           Some ("cidr_block", (String.to_json v.cidr_block))])
    let parse xml =
      Some
        {
          cidr_block =
            (Xml.required "cidrBlock"
               (Util.option_bind (Xml.member "cidrBlock" xml) String.parse));
          dhcp_options_id =
            (Xml.required "dhcpOptionsId"
               (Util.option_bind (Xml.member "dhcpOptionsId" xml)
                  String.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml) VpcState.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse));
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          instance_tenancy =
            (Xml.required "instanceTenancy"
               (Util.option_bind (Xml.member "instanceTenancy" xml)
                  Tenancy.parse));
          ipv6_cidr_block_association_set =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ipv6CidrBlockAssociationSet" xml)
                  VpcIpv6CidrBlockAssociationSet.parse));
          cidr_block_association_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "cidrBlockAssociationSet" xml)
                  VpcCidrBlockAssociationSet.parse));
          is_default =
            (Xml.required "isDefault"
               (Util.option_bind (Xml.member "isDefault" xml) Boolean.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Some
                       (Ezxmlm.make_tag "cidrBlock"
                          ([], (String.to_xml v.cidr_block)))])
                   @
                   [Some
                      (Ezxmlm.make_tag "dhcpOptionsId"
                         ([], (String.to_xml v.dhcp_options_id)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "state" ([], (VpcState.to_xml v.state)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "vpcId" ([], (String.to_xml v.vpc_id)))])
                @
                [Util.option_map v.owner_id
                   (fun f ->
                      Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
               @
               [Some
                  (Ezxmlm.make_tag "instanceTenancy"
                     ([], (Tenancy.to_xml v.instance_tenancy)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "ipv6CidrBlockAssociationSet"
                         ([], (VpcIpv6CidrBlockAssociationSet.to_xml [x]))))
                 v.ipv6_cidr_block_association_set))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "cidrBlockAssociationSet"
                        ([], (VpcCidrBlockAssociationSet.to_xml [x]))))
                v.cidr_block_association_set))
            @
            [Some
               (Ezxmlm.make_tag "isDefault"
                  ([], (Boolean.to_xml v.is_default)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a VPC.</p>"]
module LocalGateway =
  struct
    type t =
      {
      local_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the local gateway.</p>"];
      outpost_arn: String.t option
        [@ocaml.doc "<p>The Amazon Resource Name (ARN) of the Outpost.</p>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account ID that owns the local gateway.</p>"];
      state: String.t option
        [@ocaml.doc "<p>The state of the local gateway.</p>"]}[@@ocaml.doc
                                                                "<p>Describes a local gateway.</p>"]
    let make ?local_gateway_id  ?outpost_arn  ?owner_id  ?state  () =
      { local_gateway_id; outpost_arn; owner_id; state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.local_gateway_id
                 (fun f ->
                    Ezxmlm.make_tag "localGatewayId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.outpost_arn
                (fun f ->
                   Ezxmlm.make_tag "outpostArn" ([], (String.to_xml f)))])
            @
            [Util.option_map v.owner_id
               (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f -> Ezxmlm.make_tag "state" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a local gateway.</p>"]
module Subnet =
  struct
    type t =
      {
      availability_zone: String.t
        [@ocaml.doc "<p>The Availability Zone of the subnet.</p>"];
      availability_zone_id: String.t option
        [@ocaml.doc "<p>The AZ ID of the subnet.</p>"];
      available_ip_address_count: Integer.t
        [@ocaml.doc
          "<p>The number of unused private IPv4 addresses in the subnet. The IPv4 addresses for any stopped instances are considered unavailable.</p>"];
      cidr_block: String.t
        [@ocaml.doc "<p>The IPv4 CIDR block assigned to the subnet.</p>"];
      default_for_az: Boolean.t
        [@ocaml.doc
          "<p>Indicates whether this is the default subnet for the Availability Zone.</p>"];
      map_public_ip_on_launch: Boolean.t
        [@ocaml.doc
          "<p>Indicates whether instances launched in this subnet receive a public IPv4 address.</p>"];
      state: SubnetState.t
        [@ocaml.doc "<p>The current state of the subnet.</p>"];
      subnet_id: String.t [@ocaml.doc "<p>The ID of the subnet.</p>"];
      vpc_id: String.t
        [@ocaml.doc "<p>The ID of the VPC the subnet is in.</p>"];
      owner_id: String.t option
        [@ocaml.doc "<p>The ID of the AWS account that owns the subnet.</p>"];
      assign_ipv6_address_on_creation: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether a network interface created in this subnet (including a network interface created by <a>RunInstances</a>) receives an IPv6 address.</p>"];
      ipv6_cidr_block_association_set: SubnetIpv6CidrBlockAssociationSet.t
        [@ocaml.doc
          "<p>Information about the IPv6 CIDR blocks associated with the subnet.</p>"];
      tags: TagList.t [@ocaml.doc "<p>Any tags assigned to the subnet.</p>"];
      subnet_arn: String.t option
        [@ocaml.doc "<p>The Amazon Resource Name (ARN) of the subnet.</p>"];
      outpost_arn: String.t option
        [@ocaml.doc "<p>The Amazon Resource Name (ARN) of the Outpost.</p>"]}
    [@@ocaml.doc "<p>Describes a subnet.</p>"]
    let make ~availability_zone  ?availability_zone_id 
      ~available_ip_address_count  ~cidr_block  ~default_for_az 
      ~map_public_ip_on_launch  ~state  ~subnet_id  ~vpc_id  ?owner_id 
      ?assign_ipv6_address_on_creation  ?(ipv6_cidr_block_association_set=
      [])  ?(tags= [])  ?subnet_arn  ?outpost_arn  () =
      {
        availability_zone;
        availability_zone_id;
        available_ip_address_count;
        cidr_block;
        default_for_az;
        map_public_ip_on_launch;
        state;
        subnet_id;
        vpc_id;
        owner_id;
        assign_ipv6_address_on_creation;
        ipv6_cidr_block_association_set;
        tags;
        subnet_arn;
        outpost_arn
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.outpost_arn
              (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.subnet_arn
             (fun f -> Query.Pair ("SubnetArn", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("Ipv6CidrBlockAssociationSet",
                  (SubnetIpv6CidrBlockAssociationSet.to_query
                     v.ipv6_cidr_block_association_set)));
           Util.option_map v.assign_ipv6_address_on_creation
             (fun f ->
                Query.Pair
                  ("AssignIpv6AddressOnCreation", (Boolean.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)));
           Some (Query.Pair ("State", (SubnetState.to_query v.state)));
           Some
             (Query.Pair
                ("MapPublicIpOnLaunch",
                  (Boolean.to_query v.map_public_ip_on_launch)));
           Some
             (Query.Pair
                ("DefaultForAz", (Boolean.to_query v.default_for_az)));
           Some (Query.Pair ("CidrBlock", (String.to_query v.cidr_block)));
           Some
             (Query.Pair
                ("AvailableIpAddressCount",
                  (Integer.to_query v.available_ip_address_count)));
           Util.option_map v.availability_zone_id
             (fun f -> Query.Pair ("AvailabilityZoneId", (String.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.outpost_arn
              (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.subnet_arn
             (fun f -> ("subnet_arn", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Some
             ("ipv6_cidr_block_association_set",
               (SubnetIpv6CidrBlockAssociationSet.to_json
                  v.ipv6_cidr_block_association_set));
           Util.option_map v.assign_ipv6_address_on_creation
             (fun f ->
                ("assign_ipv6_address_on_creation", (Boolean.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("subnet_id", (String.to_json v.subnet_id));
           Some ("state", (SubnetState.to_json v.state));
           Some
             ("map_public_ip_on_launch",
               (Boolean.to_json v.map_public_ip_on_launch));
           Some ("default_for_az", (Boolean.to_json v.default_for_az));
           Some ("cidr_block", (String.to_json v.cidr_block));
           Some
             ("available_ip_address_count",
               (Integer.to_json v.available_ip_address_count));
           Util.option_map v.availability_zone_id
             (fun f -> ("availability_zone_id", (String.to_json f)));
           Some ("availability_zone", (String.to_json v.availability_zone))])
    let parse xml =
      Some
        {
          availability_zone =
            (Xml.required "availabilityZone"
               (Util.option_bind (Xml.member "availabilityZone" xml)
                  String.parse));
          availability_zone_id =
            (Util.option_bind (Xml.member "availabilityZoneId" xml)
               String.parse);
          available_ip_address_count =
            (Xml.required "availableIpAddressCount"
               (Util.option_bind (Xml.member "availableIpAddressCount" xml)
                  Integer.parse));
          cidr_block =
            (Xml.required "cidrBlock"
               (Util.option_bind (Xml.member "cidrBlock" xml) String.parse));
          default_for_az =
            (Xml.required "defaultForAz"
               (Util.option_bind (Xml.member "defaultForAz" xml)
                  Boolean.parse));
          map_public_ip_on_launch =
            (Xml.required "mapPublicIpOnLaunch"
               (Util.option_bind (Xml.member "mapPublicIpOnLaunch" xml)
                  Boolean.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml) SubnetState.parse));
          subnet_id =
            (Xml.required "subnetId"
               (Util.option_bind (Xml.member "subnetId" xml) String.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse));
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          assign_ipv6_address_on_creation =
            (Util.option_bind (Xml.member "assignIpv6AddressOnCreation" xml)
               Boolean.parse);
          ipv6_cidr_block_association_set =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ipv6CidrBlockAssociationSet" xml)
                  SubnetIpv6CidrBlockAssociationSet.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          subnet_arn =
            (Util.option_bind (Xml.member "subnetArn" xml) String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Some
                            (Ezxmlm.make_tag "availabilityZone"
                               ([], (String.to_xml v.availability_zone)))])
                        @
                        [Util.option_map v.availability_zone_id
                           (fun f ->
                              Ezxmlm.make_tag "availabilityZoneId"
                                ([], (String.to_xml f)))])
                       @
                       [Some
                          (Ezxmlm.make_tag "availableIpAddressCount"
                             ([],
                               (Integer.to_xml v.available_ip_address_count)))])
                      @
                      [Some
                         (Ezxmlm.make_tag "cidrBlock"
                            ([], (String.to_xml v.cidr_block)))])
                     @
                     [Some
                        (Ezxmlm.make_tag "defaultForAz"
                           ([], (Boolean.to_xml v.default_for_az)))])
                    @
                    [Some
                       (Ezxmlm.make_tag "mapPublicIpOnLaunch"
                          ([], (Boolean.to_xml v.map_public_ip_on_launch)))])
                   @
                   [Some
                      (Ezxmlm.make_tag "state"
                         ([], (SubnetState.to_xml v.state)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "subnetId"
                        ([], (String.to_xml v.subnet_id)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "vpcId" ([], (String.to_xml v.vpc_id)))])
                @
                [Util.option_map v.owner_id
                   (fun f ->
                      Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.assign_ipv6_address_on_creation
                  (fun f ->
                     Ezxmlm.make_tag "assignIpv6AddressOnCreation"
                       ([], (Boolean.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "ipv6CidrBlockAssociationSet"
                         ([], (SubnetIpv6CidrBlockAssociationSet.to_xml [x]))))
                 v.ipv6_cidr_block_association_set))
             @
             (List.map
                (fun x ->
                   Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
                v.tags))
            @
            [Util.option_map v.subnet_arn
               (fun f -> Ezxmlm.make_tag "subnetArn" ([], (String.to_xml f)))])
           @
           [Util.option_map v.outpost_arn
              (fun f -> Ezxmlm.make_tag "outpostArn" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a subnet.</p>"]
module ElasticGpus =
  struct
    type t =
      {
      elastic_gpu_id: String.t option
        [@ocaml.doc "<p>The ID of the Elastic Graphics accelerator.</p>"];
      availability_zone: String.t option
        [@ocaml.doc
          "<p>The Availability Zone in the which the Elastic Graphics accelerator resides.</p>"];
      elastic_gpu_type: String.t option
        [@ocaml.doc "<p>The type of Elastic Graphics accelerator.</p>"];
      elastic_gpu_health: ElasticGpuHealth.t option
        [@ocaml.doc "<p>The status of the Elastic Graphics accelerator.</p>"];
      elastic_gpu_state: ElasticGpuState.t option
        [@ocaml.doc "<p>The state of the Elastic Graphics accelerator.</p>"];
      instance_id: String.t option
        [@ocaml.doc
          "<p>The ID of the instance to which the Elastic Graphics accelerator is attached.</p>"];
      tags: TagList.t
        [@ocaml.doc
          "<p>The tags assigned to the Elastic Graphics accelerator.</p>"]}
    [@@ocaml.doc "<p>Describes an Elastic Graphics accelerator.</p>"]
    let make ?elastic_gpu_id  ?availability_zone  ?elastic_gpu_type 
      ?elastic_gpu_health  ?elastic_gpu_state  ?instance_id  ?(tags= [])  ()
      =
      {
        elastic_gpu_id;
        availability_zone;
        elastic_gpu_type;
        elastic_gpu_health;
        elastic_gpu_state;
        instance_id;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.elastic_gpu_state
             (fun f ->
                Query.Pair ("ElasticGpuState", (ElasticGpuState.to_query f)));
           Util.option_map v.elastic_gpu_health
             (fun f ->
                Query.Pair
                  ("ElasticGpuHealth", (ElasticGpuHealth.to_query f)));
           Util.option_map v.elastic_gpu_type
             (fun f -> Query.Pair ("ElasticGpuType", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.elastic_gpu_id
             (fun f -> Query.Pair ("ElasticGpuId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.elastic_gpu_state
             (fun f -> ("elastic_gpu_state", (ElasticGpuState.to_json f)));
           Util.option_map v.elastic_gpu_health
             (fun f -> ("elastic_gpu_health", (ElasticGpuHealth.to_json f)));
           Util.option_map v.elastic_gpu_type
             (fun f -> ("elastic_gpu_type", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.elastic_gpu_id
             (fun f -> ("elastic_gpu_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          elastic_gpu_id =
            (Util.option_bind (Xml.member "elasticGpuId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          elastic_gpu_type =
            (Util.option_bind (Xml.member "elasticGpuType" xml) String.parse);
          elastic_gpu_health =
            (Util.option_bind (Xml.member "elasticGpuHealth" xml)
               ElasticGpuHealth.parse);
          elastic_gpu_state =
            (Util.option_bind (Xml.member "elasticGpuState" xml)
               ElasticGpuState.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.elastic_gpu_id
                    (fun f ->
                       Ezxmlm.make_tag "elasticGpuId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.availability_zone
                   (fun f ->
                      Ezxmlm.make_tag "availabilityZone"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.elastic_gpu_type
                  (fun f ->
                     Ezxmlm.make_tag "elasticGpuType" ([], (String.to_xml f)))])
              @
              [Util.option_map v.elastic_gpu_health
                 (fun f ->
                    Ezxmlm.make_tag "elasticGpuHealth"
                      ([], (ElasticGpuHealth.to_xml f)))])
             @
             [Util.option_map v.elastic_gpu_state
                (fun f ->
                   Ezxmlm.make_tag "elasticGpuState"
                     ([], (ElasticGpuState.to_xml f)))])
            @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes an Elastic Graphics accelerator.</p>"]
module VpcClassicLink =
  struct
    type t =
      {
      classic_link_enabled: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the VPC is enabled for ClassicLink.</p>"];
      tags: TagList.t [@ocaml.doc "<p>Any tags assigned to the VPC.</p>"];
      vpc_id: String.t option [@ocaml.doc "<p>The ID of the VPC.</p>"]}
    [@@ocaml.doc
      "<p>Describes whether a VPC is enabled for ClassicLink.</p>"]
    let make ?classic_link_enabled  ?(tags= [])  ?vpc_id  () =
      { classic_link_enabled; tags; vpc_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.classic_link_enabled
             (fun f ->
                Query.Pair ("ClassicLinkEnabled", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.classic_link_enabled
             (fun f -> ("classic_link_enabled", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          classic_link_enabled =
            (Util.option_bind (Xml.member "classicLinkEnabled" xml)
               Boolean.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.classic_link_enabled
                (fun f ->
                   Ezxmlm.make_tag "classicLinkEnabled"
                     ([], (Boolean.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes whether a VPC is enabled for ClassicLink.</p>"]
module ImportImageTask =
  struct
    type t =
      {
      architecture: String.t option
        [@ocaml.doc
          "<p>The architecture of the virtual machine.</p> <p>Valid values: <code>i386</code> | <code>x86_64</code> | <code>arm64</code> </p>"];
      description: String.t option
        [@ocaml.doc "<p>A description of the import task.</p>"];
      encrypted: Boolean.t option
        [@ocaml.doc "<p>Indicates whether the image is encrypted.</p>"];
      hypervisor: String.t option
        [@ocaml.doc
          "<p>The target hypervisor for the import task.</p> <p>Valid values: <code>xen</code> </p>"];
      image_id: String.t option
        [@ocaml.doc
          "<p>The ID of the Amazon Machine Image (AMI) of the imported virtual machine.</p>"];
      import_task_id: String.t option
        [@ocaml.doc "<p>The ID of the import image task.</p>"];
      kms_key_id: String.t option
        [@ocaml.doc
          "<p>The identifier for the AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to create the encrypted image.</p>"];
      license_type: String.t option
        [@ocaml.doc "<p>The license type of the virtual machine.</p>"];
      platform: String.t option
        [@ocaml.doc
          "<p>The description string for the import image task.</p>"];
      progress: String.t option
        [@ocaml.doc
          "<p>The percentage of progress of the import image task.</p>"];
      snapshot_details: SnapshotDetailList.t
        [@ocaml.doc "<p>Information about the snapshots.</p>"];
      status: String.t option
        [@ocaml.doc "<p>A brief status for the import image task.</p>"];
      status_message: String.t option
        [@ocaml.doc
          "<p>A descriptive status message for the import image task.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags applied to the import image task.</p>"];
      license_specifications: ImportImageLicenseSpecificationListResponse.t
        [@ocaml.doc
          "<p>The ARNs of the license configurations that are associated with the import image task.</p>"]}
    [@@ocaml.doc "<p>Describes an import image task.</p>"]
    let make ?architecture  ?description  ?encrypted  ?hypervisor  ?image_id 
      ?import_task_id  ?kms_key_id  ?license_type  ?platform  ?progress 
      ?(snapshot_details= [])  ?status  ?status_message  ?(tags= []) 
      ?(license_specifications= [])  () =
      {
        architecture;
        description;
        encrypted;
        hypervisor;
        image_id;
        import_task_id;
        kms_key_id;
        license_type;
        platform;
        progress;
        snapshot_details;
        status;
        status_message;
        tags;
        license_specifications
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("LicenseSpecifications",
                   (ImportImageLicenseSpecificationListResponse.to_query
                      v.license_specifications)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Some
             (Query.Pair
                ("SnapshotDetailSet",
                  (SnapshotDetailList.to_query v.snapshot_details)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.license_type
             (fun f -> Query.Pair ("LicenseType", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.hypervisor
             (fun f -> Query.Pair ("Hypervisor", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.architecture
             (fun f -> Query.Pair ("Architecture", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("license_specifications",
                (ImportImageLicenseSpecificationListResponse.to_json
                   v.license_specifications));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Some
             ("snapshot_details",
               (SnapshotDetailList.to_json v.snapshot_details));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.license_type
             (fun f -> ("license_type", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.hypervisor
             (fun f -> ("hypervisor", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.architecture
             (fun f -> ("architecture", (String.to_json f)))])
    let parse xml =
      Some
        {
          architecture =
            (Util.option_bind (Xml.member "architecture" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          hypervisor =
            (Util.option_bind (Xml.member "hypervisor" xml) String.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          license_type =
            (Util.option_bind (Xml.member "licenseType" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          snapshot_details =
            (Util.of_option []
               (Util.option_bind (Xml.member "snapshotDetailSet" xml)
                  SnapshotDetailList.parse));
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          license_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "licenseSpecifications" xml)
                  ImportImageLicenseSpecificationListResponse.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Util.option_map v.architecture
                            (fun f ->
                               Ezxmlm.make_tag "architecture"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.description
                           (fun f ->
                              Ezxmlm.make_tag "description"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.encrypted
                          (fun f ->
                             Ezxmlm.make_tag "encrypted"
                               ([], (Boolean.to_xml f)))])
                      @
                      [Util.option_map v.hypervisor
                         (fun f ->
                            Ezxmlm.make_tag "hypervisor"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.image_id
                        (fun f ->
                           Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.import_task_id
                       (fun f ->
                          Ezxmlm.make_tag "importTaskId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.kms_key_id
                      (fun f ->
                         Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.license_type
                     (fun f ->
                        Ezxmlm.make_tag "licenseType" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.platform
                    (fun f ->
                       Ezxmlm.make_tag "platform" ([], (String.to_xml f)))])
                @
                [Util.option_map v.progress
                   (fun f ->
                      Ezxmlm.make_tag "progress" ([], (String.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "snapshotDetailSet"
                          ([], (SnapshotDetailList.to_xml [x]))))
                  v.snapshot_details))
              @
              [Util.option_map v.status
                 (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
             @
             [Util.option_map v.status_message
                (fun f ->
                   Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "licenseSpecifications"
                      ([],
                        (ImportImageLicenseSpecificationListResponse.to_xml
                           [x])))) v.license_specifications))
  end[@@ocaml.doc "<p>Describes an import image task.</p>"]
module SpotPrice =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc "<p>The Availability Zone.</p>"];
      instance_type: InstanceType.t option
        [@ocaml.doc "<p>The instance type.</p>"];
      product_description: RIProductDescription.t option
        [@ocaml.doc "<p>A general description of the AMI.</p>"];
      spot_price: String.t option
        [@ocaml.doc
          "<p>The maximum price per hour that you are willing to pay for a Spot Instance.</p>"];
      timestamp: DateTime.t option
        [@ocaml.doc
          "<p>The date and time the request was created, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>"]}
    [@@ocaml.doc
      "<p>Describes the maximum price per hour that you are willing to pay for a Spot Instance.</p>"]
    let make ?availability_zone  ?instance_type  ?product_description 
      ?spot_price  ?timestamp  () =
      {
        availability_zone;
        instance_type;
        product_description;
        spot_price;
        timestamp
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          product_description =
            (Util.option_bind (Xml.member "productDescription" xml)
               RIProductDescription.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.availability_zone
                  (fun f ->
                     Ezxmlm.make_tag "availabilityZone"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.instance_type
                 (fun f ->
                    Ezxmlm.make_tag "instanceType"
                      ([], (InstanceType.to_xml f)))])
             @
             [Util.option_map v.product_description
                (fun f ->
                   Ezxmlm.make_tag "productDescription"
                     ([], (RIProductDescription.to_xml f)))])
            @
            [Util.option_map v.spot_price
               (fun f -> Ezxmlm.make_tag "spotPrice" ([], (String.to_xml f)))])
           @
           [Util.option_map v.timestamp
              (fun f -> Ezxmlm.make_tag "timestamp" ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the maximum price per hour that you are willing to pay for a Spot Instance.</p>"]
module ReportInstanceReasonCodes =
  struct
    type t =
      | Instance_stuck_in_state 
      | Unresponsive 
      | Not_accepting_credentials 
      | Password_not_available 
      | Performance_network 
      | Performance_instance_store 
      | Performance_ebs_volume 
      | Performance_other 
      | Other 
    let str_to_t =
      [("other", Other);
      ("performance-other", Performance_other);
      ("performance-ebs-volume", Performance_ebs_volume);
      ("performance-instance-store", Performance_instance_store);
      ("performance-network", Performance_network);
      ("password-not-available", Password_not_available);
      ("not-accepting-credentials", Not_accepting_credentials);
      ("unresponsive", Unresponsive);
      ("instance-stuck-in-state", Instance_stuck_in_state)]
    let t_to_str =
      [(Other, "other");
      (Performance_other, "performance-other");
      (Performance_ebs_volume, "performance-ebs-volume");
      (Performance_instance_store, "performance-instance-store");
      (Performance_network, "performance-network");
      (Password_not_available, "password-not-available");
      (Not_accepting_credentials, "not-accepting-credentials");
      (Unresponsive, "unresponsive");
      (Instance_stuck_in_state, "instance-stuck-in-state")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module InstanceCreditSpecificationRequest =
  struct
    type t =
      {
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"];
      cpu_credits: String.t option
        [@ocaml.doc
          "<p>The credit option for CPU usage of the instance. Valid values are <code>standard</code> and <code>unlimited</code>.</p>"]}
    [@@ocaml.doc
      "<p>Describes the credit option for CPU usage of a burstable performance instance.</p>"]
    let make ?instance_id  ?cpu_credits  () = { instance_id; cpu_credits }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> Query.Pair ("CpuCredits", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> ("cpu_credits", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          cpu_credits =
            (Util.option_bind (Xml.member "CpuCredits" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "InstanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.cpu_credits
              (fun f -> Ezxmlm.make_tag "CpuCredits" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the credit option for CPU usage of a burstable performance instance.</p>"]
module OccurrenceDayRequestSet =
  struct
    type t = Integer.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Integer.to_query v
    let to_headers v = Headers.to_headers_list Integer.to_headers v
    let to_json v = `List (List.map Integer.to_json v)
    let parse xml =
      Util.option_all
        (List.map Integer.parse (Xml.members "OccurenceDay" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Integer.to_xml x))) v
  end
module ImageDiskContainer =
  struct
    type t =
      {
      description: String.t option
        [@ocaml.doc "<p>The description of the disk image.</p>"];
      device_name: String.t option
        [@ocaml.doc "<p>The block device mapping for the disk.</p>"];
      format: String.t option
        [@ocaml.doc
          "<p>The format of the disk image being imported.</p> <p>Valid values: <code>VHD</code> | <code>VMDK</code> | <code>OVA</code> </p>"];
      snapshot_id: String.t option
        [@ocaml.doc
          "<p>The ID of the EBS snapshot to be used for importing the snapshot.</p>"];
      url: String.t option
        [@ocaml.doc
          "<p>The URL to the Amazon S3-based disk image being imported. The URL can either be a https URL (https://..) or an Amazon S3 URL (s3://..)</p>"];
      user_bucket: UserBucket.t option
        [@ocaml.doc "<p>The S3 bucket for the disk image.</p>"]}[@@ocaml.doc
                                                                  "<p>Describes the disk container object for an import image task.</p>"]
    let make ?description  ?device_name  ?format  ?snapshot_id  ?url 
      ?user_bucket  () =
      { description; device_name; format; snapshot_id; url; user_bucket }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> Query.Pair ("UserBucket", (UserBucket.to_query f)));
           Util.option_map v.url
             (fun f -> Query.Pair ("Url", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (String.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> ("user_bucket", (UserBucket.to_json f)));
           Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.format (fun f -> ("format", (String.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          device_name =
            (Util.option_bind (Xml.member "DeviceName" xml) String.parse);
          format = (Util.option_bind (Xml.member "Format" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "SnapshotId" xml) String.parse);
          url = (Util.option_bind (Xml.member "Url" xml) String.parse);
          user_bucket =
            (Util.option_bind (Xml.member "UserBucket" xml) UserBucket.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.description
                   (fun f ->
                      Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
               @
               [Util.option_map v.device_name
                  (fun f ->
                     Ezxmlm.make_tag "DeviceName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.format
                 (fun f -> Ezxmlm.make_tag "Format" ([], (String.to_xml f)))])
             @
             [Util.option_map v.snapshot_id
                (fun f ->
                   Ezxmlm.make_tag "SnapshotId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.url
               (fun f -> Ezxmlm.make_tag "Url" ([], (String.to_xml f)))])
           @
           [Util.option_map v.user_bucket
              (fun f ->
                 Ezxmlm.make_tag "UserBucket" ([], (UserBucket.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the disk container object for an import image task.</p>"]
module ImportImageLicenseConfigurationRequest =
  struct
    type t =
      {
      license_configuration_arn: String.t option
        [@ocaml.doc "<p>The ARN of a license configuration.</p>"]}[@@ocaml.doc
                                                                    "<p>The request information of license configurations.</p>"]
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "LicenseConfigurationArn" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Ezxmlm.make_tag "LicenseConfigurationArn"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>The request information of license configurations.</p>"]
module LocalGatewayRoute =
  struct
    type t =
      {
      destination_cidr_block: String.t option
        [@ocaml.doc "<p>The CIDR block used for destination matches.</p>"];
      local_gateway_virtual_interface_group_id: String.t option
        [@ocaml.doc "<p>The ID of the virtual interface group.</p>"];
      type_: LocalGatewayRouteType.t option
        [@ocaml.doc "<p>The route type.</p>"];
      state: LocalGatewayRouteState.t option
        [@ocaml.doc "<p>The state of the route.</p>"];
      local_gateway_route_table_id: String.t option
        [@ocaml.doc "<p>The ID of the local gateway route table.</p>"]}
    [@@ocaml.doc "<p>Describes a route for a local gateway route table.</p>"]
    let make ?destination_cidr_block 
      ?local_gateway_virtual_interface_group_id  ?type_  ?state 
      ?local_gateway_route_table_id  () =
      {
        destination_cidr_block;
        local_gateway_virtual_interface_group_id;
        type_;
        state;
        local_gateway_route_table_id
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_id
              (fun f ->
                 Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (LocalGatewayRouteState.to_query f)));
           Util.option_map v.type_
             (fun f ->
                Query.Pair ("Type", (LocalGatewayRouteType.to_query f)));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayVirtualInterfaceGroupId",
                    (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_id
              (fun f -> ("local_gateway_route_table_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (LocalGatewayRouteState.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (LocalGatewayRouteType.to_json f)));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                ("local_gateway_virtual_interface_group_id",
                  (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          local_gateway_virtual_interface_group_id =
            (Util.option_bind
               (Xml.member "localGatewayVirtualInterfaceGroupId" xml)
               String.parse);
          type_ =
            (Util.option_bind (Xml.member "type" xml)
               LocalGatewayRouteType.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               LocalGatewayRouteState.parse);
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.destination_cidr_block
                  (fun f ->
                     Ezxmlm.make_tag "destinationCidrBlock"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.local_gateway_virtual_interface_group_id
                 (fun f ->
                    Ezxmlm.make_tag "localGatewayVirtualInterfaceGroupId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.type_
                (fun f ->
                   Ezxmlm.make_tag "type"
                     ([], (LocalGatewayRouteType.to_xml f)))])
            @
            [Util.option_map v.state
               (fun f ->
                  Ezxmlm.make_tag "state"
                    ([], (LocalGatewayRouteState.to_xml f)))])
           @
           [Util.option_map v.local_gateway_route_table_id
              (fun f ->
                 Ezxmlm.make_tag "localGatewayRouteTableId"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a route for a local gateway route table.</p>"]
module ScheduledInstancesBlockDeviceMappingSet =
  struct
    type t = ScheduledInstancesBlockDeviceMapping.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list ScheduledInstancesBlockDeviceMapping.to_query v
    let to_headers v =
      Headers.to_headers_list ScheduledInstancesBlockDeviceMapping.to_headers
        v
    let to_json v =
      `List (List.map ScheduledInstancesBlockDeviceMapping.to_json v)
    let parse xml =
      Util.option_all
        (List.map ScheduledInstancesBlockDeviceMapping.parse
           (Xml.members "BlockDeviceMapping" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ScheduledInstancesBlockDeviceMapping.to_xml x))) v
  end
module ScheduledInstancesIamInstanceProfile =
  struct
    type t =
      {
      arn: String.t option
        [@ocaml.doc "<p>The Amazon Resource Name (ARN).</p>"];
      name: String.t option [@ocaml.doc "<p>The name.</p>"]}[@@ocaml.doc
                                                              "<p>Describes an IAM instance profile for a Scheduled Instance.</p>"]
    let make ?arn  ?name  () = { arn; name }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "Arn" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.arn
               (fun f -> Ezxmlm.make_tag "Arn" ([], (String.to_xml f)))])
           @
           [Util.option_map v.name
              (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an IAM instance profile for a Scheduled Instance.</p>"]
module ScheduledInstancesMonitoring =
  struct
    type t =
      {
      enabled: Boolean.t option
        [@ocaml.doc "<p>Indicates whether monitoring is enabled.</p>"]}
    [@@ocaml.doc
      "<p>Describes whether monitoring is enabled for a Scheduled Instance.</p>"]
    let make ?enabled  () = { enabled }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.enabled
              (fun f -> Ezxmlm.make_tag "Enabled" ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes whether monitoring is enabled for a Scheduled Instance.</p>"]
module ScheduledInstancesNetworkInterfaceSet =
  struct
    type t = ScheduledInstancesNetworkInterface.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list ScheduledInstancesNetworkInterface.to_query v
    let to_headers v =
      Headers.to_headers_list ScheduledInstancesNetworkInterface.to_headers v
    let to_json v =
      `List (List.map ScheduledInstancesNetworkInterface.to_json v)
    let parse xml =
      Util.option_all
        (List.map ScheduledInstancesNetworkInterface.parse
           (Xml.members "NetworkInterface" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ScheduledInstancesNetworkInterface.to_xml x))) v
  end
module ScheduledInstancesPlacement =
  struct
    type t =
      {
      availability_zone: String.t option
        [@ocaml.doc "<p>The Availability Zone.</p>"];
      group_name: String.t option
        [@ocaml.doc "<p>The name of the placement group.</p>"]}[@@ocaml.doc
                                                                 "<p>Describes the placement for a Scheduled Instance.</p>"]
    let make ?availability_zone  ?group_name  () =
      { availability_zone; group_name }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.availability_zone
               (fun f ->
                  Ezxmlm.make_tag "AvailabilityZone" ([], (String.to_xml f)))])
           @
           [Util.option_map v.group_name
              (fun f -> Ezxmlm.make_tag "GroupName" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the placement for a Scheduled Instance.</p>"]
module NatGateway =
  struct
    type t =
      {
      create_time: DateTime.t option
        [@ocaml.doc "<p>The date and time the NAT gateway was created.</p>"];
      delete_time: DateTime.t option
        [@ocaml.doc
          "<p>The date and time the NAT gateway was deleted, if applicable.</p>"];
      failure_code: String.t option
        [@ocaml.doc
          "<p>If the NAT gateway could not be created, specifies the error code for the failure. (<code>InsufficientFreeAddressesInSubnet</code> | <code>Gateway.NotAttached</code> | <code>InvalidAllocationID.NotFound</code> | <code>Resource.AlreadyAssociated</code> | <code>InternalError</code> | <code>InvalidSubnetID.NotFound</code>)</p>"];
      failure_message: String.t option
        [@ocaml.doc
          "<p>If the NAT gateway could not be created, specifies the error message for the failure, that corresponds to the error code.</p> <ul> <li> <p>For InsufficientFreeAddressesInSubnet: \"Subnet has insufficient free addresses to create this NAT gateway\"</p> </li> <li> <p>For Gateway.NotAttached: \"Network vpc-xxxxxxxx has no Internet gateway attached\"</p> </li> <li> <p>For InvalidAllocationID.NotFound: \"Elastic IP address eipalloc-xxxxxxxx could not be associated with this NAT gateway\"</p> </li> <li> <p>For Resource.AlreadyAssociated: \"Elastic IP address eipalloc-xxxxxxxx is already associated\"</p> </li> <li> <p>For InternalError: \"Network interface eni-xxxxxxxx, created and used internally by this NAT gateway is in an invalid state. Please try again.\"</p> </li> <li> <p>For InvalidSubnetID.NotFound: \"The specified subnet subnet-xxxxxxxx does not exist or could not be found.\"</p> </li> </ul>"];
      nat_gateway_addresses: NatGatewayAddressList.t
        [@ocaml.doc
          "<p>Information about the IP addresses and network interface associated with the NAT gateway.</p>"];
      nat_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the NAT gateway.</p>"];
      provisioned_bandwidth: ProvisionedBandwidth.t option
        [@ocaml.doc
          "<p>Reserved. If you need to sustain traffic greater than the <a href=\"https://docs.aws.amazon.com/vpc/latest/userguide/vpc-nat-gateway.html\">documented limits</a>, contact us through the <a href=\"https://console.aws.amazon.com/support/home?\">Support Center</a>.</p>"];
      state: NatGatewayState.t option
        [@ocaml.doc
          "<p>The state of the NAT gateway.</p> <ul> <li> <p> <code>pending</code>: The NAT gateway is being created and is not ready to process traffic.</p> </li> <li> <p> <code>failed</code>: The NAT gateway could not be created. Check the <code>failureCode</code> and <code>failureMessage</code> fields for the reason.</p> </li> <li> <p> <code>available</code>: The NAT gateway is able to process traffic. This status remains until you delete the NAT gateway, and does not indicate the health of the NAT gateway.</p> </li> <li> <p> <code>deleting</code>: The NAT gateway is in the process of being terminated and may still be processing traffic.</p> </li> <li> <p> <code>deleted</code>: The NAT gateway has been terminated and is no longer processing traffic.</p> </li> </ul>"];
      subnet_id: String.t option
        [@ocaml.doc
          "<p>The ID of the subnet in which the NAT gateway is located.</p>"];
      vpc_id: String.t option
        [@ocaml.doc
          "<p>The ID of the VPC in which the NAT gateway is located.</p>"];
      tags: TagList.t [@ocaml.doc "<p>The tags for the NAT gateway.</p>"]}
    [@@ocaml.doc "<p>Describes a NAT gateway.</p>"]
    let make ?create_time  ?delete_time  ?failure_code  ?failure_message 
      ?(nat_gateway_addresses= [])  ?nat_gateway_id  ?provisioned_bandwidth 
      ?state  ?subnet_id  ?vpc_id  ?(tags= [])  () =
      {
        create_time;
        delete_time;
        failure_code;
        failure_message;
        nat_gateway_addresses;
        nat_gateway_id;
        provisioned_bandwidth;
        state;
        subnet_id;
        vpc_id;
        tags
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (NatGatewayState.to_query f)));
           Util.option_map v.provisioned_bandwidth
             (fun f ->
                Query.Pair
                  ("ProvisionedBandwidth", (ProvisionedBandwidth.to_query f)));
           Util.option_map v.nat_gateway_id
             (fun f -> Query.Pair ("NatGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("NatGatewayAddressSet",
                  (NatGatewayAddressList.to_query v.nat_gateway_addresses)));
           Util.option_map v.failure_message
             (fun f -> Query.Pair ("FailureMessage", (String.to_query f)));
           Util.option_map v.failure_code
             (fun f -> Query.Pair ("FailureCode", (String.to_query f)));
           Util.option_map v.delete_time
             (fun f -> Query.Pair ("DeleteTime", (DateTime.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (NatGatewayState.to_json f)));
           Util.option_map v.provisioned_bandwidth
             (fun f ->
                ("provisioned_bandwidth", (ProvisionedBandwidth.to_json f)));
           Util.option_map v.nat_gateway_id
             (fun f -> ("nat_gateway_id", (String.to_json f)));
           Some
             ("nat_gateway_addresses",
               (NatGatewayAddressList.to_json v.nat_gateway_addresses));
           Util.option_map v.failure_message
             (fun f -> ("failure_message", (String.to_json f)));
           Util.option_map v.failure_code
             (fun f -> ("failure_code", (String.to_json f)));
           Util.option_map v.delete_time
             (fun f -> ("delete_time", (DateTime.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)))])
    let parse xml =
      Some
        {
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          delete_time =
            (Util.option_bind (Xml.member "deleteTime" xml) DateTime.parse);
          failure_code =
            (Util.option_bind (Xml.member "failureCode" xml) String.parse);
          failure_message =
            (Util.option_bind (Xml.member "failureMessage" xml) String.parse);
          nat_gateway_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "natGatewayAddressSet" xml)
                  NatGatewayAddressList.parse));
          nat_gateway_id =
            (Util.option_bind (Xml.member "natGatewayId" xml) String.parse);
          provisioned_bandwidth =
            (Util.option_bind (Xml.member "provisionedBandwidth" xml)
               ProvisionedBandwidth.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) NatGatewayState.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.create_time
                        (fun f ->
                           Ezxmlm.make_tag "createTime"
                             ([], (DateTime.to_xml f)))])
                    @
                    [Util.option_map v.delete_time
                       (fun f ->
                          Ezxmlm.make_tag "deleteTime"
                            ([], (DateTime.to_xml f)))])
                   @
                   [Util.option_map v.failure_code
                      (fun f ->
                         Ezxmlm.make_tag "failureCode"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.failure_message
                     (fun f ->
                        Ezxmlm.make_tag "failureMessage"
                          ([], (String.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "natGatewayAddressSet"
                            ([], (NatGatewayAddressList.to_xml [x]))))
                    v.nat_gateway_addresses))
                @
                [Util.option_map v.nat_gateway_id
                   (fun f ->
                      Ezxmlm.make_tag "natGatewayId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.provisioned_bandwidth
                  (fun f ->
                     Ezxmlm.make_tag "provisionedBandwidth"
                       ([], (ProvisionedBandwidth.to_xml f)))])
              @
              [Util.option_map v.state
                 (fun f ->
                    Ezxmlm.make_tag "state" ([], (NatGatewayState.to_xml f)))])
             @
             [Util.option_map v.subnet_id
                (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.vpc_id
               (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end[@@ocaml.doc "<p>Describes a NAT gateway.</p>"]
module InstanceUsage =
  struct
    type t =
      {
      account_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account that is making use of the Capacity Reservation.</p>"];
      used_instance_count: Integer.t option
        [@ocaml.doc
          "<p>The number of instances the AWS account currently has in the Capacity Reservation.</p>"]}
    [@@ocaml.doc "<p>Information about the Capacity Reservation usage.</p>"]
    let make ?account_id  ?used_instance_count  () =
      { account_id; used_instance_count }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.used_instance_count
              (fun f ->
                 Query.Pair ("UsedInstanceCount", (Integer.to_query f)));
           Util.option_map v.account_id
             (fun f -> Query.Pair ("AccountId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.used_instance_count
              (fun f -> ("used_instance_count", (Integer.to_json f)));
           Util.option_map v.account_id
             (fun f -> ("account_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          account_id =
            (Util.option_bind (Xml.member "accountId" xml) String.parse);
          used_instance_count =
            (Util.option_bind (Xml.member "usedInstanceCount" xml)
               Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.account_id
               (fun f -> Ezxmlm.make_tag "accountId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.used_instance_count
              (fun f ->
                 Ezxmlm.make_tag "usedInstanceCount" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc "<p>Information about the Capacity Reservation usage.</p>"]
module DescribeFastSnapshotRestoreSuccessItem =
  struct
    type t =
      {
      snapshot_id: String.t option
        [@ocaml.doc "<p>The ID of the snapshot.</p>"];
      availability_zone: String.t option
        [@ocaml.doc "<p>The Availability Zone.</p>"];
      state: FastSnapshotRestoreStateCode.t option
        [@ocaml.doc "<p>The state of fast snapshot restores.</p>"];
      state_transition_reason: String.t option
        [@ocaml.doc
          "<p>The reason for the state transition. The possible values are as follows:</p> <ul> <li> <p> <code>Client.UserInitiated</code> - The state successfully transitioned to <code>enabling</code> or <code>disabling</code>.</p> </li> <li> <p> <code>Client.UserInitiated - Lifecycle state transition</code> - The state successfully transitioned to <code>optimizing</code>, <code>enabled</code>, or <code>disabled</code>.</p> </li> </ul>"];
      owner_id: String.t option
        [@ocaml.doc
          "<p>The ID of the AWS account that owns the snapshot.</p>"];
      owner_alias: String.t option
        [@ocaml.doc "<p>The alias of the snapshot owner.</p>"];
      enabling_time: DateTime.t option
        [@ocaml.doc
          "<p>The time at which fast snapshot restores entered the <code>enabling</code> state.</p>"];
      optimizing_time: DateTime.t option
        [@ocaml.doc
          "<p>The time at which fast snapshot restores entered the <code>optimizing</code> state.</p>"];
      enabled_time: DateTime.t option
        [@ocaml.doc
          "<p>The time at which fast snapshot restores entered the <code>enabled</code> state.</p>"];
      disabling_time: DateTime.t option
        [@ocaml.doc
          "<p>The time at which fast snapshot restores entered the <code>disabling</code> state.</p>"];
      disabled_time: DateTime.t option
        [@ocaml.doc
          "<p>The time at which fast snapshot restores entered the <code>disabled</code> state.</p>"]}
    [@@ocaml.doc "<p>Describes fast snapshot restores for a snapshot.</p>"]
    let make ?snapshot_id  ?availability_zone  ?state 
      ?state_transition_reason  ?owner_id  ?owner_alias  ?enabling_time 
      ?optimizing_time  ?enabled_time  ?disabling_time  ?disabled_time  () =
      {
        snapshot_id;
        availability_zone;
        state;
        state_transition_reason;
        owner_id;
        owner_alias;
        enabling_time;
        optimizing_time;
        enabled_time;
        disabling_time;
        disabled_time
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> Query.Pair ("DisabledTime", (DateTime.to_query f)));
           Util.option_map v.disabling_time
             (fun f -> Query.Pair ("DisablingTime", (DateTime.to_query f)));
           Util.option_map v.enabled_time
             (fun f -> Query.Pair ("EnabledTime", (DateTime.to_query f)));
           Util.option_map v.optimizing_time
             (fun f -> Query.Pair ("OptimizingTime", (DateTime.to_query f)));
           Util.option_map v.enabling_time
             (fun f -> Query.Pair ("EnablingTime", (DateTime.to_query f)));
           Util.option_map v.owner_alias
             (fun f -> Query.Pair ("OwnerAlias", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.state_transition_reason
             (fun f ->
                Query.Pair ("StateTransitionReason", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (FastSnapshotRestoreStateCode.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> ("disabled_time", (DateTime.to_json f)));
           Util.option_map v.disabling_time
             (fun f -> ("disabling_time", (DateTime.to_json f)));
           Util.option_map v.enabled_time
             (fun f -> ("enabled_time", (DateTime.to_json f)));
           Util.option_map v.optimizing_time
             (fun f -> ("optimizing_time", (DateTime.to_json f)));
           Util.option_map v.enabling_time
             (fun f -> ("enabling_time", (DateTime.to_json f)));
           Util.option_map v.owner_alias
             (fun f -> ("owner_alias", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.state_transition_reason
             (fun f -> ("state_transition_reason", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (FastSnapshotRestoreStateCode.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               FastSnapshotRestoreStateCode.parse);
          state_transition_reason =
            (Util.option_bind (Xml.member "stateTransitionReason" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          owner_alias =
            (Util.option_bind (Xml.member "ownerAlias" xml) String.parse);
          enabling_time =
            (Util.option_bind (Xml.member "enablingTime" xml) DateTime.parse);
          optimizing_time =
            (Util.option_bind (Xml.member "optimizingTime" xml)
               DateTime.parse);
          enabled_time =
            (Util.option_bind (Xml.member "enabledTime" xml) DateTime.parse);
          disabling_time =
            (Util.option_bind (Xml.member "disablingTime" xml) DateTime.parse);
          disabled_time =
            (Util.option_bind (Xml.member "disabledTime" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.snapshot_id
                        (fun f ->
                           Ezxmlm.make_tag "snapshotId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.availability_zone
                       (fun f ->
                          Ezxmlm.make_tag "availabilityZone"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.state
                      (fun f ->
                         Ezxmlm.make_tag "state"
                           ([], (FastSnapshotRestoreStateCode.to_xml f)))])
                  @
                  [Util.option_map v.state_transition_reason
                     (fun f ->
                        Ezxmlm.make_tag "stateTransitionReason"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.owner_id
                    (fun f ->
                       Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.owner_alias
                   (fun f ->
                      Ezxmlm.make_tag "ownerAlias" ([], (String.to_xml f)))])
               @
               [Util.option_map v.enabling_time
                  (fun f ->
                     Ezxmlm.make_tag "enablingTime" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.optimizing_time
                 (fun f ->
                    Ezxmlm.make_tag "optimizingTime"
                      ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.enabled_time
                (fun f ->
                   Ezxmlm.make_tag "enabledTime" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.disabling_time
               (fun f ->
                  Ezxmlm.make_tag "disablingTime" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.disabled_time
              (fun f ->
                 Ezxmlm.make_tag "disabledTime" ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc "<p>Describes fast snapshot restores for a snapshot.</p>"]
module EgressOnlyInternetGateway =
  struct
    type t =
      {
      attachments: InternetGatewayAttachmentList.t
        [@ocaml.doc
          "<p>Information about the attachment of the egress-only internet gateway.</p>"];
      egress_only_internet_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the egress-only internet gateway.</p>"]}
    [@@ocaml.doc "<p>Describes an egress-only internet gateway.</p>"]
    let make ?(attachments= [])  ?egress_only_internet_gateway_id  () =
      { attachments; egress_only_internet_gateway_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.egress_only_internet_gateway_id
              (fun f ->
                 Query.Pair
                   ("EgressOnlyInternetGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("AttachmentSet",
                  (InternetGatewayAttachmentList.to_query v.attachments)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.egress_only_internet_gateway_id
              (fun f ->
                 ("egress_only_internet_gateway_id", (String.to_json f)));
           Some
             ("attachments",
               (InternetGatewayAttachmentList.to_json v.attachments))])
    let parse xml =
      Some
        {
          attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "attachmentSet" xml)
                  InternetGatewayAttachmentList.parse));
          egress_only_internet_gateway_id =
            (Util.option_bind (Xml.member "egressOnlyInternetGatewayId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "attachmentSet"
                       ([], (InternetGatewayAttachmentList.to_xml [x]))))
               v.attachments))
           @
           [Util.option_map v.egress_only_internet_gateway_id
              (fun f ->
                 Ezxmlm.make_tag "egressOnlyInternetGatewayId"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an egress-only internet gateway.</p>"]
module LoadPermissionListRequest =
  struct
    type t = LoadPermissionRequest.t list
    let make elems () = elems
    let to_query v = Query.to_query_list LoadPermissionRequest.to_query v
    let to_headers v =
      Headers.to_headers_list LoadPermissionRequest.to_headers v
    let to_json v = `List (List.map LoadPermissionRequest.to_json v)
    let parse xml =
      Util.option_all
        (List.map LoadPermissionRequest.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (LoadPermissionRequest.to_xml x))) v
  end
module CapacityReservationIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module FilterList =
  struct
    type t = Filter.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Filter.to_query v
    let to_headers v = Headers.to_headers_list Filter.to_headers v
    let to_json v = `List (List.map Filter.to_json v)
    let parse xml =
      Util.option_all (List.map Filter.parse (Xml.members "Filter" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Filter.to_xml x))) v
  end
module BlockDeviceMappingRequestList =
  struct
    type t = BlockDeviceMapping.t list
    let make elems () = elems
    let to_query v = Query.to_query_list BlockDeviceMapping.to_query v
    let to_headers v =
      Headers.to_headers_list BlockDeviceMapping.to_headers v
    let to_json v = `List (List.map BlockDeviceMapping.to_json v)
    let parse xml =
      Util.option_all
        (List.map BlockDeviceMapping.parse
           (Xml.members "BlockDeviceMapping" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (BlockDeviceMapping.to_xml x))) v
  end
module TagSpecificationList =
  struct
    type t = TagSpecification.t list
    let make elems () = elems
    let to_query v = Query.to_query_list TagSpecification.to_query v
    let to_headers v = Headers.to_headers_list TagSpecification.to_headers v
    let to_json v = `List (List.map TagSpecification.to_json v)
    let parse xml =
      Util.option_all
        (List.map TagSpecification.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (TagSpecification.to_xml x)))
        v
  end
module TagDescriptionList =
  struct
    type t = TagDescription.t list
    let make elems () = elems
    let to_query v = Query.to_query_list TagDescription.to_query v
    let to_headers v = Headers.to_headers_list TagDescription.to_headers v
    let to_json v = `List (List.map TagDescription.to_json v)
    let parse xml =
      Util.option_all
        (List.map TagDescription.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (TagDescription.to_xml x))) v
  end
module DhcpOptionsList =
  struct
    type t = DhcpOptions.t list
    let make elems () = elems
    let to_query v = Query.to_query_list DhcpOptions.to_query v
    let to_headers v = Headers.to_headers_list DhcpOptions.to_headers v
    let to_json v = `List (List.map DhcpOptions.to_json v)
    let parse xml =
      Util.option_all (List.map DhcpOptions.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (DhcpOptions.to_xml x))) v
  end
module VpnGatewayList =
  struct
    type t = VpnGateway.t list
    let make elems () = elems
    let to_query v = Query.to_query_list VpnGateway.to_query v
    let to_headers v = Headers.to_headers_list VpnGateway.to_headers v
    let to_json v = `List (List.map VpnGateway.to_json v)
    let parse xml =
      Util.option_all (List.map VpnGateway.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VpnGateway.to_xml x))) v
  end
module TransitGatewayAttachmentPropagationList =
  struct
    type t = TransitGatewayAttachmentPropagation.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list TransitGatewayAttachmentPropagation.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayAttachmentPropagation.to_headers
        v
    let to_json v =
      `List (List.map TransitGatewayAttachmentPropagation.to_json v)
    let parse xml =
      Util.option_all
        (List.map TransitGatewayAttachmentPropagation.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayAttachmentPropagation.to_xml x))) v
  end
module CapacityReservationSet =
  struct
    type t = CapacityReservation.t list
    let make elems () = elems
    let to_query v = Query.to_query_list CapacityReservation.to_query v
    let to_headers v =
      Headers.to_headers_list CapacityReservation.to_headers v
    let to_json v = `List (List.map CapacityReservation.to_json v)
    let parse xml =
      Util.option_all
        (List.map CapacityReservation.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (CapacityReservation.to_xml x))) v
  end
module ElasticGpuIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module ReservedInstancesModificationList =
  struct
    type t = ReservedInstancesModification.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list ReservedInstancesModification.to_query v
    let to_headers v =
      Headers.to_headers_list ReservedInstancesModification.to_headers v
    let to_json v = `List (List.map ReservedInstancesModification.to_json v)
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesModification.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ReservedInstancesModification.to_xml x))) v
  end
module PlacementGroupList =
  struct
    type t = PlacementGroup.t list
    let make elems () = elems
    let to_query v = Query.to_query_list PlacementGroup.to_query v
    let to_headers v = Headers.to_headers_list PlacementGroup.to_headers v
    let to_json v = `List (List.map PlacementGroup.to_json v)
    let parse xml =
      Util.option_all
        (List.map PlacementGroup.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PlacementGroup.to_xml x))) v
  end
module TransitGatewayRouteTablePropagationList =
  struct
    type t = TransitGatewayRouteTablePropagation.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list TransitGatewayRouteTablePropagation.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayRouteTablePropagation.to_headers
        v
    let to_json v =
      `List (List.map TransitGatewayRouteTablePropagation.to_json v)
    let parse xml =
      Util.option_all
        (List.map TransitGatewayRouteTablePropagation.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayRouteTablePropagation.to_xml x))) v
  end
module KeyPairList =
  struct
    type t = KeyPairInfo.t list
    let make elems () = elems
    let to_query v = Query.to_query_list KeyPairInfo.to_query v
    let to_headers v = Headers.to_headers_list KeyPairInfo.to_headers v
    let to_json v = `List (List.map KeyPairInfo.to_json v)
    let parse xml =
      Util.option_all (List.map KeyPairInfo.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (KeyPairInfo.to_xml x))) v
  end
module HistoryRecordSet =
  struct
    type t = HistoryRecordEntry.t list
    let make elems () = elems
    let to_query v = Query.to_query_list HistoryRecordEntry.to_query v
    let to_headers v =
      Headers.to_headers_list HistoryRecordEntry.to_headers v
    let to_json v = `List (List.map HistoryRecordEntry.to_json v)
    let parse xml =
      Util.option_all
        (List.map HistoryRecordEntry.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (HistoryRecordEntry.to_xml x))) v
  end
module HostReservationSet =
  struct
    type t = HostReservation.t list
    let make elems () = elems
    let to_query v = Query.to_query_list HostReservation.to_query v
    let to_headers v = Headers.to_headers_list HostReservation.to_headers v
    let to_json v = `List (List.map HostReservation.to_json v)
    let parse xml =
      Util.option_all
        (List.map HostReservation.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (HostReservation.to_xml x)))
        v
  end
module LaunchPermissionModifications =
  struct
    type t =
      {
      add: LaunchPermissionList.t
        [@ocaml.doc
          "<p>The AWS account ID to add to the list of launch permissions for the AMI.</p>"];
      remove: LaunchPermissionList.t
        [@ocaml.doc
          "<p>The AWS account ID to remove from the list of launch permissions for the AMI.</p>"]}
    [@@ocaml.doc "<p>Describes a launch permission modification.</p>"]
    let make ?(add= [])  ?(remove= [])  () = { add; remove }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Remove", (LaunchPermissionList.to_query v.remove)));
           Some (Query.Pair ("Add", (LaunchPermissionList.to_query v.add)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("remove", (LaunchPermissionList.to_json v.remove));
           Some ("add", (LaunchPermissionList.to_json v.add))])
    let parse xml =
      Some
        {
          add =
            (Util.of_option []
               (Util.option_bind (Xml.member "Add" xml)
                  LaunchPermissionList.parse));
          remove =
            (Util.of_option []
               (Util.option_bind (Xml.member "Remove" xml)
                  LaunchPermissionList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Add"
                       ([], (LaunchPermissionList.to_xml [x])))) v.add))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Remove"
                      ([], (LaunchPermissionList.to_xml [x])))) v.remove))
  end[@@ocaml.doc "<p>Describes a launch permission modification.</p>"]
module OperationType =
  struct
    type t =
      | Add 
      | Remove 
    let str_to_t = [("remove", Remove); ("add", Add)]
    let t_to_str = [(Remove, "remove"); (Add, "add")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ProductCodeStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "ProductCode" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module UserGroupStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "UserGroup" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module UserIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "UserId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module InstanceAttributeName =
  struct
    type t =
      | InstanceType 
      | Kernel 
      | Ramdisk 
      | UserData 
      | DisableApiTermination 
      | InstanceInitiatedShutdownBehavior 
      | RootDeviceName 
      | BlockDeviceMapping 
      | ProductCodes 
      | SourceDestCheck 
      | GroupSet 
      | EbsOptimized 
      | SriovNetSupport 
      | EnaSupport 
    let str_to_t =
      [("enaSupport", EnaSupport);
      ("sriovNetSupport", SriovNetSupport);
      ("ebsOptimized", EbsOptimized);
      ("groupSet", GroupSet);
      ("sourceDestCheck", SourceDestCheck);
      ("productCodes", ProductCodes);
      ("blockDeviceMapping", BlockDeviceMapping);
      ("rootDeviceName", RootDeviceName);
      ("instanceInitiatedShutdownBehavior",
        InstanceInitiatedShutdownBehavior);
      ("disableApiTermination", DisableApiTermination);
      ("userData", UserData);
      ("ramdisk", Ramdisk);
      ("kernel", Kernel);
      ("instanceType", InstanceType)]
    let t_to_str =
      [(EnaSupport, "enaSupport");
      (SriovNetSupport, "sriovNetSupport");
      (EbsOptimized, "ebsOptimized");
      (GroupSet, "groupSet");
      (SourceDestCheck, "sourceDestCheck");
      (ProductCodes, "productCodes");
      (BlockDeviceMapping, "blockDeviceMapping");
      (RootDeviceName, "rootDeviceName");
      (InstanceInitiatedShutdownBehavior,
        "instanceInitiatedShutdownBehavior");
      (DisableApiTermination, "disableApiTermination");
      (UserData, "userData");
      (Ramdisk, "ramdisk");
      (Kernel, "kernel");
      (InstanceType, "instanceType")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module RequestHostIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module CreateTransitGatewayVpcAttachmentRequestOptions =
  struct
    type t =
      {
      dns_support: DnsSupportValue.t option
        [@ocaml.doc
          "<p>Enable or disable DNS support. The default is <code>enable</code>.</p>"];
      ipv6_support: Ipv6SupportValue.t option
        [@ocaml.doc
          "<p>Enable or disable IPv6 support. The default is <code>enable</code>.</p>"]}
    [@@ocaml.doc "<p>Describes the options for a VPC attachment.</p>"]
    let make ?dns_support  ?ipv6_support  () = { dns_support; ipv6_support }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_support
              (fun f ->
                 Query.Pair ("Ipv6Support", (Ipv6SupportValue.to_query f)));
           Util.option_map v.dns_support
             (fun f ->
                Query.Pair ("DnsSupport", (DnsSupportValue.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_support
              (fun f -> ("ipv6_support", (Ipv6SupportValue.to_json f)));
           Util.option_map v.dns_support
             (fun f -> ("dns_support", (DnsSupportValue.to_json f)))])
    let parse xml =
      Some
        {
          dns_support =
            (Util.option_bind (Xml.member "DnsSupport" xml)
               DnsSupportValue.parse);
          ipv6_support =
            (Util.option_bind (Xml.member "Ipv6Support" xml)
               Ipv6SupportValue.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dns_support
               (fun f ->
                  Ezxmlm.make_tag "DnsSupport"
                    ([], (DnsSupportValue.to_xml f)))])
           @
           [Util.option_map v.ipv6_support
              (fun f ->
                 Ezxmlm.make_tag "Ipv6Support"
                   ([], (Ipv6SupportValue.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the options for a VPC attachment.</p>"]
module LocalGatewayIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module ReservedInstancesConfigurationList =
  struct
    type t = ReservedInstancesConfiguration.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list ReservedInstancesConfiguration.to_query v
    let to_headers v =
      Headers.to_headers_list ReservedInstancesConfiguration.to_headers v
    let to_json v = `List (List.map ReservedInstancesConfiguration.to_json v)
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesConfiguration.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ReservedInstancesConfiguration.to_xml x))) v
  end
module ReservedInstancesIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ReservedInstancesId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module VpcEndpointConnectionSet =
  struct
    type t = VpcEndpointConnection.t list
    let make elems () = elems
    let to_query v = Query.to_query_list VpcEndpointConnection.to_query v
    let to_headers v =
      Headers.to_headers_list VpcEndpointConnection.to_headers v
    let to_json v = `List (List.map VpcEndpointConnection.to_json v)
    let parse xml =
      Util.option_all
        (List.map VpcEndpointConnection.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (VpcEndpointConnection.to_xml x))) v
  end
module GroupNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "GroupName" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module ExportImageTaskList =
  struct
    type t = ExportImageTask.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ExportImageTask.to_query v
    let to_headers v = Headers.to_headers_list ExportImageTask.to_headers v
    let to_json v = `List (List.map ExportImageTask.to_json v)
    let parse xml =
      Util.option_all
        (List.map ExportImageTask.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ExportImageTask.to_xml x)))
        v
  end
module ExportTaskS3LocationRequest =
  struct
    type t =
      {
      s3_bucket: String.t [@ocaml.doc "<p>The destination S3 bucket.</p>"];
      s3_prefix: String.t option
        [@ocaml.doc "<p>The prefix (logical hierarchy) in the bucket.</p>"]}
    [@@ocaml.doc
      "<p>Describes the destination for an export image task.</p>"]
    let make ~s3_bucket  ?s3_prefix  () = { s3_bucket; s3_prefix }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> Query.Pair ("S3Prefix", (String.to_query f)));
           Some (Query.Pair ("S3Bucket", (String.to_query v.s3_bucket)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> ("s3_prefix", (String.to_json f)));
           Some ("s3_bucket", (String.to_json v.s3_bucket))])
    let parse xml =
      Some
        {
          s3_bucket =
            (Xml.required "S3Bucket"
               (Util.option_bind (Xml.member "S3Bucket" xml) String.parse));
          s3_prefix =
            (Util.option_bind (Xml.member "S3Prefix" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "S3Bucket" ([], (String.to_xml v.s3_bucket)))])
           @
           [Util.option_map v.s3_prefix
              (fun f -> Ezxmlm.make_tag "S3Prefix" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the destination for an export image task.</p>"]
module RequestSpotLaunchSpecification =
  struct
    type t =
      {
      security_group_ids: ValueStringList.t
        [@ocaml.doc "<p>One or more security group IDs.</p>"];
      security_groups: ValueStringList.t
        [@ocaml.doc
          "<p>One or more security groups. When requesting instances in a VPC, you must specify the IDs of the security groups. When requesting instances in EC2-Classic, you can specify the names or the IDs of the security groups.</p>"];
      addressing_type: String.t option [@ocaml.doc "<p>Deprecated.</p>"];
      block_device_mappings: BlockDeviceMappingList.t
        [@ocaml.doc
          "<p>One or more block device mapping entries. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.</p>"];
      ebs_optimized: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the instance is optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.</p> <p>Default: <code>false</code> </p>"];
      iam_instance_profile: IamInstanceProfileSpecification.t option
        [@ocaml.doc "<p>The IAM instance profile.</p>"];
      image_id: String.t option [@ocaml.doc "<p>The ID of the AMI.</p>"];
      instance_type: InstanceType.t option
        [@ocaml.doc "<p>The instance type.</p>"];
      kernel_id: String.t option [@ocaml.doc "<p>The ID of the kernel.</p>"];
      key_name: String.t option
        [@ocaml.doc "<p>The name of the key pair.</p>"];
      monitoring: RunInstancesMonitoringEnabled.t option
        [@ocaml.doc
          "<p>Indicates whether basic or detailed monitoring is enabled for the instance.</p> <p>Default: Disabled</p>"];
      network_interfaces: InstanceNetworkInterfaceSpecificationList.t
        [@ocaml.doc
          "<p>One or more network interfaces. If you specify a network interface, you must specify subnet IDs and security group IDs using the network interface.</p>"];
      placement: SpotPlacement.t option
        [@ocaml.doc "<p>The placement information for the instance.</p>"];
      ramdisk_id: String.t option
        [@ocaml.doc "<p>The ID of the RAM disk.</p>"];
      subnet_id: String.t option
        [@ocaml.doc
          "<p>The IDs of the subnets in which to launch the instance. To specify multiple subnets, separate them using commas; for example, \"subnet-1234abcdeexample1, subnet-0987cdef6example2\".</p>"];
      user_data: String.t option
        [@ocaml.doc
          "<p>The Base64-encoded user data for the instance. User data is limited to 16 KB.</p>"]}
    [@@ocaml.doc
      "<p>Describes the launch specification for an instance.</p>"]
    let make ?(security_group_ids= [])  ?(security_groups= []) 
      ?addressing_type  ?(block_device_mappings= [])  ?ebs_optimized 
      ?iam_instance_profile  ?image_id  ?instance_type  ?kernel_id  ?key_name
       ?monitoring  ?(network_interfaces= [])  ?placement  ?ramdisk_id 
      ?subnet_id  ?user_data  () =
      {
        security_group_ids;
        security_groups;
        addressing_type;
        block_device_mappings;
        ebs_optimized;
        iam_instance_profile;
        image_id;
        instance_type;
        kernel_id;
        key_name;
        monitoring;
        network_interfaces;
        placement;
        ramdisk_id;
        subnet_id;
        user_data
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (SpotPlacement.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterface",
                  (InstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair
                  ("Monitoring", (RunInstancesMonitoringEnabled.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (IamInstanceProfileSpecification.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Util.option_map v.addressing_type
             (fun f -> Query.Pair ("AddressingType", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroup",
                  (ValueStringList.to_query v.security_groups)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (ValueStringList.to_query v.security_group_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (SpotPlacement.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Util.option_map v.monitoring
             (fun f ->
                ("monitoring", (RunInstancesMonitoringEnabled.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (IamInstanceProfileSpecification.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings));
           Util.option_map v.addressing_type
             (fun f -> ("addressing_type", (String.to_json f)));
           Some
             ("security_groups", (ValueStringList.to_json v.security_groups));
           Some
             ("security_group_ids",
               (ValueStringList.to_json v.security_group_ids))])
    let parse xml =
      Some
        {
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  ValueStringList.parse));
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroup" xml)
                  ValueStringList.parse));
          addressing_type =
            (Util.option_bind (Xml.member "addressingType" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml)
               RunInstancesMonitoringEnabled.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterface" xml)
                  InstanceNetworkInterfaceSpecificationList.parse));
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               SpotPlacement.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((([] @
                          (List.map
                             (fun x ->
                                Some
                                  (Ezxmlm.make_tag "SecurityGroupId"
                                     ([], (ValueStringList.to_xml [x]))))
                             v.security_group_ids))
                         @
                         (List.map
                            (fun x ->
                               Some
                                 (Ezxmlm.make_tag "SecurityGroup"
                                    ([], (ValueStringList.to_xml [x]))))
                            v.security_groups))
                        @
                        [Util.option_map v.addressing_type
                           (fun f ->
                              Ezxmlm.make_tag "addressingType"
                                ([], (String.to_xml f)))])
                       @
                       (List.map
                          (fun x ->
                             Some
                               (Ezxmlm.make_tag "blockDeviceMapping"
                                  ([], (BlockDeviceMappingList.to_xml [x]))))
                          v.block_device_mappings))
                      @
                      [Util.option_map v.ebs_optimized
                         (fun f ->
                            Ezxmlm.make_tag "ebsOptimized"
                              ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.iam_instance_profile
                        (fun f ->
                           Ezxmlm.make_tag "iamInstanceProfile"
                             ([], (IamInstanceProfileSpecification.to_xml f)))])
                    @
                    [Util.option_map v.image_id
                       (fun f ->
                          Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.instance_type
                      (fun f ->
                         Ezxmlm.make_tag "instanceType"
                           ([], (InstanceType.to_xml f)))])
                  @
                  [Util.option_map v.kernel_id
                     (fun f ->
                        Ezxmlm.make_tag "kernelId" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.key_name
                    (fun f ->
                       Ezxmlm.make_tag "keyName" ([], (String.to_xml f)))])
                @
                [Util.option_map v.monitoring
                   (fun f ->
                      Ezxmlm.make_tag "monitoring"
                        ([], (RunInstancesMonitoringEnabled.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "NetworkInterface"
                          ([],
                            (InstanceNetworkInterfaceSpecificationList.to_xml
                               [x])))) v.network_interfaces))
              @
              [Util.option_map v.placement
                 (fun f ->
                    Ezxmlm.make_tag "placement"
                      ([], (SpotPlacement.to_xml f)))])
             @
             [Util.option_map v.ramdisk_id
                (fun f -> Ezxmlm.make_tag "ramdiskId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.subnet_id
               (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.user_data
              (fun f -> Ezxmlm.make_tag "userData" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the launch specification for an instance.</p>"]
module UnsuccessfulItemSet =
  struct
    type t = UnsuccessfulItem.t list
    let make elems () = elems
    let to_query v = Query.to_query_list UnsuccessfulItem.to_query v
    let to_headers v = Headers.to_headers_list UnsuccessfulItem.to_headers v
    let to_json v = `List (List.map UnsuccessfulItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map UnsuccessfulItem.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (UnsuccessfulItem.to_xml x)))
        v
  end
module Status =
  struct
    type t =
      | MoveInProgress 
      | InVpc 
      | InClassic 
    let str_to_t =
      [("InClassic", InClassic);
      ("InVpc", InVpc);
      ("MoveInProgress", MoveInProgress)]
    let t_to_str =
      [(InClassic, "InClassic");
      (InVpc, "InVpc");
      (MoveInProgress, "MoveInProgress")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module TransitGatewayRouteTableIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module TrafficMirrorFilterSet =
  struct
    type t = TrafficMirrorFilter.t list
    let make elems () = elems
    let to_query v = Query.to_query_list TrafficMirrorFilter.to_query v
    let to_headers v =
      Headers.to_headers_list TrafficMirrorFilter.to_headers v
    let to_json v = `List (List.map TrafficMirrorFilter.to_json v)
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorFilter.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (TrafficMirrorFilter.to_xml x))) v
  end
module PrivateIpAddressStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "PrivateIpAddress" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module TransitGatewayList =
  struct
    type t = TransitGateway.t list
    let make elems () = elems
    let to_query v = Query.to_query_list TransitGateway.to_query v
    let to_headers v = Headers.to_headers_list TransitGateway.to_headers v
    let to_json v = `List (List.map TransitGateway.to_json v)
    let parse xml =
      Util.option_all
        (List.map TransitGateway.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (TransitGateway.to_xml x))) v
  end
module ClientVpnAuthenticationRequestList =
  struct
    type t = ClientVpnAuthenticationRequest.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list ClientVpnAuthenticationRequest.to_query v
    let to_headers v =
      Headers.to_headers_list ClientVpnAuthenticationRequest.to_headers v
    let to_json v = `List (List.map ClientVpnAuthenticationRequest.to_json v)
    let parse xml =
      Util.option_all
        (List.map ClientVpnAuthenticationRequest.parse
           (Xml.members "member" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ClientVpnAuthenticationRequest.to_xml x))) v
  end
module ConnectionLogOptions =
  struct
    type t =
      {
      enabled: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether connection logging is enabled.</p>"];
      cloudwatch_log_group: String.t option
        [@ocaml.doc "<p>The name of the CloudWatch Logs log group.</p>"];
      cloudwatch_log_stream: String.t option
        [@ocaml.doc
          "<p>The name of the CloudWatch Logs log stream to which the connection data is published.</p>"]}
    [@@ocaml.doc
      "<p>Describes the client connection logging options for the Client VPN endpoint.</p>"]
    let make ?enabled  ?cloudwatch_log_group  ?cloudwatch_log_stream  () =
      { enabled; cloudwatch_log_group; cloudwatch_log_stream }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cloudwatch_log_stream
              (fun f ->
                 Query.Pair ("CloudwatchLogStream", (String.to_query f)));
           Util.option_map v.cloudwatch_log_group
             (fun f -> Query.Pair ("CloudwatchLogGroup", (String.to_query f)));
           Util.option_map v.enabled
             (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cloudwatch_log_stream
              (fun f -> ("cloudwatch_log_stream", (String.to_json f)));
           Util.option_map v.cloudwatch_log_group
             (fun f -> ("cloudwatch_log_group", (String.to_json f)));
           Util.option_map v.enabled
             (fun f -> ("enabled", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse);
          cloudwatch_log_group =
            (Util.option_bind (Xml.member "CloudwatchLogGroup" xml)
               String.parse);
          cloudwatch_log_stream =
            (Util.option_bind (Xml.member "CloudwatchLogStream" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.enabled
                (fun f -> Ezxmlm.make_tag "Enabled" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.cloudwatch_log_group
               (fun f ->
                  Ezxmlm.make_tag "CloudwatchLogGroup"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.cloudwatch_log_stream
              (fun f ->
                 Ezxmlm.make_tag "CloudwatchLogStream"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the client connection logging options for the Client VPN endpoint.</p>"]
module TransitGatewayPropagation =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option
        [@ocaml.doc "<p>The ID of the attachment.</p>"];
      resource_id: String.t option
        [@ocaml.doc "<p>The ID of the resource.</p>"];
      resource_type: TransitGatewayAttachmentResourceType.t option
        [@ocaml.doc "<p>The resource type.</p>"];
      transit_gateway_route_table_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway route table.</p>"];
      state: TransitGatewayPropagationState.t option
        [@ocaml.doc "<p>The state.</p>"]}[@@ocaml.doc
                                           "<p>Describes route propagation.</p>"]
    let make ?transit_gateway_attachment_id  ?resource_id  ?resource_type 
      ?transit_gateway_route_table_id  ?state  () =
      {
        transit_gateway_attachment_id;
        resource_id;
        resource_type;
        transit_gateway_route_table_id;
        state
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayPropagationState.to_query f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayRouteTableId", (String.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayPropagationState.to_json f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f -> ("transit_gateway_route_table_id", (String.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          transit_gateway_route_table_id =
            (Util.option_bind (Xml.member "transitGatewayRouteTableId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayPropagationState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.transit_gateway_attachment_id
                  (fun f ->
                     Ezxmlm.make_tag "transitGatewayAttachmentId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.resource_id
                 (fun f ->
                    Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.resource_type
                (fun f ->
                   Ezxmlm.make_tag "resourceType"
                     ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
            @
            [Util.option_map v.transit_gateway_route_table_id
               (fun f ->
                  Ezxmlm.make_tag "transitGatewayRouteTableId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (TransitGatewayPropagationState.to_xml f)))])
  end[@@ocaml.doc "<p>Describes route propagation.</p>"]
module ClassicLinkDnsSupportList =
  struct
    type t = ClassicLinkDnsSupport.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ClassicLinkDnsSupport.to_query v
    let to_headers v =
      Headers.to_headers_list ClassicLinkDnsSupport.to_headers v
    let to_json v = `List (List.map ClassicLinkDnsSupport.to_json v)
    let parse xml =
      Util.option_all
        (List.map ClassicLinkDnsSupport.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ClassicLinkDnsSupport.to_xml x))) v
  end
module ImportTaskIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ImportTaskId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module ReservedInstancesListingList =
  struct
    type t = ReservedInstancesListing.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ReservedInstancesListing.to_query v
    let to_headers v =
      Headers.to_headers_list ReservedInstancesListing.to_headers v
    let to_json v = `List (List.map ReservedInstancesListing.to_json v)
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesListing.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ReservedInstancesListing.to_xml x)))
        v
  end
module InstanceStateChangeList =
  struct
    type t = InstanceStateChange.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InstanceStateChange.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceStateChange.to_headers v
    let to_json v = `List (List.map InstanceStateChange.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceStateChange.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstanceStateChange.to_xml x))) v
  end
module ClientCertificateRevocationListStatus =
  struct
    type t =
      {
      code: ClientCertificateRevocationListStatusCode.t option
        [@ocaml.doc
          "<p>The state of the client certificate revocation list.</p>"];
      message: String.t option
        [@ocaml.doc
          "<p>A message about the status of the client certificate revocation list, if applicable.</p>"]}
    [@@ocaml.doc
      "<p>Describes the state of a client certificate revocation list.</p>"]
    let make ?code  ?message  () = { code; message }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code",
                    (ClientCertificateRevocationListStatusCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code",
                  (ClientCertificateRevocationListStatusCode.to_json f)))])
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               ClientCertificateRevocationListStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([],
                      (ClientCertificateRevocationListStatusCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the state of a client certificate revocation list.</p>"]
module TerminateConnectionStatusSet =
  struct
    type t = TerminateConnectionStatus.t list
    let make elems () = elems
    let to_query v = Query.to_query_list TerminateConnectionStatus.to_query v
    let to_headers v =
      Headers.to_headers_list TerminateConnectionStatus.to_headers v
    let to_json v = `List (List.map TerminateConnectionStatus.to_json v)
    let parse xml =
      Util.option_all
        (List.map TerminateConnectionStatus.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TerminateConnectionStatus.to_xml x))) v
  end
module InstanceTypeOfferingsList =
  struct
    type t = InstanceTypeOffering.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InstanceTypeOffering.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceTypeOffering.to_headers v
    let to_json v = `List (List.map InstanceTypeOffering.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceTypeOffering.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstanceTypeOffering.to_xml x))) v
  end
module InstanceStatusList =
  struct
    type t = InstanceStatus.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InstanceStatus.to_query v
    let to_headers v = Headers.to_headers_list InstanceStatus.to_headers v
    let to_json v = `List (List.map InstanceStatus.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceStatus.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InstanceStatus.to_xml x))) v
  end
module ImageList =
  struct
    type t = Image.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Image.to_query v
    let to_headers v = Headers.to_headers_list Image.to_headers v
    let to_json v = `List (List.map Image.to_json v)
    let parse xml =
      Util.option_all (List.map Image.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Image.to_xml x))) v
  end
module PriceScheduleSpecificationList =
  struct
    type t = PriceScheduleSpecification.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list PriceScheduleSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list PriceScheduleSpecification.to_headers v
    let to_json v = `List (List.map PriceScheduleSpecification.to_json v)
    let parse xml =
      Util.option_all
        (List.map PriceScheduleSpecification.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (PriceScheduleSpecification.to_xml x))) v
  end
module ImportSnapshotTaskList =
  struct
    type t = ImportSnapshotTask.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ImportSnapshotTask.to_query v
    let to_headers v =
      Headers.to_headers_list ImportSnapshotTask.to_headers v
    let to_json v = `List (List.map ImportSnapshotTask.to_json v)
    let parse xml =
      Util.option_all
        (List.map ImportSnapshotTask.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ImportSnapshotTask.to_xml x))) v
  end
module NetworkInterfacePermissionList =
  struct
    type t = NetworkInterfacePermission.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list NetworkInterfacePermission.to_query v
    let to_headers v =
      Headers.to_headers_list NetworkInterfacePermission.to_headers v
    let to_json v = `List (List.map NetworkInterfacePermission.to_json v)
    let parse xml =
      Util.option_all
        (List.map NetworkInterfacePermission.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (NetworkInterfacePermission.to_xml x))) v
  end
module SpotInstanceRequestIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "SpotInstanceRequestId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module TransitGatewayAssociation =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway route table.</p>"];
      transit_gateway_attachment_id: String.t option
        [@ocaml.doc "<p>The ID of the attachment.</p>"];
      resource_id: String.t option
        [@ocaml.doc "<p>The ID of the resource.</p>"];
      resource_type: TransitGatewayAttachmentResourceType.t option
        [@ocaml.doc "<p>The resource type.</p>"];
      state: TransitGatewayAssociationState.t option
        [@ocaml.doc "<p>The state of the association.</p>"]}[@@ocaml.doc
                                                              "<p>Describes an association between a resource attachment and a transit gateway route table.</p>"]
    let make ?transit_gateway_route_table_id  ?transit_gateway_attachment_id 
      ?resource_id  ?resource_type  ?state  () =
      {
        transit_gateway_route_table_id;
        transit_gateway_attachment_id;
        resource_id;
        resource_type;
        state
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayAssociationState.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayRouteTableId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayAssociationState.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f -> ("transit_gateway_route_table_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Util.option_bind (Xml.member "transitGatewayRouteTableId" xml)
               String.parse);
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAssociationState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.transit_gateway_route_table_id
                  (fun f ->
                     Ezxmlm.make_tag "transitGatewayRouteTableId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.transit_gateway_attachment_id
                 (fun f ->
                    Ezxmlm.make_tag "transitGatewayAttachmentId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.resource_id
                (fun f ->
                   Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "resourceType"
                    ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (TransitGatewayAssociationState.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an association between a resource attachment and a transit gateway route table.</p>"]
module InstanceTypeList =
  struct
    type t = InstanceType.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InstanceType.to_query v
    let to_headers v = Headers.to_headers_list InstanceType.to_headers v
    let to_json v = `List (List.map InstanceType.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceType.parse (Xml.members "member" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InstanceType.to_xml x))) v
  end
module ProductDescriptionList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module ResponseHostIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module HostList =
  struct
    type t = Host.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Host.to_query v
    let to_headers v = Headers.to_headers_list Host.to_headers v
    let to_json v = `List (List.map Host.to_json v)
    let parse xml =
      Util.option_all (List.map Host.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Host.to_xml x))) v
  end
module CustomerGatewayIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "CustomerGatewayId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module TransitGatewayMulticastDomainAssociations =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway multicast domain.</p>"];
      transit_gateway_attachment_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway attachment.</p>"];
      resource_id: String.t option
        [@ocaml.doc "<p>The ID of the resource.</p>"];
      resource_type: TransitGatewayAttachmentResourceType.t option
        [@ocaml.doc
          "<p>The type of resource, for example a VPC attachment.</p>"];
      subnets: SubnetAssociationList.t
        [@ocaml.doc
          "<p>The subnets associated with the multicast domain.</p>"]}
    [@@ocaml.doc "<p>Describes the multicast domain associations.</p>"]
    let make ?transit_gateway_multicast_domain_id 
      ?transit_gateway_attachment_id  ?resource_id  ?resource_type 
      ?(subnets= [])  () =
      {
        transit_gateway_multicast_domain_id;
        transit_gateway_attachment_id;
        resource_id;
        resource_type;
        subnets
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Subnets", (SubnetAssociationList.to_query v.subnets)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("subnets", (SubnetAssociationList.to_json v.subnets));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          subnets =
            (Util.of_option []
               (Util.option_bind (Xml.member "subnets" xml)
                  SubnetAssociationList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.transit_gateway_multicast_domain_id
                  (fun f ->
                     Ezxmlm.make_tag "transitGatewayMulticastDomainId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.transit_gateway_attachment_id
                 (fun f ->
                    Ezxmlm.make_tag "transitGatewayAttachmentId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.resource_id
                (fun f ->
                   Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "resourceType"
                    ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "subnets"
                      ([], (SubnetAssociationList.to_xml [x])))) v.subnets))
  end[@@ocaml.doc "<p>Describes the multicast domain associations.</p>"]
module LaunchTemplateSet =
  struct
    type t = LaunchTemplate.t list
    let make elems () = elems
    let to_query v = Query.to_query_list LaunchTemplate.to_query v
    let to_headers v = Headers.to_headers_list LaunchTemplate.to_headers v
    let to_json v = `List (List.map LaunchTemplate.to_json v)
    let parse xml =
      Util.option_all
        (List.map LaunchTemplate.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (LaunchTemplate.to_xml x))) v
  end
module PrefixListSet =
  struct
    type t = PrefixList.t list
    let make elems () = elems
    let to_query v = Query.to_query_list PrefixList.to_query v
    let to_headers v = Headers.to_headers_list PrefixList.to_headers v
    let to_json v = `List (List.map PrefixList.to_json v)
    let parse xml =
      Util.option_all (List.map PrefixList.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PrefixList.to_xml x))) v
  end
module VpnConnectionIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "VpnConnectionId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module InstanceFamilyCreditSpecification =
  struct
    type t =
      {
      instance_family: UnlimitedSupportedInstanceFamily.t option
        [@ocaml.doc "<p>The instance family.</p>"];
      cpu_credits: String.t option
        [@ocaml.doc
          "<p>The default credit option for CPU usage of the instance family. Valid values are <code>standard</code> and <code>unlimited</code>.</p>"]}
    [@@ocaml.doc
      "<p>Describes the default credit option for CPU usage of a burstable performance instance family.</p>"]
    let make ?instance_family  ?cpu_credits  () =
      { instance_family; cpu_credits }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> Query.Pair ("CpuCredits", (String.to_query f)));
           Util.option_map v.instance_family
             (fun f ->
                Query.Pair
                  ("InstanceFamily",
                    (UnlimitedSupportedInstanceFamily.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> ("cpu_credits", (String.to_json f)));
           Util.option_map v.instance_family
             (fun f ->
                ("instance_family",
                  (UnlimitedSupportedInstanceFamily.to_json f)))])
    let parse xml =
      Some
        {
          instance_family =
            (Util.option_bind (Xml.member "instanceFamily" xml)
               UnlimitedSupportedInstanceFamily.parse);
          cpu_credits =
            (Util.option_bind (Xml.member "cpuCredits" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_family
               (fun f ->
                  Ezxmlm.make_tag "instanceFamily"
                    ([], (UnlimitedSupportedInstanceFamily.to_xml f)))])
           @
           [Util.option_map v.cpu_credits
              (fun f -> Ezxmlm.make_tag "cpuCredits" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the default credit option for CPU usage of a burstable performance instance family.</p>"]
module ActiveInstanceSet =
  struct
    type t = ActiveInstance.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ActiveInstance.to_query v
    let to_headers v = Headers.to_headers_list ActiveInstance.to_headers v
    let to_json v = `List (List.map ActiveInstance.to_json v)
    let parse xml =
      Util.option_all
        (List.map ActiveInstance.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ActiveInstance.to_xml x))) v
  end
module SnapshotAttributeName =
  struct
    type t =
      | ProductCodes 
      | CreateVolumePermission 
    let str_to_t =
      [("createVolumePermission", CreateVolumePermission);
      ("productCodes", ProductCodes)]
    let t_to_str =
      [(CreateVolumePermission, "createVolumePermission");
      (ProductCodes, "productCodes")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module AttributeBooleanValue =
  struct
    type t =
      {
      value: Boolean.t option
        [@ocaml.doc
          "<p>The attribute value. The valid values are <code>true</code> or <code>false</code>.</p>"]}
    [@@ocaml.doc
      "<p>Describes a value for a resource attribute that is a Boolean value.</p>"]
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Boolean.to_json f)))])
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) Boolean.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes a value for a resource attribute that is a Boolean value.</p>"]
module BlobAttributeValue =
  struct
    type t = {
      value: Blob.t option }
    let make ?value  () = { value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Blob.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Blob.to_json f)))])
    let parse xml =
      Some { value = (Util.option_bind (Xml.member "value" xml) Blob.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (Blob.to_xml f)))])
  end
module InstanceBlockDeviceMappingSpecificationList =
  struct
    type t = InstanceBlockDeviceMappingSpecification.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list InstanceBlockDeviceMappingSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list
        InstanceBlockDeviceMappingSpecification.to_headers v
    let to_json v =
      `List (List.map InstanceBlockDeviceMappingSpecification.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceBlockDeviceMappingSpecification.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InstanceBlockDeviceMappingSpecification.to_xml x))) v
  end
module FpgaImageAttribute =
  struct
    type t =
      {
      fpga_image_id: String.t option [@ocaml.doc "<p>The ID of the AFI.</p>"];
      name: String.t option [@ocaml.doc "<p>The name of the AFI.</p>"];
      description: String.t option
        [@ocaml.doc "<p>The description of the AFI.</p>"];
      load_permissions: LoadPermissionList.t
        [@ocaml.doc "<p>The load permissions.</p>"];
      product_codes: ProductCodeList.t
        [@ocaml.doc "<p>The product codes.</p>"]}[@@ocaml.doc
                                                   "<p>Describes an Amazon FPGA image (AFI) attribute.</p>"]
    let make ?fpga_image_id  ?name  ?description  ?(load_permissions= []) 
      ?(product_codes= [])  () =
      { fpga_image_id; name; description; load_permissions; product_codes }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Some
             (Query.Pair
                ("LoadPermissions",
                  (LoadPermissionList.to_query v.load_permissions)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.fpga_image_id
             (fun f -> Query.Pair ("FpgaImageId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Some
             ("load_permissions",
               (LoadPermissionList.to_json v.load_permissions));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.fpga_image_id
             (fun f -> ("fpga_image_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          fpga_image_id =
            (Util.option_bind (Xml.member "fpgaImageId" xml) String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          load_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "loadPermissions" xml)
                  LoadPermissionList.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.fpga_image_id
                  (fun f ->
                     Ezxmlm.make_tag "fpgaImageId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.name
                 (fun f -> Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "loadPermissions"
                       ([], (LoadPermissionList.to_xml [x]))))
               v.load_permissions))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "productCodes"
                      ([], (ProductCodeList.to_xml [x])))) v.product_codes))
  end[@@ocaml.doc "<p>Describes an Amazon FPGA image (AFI) attribute.</p>"]
module CopyTagsFromSource =
  struct
    type t =
      | Volume 
    let str_to_t = [("volume", Volume)]
    let t_to_str = [(Volume, "volume")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module InstanceSpecification =
  struct
    type t =
      {
      instance_id: String.t option
        [@ocaml.doc
          "<p>The instance to specify which volumes should be snapshotted.</p>"];
      exclude_boot_volume: Boolean.t option
        [@ocaml.doc
          "<p>Excludes the root volume from being snapshotted.</p>"]}
    [@@ocaml.doc
      "<p>The instance details to specify which volumes should be snapshotted.</p>"]
    let make ?instance_id  ?exclude_boot_volume  () =
      { instance_id; exclude_boot_volume }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.exclude_boot_volume
              (fun f ->
                 Query.Pair ("ExcludeBootVolume", (Boolean.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.exclude_boot_volume
              (fun f -> ("exclude_boot_volume", (Boolean.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          exclude_boot_volume =
            (Util.option_bind (Xml.member "ExcludeBootVolume" xml)
               Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "InstanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.exclude_boot_volume
              (fun f ->
                 Ezxmlm.make_tag "ExcludeBootVolume" ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc
       "<p>The instance details to specify which volumes should be snapshotted.</p>"]
module ZoneIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "ZoneId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module ZoneNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "ZoneName" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module InstanceIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "InstanceId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module TransitGatewayMulticastDomainList =
  struct
    type t = TransitGatewayMulticastDomain.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list TransitGatewayMulticastDomain.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayMulticastDomain.to_headers v
    let to_json v = `List (List.map TransitGatewayMulticastDomain.to_json v)
    let parse xml =
      Util.option_all
        (List.map TransitGatewayMulticastDomain.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayMulticastDomain.to_xml x))) v
  end
module PrincipalIdFormatList =
  struct
    type t = PrincipalIdFormat.t list
    let make elems () = elems
    let to_query v = Query.to_query_list PrincipalIdFormat.to_query v
    let to_headers v = Headers.to_headers_list PrincipalIdFormat.to_headers v
    let to_json v = `List (List.map PrincipalIdFormat.to_json v)
    let parse xml =
      Util.option_all
        (List.map PrincipalIdFormat.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PrincipalIdFormat.to_xml x)))
        v
  end
module VpnGatewayIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "VpnGatewayId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module AllowedPrincipalSet =
  struct
    type t = AllowedPrincipal.t list
    let make elems () = elems
    let to_query v = Query.to_query_list AllowedPrincipal.to_query v
    let to_headers v = Headers.to_headers_list AllowedPrincipal.to_headers v
    let to_json v = `List (List.map AllowedPrincipal.to_json v)
    let parse xml =
      Util.option_all
        (List.map AllowedPrincipal.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (AllowedPrincipal.to_xml x)))
        v
  end
module ByoipCidrSet =
  struct
    type t = ByoipCidr.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ByoipCidr.to_query v
    let to_headers v = Headers.to_headers_list ByoipCidr.to_headers v
    let to_json v = `List (List.map ByoipCidr.to_json v)
    let parse xml =
      Util.option_all (List.map ByoipCidr.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (ByoipCidr.to_xml x)))
        v
  end
module CoipPoolSet =
  struct
    type t = CoipPool.t list
    let make elems () = elems
    let to_query v = Query.to_query_list CoipPool.to_query v
    let to_headers v = Headers.to_headers_list CoipPool.to_headers v
    let to_json v = `List (List.map CoipPool.to_json v)
    let parse xml =
      Util.option_all (List.map CoipPool.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (CoipPool.to_xml x)))
        v
  end
module SpotDatafeedSubscription =
  struct
    type t =
      {
      bucket: String.t option
        [@ocaml.doc
          "<p>The Amazon S3 bucket where the Spot Instance data feed is located.</p>"];
      fault: SpotInstanceStateFault.t option
        [@ocaml.doc
          "<p>The fault codes for the Spot Instance request, if any.</p>"];
      owner_id: String.t option
        [@ocaml.doc "<p>The AWS account ID of the account.</p>"];
      prefix: String.t option
        [@ocaml.doc
          "<p>The prefix that is prepended to data feed files.</p>"];
      state: DatafeedSubscriptionState.t option
        [@ocaml.doc
          "<p>The state of the Spot Instance data feed subscription.</p>"]}
    [@@ocaml.doc "<p>Describes the data feed for a Spot Instance.</p>"]
    let make ?bucket  ?fault  ?owner_id  ?prefix  ?state  () =
      { bucket; fault; owner_id; prefix; state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair ("State", (DatafeedSubscriptionState.to_query f)));
           Util.option_map v.prefix
             (fun f -> Query.Pair ("Prefix", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.fault
             (fun f ->
                Query.Pair ("Fault", (SpotInstanceStateFault.to_query f)));
           Util.option_map v.bucket
             (fun f -> Query.Pair ("Bucket", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (DatafeedSubscriptionState.to_json f)));
           Util.option_map v.prefix (fun f -> ("prefix", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.fault
             (fun f -> ("fault", (SpotInstanceStateFault.to_json f)));
           Util.option_map v.bucket (fun f -> ("bucket", (String.to_json f)))])
    let parse xml =
      Some
        {
          bucket = (Util.option_bind (Xml.member "bucket" xml) String.parse);
          fault =
            (Util.option_bind (Xml.member "fault" xml)
               SpotInstanceStateFault.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          prefix = (Util.option_bind (Xml.member "prefix" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               DatafeedSubscriptionState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.bucket
                  (fun f -> Ezxmlm.make_tag "bucket" ([], (String.to_xml f)))])
              @
              [Util.option_map v.fault
                 (fun f ->
                    Ezxmlm.make_tag "fault"
                      ([], (SpotInstanceStateFault.to_xml f)))])
             @
             [Util.option_map v.owner_id
                (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.prefix
               (fun f -> Ezxmlm.make_tag "prefix" ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (DatafeedSubscriptionState.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the data feed for a Spot Instance.</p>"]
module DeleteFleetErrorSet =
  struct
    type t = DeleteFleetErrorItem.t list
    let make elems () = elems
    let to_query v = Query.to_query_list DeleteFleetErrorItem.to_query v
    let to_headers v =
      Headers.to_headers_list DeleteFleetErrorItem.to_headers v
    let to_json v = `List (List.map DeleteFleetErrorItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map DeleteFleetErrorItem.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (DeleteFleetErrorItem.to_xml x))) v
  end
module DeleteFleetSuccessSet =
  struct
    type t = DeleteFleetSuccessItem.t list
    let make elems () = elems
    let to_query v = Query.to_query_list DeleteFleetSuccessItem.to_query v
    let to_headers v =
      Headers.to_headers_list DeleteFleetSuccessItem.to_headers v
    let to_json v = `List (List.map DeleteFleetSuccessItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map DeleteFleetSuccessItem.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (DeleteFleetSuccessItem.to_xml x)))
        v
  end
module DisableFastSnapshotRestoreErrorSet =
  struct
    type t = DisableFastSnapshotRestoreErrorItem.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list DisableFastSnapshotRestoreErrorItem.to_query v
    let to_headers v =
      Headers.to_headers_list DisableFastSnapshotRestoreErrorItem.to_headers
        v
    let to_json v =
      `List (List.map DisableFastSnapshotRestoreErrorItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map DisableFastSnapshotRestoreErrorItem.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (DisableFastSnapshotRestoreErrorItem.to_xml x))) v
  end
module DisableFastSnapshotRestoreSuccessSet =
  struct
    type t = DisableFastSnapshotRestoreSuccessItem.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list DisableFastSnapshotRestoreSuccessItem.to_query v
    let to_headers v =
      Headers.to_headers_list
        DisableFastSnapshotRestoreSuccessItem.to_headers v
    let to_json v =
      `List (List.map DisableFastSnapshotRestoreSuccessItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map DisableFastSnapshotRestoreSuccessItem.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (DisableFastSnapshotRestoreSuccessItem.to_xml x))) v
  end
module ReservedInstancesModificationIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse
           (Xml.members "ReservedInstancesModificationId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module RequestInstanceTypeList =
  struct
    type t = InstanceType.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InstanceType.to_query v
    let to_headers v = Headers.to_headers_list InstanceType.to_headers v
    let to_json v = `List (List.map InstanceType.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceType.parse (Xml.members "member" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InstanceType.to_xml x))) v
  end
module PlacementGroupIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "GroupId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module PlacementGroupStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module Ipv6AddressList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module ScheduledInstanceSet =
  struct
    type t = ScheduledInstance.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ScheduledInstance.to_query v
    let to_headers v = Headers.to_headers_list ScheduledInstance.to_headers v
    let to_json v = `List (List.map ScheduledInstance.to_json v)
    let parse xml =
      Util.option_all
        (List.map ScheduledInstance.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ScheduledInstance.to_xml x)))
        v
  end
module FlowLogSet =
  struct
    type t = FlowLog.t list
    let make elems () = elems
    let to_query v = Query.to_query_list FlowLog.to_query v
    let to_headers v = Headers.to_headers_list FlowLog.to_headers v
    let to_json v = `List (List.map FlowLog.to_json v)
    let parse xml =
      Util.option_all (List.map FlowLog.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (FlowLog.to_xml x))) v
  end
module BundleTaskList =
  struct
    type t = BundleTask.t list
    let make elems () = elems
    let to_query v = Query.to_query_list BundleTask.to_query v
    let to_headers v = Headers.to_headers_list BundleTask.to_headers v
    let to_json v = `List (List.map BundleTask.to_json v)
    let parse xml =
      Util.option_all (List.map BundleTask.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (BundleTask.to_xml x))) v
  end
module InstanceCreditSpecificationList =
  struct
    type t = InstanceCreditSpecification.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list InstanceCreditSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceCreditSpecification.to_headers v
    let to_json v = `List (List.map InstanceCreditSpecification.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceCreditSpecification.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InstanceCreditSpecification.to_xml x))) v
  end
module SubnetIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "SubnetId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module CoipAddressUsageSet =
  struct
    type t = CoipAddressUsage.t list
    let make elems () = elems
    let to_query v = Query.to_query_list CoipAddressUsage.to_query v
    let to_headers v = Headers.to_headers_list CoipAddressUsage.to_headers v
    let to_json v = `List (List.map CoipAddressUsage.to_json v)
    let parse xml =
      Util.option_all
        (List.map CoipAddressUsage.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (CoipAddressUsage.to_xml x)))
        v
  end
module ReservedInstanceIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ReservedInstanceId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module TargetConfigurationRequestSet =
  struct
    type t = TargetConfigurationRequest.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list TargetConfigurationRequest.to_query v
    let to_headers v =
      Headers.to_headers_list TargetConfigurationRequest.to_headers v
    let to_json v = `List (List.map TargetConfigurationRequest.to_json v)
    let parse xml =
      Util.option_all
        (List.map TargetConfigurationRequest.parse
           (Xml.members "TargetConfigurationRequest" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TargetConfigurationRequest.to_xml x))) v
  end
module LocalGatewayRouteTableVpcAssociationIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module StaleSecurityGroupSet =
  struct
    type t = StaleSecurityGroup.t list
    let make elems () = elems
    let to_query v = Query.to_query_list StaleSecurityGroup.to_query v
    let to_headers v =
      Headers.to_headers_list StaleSecurityGroup.to_headers v
    let to_json v = `List (List.map StaleSecurityGroup.to_json v)
    let parse xml =
      Util.option_all
        (List.map StaleSecurityGroup.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (StaleSecurityGroup.to_xml x))) v
  end
module SecurityGroupReferences =
  struct
    type t = SecurityGroupReference.t list
    let make elems () = elems
    let to_query v = Query.to_query_list SecurityGroupReference.to_query v
    let to_headers v =
      Headers.to_headers_list SecurityGroupReference.to_headers v
    let to_json v = `List (List.map SecurityGroupReference.to_json v)
    let parse xml =
      Util.option_all
        (List.map SecurityGroupReference.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (SecurityGroupReference.to_xml x)))
        v
  end
module AssignedPrivateIpAddressList =
  struct
    type t = AssignedPrivateIpAddress.t list
    let make elems () = elems
    let to_query v = Query.to_query_list AssignedPrivateIpAddress.to_query v
    let to_headers v =
      Headers.to_headers_list AssignedPrivateIpAddress.to_headers v
    let to_json v = `List (List.map AssignedPrivateIpAddress.to_json v)
    let parse xml =
      Util.option_all
        (List.map AssignedPrivateIpAddress.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (AssignedPrivateIpAddress.to_xml x)))
        v
  end
module TransitGatewayMulticastRegisteredGroupMembers =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway multicast domain.</p>"];
      registered_network_interface_ids: ValueStringList.t
        [@ocaml.doc "<p>The ID of the registered network interfaces.</p>"];
      group_ip_address: String.t option
        [@ocaml.doc
          "<p>The IP address assigned to the transit gateway multicast group.</p>"]}
    [@@ocaml.doc
      "<p>Describes the registered transit gateway multicast group members.</p>"]
    let make ?transit_gateway_multicast_domain_id 
      ?(registered_network_interface_ids= [])  ?group_ip_address  () =
      {
        transit_gateway_multicast_domain_id;
        registered_network_interface_ids;
        group_ip_address
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("RegisteredNetworkInterfaceIds",
                  (ValueStringList.to_query
                     v.registered_network_interface_ids)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> ("group_ip_address", (String.to_json f)));
           Some
             ("registered_network_interface_ids",
               (ValueStringList.to_json v.registered_network_interface_ids));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          registered_network_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "registeredNetworkInterfaceIds" xml)
                  ValueStringList.parse));
          group_ip_address =
            (Util.option_bind (Xml.member "groupIpAddress" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.transit_gateway_multicast_domain_id
                (fun f ->
                   Ezxmlm.make_tag "transitGatewayMulticastDomainId"
                     ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "registeredNetworkInterfaceIds"
                       ([], (ValueStringList.to_xml [x]))))
               v.registered_network_interface_ids))
           @
           [Util.option_map v.group_ip_address
              (fun f ->
                 Ezxmlm.make_tag "groupIpAddress" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the registered transit gateway multicast group members.</p>"]
module LocalGatewayRouteTableVpcAssociationSet =
  struct
    type t = LocalGatewayRouteTableVpcAssociation.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list LocalGatewayRouteTableVpcAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list LocalGatewayRouteTableVpcAssociation.to_headers
        v
    let to_json v =
      `List (List.map LocalGatewayRouteTableVpcAssociation.to_json v)
    let parse xml =
      Util.option_all
        (List.map LocalGatewayRouteTableVpcAssociation.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LocalGatewayRouteTableVpcAssociation.to_xml x))) v
  end
module AssociationIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "AssociationId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module CreateVolumePermissionModifications =
  struct
    type t =
      {
      add: CreateVolumePermissionList.t
        [@ocaml.doc
          "<p>Adds the specified AWS account ID or group to the list.</p>"];
      remove: CreateVolumePermissionList.t
        [@ocaml.doc
          "<p>Removes the specified AWS account ID or group from the list.</p>"]}
    [@@ocaml.doc
      "<p>Describes modifications to the list of create volume permissions for a volume.</p>"]
    let make ?(add= [])  ?(remove= [])  () = { add; remove }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Remove", (CreateVolumePermissionList.to_query v.remove)));
           Some
             (Query.Pair ("Add", (CreateVolumePermissionList.to_query v.add)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("remove", (CreateVolumePermissionList.to_json v.remove));
           Some ("add", (CreateVolumePermissionList.to_json v.add))])
    let parse xml =
      Some
        {
          add =
            (Util.of_option []
               (Util.option_bind (Xml.member "Add" xml)
                  CreateVolumePermissionList.parse));
          remove =
            (Util.of_option []
               (Util.option_bind (Xml.member "Remove" xml)
                  CreateVolumePermissionList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Add"
                       ([], (CreateVolumePermissionList.to_xml [x])))) v.add))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Remove"
                      ([], (CreateVolumePermissionList.to_xml [x]))))
              v.remove))
  end[@@ocaml.doc
       "<p>Describes modifications to the list of create volume permissions for a volume.</p>"]
module VolumeList =
  struct
    type t = Volume.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Volume.to_query v
    let to_headers v = Headers.to_headers_list Volume.to_headers v
    let to_json v = `List (List.map Volume.to_json v)
    let parse xml =
      Util.option_all (List.map Volume.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Volume.to_xml x))) v
  end
module AvailabilityZoneStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "AvailabilityZone" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module SnapshotIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "SnapshotId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module ClientVpnConnectionSet =
  struct
    type t = ClientVpnConnection.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ClientVpnConnection.to_query v
    let to_headers v =
      Headers.to_headers_list ClientVpnConnection.to_headers v
    let to_json v = `List (List.map ClientVpnConnection.to_json v)
    let parse xml =
      Util.option_all
        (List.map ClientVpnConnection.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ClientVpnConnection.to_xml x))) v
  end
module TrafficMirrorPortRangeRequest =
  struct
    type t =
      {
      from_port: Integer.t option
        [@ocaml.doc
          "<p>The first port in the Traffic Mirror port range. This applies to the TCP and UDP protocols.</p>"];
      to_port: Integer.t option
        [@ocaml.doc
          "<p>The last port in the Traffic Mirror port range. This applies to the TCP and UDP protocols.</p>"]}
    [@@ocaml.doc
      "<p>Information about the Traffic Mirror filter rule port range.</p>"]
    let make ?from_port  ?to_port  () = { from_port; to_port }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.to_port
              (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.to_port
              (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          from_port =
            (Util.option_bind (Xml.member "FromPort" xml) Integer.parse);
          to_port =
            (Util.option_bind (Xml.member "ToPort" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.from_port
               (fun f -> Ezxmlm.make_tag "FromPort" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.to_port
              (fun f -> Ezxmlm.make_tag "ToPort" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc
       "<p>Information about the Traffic Mirror filter rule port range.</p>"]
module VolumeIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "VolumeId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module LocalGatewayRouteTableSet =
  struct
    type t = LocalGatewayRouteTable.t list
    let make elems () = elems
    let to_query v = Query.to_query_list LocalGatewayRouteTable.to_query v
    let to_headers v =
      Headers.to_headers_list LocalGatewayRouteTable.to_headers v
    let to_json v = `List (List.map LocalGatewayRouteTable.to_json v)
    let parse xml =
      Util.option_all
        (List.map LocalGatewayRouteTable.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (LocalGatewayRouteTable.to_xml x)))
        v
  end
module VpcClassicLinkIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "VpcId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module RegionList =
  struct
    type t = Region.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Region.to_query v
    let to_headers v = Headers.to_headers_list Region.to_headers v
    let to_json v = `List (List.map Region.to_json v)
    let parse xml =
      Util.option_all (List.map Region.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Region.to_xml x))) v
  end
module VpnConnectionOptionsSpecification =
  struct
    type t =
      {
      enable_acceleration: Boolean.t option
        [@ocaml.doc
          "<p>Indicate whether to enable acceleration for the VPN connection.</p> <p>Default: <code>false</code> </p>"];
      static_routes_only: Boolean.t option
        [@ocaml.doc
          "<p>Indicate whether the VPN connection uses static routes only. If you are creating a VPN connection for a device that does not support BGP, you must specify <code>true</code>. Use <a>CreateVpnConnectionRoute</a> to create a static route.</p> <p>Default: <code>false</code> </p>"];
      tunnel_options: VpnTunnelOptionsSpecificationsList.t
        [@ocaml.doc "<p>The tunnel options for the VPN connection.</p>"]}
    [@@ocaml.doc "<p>Describes VPN connection options.</p>"]
    let make ?enable_acceleration  ?static_routes_only  ?(tunnel_options= [])
       () = { enable_acceleration; static_routes_only; tunnel_options }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TunnelOptions",
                   (VpnTunnelOptionsSpecificationsList.to_query
                      v.tunnel_options)));
           Util.option_map v.static_routes_only
             (fun f -> Query.Pair ("StaticRoutesOnly", (Boolean.to_query f)));
           Util.option_map v.enable_acceleration
             (fun f ->
                Query.Pair ("EnableAcceleration", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tunnel_options",
                (VpnTunnelOptionsSpecificationsList.to_json v.tunnel_options));
           Util.option_map v.static_routes_only
             (fun f -> ("static_routes_only", (Boolean.to_json f)));
           Util.option_map v.enable_acceleration
             (fun f -> ("enable_acceleration", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          enable_acceleration =
            (Util.option_bind (Xml.member "EnableAcceleration" xml)
               Boolean.parse);
          static_routes_only =
            (Util.option_bind (Xml.member "staticRoutesOnly" xml)
               Boolean.parse);
          tunnel_options =
            (Util.of_option []
               (Util.option_bind (Xml.member "TunnelOptions" xml)
                  VpnTunnelOptionsSpecificationsList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.enable_acceleration
                (fun f ->
                   Ezxmlm.make_tag "EnableAcceleration"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.static_routes_only
               (fun f ->
                  Ezxmlm.make_tag "staticRoutesOnly" ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "TunnelOptions"
                      ([], (VpnTunnelOptionsSpecificationsList.to_xml [x]))))
              v.tunnel_options))
  end[@@ocaml.doc "<p>Describes VPN connection options.</p>"]
module CidrAuthorizationContext =
  struct
    type t =
      {
      message: String.t
        [@ocaml.doc
          "<p>The plain-text authorization message for the prefix and account.</p>"];
      signature: String.t
        [@ocaml.doc
          "<p>The signed authorization message for the prefix and account.</p>"]}
    [@@ocaml.doc
      "<p>Provides authorization for Amazon to bring a specific IP address range to a specific AWS account using bring your own IP addresses (BYOIP). For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-byoip.html#prepare-for-byoip\">Prepare to Bring Your Address Range to Your AWS Account</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"]
    let make ~message  ~signature  () = { message; signature }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Signature", (String.to_query v.signature)));
           Some (Query.Pair ("Message", (String.to_query v.message)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("signature", (String.to_json v.signature));
           Some ("message", (String.to_json v.message))])
    let parse xml =
      Some
        {
          message =
            (Xml.required "Message"
               (Util.option_bind (Xml.member "Message" xml) String.parse));
          signature =
            (Xml.required "Signature"
               (Util.option_bind (Xml.member "Signature" xml) String.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some (Ezxmlm.make_tag "Message" ([], (String.to_xml v.message)))])
           @
           [Some
              (Ezxmlm.make_tag "Signature" ([], (String.to_xml v.signature)))])
  end[@@ocaml.doc
       "<p>Provides authorization for Amazon to bring a specific IP address range to a specific AWS account using bring your own IP addresses (BYOIP). For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-byoip.html#prepare-for-byoip\">Prepare to Bring Your Address Range to Your AWS Account</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"]
module ModifyTransitGatewayVpcAttachmentRequestOptions =
  struct
    type t =
      {
      dns_support: DnsSupportValue.t option
        [@ocaml.doc
          "<p>Enable or disable DNS support. The default is <code>enable</code>.</p>"];
      ipv6_support: Ipv6SupportValue.t option
        [@ocaml.doc
          "<p>Enable or disable IPv6 support. The default is <code>enable</code>.</p>"]}
    [@@ocaml.doc "<p>Describes the options for a VPC attachment.</p>"]
    let make ?dns_support  ?ipv6_support  () = { dns_support; ipv6_support }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_support
              (fun f ->
                 Query.Pair ("Ipv6Support", (Ipv6SupportValue.to_query f)));
           Util.option_map v.dns_support
             (fun f ->
                Query.Pair ("DnsSupport", (DnsSupportValue.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_support
              (fun f -> ("ipv6_support", (Ipv6SupportValue.to_json f)));
           Util.option_map v.dns_support
             (fun f -> ("dns_support", (DnsSupportValue.to_json f)))])
    let parse xml =
      Some
        {
          dns_support =
            (Util.option_bind (Xml.member "DnsSupport" xml)
               DnsSupportValue.parse);
          ipv6_support =
            (Util.option_bind (Xml.member "Ipv6Support" xml)
               Ipv6SupportValue.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dns_support
               (fun f ->
                  Ezxmlm.make_tag "DnsSupport"
                    ([], (DnsSupportValue.to_xml f)))])
           @
           [Util.option_map v.ipv6_support
              (fun f ->
                 Ezxmlm.make_tag "Ipv6Support"
                   ([], (Ipv6SupportValue.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the options for a VPC attachment.</p>"]
module AllocationIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "AllocationId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module PublicIpStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "PublicIp" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module PeeringConnectionOptionsRequest =
  struct
    type t =
      {
      allow_dns_resolution_from_remote_vpc: Boolean.t option
        [@ocaml.doc
          "<p>If true, enables a local VPC to resolve public DNS hostnames to private IP addresses when queried from instances in the peer VPC.</p>"];
      allow_egress_from_local_classic_link_to_remote_vpc: Boolean.t option
        [@ocaml.doc
          "<p>If true, enables outbound communication from an EC2-Classic instance that's linked to a local VPC using ClassicLink to instances in a peer VPC.</p>"];
      allow_egress_from_local_vpc_to_remote_classic_link: Boolean.t option
        [@ocaml.doc
          "<p>If true, enables outbound communication from instances in a local VPC to an EC2-Classic instance that's linked to a peer VPC using ClassicLink.</p>"]}
    [@@ocaml.doc "<p>The VPC peering connection options.</p>"]
    let make ?allow_dns_resolution_from_remote_vpc 
      ?allow_egress_from_local_classic_link_to_remote_vpc 
      ?allow_egress_from_local_vpc_to_remote_classic_link  () =
      {
        allow_dns_resolution_from_remote_vpc;
        allow_egress_from_local_classic_link_to_remote_vpc;
        allow_egress_from_local_vpc_to_remote_classic_link
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 Query.Pair
                   ("AllowEgressFromLocalVpcToRemoteClassicLink",
                     (Boolean.to_query f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowEgressFromLocalClassicLinkToRemoteVpc",
                    (Boolean.to_query f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowDnsResolutionFromRemoteVpc", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 ("allow_egress_from_local_vpc_to_remote_classic_link",
                   (Boolean.to_json f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                ("allow_egress_from_local_classic_link_to_remote_vpc",
                  (Boolean.to_json f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                ("allow_dns_resolution_from_remote_vpc", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          allow_dns_resolution_from_remote_vpc =
            (Util.option_bind
               (Xml.member "AllowDnsResolutionFromRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_classic_link_to_remote_vpc =
            (Util.option_bind
               (Xml.member "AllowEgressFromLocalClassicLinkToRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_vpc_to_remote_classic_link =
            (Util.option_bind
               (Xml.member "AllowEgressFromLocalVpcToRemoteClassicLink" xml)
               Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.allow_dns_resolution_from_remote_vpc
                (fun f ->
                   Ezxmlm.make_tag "AllowDnsResolutionFromRemoteVpc"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map
               v.allow_egress_from_local_classic_link_to_remote_vpc
               (fun f ->
                  Ezxmlm.make_tag
                    "AllowEgressFromLocalClassicLinkToRemoteVpc"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 Ezxmlm.make_tag "AllowEgressFromLocalVpcToRemoteClassicLink"
                   ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc "<p>The VPC peering connection options.</p>"]
module AddressList =
  struct
    type t = Address.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Address.to_query v
    let to_headers v = Headers.to_headers_list Address.to_headers v
    let to_json v = `List (List.map Address.to_json v)
    let parse xml =
      Util.option_all (List.map Address.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Address.to_xml x))) v
  end
module InstanceTypeInfoList =
  struct
    type t = InstanceTypeInfo.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InstanceTypeInfo.to_query v
    let to_headers v = Headers.to_headers_list InstanceTypeInfo.to_headers v
    let to_json v = `List (List.map InstanceTypeInfo.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceTypeInfo.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InstanceTypeInfo.to_xml x)))
        v
  end
module ClientVpnRouteSet =
  struct
    type t = ClientVpnRoute.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ClientVpnRoute.to_query v
    let to_headers v = Headers.to_headers_list ClientVpnRoute.to_headers v
    let to_json v = `List (List.map ClientVpnRoute.to_json v)
    let parse xml =
      Util.option_all
        (List.map ClientVpnRoute.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ClientVpnRoute.to_xml x))) v
  end
module CapacityReservationSpecification =
  struct
    type t =
      {
      capacity_reservation_preference: CapacityReservationPreference.t option
        [@ocaml.doc
          "<p>Indicates the instance's Capacity Reservation preferences. Possible preferences include:</p> <ul> <li> <p> <code>open</code> - The instance can run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).</p> </li> <li> <p> <code>none</code> - The instance avoids running in a Capacity Reservation even if one is available. The instance runs as an On-Demand Instance.</p> </li> </ul>"];
      capacity_reservation_target: CapacityReservationTarget.t option
        [@ocaml.doc
          "<p>Information about the target Capacity Reservation.</p>"]}
    [@@ocaml.doc
      "<p>Describes an instance's Capacity Reservation targeting option. You can specify only one parameter at a time. If you specify <code>CapacityReservationPreference</code> and <code>CapacityReservationTarget</code>, the request fails.</p> <p>Use the <code>CapacityReservationPreference</code> parameter to configure the instance to run as an On-Demand Instance or to run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). Use the <code>CapacityReservationTarget</code> parameter to explicitly target a specific Capacity Reservation.</p>"]
    let make ?capacity_reservation_preference  ?capacity_reservation_target 
      () = { capacity_reservation_preference; capacity_reservation_target }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Query.Pair
                   ("CapacityReservationTarget",
                     (CapacityReservationTarget.to_query f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                Query.Pair
                  ("CapacityReservationPreference",
                    (CapacityReservationPreference.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 ("capacity_reservation_target",
                   (CapacityReservationTarget.to_json f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                ("capacity_reservation_preference",
                  (CapacityReservationPreference.to_json f)))])
    let parse xml =
      Some
        {
          capacity_reservation_preference =
            (Util.option_bind
               (Xml.member "CapacityReservationPreference" xml)
               CapacityReservationPreference.parse);
          capacity_reservation_target =
            (Util.option_bind (Xml.member "CapacityReservationTarget" xml)
               CapacityReservationTarget.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.capacity_reservation_preference
               (fun f ->
                  Ezxmlm.make_tag "CapacityReservationPreference"
                    ([], (CapacityReservationPreference.to_xml f)))])
           @
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Ezxmlm.make_tag "CapacityReservationTarget"
                   ([], (CapacityReservationTarget.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes an instance's Capacity Reservation targeting option. You can specify only one parameter at a time. If you specify <code>CapacityReservationPreference</code> and <code>CapacityReservationTarget</code>, the request fails.</p> <p>Use the <code>CapacityReservationPreference</code> parameter to configure the instance to run as an On-Demand Instance or to run in any <code>open</code> Capacity Reservation that has matching attributes (instance type, platform, Availability Zone). Use the <code>CapacityReservationTarget</code> parameter to explicitly target a specific Capacity Reservation.</p>"]
module ClientVpnSecurityGroupIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module VpnConnectionList =
  struct
    type t = VpnConnection.t list
    let make elems () = elems
    let to_query v = Query.to_query_list VpnConnection.to_query v
    let to_headers v = Headers.to_headers_list VpnConnection.to_headers v
    let to_json v = `List (List.map VpnConnection.to_json v)
    let parse xml =
      Util.option_all (List.map VpnConnection.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VpnConnection.to_xml x))) v
  end
module RequestHostIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module DnsServersOptionsModifyStructure =
  struct
    type t =
      {
      custom_dns_servers: ValueStringList.t
        [@ocaml.doc
          "<p>The IPv4 address range, in CIDR notation, of the DNS servers to be used. You can specify up to two DNS servers. Ensure that the DNS servers can be reached by the clients. The specified values overwrite the existing values.</p>"];
      enabled: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether DNS servers should be used. Specify <code>False</code> to delete the existing DNS servers.</p>"]}
    [@@ocaml.doc "<p>Information about the DNS server to be used.</p>"]
    let make ?(custom_dns_servers= [])  ?enabled  () =
      { custom_dns_servers; enabled }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("CustomDnsServers",
                  (ValueStringList.to_query v.custom_dns_servers)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)));
           Some
             ("custom_dns_servers",
               (ValueStringList.to_json v.custom_dns_servers))])
    let parse xml =
      Some
        {
          custom_dns_servers =
            (Util.of_option []
               (Util.option_bind (Xml.member "CustomDnsServers" xml)
                  ValueStringList.parse));
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "CustomDnsServers"
                       ([], (ValueStringList.to_xml [x]))))
               v.custom_dns_servers))
           @
           [Util.option_map v.enabled
              (fun f -> Ezxmlm.make_tag "Enabled" ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc "<p>Information about the DNS server to be used.</p>"]
module TargetNetworkSet =
  struct
    type t = TargetNetwork.t list
    let make elems () = elems
    let to_query v = Query.to_query_list TargetNetwork.to_query v
    let to_headers v = Headers.to_headers_list TargetNetwork.to_headers v
    let to_json v = `List (List.map TargetNetwork.to_json v)
    let parse xml =
      Util.option_all (List.map TargetNetwork.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (TargetNetwork.to_xml x))) v
  end
module RegionNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "RegionName" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module BillingProductList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module VpcPeeringConnectionList =
  struct
    type t = VpcPeeringConnection.t list
    let make elems () = elems
    let to_query v = Query.to_query_list VpcPeeringConnection.to_query v
    let to_headers v =
      Headers.to_headers_list VpcPeeringConnection.to_headers v
    let to_json v = `List (List.map VpcPeeringConnection.to_json v)
    let parse xml =
      Util.option_all
        (List.map VpcPeeringConnection.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (VpcPeeringConnection.to_xml x))) v
  end
module NetworkAclList =
  struct
    type t = NetworkAcl.t list
    let make elems () = elems
    let to_query v = Query.to_query_list NetworkAcl.to_query v
    let to_headers v = Headers.to_headers_list NetworkAcl.to_headers v
    let to_json v = `List (List.map NetworkAcl.to_json v)
    let parse xml =
      Util.option_all (List.map NetworkAcl.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (NetworkAcl.to_xml x))) v
  end
module LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet =
  struct
    type t = LocalGatewayRouteTableVirtualInterfaceGroupAssociation.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list
        LocalGatewayRouteTableVirtualInterfaceGroupAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list
        LocalGatewayRouteTableVirtualInterfaceGroupAssociation.to_headers v
    let to_json v =
      `List
        (List.map
           LocalGatewayRouteTableVirtualInterfaceGroupAssociation.to_json v)
    let parse xml =
      Util.option_all
        (List.map
           LocalGatewayRouteTableVirtualInterfaceGroupAssociation.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([],
               (LocalGatewayRouteTableVirtualInterfaceGroupAssociation.to_xml
                  x))) v
  end
module FleetIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module LaunchTemplateNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module CancelSpotFleetRequestsErrorSet =
  struct
    type t = CancelSpotFleetRequestsErrorItem.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list CancelSpotFleetRequestsErrorItem.to_query v
    let to_headers v =
      Headers.to_headers_list CancelSpotFleetRequestsErrorItem.to_headers v
    let to_json v =
      `List (List.map CancelSpotFleetRequestsErrorItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map CancelSpotFleetRequestsErrorItem.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (CancelSpotFleetRequestsErrorItem.to_xml x))) v
  end
module CancelSpotFleetRequestsSuccessSet =
  struct
    type t = CancelSpotFleetRequestsSuccessItem.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list CancelSpotFleetRequestsSuccessItem.to_query v
    let to_headers v =
      Headers.to_headers_list CancelSpotFleetRequestsSuccessItem.to_headers v
    let to_json v =
      `List (List.map CancelSpotFleetRequestsSuccessItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map CancelSpotFleetRequestsSuccessItem.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (CancelSpotFleetRequestsSuccessItem.to_xml x))) v
  end
module AccountAttributeList =
  struct
    type t = AccountAttribute.t list
    let make elems () = elems
    let to_query v = Query.to_query_list AccountAttribute.to_query v
    let to_headers v = Headers.to_headers_list AccountAttribute.to_headers v
    let to_json v = `List (List.map AccountAttribute.to_json v)
    let parse xml =
      Util.option_all
        (List.map AccountAttribute.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (AccountAttribute.to_xml x)))
        v
  end
module ResourceIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module PeeringConnectionOptions =
  struct
    type t =
      {
      allow_dns_resolution_from_remote_vpc: Boolean.t option
        [@ocaml.doc
          "<p>If true, the public DNS hostnames of instances in the specified VPC resolve to private IP addresses when queried from instances in the peer VPC.</p>"];
      allow_egress_from_local_classic_link_to_remote_vpc: Boolean.t option
        [@ocaml.doc
          "<p>If true, enables outbound communication from an EC2-Classic instance that's linked to a local VPC using ClassicLink to instances in a peer VPC.</p>"];
      allow_egress_from_local_vpc_to_remote_classic_link: Boolean.t option
        [@ocaml.doc
          "<p>If true, enables outbound communication from instances in a local VPC to an EC2-Classic instance that's linked to a peer VPC using ClassicLink.</p>"]}
    [@@ocaml.doc "<p>Describes the VPC peering connection options.</p>"]
    let make ?allow_dns_resolution_from_remote_vpc 
      ?allow_egress_from_local_classic_link_to_remote_vpc 
      ?allow_egress_from_local_vpc_to_remote_classic_link  () =
      {
        allow_dns_resolution_from_remote_vpc;
        allow_egress_from_local_classic_link_to_remote_vpc;
        allow_egress_from_local_vpc_to_remote_classic_link
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 Query.Pair
                   ("AllowEgressFromLocalVpcToRemoteClassicLink",
                     (Boolean.to_query f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowEgressFromLocalClassicLinkToRemoteVpc",
                    (Boolean.to_query f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowDnsResolutionFromRemoteVpc", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 ("allow_egress_from_local_vpc_to_remote_classic_link",
                   (Boolean.to_json f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                ("allow_egress_from_local_classic_link_to_remote_vpc",
                  (Boolean.to_json f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                ("allow_dns_resolution_from_remote_vpc", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          allow_dns_resolution_from_remote_vpc =
            (Util.option_bind
               (Xml.member "allowDnsResolutionFromRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_classic_link_to_remote_vpc =
            (Util.option_bind
               (Xml.member "allowEgressFromLocalClassicLinkToRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_vpc_to_remote_classic_link =
            (Util.option_bind
               (Xml.member "allowEgressFromLocalVpcToRemoteClassicLink" xml)
               Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.allow_dns_resolution_from_remote_vpc
                (fun f ->
                   Ezxmlm.make_tag "allowDnsResolutionFromRemoteVpc"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map
               v.allow_egress_from_local_classic_link_to_remote_vpc
               (fun f ->
                  Ezxmlm.make_tag
                    "allowEgressFromLocalClassicLinkToRemoteVpc"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 Ezxmlm.make_tag "allowEgressFromLocalVpcToRemoteClassicLink"
                   ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the VPC peering connection options.</p>"]
module VpcIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "VpcId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module DiskImageList =
  struct
    type t = DiskImage.t list
    let make elems () = elems
    let to_query v = Query.to_query_list DiskImage.to_query v
    let to_headers v = Headers.to_headers_list DiskImage.to_headers v
    let to_json v = `List (List.map DiskImage.to_json v)
    let parse xml =
      Util.option_all (List.map DiskImage.parse (Xml.members "member" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (DiskImage.to_xml x)))
        v
  end
module ImportInstanceLaunchSpecification =
  struct
    type t =
      {
      additional_info: String.t option [@ocaml.doc "<p>Reserved.</p>"];
      architecture: ArchitectureValues.t option
        [@ocaml.doc "<p>The architecture of the instance.</p>"];
      group_ids: SecurityGroupIdStringList.t
        [@ocaml.doc "<p>The security group IDs.</p>"];
      group_names: SecurityGroupStringList.t
        [@ocaml.doc "<p>The security group names.</p>"];
      instance_initiated_shutdown_behavior: ShutdownBehavior.t option
        [@ocaml.doc
          "<p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p>"];
      instance_type: InstanceType.t option
        [@ocaml.doc
          "<p>The instance type. For more information about the instance types that you can import, see <a href=\"https://docs.aws.amazon.com/vm-import/latest/userguide/vmie_prereqs.html#vmimport-instance-types\">Instance Types</a> in the VM Import/Export User Guide.</p>"];
      monitoring: Boolean.t option
        [@ocaml.doc "<p>Indicates whether monitoring is enabled.</p>"];
      placement: Placement.t option
        [@ocaml.doc "<p>The placement information for the instance.</p>"];
      private_ip_address: String.t option
        [@ocaml.doc
          "<p>[EC2-VPC] An available IP address from the IP address range of the subnet.</p>"];
      subnet_id: String.t option
        [@ocaml.doc
          "<p>[EC2-VPC] The ID of the subnet in which to launch the instance.</p>"];
      user_data: UserData.t option
        [@ocaml.doc
          "<p>The Base64-encoded user data to make available to the instance.</p>"]}
    [@@ocaml.doc "<p>Describes the launch specification for VM import.</p>"]
    let make ?additional_info  ?architecture  ?(group_ids= []) 
      ?(group_names= [])  ?instance_initiated_shutdown_behavior 
      ?instance_type  ?monitoring  ?placement  ?private_ip_address 
      ?subnet_id  ?user_data  () =
      {
        additional_info;
        architecture;
        group_ids;
        group_names;
        instance_initiated_shutdown_behavior;
        instance_type;
        monitoring;
        placement;
        private_ip_address;
        subnet_id;
        user_data
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> Query.Pair ("UserData", (UserData.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (Placement.to_query f)));
           Util.option_map v.monitoring
             (fun f -> Query.Pair ("Monitoring", (Boolean.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (ShutdownBehavior.to_query f)));
           Some
             (Query.Pair
                ("GroupName",
                  (SecurityGroupStringList.to_query v.group_names)));
           Some
             (Query.Pair
                ("GroupId", (SecurityGroupIdStringList.to_query v.group_ids)));
           Util.option_map v.architecture
             (fun f ->
                Query.Pair ("Architecture", (ArchitectureValues.to_query f)));
           Util.option_map v.additional_info
             (fun f -> Query.Pair ("AdditionalInfo", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> ("user_data", (UserData.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (Placement.to_json f)));
           Util.option_map v.monitoring
             (fun f -> ("monitoring", (Boolean.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (ShutdownBehavior.to_json f)));
           Some
             ("group_names", (SecurityGroupStringList.to_json v.group_names));
           Some
             ("group_ids", (SecurityGroupIdStringList.to_json v.group_ids));
           Util.option_map v.architecture
             (fun f -> ("architecture", (ArchitectureValues.to_json f)));
           Util.option_map v.additional_info
             (fun f -> ("additional_info", (String.to_json f)))])
    let parse xml =
      Some
        {
          additional_info =
            (Util.option_bind (Xml.member "additionalInfo" xml) String.parse);
          architecture =
            (Util.option_bind (Xml.member "architecture" xml)
               ArchitectureValues.parse);
          group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupId" xml)
                  SecurityGroupIdStringList.parse));
          group_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupName" xml)
                  SecurityGroupStringList.parse));
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               ShutdownBehavior.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml) Boolean.parse);
          placement =
            (Util.option_bind (Xml.member "placement" xml) Placement.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml) UserData.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.additional_info
                        (fun f ->
                           Ezxmlm.make_tag "additionalInfo"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.architecture
                       (fun f ->
                          Ezxmlm.make_tag "architecture"
                            ([], (ArchitectureValues.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "GroupId"
                              ([], (SecurityGroupIdStringList.to_xml [x]))))
                      v.group_ids))
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "GroupName"
                             ([], (SecurityGroupStringList.to_xml [x]))))
                     v.group_names))
                 @
                 [Util.option_map v.instance_initiated_shutdown_behavior
                    (fun f ->
                       Ezxmlm.make_tag "instanceInitiatedShutdownBehavior"
                         ([], (ShutdownBehavior.to_xml f)))])
                @
                [Util.option_map v.instance_type
                   (fun f ->
                      Ezxmlm.make_tag "instanceType"
                        ([], (InstanceType.to_xml f)))])
               @
               [Util.option_map v.monitoring
                  (fun f ->
                     Ezxmlm.make_tag "monitoring" ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.placement
                 (fun f ->
                    Ezxmlm.make_tag "placement" ([], (Placement.to_xml f)))])
             @
             [Util.option_map v.private_ip_address
                (fun f ->
                   Ezxmlm.make_tag "privateIpAddress" ([], (String.to_xml f)))])
            @
            [Util.option_map v.subnet_id
               (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.user_data
              (fun f -> Ezxmlm.make_tag "userData" ([], (UserData.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the launch specification for VM import.</p>"]
module VpcEndpointSet =
  struct
    type t = VpcEndpoint.t list
    let make elems () = elems
    let to_query v = Query.to_query_list VpcEndpoint.to_query v
    let to_headers v = Headers.to_headers_list VpcEndpoint.to_headers v
    let to_json v = `List (List.map VpcEndpoint.to_json v)
    let parse xml =
      Util.option_all (List.map VpcEndpoint.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VpcEndpoint.to_xml x))) v
  end
module ClassicLinkInstanceList =
  struct
    type t = ClassicLinkInstance.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ClassicLinkInstance.to_query v
    let to_headers v =
      Headers.to_headers_list ClassicLinkInstance.to_headers v
    let to_json v = `List (List.map ClassicLinkInstance.to_json v)
    let parse xml =
      Util.option_all
        (List.map ClassicLinkInstance.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ClassicLinkInstance.to_xml x))) v
  end
module PurchaseSet =
  struct
    type t = Purchase.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Purchase.to_query v
    let to_headers v = Headers.to_headers_list Purchase.to_headers v
    let to_json v = `List (List.map Purchase.to_json v)
    let parse xml =
      Util.option_all (List.map Purchase.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Purchase.to_xml x)))
        v
  end
module TransitGatewayAttachmentList =
  struct
    type t = TransitGatewayAttachment.t list
    let make elems () = elems
    let to_query v = Query.to_query_list TransitGatewayAttachment.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayAttachment.to_headers v
    let to_json v = `List (List.map TransitGatewayAttachment.to_json v)
    let parse xml =
      Util.option_all
        (List.map TransitGatewayAttachment.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (TransitGatewayAttachment.to_xml x)))
        v
  end
module ImageAttributeName =
  struct
    type t =
      | Description 
      | Kernel 
      | Ramdisk 
      | LaunchPermission 
      | ProductCodes 
      | BlockDeviceMapping 
      | SriovNetSupport 
    let str_to_t =
      [("sriovNetSupport", SriovNetSupport);
      ("blockDeviceMapping", BlockDeviceMapping);
      ("productCodes", ProductCodes);
      ("launchPermission", LaunchPermission);
      ("ramdisk", Ramdisk);
      ("kernel", Kernel);
      ("description", Description)]
    let t_to_str =
      [(SriovNetSupport, "sriovNetSupport");
      (BlockDeviceMapping, "blockDeviceMapping");
      (ProductCodes, "productCodes");
      (LaunchPermission, "launchPermission");
      (Ramdisk, "ramdisk");
      (Kernel, "kernel");
      (Description, "description")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module SnapshotList =
  struct
    type t = Snapshot.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Snapshot.to_query v
    let to_headers v = Headers.to_headers_list Snapshot.to_headers v
    let to_json v = `List (List.map Snapshot.to_json v)
    let parse xml =
      Util.option_all (List.map Snapshot.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Snapshot.to_xml x)))
        v
  end
module TransitGatewayMulticastDomainIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module PurchasedScheduledInstanceSet =
  struct
    type t = ScheduledInstance.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ScheduledInstance.to_query v
    let to_headers v = Headers.to_headers_list ScheduledInstance.to_headers v
    let to_json v = `List (List.map ScheduledInstance.to_json v)
    let parse xml =
      Util.option_all
        (List.map ScheduledInstance.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ScheduledInstance.to_xml x)))
        v
  end
module CreateFleetErrorsSet =
  struct
    type t = CreateFleetError.t list
    let make elems () = elems
    let to_query v = Query.to_query_list CreateFleetError.to_query v
    let to_headers v = Headers.to_headers_list CreateFleetError.to_headers v
    let to_json v = `List (List.map CreateFleetError.to_json v)
    let parse xml =
      Util.option_all
        (List.map CreateFleetError.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (CreateFleetError.to_xml x)))
        v
  end
module CreateFleetInstancesSet =
  struct
    type t = CreateFleetInstance.t list
    let make elems () = elems
    let to_query v = Query.to_query_list CreateFleetInstance.to_query v
    let to_headers v =
      Headers.to_headers_list CreateFleetInstance.to_headers v
    let to_json v = `List (List.map CreateFleetInstance.to_json v)
    let parse xml =
      Util.option_all
        (List.map CreateFleetInstance.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (CreateFleetInstance.to_xml x))) v
  end
module SnapshotSet =
  struct
    type t = SnapshotInfo.t list
    let make elems () = elems
    let to_query v = Query.to_query_list SnapshotInfo.to_query v
    let to_headers v = Headers.to_headers_list SnapshotInfo.to_headers v
    let to_json v = `List (List.map SnapshotInfo.to_json v)
    let parse xml =
      Util.option_all (List.map SnapshotInfo.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (SnapshotInfo.to_xml x))) v
  end
module TrafficMirrorTargetSet =
  struct
    type t = TrafficMirrorTarget.t list
    let make elems () = elems
    let to_query v = Query.to_query_list TrafficMirrorTarget.to_query v
    let to_headers v =
      Headers.to_headers_list TrafficMirrorTarget.to_headers v
    let to_json v = `List (List.map TrafficMirrorTarget.to_json v)
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorTarget.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (TrafficMirrorTarget.to_xml x))) v
  end
module NetworkInterfaceAttribute =
  struct
    type t =
      | Description 
      | GroupSet 
      | SourceDestCheck 
      | Attachment 
    let str_to_t =
      [("attachment", Attachment);
      ("sourceDestCheck", SourceDestCheck);
      ("groupSet", GroupSet);
      ("description", Description)]
    let t_to_str =
      [(Attachment, "attachment");
      (SourceDestCheck, "sourceDestCheck");
      (GroupSet, "groupSet");
      (Description, "description")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module TrafficMirrorFilterRuleFieldList =
  struct
    type t = TrafficMirrorFilterRuleField.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list TrafficMirrorFilterRuleField.to_query v
    let to_headers v =
      Headers.to_headers_list TrafficMirrorFilterRuleField.to_headers v
    let to_json v = `List (List.map TrafficMirrorFilterRuleField.to_json v)
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorFilterRuleField.parse
           (Xml.members "member" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TrafficMirrorFilterRuleField.to_xml x))) v
  end
module VolumeModificationList =
  struct
    type t = VolumeModification.t list
    let make elems () = elems
    let to_query v = Query.to_query_list VolumeModification.to_query v
    let to_headers v =
      Headers.to_headers_list VolumeModification.to_headers v
    let to_json v = `List (List.map VolumeModification.to_json v)
    let parse xml =
      Util.option_all
        (List.map VolumeModification.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (VolumeModification.to_xml x))) v
  end
module ResetImageAttributeName =
  struct
    type t =
      | LaunchPermission 
    let str_to_t = [("launchPermission", LaunchPermission)]
    let t_to_str = [(LaunchPermission, "launchPermission")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module NewDhcpConfigurationList =
  struct
    type t = NewDhcpConfiguration.t list
    let make elems () = elems
    let to_query v = Query.to_query_list NewDhcpConfiguration.to_query v
    let to_headers v =
      Headers.to_headers_list NewDhcpConfiguration.to_headers v
    let to_json v = `List (List.map NewDhcpConfiguration.to_json v)
    let parse xml =
      Util.option_all
        (List.map NewDhcpConfiguration.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (NewDhcpConfiguration.to_xml x))) v
  end
module VpcAttributeName =
  struct
    type t =
      | EnableDnsSupport 
      | EnableDnsHostnames 
    let str_to_t =
      [("enableDnsHostnames", EnableDnsHostnames);
      ("enableDnsSupport", EnableDnsSupport)]
    let t_to_str =
      [(EnableDnsHostnames, "enableDnsHostnames");
      (EnableDnsSupport, "enableDnsSupport")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module NetworkInterfaceList =
  struct
    type t = NetworkInterface.t list
    let make elems () = elems
    let to_query v = Query.to_query_list NetworkInterface.to_query v
    let to_headers v = Headers.to_headers_list NetworkInterface.to_headers v
    let to_json v = `List (List.map NetworkInterface.to_json v)
    let parse xml =
      Util.option_all
        (List.map NetworkInterface.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (NetworkInterface.to_xml x)))
        v
  end
module ConnectionNotificationSet =
  struct
    type t = ConnectionNotification.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ConnectionNotification.to_query v
    let to_headers v =
      Headers.to_headers_list ConnectionNotification.to_headers v
    let to_json v = `List (List.map ConnectionNotification.to_json v)
    let parse xml =
      Util.option_all
        (List.map ConnectionNotification.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ConnectionNotification.to_xml x)))
        v
  end
module ResetFpgaImageAttributeName =
  struct
    type t =
      | LoadPermission 
    let str_to_t = [("loadPermission", LoadPermission)]
    let t_to_str = [(LoadPermission, "loadPermission")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module ReservedInstancesList =
  struct
    type t = ReservedInstances.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ReservedInstances.to_query v
    let to_headers v = Headers.to_headers_list ReservedInstances.to_headers v
    let to_json v = `List (List.map ReservedInstances.to_json v)
    let parse xml =
      Util.option_all
        (List.map ReservedInstances.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ReservedInstances.to_xml x)))
        v
  end
module GroupIds =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module ResourceList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module TransitGatewayPeeringAttachmentList =
  struct
    type t = TransitGatewayPeeringAttachment.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list TransitGatewayPeeringAttachment.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayPeeringAttachment.to_headers v
    let to_json v =
      `List (List.map TransitGatewayPeeringAttachment.to_json v)
    let parse xml =
      Util.option_all
        (List.map TransitGatewayPeeringAttachment.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayPeeringAttachment.to_xml x))) v
  end
module CancelledSpotInstanceRequestList =
  struct
    type t = CancelledSpotInstanceRequest.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list CancelledSpotInstanceRequest.to_query v
    let to_headers v =
      Headers.to_headers_list CancelledSpotInstanceRequest.to_headers v
    let to_json v = `List (List.map CancelledSpotInstanceRequest.to_json v)
    let parse xml =
      Util.option_all
        (List.map CancelledSpotInstanceRequest.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (CancelledSpotInstanceRequest.to_xml x))) v
  end
module ServiceConfigurationSet =
  struct
    type t = ServiceConfiguration.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ServiceConfiguration.to_query v
    let to_headers v =
      Headers.to_headers_list ServiceConfiguration.to_headers v
    let to_json v = `List (List.map ServiceConfiguration.to_json v)
    let parse xml =
      Util.option_all
        (List.map ServiceConfiguration.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ServiceConfiguration.to_xml x))) v
  end
module StorageLocation =
  struct
    type t =
      {
      bucket: String.t option
        [@ocaml.doc "<p>The name of the S3 bucket.</p>"];
      key: String.t option [@ocaml.doc "<p>The key.</p>"]}[@@ocaml.doc
                                                            "<p>Describes a storage location in Amazon S3.</p>"]
    let make ?bucket  ?key  () = { bucket; key }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.key
              (fun f -> Query.Pair ("Key", (String.to_query f)));
           Util.option_map v.bucket
             (fun f -> Query.Pair ("Bucket", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.key (fun f -> ("key", (String.to_json f)));
           Util.option_map v.bucket (fun f -> ("bucket", (String.to_json f)))])
    let parse xml =
      Some
        {
          bucket = (Util.option_bind (Xml.member "Bucket" xml) String.parse);
          key = (Util.option_bind (Xml.member "Key" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.bucket
               (fun f -> Ezxmlm.make_tag "Bucket" ([], (String.to_xml f)))])
           @
           [Util.option_map v.key
              (fun f -> Ezxmlm.make_tag "Key" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a storage location in Amazon S3.</p>"]
module BundleIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "BundleId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module DescribeConversionTaskList =
  struct
    type t = ConversionTask.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ConversionTask.to_query v
    let to_headers v = Headers.to_headers_list ConversionTask.to_headers v
    let to_json v = `List (List.map ConversionTask.to_json v)
    let parse xml =
      Util.option_all
        (List.map ConversionTask.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ConversionTask.to_xml x))) v
  end
module LocalGatewayRouteTableIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module TransitGatewayVpcAttachmentList =
  struct
    type t = TransitGatewayVpcAttachment.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list TransitGatewayVpcAttachment.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayVpcAttachment.to_headers v
    let to_json v = `List (List.map TransitGatewayVpcAttachment.to_json v)
    let parse xml =
      Util.option_all
        (List.map TransitGatewayVpcAttachment.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayVpcAttachment.to_xml x))) v
  end
module ExportToS3TaskSpecification =
  struct
    type t =
      {
      container_format: ContainerFormat.t option
        [@ocaml.doc
          "<p>The container format used to combine disk images with metadata (such as OVF). If absent, only the disk image is exported.</p>"];
      disk_image_format: DiskImageFormat.t option
        [@ocaml.doc "<p>The format for the exported image.</p>"];
      s3_bucket: String.t option
        [@ocaml.doc
          "<p>The S3 bucket for the destination image. The destination bucket must exist and grant WRITE and READ_ACP permissions to the AWS account <code>vm-import-export@amazon.com</code>.</p>"];
      s3_prefix: String.t option
        [@ocaml.doc
          "<p>The image is written to a single object in the S3 bucket at the S3 key s3prefix + exportTaskId + '.' + diskImageFormat.</p>"]}
    [@@ocaml.doc "<p>Describes an instance export task.</p>"]
    let make ?container_format  ?disk_image_format  ?s3_bucket  ?s3_prefix 
      () = { container_format; disk_image_format; s3_bucket; s3_prefix }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> Query.Pair ("S3Prefix", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)));
           Util.option_map v.disk_image_format
             (fun f ->
                Query.Pair ("DiskImageFormat", (DiskImageFormat.to_query f)));
           Util.option_map v.container_format
             (fun f ->
                Query.Pair ("ContainerFormat", (ContainerFormat.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> ("s3_prefix", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)));
           Util.option_map v.disk_image_format
             (fun f -> ("disk_image_format", (DiskImageFormat.to_json f)));
           Util.option_map v.container_format
             (fun f -> ("container_format", (ContainerFormat.to_json f)))])
    let parse xml =
      Some
        {
          container_format =
            (Util.option_bind (Xml.member "containerFormat" xml)
               ContainerFormat.parse);
          disk_image_format =
            (Util.option_bind (Xml.member "diskImageFormat" xml)
               DiskImageFormat.parse);
          s3_bucket =
            (Util.option_bind (Xml.member "s3Bucket" xml) String.parse);
          s3_prefix =
            (Util.option_bind (Xml.member "s3Prefix" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.container_format
                 (fun f ->
                    Ezxmlm.make_tag "containerFormat"
                      ([], (ContainerFormat.to_xml f)))])
             @
             [Util.option_map v.disk_image_format
                (fun f ->
                   Ezxmlm.make_tag "diskImageFormat"
                     ([], (DiskImageFormat.to_xml f)))])
            @
            [Util.option_map v.s3_bucket
               (fun f -> Ezxmlm.make_tag "s3Bucket" ([], (String.to_xml f)))])
           @
           [Util.option_map v.s3_prefix
              (fun f -> Ezxmlm.make_tag "s3Prefix" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an instance export task.</p>"]
module ReservedInstanceReservationValueSet =
  struct
    type t = ReservedInstanceReservationValue.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list ReservedInstanceReservationValue.to_query v
    let to_headers v =
      Headers.to_headers_list ReservedInstanceReservationValue.to_headers v
    let to_json v =
      `List (List.map ReservedInstanceReservationValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map ReservedInstanceReservationValue.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ReservedInstanceReservationValue.to_xml x))) v
  end
module TargetReservationValueSet =
  struct
    type t = TargetReservationValue.t list
    let make elems () = elems
    let to_query v = Query.to_query_list TargetReservationValue.to_query v
    let to_headers v =
      Headers.to_headers_list TargetReservationValue.to_headers v
    let to_json v = `List (List.map TargetReservationValue.to_json v)
    let parse xml =
      Util.option_all
        (List.map TargetReservationValue.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (TargetReservationValue.to_xml x)))
        v
  end
module TransitGatewayRouteList =
  struct
    type t = TransitGatewayRoute.t list
    let make elems () = elems
    let to_query v = Query.to_query_list TransitGatewayRoute.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayRoute.to_headers v
    let to_json v = `List (List.map TransitGatewayRoute.to_json v)
    let parse xml =
      Util.option_all
        (List.map TransitGatewayRoute.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (TransitGatewayRoute.to_xml x))) v
  end
module HistoryRecords =
  struct
    type t = HistoryRecord.t list
    let make elems () = elems
    let to_query v = Query.to_query_list HistoryRecord.to_query v
    let to_headers v = Headers.to_headers_list HistoryRecord.to_headers v
    let to_json v = `List (List.map HistoryRecord.to_json v)
    let parse xml =
      Util.option_all (List.map HistoryRecord.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (HistoryRecord.to_xml x))) v
  end
module FpgaImageList =
  struct
    type t = FpgaImage.t list
    let make elems () = elems
    let to_query v = Query.to_query_list FpgaImage.to_query v
    let to_headers v = Headers.to_headers_list FpgaImage.to_headers v
    let to_json v = `List (List.map FpgaImage.to_json v)
    let parse xml =
      Util.option_all (List.map FpgaImage.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (FpgaImage.to_xml x)))
        v
  end
module OwnerStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "Owner" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module RestorableByStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module EnableFastSnapshotRestoreErrorSet =
  struct
    type t = EnableFastSnapshotRestoreErrorItem.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list EnableFastSnapshotRestoreErrorItem.to_query v
    let to_headers v =
      Headers.to_headers_list EnableFastSnapshotRestoreErrorItem.to_headers v
    let to_json v =
      `List (List.map EnableFastSnapshotRestoreErrorItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map EnableFastSnapshotRestoreErrorItem.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (EnableFastSnapshotRestoreErrorItem.to_xml x))) v
  end
module EnableFastSnapshotRestoreSuccessSet =
  struct
    type t = EnableFastSnapshotRestoreSuccessItem.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list EnableFastSnapshotRestoreSuccessItem.to_query v
    let to_headers v =
      Headers.to_headers_list EnableFastSnapshotRestoreSuccessItem.to_headers
        v
    let to_json v =
      `List (List.map EnableFastSnapshotRestoreSuccessItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map EnableFastSnapshotRestoreSuccessItem.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (EnableFastSnapshotRestoreSuccessItem.to_xml x))) v
  end
module InstanceIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module RouteTableList =
  struct
    type t = RouteTable.t list
    let make elems () = elems
    let to_query v = Query.to_query_list RouteTable.to_query v
    let to_headers v = Headers.to_headers_list RouteTable.to_headers v
    let to_json v = `List (List.map RouteTable.to_json v)
    let parse xml =
      Util.option_all (List.map RouteTable.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (RouteTable.to_xml x))) v
  end
module LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module UnsuccessfulItemList =
  struct
    type t = UnsuccessfulItem.t list
    let make elems () = elems
    let to_query v = Query.to_query_list UnsuccessfulItem.to_query v
    let to_headers v = Headers.to_headers_list UnsuccessfulItem.to_headers v
    let to_json v = `List (List.map UnsuccessfulItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map UnsuccessfulItem.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (UnsuccessfulItem.to_xml x)))
        v
  end
module IamInstanceProfileAssociationSet =
  struct
    type t = IamInstanceProfileAssociation.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list IamInstanceProfileAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list IamInstanceProfileAssociation.to_headers v
    let to_json v = `List (List.map IamInstanceProfileAssociation.to_json v)
    let parse xml =
      Util.option_all
        (List.map IamInstanceProfileAssociation.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (IamInstanceProfileAssociation.to_xml x))) v
  end
module LaunchTemplateVersionSet =
  struct
    type t = LaunchTemplateVersion.t list
    let make elems () = elems
    let to_query v = Query.to_query_list LaunchTemplateVersion.to_query v
    let to_headers v =
      Headers.to_headers_list LaunchTemplateVersion.to_headers v
    let to_json v = `List (List.map LaunchTemplateVersion.to_json v)
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateVersion.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (LaunchTemplateVersion.to_xml x))) v
  end
module TransitGatewayAttachmentIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module TransitGatewayMulticastGroupList =
  struct
    type t = TransitGatewayMulticastGroup.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list TransitGatewayMulticastGroup.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayMulticastGroup.to_headers v
    let to_json v = `List (List.map TransitGatewayMulticastGroup.to_json v)
    let parse xml =
      Util.option_all
        (List.map TransitGatewayMulticastGroup.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayMulticastGroup.to_xml x))) v
  end
module ScheduledInstanceIdRequestSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ScheduledInstanceId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module SlotStartTimeRangeRequest =
  struct
    type t =
      {
      earliest_time: DateTime.t option
        [@ocaml.doc
          "<p>The earliest date and time, in UTC, for the Scheduled Instance to start.</p>"];
      latest_time: DateTime.t option
        [@ocaml.doc
          "<p>The latest date and time, in UTC, for the Scheduled Instance to start.</p>"]}
    [@@ocaml.doc
      "<p>Describes the time period for a Scheduled Instance to start its first schedule.</p>"]
    let make ?earliest_time  ?latest_time  () =
      { earliest_time; latest_time }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.latest_time
              (fun f -> Query.Pair ("LatestTime", (DateTime.to_query f)));
           Util.option_map v.earliest_time
             (fun f -> Query.Pair ("EarliestTime", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.latest_time
              (fun f -> ("latest_time", (DateTime.to_json f)));
           Util.option_map v.earliest_time
             (fun f -> ("earliest_time", (DateTime.to_json f)))])
    let parse xml =
      Some
        {
          earliest_time =
            (Util.option_bind (Xml.member "EarliestTime" xml) DateTime.parse);
          latest_time =
            (Util.option_bind (Xml.member "LatestTime" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.earliest_time
               (fun f ->
                  Ezxmlm.make_tag "EarliestTime" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.latest_time
              (fun f ->
                 Ezxmlm.make_tag "LatestTime" ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the time period for a Scheduled Instance to start its first schedule.</p>"]
module LocalGatewayVirtualInterfaceSet =
  struct
    type t = LocalGatewayVirtualInterface.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list LocalGatewayVirtualInterface.to_query v
    let to_headers v =
      Headers.to_headers_list LocalGatewayVirtualInterface.to_headers v
    let to_json v = `List (List.map LocalGatewayVirtualInterface.to_json v)
    let parse xml =
      Util.option_all
        (List.map LocalGatewayVirtualInterface.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LocalGatewayVirtualInterface.to_xml x))) v
  end
module CpuOptionsRequest =
  struct
    type t =
      {
      core_count: Integer.t option
        [@ocaml.doc "<p>The number of CPU cores for the instance.</p>"];
      threads_per_core: Integer.t option
        [@ocaml.doc
          "<p>The number of threads per CPU core. To disable multithreading for the instance, specify a value of <code>1</code>. Otherwise, specify the default value of <code>2</code>.</p>"]}
    [@@ocaml.doc
      "<p>The CPU options for the instance. Both the core count and threads per core must be specified in the request.</p>"]
    let make ?core_count  ?threads_per_core  () =
      { core_count; threads_per_core }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> Query.Pair ("ThreadsPerCore", (Integer.to_query f)));
           Util.option_map v.core_count
             (fun f -> Query.Pair ("CoreCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> ("threads_per_core", (Integer.to_json f)));
           Util.option_map v.core_count
             (fun f -> ("core_count", (Integer.to_json f)))])
    let parse xml =
      Some
        {
          core_count =
            (Util.option_bind (Xml.member "CoreCount" xml) Integer.parse);
          threads_per_core =
            (Util.option_bind (Xml.member "ThreadsPerCore" xml) Integer.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.core_count
               (fun f -> Ezxmlm.make_tag "CoreCount" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.threads_per_core
              (fun f ->
                 Ezxmlm.make_tag "ThreadsPerCore" ([], (Integer.to_xml f)))])
  end[@@ocaml.doc
       "<p>The CPU options for the instance. Both the core count and threads per core must be specified in the request.</p>"]
module ElasticGpuSpecifications =
  struct
    type t = ElasticGpuSpecification.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ElasticGpuSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list ElasticGpuSpecification.to_headers v
    let to_json v = `List (List.map ElasticGpuSpecification.to_json v)
    let parse xml =
      Util.option_all
        (List.map ElasticGpuSpecification.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ElasticGpuSpecification.to_xml x)))
        v
  end
module ElasticInferenceAccelerators =
  struct
    type t = ElasticInferenceAccelerator.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list ElasticInferenceAccelerator.to_query v
    let to_headers v =
      Headers.to_headers_list ElasticInferenceAccelerator.to_headers v
    let to_json v = `List (List.map ElasticInferenceAccelerator.to_json v)
    let parse xml =
      Util.option_all
        (List.map ElasticInferenceAccelerator.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ElasticInferenceAccelerator.to_xml x))) v
  end
module HibernationOptionsRequest =
  struct
    type t =
      {
      configured: Boolean.t option
        [@ocaml.doc
          "<p>If you set this parameter to <code>true</code>, your instance is enabled for hibernation.</p> <p>Default: <code>false</code> </p>"]}
    [@@ocaml.doc
      "<p>Indicates whether your instance is configured for hibernation. This parameter is valid only if the instance meets the <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites\">hibernation prerequisites</a>. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html\">Hibernate Your Instance</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"]
    let make ?configured  () = { configured }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> Query.Pair ("Configured", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> ("configured", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          configured =
            (Util.option_bind (Xml.member "Configured" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.configured
              (fun f -> Ezxmlm.make_tag "Configured" ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc
       "<p>Indicates whether your instance is configured for hibernation. This parameter is valid only if the instance meets the <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites\">hibernation prerequisites</a>. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html\">Hibernate Your Instance</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"]
module InstanceMarketOptionsRequest =
  struct
    type t =
      {
      market_type: MarketType.t option [@ocaml.doc "<p>The market type.</p>"];
      spot_options: SpotMarketOptions.t option
        [@ocaml.doc "<p>The options for Spot Instances.</p>"]}[@@ocaml.doc
                                                                "<p>Describes the market (purchasing) option for the instances.</p>"]
    let make ?market_type  ?spot_options  () = { market_type; spot_options }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f ->
                 Query.Pair ("SpotOptions", (SpotMarketOptions.to_query f)));
           Util.option_map v.market_type
             (fun f -> Query.Pair ("MarketType", (MarketType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f -> ("spot_options", (SpotMarketOptions.to_json f)));
           Util.option_map v.market_type
             (fun f -> ("market_type", (MarketType.to_json f)))])
    let parse xml =
      Some
        {
          market_type =
            (Util.option_bind (Xml.member "MarketType" xml) MarketType.parse);
          spot_options =
            (Util.option_bind (Xml.member "SpotOptions" xml)
               SpotMarketOptions.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.market_type
               (fun f ->
                  Ezxmlm.make_tag "MarketType" ([], (MarketType.to_xml f)))])
           @
           [Util.option_map v.spot_options
              (fun f ->
                 Ezxmlm.make_tag "SpotOptions"
                   ([], (SpotMarketOptions.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the market (purchasing) option for the instances.</p>"]
module InstanceMetadataOptionsRequest =
  struct
    type t =
      {
      http_tokens: HttpTokensState.t option
        [@ocaml.doc
          "<p>The state of token usage for your instance metadata requests. If the parameter is not specified in the request, the default state is <code>optional</code>.</p> <p>If the state is <code>optional</code>, you can choose to retrieve instance metadata with or without a signed token header on your request. If you retrieve the IAM role credentials without a token, the version 1.0 role credentials are returned. If you retrieve the IAM role credentials using a valid signed token, the version 2.0 role credentials are returned.</p> <p>If the state is <code>required</code>, you must send a signed token header with any instance metadata retrieval requests. In this state, retrieving the IAM role credentials always returns the version 2.0 credentials; the version 1.0 credentials are not available.</p>"];
      http_put_response_hop_limit: Integer.t option
        [@ocaml.doc
          "<p>The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.</p> <p>Default: 1</p> <p>Possible values: Integers from 1 to 64</p>"];
      http_endpoint: InstanceMetadataEndpointState.t option
        [@ocaml.doc
          "<p>This parameter enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is <code>enabled</code>.</p> <note> <p>If you specify a value of <code>disabled</code>, you will not be able to access your instance metadata.</p> </note>"]}
    [@@ocaml.doc "<p>The metadata options for the instance.</p>"]
    let make ?http_tokens  ?http_put_response_hop_limit  ?http_endpoint  () =
      { http_tokens; http_put_response_hop_limit; http_endpoint }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.http_endpoint
              (fun f ->
                 Query.Pair
                   ("HttpEndpoint",
                     (InstanceMetadataEndpointState.to_query f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f ->
                Query.Pair ("HttpPutResponseHopLimit", (Integer.to_query f)));
           Util.option_map v.http_tokens
             (fun f ->
                Query.Pair ("HttpTokens", (HttpTokensState.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.http_endpoint
              (fun f ->
                 ("http_endpoint", (InstanceMetadataEndpointState.to_json f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f -> ("http_put_response_hop_limit", (Integer.to_json f)));
           Util.option_map v.http_tokens
             (fun f -> ("http_tokens", (HttpTokensState.to_json f)))])
    let parse xml =
      Some
        {
          http_tokens =
            (Util.option_bind (Xml.member "HttpTokens" xml)
               HttpTokensState.parse);
          http_put_response_hop_limit =
            (Util.option_bind (Xml.member "HttpPutResponseHopLimit" xml)
               Integer.parse);
          http_endpoint =
            (Util.option_bind (Xml.member "HttpEndpoint" xml)
               InstanceMetadataEndpointState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.http_tokens
                (fun f ->
                   Ezxmlm.make_tag "HttpTokens"
                     ([], (HttpTokensState.to_xml f)))])
            @
            [Util.option_map v.http_put_response_hop_limit
               (fun f ->
                  Ezxmlm.make_tag "HttpPutResponseHopLimit"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.http_endpoint
              (fun f ->
                 Ezxmlm.make_tag "HttpEndpoint"
                   ([], (InstanceMetadataEndpointState.to_xml f)))])
  end[@@ocaml.doc "<p>The metadata options for the instance.</p>"]
module LaunchTemplateSpecification =
  struct
    type t =
      {
      launch_template_id: String.t option
        [@ocaml.doc "<p>The ID of the launch template.</p>"];
      launch_template_name: String.t option
        [@ocaml.doc "<p>The name of the launch template.</p>"];
      version: String.t option
        [@ocaml.doc
          "<p>The version number of the launch template.</p> <p>Default: The default version for the launch template.</p>"]}
    [@@ocaml.doc
      "<p>The launch template to use. You must specify either the launch template ID or launch template name in the request, but not both.</p>"]
    let make ?launch_template_id  ?launch_template_name  ?version  () =
      { launch_template_id; launch_template_name; version }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> Query.Pair ("Version", (String.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> ("version", (String.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "LaunchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "LaunchTemplateName" xml)
               String.parse);
          version =
            (Util.option_bind (Xml.member "Version" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.launch_template_id
                (fun f ->
                   Ezxmlm.make_tag "LaunchTemplateId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.launch_template_name
               (fun f ->
                  Ezxmlm.make_tag "LaunchTemplateName"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.version
              (fun f -> Ezxmlm.make_tag "Version" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>The launch template to use. You must specify either the launch template ID or launch template name in the request, but not both.</p>"]
module LicenseSpecificationListRequest =
  struct
    type t = LicenseConfigurationRequest.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list LicenseConfigurationRequest.to_query v
    let to_headers v =
      Headers.to_headers_list LicenseConfigurationRequest.to_headers v
    let to_json v = `List (List.map LicenseConfigurationRequest.to_json v)
    let parse xml =
      Util.option_all
        (List.map LicenseConfigurationRequest.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LicenseConfigurationRequest.to_xml x))) v
  end
module LocalGatewayVirtualInterfaceGroupSet =
  struct
    type t = LocalGatewayVirtualInterfaceGroup.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list LocalGatewayVirtualInterfaceGroup.to_query v
    let to_headers v =
      Headers.to_headers_list LocalGatewayVirtualInterfaceGroup.to_headers v
    let to_json v =
      `List (List.map LocalGatewayVirtualInterfaceGroup.to_json v)
    let parse xml =
      Util.option_all
        (List.map LocalGatewayVirtualInterfaceGroup.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LocalGatewayVirtualInterfaceGroup.to_xml x))) v
  end
module ExecutableByStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ExecutableBy" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module ImageIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "ImageId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module MovingAddressStatusSet =
  struct
    type t = MovingAddressStatus.t list
    let make elems () = elems
    let to_query v = Query.to_query_list MovingAddressStatus.to_query v
    let to_headers v =
      Headers.to_headers_list MovingAddressStatus.to_headers v
    let to_json v = `List (List.map MovingAddressStatus.to_json v)
    let parse xml =
      Util.option_all
        (List.map MovingAddressStatus.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (MovingAddressStatus.to_xml x))) v
  end
module ExportTaskIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ExportTaskId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module ReservedInstancesOfferingIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module RequestLaunchTemplateData =
  struct
    type t =
      {
      kernel_id: String.t option
        [@ocaml.doc
          "<p>The ID of the kernel.</p> <important> <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html\">User Provided Kernels</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> </important>"];
      ebs_optimized: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.</p>"];
      iam_instance_profile:
        LaunchTemplateIamInstanceProfileSpecificationRequest.t option
        [@ocaml.doc "<p>The IAM instance profile.</p>"];
      block_device_mappings: LaunchTemplateBlockDeviceMappingRequestList.t
        [@ocaml.doc
          "<p>The block device mapping.</p> <important> <p>Supplying both a snapshot ID and an encryption value as arguments for block-device mapping results in an error. This is because only blank volumes can be encrypted on start, and these are not created from a snapshot. If a snapshot is the basis for the volume, it contains data by definition and its encryption status cannot be changed using this action.</p> </important>"];
      network_interfaces:
        LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.t
        [@ocaml.doc
          "<p>One or more network interfaces. If you specify a network interface, you must specify any security groups and subnets as part of the network interface.</p>"];
      image_id: String.t option [@ocaml.doc "<p>The ID of the AMI.</p>"];
      instance_type: InstanceType.t option
        [@ocaml.doc
          "<p>The instance type. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html\">Instance Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"];
      key_name: String.t option
        [@ocaml.doc
          "<p>The name of the key pair. You can create a key pair using <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html\">CreateKeyPair</a> or <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html\">ImportKeyPair</a>.</p> <important> <p>If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.</p> </important>"];
      monitoring: LaunchTemplatesMonitoringRequest.t option
        [@ocaml.doc "<p>The monitoring for the instance.</p>"];
      placement: LaunchTemplatePlacementRequest.t option
        [@ocaml.doc "<p>The placement for the instance.</p>"];
      ram_disk_id: String.t option
        [@ocaml.doc
          "<p>The ID of the RAM disk.</p> <important> <p>We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html\">User Provided Kernels</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p> </important>"];
      disable_api_termination: Boolean.t option
        [@ocaml.doc
          "<p>If you set this parameter to <code>true</code>, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute after launch, use <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html\">ModifyInstanceAttribute</a>. Alternatively, if you set <code>InstanceInitiatedShutdownBehavior</code> to <code>terminate</code>, you can terminate the instance by running the shutdown command from the instance.</p>"];
      instance_initiated_shutdown_behavior: ShutdownBehavior.t option
        [@ocaml.doc
          "<p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p> <p>Default: <code>stop</code> </p>"];
      user_data: String.t option
        [@ocaml.doc
          "<p>The Base64-encoded user data to make available to the instance. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html\">Running Commands on Your Linux Instance at Launch</a> (Linux) and <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/ec2-instance-metadata.html#instancedata-add-user-data\">Adding User Data</a> (Windows).</p>"];
      tag_specifications: LaunchTemplateTagSpecificationRequestList.t
        [@ocaml.doc
          "<p>The tags to apply to the resources during launch. You can only tag instances and volumes on launch. The specified tags are applied to all instances or volumes that are created during launch. To tag a resource after it has been created, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html\">CreateTags</a>.</p>"];
      elastic_gpu_specifications: ElasticGpuSpecificationList.t
        [@ocaml.doc "<p>An elastic GPU to associate with the instance.</p>"];
      elastic_inference_accelerators:
        LaunchTemplateElasticInferenceAcceleratorList.t
        [@ocaml.doc
          "<p> The elastic inference accelerator for the instance. </p>"];
      security_group_ids: SecurityGroupIdStringList.t
        [@ocaml.doc
          "<p>One or more security group IDs. You can create a security group using <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateSecurityGroup.html\">CreateSecurityGroup</a>. You cannot specify both a security group ID and security name in the same request.</p>"];
      security_groups: SecurityGroupStringList.t
        [@ocaml.doc
          "<p>[EC2-Classic, default VPC] One or more security group names. For a nondefault VPC, you must use security group IDs instead. You cannot specify both a security group ID and security name in the same request.</p>"];
      instance_market_options:
        LaunchTemplateInstanceMarketOptionsRequest.t option
        [@ocaml.doc
          "<p>The market (purchasing) option for the instances.</p>"];
      credit_specification: CreditSpecificationRequest.t option
        [@ocaml.doc
          "<p>The credit option for CPU usage of the instance. Valid for T2 or T3 instances only.</p>"];
      cpu_options: LaunchTemplateCpuOptionsRequest.t option
        [@ocaml.doc
          "<p>The CPU options for the instance. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html\">Optimizing CPU Options</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"];
      capacity_reservation_specification:
        LaunchTemplateCapacityReservationSpecificationRequest.t option
        [@ocaml.doc
          "<p>The Capacity Reservation targeting option. If you do not specify this parameter, the instance's Capacity Reservation preference defaults to <code>open</code>, which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).</p>"];
      license_specifications: LaunchTemplateLicenseSpecificationListRequest.t
        [@ocaml.doc "<p>The license configurations.</p>"];
      hibernation_options: LaunchTemplateHibernationOptionsRequest.t option
        [@ocaml.doc
          "<p>Indicates whether an instance is enabled for hibernation. This parameter is valid only if the instance meets the <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites\">hibernation prerequisites</a>. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html\">Hibernate Your Instance</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"]}
    [@@ocaml.doc "<p>The information to include in the launch template.</p>"]
    let make ?kernel_id  ?ebs_optimized  ?iam_instance_profile 
      ?(block_device_mappings= [])  ?(network_interfaces= [])  ?image_id 
      ?instance_type  ?key_name  ?monitoring  ?placement  ?ram_disk_id 
      ?disable_api_termination  ?instance_initiated_shutdown_behavior 
      ?user_data  ?(tag_specifications= [])  ?(elastic_gpu_specifications=
      [])  ?(elastic_inference_accelerators= [])  ?(security_group_ids= []) 
      ?(security_groups= [])  ?instance_market_options  ?credit_specification
       ?cpu_options  ?capacity_reservation_specification 
      ?(license_specifications= [])  ?hibernation_options  () =
      {
        kernel_id;
        ebs_optimized;
        iam_instance_profile;
        block_device_mappings;
        network_interfaces;
        image_id;
        instance_type;
        key_name;
        monitoring;
        placement;
        ram_disk_id;
        disable_api_termination;
        instance_initiated_shutdown_behavior;
        user_data;
        tag_specifications;
        elastic_gpu_specifications;
        elastic_inference_accelerators;
        security_group_ids;
        security_groups;
        instance_market_options;
        credit_specification;
        cpu_options;
        capacity_reservation_specification;
        license_specifications;
        hibernation_options
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.hibernation_options
              (fun f ->
                 Query.Pair
                   ("HibernationOptions",
                     (LaunchTemplateHibernationOptionsRequest.to_query f)));
           Some
             (Query.Pair
                ("LicenseSpecification",
                  (LaunchTemplateLicenseSpecificationListRequest.to_query
                     v.license_specifications)));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                Query.Pair
                  ("CapacityReservationSpecification",
                    (LaunchTemplateCapacityReservationSpecificationRequest.to_query
                       f)));
           Util.option_map v.cpu_options
             (fun f ->
                Query.Pair
                  ("CpuOptions",
                    (LaunchTemplateCpuOptionsRequest.to_query f)));
           Util.option_map v.credit_specification
             (fun f ->
                Query.Pair
                  ("CreditSpecification",
                    (CreditSpecificationRequest.to_query f)));
           Util.option_map v.instance_market_options
             (fun f ->
                Query.Pair
                  ("InstanceMarketOptions",
                    (LaunchTemplateInstanceMarketOptionsRequest.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroup",
                  (SecurityGroupStringList.to_query v.security_groups)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.security_group_ids)));
           Some
             (Query.Pair
                ("ElasticInferenceAccelerator",
                  (LaunchTemplateElasticInferenceAcceleratorList.to_query
                     v.elastic_inference_accelerators)));
           Some
             (Query.Pair
                ("ElasticGpuSpecification",
                  (ElasticGpuSpecificationList.to_query
                     v.elastic_gpu_specifications)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (LaunchTemplateTagSpecificationRequestList.to_query
                     v.tag_specifications)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (ShutdownBehavior.to_query f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                Query.Pair ("DisableApiTermination", (Boolean.to_query f)));
           Util.option_map v.ram_disk_id
             (fun f -> Query.Pair ("RamDiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f ->
                Query.Pair
                  ("Placement", (LaunchTemplatePlacementRequest.to_query f)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair
                  ("Monitoring",
                    (LaunchTemplatesMonitoringRequest.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterface",
                  (LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.to_query
                     v.network_interfaces)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (LaunchTemplateBlockDeviceMappingRequestList.to_query
                     v.block_device_mappings)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (LaunchTemplateIamInstanceProfileSpecificationRequest.to_query
                       f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.hibernation_options
              (fun f ->
                 ("hibernation_options",
                   (LaunchTemplateHibernationOptionsRequest.to_json f)));
           Some
             ("license_specifications",
               (LaunchTemplateLicenseSpecificationListRequest.to_json
                  v.license_specifications));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                ("capacity_reservation_specification",
                  (LaunchTemplateCapacityReservationSpecificationRequest.to_json
                     f)));
           Util.option_map v.cpu_options
             (fun f ->
                ("cpu_options", (LaunchTemplateCpuOptionsRequest.to_json f)));
           Util.option_map v.credit_specification
             (fun f ->
                ("credit_specification",
                  (CreditSpecificationRequest.to_json f)));
           Util.option_map v.instance_market_options
             (fun f ->
                ("instance_market_options",
                  (LaunchTemplateInstanceMarketOptionsRequest.to_json f)));
           Some
             ("security_groups",
               (SecurityGroupStringList.to_json v.security_groups));
           Some
             ("security_group_ids",
               (SecurityGroupIdStringList.to_json v.security_group_ids));
           Some
             ("elastic_inference_accelerators",
               (LaunchTemplateElasticInferenceAcceleratorList.to_json
                  v.elastic_inference_accelerators));
           Some
             ("elastic_gpu_specifications",
               (ElasticGpuSpecificationList.to_json
                  v.elastic_gpu_specifications));
           Some
             ("tag_specifications",
               (LaunchTemplateTagSpecificationRequestList.to_json
                  v.tag_specifications));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (ShutdownBehavior.to_json f)));
           Util.option_map v.disable_api_termination
             (fun f -> ("disable_api_termination", (Boolean.to_json f)));
           Util.option_map v.ram_disk_id
             (fun f -> ("ram_disk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f ->
                ("placement", (LaunchTemplatePlacementRequest.to_json f)));
           Util.option_map v.monitoring
             (fun f ->
                ("monitoring", (LaunchTemplatesMonitoringRequest.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Some
             ("network_interfaces",
               (LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.to_json
                  v.network_interfaces));
           Some
             ("block_device_mappings",
               (LaunchTemplateBlockDeviceMappingRequestList.to_json
                  v.block_device_mappings));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (LaunchTemplateIamInstanceProfileSpecificationRequest.to_json
                     f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          kernel_id =
            (Util.option_bind (Xml.member "KernelId" xml) String.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "EbsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "IamInstanceProfile" xml)
               LaunchTemplateIamInstanceProfileSpecificationRequest.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "BlockDeviceMapping" xml)
                  LaunchTemplateBlockDeviceMappingRequestList.parse));
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterface" xml)
                  LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.parse));
          image_id =
            (Util.option_bind (Xml.member "ImageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml)
               InstanceType.parse);
          key_name =
            (Util.option_bind (Xml.member "KeyName" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "Monitoring" xml)
               LaunchTemplatesMonitoringRequest.parse);
          placement =
            (Util.option_bind (Xml.member "Placement" xml)
               LaunchTemplatePlacementRequest.parse);
          ram_disk_id =
            (Util.option_bind (Xml.member "RamDiskId" xml) String.parse);
          disable_api_termination =
            (Util.option_bind (Xml.member "DisableApiTermination" xml)
               Boolean.parse);
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "InstanceInitiatedShutdownBehavior" xml)
               ShutdownBehavior.parse);
          user_data =
            (Util.option_bind (Xml.member "UserData" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  LaunchTemplateTagSpecificationRequestList.parse));
          elastic_gpu_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "ElasticGpuSpecification" xml)
                  ElasticGpuSpecificationList.parse));
          elastic_inference_accelerators =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ElasticInferenceAccelerator" xml)
                  LaunchTemplateElasticInferenceAcceleratorList.parse));
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroup" xml)
                  SecurityGroupStringList.parse));
          instance_market_options =
            (Util.option_bind (Xml.member "InstanceMarketOptions" xml)
               LaunchTemplateInstanceMarketOptionsRequest.parse);
          credit_specification =
            (Util.option_bind (Xml.member "CreditSpecification" xml)
               CreditSpecificationRequest.parse);
          cpu_options =
            (Util.option_bind (Xml.member "CpuOptions" xml)
               LaunchTemplateCpuOptionsRequest.parse);
          capacity_reservation_specification =
            (Util.option_bind
               (Xml.member "CapacityReservationSpecification" xml)
               LaunchTemplateCapacityReservationSpecificationRequest.parse);
          license_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "LicenseSpecification" xml)
                  LaunchTemplateLicenseSpecificationListRequest.parse));
          hibernation_options =
            (Util.option_bind (Xml.member "HibernationOptions" xml)
               LaunchTemplateHibernationOptionsRequest.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((((((((((([] @
                                   [Util.option_map v.kernel_id
                                      (fun f ->
                                         Ezxmlm.make_tag "KernelId"
                                           ([], (String.to_xml f)))])
                                  @
                                  [Util.option_map v.ebs_optimized
                                     (fun f ->
                                        Ezxmlm.make_tag "EbsOptimized"
                                          ([], (Boolean.to_xml f)))])
                                 @
                                 [Util.option_map v.iam_instance_profile
                                    (fun f ->
                                       Ezxmlm.make_tag "IamInstanceProfile"
                                         ([],
                                           (LaunchTemplateIamInstanceProfileSpecificationRequest.to_xml
                                              f)))])
                                @
                                (List.map
                                   (fun x ->
                                      Some
                                        (Ezxmlm.make_tag "BlockDeviceMapping"
                                           ([],
                                             (LaunchTemplateBlockDeviceMappingRequestList.to_xml
                                                [x]))))
                                   v.block_device_mappings))
                               @
                               (List.map
                                  (fun x ->
                                     Some
                                       (Ezxmlm.make_tag "NetworkInterface"
                                          ([],
                                            (LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.to_xml
                                               [x])))) v.network_interfaces))
                              @
                              [Util.option_map v.image_id
                                 (fun f ->
                                    Ezxmlm.make_tag "ImageId"
                                      ([], (String.to_xml f)))])
                             @
                             [Util.option_map v.instance_type
                                (fun f ->
                                   Ezxmlm.make_tag "InstanceType"
                                     ([], (InstanceType.to_xml f)))])
                            @
                            [Util.option_map v.key_name
                               (fun f ->
                                  Ezxmlm.make_tag "KeyName"
                                    ([], (String.to_xml f)))])
                           @
                           [Util.option_map v.monitoring
                              (fun f ->
                                 Ezxmlm.make_tag "Monitoring"
                                   ([],
                                     (LaunchTemplatesMonitoringRequest.to_xml
                                        f)))])
                          @
                          [Util.option_map v.placement
                             (fun f ->
                                Ezxmlm.make_tag "Placement"
                                  ([],
                                    (LaunchTemplatePlacementRequest.to_xml f)))])
                         @
                         [Util.option_map v.ram_disk_id
                            (fun f ->
                               Ezxmlm.make_tag "RamDiskId"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.disable_api_termination
                           (fun f ->
                              Ezxmlm.make_tag "DisableApiTermination"
                                ([], (Boolean.to_xml f)))])
                       @
                       [Util.option_map
                          v.instance_initiated_shutdown_behavior
                          (fun f ->
                             Ezxmlm.make_tag
                               "InstanceInitiatedShutdownBehavior"
                               ([], (ShutdownBehavior.to_xml f)))])
                      @
                      [Util.option_map v.user_data
                         (fun f ->
                            Ezxmlm.make_tag "UserData"
                              ([], (String.to_xml f)))])
                     @
                     (List.map
                        (fun x ->
                           Some
                             (Ezxmlm.make_tag "TagSpecification"
                                ([],
                                  (LaunchTemplateTagSpecificationRequestList.to_xml
                                     [x])))) v.tag_specifications))
                    @
                    (List.map
                       (fun x ->
                          Some
                            (Ezxmlm.make_tag "ElasticGpuSpecification"
                               ([], (ElasticGpuSpecificationList.to_xml [x]))))
                       v.elastic_gpu_specifications))
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "ElasticInferenceAccelerator"
                              ([],
                                (LaunchTemplateElasticInferenceAcceleratorList.to_xml
                                   [x])))) v.elastic_inference_accelerators))
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "SecurityGroupId"
                             ([], (SecurityGroupIdStringList.to_xml [x]))))
                     v.security_group_ids))
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "SecurityGroup"
                            ([], (SecurityGroupStringList.to_xml [x]))))
                    v.security_groups))
                @
                [Util.option_map v.instance_market_options
                   (fun f ->
                      Ezxmlm.make_tag "InstanceMarketOptions"
                        ([],
                          (LaunchTemplateInstanceMarketOptionsRequest.to_xml
                             f)))])
               @
               [Util.option_map v.credit_specification
                  (fun f ->
                     Ezxmlm.make_tag "CreditSpecification"
                       ([], (CreditSpecificationRequest.to_xml f)))])
              @
              [Util.option_map v.cpu_options
                 (fun f ->
                    Ezxmlm.make_tag "CpuOptions"
                      ([], (LaunchTemplateCpuOptionsRequest.to_xml f)))])
             @
             [Util.option_map v.capacity_reservation_specification
                (fun f ->
                   Ezxmlm.make_tag "CapacityReservationSpecification"
                     ([],
                       (LaunchTemplateCapacityReservationSpecificationRequest.to_xml
                          f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "LicenseSpecification"
                       ([],
                         (LaunchTemplateLicenseSpecificationListRequest.to_xml
                            [x])))) v.license_specifications))
           @
           [Util.option_map v.hibernation_options
              (fun f ->
                 Ezxmlm.make_tag "HibernationOptions"
                   ([], (LaunchTemplateHibernationOptionsRequest.to_xml f)))])
  end[@@ocaml.doc
       "<p>The information to include in the launch template.</p>"]
module TrafficMirrorSessionSet =
  struct
    type t = TrafficMirrorSession.t list
    let make elems () = elems
    let to_query v = Query.to_query_list TrafficMirrorSession.to_query v
    let to_headers v =
      Headers.to_headers_list TrafficMirrorSession.to_headers v
    let to_json v = `List (List.map TrafficMirrorSession.to_json v)
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorSession.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (TrafficMirrorSession.to_xml x))) v
  end
module NetworkInterfaceAttachmentChanges =
  struct
    type t =
      {
      attachment_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface attachment.</p>"];
      delete_on_termination: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the network interface is deleted when the instance is terminated.</p>"]}
    [@@ocaml.doc "<p>Describes an attachment change.</p>"]
    let make ?attachment_id  ?delete_on_termination  () =
      { attachment_id; delete_on_termination }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f ->
                 Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attachment_id
             (fun f -> Query.Pair ("AttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attachment_id
             (fun f -> ("attachment_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          attachment_id =
            (Util.option_bind (Xml.member "attachmentId" xml) String.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.attachment_id
               (fun f ->
                  Ezxmlm.make_tag "attachmentId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.delete_on_termination
              (fun f ->
                 Ezxmlm.make_tag "deleteOnTermination"
                   ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an attachment change.</p>"]
module DeleteLaunchTemplateVersionsResponseErrorSet =
  struct
    type t = DeleteLaunchTemplateVersionsResponseErrorItem.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list
        DeleteLaunchTemplateVersionsResponseErrorItem.to_query v
    let to_headers v =
      Headers.to_headers_list
        DeleteLaunchTemplateVersionsResponseErrorItem.to_headers v
    let to_json v =
      `List
        (List.map DeleteLaunchTemplateVersionsResponseErrorItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map DeleteLaunchTemplateVersionsResponseErrorItem.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (DeleteLaunchTemplateVersionsResponseErrorItem.to_xml x)))
        v
  end
module DeleteLaunchTemplateVersionsResponseSuccessSet =
  struct
    type t = DeleteLaunchTemplateVersionsResponseSuccessItem.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list
        DeleteLaunchTemplateVersionsResponseSuccessItem.to_query v
    let to_headers v =
      Headers.to_headers_list
        DeleteLaunchTemplateVersionsResponseSuccessItem.to_headers v
    let to_json v =
      `List
        (List.map DeleteLaunchTemplateVersionsResponseSuccessItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map DeleteLaunchTemplateVersionsResponseSuccessItem.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (DeleteLaunchTemplateVersionsResponseSuccessItem.to_xml x)))
        v
  end
module KeyNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "KeyName" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module KeyPairIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "KeyPairId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module TransitGatewayMulticastRegisteredGroupSources =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway multicast domain.</p>"];
      registered_network_interface_ids: ValueStringList.t
        [@ocaml.doc
          "<p>The IDs of the network interfaces members registered with the transit gateway multicast group.</p>"];
      group_ip_address: String.t option
        [@ocaml.doc
          "<p>The IP address assigned to the transit gateway multicast group.</p>"]}
    [@@ocaml.doc
      "<p>Describes the members registered with the transit gateway multicast group.</p>"]
    let make ?transit_gateway_multicast_domain_id 
      ?(registered_network_interface_ids= [])  ?group_ip_address  () =
      {
        transit_gateway_multicast_domain_id;
        registered_network_interface_ids;
        group_ip_address
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("RegisteredNetworkInterfaceIds",
                  (ValueStringList.to_query
                     v.registered_network_interface_ids)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> ("group_ip_address", (String.to_json f)));
           Some
             ("registered_network_interface_ids",
               (ValueStringList.to_json v.registered_network_interface_ids));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          registered_network_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "registeredNetworkInterfaceIds" xml)
                  ValueStringList.parse));
          group_ip_address =
            (Util.option_bind (Xml.member "groupIpAddress" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.transit_gateway_multicast_domain_id
                (fun f ->
                   Ezxmlm.make_tag "transitGatewayMulticastDomainId"
                     ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "registeredNetworkInterfaceIds"
                       ([], (ValueStringList.to_xml [x]))))
               v.registered_network_interface_ids))
           @
           [Util.option_map v.group_ip_address
              (fun f ->
                 Ezxmlm.make_tag "groupIpAddress" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the members registered with the transit gateway multicast group.</p>"]
module SpotInstanceRequestList =
  struct
    type t = SpotInstanceRequest.t list
    let make elems () = elems
    let to_query v = Query.to_query_list SpotInstanceRequest.to_query v
    let to_headers v =
      Headers.to_headers_list SpotInstanceRequest.to_headers v
    let to_json v = `List (List.map SpotInstanceRequest.to_json v)
    let parse xml =
      Util.option_all
        (List.map SpotInstanceRequest.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (SpotInstanceRequest.to_xml x))) v
  end
module FailedQueuedPurchaseDeletionSet =
  struct
    type t = FailedQueuedPurchaseDeletion.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list FailedQueuedPurchaseDeletion.to_query v
    let to_headers v =
      Headers.to_headers_list FailedQueuedPurchaseDeletion.to_headers v
    let to_json v = `List (List.map FailedQueuedPurchaseDeletion.to_json v)
    let parse xml =
      Util.option_all
        (List.map FailedQueuedPurchaseDeletion.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (FailedQueuedPurchaseDeletion.to_xml x))) v
  end
module SuccessfulQueuedPurchaseDeletionSet =
  struct
    type t = SuccessfulQueuedPurchaseDeletion.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list SuccessfulQueuedPurchaseDeletion.to_query v
    let to_headers v =
      Headers.to_headers_list SuccessfulQueuedPurchaseDeletion.to_headers v
    let to_json v =
      `List (List.map SuccessfulQueuedPurchaseDeletion.to_json v)
    let parse xml =
      Util.option_all
        (List.map SuccessfulQueuedPurchaseDeletion.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (SuccessfulQueuedPurchaseDeletion.to_xml x))) v
  end
module ExportTaskList =
  struct
    type t = ExportTask.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ExportTask.to_query v
    let to_headers v = Headers.to_headers_list ExportTask.to_headers v
    let to_json v = `List (List.map ExportTask.to_json v)
    let parse xml =
      Util.option_all (List.map ExportTask.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ExportTask.to_xml x))) v
  end
module InstanceMonitoringList =
  struct
    type t = InstanceMonitoring.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InstanceMonitoring.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceMonitoring.to_headers v
    let to_json v = `List (List.map InstanceMonitoring.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceMonitoring.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstanceMonitoring.to_xml x))) v
  end
module SecurityGroupList =
  struct
    type t = SecurityGroup.t list
    let make elems () = elems
    let to_query v = Query.to_query_list SecurityGroup.to_query v
    let to_headers v = Headers.to_headers_list SecurityGroup.to_headers v
    let to_json v = `List (List.map SecurityGroup.to_json v)
    let parse xml =
      Util.option_all (List.map SecurityGroup.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (SecurityGroup.to_xml x))) v
  end
module ServiceDetailSet =
  struct
    type t = ServiceDetail.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ServiceDetail.to_query v
    let to_headers v = Headers.to_headers_list ServiceDetail.to_headers v
    let to_json v = `List (List.map ServiceDetail.to_json v)
    let parse xml =
      Util.option_all (List.map ServiceDetail.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ServiceDetail.to_xml x))) v
  end
module EndpointSet =
  struct
    type t = ClientVpnEndpoint.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ClientVpnEndpoint.to_query v
    let to_headers v = Headers.to_headers_list ClientVpnEndpoint.to_headers v
    let to_json v = `List (List.map ClientVpnEndpoint.to_json v)
    let parse xml =
      Util.option_all
        (List.map ClientVpnEndpoint.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ClientVpnEndpoint.to_xml x)))
        v
  end
module FleetLaunchTemplateConfigListRequest =
  struct
    type t = FleetLaunchTemplateConfigRequest.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list FleetLaunchTemplateConfigRequest.to_query v
    let to_headers v =
      Headers.to_headers_list FleetLaunchTemplateConfigRequest.to_headers v
    let to_json v =
      `List (List.map FleetLaunchTemplateConfigRequest.to_json v)
    let parse xml =
      Util.option_all
        (List.map FleetLaunchTemplateConfigRequest.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (FleetLaunchTemplateConfigRequest.to_xml x))) v
  end
module OnDemandOptionsRequest =
  struct
    type t =
      {
      allocation_strategy: FleetOnDemandAllocationStrategy.t option
        [@ocaml.doc
          "<p>The order of the launch template overrides to use in fulfilling On-Demand capacity. If you specify <code>lowest-price</code>, EC2 Fleet uses price to determine the order, launching the lowest price first. If you specify <code>prioritized</code>, EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first. If you do not specify a value, EC2 Fleet defaults to <code>lowest-price</code>.</p>"];
      capacity_reservation_options:
        CapacityReservationOptionsRequest.t option
        [@ocaml.doc
          "<p>The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity. Supported only for fleets of type <code>instant</code>.</p>"];
      single_instance_type: Boolean.t option
        [@ocaml.doc
          "<p>Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet. Supported only for fleets of type <code>instant</code>.</p>"];
      single_availability_zone: Boolean.t option
        [@ocaml.doc
          "<p>Indicates that the fleet launches all On-Demand Instances into a single Availability Zone. Supported only for fleets of type <code>instant</code>.</p>"];
      min_target_capacity: Integer.t option
        [@ocaml.doc
          "<p>The minimum target capacity for On-Demand Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances.</p>"];
      max_total_price: String.t option
        [@ocaml.doc
          "<p>The maximum amount per hour for On-Demand Instances that you're willing to pay.</p>"]}
    [@@ocaml.doc
      "<p>Describes the configuration of On-Demand Instances in an EC2 Fleet.</p>"]
    let make ?allocation_strategy  ?capacity_reservation_options 
      ?single_instance_type  ?single_availability_zone  ?min_target_capacity 
      ?max_total_price  () =
      {
        allocation_strategy;
        capacity_reservation_options;
        single_instance_type;
        single_availability_zone;
        min_target_capacity;
        max_total_price
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> Query.Pair ("MaxTotalPrice", (String.to_query f)));
           Util.option_map v.min_target_capacity
             (fun f -> Query.Pair ("MinTargetCapacity", (Integer.to_query f)));
           Util.option_map v.single_availability_zone
             (fun f ->
                Query.Pair ("SingleAvailabilityZone", (Boolean.to_query f)));
           Util.option_map v.single_instance_type
             (fun f ->
                Query.Pair ("SingleInstanceType", (Boolean.to_query f)));
           Util.option_map v.capacity_reservation_options
             (fun f ->
                Query.Pair
                  ("CapacityReservationOptions",
                    (CapacityReservationOptionsRequest.to_query f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                Query.Pair
                  ("AllocationStrategy",
                    (FleetOnDemandAllocationStrategy.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> ("max_total_price", (String.to_json f)));
           Util.option_map v.min_target_capacity
             (fun f -> ("min_target_capacity", (Integer.to_json f)));
           Util.option_map v.single_availability_zone
             (fun f -> ("single_availability_zone", (Boolean.to_json f)));
           Util.option_map v.single_instance_type
             (fun f -> ("single_instance_type", (Boolean.to_json f)));
           Util.option_map v.capacity_reservation_options
             (fun f ->
                ("capacity_reservation_options",
                  (CapacityReservationOptionsRequest.to_json f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                ("allocation_strategy",
                  (FleetOnDemandAllocationStrategy.to_json f)))])
    let parse xml =
      Some
        {
          allocation_strategy =
            (Util.option_bind (Xml.member "AllocationStrategy" xml)
               FleetOnDemandAllocationStrategy.parse);
          capacity_reservation_options =
            (Util.option_bind (Xml.member "CapacityReservationOptions" xml)
               CapacityReservationOptionsRequest.parse);
          single_instance_type =
            (Util.option_bind (Xml.member "SingleInstanceType" xml)
               Boolean.parse);
          single_availability_zone =
            (Util.option_bind (Xml.member "SingleAvailabilityZone" xml)
               Boolean.parse);
          min_target_capacity =
            (Util.option_bind (Xml.member "MinTargetCapacity" xml)
               Integer.parse);
          max_total_price =
            (Util.option_bind (Xml.member "MaxTotalPrice" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.allocation_strategy
                   (fun f ->
                      Ezxmlm.make_tag "AllocationStrategy"
                        ([], (FleetOnDemandAllocationStrategy.to_xml f)))])
               @
               [Util.option_map v.capacity_reservation_options
                  (fun f ->
                     Ezxmlm.make_tag "CapacityReservationOptions"
                       ([], (CapacityReservationOptionsRequest.to_xml f)))])
              @
              [Util.option_map v.single_instance_type
                 (fun f ->
                    Ezxmlm.make_tag "SingleInstanceType"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.single_availability_zone
                (fun f ->
                   Ezxmlm.make_tag "SingleAvailabilityZone"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.min_target_capacity
               (fun f ->
                  Ezxmlm.make_tag "MinTargetCapacity"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.max_total_price
              (fun f ->
                 Ezxmlm.make_tag "MaxTotalPrice" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the configuration of On-Demand Instances in an EC2 Fleet.</p>"]
module SpotOptionsRequest =
  struct
    type t =
      {
      allocation_strategy: SpotAllocationStrategy.t option
        [@ocaml.doc
          "<p>Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.</p> <p>If the allocation strategy is <code>lowest-price</code>, EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.</p> <p>If the allocation strategy is <code>diversified</code>, EC2 Fleet launches instances from all of the Spot Instance pools that you specify.</p> <p>If the allocation strategy is <code>capacity-optimized</code>, EC2 Fleet launches instances from Spot Instance pools with optimal capacity for the number of instances that are launching.</p>"];
      instance_interruption_behavior:
        SpotInstanceInterruptionBehavior.t option
        [@ocaml.doc
          "<p>The behavior when a Spot Instance is interrupted. The default is <code>terminate</code>.</p>"];
      instance_pools_to_use_count: Integer.t option
        [@ocaml.doc
          "<p>The number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot <b>AllocationStrategy</b> is set to <code>lowest-price</code>. EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.</p>"];
      single_instance_type: Boolean.t option
        [@ocaml.doc
          "<p>Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet. Supported only for fleets of type <code>instant</code>.</p>"];
      single_availability_zone: Boolean.t option
        [@ocaml.doc
          "<p>Indicates that the fleet launches all Spot Instances into a single Availability Zone. Supported only for fleets of type <code>instant</code>.</p>"];
      min_target_capacity: Integer.t option
        [@ocaml.doc
          "<p>The minimum target capacity for Spot Instances in the fleet. If the minimum target capacity is not reached, the fleet launches no instances.</p>"];
      max_total_price: String.t option
        [@ocaml.doc
          "<p>The maximum amount per hour for Spot Instances that you're willing to pay.</p>"]}
    [@@ocaml.doc
      "<p>Describes the configuration of Spot Instances in an EC2 Fleet request.</p>"]
    let make ?allocation_strategy  ?instance_interruption_behavior 
      ?instance_pools_to_use_count  ?single_instance_type 
      ?single_availability_zone  ?min_target_capacity  ?max_total_price  () =
      {
        allocation_strategy;
        instance_interruption_behavior;
        instance_pools_to_use_count;
        single_instance_type;
        single_availability_zone;
        min_target_capacity;
        max_total_price
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> Query.Pair ("MaxTotalPrice", (String.to_query f)));
           Util.option_map v.min_target_capacity
             (fun f -> Query.Pair ("MinTargetCapacity", (Integer.to_query f)));
           Util.option_map v.single_availability_zone
             (fun f ->
                Query.Pair ("SingleAvailabilityZone", (Boolean.to_query f)));
           Util.option_map v.single_instance_type
             (fun f ->
                Query.Pair ("SingleInstanceType", (Boolean.to_query f)));
           Util.option_map v.instance_pools_to_use_count
             (fun f ->
                Query.Pair ("InstancePoolsToUseCount", (Integer.to_query f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInterruptionBehavior",
                    (SpotInstanceInterruptionBehavior.to_query f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                Query.Pair
                  ("AllocationStrategy", (SpotAllocationStrategy.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> ("max_total_price", (String.to_json f)));
           Util.option_map v.min_target_capacity
             (fun f -> ("min_target_capacity", (Integer.to_json f)));
           Util.option_map v.single_availability_zone
             (fun f -> ("single_availability_zone", (Boolean.to_json f)));
           Util.option_map v.single_instance_type
             (fun f -> ("single_instance_type", (Boolean.to_json f)));
           Util.option_map v.instance_pools_to_use_count
             (fun f -> ("instance_pools_to_use_count", (Integer.to_json f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                ("instance_interruption_behavior",
                  (SpotInstanceInterruptionBehavior.to_json f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                ("allocation_strategy", (SpotAllocationStrategy.to_json f)))])
    let parse xml =
      Some
        {
          allocation_strategy =
            (Util.option_bind (Xml.member "AllocationStrategy" xml)
               SpotAllocationStrategy.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "InstanceInterruptionBehavior" xml)
               SpotInstanceInterruptionBehavior.parse);
          instance_pools_to_use_count =
            (Util.option_bind (Xml.member "InstancePoolsToUseCount" xml)
               Integer.parse);
          single_instance_type =
            (Util.option_bind (Xml.member "SingleInstanceType" xml)
               Boolean.parse);
          single_availability_zone =
            (Util.option_bind (Xml.member "SingleAvailabilityZone" xml)
               Boolean.parse);
          min_target_capacity =
            (Util.option_bind (Xml.member "MinTargetCapacity" xml)
               Integer.parse);
          max_total_price =
            (Util.option_bind (Xml.member "MaxTotalPrice" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.allocation_strategy
                    (fun f ->
                       Ezxmlm.make_tag "AllocationStrategy"
                         ([], (SpotAllocationStrategy.to_xml f)))])
                @
                [Util.option_map v.instance_interruption_behavior
                   (fun f ->
                      Ezxmlm.make_tag "InstanceInterruptionBehavior"
                        ([], (SpotInstanceInterruptionBehavior.to_xml f)))])
               @
               [Util.option_map v.instance_pools_to_use_count
                  (fun f ->
                     Ezxmlm.make_tag "InstancePoolsToUseCount"
                       ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.single_instance_type
                 (fun f ->
                    Ezxmlm.make_tag "SingleInstanceType"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.single_availability_zone
                (fun f ->
                   Ezxmlm.make_tag "SingleAvailabilityZone"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.min_target_capacity
               (fun f ->
                  Ezxmlm.make_tag "MinTargetCapacity"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.max_total_price
              (fun f ->
                 Ezxmlm.make_tag "MaxTotalPrice" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the configuration of Spot Instances in an EC2 Fleet request.</p>"]
module TargetCapacitySpecificationRequest =
  struct
    type t =
      {
      total_target_capacity: Integer.t
        [@ocaml.doc
          "<p>The number of units to request, filled using <code>DefaultTargetCapacityType</code>.</p>"];
      on_demand_target_capacity: Integer.t option
        [@ocaml.doc "<p>The number of On-Demand units to request.</p>"];
      spot_target_capacity: Integer.t option
        [@ocaml.doc "<p>The number of Spot units to request.</p>"];
      default_target_capacity_type: DefaultTargetCapacityType.t option
        [@ocaml.doc
          "<p>The default <code>TotalTargetCapacity</code>, which is either <code>Spot</code> or <code>On-Demand</code>.</p>"]}
    [@@ocaml.doc
      "<p>The number of units to request. You can choose to set the target capacity as the number of instances. Or you can set the target capacity to a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>, you can specify a target capacity of 0 and add capacity later.</p> <p>You can use the On-Demand Instance <code>MaxTotalPrice</code> parameter, the Spot Instance <code>MaxTotalPrice</code> parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, EC2 Fleet will launch instances until it reaches the maximum amount that you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasn\226\128\153t met the target capacity. The <code>MaxTotalPrice</code> parameters are located in and .</p>"]
    let make ~total_target_capacity  ?on_demand_target_capacity 
      ?spot_target_capacity  ?default_target_capacity_type  () =
      {
        total_target_capacity;
        on_demand_target_capacity;
        spot_target_capacity;
        default_target_capacity_type
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.default_target_capacity_type
              (fun f ->
                 Query.Pair
                   ("DefaultTargetCapacityType",
                     (DefaultTargetCapacityType.to_query f)));
           Util.option_map v.spot_target_capacity
             (fun f ->
                Query.Pair ("SpotTargetCapacity", (Integer.to_query f)));
           Util.option_map v.on_demand_target_capacity
             (fun f ->
                Query.Pair ("OnDemandTargetCapacity", (Integer.to_query f)));
           Some
             (Query.Pair
                ("TotalTargetCapacity",
                  (Integer.to_query v.total_target_capacity)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.default_target_capacity_type
              (fun f ->
                 ("default_target_capacity_type",
                   (DefaultTargetCapacityType.to_json f)));
           Util.option_map v.spot_target_capacity
             (fun f -> ("spot_target_capacity", (Integer.to_json f)));
           Util.option_map v.on_demand_target_capacity
             (fun f -> ("on_demand_target_capacity", (Integer.to_json f)));
           Some
             ("total_target_capacity",
               (Integer.to_json v.total_target_capacity))])
    let parse xml =
      Some
        {
          total_target_capacity =
            (Xml.required "TotalTargetCapacity"
               (Util.option_bind (Xml.member "TotalTargetCapacity" xml)
                  Integer.parse));
          on_demand_target_capacity =
            (Util.option_bind (Xml.member "OnDemandTargetCapacity" xml)
               Integer.parse);
          spot_target_capacity =
            (Util.option_bind (Xml.member "SpotTargetCapacity" xml)
               Integer.parse);
          default_target_capacity_type =
            (Util.option_bind (Xml.member "DefaultTargetCapacityType" xml)
               DefaultTargetCapacityType.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "TotalTargetCapacity"
                    ([], (Integer.to_xml v.total_target_capacity)))])
             @
             [Util.option_map v.on_demand_target_capacity
                (fun f ->
                   Ezxmlm.make_tag "OnDemandTargetCapacity"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.spot_target_capacity
               (fun f ->
                  Ezxmlm.make_tag "SpotTargetCapacity"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.default_target_capacity_type
              (fun f ->
                 Ezxmlm.make_tag "DefaultTargetCapacityType"
                   ([], (DefaultTargetCapacityType.to_xml f)))])
  end[@@ocaml.doc
       "<p>The number of units to request. You can choose to set the target capacity as the number of instances. Or you can set the target capacity to a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is <code>maintain</code>, you can specify a target capacity of 0 and add capacity later.</p> <p>You can use the On-Demand Instance <code>MaxTotalPrice</code> parameter, the Spot Instance <code>MaxTotalPrice</code> parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, EC2 Fleet will launch instances until it reaches the maximum amount that you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasn\226\128\153t met the target capacity. The <code>MaxTotalPrice</code> parameters are located in and .</p>"]
module TransitGatewayMulticastDeregisteredGroupSources =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway multicast domain.</p>"];
      deregistered_network_interface_ids: ValueStringList.t
        [@ocaml.doc
          "<p>The network interface IDs of the non-registered members.</p>"];
      group_ip_address: String.t option
        [@ocaml.doc
          "<p>The IP address assigned to the transit gateway multicast group.</p>"]}
    [@@ocaml.doc
      "<p>Describes the deregistered transit gateway multicast group sources.</p>"]
    let make ?transit_gateway_multicast_domain_id 
      ?(deregistered_network_interface_ids= [])  ?group_ip_address  () =
      {
        transit_gateway_multicast_domain_id;
        deregistered_network_interface_ids;
        group_ip_address
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("DeregisteredNetworkInterfaceIds",
                  (ValueStringList.to_query
                     v.deregistered_network_interface_ids)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> ("group_ip_address", (String.to_json f)));
           Some
             ("deregistered_network_interface_ids",
               (ValueStringList.to_json v.deregistered_network_interface_ids));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          deregistered_network_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "deregisteredNetworkInterfaceIds" xml)
                  ValueStringList.parse));
          group_ip_address =
            (Util.option_bind (Xml.member "groupIpAddress" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.transit_gateway_multicast_domain_id
                (fun f ->
                   Ezxmlm.make_tag "transitGatewayMulticastDomainId"
                     ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "deregisteredNetworkInterfaceIds"
                       ([], (ValueStringList.to_xml [x]))))
               v.deregistered_network_interface_ids))
           @
           [Util.option_map v.group_ip_address
              (fun f ->
                 Ezxmlm.make_tag "groupIpAddress" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the deregistered transit gateway multicast group sources.</p>"]
module InternetGatewayList =
  struct
    type t = InternetGateway.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InternetGateway.to_query v
    let to_headers v = Headers.to_headers_list InternetGateway.to_headers v
    let to_json v = `List (List.map InternetGateway.to_json v)
    let parse xml =
      Util.option_all
        (List.map InternetGateway.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InternetGateway.to_xml x)))
        v
  end
module NetworkInterfaceIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module AccountAttributeNameStringList =
  struct
    type t = AccountAttributeName.t list
    let make elems () = elems
    let to_query v = Query.to_query_list AccountAttributeName.to_query v
    let to_headers v =
      Headers.to_headers_list AccountAttributeName.to_headers v
    let to_json v = `List (List.map AccountAttributeName.to_json v)
    let parse xml =
      Util.option_all
        (List.map AccountAttributeName.parse
           (Xml.members "attributeName" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (AccountAttributeName.to_xml x))) v
  end
module ConversionIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module FleetSet =
  struct
    type t = FleetData.t list
    let make elems () = elems
    let to_query v = Query.to_query_list FleetData.to_query v
    let to_headers v = Headers.to_headers_list FleetData.to_headers v
    let to_json v = `List (List.map FleetData.to_json v)
    let parse xml =
      Util.option_all (List.map FleetData.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (FleetData.to_xml x)))
        v
  end
module DeleteQueuedReservedInstancesIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module SpotFleetRequestConfigSet =
  struct
    type t = SpotFleetRequestConfig.t list
    let make elems () = elems
    let to_query v = Query.to_query_list SpotFleetRequestConfig.to_query v
    let to_headers v =
      Headers.to_headers_list SpotFleetRequestConfig.to_headers v
    let to_json v = `List (List.map SpotFleetRequestConfig.to_json v)
    let parse xml =
      Util.option_all
        (List.map SpotFleetRequestConfig.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (SpotFleetRequestConfig.to_xml x)))
        v
  end
module FpgaImageAttributeName =
  struct
    type t =
      | Description 
      | Name 
      | LoadPermission 
      | ProductCodes 
    let str_to_t =
      [("productCodes", ProductCodes);
      ("loadPermission", LoadPermission);
      ("name", Name);
      ("description", Description)]
    let t_to_str =
      [(ProductCodes, "productCodes");
      (LoadPermission, "loadPermission");
      (Name, "name");
      (Description, "description")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module VolumeAttributeName =
  struct
    type t =
      | AutoEnableIO 
      | ProductCodes 
    let str_to_t =
      [("productCodes", ProductCodes); ("autoEnableIO", AutoEnableIO)]
    let t_to_str =
      [(ProductCodes, "productCodes"); (AutoEnableIO, "autoEnableIO")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module PurchaseRequestSet =
  struct
    type t = PurchaseRequest.t list
    let make elems () = elems
    let to_query v = Query.to_query_list PurchaseRequest.to_query v
    let to_headers v = Headers.to_headers_list PurchaseRequest.to_headers v
    let to_json v = `List (List.map PurchaseRequest.to_json v)
    let parse xml =
      Util.option_all
        (List.map PurchaseRequest.parse (Xml.members "PurchaseRequest" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PurchaseRequest.to_xml x)))
        v
  end
module AvailabilityZoneList =
  struct
    type t = AvailabilityZone.t list
    let make elems () = elems
    let to_query v = Query.to_query_list AvailabilityZone.to_query v
    let to_headers v = Headers.to_headers_list AvailabilityZone.to_headers v
    let to_json v = `List (List.map AvailabilityZone.to_json v)
    let parse xml =
      Util.option_all
        (List.map AvailabilityZone.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (AvailabilityZone.to_xml x)))
        v
  end
module CoipPoolIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module CustomerGatewayList =
  struct
    type t = CustomerGateway.t list
    let make elems () = elems
    let to_query v = Query.to_query_list CustomerGateway.to_query v
    let to_headers v = Headers.to_headers_list CustomerGateway.to_headers v
    let to_json v = `List (List.map CustomerGateway.to_json v)
    let parse xml =
      Util.option_all
        (List.map CustomerGateway.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (CustomerGateway.to_xml x)))
        v
  end
module VolumeStatusList =
  struct
    type t = VolumeStatusItem.t list
    let make elems () = elems
    let to_query v = Query.to_query_list VolumeStatusItem.to_query v
    let to_headers v = Headers.to_headers_list VolumeStatusItem.to_headers v
    let to_json v = `List (List.map VolumeStatusItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map VolumeStatusItem.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VolumeStatusItem.to_xml x)))
        v
  end
module TransitGatewayRequestOptions =
  struct
    type t =
      {
      amazon_side_asn: Long.t option
        [@ocaml.doc
          "<p>A private Autonomous System Number (ASN) for the Amazon side of a BGP session. The range is 64512 to 65534 for 16-bit ASNs and 4200000000 to 4294967294 for 32-bit ASNs.</p>"];
      auto_accept_shared_attachments:
        AutoAcceptSharedAttachmentsValue.t option
        [@ocaml.doc
          "<p>Enable or disable automatic acceptance of attachment requests. The default is <code>disable</code>.</p>"];
      default_route_table_association:
        DefaultRouteTableAssociationValue.t option
        [@ocaml.doc
          "<p>Enable or disable automatic association with the default association route table. The default is <code>enable</code>.</p>"];
      default_route_table_propagation:
        DefaultRouteTablePropagationValue.t option
        [@ocaml.doc
          "<p>Enable or disable automatic propagation of routes to the default propagation route table. The default is <code>enable</code>.</p>"];
      vpn_ecmp_support: VpnEcmpSupportValue.t option
        [@ocaml.doc
          "<p>Enable or disable Equal Cost Multipath Protocol support.</p>"];
      dns_support: DnsSupportValue.t option
        [@ocaml.doc "<p>Enable or disable DNS support.</p>"];
      multicast_support: MulticastSupportValue.t option
        [@ocaml.doc
          "<p>Indicates whether multicast is enabled on the transit gateway</p>"]}
    [@@ocaml.doc "<p>Describes the options for a transit gateway.</p>"]
    let make ?amazon_side_asn  ?auto_accept_shared_attachments 
      ?default_route_table_association  ?default_route_table_propagation 
      ?vpn_ecmp_support  ?dns_support  ?multicast_support  () =
      {
        amazon_side_asn;
        auto_accept_shared_attachments;
        default_route_table_association;
        default_route_table_propagation;
        vpn_ecmp_support;
        dns_support;
        multicast_support
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.multicast_support
              (fun f ->
                 Query.Pair
                   ("MulticastSupport", (MulticastSupportValue.to_query f)));
           Util.option_map v.dns_support
             (fun f ->
                Query.Pair ("DnsSupport", (DnsSupportValue.to_query f)));
           Util.option_map v.vpn_ecmp_support
             (fun f ->
                Query.Pair
                  ("VpnEcmpSupport", (VpnEcmpSupportValue.to_query f)));
           Util.option_map v.default_route_table_propagation
             (fun f ->
                Query.Pair
                  ("DefaultRouteTablePropagation",
                    (DefaultRouteTablePropagationValue.to_query f)));
           Util.option_map v.default_route_table_association
             (fun f ->
                Query.Pair
                  ("DefaultRouteTableAssociation",
                    (DefaultRouteTableAssociationValue.to_query f)));
           Util.option_map v.auto_accept_shared_attachments
             (fun f ->
                Query.Pair
                  ("AutoAcceptSharedAttachments",
                    (AutoAcceptSharedAttachmentsValue.to_query f)));
           Util.option_map v.amazon_side_asn
             (fun f -> Query.Pair ("AmazonSideAsn", (Long.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.multicast_support
              (fun f ->
                 ("multicast_support", (MulticastSupportValue.to_json f)));
           Util.option_map v.dns_support
             (fun f -> ("dns_support", (DnsSupportValue.to_json f)));
           Util.option_map v.vpn_ecmp_support
             (fun f -> ("vpn_ecmp_support", (VpnEcmpSupportValue.to_json f)));
           Util.option_map v.default_route_table_propagation
             (fun f ->
                ("default_route_table_propagation",
                  (DefaultRouteTablePropagationValue.to_json f)));
           Util.option_map v.default_route_table_association
             (fun f ->
                ("default_route_table_association",
                  (DefaultRouteTableAssociationValue.to_json f)));
           Util.option_map v.auto_accept_shared_attachments
             (fun f ->
                ("auto_accept_shared_attachments",
                  (AutoAcceptSharedAttachmentsValue.to_json f)));
           Util.option_map v.amazon_side_asn
             (fun f -> ("amazon_side_asn", (Long.to_json f)))])
    let parse xml =
      Some
        {
          amazon_side_asn =
            (Util.option_bind (Xml.member "AmazonSideAsn" xml) Long.parse);
          auto_accept_shared_attachments =
            (Util.option_bind (Xml.member "AutoAcceptSharedAttachments" xml)
               AutoAcceptSharedAttachmentsValue.parse);
          default_route_table_association =
            (Util.option_bind (Xml.member "DefaultRouteTableAssociation" xml)
               DefaultRouteTableAssociationValue.parse);
          default_route_table_propagation =
            (Util.option_bind (Xml.member "DefaultRouteTablePropagation" xml)
               DefaultRouteTablePropagationValue.parse);
          vpn_ecmp_support =
            (Util.option_bind (Xml.member "VpnEcmpSupport" xml)
               VpnEcmpSupportValue.parse);
          dns_support =
            (Util.option_bind (Xml.member "DnsSupport" xml)
               DnsSupportValue.parse);
          multicast_support =
            (Util.option_bind (Xml.member "MulticastSupport" xml)
               MulticastSupportValue.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.amazon_side_asn
                    (fun f ->
                       Ezxmlm.make_tag "AmazonSideAsn" ([], (Long.to_xml f)))])
                @
                [Util.option_map v.auto_accept_shared_attachments
                   (fun f ->
                      Ezxmlm.make_tag "AutoAcceptSharedAttachments"
                        ([], (AutoAcceptSharedAttachmentsValue.to_xml f)))])
               @
               [Util.option_map v.default_route_table_association
                  (fun f ->
                     Ezxmlm.make_tag "DefaultRouteTableAssociation"
                       ([], (DefaultRouteTableAssociationValue.to_xml f)))])
              @
              [Util.option_map v.default_route_table_propagation
                 (fun f ->
                    Ezxmlm.make_tag "DefaultRouteTablePropagation"
                      ([], (DefaultRouteTablePropagationValue.to_xml f)))])
             @
             [Util.option_map v.vpn_ecmp_support
                (fun f ->
                   Ezxmlm.make_tag "VpnEcmpSupport"
                     ([], (VpnEcmpSupportValue.to_xml f)))])
            @
            [Util.option_map v.dns_support
               (fun f ->
                  Ezxmlm.make_tag "DnsSupport"
                    ([], (DnsSupportValue.to_xml f)))])
           @
           [Util.option_map v.multicast_support
              (fun f ->
                 Ezxmlm.make_tag "MulticastSupport"
                   ([], (MulticastSupportValue.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the options for a transit gateway.</p>"]
module TransitGatewayRouteTableAssociationList =
  struct
    type t = TransitGatewayRouteTableAssociation.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list TransitGatewayRouteTableAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayRouteTableAssociation.to_headers
        v
    let to_json v =
      `List (List.map TransitGatewayRouteTableAssociation.to_json v)
    let parse xml =
      Util.option_all
        (List.map TransitGatewayRouteTableAssociation.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayRouteTableAssociation.to_xml x))) v
  end
module HostOfferingSet =
  struct
    type t = HostOffering.t list
    let make elems () = elems
    let to_query v = Query.to_query_list HostOffering.to_query v
    let to_headers v = Headers.to_headers_list HostOffering.to_headers v
    let to_json v = `List (List.map HostOffering.to_json v)
    let parse xml =
      Util.option_all (List.map HostOffering.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (HostOffering.to_xml x))) v
  end
module TransitGatewayIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module Affinity =
  struct
    type t =
      | Default 
      | Host 
    let str_to_t = [("host", Host); ("default", Default)]
    let t_to_str = [(Host, "host"); (Default, "default")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module HostTenancy =
  struct
    type t =
      | Dedicated 
      | Host 
    let str_to_t = [("host", Host); ("dedicated", Dedicated)]
    let t_to_str = [(Host, "host"); (Dedicated, "dedicated")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module EgressOnlyInternetGatewayIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module NetworkInterfacePermissionIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module ModifyVpnTunnelOptionsSpecification =
  struct
    type t =
      {
      tunnel_inside_cidr: String.t option
        [@ocaml.doc
          "<p>The range of inside IP addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. </p> <p>Constraints: A size /30 CIDR block from the <code>169.254.0.0/16</code> range. The following CIDR blocks are reserved and cannot be used:</p> <ul> <li> <p> <code>169.254.0.0/30</code> </p> </li> <li> <p> <code>169.254.1.0/30</code> </p> </li> <li> <p> <code>169.254.2.0/30</code> </p> </li> <li> <p> <code>169.254.3.0/30</code> </p> </li> <li> <p> <code>169.254.4.0/30</code> </p> </li> <li> <p> <code>169.254.5.0/30</code> </p> </li> <li> <p> <code>169.254.169.252/30</code> </p> </li> </ul>"];
      pre_shared_key: String.t option
        [@ocaml.doc
          "<p>The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and the customer gateway.</p> <p>Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).</p>"];
      phase1_lifetime_seconds: Integer.t option
        [@ocaml.doc
          "<p>The lifetime for phase 1 of the IKE negotiation, in seconds.</p> <p>Constraints: A value between 900 and 28,800.</p> <p>Default: <code>28800</code> </p>"];
      phase2_lifetime_seconds: Integer.t option
        [@ocaml.doc
          "<p>The lifetime for phase 2 of the IKE negotiation, in seconds.</p> <p>Constraints: A value between 900 and 3,600. The value must be less than the value for <code>Phase1LifetimeSeconds</code>.</p> <p>Default: <code>3600</code> </p>"];
      rekey_margin_time_seconds: Integer.t option
        [@ocaml.doc
          "<p>The margin time, in seconds, before the phase 2 lifetime expires, during which the AWS side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for <code>RekeyFuzzPercentage</code>.</p> <p>Constraints: A value between 60 and half of <code>Phase2LifetimeSeconds</code>.</p> <p>Default: <code>540</code> </p>"];
      rekey_fuzz_percentage: Integer.t option
        [@ocaml.doc
          "<p>The percentage of the rekey window (determined by <code>RekeyMarginTimeSeconds</code>) during which the rekey time is randomly selected.</p> <p>Constraints: A value between 0 and 100.</p> <p>Default: <code>100</code> </p>"];
      replay_window_size: Integer.t option
        [@ocaml.doc
          "<p>The number of packets in an IKE replay window.</p> <p>Constraints: A value between 64 and 2048.</p> <p>Default: <code>1024</code> </p>"];
      d_p_d_timeout_seconds: Integer.t option
        [@ocaml.doc
          "<p>The number of seconds after which a DPD timeout occurs.</p> <p>Constraints: A value between 0 and 30.</p> <p>Default: <code>30</code> </p>"];
      phase1_encryption_algorithms: Phase1EncryptionAlgorithmsRequestList.t
        [@ocaml.doc
          "<p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p> <p>Valid values: <code>AES128</code> | <code>AES256</code> </p>"];
      phase2_encryption_algorithms: Phase2EncryptionAlgorithmsRequestList.t
        [@ocaml.doc
          "<p>One or more encryption algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p> <p>Valid values: <code>AES128</code> | <code>AES256</code> </p>"];
      phase1_integrity_algorithms: Phase1IntegrityAlgorithmsRequestList.t
        [@ocaml.doc
          "<p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p> <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> </p>"];
      phase2_integrity_algorithms: Phase2IntegrityAlgorithmsRequestList.t
        [@ocaml.doc
          "<p>One or more integrity algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p> <p>Valid values: <code>SHA1</code> | <code>SHA2-256</code> </p>"];
      phase1_d_h_group_numbers: Phase1DHGroupNumbersRequestList.t
        [@ocaml.doc
          "<p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 1 IKE negotiations.</p> <p>Valid values: <code>2</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>22</code> | <code>23</code> | <code>24</code> </p>"];
      phase2_d_h_group_numbers: Phase2DHGroupNumbersRequestList.t
        [@ocaml.doc
          "<p>One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 2 IKE negotiations.</p> <p>Valid values: <code>2</code> | <code>5</code> | <code>14</code> | <code>15</code> | <code>16</code> | <code>17</code> | <code>18</code> | <code>22</code> | <code>23</code> | <code>24</code> </p>"];
      i_k_e_versions: IKEVersionsRequestList.t
        [@ocaml.doc
          "<p>The IKE versions that are permitted for the VPN tunnel.</p> <p>Valid values: <code>ikev1</code> | <code>ikev2</code> </p>"]}
    [@@ocaml.doc "<p>The AWS Site-to-Site VPN tunnel options to modify.</p>"]
    let make ?tunnel_inside_cidr  ?pre_shared_key  ?phase1_lifetime_seconds 
      ?phase2_lifetime_seconds  ?rekey_margin_time_seconds 
      ?rekey_fuzz_percentage  ?replay_window_size  ?d_p_d_timeout_seconds 
      ?(phase1_encryption_algorithms= [])  ?(phase2_encryption_algorithms=
      [])  ?(phase1_integrity_algorithms= [])  ?(phase2_integrity_algorithms=
      [])  ?(phase1_d_h_group_numbers= [])  ?(phase2_d_h_group_numbers= []) 
      ?(i_k_e_versions= [])  () =
      {
        tunnel_inside_cidr;
        pre_shared_key;
        phase1_lifetime_seconds;
        phase2_lifetime_seconds;
        rekey_margin_time_seconds;
        rekey_fuzz_percentage;
        replay_window_size;
        d_p_d_timeout_seconds;
        phase1_encryption_algorithms;
        phase2_encryption_algorithms;
        phase1_integrity_algorithms;
        phase2_integrity_algorithms;
        phase1_d_h_group_numbers;
        phase2_d_h_group_numbers;
        i_k_e_versions
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("IKEVersion",
                   (IKEVersionsRequestList.to_query v.i_k_e_versions)));
           Some
             (Query.Pair
                ("Phase2DHGroupNumber",
                  (Phase2DHGroupNumbersRequestList.to_query
                     v.phase2_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase1DHGroupNumber",
                  (Phase1DHGroupNumbersRequestList.to_query
                     v.phase1_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase2IntegrityAlgorithm",
                  (Phase2IntegrityAlgorithmsRequestList.to_query
                     v.phase2_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase1IntegrityAlgorithm",
                  (Phase1IntegrityAlgorithmsRequestList.to_query
                     v.phase1_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase2EncryptionAlgorithm",
                  (Phase2EncryptionAlgorithmsRequestList.to_query
                     v.phase2_encryption_algorithms)));
           Some
             (Query.Pair
                ("Phase1EncryptionAlgorithm",
                  (Phase1EncryptionAlgorithmsRequestList.to_query
                     v.phase1_encryption_algorithms)));
           Util.option_map v.d_p_d_timeout_seconds
             (fun f -> Query.Pair ("DPDTimeoutSeconds", (Integer.to_query f)));
           Util.option_map v.replay_window_size
             (fun f -> Query.Pair ("ReplayWindowSize", (Integer.to_query f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f ->
                Query.Pair ("RekeyFuzzPercentage", (Integer.to_query f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f ->
                Query.Pair ("RekeyMarginTimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase2LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase1LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.pre_shared_key
             (fun f -> Query.Pair ("PreSharedKey", (String.to_query f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> Query.Pair ("TunnelInsideCidr", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("i_k_e_versions",
                (IKEVersionsRequestList.to_json v.i_k_e_versions));
           Some
             ("phase2_d_h_group_numbers",
               (Phase2DHGroupNumbersRequestList.to_json
                  v.phase2_d_h_group_numbers));
           Some
             ("phase1_d_h_group_numbers",
               (Phase1DHGroupNumbersRequestList.to_json
                  v.phase1_d_h_group_numbers));
           Some
             ("phase2_integrity_algorithms",
               (Phase2IntegrityAlgorithmsRequestList.to_json
                  v.phase2_integrity_algorithms));
           Some
             ("phase1_integrity_algorithms",
               (Phase1IntegrityAlgorithmsRequestList.to_json
                  v.phase1_integrity_algorithms));
           Some
             ("phase2_encryption_algorithms",
               (Phase2EncryptionAlgorithmsRequestList.to_json
                  v.phase2_encryption_algorithms));
           Some
             ("phase1_encryption_algorithms",
               (Phase1EncryptionAlgorithmsRequestList.to_json
                  v.phase1_encryption_algorithms));
           Util.option_map v.d_p_d_timeout_seconds
             (fun f -> ("d_p_d_timeout_seconds", (Integer.to_json f)));
           Util.option_map v.replay_window_size
             (fun f -> ("replay_window_size", (Integer.to_json f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f -> ("rekey_fuzz_percentage", (Integer.to_json f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f -> ("rekey_margin_time_seconds", (Integer.to_json f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f -> ("phase2_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f -> ("phase1_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.pre_shared_key
             (fun f -> ("pre_shared_key", (String.to_json f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> ("tunnel_inside_cidr", (String.to_json f)))])
    let parse xml =
      Some
        {
          tunnel_inside_cidr =
            (Util.option_bind (Xml.member "TunnelInsideCidr" xml)
               String.parse);
          pre_shared_key =
            (Util.option_bind (Xml.member "PreSharedKey" xml) String.parse);
          phase1_lifetime_seconds =
            (Util.option_bind (Xml.member "Phase1LifetimeSeconds" xml)
               Integer.parse);
          phase2_lifetime_seconds =
            (Util.option_bind (Xml.member "Phase2LifetimeSeconds" xml)
               Integer.parse);
          rekey_margin_time_seconds =
            (Util.option_bind (Xml.member "RekeyMarginTimeSeconds" xml)
               Integer.parse);
          rekey_fuzz_percentage =
            (Util.option_bind (Xml.member "RekeyFuzzPercentage" xml)
               Integer.parse);
          replay_window_size =
            (Util.option_bind (Xml.member "ReplayWindowSize" xml)
               Integer.parse);
          d_p_d_timeout_seconds =
            (Util.option_bind (Xml.member "DPDTimeoutSeconds" xml)
               Integer.parse);
          phase1_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1EncryptionAlgorithm" xml)
                  Phase1EncryptionAlgorithmsRequestList.parse));
          phase2_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2EncryptionAlgorithm" xml)
                  Phase2EncryptionAlgorithmsRequestList.parse));
          phase1_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1IntegrityAlgorithm" xml)
                  Phase1IntegrityAlgorithmsRequestList.parse));
          phase2_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2IntegrityAlgorithm" xml)
                  Phase2IntegrityAlgorithmsRequestList.parse));
          phase1_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1DHGroupNumber" xml)
                  Phase1DHGroupNumbersRequestList.parse));
          phase2_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2DHGroupNumber" xml)
                  Phase2DHGroupNumbersRequestList.parse));
          i_k_e_versions =
            (Util.of_option []
               (Util.option_bind (Xml.member "IKEVersion" xml)
                  IKEVersionsRequestList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Util.option_map v.tunnel_inside_cidr
                            (fun f ->
                               Ezxmlm.make_tag "TunnelInsideCidr"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.pre_shared_key
                           (fun f ->
                              Ezxmlm.make_tag "PreSharedKey"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.phase1_lifetime_seconds
                          (fun f ->
                             Ezxmlm.make_tag "Phase1LifetimeSeconds"
                               ([], (Integer.to_xml f)))])
                      @
                      [Util.option_map v.phase2_lifetime_seconds
                         (fun f ->
                            Ezxmlm.make_tag "Phase2LifetimeSeconds"
                              ([], (Integer.to_xml f)))])
                     @
                     [Util.option_map v.rekey_margin_time_seconds
                        (fun f ->
                           Ezxmlm.make_tag "RekeyMarginTimeSeconds"
                             ([], (Integer.to_xml f)))])
                    @
                    [Util.option_map v.rekey_fuzz_percentage
                       (fun f ->
                          Ezxmlm.make_tag "RekeyFuzzPercentage"
                            ([], (Integer.to_xml f)))])
                   @
                   [Util.option_map v.replay_window_size
                      (fun f ->
                         Ezxmlm.make_tag "ReplayWindowSize"
                           ([], (Integer.to_xml f)))])
                  @
                  [Util.option_map v.d_p_d_timeout_seconds
                     (fun f ->
                        Ezxmlm.make_tag "DPDTimeoutSeconds"
                          ([], (Integer.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "Phase1EncryptionAlgorithm"
                            ([],
                              (Phase1EncryptionAlgorithmsRequestList.to_xml
                                 [x])))) v.phase1_encryption_algorithms))
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "Phase2EncryptionAlgorithm"
                           ([],
                             (Phase2EncryptionAlgorithmsRequestList.to_xml
                                [x])))) v.phase2_encryption_algorithms))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Phase1IntegrityAlgorithm"
                          ([],
                            (Phase1IntegrityAlgorithmsRequestList.to_xml [x]))))
                  v.phase1_integrity_algorithms))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Phase2IntegrityAlgorithm"
                         ([],
                           (Phase2IntegrityAlgorithmsRequestList.to_xml [x]))))
                 v.phase2_integrity_algorithms))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Phase1DHGroupNumber"
                        ([], (Phase1DHGroupNumbersRequestList.to_xml [x]))))
                v.phase1_d_h_group_numbers))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Phase2DHGroupNumber"
                       ([], (Phase2DHGroupNumbersRequestList.to_xml [x]))))
               v.phase2_d_h_group_numbers))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "IKEVersion"
                      ([], (IKEVersionsRequestList.to_xml [x]))))
              v.i_k_e_versions))
  end[@@ocaml.doc
       "<p>The AWS Site-to-Site VPN tunnel options to modify.</p>"]
module TransitGatewayRouteTableList =
  struct
    type t = TransitGatewayRouteTable.t list
    let make elems () = elems
    let to_query v = Query.to_query_list TransitGatewayRouteTable.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayRouteTable.to_headers v
    let to_json v = `List (List.map TransitGatewayRouteTable.to_json v)
    let parse xml =
      Util.option_all
        (List.map TransitGatewayRouteTable.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (TransitGatewayRouteTable.to_xml x)))
        v
  end
module ClientData =
  struct
    type t =
      {
      comment: String.t option
        [@ocaml.doc "<p>A user-defined comment about the disk upload.</p>"];
      upload_end: DateTime.t option
        [@ocaml.doc "<p>The time that the disk upload ends.</p>"];
      upload_size: Double.t option
        [@ocaml.doc "<p>The size of the uploaded disk image, in GiB.</p>"];
      upload_start: DateTime.t option
        [@ocaml.doc "<p>The time that the disk upload starts.</p>"]}[@@ocaml.doc
                                                                    "<p>Describes the client-specific data.</p>"]
    let make ?comment  ?upload_end  ?upload_size  ?upload_start  () =
      { comment; upload_end; upload_size; upload_start }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.upload_start
              (fun f -> Query.Pair ("UploadStart", (DateTime.to_query f)));
           Util.option_map v.upload_size
             (fun f -> Query.Pair ("UploadSize", (Double.to_query f)));
           Util.option_map v.upload_end
             (fun f -> Query.Pair ("UploadEnd", (DateTime.to_query f)));
           Util.option_map v.comment
             (fun f -> Query.Pair ("Comment", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.upload_start
              (fun f -> ("upload_start", (DateTime.to_json f)));
           Util.option_map v.upload_size
             (fun f -> ("upload_size", (Double.to_json f)));
           Util.option_map v.upload_end
             (fun f -> ("upload_end", (DateTime.to_json f)));
           Util.option_map v.comment
             (fun f -> ("comment", (String.to_json f)))])
    let parse xml =
      Some
        {
          comment =
            (Util.option_bind (Xml.member "Comment" xml) String.parse);
          upload_end =
            (Util.option_bind (Xml.member "UploadEnd" xml) DateTime.parse);
          upload_size =
            (Util.option_bind (Xml.member "UploadSize" xml) Double.parse);
          upload_start =
            (Util.option_bind (Xml.member "UploadStart" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.comment
                 (fun f -> Ezxmlm.make_tag "Comment" ([], (String.to_xml f)))])
             @
             [Util.option_map v.upload_end
                (fun f ->
                   Ezxmlm.make_tag "UploadEnd" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.upload_size
               (fun f -> Ezxmlm.make_tag "UploadSize" ([], (Double.to_xml f)))])
           @
           [Util.option_map v.upload_start
              (fun f ->
                 Ezxmlm.make_tag "UploadStart" ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc "<p>Describes the client-specific data.</p>"]
module SnapshotDiskContainer =
  struct
    type t =
      {
      description: String.t option
        [@ocaml.doc
          "<p>The description of the disk image being imported.</p>"];
      format: String.t option
        [@ocaml.doc
          "<p>The format of the disk image being imported.</p> <p>Valid values: <code>VHD</code> | <code>VMDK</code> </p>"];
      url: String.t option
        [@ocaml.doc
          "<p>The URL to the Amazon S3-based disk image being imported. It can either be a https URL (https://..) or an Amazon S3 URL (s3://..).</p>"];
      user_bucket: UserBucket.t option
        [@ocaml.doc "<p>The S3 bucket for the disk image.</p>"]}[@@ocaml.doc
                                                                  "<p>The disk container object for the import snapshot request.</p>"]
    let make ?description  ?format  ?url  ?user_bucket  () =
      { description; format; url; user_bucket }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> Query.Pair ("UserBucket", (UserBucket.to_query f)));
           Util.option_map v.url
             (fun f -> Query.Pair ("Url", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> ("user_bucket", (UserBucket.to_json f)));
           Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.format (fun f -> ("format", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          format = (Util.option_bind (Xml.member "Format" xml) String.parse);
          url = (Util.option_bind (Xml.member "Url" xml) String.parse);
          user_bucket =
            (Util.option_bind (Xml.member "UserBucket" xml) UserBucket.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
             @
             [Util.option_map v.format
                (fun f -> Ezxmlm.make_tag "Format" ([], (String.to_xml f)))])
            @
            [Util.option_map v.url
               (fun f -> Ezxmlm.make_tag "Url" ([], (String.to_xml f)))])
           @
           [Util.option_map v.user_bucket
              (fun f ->
                 Ezxmlm.make_tag "UserBucket" ([], (UserBucket.to_xml f)))])
  end[@@ocaml.doc
       "<p>The disk container object for the import snapshot request.</p>"]
module TransitGatewayMulticastDeregisteredGroupMembers =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option
        [@ocaml.doc "<p>The ID of the transit gateway multicast domain.</p>"];
      deregistered_network_interface_ids: ValueStringList.t
        [@ocaml.doc
          "<p>The network interface IDs of the deregistered members.</p>"];
      group_ip_address: String.t option
        [@ocaml.doc
          "<p>The IP address assigned to the transit gateway multicast group.</p>"]}
    [@@ocaml.doc
      "<p>Describes the deregistered transit gateway multicast group members.</p>"]
    let make ?transit_gateway_multicast_domain_id 
      ?(deregistered_network_interface_ids= [])  ?group_ip_address  () =
      {
        transit_gateway_multicast_domain_id;
        deregistered_network_interface_ids;
        group_ip_address
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("DeregisteredNetworkInterfaceIds",
                  (ValueStringList.to_query
                     v.deregistered_network_interface_ids)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> ("group_ip_address", (String.to_json f)));
           Some
             ("deregistered_network_interface_ids",
               (ValueStringList.to_json v.deregistered_network_interface_ids));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          deregistered_network_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "deregisteredNetworkInterfaceIds" xml)
                  ValueStringList.parse));
          group_ip_address =
            (Util.option_bind (Xml.member "groupIpAddress" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.transit_gateway_multicast_domain_id
                (fun f ->
                   Ezxmlm.make_tag "transitGatewayMulticastDomainId"
                     ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "deregisteredNetworkInterfaceIds"
                       ([], (ValueStringList.to_xml [x]))))
               v.deregistered_network_interface_ids))
           @
           [Util.option_map v.group_ip_address
              (fun f ->
                 Ezxmlm.make_tag "groupIpAddress" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the deregistered transit gateway multicast group members.</p>"]
module AuthorizationRuleSet =
  struct
    type t = AuthorizationRule.t list
    let make elems () = elems
    let to_query v = Query.to_query_list AuthorizationRule.to_query v
    let to_headers v = Headers.to_headers_list AuthorizationRule.to_headers v
    let to_json v = `List (List.map AuthorizationRule.to_json v)
    let parse xml =
      Util.option_all
        (List.map AuthorizationRule.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (AuthorizationRule.to_xml x)))
        v
  end
module TransitGatewayMulticastDomainAssociationList =
  struct
    type t = TransitGatewayMulticastDomainAssociation.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list TransitGatewayMulticastDomainAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list
        TransitGatewayMulticastDomainAssociation.to_headers v
    let to_json v =
      `List (List.map TransitGatewayMulticastDomainAssociation.to_json v)
    let parse xml =
      Util.option_all
        (List.map TransitGatewayMulticastDomainAssociation.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayMulticastDomainAssociation.to_xml x))) v
  end
module TrafficMirrorSessionFieldList =
  struct
    type t = TrafficMirrorSessionField.t list
    let make elems () = elems
    let to_query v = Query.to_query_list TrafficMirrorSessionField.to_query v
    let to_headers v =
      Headers.to_headers_list TrafficMirrorSessionField.to_headers v
    let to_json v = `List (List.map TrafficMirrorSessionField.to_json v)
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorSessionField.parse (Xml.members "member" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TrafficMirrorSessionField.to_xml x))) v
  end
module SuccessfulInstanceCreditSpecificationSet =
  struct
    type t = SuccessfulInstanceCreditSpecificationItem.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list SuccessfulInstanceCreditSpecificationItem.to_query
        v
    let to_headers v =
      Headers.to_headers_list
        SuccessfulInstanceCreditSpecificationItem.to_headers v
    let to_json v =
      `List (List.map SuccessfulInstanceCreditSpecificationItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map SuccessfulInstanceCreditSpecificationItem.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (SuccessfulInstanceCreditSpecificationItem.to_xml x))) v
  end
module UnsuccessfulInstanceCreditSpecificationSet =
  struct
    type t = UnsuccessfulInstanceCreditSpecificationItem.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list
        UnsuccessfulInstanceCreditSpecificationItem.to_query v
    let to_headers v =
      Headers.to_headers_list
        UnsuccessfulInstanceCreditSpecificationItem.to_headers v
    let to_json v =
      `List (List.map UnsuccessfulInstanceCreditSpecificationItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map UnsuccessfulInstanceCreditSpecificationItem.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (UnsuccessfulInstanceCreditSpecificationItem.to_xml x))) v
  end
module ReservedInstancesOfferingList =
  struct
    type t = ReservedInstancesOffering.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ReservedInstancesOffering.to_query v
    let to_headers v =
      Headers.to_headers_list ReservedInstancesOffering.to_headers v
    let to_json v = `List (List.map ReservedInstancesOffering.to_json v)
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesOffering.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ReservedInstancesOffering.to_xml x))) v
  end
module ScheduledInstanceAvailabilitySet =
  struct
    type t = ScheduledInstanceAvailability.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list ScheduledInstanceAvailability.to_query v
    let to_headers v =
      Headers.to_headers_list ScheduledInstanceAvailability.to_headers v
    let to_json v = `List (List.map ScheduledInstanceAvailability.to_json v)
    let parse xml =
      Util.option_all
        (List.map ScheduledInstanceAvailability.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ScheduledInstanceAvailability.to_xml x))) v
  end
module ReservationList =
  struct
    type t = Reservation.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Reservation.to_query v
    let to_headers v = Headers.to_headers_list Reservation.to_headers v
    let to_json v = `List (List.map Reservation.to_json v)
    let parse xml =
      Util.option_all (List.map Reservation.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (Reservation.to_xml x))) v
  end
module LocalGatewayVirtualInterfaceGroupIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module PublicIpv4PoolSet =
  struct
    type t = PublicIpv4Pool.t list
    let make elems () = elems
    let to_query v = Query.to_query_list PublicIpv4Pool.to_query v
    let to_headers v = Headers.to_headers_list PublicIpv4Pool.to_headers v
    let to_json v = `List (List.map PublicIpv4Pool.to_json v)
    let parse xml =
      Util.option_all
        (List.map PublicIpv4Pool.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PublicIpv4Pool.to_xml x))) v
  end
module VpcList =
  struct
    type t = Vpc.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Vpc.to_query v
    let to_headers v = Headers.to_headers_list Vpc.to_headers v
    let to_json v = `List (List.map Vpc.to_json v)
    let parse xml =
      Util.option_all (List.map Vpc.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Vpc.to_xml x))) v
  end
module LocalGatewaySet =
  struct
    type t = LocalGateway.t list
    let make elems () = elems
    let to_query v = Query.to_query_list LocalGateway.to_query v
    let to_headers v = Headers.to_headers_list LocalGateway.to_headers v
    let to_json v = `List (List.map LocalGateway.to_json v)
    let parse xml =
      Util.option_all (List.map LocalGateway.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (LocalGateway.to_xml x))) v
  end
module SubnetList =
  struct
    type t = Subnet.t list
    let make elems () = elems
    let to_query v = Query.to_query_list Subnet.to_query v
    let to_headers v = Headers.to_headers_list Subnet.to_headers v
    let to_json v = `List (List.map Subnet.to_json v)
    let parse xml =
      Util.option_all (List.map Subnet.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Subnet.to_xml x))) v
  end
module ElasticGpuSet =
  struct
    type t = ElasticGpus.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ElasticGpus.to_query v
    let to_headers v = Headers.to_headers_list ElasticGpus.to_headers v
    let to_json v = `List (List.map ElasticGpus.to_json v)
    let parse xml =
      Util.option_all (List.map ElasticGpus.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ElasticGpus.to_xml x))) v
  end
module VpcClassicLinkList =
  struct
    type t = VpcClassicLink.t list
    let make elems () = elems
    let to_query v = Query.to_query_list VpcClassicLink.to_query v
    let to_headers v = Headers.to_headers_list VpcClassicLink.to_headers v
    let to_json v = `List (List.map VpcClassicLink.to_json v)
    let parse xml =
      Util.option_all
        (List.map VpcClassicLink.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VpcClassicLink.to_xml x))) v
  end
module ImportImageTaskList =
  struct
    type t = ImportImageTask.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ImportImageTask.to_query v
    let to_headers v = Headers.to_headers_list ImportImageTask.to_headers v
    let to_json v = `List (List.map ImportImageTask.to_json v)
    let parse xml =
      Util.option_all
        (List.map ImportImageTask.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ImportImageTask.to_xml x)))
        v
  end
module FlowLogsResourceType =
  struct
    type t =
      | VPC 
      | Subnet 
      | NetworkInterface 
    let str_to_t =
      [("NetworkInterface", NetworkInterface);
      ("Subnet", Subnet);
      ("VPC", VPC)]
    let t_to_str =
      [(NetworkInterface, "NetworkInterface");
      (Subnet, "Subnet");
      (VPC, "VPC")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module VpcTenancy =
  struct
    type t =
      | Default 
    let str_to_t = [("default", Default)]
    let t_to_str = [(Default, "default")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module FpgaImageIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module DhcpOptionsIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "DhcpOptionsId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module SpotPriceHistoryList =
  struct
    type t = SpotPrice.t list
    let make elems () = elems
    let to_query v = Query.to_query_list SpotPrice.to_query v
    let to_headers v = Headers.to_headers_list SpotPrice.to_headers v
    let to_json v = `List (List.map SpotPrice.to_json v)
    let parse xml =
      Util.option_all (List.map SpotPrice.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (SpotPrice.to_xml x)))
        v
  end
module ReasonCodesList =
  struct
    type t = ReportInstanceReasonCodes.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ReportInstanceReasonCodes.to_query v
    let to_headers v =
      Headers.to_headers_list ReportInstanceReasonCodes.to_headers v
    let to_json v = `List (List.map ReportInstanceReasonCodes.to_json v)
    let parse xml =
      Util.option_all
        (List.map ReportInstanceReasonCodes.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ReportInstanceReasonCodes.to_xml x))) v
  end
module ReportStatusType =
  struct
    type t =
      | Ok 
      | Impaired 
    let str_to_t = [("impaired", Impaired); ("ok", Ok)]
    let t_to_str = [(Impaired, "impaired"); (Ok, "ok")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module InstanceCreditSpecificationListRequest =
  struct
    type t = InstanceCreditSpecificationRequest.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list InstanceCreditSpecificationRequest.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceCreditSpecificationRequest.to_headers v
    let to_json v =
      `List (List.map InstanceCreditSpecificationRequest.to_json v)
    let parse xml =
      Util.option_all
        (List.map InstanceCreditSpecificationRequest.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InstanceCreditSpecificationRequest.to_xml x))) v
  end
module VersionStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module NetworkInterfaceCreationType =
  struct
    type t =
      | Efa 
    let str_to_t = [("efa", Efa)]
    let t_to_str = [(Efa, "efa")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
  end
module HostReservationIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module ScheduledInstanceRecurrenceRequest =
  struct
    type t =
      {
      frequency: String.t option
        [@ocaml.doc
          "<p>The frequency (<code>Daily</code>, <code>Weekly</code>, or <code>Monthly</code>).</p>"];
      interval: Integer.t option
        [@ocaml.doc
          "<p>The interval quantity. The interval unit depends on the value of <code>Frequency</code>. For example, every 2 weeks or every 2 months.</p>"];
      occurrence_days: OccurrenceDayRequestSet.t
        [@ocaml.doc
          "<p>The days. For a monthly schedule, this is one or more days of the month (1-31). For a weekly schedule, this is one or more days of the week (1-7, where 1 is Sunday). You can't specify this value with a daily schedule. If the occurrence is relative to the end of the month, you can specify only a single day.</p>"];
      occurrence_relative_to_end: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the occurrence is relative to the end of the specified week or month. You can't specify this value with a daily schedule.</p>"];
      occurrence_unit: String.t option
        [@ocaml.doc
          "<p>The unit for <code>OccurrenceDays</code> (<code>DayOfWeek</code> or <code>DayOfMonth</code>). This value is required for a monthly schedule. You can't specify <code>DayOfWeek</code> with a weekly schedule. You can't specify this value with a daily schedule.</p>"]}
    [@@ocaml.doc
      "<p>Describes the recurring schedule for a Scheduled Instance.</p>"]
    let make ?frequency  ?interval  ?(occurrence_days= []) 
      ?occurrence_relative_to_end  ?occurrence_unit  () =
      {
        frequency;
        interval;
        occurrence_days;
        occurrence_relative_to_end;
        occurrence_unit
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.occurrence_unit
              (fun f -> Query.Pair ("OccurrenceUnit", (String.to_query f)));
           Util.option_map v.occurrence_relative_to_end
             (fun f ->
                Query.Pair ("OccurrenceRelativeToEnd", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("OccurrenceDay",
                  (OccurrenceDayRequestSet.to_query v.occurrence_days)));
           Util.option_map v.interval
             (fun f -> Query.Pair ("Interval", (Integer.to_query f)));
           Util.option_map v.frequency
             (fun f -> Query.Pair ("Frequency", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.occurrence_unit
              (fun f -> ("occurrence_unit", (String.to_json f)));
           Util.option_map v.occurrence_relative_to_end
             (fun f -> ("occurrence_relative_to_end", (Boolean.to_json f)));
           Some
             ("occurrence_days",
               (OccurrenceDayRequestSet.to_json v.occurrence_days));
           Util.option_map v.interval
             (fun f -> ("interval", (Integer.to_json f)));
           Util.option_map v.frequency
             (fun f -> ("frequency", (String.to_json f)))])
    let parse xml =
      Some
        {
          frequency =
            (Util.option_bind (Xml.member "Frequency" xml) String.parse);
          interval =
            (Util.option_bind (Xml.member "Interval" xml) Integer.parse);
          occurrence_days =
            (Util.of_option []
               (Util.option_bind (Xml.member "OccurrenceDay" xml)
                  OccurrenceDayRequestSet.parse));
          occurrence_relative_to_end =
            (Util.option_bind (Xml.member "OccurrenceRelativeToEnd" xml)
               Boolean.parse);
          occurrence_unit =
            (Util.option_bind (Xml.member "OccurrenceUnit" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.frequency
                  (fun f ->
                     Ezxmlm.make_tag "Frequency" ([], (String.to_xml f)))])
              @
              [Util.option_map v.interval
                 (fun f ->
                    Ezxmlm.make_tag "Interval" ([], (Integer.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "OccurrenceDay"
                        ([], (OccurrenceDayRequestSet.to_xml [x]))))
                v.occurrence_days))
            @
            [Util.option_map v.occurrence_relative_to_end
               (fun f ->
                  Ezxmlm.make_tag "OccurrenceRelativeToEnd"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.occurrence_unit
              (fun f ->
                 Ezxmlm.make_tag "OccurrenceUnit" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the recurring schedule for a Scheduled Instance.</p>"]
module SlotDateTimeRangeRequest =
  struct
    type t =
      {
      earliest_time: DateTime.t
        [@ocaml.doc
          "<p>The earliest date and time, in UTC, for the Scheduled Instance to start.</p>"];
      latest_time: DateTime.t
        [@ocaml.doc
          "<p>The latest date and time, in UTC, for the Scheduled Instance to start. This value must be later than or equal to the earliest date and at most three months in the future.</p>"]}
    [@@ocaml.doc
      "<p>Describes the time period for a Scheduled Instance to start its first schedule. The time period must span less than one day.</p>"]
    let make ~earliest_time  ~latest_time  () =
      { earliest_time; latest_time }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("LatestTime", (DateTime.to_query v.latest_time)));
           Some
             (Query.Pair
                ("EarliestTime", (DateTime.to_query v.earliest_time)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("latest_time", (DateTime.to_json v.latest_time));
           Some ("earliest_time", (DateTime.to_json v.earliest_time))])
    let parse xml =
      Some
        {
          earliest_time =
            (Xml.required "EarliestTime"
               (Util.option_bind (Xml.member "EarliestTime" xml)
                  DateTime.parse));
          latest_time =
            (Xml.required "LatestTime"
               (Util.option_bind (Xml.member "LatestTime" xml) DateTime.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "EarliestTime"
                  ([], (DateTime.to_xml v.earliest_time)))])
           @
           [Some
              (Ezxmlm.make_tag "LatestTime"
                 ([], (DateTime.to_xml v.latest_time)))])
  end[@@ocaml.doc
       "<p>Describes the time period for a Scheduled Instance to start its first schedule. The time period must span less than one day.</p>"]
module ImageDiskContainerList =
  struct
    type t = ImageDiskContainer.t list
    let make elems () = elems
    let to_query v = Query.to_query_list ImageDiskContainer.to_query v
    let to_headers v =
      Headers.to_headers_list ImageDiskContainer.to_headers v
    let to_json v = `List (List.map ImageDiskContainer.to_json v)
    let parse xml =
      Util.option_all
        (List.map ImageDiskContainer.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ImageDiskContainer.to_xml x))) v
  end
module ImportImageLicenseSpecificationListRequest =
  struct
    type t = ImportImageLicenseConfigurationRequest.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list ImportImageLicenseConfigurationRequest.to_query v
    let to_headers v =
      Headers.to_headers_list
        ImportImageLicenseConfigurationRequest.to_headers v
    let to_json v =
      `List (List.map ImportImageLicenseConfigurationRequest.to_json v)
    let parse xml =
      Util.option_all
        (List.map ImportImageLicenseConfigurationRequest.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ImportImageLicenseConfigurationRequest.to_xml x))) v
  end
module LocalGatewayRouteList =
  struct
    type t = LocalGatewayRoute.t list
    let make elems () = elems
    let to_query v = Query.to_query_list LocalGatewayRoute.to_query v
    let to_headers v = Headers.to_headers_list LocalGatewayRoute.to_headers v
    let to_json v = `List (List.map LocalGatewayRoute.to_json v)
    let parse xml =
      Util.option_all
        (List.map LocalGatewayRoute.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (LocalGatewayRoute.to_xml x)))
        v
  end
module ScheduledInstancesLaunchSpecification =
  struct
    type t =
      {
      block_device_mappings: ScheduledInstancesBlockDeviceMappingSet.t
        [@ocaml.doc "<p>The block device mapping entries.</p>"];
      ebs_optimized: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.</p> <p>Default: <code>false</code> </p>"];
      iam_instance_profile: ScheduledInstancesIamInstanceProfile.t option
        [@ocaml.doc "<p>The IAM instance profile.</p>"];
      image_id: String.t
        [@ocaml.doc "<p>The ID of the Amazon Machine Image (AMI).</p>"];
      instance_type: String.t option [@ocaml.doc "<p>The instance type.</p>"];
      kernel_id: String.t option [@ocaml.doc "<p>The ID of the kernel.</p>"];
      key_name: String.t option
        [@ocaml.doc "<p>The name of the key pair.</p>"];
      monitoring: ScheduledInstancesMonitoring.t option
        [@ocaml.doc "<p>Enable or disable monitoring for the instances.</p>"];
      network_interfaces: ScheduledInstancesNetworkInterfaceSet.t
        [@ocaml.doc "<p>The network interfaces.</p>"];
      placement: ScheduledInstancesPlacement.t option
        [@ocaml.doc "<p>The placement information.</p>"];
      ramdisk_id: String.t option
        [@ocaml.doc "<p>The ID of the RAM disk.</p>"];
      security_group_ids: ScheduledInstancesSecurityGroupIdSet.t
        [@ocaml.doc "<p>The IDs of the security groups.</p>"];
      subnet_id: String.t option
        [@ocaml.doc
          "<p>The ID of the subnet in which to launch the instances.</p>"];
      user_data: String.t option
        [@ocaml.doc "<p>The base64-encoded MIME user data.</p>"]}[@@ocaml.doc
                                                                   "<p>Describes the launch specification for a Scheduled Instance.</p> <p>If you are launching the Scheduled Instance in EC2-VPC, you must specify the ID of the subnet. You can specify the subnet using either <code>SubnetId</code> or <code>NetworkInterface</code>.</p>"]
    let make ?(block_device_mappings= [])  ?ebs_optimized 
      ?iam_instance_profile  ~image_id  ?instance_type  ?kernel_id  ?key_name
       ?monitoring  ?(network_interfaces= [])  ?placement  ?ramdisk_id 
      ?(security_group_ids= [])  ?subnet_id  ?user_data  () =
      {
        block_device_mappings;
        ebs_optimized;
        iam_instance_profile;
        image_id;
        instance_type;
        kernel_id;
        key_name;
        monitoring;
        network_interfaces;
        placement;
        ramdisk_id;
        security_group_ids;
        subnet_id;
        user_data
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (ScheduledInstancesSecurityGroupIdSet.to_query
                     v.security_group_ids)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f ->
                Query.Pair
                  ("Placement", (ScheduledInstancesPlacement.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterface",
                  (ScheduledInstancesNetworkInterfaceSet.to_query
                     v.network_interfaces)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair
                  ("Monitoring", (ScheduledInstancesMonitoring.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (ScheduledInstancesIamInstanceProfile.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (ScheduledInstancesBlockDeviceMappingSet.to_query
                     v.block_device_mappings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Some
             ("security_group_ids",
               (ScheduledInstancesSecurityGroupIdSet.to_json
                  v.security_group_ids));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (ScheduledInstancesPlacement.to_json f)));
           Some
             ("network_interfaces",
               (ScheduledInstancesNetworkInterfaceSet.to_json
                  v.network_interfaces));
           Util.option_map v.monitoring
             (fun f ->
                ("monitoring", (ScheduledInstancesMonitoring.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Some ("image_id", (String.to_json v.image_id));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (ScheduledInstancesIamInstanceProfile.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Some
             ("block_device_mappings",
               (ScheduledInstancesBlockDeviceMappingSet.to_json
                  v.block_device_mappings))])
    let parse xml =
      Some
        {
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "BlockDeviceMapping" xml)
                  ScheduledInstancesBlockDeviceMappingSet.parse));
          ebs_optimized =
            (Util.option_bind (Xml.member "EbsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "IamInstanceProfile" xml)
               ScheduledInstancesIamInstanceProfile.parse);
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml) String.parse);
          kernel_id =
            (Util.option_bind (Xml.member "KernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "KeyName" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "Monitoring" xml)
               ScheduledInstancesMonitoring.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterface" xml)
                  ScheduledInstancesNetworkInterfaceSet.parse));
          placement =
            (Util.option_bind (Xml.member "Placement" xml)
               ScheduledInstancesPlacement.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "RamdiskId" xml) String.parse);
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  ScheduledInstancesSecurityGroupIdSet.parse));
          subnet_id =
            (Util.option_bind (Xml.member "SubnetId" xml) String.parse);
          user_data =
            (Util.option_bind (Xml.member "UserData" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        (List.map
                           (fun x ->
                              Some
                                (Ezxmlm.make_tag "BlockDeviceMapping"
                                   ([],
                                     (ScheduledInstancesBlockDeviceMappingSet.to_xml
                                        [x])))) v.block_device_mappings))
                       @
                       [Util.option_map v.ebs_optimized
                          (fun f ->
                             Ezxmlm.make_tag "EbsOptimized"
                               ([], (Boolean.to_xml f)))])
                      @
                      [Util.option_map v.iam_instance_profile
                         (fun f ->
                            Ezxmlm.make_tag "IamInstanceProfile"
                              ([],
                                (ScheduledInstancesIamInstanceProfile.to_xml
                                   f)))])
                     @
                     [Some
                        (Ezxmlm.make_tag "ImageId"
                           ([], (String.to_xml v.image_id)))])
                    @
                    [Util.option_map v.instance_type
                       (fun f ->
                          Ezxmlm.make_tag "InstanceType"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.kernel_id
                      (fun f ->
                         Ezxmlm.make_tag "KernelId" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.key_name
                     (fun f ->
                        Ezxmlm.make_tag "KeyName" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.monitoring
                    (fun f ->
                       Ezxmlm.make_tag "Monitoring"
                         ([], (ScheduledInstancesMonitoring.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "NetworkInterface"
                           ([],
                             (ScheduledInstancesNetworkInterfaceSet.to_xml
                                [x])))) v.network_interfaces))
               @
               [Util.option_map v.placement
                  (fun f ->
                     Ezxmlm.make_tag "Placement"
                       ([], (ScheduledInstancesPlacement.to_xml f)))])
              @
              [Util.option_map v.ramdisk_id
                 (fun f ->
                    Ezxmlm.make_tag "RamdiskId" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "SecurityGroupId"
                        ([],
                          (ScheduledInstancesSecurityGroupIdSet.to_xml [x]))))
                v.security_group_ids))
            @
            [Util.option_map v.subnet_id
               (fun f -> Ezxmlm.make_tag "SubnetId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.user_data
              (fun f -> Ezxmlm.make_tag "UserData" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the launch specification for a Scheduled Instance.</p> <p>If you are launching the Scheduled Instance in EC2-VPC, you must specify the ID of the subnet. You can specify the subnet using either <code>SubnetId</code> or <code>NetworkInterface</code>.</p>"]
module ExportImageTaskIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_json v = `List (List.map String.to_json v)
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ExportImageTaskId" xml))
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
  end
module NatGatewayList =
  struct
    type t = NatGateway.t list
    let make elems () = elems
    let to_query v = Query.to_query_list NatGateway.to_query v
    let to_headers v = Headers.to_headers_list NatGateway.to_headers v
    let to_json v = `List (List.map NatGateway.to_json v)
    let parse xml =
      Util.option_all (List.map NatGateway.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (NatGateway.to_xml x))) v
  end
module InstanceUsageSet =
  struct
    type t = InstanceUsage.t list
    let make elems () = elems
    let to_query v = Query.to_query_list InstanceUsage.to_query v
    let to_headers v = Headers.to_headers_list InstanceUsage.to_headers v
    let to_json v = `List (List.map InstanceUsage.to_json v)
    let parse xml =
      Util.option_all (List.map InstanceUsage.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InstanceUsage.to_xml x))) v
  end
module DescribeFastSnapshotRestoreSuccessSet =
  struct
    type t = DescribeFastSnapshotRestoreSuccessItem.t list
    let make elems () = elems
    let to_query v =
      Query.to_query_list DescribeFastSnapshotRestoreSuccessItem.to_query v
    let to_headers v =
      Headers.to_headers_list
        DescribeFastSnapshotRestoreSuccessItem.to_headers v
    let to_json v =
      `List (List.map DescribeFastSnapshotRestoreSuccessItem.to_json v)
    let parse xml =
      Util.option_all
        (List.map DescribeFastSnapshotRestoreSuccessItem.parse
           (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (DescribeFastSnapshotRestoreSuccessItem.to_xml x))) v
  end
module ReservedInstanceLimitPrice =
  struct
    type t =
      {
      amount: Double.t option
        [@ocaml.doc
          "<p>Used for Reserved Instance Marketplace offerings. Specifies the limit price on the total order (instanceCount * price).</p>"];
      currency_code: CurrencyCodeValues.t option
        [@ocaml.doc
          "<p>The currency in which the <code>limitPrice</code> amount is specified. At this time, the only supported currency is <code>USD</code>.</p>"]}
    [@@ocaml.doc
      "<p>Describes the limit price of a Reserved Instance offering.</p>"]
    let make ?amount  ?currency_code  () = { amount; currency_code }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.currency_code
              (fun f ->
                 Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.amount
             (fun f -> Query.Pair ("Amount", (Double.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.currency_code
              (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.amount (fun f -> ("amount", (Double.to_json f)))])
    let parse xml =
      Some
        {
          amount = (Util.option_bind (Xml.member "amount" xml) Double.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.amount
               (fun f -> Ezxmlm.make_tag "amount" ([], (Double.to_xml f)))])
           @
           [Util.option_map v.currency_code
              (fun f ->
                 Ezxmlm.make_tag "currencyCode"
                   ([], (CurrencyCodeValues.to_xml f)))])
  end[@@ocaml.doc
       "<p>Describes the limit price of a Reserved Instance offering.</p>"]
module EgressOnlyInternetGatewayList =
  struct
    type t = EgressOnlyInternetGateway.t list
    let make elems () = elems
    let to_query v = Query.to_query_list EgressOnlyInternetGateway.to_query v
    let to_headers v =
      Headers.to_headers_list EgressOnlyInternetGateway.to_headers v
    let to_json v = `List (List.map EgressOnlyInternetGateway.to_json v)
    let parse xml =
      Util.option_all
        (List.map EgressOnlyInternetGateway.parse (Xml.members "item" xml))
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (EgressOnlyInternetGateway.to_xml x))) v
  end
module LoadPermissionModifications =
  struct
    type t =
      {
      add: LoadPermissionListRequest.t
        [@ocaml.doc "<p>The load permissions to add.</p>"];
      remove: LoadPermissionListRequest.t
        [@ocaml.doc "<p>The load permissions to remove.</p>"]}[@@ocaml.doc
                                                                "<p>Describes modifications to the load permissions of an Amazon FPGA image (AFI).</p>"]
    let make ?(add= [])  ?(remove= [])  () = { add; remove }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Remove", (LoadPermissionListRequest.to_query v.remove)));
           Some
             (Query.Pair ("Add", (LoadPermissionListRequest.to_query v.add)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("remove", (LoadPermissionListRequest.to_json v.remove));
           Some ("add", (LoadPermissionListRequest.to_json v.add))])
    let parse xml =
      Some
        {
          add =
            (Util.of_option []
               (Util.option_bind (Xml.member "Add" xml)
                  LoadPermissionListRequest.parse));
          remove =
            (Util.of_option []
               (Util.option_bind (Xml.member "Remove" xml)
                  LoadPermissionListRequest.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Add"
                       ([], (LoadPermissionListRequest.to_xml [x])))) v.add))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Remove"
                      ([], (LoadPermissionListRequest.to_xml [x])))) v.remove))
  end[@@ocaml.doc
       "<p>Describes modifications to the load permissions of an Amazon FPGA image (AFI).</p>"]
module CreateTrafficMirrorFilterResult =
  struct
    type t =
      {
      traffic_mirror_filter: TrafficMirrorFilter.t option
        [@ocaml.doc "<p>Information about the Traffic Mirror filter.</p>"];
      client_token: String.t option
        [@ocaml.doc
          "<p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html\">How to Ensure Idempotency</a>.</p>"]}
    let make ?traffic_mirror_filter  ?client_token  () =
      { traffic_mirror_filter; client_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.traffic_mirror_filter
             (fun f ->
                Query.Pair
                  ("TrafficMirrorFilter", (TrafficMirrorFilter.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.traffic_mirror_filter
             (fun f ->
                ("traffic_mirror_filter", (TrafficMirrorFilter.to_json f)))])
    let parse xml =
      Some
        {
          traffic_mirror_filter =
            (Util.option_bind (Xml.member "trafficMirrorFilter" xml)
               TrafficMirrorFilter.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.traffic_mirror_filter
               (fun f ->
                  Ezxmlm.make_tag "trafficMirrorFilter"
                    ([], (TrafficMirrorFilter.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
  end
module DescribeTagsResult =
  struct
    type t =
      {
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"];
      tags: TagDescriptionList.t [@ocaml.doc "<p>The tags.</p>"]}
    let make ?next_token  ?(tags= [])  () = { next_token; tags }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("TagSet", (TagDescriptionList.to_query v.tags)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagDescriptionList.to_json v.tags));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml)
                  TagDescriptionList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "tagSet"
                      ([], (TagDescriptionList.to_xml [x])))) v.tags))
  end
module DescribeDhcpOptionsResult =
  struct
    type t =
      {
      dhcp_options: DhcpOptionsList.t
        [@ocaml.doc
          "<p>Information about one or more DHCP options sets.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(dhcp_options= [])  ?next_token  () =
      { dhcp_options; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("DhcpOptionsSet", (DhcpOptionsList.to_query v.dhcp_options)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("dhcp_options", (DhcpOptionsList.to_json v.dhcp_options))])
    let parse xml =
      Some
        {
          dhcp_options =
            (Util.of_option []
               (Util.option_bind (Xml.member "dhcpOptionsSet" xml)
                  DhcpOptionsList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "dhcpOptionsSet"
                       ([], (DhcpOptionsList.to_xml [x])))) v.dhcp_options))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeVpnGatewaysResult =
  struct
    type t =
      {
      vpn_gateways: VpnGatewayList.t
        [@ocaml.doc
          "<p>Information about one or more virtual private gateways.</p>"]}
    [@@ocaml.doc "<p>Contains the output of DescribeVpnGateways.</p>"]
    let make ?(vpn_gateways= [])  () = { vpn_gateways }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpnGatewaySet", (VpnGatewayList.to_query v.vpn_gateways)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpn_gateways", (VpnGatewayList.to_json v.vpn_gateways))])
    let parse xml =
      Some
        {
          vpn_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpnGatewaySet" xml)
                  VpnGatewayList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "vpnGatewaySet"
                      ([], (VpnGatewayList.to_xml [x])))) v.vpn_gateways))
  end[@@ocaml.doc "<p>Contains the output of DescribeVpnGateways.</p>"]
module GetTransitGatewayAttachmentPropagationsResult =
  struct
    type t =
      {
      transit_gateway_attachment_propagations:
        TransitGatewayAttachmentPropagationList.t
        [@ocaml.doc "<p>Information about the propagation route tables.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(transit_gateway_attachment_propagations= [])  ?next_token  ()
      = { transit_gateway_attachment_propagations; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentPropagations",
                  (TransitGatewayAttachmentPropagationList.to_query
                     v.transit_gateway_attachment_propagations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_attachment_propagations",
               (TransitGatewayAttachmentPropagationList.to_json
                  v.transit_gateway_attachment_propagations))])
    let parse xml =
      Some
        {
          transit_gateway_attachment_propagations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "transitGatewayAttachmentPropagations" xml)
                  TransitGatewayAttachmentPropagationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "transitGatewayAttachmentPropagations"
                       ([],
                         (TransitGatewayAttachmentPropagationList.to_xml [x]))))
               v.transit_gateway_attachment_propagations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeCapacityReservationsResult =
  struct
    type t =
      {
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"];
      capacity_reservations: CapacityReservationSet.t
        [@ocaml.doc "<p>Information about the Capacity Reservations.</p>"]}
    let make ?next_token  ?(capacity_reservations= [])  () =
      { next_token; capacity_reservations }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("CapacityReservationSet",
                   (CapacityReservationSet.to_query v.capacity_reservations)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("capacity_reservations",
                (CapacityReservationSet.to_json v.capacity_reservations));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          capacity_reservations =
            (Util.of_option []
               (Util.option_bind (Xml.member "capacityReservationSet" xml)
                  CapacityReservationSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "capacityReservationSet"
                      ([], (CapacityReservationSet.to_xml [x]))))
              v.capacity_reservations))
  end
module DescribeReservedInstancesModificationsResult =
  struct
    type t =
      {
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"];
      reserved_instances_modifications: ReservedInstancesModificationList.t
        [@ocaml.doc "<p>The Reserved Instance modification information.</p>"]}
    [@@ocaml.doc
      "<p>Contains the output of DescribeReservedInstancesModifications.</p>"]
    let make ?next_token  ?(reserved_instances_modifications= [])  () =
      { next_token; reserved_instances_modifications }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesModificationsSet",
                   (ReservedInstancesModificationList.to_query
                      v.reserved_instances_modifications)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_modifications",
                (ReservedInstancesModificationList.to_json
                   v.reserved_instances_modifications));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          reserved_instances_modifications =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesModificationsSet" xml)
                  ReservedInstancesModificationList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "reservedInstancesModificationsSet"
                      ([], (ReservedInstancesModificationList.to_xml [x]))))
              v.reserved_instances_modifications))
  end[@@ocaml.doc
       "<p>Contains the output of DescribeReservedInstancesModifications.</p>"]
module DescribePlacementGroupsResult =
  struct
    type t =
      {
      placement_groups: PlacementGroupList.t
        [@ocaml.doc "<p>Information about the placement groups.</p>"]}
    let make ?(placement_groups= [])  () = { placement_groups }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PlacementGroupSet",
                   (PlacementGroupList.to_query v.placement_groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("placement_groups",
                (PlacementGroupList.to_json v.placement_groups))])
    let parse xml =
      Some
        {
          placement_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "placementGroupSet" xml)
                  PlacementGroupList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "placementGroupSet"
                      ([], (PlacementGroupList.to_xml [x]))))
              v.placement_groups))
  end
module GetTransitGatewayRouteTablePropagationsResult =
  struct
    type t =
      {
      transit_gateway_route_table_propagations:
        TransitGatewayRouteTablePropagationList.t
        [@ocaml.doc "<p>Information about the route table propagations.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(transit_gateway_route_table_propagations= [])  ?next_token  ()
      = { transit_gateway_route_table_propagations; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTablePropagations",
                  (TransitGatewayRouteTablePropagationList.to_query
                     v.transit_gateway_route_table_propagations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_route_table_propagations",
               (TransitGatewayRouteTablePropagationList.to_json
                  v.transit_gateway_route_table_propagations))])
    let parse xml =
      Some
        {
          transit_gateway_route_table_propagations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "transitGatewayRouteTablePropagations" xml)
                  TransitGatewayRouteTablePropagationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "transitGatewayRouteTablePropagations"
                       ([],
                         (TransitGatewayRouteTablePropagationList.to_xml [x]))))
               v.transit_gateway_route_table_propagations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeKeyPairsResult =
  struct
    type t =
      {
      key_pairs: KeyPairList.t
        [@ocaml.doc "<p>Information about the key pairs.</p>"]}
    let make ?(key_pairs= [])  () = { key_pairs }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("KeySet", (KeyPairList.to_query v.key_pairs)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("key_pairs", (KeyPairList.to_json v.key_pairs))])
    let parse xml =
      Some
        {
          key_pairs =
            (Util.of_option []
               (Util.option_bind (Xml.member "keySet" xml) KeyPairList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "keySet" ([], (KeyPairList.to_xml [x]))))
              v.key_pairs))
  end
module CreateLaunchTemplateResult =
  struct
    type t =
      {
      launch_template: LaunchTemplate.t option
        [@ocaml.doc "<p>Information about the launch template.</p>"]}
    let make ?launch_template  () = { launch_template }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template
              (fun f ->
                 Query.Pair ("LaunchTemplate", (LaunchTemplate.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template
              (fun f -> ("launch_template", (LaunchTemplate.to_json f)))])
    let parse xml =
      Some
        {
          launch_template =
            (Util.option_bind (Xml.member "launchTemplate" xml)
               LaunchTemplate.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.launch_template
              (fun f ->
                 Ezxmlm.make_tag "launchTemplate"
                   ([], (LaunchTemplate.to_xml f)))])
  end
module DescribeFleetHistoryResult =
  struct
    type t =
      {
      history_records: HistoryRecordSet.t
        [@ocaml.doc
          "<p>Information about the events in the history of the EC2 Fleet.</p>"];
      last_evaluated_time: DateTime.t option
        [@ocaml.doc
          "<p>The last date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). All records up to this time were retrieved.</p> <p>If <code>nextToken</code> indicates that there are more results, this value is not present.</p>"];
      next_token: String.t option
        [@ocaml.doc "<p>The token for the next set of results.</p>"];
      fleet_id: String.t option [@ocaml.doc "<p>The ID of the EC Fleet.</p>"];
      start_time: DateTime.t option
        [@ocaml.doc
          "<p>The start date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>"]}
    let make ?(history_records= [])  ?last_evaluated_time  ?next_token 
      ?fleet_id  ?start_time  () =
      {
        history_records;
        last_evaluated_time;
        next_token;
        fleet_id;
        start_time
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.start_time
              (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Util.option_map v.fleet_id
             (fun f -> Query.Pair ("FleetId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.last_evaluated_time
             (fun f ->
                Query.Pair ("LastEvaluatedTime", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("HistoryRecordSet",
                  (HistoryRecordSet.to_query v.history_records)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.start_time
              (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.fleet_id
             (fun f -> ("fleet_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.last_evaluated_time
             (fun f -> ("last_evaluated_time", (DateTime.to_json f)));
           Some
             ("history_records",
               (HistoryRecordSet.to_json v.history_records))])
    let parse xml =
      Some
        {
          history_records =
            (Util.of_option []
               (Util.option_bind (Xml.member "historyRecordSet" xml)
                  HistoryRecordSet.parse));
          last_evaluated_time =
            (Util.option_bind (Xml.member "lastEvaluatedTime" xml)
               DateTime.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse);
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "historyRecordSet"
                          ([], (HistoryRecordSet.to_xml [x]))))
                  v.history_records))
              @
              [Util.option_map v.last_evaluated_time
                 (fun f ->
                    Ezxmlm.make_tag "lastEvaluatedTime"
                      ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
            @
            [Util.option_map v.fleet_id
               (fun f -> Ezxmlm.make_tag "fleetId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.start_time
              (fun f -> Ezxmlm.make_tag "startTime" ([], (DateTime.to_xml f)))])
  end
module DescribeHostReservationsResult =
  struct
    type t =
      {
      host_reservation_set: HostReservationSet.t
        [@ocaml.doc "<p>Details about the reservation's configuration.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(host_reservation_set= [])  ?next_token  () =
      { host_reservation_set; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("HostReservationSet",
                  (HostReservationSet.to_query v.host_reservation_set)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("host_reservation_set",
               (HostReservationSet.to_json v.host_reservation_set))])
    let parse xml =
      Some
        {
          host_reservation_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostReservationSet" xml)
                  HostReservationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "hostReservationSet"
                       ([], (HostReservationSet.to_xml [x]))))
               v.host_reservation_set))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeVpcEndpointConnectionsResult =
  struct
    type t =
      {
      vpc_endpoint_connections: VpcEndpointConnectionSet.t
        [@ocaml.doc
          "<p>Information about one or more VPC endpoint connections.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(vpc_endpoint_connections= [])  ?next_token  () =
      { vpc_endpoint_connections; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("VpcEndpointConnectionSet",
                  (VpcEndpointConnectionSet.to_query
                     v.vpc_endpoint_connections)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("vpc_endpoint_connections",
               (VpcEndpointConnectionSet.to_json v.vpc_endpoint_connections))])
    let parse xml =
      Some
        {
          vpc_endpoint_connections =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcEndpointConnectionSet" xml)
                  VpcEndpointConnectionSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "vpcEndpointConnectionSet"
                       ([], (VpcEndpointConnectionSet.to_xml [x]))))
               v.vpc_endpoint_connections))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module AssociateAddressResult =
  struct
    type t =
      {
      association_id: String.t option
        [@ocaml.doc
          "<p>[EC2-VPC] The ID that represents the association of the Elastic IP address with an instance.</p>"]}
    let make ?association_id  () = { association_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association_id
              (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_id
              (fun f -> ("association_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.association_id
              (fun f ->
                 Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
  end
module DescribeExportImageTasksResult =
  struct
    type t =
      {
      export_image_tasks: ExportImageTaskList.t
        [@ocaml.doc "<p>Information about the export image tasks.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to get the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(export_image_tasks= [])  ?next_token  () =
      { export_image_tasks; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ExportImageTaskSet",
                  (ExportImageTaskList.to_query v.export_image_tasks)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("export_image_tasks",
               (ExportImageTaskList.to_json v.export_image_tasks))])
    let parse xml =
      Some
        {
          export_image_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "exportImageTaskSet" xml)
                  ExportImageTaskList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "exportImageTaskSet"
                       ([], (ExportImageTaskList.to_xml [x]))))
               v.export_image_tasks))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module CreateFlowLogsResult =
  struct
    type t =
      {
      client_token: String.t option
        [@ocaml.doc
          "<p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>"];
      flow_log_ids: ValueStringList.t
        [@ocaml.doc "<p>The IDs of the flow logs.</p>"];
      unsuccessful: UnsuccessfulItemSet.t
        [@ocaml.doc
          "<p>Information about the flow logs that could not be created successfully.</p>"]}
    let make ?client_token  ?(flow_log_ids= [])  ?(unsuccessful= [])  () =
      { client_token; flow_log_ids; unsuccessful }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)));
           Some
             (Query.Pair
                ("FlowLogIdSet", (ValueStringList.to_query v.flow_log_ids)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful));
           Some ("flow_log_ids", (ValueStringList.to_json v.flow_log_ids));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          flow_log_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "flowLogIdSet" xml)
                  ValueStringList.parse));
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.client_token
                (fun f ->
                   Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "flowLogIdSet"
                       ([], (ValueStringList.to_xml [x])))) v.flow_log_ids))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemSet.to_xml [x])))) v.unsuccessful))
  end
module CreateNetworkInterfaceResult =
  struct
    type t =
      {
      network_interface: NetworkInterface.t option
        [@ocaml.doc "<p>Information about the network interface.</p>"]}
    [@@ocaml.doc "<p>Contains the output of CreateNetworkInterface.</p>"]
    let make ?network_interface  () = { network_interface }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_interface
              (fun f ->
                 Query.Pair
                   ("NetworkInterface", (NetworkInterface.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_interface
              (fun f -> ("network_interface", (NetworkInterface.to_json f)))])
    let parse xml =
      Some
        {
          network_interface =
            (Util.option_bind (Xml.member "networkInterface" xml)
               NetworkInterface.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.network_interface
              (fun f ->
                 Ezxmlm.make_tag "networkInterface"
                   ([], (NetworkInterface.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of CreateNetworkInterface.</p>"]
module RestoreAddressToClassicResult =
  struct
    type t =
      {
      public_ip: String.t option
        [@ocaml.doc "<p>The Elastic IP address.</p>"];
      status: Status.t option
        [@ocaml.doc "<p>The move status for the IP address.</p>"]}
    let make ?public_ip  ?status  () = { public_ip; status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (Status.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (Status.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)))])
    let parse xml =
      Some
        {
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) Status.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.public_ip
               (fun f -> Ezxmlm.make_tag "publicIp" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f -> Ezxmlm.make_tag "status" ([], (Status.to_xml f)))])
  end
module DescribeTrafficMirrorFiltersResult =
  struct
    type t =
      {
      traffic_mirror_filters: TrafficMirrorFilterSet.t
        [@ocaml.doc
          "<p>Information about one or more Traffic Mirror filters.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. The value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(traffic_mirror_filters= [])  ?next_token  () =
      { traffic_mirror_filters; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterSet",
                  (TrafficMirrorFilterSet.to_query v.traffic_mirror_filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("traffic_mirror_filters",
               (TrafficMirrorFilterSet.to_json v.traffic_mirror_filters))])
    let parse xml =
      Some
        {
          traffic_mirror_filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "trafficMirrorFilterSet" xml)
                  TrafficMirrorFilterSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "trafficMirrorFilterSet"
                       ([], (TrafficMirrorFilterSet.to_xml [x]))))
               v.traffic_mirror_filters))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module ReplaceNetworkAclAssociationResult =
  struct
    type t =
      {
      new_association_id: String.t option
        [@ocaml.doc "<p>The ID of the new association.</p>"]}
    let make ?new_association_id  () = { new_association_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.new_association_id
              (fun f -> Query.Pair ("NewAssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.new_association_id
              (fun f -> ("new_association_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          new_association_id =
            (Util.option_bind (Xml.member "newAssociationId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.new_association_id
              (fun f ->
                 Ezxmlm.make_tag "newAssociationId" ([], (String.to_xml f)))])
  end
module AttachClassicLinkVpcResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module DescribeTransitGatewaysResult =
  struct
    type t =
      {
      transit_gateways: TransitGatewayList.t
        [@ocaml.doc "<p>Information about the transit gateways.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(transit_gateways= [])  ?next_token  () =
      { transit_gateways; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewaySet",
                  (TransitGatewayList.to_query v.transit_gateways)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateways",
               (TransitGatewayList.to_json v.transit_gateways))])
    let parse xml =
      Some
        {
          transit_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "transitGatewaySet" xml)
                  TransitGatewayList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "transitGatewaySet"
                       ([], (TransitGatewayList.to_xml [x]))))
               v.transit_gateways))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module ModifyVpcEndpointServiceConfigurationResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module CopyImageResult =
  struct
    type t =
      {
      image_id: String.t option [@ocaml.doc "<p>The ID of the new AMI.</p>"]}
    [@@ocaml.doc "<p>Contains the output of CopyImage.</p>"]
    let make ?image_id  () = { image_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> Query.Pair ("ImageId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> ("image_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.image_id
              (fun f -> Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of CopyImage.</p>"]
module CreateInstanceExportTaskResult =
  struct
    type t =
      {
      export_task: ExportTask.t option
        [@ocaml.doc "<p>Information about the instance export task.</p>"]}
    let make ?export_task  () = { export_task }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.export_task
              (fun f -> Query.Pair ("ExportTask", (ExportTask.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.export_task
              (fun f -> ("export_task", (ExportTask.to_json f)))])
    let parse xml =
      Some
        {
          export_task =
            (Util.option_bind (Xml.member "exportTask" xml) ExportTask.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.export_task
              (fun f ->
                 Ezxmlm.make_tag "exportTask" ([], (ExportTask.to_xml f)))])
  end
module DisableTransitGatewayRouteTablePropagationResult =
  struct
    type t =
      {
      propagation: TransitGatewayPropagation.t option
        [@ocaml.doc "<p>Information about route propagation.</p>"]}
    let make ?propagation  () = { propagation }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.propagation
              (fun f ->
                 Query.Pair
                   ("Propagation", (TransitGatewayPropagation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.propagation
              (fun f ->
                 ("propagation", (TransitGatewayPropagation.to_json f)))])
    let parse xml =
      Some
        {
          propagation =
            (Util.option_bind (Xml.member "propagation" xml)
               TransitGatewayPropagation.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.propagation
              (fun f ->
                 Ezxmlm.make_tag "propagation"
                   ([], (TransitGatewayPropagation.to_xml f)))])
  end
module DescribeVpcClassicLinkDnsSupportResult =
  struct
    type t =
      {
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"];
      vpcs: ClassicLinkDnsSupportList.t
        [@ocaml.doc
          "<p>Information about the ClassicLink DNS support status of the VPCs.</p>"]}
    let make ?next_token  ?(vpcs= [])  () = { next_token; vpcs }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Vpcs", (ClassicLinkDnsSupportList.to_query v.vpcs)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpcs", (ClassicLinkDnsSupportList.to_json v.vpcs));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          vpcs =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcs" xml)
                  ClassicLinkDnsSupportList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "vpcs"
                      ([], (ClassicLinkDnsSupportList.to_xml [x])))) v.vpcs))
  end
module DisassociateVpcCidrBlockResult =
  struct
    type t =
      {
      ipv6_cidr_block_association: VpcIpv6CidrBlockAssociation.t option
        [@ocaml.doc
          "<p>Information about the IPv6 CIDR block association.</p>"];
      cidr_block_association: VpcCidrBlockAssociation.t option
        [@ocaml.doc
          "<p>Information about the IPv4 CIDR block association.</p>"];
      vpc_id: String.t option [@ocaml.doc "<p>The ID of the VPC.</p>"]}
    let make ?ipv6_cidr_block_association  ?cidr_block_association  ?vpc_id 
      () = { ipv6_cidr_block_association; cidr_block_association; vpc_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.cidr_block_association
             (fun f ->
                Query.Pair
                  ("CidrBlockAssociation",
                    (VpcCidrBlockAssociation.to_query f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockAssociation",
                    (VpcIpv6CidrBlockAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.cidr_block_association
             (fun f ->
                ("cidr_block_association",
                  (VpcCidrBlockAssociation.to_json f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                ("ipv6_cidr_block_association",
                  (VpcIpv6CidrBlockAssociation.to_json f)))])
    let parse xml =
      Some
        {
          ipv6_cidr_block_association =
            (Util.option_bind (Xml.member "ipv6CidrBlockAssociation" xml)
               VpcIpv6CidrBlockAssociation.parse);
          cidr_block_association =
            (Util.option_bind (Xml.member "cidrBlockAssociation" xml)
               VpcCidrBlockAssociation.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.ipv6_cidr_block_association
                (fun f ->
                   Ezxmlm.make_tag "ipv6CidrBlockAssociation"
                     ([], (VpcIpv6CidrBlockAssociation.to_xml f)))])
            @
            [Util.option_map v.cidr_block_association
               (fun f ->
                  Ezxmlm.make_tag "cidrBlockAssociation"
                    ([], (VpcCidrBlockAssociation.to_xml f)))])
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
  end
module DescribeReservedInstancesListingsResult =
  struct
    type t =
      {
      reserved_instances_listings: ReservedInstancesListingList.t
        [@ocaml.doc
          "<p>Information about the Reserved Instance listing.</p>"]}
    [@@ocaml.doc
      "<p>Contains the output of DescribeReservedInstancesListings.</p>"]
    let make ?(reserved_instances_listings= [])  () =
      { reserved_instances_listings }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesListingsSet",
                   (ReservedInstancesListingList.to_query
                      v.reserved_instances_listings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_listings",
                (ReservedInstancesListingList.to_json
                   v.reserved_instances_listings))])
    let parse xml =
      Some
        {
          reserved_instances_listings =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesListingsSet" xml)
                  ReservedInstancesListingList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "reservedInstancesListingsSet"
                      ([], (ReservedInstancesListingList.to_xml [x]))))
              v.reserved_instances_listings))
  end[@@ocaml.doc
       "<p>Contains the output of DescribeReservedInstancesListings.</p>"]
module CreateVpcEndpointServiceConfigurationResult =
  struct
    type t =
      {
      service_configuration: ServiceConfiguration.t option
        [@ocaml.doc "<p>Information about the service configuration.</p>"];
      client_token: String.t option
        [@ocaml.doc
          "<p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request.</p>"]}
    let make ?service_configuration  ?client_token  () =
      { service_configuration; client_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.service_configuration
             (fun f ->
                Query.Pair
                  ("ServiceConfiguration", (ServiceConfiguration.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.service_configuration
             (fun f ->
                ("service_configuration", (ServiceConfiguration.to_json f)))])
    let parse xml =
      Some
        {
          service_configuration =
            (Util.option_bind (Xml.member "serviceConfiguration" xml)
               ServiceConfiguration.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.service_configuration
               (fun f ->
                  Ezxmlm.make_tag "serviceConfiguration"
                    ([], (ServiceConfiguration.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
  end
module AllocateAddressResult =
  struct
    type t =
      {
      public_ip: String.t option
        [@ocaml.doc "<p>The Elastic IP address.</p>"];
      allocation_id: String.t option
        [@ocaml.doc
          "<p>[EC2-VPC] The ID that AWS assigns to represent the allocation of the Elastic IP address for use with instances in a VPC.</p>"];
      public_ipv4_pool: String.t option
        [@ocaml.doc "<p>The ID of an address pool.</p>"];
      network_border_group: String.t option
        [@ocaml.doc
          "<p>The location from which the IP address is advertised.</p>"];
      domain: DomainType.t option
        [@ocaml.doc
          "<p>Indicates whether this Elastic IP address is for use with instances in EC2-Classic (<code>standard</code>) or instances in a VPC (<code>vpc</code>).</p>"];
      customer_owned_ip: String.t option
        [@ocaml.doc "<p>The customer-owned IP address.</p>"];
      customer_owned_ipv4_pool: String.t option
        [@ocaml.doc "<p>The ID of the customer-owned address pool.</p>"]}
    let make ?public_ip  ?allocation_id  ?public_ipv4_pool 
      ?network_border_group  ?domain  ?customer_owned_ip 
      ?customer_owned_ipv4_pool  () =
      {
        public_ip;
        allocation_id;
        public_ipv4_pool;
        network_border_group;
        domain;
        customer_owned_ip;
        customer_owned_ipv4_pool
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.customer_owned_ipv4_pool
              (fun f ->
                 Query.Pair ("CustomerOwnedIpv4Pool", (String.to_query f)));
           Util.option_map v.customer_owned_ip
             (fun f -> Query.Pair ("CustomerOwnedIp", (String.to_query f)));
           Util.option_map v.domain
             (fun f -> Query.Pair ("Domain", (DomainType.to_query f)));
           Util.option_map v.network_border_group
             (fun f -> Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.public_ipv4_pool
             (fun f -> Query.Pair ("PublicIpv4Pool", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.customer_owned_ipv4_pool
              (fun f -> ("customer_owned_ipv4_pool", (String.to_json f)));
           Util.option_map v.customer_owned_ip
             (fun f -> ("customer_owned_ip", (String.to_json f)));
           Util.option_map v.domain
             (fun f -> ("domain", (DomainType.to_json f)));
           Util.option_map v.network_border_group
             (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.public_ipv4_pool
             (fun f -> ("public_ipv4_pool", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)))])
    let parse xml =
      Some
        {
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse);
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          public_ipv4_pool =
            (Util.option_bind (Xml.member "publicIpv4Pool" xml) String.parse);
          network_border_group =
            (Util.option_bind (Xml.member "networkBorderGroup" xml)
               String.parse);
          domain =
            (Util.option_bind (Xml.member "domain" xml) DomainType.parse);
          customer_owned_ip =
            (Util.option_bind (Xml.member "customerOwnedIp" xml) String.parse);
          customer_owned_ipv4_pool =
            (Util.option_bind (Xml.member "customerOwnedIpv4Pool" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.public_ip
                    (fun f ->
                       Ezxmlm.make_tag "publicIp" ([], (String.to_xml f)))])
                @
                [Util.option_map v.allocation_id
                   (fun f ->
                      Ezxmlm.make_tag "allocationId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.public_ipv4_pool
                  (fun f ->
                     Ezxmlm.make_tag "publicIpv4Pool" ([], (String.to_xml f)))])
              @
              [Util.option_map v.network_border_group
                 (fun f ->
                    Ezxmlm.make_tag "networkBorderGroup"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.domain
                (fun f ->
                   Ezxmlm.make_tag "domain" ([], (DomainType.to_xml f)))])
            @
            [Util.option_map v.customer_owned_ip
               (fun f ->
                  Ezxmlm.make_tag "customerOwnedIp" ([], (String.to_xml f)))])
           @
           [Util.option_map v.customer_owned_ipv4_pool
              (fun f ->
                 Ezxmlm.make_tag "customerOwnedIpv4Pool"
                   ([], (String.to_xml f)))])
  end
module ModifyTrafficMirrorFilterRuleResult =
  struct
    type t =
      {
      traffic_mirror_filter_rule: TrafficMirrorFilterRule.t option
        [@ocaml.doc "<p>Modifies a Traffic Mirror rule.</p>"]}
    let make ?traffic_mirror_filter_rule  () = { traffic_mirror_filter_rule }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_rule
              (fun f ->
                 Query.Pair
                   ("TrafficMirrorFilterRule",
                     (TrafficMirrorFilterRule.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_rule
              (fun f ->
                 ("traffic_mirror_filter_rule",
                   (TrafficMirrorFilterRule.to_json f)))])
    let parse xml =
      Some
        {
          traffic_mirror_filter_rule =
            (Util.option_bind (Xml.member "trafficMirrorFilterRule" xml)
               TrafficMirrorFilterRule.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.traffic_mirror_filter_rule
              (fun f ->
                 Ezxmlm.make_tag "trafficMirrorFilterRule"
                   ([], (TrafficMirrorFilterRule.to_xml f)))])
  end
module CreateDefaultVpcResult =
  struct
    type t =
      {
      vpc: Vpc.t option [@ocaml.doc "<p>Information about the VPC.</p>"]}
    let make ?vpc  () = { vpc }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc
              (fun f -> Query.Pair ("Vpc", (Vpc.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc (fun f -> ("vpc", (Vpc.to_json f)))])
    let parse xml =
      Some { vpc = (Util.option_bind (Xml.member "vpc" xml) Vpc.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpc
              (fun f -> Ezxmlm.make_tag "vpc" ([], (Vpc.to_xml f)))])
  end
module TerminateInstancesResult =
  struct
    type t =
      {
      terminating_instances: InstanceStateChangeList.t
        [@ocaml.doc "<p>Information about the terminated instances.</p>"]}
    let make ?(terminating_instances= [])  () = { terminating_instances }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceStateChangeList.to_query v.terminating_instances)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("terminating_instances",
                (InstanceStateChangeList.to_json v.terminating_instances))])
    let parse xml =
      Some
        {
          terminating_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceStateChangeList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "instancesSet"
                      ([], (InstanceStateChangeList.to_xml [x]))))
              v.terminating_instances))
  end
module ExportClientVpnClientCertificateRevocationListResult =
  struct
    type t =
      {
      certificate_revocation_list: String.t option
        [@ocaml.doc
          "<p>Information about the client certificate revocation list.</p>"];
      status: ClientCertificateRevocationListStatus.t option
        [@ocaml.doc
          "<p>The current state of the client certificate revocation list.</p>"]}
    let make ?certificate_revocation_list  ?status  () =
      { certificate_revocation_list; status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair
                   ("Status",
                     (ClientCertificateRevocationListStatus.to_query f)));
           Util.option_map v.certificate_revocation_list
             (fun f ->
                Query.Pair ("CertificateRevocationList", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 ("status",
                   (ClientCertificateRevocationListStatus.to_json f)));
           Util.option_map v.certificate_revocation_list
             (fun f -> ("certificate_revocation_list", (String.to_json f)))])
    let parse xml =
      Some
        {
          certificate_revocation_list =
            (Util.option_bind (Xml.member "certificateRevocationList" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientCertificateRevocationListStatus.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.certificate_revocation_list
               (fun f ->
                  Ezxmlm.make_tag "certificateRevocationList"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status"
                   ([], (ClientCertificateRevocationListStatus.to_xml f)))])
  end
module TerminateClientVpnConnectionsResult =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option
        [@ocaml.doc "<p>The ID of the Client VPN endpoint.</p>"];
      username: String.t option
        [@ocaml.doc
          "<p>The user who established the terminated client connections.</p>"];
      connection_statuses: TerminateConnectionStatusSet.t
        [@ocaml.doc "<p>The current state of the client connections.</p>"]}
    let make ?client_vpn_endpoint_id  ?username  ?(connection_statuses= []) 
      () = { client_vpn_endpoint_id; username; connection_statuses }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ConnectionStatuses",
                   (TerminateConnectionStatusSet.to_query
                      v.connection_statuses)));
           Util.option_map v.username
             (fun f -> Query.Pair ("Username", (String.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("connection_statuses",
                (TerminateConnectionStatusSet.to_json v.connection_statuses));
           Util.option_map v.username
             (fun f -> ("username", (String.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          username =
            (Util.option_bind (Xml.member "username" xml) String.parse);
          connection_statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "connectionStatuses" xml)
                  TerminateConnectionStatusSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.client_vpn_endpoint_id
                (fun f ->
                   Ezxmlm.make_tag "clientVpnEndpointId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.username
               (fun f -> Ezxmlm.make_tag "username" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "connectionStatuses"
                      ([], (TerminateConnectionStatusSet.to_xml [x]))))
              v.connection_statuses))
  end
module DescribeInstanceTypeOfferingsResult =
  struct
    type t =
      {
      instance_type_offerings: InstanceTypeOfferingsList.t
        [@ocaml.doc "<p>The instance types offered.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(instance_type_offerings= [])  ?next_token  () =
      { instance_type_offerings; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceTypeOfferingSet",
                  (InstanceTypeOfferingsList.to_query
                     v.instance_type_offerings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_type_offerings",
               (InstanceTypeOfferingsList.to_json v.instance_type_offerings))])
    let parse xml =
      Some
        {
          instance_type_offerings =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceTypeOfferingSet" xml)
                  InstanceTypeOfferingsList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "instanceTypeOfferingSet"
                       ([], (InstanceTypeOfferingsList.to_xml [x]))))
               v.instance_type_offerings))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeInstanceStatusResult =
  struct
    type t =
      {
      instance_statuses: InstanceStatusList.t
        [@ocaml.doc "<p>Information about the status of the instances.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(instance_statuses= [])  ?next_token  () =
      { instance_statuses; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceStatusSet",
                  (InstanceStatusList.to_query v.instance_statuses)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_statuses",
               (InstanceStatusList.to_json v.instance_statuses))])
    let parse xml =
      Some
        {
          instance_statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceStatusSet" xml)
                  InstanceStatusList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "instanceStatusSet"
                       ([], (InstanceStatusList.to_xml [x]))))
               v.instance_statuses))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module CreateReservedInstancesListingResult =
  struct
    type t =
      {
      reserved_instances_listings: ReservedInstancesListingList.t
        [@ocaml.doc
          "<p>Information about the Standard Reserved Instance listing.</p>"]}
    [@@ocaml.doc
      "<p>Contains the output of CreateReservedInstancesListing.</p>"]
    let make ?(reserved_instances_listings= [])  () =
      { reserved_instances_listings }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesListingsSet",
                   (ReservedInstancesListingList.to_query
                      v.reserved_instances_listings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_listings",
                (ReservedInstancesListingList.to_json
                   v.reserved_instances_listings))])
    let parse xml =
      Some
        {
          reserved_instances_listings =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesListingsSet" xml)
                  ReservedInstancesListingList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "reservedInstancesListingsSet"
                      ([], (ReservedInstancesListingList.to_xml [x]))))
              v.reserved_instances_listings))
  end[@@ocaml.doc
       "<p>Contains the output of CreateReservedInstancesListing.</p>"]
module RejectTransitGatewayPeeringAttachmentResult =
  struct
    type t =
      {
      transit_gateway_peering_attachment:
        TransitGatewayPeeringAttachment.t option
        [@ocaml.doc "<p>The transit gateway peering attachment.</p>"]}
    let make ?transit_gateway_peering_attachment  () =
      { transit_gateway_peering_attachment }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayPeeringAttachment",
                     (TransitGatewayPeeringAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 ("transit_gateway_peering_attachment",
                   (TransitGatewayPeeringAttachment.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_peering_attachment =
            (Util.option_bind
               (Xml.member "transitGatewayPeeringAttachment" xml)
               TransitGatewayPeeringAttachment.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayPeeringAttachment"
                   ([], (TransitGatewayPeeringAttachment.to_xml f)))])
  end
module ModifyFleetResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Is <code>true</code> if the request succeeds, and an error otherwise.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module CreateFpgaImageResult =
  struct
    type t =
      {
      fpga_image_id: String.t option
        [@ocaml.doc "<p>The FPGA image identifier (AFI ID).</p>"];
      fpga_image_global_id: String.t option
        [@ocaml.doc "<p>The global FPGA image identifier (AGFI ID).</p>"]}
    let make ?fpga_image_id  ?fpga_image_global_id  () =
      { fpga_image_id; fpga_image_global_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_global_id
              (fun f -> Query.Pair ("FpgaImageGlobalId", (String.to_query f)));
           Util.option_map v.fpga_image_id
             (fun f -> Query.Pair ("FpgaImageId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_global_id
              (fun f -> ("fpga_image_global_id", (String.to_json f)));
           Util.option_map v.fpga_image_id
             (fun f -> ("fpga_image_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          fpga_image_id =
            (Util.option_bind (Xml.member "fpgaImageId" xml) String.parse);
          fpga_image_global_id =
            (Util.option_bind (Xml.member "fpgaImageGlobalId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.fpga_image_id
               (fun f ->
                  Ezxmlm.make_tag "fpgaImageId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.fpga_image_global_id
              (fun f ->
                 Ezxmlm.make_tag "fpgaImageGlobalId" ([], (String.to_xml f)))])
  end
module DescribeImagesResult =
  struct
    type t =
      {
      images: ImageList.t [@ocaml.doc "<p>Information about the images.</p>"]}
    let make ?(images= [])  () = { images }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("ImagesSet", (ImageList.to_query v.images)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt [Some ("images", (ImageList.to_json v.images))])
    let parse xml =
      Some
        {
          images =
            (Util.of_option []
               (Util.option_bind (Xml.member "imagesSet" xml) ImageList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "imagesSet" ([], (ImageList.to_xml [x]))))
              v.images))
  end
module DescribeImportSnapshotTasksResult =
  struct
    type t =
      {
      import_snapshot_tasks: ImportSnapshotTaskList.t
        [@ocaml.doc
          "<p>A list of zero or more import snapshot tasks that are currently active or were completed or canceled in the previous 7 days.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to get the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(import_snapshot_tasks= [])  ?next_token  () =
      { import_snapshot_tasks; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ImportSnapshotTaskSet",
                  (ImportSnapshotTaskList.to_query v.import_snapshot_tasks)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("import_snapshot_tasks",
               (ImportSnapshotTaskList.to_json v.import_snapshot_tasks))])
    let parse xml =
      Some
        {
          import_snapshot_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "importSnapshotTaskSet" xml)
                  ImportSnapshotTaskList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "importSnapshotTaskSet"
                       ([], (ImportSnapshotTaskList.to_xml [x]))))
               v.import_snapshot_tasks))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module CreateTrafficMirrorFilterRuleResult =
  struct
    type t =
      {
      traffic_mirror_filter_rule: TrafficMirrorFilterRule.t option
        [@ocaml.doc "<p>The Traffic Mirror rule.</p>"];
      client_token: String.t option
        [@ocaml.doc
          "<p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html\">How to Ensure Idempotency</a>.</p>"]}
    let make ?traffic_mirror_filter_rule  ?client_token  () =
      { traffic_mirror_filter_rule; client_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.traffic_mirror_filter_rule
             (fun f ->
                Query.Pair
                  ("TrafficMirrorFilterRule",
                    (TrafficMirrorFilterRule.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.traffic_mirror_filter_rule
             (fun f ->
                ("traffic_mirror_filter_rule",
                  (TrafficMirrorFilterRule.to_json f)))])
    let parse xml =
      Some
        {
          traffic_mirror_filter_rule =
            (Util.option_bind (Xml.member "trafficMirrorFilterRule" xml)
               TrafficMirrorFilterRule.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.traffic_mirror_filter_rule
               (fun f ->
                  Ezxmlm.make_tag "trafficMirrorFilterRule"
                    ([], (TrafficMirrorFilterRule.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
  end
module DescribeNetworkInterfacePermissionsResult =
  struct
    type t =
      {
      network_interface_permissions: NetworkInterfacePermissionList.t
        [@ocaml.doc "<p>The network interface permissions.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results.</p>"]}
    [@@ocaml.doc
      "<p>Contains the output for DescribeNetworkInterfacePermissions.</p>"]
    let make ?(network_interface_permissions= [])  ?next_token  () =
      { network_interface_permissions; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfacePermissions",
                  (NetworkInterfacePermissionList.to_query
                     v.network_interface_permissions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("network_interface_permissions",
               (NetworkInterfacePermissionList.to_json
                  v.network_interface_permissions))])
    let parse xml =
      Some
        {
          network_interface_permissions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "networkInterfacePermissions" xml)
                  NetworkInterfacePermissionList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "networkInterfacePermissions"
                       ([], (NetworkInterfacePermissionList.to_xml [x]))))
               v.network_interface_permissions))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Contains the output for DescribeNetworkInterfacePermissions.</p>"]
module CreateTransitGatewayResult =
  struct
    type t =
      {
      transit_gateway: TransitGateway.t option
        [@ocaml.doc "<p>Information about the transit gateway.</p>"]}
    let make ?transit_gateway  () = { transit_gateway }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway
              (fun f ->
                 Query.Pair ("TransitGateway", (TransitGateway.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway
              (fun f -> ("transit_gateway", (TransitGateway.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway =
            (Util.option_bind (Xml.member "transitGateway" xml)
               TransitGateway.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway
              (fun f ->
                 Ezxmlm.make_tag "transitGateway"
                   ([], (TransitGateway.to_xml f)))])
  end
module AssociateTransitGatewayRouteTableResult =
  struct
    type t =
      {
      association: TransitGatewayAssociation.t option
        [@ocaml.doc "<p>The ID of the association.</p>"]}
    let make ?association  () = { association }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association
              (fun f ->
                 Query.Pair
                   ("Association", (TransitGatewayAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association
              (fun f ->
                 ("association", (TransitGatewayAssociation.to_json f)))])
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               TransitGatewayAssociation.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.association
              (fun f ->
                 Ezxmlm.make_tag "association"
                   ([], (TransitGatewayAssociation.to_xml f)))])
  end
module CancelImportTaskResult =
  struct
    type t =
      {
      import_task_id: String.t option
        [@ocaml.doc "<p>The ID of the task being canceled.</p>"];
      previous_state: String.t option
        [@ocaml.doc "<p>The current state of the task being canceled.</p>"];
      state: String.t option
        [@ocaml.doc "<p>The current state of the task being canceled.</p>"]}
    let make ?import_task_id  ?previous_state  ?state  () =
      { import_task_id; previous_state; state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (String.to_query f)));
           Util.option_map v.previous_state
             (fun f -> Query.Pair ("PreviousState", (String.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.previous_state
             (fun f -> ("previous_state", (String.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          previous_state =
            (Util.option_bind (Xml.member "previousState" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.import_task_id
                (fun f ->
                   Ezxmlm.make_tag "importTaskId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.previous_state
               (fun f ->
                  Ezxmlm.make_tag "previousState" ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f -> Ezxmlm.make_tag "state" ([], (String.to_xml f)))])
  end
module ModifyTrafficMirrorFilterNetworkServicesResult =
  struct
    type t =
      {
      traffic_mirror_filter: TrafficMirrorFilter.t option
        [@ocaml.doc
          "<p>The Traffic Mirror filter that the network service is associated with.</p>"]}
    let make ?traffic_mirror_filter  () = { traffic_mirror_filter }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter
              (fun f ->
                 Query.Pair
                   ("TrafficMirrorFilter", (TrafficMirrorFilter.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter
              (fun f ->
                 ("traffic_mirror_filter", (TrafficMirrorFilter.to_json f)))])
    let parse xml =
      Some
        {
          traffic_mirror_filter =
            (Util.option_bind (Xml.member "trafficMirrorFilter" xml)
               TrafficMirrorFilter.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.traffic_mirror_filter
              (fun f ->
                 Ezxmlm.make_tag "trafficMirrorFilter"
                   ([], (TrafficMirrorFilter.to_xml f)))])
  end
module CopySnapshotResult =
  struct
    type t =
      {
      snapshot_id: String.t option
        [@ocaml.doc "<p>The ID of the new snapshot.</p>"];
      tags: TagList.t
        [@ocaml.doc "<p>Any tags applied to the new snapshot.</p>"]}
    let make ?snapshot_id  ?(tags= [])  () = { snapshot_id; tags }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.snapshot_id
               (fun f -> Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
  end
module AllocateHostsResult =
  struct
    type t =
      {
      host_ids: ResponseHostIdList.t
        [@ocaml.doc
          "<p>The ID of the allocated Dedicated Host. This is used to launch an instance onto a specific host.</p>"]}
    [@@ocaml.doc "<p>Contains the output of AllocateHosts.</p>"]
    let make ?(host_ids= [])  () = { host_ids }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("HostIdSet", (ResponseHostIdList.to_query v.host_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("host_ids", (ResponseHostIdList.to_json v.host_ids))])
    let parse xml =
      Some
        {
          host_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostIdSet" xml)
                  ResponseHostIdList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "hostIdSet"
                      ([], (ResponseHostIdList.to_xml [x])))) v.host_ids))
  end[@@ocaml.doc "<p>Contains the output of AllocateHosts.</p>"]
module CreateVpnGatewayResult =
  struct
    type t =
      {
      vpn_gateway: VpnGateway.t option
        [@ocaml.doc "<p>Information about the virtual private gateway.</p>"]}
    [@@ocaml.doc "<p>Contains the output of CreateVpnGateway.</p>"]
    let make ?vpn_gateway  () = { vpn_gateway }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_gateway
              (fun f -> Query.Pair ("VpnGateway", (VpnGateway.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_gateway
              (fun f -> ("vpn_gateway", (VpnGateway.to_json f)))])
    let parse xml =
      Some
        {
          vpn_gateway =
            (Util.option_bind (Xml.member "vpnGateway" xml) VpnGateway.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpn_gateway
              (fun f ->
                 Ezxmlm.make_tag "vpnGateway" ([], (VpnGateway.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of CreateVpnGateway.</p>"]
module CreateCapacityReservationResult =
  struct
    type t =
      {
      capacity_reservation: CapacityReservation.t option
        [@ocaml.doc "<p>Information about the Capacity Reservation.</p>"]}
    let make ?capacity_reservation  () = { capacity_reservation }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation
              (fun f ->
                 Query.Pair
                   ("CapacityReservation", (CapacityReservation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation
              (fun f ->
                 ("capacity_reservation", (CapacityReservation.to_json f)))])
    let parse xml =
      Some
        {
          capacity_reservation =
            (Util.option_bind (Xml.member "capacityReservation" xml)
               CapacityReservation.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.capacity_reservation
              (fun f ->
                 Ezxmlm.make_tag "capacityReservation"
                   ([], (CapacityReservation.to_xml f)))])
  end
module CreateLaunchTemplateVersionResult =
  struct
    type t =
      {
      launch_template_version: LaunchTemplateVersion.t option
        [@ocaml.doc "<p>Information about the launch template version.</p>"]}
    let make ?launch_template_version  () = { launch_template_version }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template_version
              (fun f ->
                 Query.Pair
                   ("LaunchTemplateVersion",
                     (LaunchTemplateVersion.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template_version
              (fun f ->
                 ("launch_template_version",
                   (LaunchTemplateVersion.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_version =
            (Util.option_bind (Xml.member "launchTemplateVersion" xml)
               LaunchTemplateVersion.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.launch_template_version
              (fun f ->
                 Ezxmlm.make_tag "launchTemplateVersion"
                   ([], (LaunchTemplateVersion.to_xml f)))])
  end
module DescribeHostsResult =
  struct
    type t =
      {
      hosts: HostList.t
        [@ocaml.doc "<p>Information about the Dedicated Hosts.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(hosts= [])  ?next_token  () = { hosts; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("HostSet", (HostList.to_query v.hosts)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("hosts", (HostList.to_json v.hosts))])
    let parse xml =
      Some
        {
          hosts =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostSet" xml) HostList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "hostSet" ([], (HostList.to_xml [x]))))
               v.hosts))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DisassociateTransitGatewayMulticastDomainResult =
  struct
    type t =
      {
      associations: TransitGatewayMulticastDomainAssociations.t option
        [@ocaml.doc "<p>Information about the association.</p>"]}
    let make ?associations  () = { associations }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.associations
              (fun f ->
                 Query.Pair
                   ("Associations",
                     (TransitGatewayMulticastDomainAssociations.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.associations
              (fun f ->
                 ("associations",
                   (TransitGatewayMulticastDomainAssociations.to_json f)))])
    let parse xml =
      Some
        {
          associations =
            (Util.option_bind (Xml.member "associations" xml)
               TransitGatewayMulticastDomainAssociations.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.associations
              (fun f ->
                 Ezxmlm.make_tag "associations"
                   ([], (TransitGatewayMulticastDomainAssociations.to_xml f)))])
  end
module DescribeLaunchTemplatesResult =
  struct
    type t =
      {
      launch_templates: LaunchTemplateSet.t
        [@ocaml.doc "<p>Information about the launch templates.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(launch_templates= [])  ?next_token  () =
      { launch_templates; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LaunchTemplates",
                  (LaunchTemplateSet.to_query v.launch_templates)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("launch_templates",
               (LaunchTemplateSet.to_json v.launch_templates))])
    let parse xml =
      Some
        {
          launch_templates =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchTemplates" xml)
                  LaunchTemplateSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "launchTemplates"
                       ([], (LaunchTemplateSet.to_xml [x]))))
               v.launch_templates))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribePrefixListsResult =
  struct
    type t =
      {
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"];
      prefix_lists: PrefixListSet.t
        [@ocaml.doc "<p>All available prefix lists.</p>"]}
    let make ?next_token  ?(prefix_lists= [])  () =
      { next_token; prefix_lists }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PrefixListSet", (PrefixListSet.to_query v.prefix_lists)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("prefix_lists", (PrefixListSet.to_json v.prefix_lists));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          prefix_lists =
            (Util.of_option []
               (Util.option_bind (Xml.member "prefixListSet" xml)
                  PrefixListSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "prefixListSet"
                      ([], (PrefixListSet.to_xml [x])))) v.prefix_lists))
  end
module DeprovisionByoipCidrResult =
  struct
    type t =
      {
      byoip_cidr: ByoipCidr.t option
        [@ocaml.doc "<p>Information about the address range.</p>"]}
    let make ?byoip_cidr  () = { byoip_cidr }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> Query.Pair ("ByoipCidr", (ByoipCidr.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> ("byoip_cidr", (ByoipCidr.to_json f)))])
    let parse xml =
      Some
        {
          byoip_cidr =
            (Util.option_bind (Xml.member "byoipCidr" xml) ByoipCidr.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.byoip_cidr
              (fun f ->
                 Ezxmlm.make_tag "byoipCidr" ([], (ByoipCidr.to_xml f)))])
  end
module ModifyInstancePlacementResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Is <code>true</code> if the request succeeds, and an error otherwise.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module GetDefaultCreditSpecificationResult =
  struct
    type t =
      {
      instance_family_credit_specification:
        InstanceFamilyCreditSpecification.t option
        [@ocaml.doc
          "<p>The default credit option for CPU usage of the instance family.</p>"]}
    let make ?instance_family_credit_specification  () =
      { instance_family_credit_specification }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_family_credit_specification
              (fun f ->
                 Query.Pair
                   ("InstanceFamilyCreditSpecification",
                     (InstanceFamilyCreditSpecification.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_family_credit_specification
              (fun f ->
                 ("instance_family_credit_specification",
                   (InstanceFamilyCreditSpecification.to_json f)))])
    let parse xml =
      Some
        {
          instance_family_credit_specification =
            (Util.option_bind
               (Xml.member "instanceFamilyCreditSpecification" xml)
               InstanceFamilyCreditSpecification.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.instance_family_credit_specification
              (fun f ->
                 Ezxmlm.make_tag "instanceFamilyCreditSpecification"
                   ([], (InstanceFamilyCreditSpecification.to_xml f)))])
  end
module DeleteLaunchTemplateResult =
  struct
    type t =
      {
      launch_template: LaunchTemplate.t option
        [@ocaml.doc "<p>Information about the launch template.</p>"]}
    let make ?launch_template  () = { launch_template }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template
              (fun f ->
                 Query.Pair ("LaunchTemplate", (LaunchTemplate.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template
              (fun f -> ("launch_template", (LaunchTemplate.to_json f)))])
    let parse xml =
      Some
        {
          launch_template =
            (Util.option_bind (Xml.member "launchTemplate" xml)
               LaunchTemplate.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.launch_template
              (fun f ->
                 Ezxmlm.make_tag "launchTemplate"
                   ([], (LaunchTemplate.to_xml f)))])
  end
module DescribeSpotFleetInstancesResponse =
  struct
    type t =
      {
      active_instances: ActiveInstanceSet.t
        [@ocaml.doc
          "<p>The running instances. This list is refreshed periodically and might be out of date.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>"];
      spot_fleet_request_id: String.t option
        [@ocaml.doc "<p>The ID of the Spot Fleet request.</p>"]}[@@ocaml.doc
                                                                  "<p>Contains the output of DescribeSpotFleetInstances.</p>"]
    let make ?(active_instances= [])  ?next_token  ?spot_fleet_request_id  ()
      = { active_instances; next_token; spot_fleet_request_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Query.Pair ("SpotFleetRequestId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ActiveInstanceSet",
                  (ActiveInstanceSet.to_query v.active_instances)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f -> ("spot_fleet_request_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("active_instances",
               (ActiveInstanceSet.to_json v.active_instances))])
    let parse xml =
      Some
        {
          active_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "activeInstanceSet" xml)
                  ActiveInstanceSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "activeInstanceSet"
                        ([], (ActiveInstanceSet.to_xml [x]))))
                v.active_instances))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Ezxmlm.make_tag "spotFleetRequestId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Contains the output of DescribeSpotFleetInstances.</p>"]
module DescribeFpgaImageAttributeResult =
  struct
    type t =
      {
      fpga_image_attribute: FpgaImageAttribute.t option
        [@ocaml.doc "<p>Information about the attribute.</p>"]}
    let make ?fpga_image_attribute  () = { fpga_image_attribute }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_attribute
              (fun f ->
                 Query.Pair
                   ("FpgaImageAttribute", (FpgaImageAttribute.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_attribute
              (fun f ->
                 ("fpga_image_attribute", (FpgaImageAttribute.to_json f)))])
    let parse xml =
      Some
        {
          fpga_image_attribute =
            (Util.option_bind (Xml.member "fpgaImageAttribute" xml)
               FpgaImageAttribute.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.fpga_image_attribute
              (fun f ->
                 Ezxmlm.make_tag "fpgaImageAttribute"
                   ([], (FpgaImageAttribute.to_xml f)))])
  end
module CreateDefaultSubnetResult =
  struct
    type t =
      {
      subnet: Subnet.t option
        [@ocaml.doc "<p>Information about the subnet.</p>"]}
    let make ?subnet  () = { subnet }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> Query.Pair ("Subnet", (Subnet.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> ("subnet", (Subnet.to_json f)))])
    let parse xml =
      Some
        { subnet = (Util.option_bind (Xml.member "subnet" xml) Subnet.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.subnet
              (fun f -> Ezxmlm.make_tag "subnet" ([], (Subnet.to_xml f)))])
  end
module DeleteEgressOnlyInternetGatewayResult =
  struct
    type t =
      {
      return_code: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return_code  () = { return_code }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return_code
              (fun f -> Query.Pair ("ReturnCode", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return_code
              (fun f -> ("return_code", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          return_code =
            (Util.option_bind (Xml.member "returnCode" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return_code
              (fun f -> Ezxmlm.make_tag "returnCode" ([], (Boolean.to_xml f)))])
  end
module DescribeTransitGatewayMulticastDomainsResult =
  struct
    type t =
      {
      transit_gateway_multicast_domains: TransitGatewayMulticastDomainList.t
        [@ocaml.doc
          "<p>Information about the transit gateway multicast domains.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(transit_gateway_multicast_domains= [])  ?next_token  () =
      { transit_gateway_multicast_domains; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayMulticastDomains",
                  (TransitGatewayMulticastDomainList.to_query
                     v.transit_gateway_multicast_domains)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_multicast_domains",
               (TransitGatewayMulticastDomainList.to_json
                  v.transit_gateway_multicast_domains))])
    let parse xml =
      Some
        {
          transit_gateway_multicast_domains =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "transitGatewayMulticastDomains" xml)
                  TransitGatewayMulticastDomainList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "transitGatewayMulticastDomains"
                       ([], (TransitGatewayMulticastDomainList.to_xml [x]))))
               v.transit_gateway_multicast_domains))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribePrincipalIdFormatResult =
  struct
    type t =
      {
      principals: PrincipalIdFormatList.t
        [@ocaml.doc
          "<p>Information about the ID format settings for the ARN.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is null when there are no more results to return.</p>"]}
    let make ?(principals= [])  ?next_token  () = { principals; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("PrincipalSet",
                  (PrincipalIdFormatList.to_query v.principals)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("principals", (PrincipalIdFormatList.to_json v.principals))])
    let parse xml =
      Some
        {
          principals =
            (Util.of_option []
               (Util.option_bind (Xml.member "principalSet" xml)
                  PrincipalIdFormatList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "principalSet"
                       ([], (PrincipalIdFormatList.to_xml [x]))))
               v.principals))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module AcceptVpcEndpointConnectionsResult =
  struct
    type t =
      {
      unsuccessful: UnsuccessfulItemSet.t
        [@ocaml.doc
          "<p>Information about the interface endpoints that were not accepted, if applicable.</p>"]}
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemSet.to_xml [x])))) v.unsuccessful))
  end
module DescribeVpcEndpointServicePermissionsResult =
  struct
    type t =
      {
      allowed_principals: AllowedPrincipalSet.t
        [@ocaml.doc
          "<p>Information about one or more allowed principals.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(allowed_principals= [])  ?next_token  () =
      { allowed_principals; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("AllowedPrincipals",
                  (AllowedPrincipalSet.to_query v.allowed_principals)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("allowed_principals",
               (AllowedPrincipalSet.to_json v.allowed_principals))])
    let parse xml =
      Some
        {
          allowed_principals =
            (Util.of_option []
               (Util.option_bind (Xml.member "allowedPrincipals" xml)
                  AllowedPrincipalSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "allowedPrincipals"
                       ([], (AllowedPrincipalSet.to_xml [x]))))
               v.allowed_principals))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeByoipCidrsResult =
  struct
    type t =
      {
      byoip_cidrs: ByoipCidrSet.t
        [@ocaml.doc "<p>Information about your address ranges.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(byoip_cidrs= [])  ?next_token  () =
      { byoip_cidrs; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ByoipCidrSet", (ByoipCidrSet.to_query v.byoip_cidrs)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("byoip_cidrs", (ByoipCidrSet.to_json v.byoip_cidrs))])
    let parse xml =
      Some
        {
          byoip_cidrs =
            (Util.of_option []
               (Util.option_bind (Xml.member "byoipCidrSet" xml)
                  ByoipCidrSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "byoipCidrSet"
                       ([], (ByoipCidrSet.to_xml [x])))) v.byoip_cidrs))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeCoipPoolsResult =
  struct
    type t =
      {
      coip_pools: CoipPoolSet.t
        [@ocaml.doc "<p>Information about the address pools.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(coip_pools= [])  ?next_token  () = { coip_pools; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair ("CoipPoolSet", (CoipPoolSet.to_query v.coip_pools)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("coip_pools", (CoipPoolSet.to_json v.coip_pools))])
    let parse xml =
      Some
        {
          coip_pools =
            (Util.of_option []
               (Util.option_bind (Xml.member "coipPoolSet" xml)
                  CoipPoolSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "coipPoolSet"
                       ([], (CoipPoolSet.to_xml [x])))) v.coip_pools))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeSpotDatafeedSubscriptionResult =
  struct
    type t =
      {
      spot_datafeed_subscription: SpotDatafeedSubscription.t option
        [@ocaml.doc "<p>The Spot Instance data feed subscription.</p>"]}
    [@@ocaml.doc
      "<p>Contains the output of DescribeSpotDatafeedSubscription.</p>"]
    let make ?spot_datafeed_subscription  () = { spot_datafeed_subscription }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 Query.Pair
                   ("SpotDatafeedSubscription",
                     (SpotDatafeedSubscription.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 ("spot_datafeed_subscription",
                   (SpotDatafeedSubscription.to_json f)))])
    let parse xml =
      Some
        {
          spot_datafeed_subscription =
            (Util.option_bind (Xml.member "spotDatafeedSubscription" xml)
               SpotDatafeedSubscription.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 Ezxmlm.make_tag "spotDatafeedSubscription"
                   ([], (SpotDatafeedSubscription.to_xml f)))])
  end[@@ocaml.doc
       "<p>Contains the output of DescribeSpotDatafeedSubscription.</p>"]
module DeleteFleetsResult =
  struct
    type t =
      {
      successful_fleet_deletions: DeleteFleetSuccessSet.t
        [@ocaml.doc
          "<p>Information about the EC2 Fleets that are successfully deleted.</p>"];
      unsuccessful_fleet_deletions: DeleteFleetErrorSet.t
        [@ocaml.doc
          "<p>Information about the EC2 Fleets that are not successfully deleted.</p>"]}
    let make ?(successful_fleet_deletions= []) 
      ?(unsuccessful_fleet_deletions= [])  () =
      { successful_fleet_deletions; unsuccessful_fleet_deletions }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnsuccessfulFleetDeletionSet",
                   (DeleteFleetErrorSet.to_query
                      v.unsuccessful_fleet_deletions)));
           Some
             (Query.Pair
                ("SuccessfulFleetDeletionSet",
                  (DeleteFleetSuccessSet.to_query
                     v.successful_fleet_deletions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful_fleet_deletions",
                (DeleteFleetErrorSet.to_json v.unsuccessful_fleet_deletions));
           Some
             ("successful_fleet_deletions",
               (DeleteFleetSuccessSet.to_json v.successful_fleet_deletions))])
    let parse xml =
      Some
        {
          successful_fleet_deletions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "successfulFleetDeletionSet" xml)
                  DeleteFleetSuccessSet.parse));
          unsuccessful_fleet_deletions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "unsuccessfulFleetDeletionSet" xml)
                  DeleteFleetErrorSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "successfulFleetDeletionSet"
                       ([], (DeleteFleetSuccessSet.to_xml [x]))))
               v.successful_fleet_deletions))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessfulFleetDeletionSet"
                      ([], (DeleteFleetErrorSet.to_xml [x]))))
              v.unsuccessful_fleet_deletions))
  end
module DisableFastSnapshotRestoresResult =
  struct
    type t =
      {
      successful: DisableFastSnapshotRestoreSuccessSet.t
        [@ocaml.doc
          "<p>Information about the snapshots for which fast snapshot restores were successfully disabled.</p>"];
      unsuccessful: DisableFastSnapshotRestoreErrorSet.t
        [@ocaml.doc
          "<p>Information about the snapshots for which fast snapshot restores could not be disabled.</p>"]}
    let make ?(successful= [])  ?(unsuccessful= [])  () =
      { successful; unsuccessful }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (DisableFastSnapshotRestoreErrorSet.to_query
                      v.unsuccessful)));
           Some
             (Query.Pair
                ("Successful",
                  (DisableFastSnapshotRestoreSuccessSet.to_query v.successful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful",
                (DisableFastSnapshotRestoreErrorSet.to_json v.unsuccessful));
           Some
             ("successful",
               (DisableFastSnapshotRestoreSuccessSet.to_json v.successful))])
    let parse xml =
      Some
        {
          successful =
            (Util.of_option []
               (Util.option_bind (Xml.member "successful" xml)
                  DisableFastSnapshotRestoreSuccessSet.parse));
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  DisableFastSnapshotRestoreErrorSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "successful"
                       ([],
                         (DisableFastSnapshotRestoreSuccessSet.to_xml [x]))))
               v.successful))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (DisableFastSnapshotRestoreErrorSet.to_xml [x]))))
              v.unsuccessful))
  end
module GetEbsDefaultKmsKeyIdResult =
  struct
    type t =
      {
      kms_key_id: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the default CMK for encryption by default.</p>"]}
    let make ?kms_key_id  () = { kms_key_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> ("kms_key_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.kms_key_id
              (fun f -> Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
  end
module DeleteTrafficMirrorFilterResult =
  struct
    type t =
      {
      traffic_mirror_filter_id: String.t option
        [@ocaml.doc "<p>The ID of the Traffic Mirror filter.</p>"]}
    let make ?traffic_mirror_filter_id  () = { traffic_mirror_filter_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_id
              (fun f ->
                 Query.Pair ("TrafficMirrorFilterId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_id
              (fun f -> ("traffic_mirror_filter_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          traffic_mirror_filter_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.traffic_mirror_filter_id
              (fun f ->
                 Ezxmlm.make_tag "trafficMirrorFilterId"
                   ([], (String.to_xml f)))])
  end
module DescribeScheduledInstancesResult =
  struct
    type t =
      {
      next_token: String.t option
        [@ocaml.doc
          "<p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>"];
      scheduled_instance_set: ScheduledInstanceSet.t
        [@ocaml.doc "<p>Information about the Scheduled Instances.</p>"]}
    [@@ocaml.doc "<p>Contains the output of DescribeScheduledInstances.</p>"]
    let make ?next_token  ?(scheduled_instance_set= [])  () =
      { next_token; scheduled_instance_set }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ScheduledInstanceSet",
                   (ScheduledInstanceSet.to_query v.scheduled_instance_set)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("scheduled_instance_set",
                (ScheduledInstanceSet.to_json v.scheduled_instance_set));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          scheduled_instance_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "scheduledInstanceSet" xml)
                  ScheduledInstanceSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "scheduledInstanceSet"
                      ([], (ScheduledInstanceSet.to_xml [x]))))
              v.scheduled_instance_set))
  end[@@ocaml.doc
       "<p>Contains the output of DescribeScheduledInstances.</p>"]
module ModifyInstanceMetadataOptionsResult =
  struct
    type t =
      {
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"];
      instance_metadata_options: InstanceMetadataOptionsResponse.t option
        [@ocaml.doc "<p>The metadata options for the instance.</p>"]}
    let make ?instance_id  ?instance_metadata_options  () =
      { instance_id; instance_metadata_options }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_metadata_options
              (fun f ->
                 Query.Pair
                   ("InstanceMetadataOptions",
                     (InstanceMetadataOptionsResponse.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_metadata_options
              (fun f ->
                 ("instance_metadata_options",
                   (InstanceMetadataOptionsResponse.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_metadata_options =
            (Util.option_bind (Xml.member "instanceMetadataOptions" xml)
               InstanceMetadataOptionsResponse.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.instance_metadata_options
              (fun f ->
                 Ezxmlm.make_tag "instanceMetadataOptions"
                   ([], (InstanceMetadataOptionsResponse.to_xml f)))])
  end
module DescribeFlowLogsResult =
  struct
    type t =
      {
      flow_logs: FlowLogSet.t
        [@ocaml.doc "<p>Information about the flow logs.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(flow_logs= [])  ?next_token  () = { flow_logs; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair ("FlowLogSet", (FlowLogSet.to_query v.flow_logs)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("flow_logs", (FlowLogSet.to_json v.flow_logs))])
    let parse xml =
      Some
        {
          flow_logs =
            (Util.of_option []
               (Util.option_bind (Xml.member "flowLogSet" xml)
                  FlowLogSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "flowLogSet"
                       ([], (FlowLogSet.to_xml [x])))) v.flow_logs))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeBundleTasksResult =
  struct
    type t =
      {
      bundle_tasks: BundleTaskList.t
        [@ocaml.doc "<p>Information about the bundle tasks.</p>"]}
    let make ?(bundle_tasks= [])  () = { bundle_tasks }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("BundleInstanceTasksSet",
                   (BundleTaskList.to_query v.bundle_tasks)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("bundle_tasks", (BundleTaskList.to_json v.bundle_tasks))])
    let parse xml =
      Some
        {
          bundle_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "bundleInstanceTasksSet" xml)
                  BundleTaskList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "bundleInstanceTasksSet"
                      ([], (BundleTaskList.to_xml [x])))) v.bundle_tasks))
  end
module DescribeInstanceCreditSpecificationsResult =
  struct
    type t =
      {
      instance_credit_specifications: InstanceCreditSpecificationList.t
        [@ocaml.doc
          "<p>Information about the credit option for CPU usage of an instance.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(instance_credit_specifications= [])  ?next_token  () =
      { instance_credit_specifications; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceCreditSpecificationSet",
                  (InstanceCreditSpecificationList.to_query
                     v.instance_credit_specifications)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_credit_specifications",
               (InstanceCreditSpecificationList.to_json
                  v.instance_credit_specifications))])
    let parse xml =
      Some
        {
          instance_credit_specifications =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "instanceCreditSpecificationSet" xml)
                  InstanceCreditSpecificationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "instanceCreditSpecificationSet"
                       ([], (InstanceCreditSpecificationList.to_xml [x]))))
               v.instance_credit_specifications))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module GetCoipPoolUsageResult =
  struct
    type t =
      {
      coip_pool_id: String.t option
        [@ocaml.doc "<p>The ID of the customer-owned address pool.</p>"];
      coip_address_usages: CoipAddressUsageSet.t
        [@ocaml.doc "<p>Information about the address usage.</p>"];
      local_gateway_route_table_id: String.t option
        [@ocaml.doc "<p>The ID of the local gateway route table.</p>"]}
    let make ?coip_pool_id  ?(coip_address_usages= []) 
      ?local_gateway_route_table_id  () =
      { coip_pool_id; coip_address_usages; local_gateway_route_table_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_id
              (fun f ->
                 Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)));
           Some
             (Query.Pair
                ("CoipAddressUsageSet",
                  (CoipAddressUsageSet.to_query v.coip_address_usages)));
           Util.option_map v.coip_pool_id
             (fun f -> Query.Pair ("CoipPoolId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_id
              (fun f -> ("local_gateway_route_table_id", (String.to_json f)));
           Some
             ("coip_address_usages",
               (CoipAddressUsageSet.to_json v.coip_address_usages));
           Util.option_map v.coip_pool_id
             (fun f -> ("coip_pool_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          coip_pool_id =
            (Util.option_bind (Xml.member "coipPoolId" xml) String.parse);
          coip_address_usages =
            (Util.of_option []
               (Util.option_bind (Xml.member "coipAddressUsageSet" xml)
                  CoipAddressUsageSet.parse));
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.coip_pool_id
                (fun f ->
                   Ezxmlm.make_tag "coipPoolId" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "coipAddressUsageSet"
                       ([], (CoipAddressUsageSet.to_xml [x]))))
               v.coip_address_usages))
           @
           [Util.option_map v.local_gateway_route_table_id
              (fun f ->
                 Ezxmlm.make_tag "localGatewayRouteTableId"
                   ([], (String.to_xml f)))])
  end
module ImportKeyPairResult =
  struct
    type t =
      {
      key_fingerprint: String.t option
        [@ocaml.doc
          "<p>The MD5 public key fingerprint as specified in section 4 of RFC 4716.</p>"];
      key_name: String.t option
        [@ocaml.doc "<p>The key pair name you provided.</p>"]}
    let make ?key_fingerprint  ?key_name  () = { key_fingerprint; key_name }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.key_name
              (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.key_fingerprint
             (fun f -> Query.Pair ("KeyFingerprint", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.key_name
              (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.key_fingerprint
             (fun f -> ("key_fingerprint", (String.to_json f)))])
    let parse xml =
      Some
        {
          key_fingerprint =
            (Util.option_bind (Xml.member "keyFingerprint" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.key_fingerprint
               (fun f ->
                  Ezxmlm.make_tag "keyFingerprint" ([], (String.to_xml f)))])
           @
           [Util.option_map v.key_name
              (fun f -> Ezxmlm.make_tag "keyName" ([], (String.to_xml f)))])
  end
module DescribeStaleSecurityGroupsResult =
  struct
    type t =
      {
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>"];
      stale_security_group_set: StaleSecurityGroupSet.t
        [@ocaml.doc "<p>Information about the stale security groups.</p>"]}
    let make ?next_token  ?(stale_security_group_set= [])  () =
      { next_token; stale_security_group_set }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("StaleSecurityGroupSet",
                   (StaleSecurityGroupSet.to_query v.stale_security_group_set)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("stale_security_group_set",
                (StaleSecurityGroupSet.to_json v.stale_security_group_set));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          stale_security_group_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "staleSecurityGroupSet" xml)
                  StaleSecurityGroupSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "staleSecurityGroupSet"
                      ([], (StaleSecurityGroupSet.to_xml [x]))))
              v.stale_security_group_set))
  end
module DescribeSecurityGroupReferencesResult =
  struct
    type t =
      {
      security_group_reference_set: SecurityGroupReferences.t
        [@ocaml.doc
          "<p>Information about the VPCs with the referencing security groups.</p>"]}
    let make ?(security_group_reference_set= [])  () =
      { security_group_reference_set }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SecurityGroupReferenceSet",
                   (SecurityGroupReferences.to_query
                      v.security_group_reference_set)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("security_group_reference_set",
                (SecurityGroupReferences.to_json
                   v.security_group_reference_set))])
    let parse xml =
      Some
        {
          security_group_reference_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupReferenceSet" xml)
                  SecurityGroupReferences.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "securityGroupReferenceSet"
                      ([], (SecurityGroupReferences.to_xml [x]))))
              v.security_group_reference_set))
  end
module CreateVpnConnectionResult =
  struct
    type t =
      {
      vpn_connection: VpnConnection.t option
        [@ocaml.doc "<p>Information about the VPN connection.</p>"]}[@@ocaml.doc
                                                                    "<p>Contains the output of CreateVpnConnection.</p>"]
    let make ?vpn_connection  () = { vpn_connection }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f ->
                 Query.Pair ("VpnConnection", (VpnConnection.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f -> ("vpn_connection", (VpnConnection.to_json f)))])
    let parse xml =
      Some
        {
          vpn_connection =
            (Util.option_bind (Xml.member "vpnConnection" xml)
               VpnConnection.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpn_connection
              (fun f ->
                 Ezxmlm.make_tag "vpnConnection"
                   ([], (VpnConnection.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of CreateVpnConnection.</p>"]
module KeyPair =
  struct
    type t =
      {
      key_fingerprint: String.t
        [@ocaml.doc
          "<p>The SHA-1 digest of the DER encoded private key.</p>"];
      key_material: String.t
        [@ocaml.doc "<p>An unencrypted PEM encoded RSA private key.</p>"];
      key_name: String.t [@ocaml.doc "<p>The name of the key pair.</p>"];
      key_pair_id: String.t option
        [@ocaml.doc "<p>The ID of the key pair.</p>"]}[@@ocaml.doc
                                                        "<p>Describes a key pair.</p>"]
    let make ~key_fingerprint  ~key_material  ~key_name  ?key_pair_id  () =
      { key_fingerprint; key_material; key_name; key_pair_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.key_pair_id
              (fun f -> Query.Pair ("KeyPairId", (String.to_query f)));
           Some (Query.Pair ("KeyName", (String.to_query v.key_name)));
           Some
             (Query.Pair ("KeyMaterial", (String.to_query v.key_material)));
           Some
             (Query.Pair
                ("KeyFingerprint", (String.to_query v.key_fingerprint)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.key_pair_id
              (fun f -> ("key_pair_id", (String.to_json f)));
           Some ("key_name", (String.to_json v.key_name));
           Some ("key_material", (String.to_json v.key_material));
           Some ("key_fingerprint", (String.to_json v.key_fingerprint))])
    let parse xml =
      Some
        {
          key_fingerprint =
            (Xml.required "keyFingerprint"
               (Util.option_bind (Xml.member "keyFingerprint" xml)
                  String.parse));
          key_material =
            (Xml.required "keyMaterial"
               (Util.option_bind (Xml.member "keyMaterial" xml) String.parse));
          key_name =
            (Xml.required "keyName"
               (Util.option_bind (Xml.member "keyName" xml) String.parse));
          key_pair_id =
            (Util.option_bind (Xml.member "keyPairId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "keyFingerprint"
                    ([], (String.to_xml v.key_fingerprint)))])
             @
             [Some
                (Ezxmlm.make_tag "keyMaterial"
                   ([], (String.to_xml v.key_material)))])
            @
            [Some
               (Ezxmlm.make_tag "keyName" ([], (String.to_xml v.key_name)))])
           @
           [Util.option_map v.key_pair_id
              (fun f -> Ezxmlm.make_tag "keyPairId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Describes a key pair.</p>"]
module AssignPrivateIpAddressesResult =
  struct
    type t =
      {
      network_interface_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface.</p>"];
      assigned_private_ip_addresses: AssignedPrivateIpAddressList.t
        [@ocaml.doc
          "<p>The private IP addresses assigned to the network interface.</p>"]}
    let make ?network_interface_id  ?(assigned_private_ip_addresses= [])  ()
      = { network_interface_id; assigned_private_ip_addresses }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AssignedPrivateIpAddressesSet",
                   (AssignedPrivateIpAddressList.to_query
                      v.assigned_private_ip_addresses)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("assigned_private_ip_addresses",
                (AssignedPrivateIpAddressList.to_json
                   v.assigned_private_ip_addresses));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          assigned_private_ip_addresses =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "assignedPrivateIpAddressesSet" xml)
                  AssignedPrivateIpAddressList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.network_interface_id
               (fun f ->
                  Ezxmlm.make_tag "networkInterfaceId"
                    ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "assignedPrivateIpAddressesSet"
                      ([], (AssignedPrivateIpAddressList.to_xml [x]))))
              v.assigned_private_ip_addresses))
  end
module ModifyInstanceEventStartTimeResult =
  struct
    type t = {
      event: InstanceStatusEvent.t option }
    let make ?event  () = { event }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.event
              (fun f ->
                 Query.Pair ("Event", (InstanceStatusEvent.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.event
              (fun f -> ("event", (InstanceStatusEvent.to_json f)))])
    let parse xml =
      Some
        {
          event =
            (Util.option_bind (Xml.member "event" xml)
               InstanceStatusEvent.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.event
              (fun f ->
                 Ezxmlm.make_tag "event" ([], (InstanceStatusEvent.to_xml f)))])
  end
module RegisterTransitGatewayMulticastGroupMembersResult =
  struct
    type t =
      {
      registered_multicast_group_members:
        TransitGatewayMulticastRegisteredGroupMembers.t option
        [@ocaml.doc
          "<p>Information about the registered transit gateway multicast group members.</p>"]}
    let make ?registered_multicast_group_members  () =
      { registered_multicast_group_members }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.registered_multicast_group_members
              (fun f ->
                 Query.Pair
                   ("RegisteredMulticastGroupMembers",
                     (TransitGatewayMulticastRegisteredGroupMembers.to_query
                        f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.registered_multicast_group_members
              (fun f ->
                 ("registered_multicast_group_members",
                   (TransitGatewayMulticastRegisteredGroupMembers.to_json f)))])
    let parse xml =
      Some
        {
          registered_multicast_group_members =
            (Util.option_bind
               (Xml.member "registeredMulticastGroupMembers" xml)
               TransitGatewayMulticastRegisteredGroupMembers.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.registered_multicast_group_members
              (fun f ->
                 Ezxmlm.make_tag "registeredMulticastGroupMembers"
                   ([],
                     (TransitGatewayMulticastRegisteredGroupMembers.to_xml f)))])
  end
module CreateCustomerGatewayResult =
  struct
    type t =
      {
      customer_gateway: CustomerGateway.t option
        [@ocaml.doc "<p>Information about the customer gateway.</p>"]}
    [@@ocaml.doc "<p>Contains the output of CreateCustomerGateway.</p>"]
    let make ?customer_gateway  () = { customer_gateway }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.customer_gateway
              (fun f ->
                 Query.Pair ("CustomerGateway", (CustomerGateway.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.customer_gateway
              (fun f -> ("customer_gateway", (CustomerGateway.to_json f)))])
    let parse xml =
      Some
        {
          customer_gateway =
            (Util.option_bind (Xml.member "customerGateway" xml)
               CustomerGateway.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.customer_gateway
              (fun f ->
                 Ezxmlm.make_tag "customerGateway"
                   ([], (CustomerGateway.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of CreateCustomerGateway.</p>"]
module ModifyReservedInstancesResult =
  struct
    type t =
      {
      reserved_instances_modification_id: String.t option
        [@ocaml.doc "<p>The ID for the modification.</p>"]}[@@ocaml.doc
                                                             "<p>Contains the output of ModifyReservedInstances.</p>"]
    let make ?reserved_instances_modification_id  () =
      { reserved_instances_modification_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_modification_id
              (fun f ->
                 Query.Pair
                   ("ReservedInstancesModificationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_modification_id
              (fun f ->
                 ("reserved_instances_modification_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          reserved_instances_modification_id =
            (Util.option_bind
               (Xml.member "reservedInstancesModificationId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.reserved_instances_modification_id
              (fun f ->
                 Ezxmlm.make_tag "reservedInstancesModificationId"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of ModifyReservedInstances.</p>"]
module DescribeLocalGatewayRouteTableVpcAssociationsResult =
  struct
    type t =
      {
      local_gateway_route_table_vpc_associations:
        LocalGatewayRouteTableVpcAssociationSet.t
        [@ocaml.doc "<p>Information about the associations.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(local_gateway_route_table_vpc_associations= [])  ?next_token 
      () = { local_gateway_route_table_vpc_associations; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableVpcAssociationSet",
                  (LocalGatewayRouteTableVpcAssociationSet.to_query
                     v.local_gateway_route_table_vpc_associations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateway_route_table_vpc_associations",
               (LocalGatewayRouteTableVpcAssociationSet.to_json
                  v.local_gateway_route_table_vpc_associations))])
    let parse xml =
      Some
        {
          local_gateway_route_table_vpc_associations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "localGatewayRouteTableVpcAssociationSet" xml)
                  LocalGatewayRouteTableVpcAssociationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag
                       "localGatewayRouteTableVpcAssociationSet"
                       ([],
                         (LocalGatewayRouteTableVpcAssociationSet.to_xml [x]))))
               v.local_gateway_route_table_vpc_associations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module ModifyVolumeResult =
  struct
    type t =
      {
      volume_modification: VolumeModification.t option
        [@ocaml.doc "<p>Information about the volume modification.</p>"]}
    let make ?volume_modification  () = { volume_modification }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_modification
              (fun f ->
                 Query.Pair
                   ("VolumeModification", (VolumeModification.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_modification
              (fun f ->
                 ("volume_modification", (VolumeModification.to_json f)))])
    let parse xml =
      Some
        {
          volume_modification =
            (Util.option_bind (Xml.member "volumeModification" xml)
               VolumeModification.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.volume_modification
              (fun f ->
                 Ezxmlm.make_tag "volumeModification"
                   ([], (VolumeModification.to_xml f)))])
  end
module ImportSnapshotResult =
  struct
    type t =
      {
      description: String.t option
        [@ocaml.doc "<p>A description of the import snapshot task.</p>"];
      import_task_id: String.t option
        [@ocaml.doc "<p>The ID of the import snapshot task.</p>"];
      snapshot_task_detail: SnapshotTaskDetail.t option
        [@ocaml.doc "<p>Information about the import snapshot task.</p>"]}
    let make ?description  ?import_task_id  ?snapshot_task_detail  () =
      { description; import_task_id; snapshot_task_detail }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.snapshot_task_detail
              (fun f ->
                 Query.Pair
                   ("SnapshotTaskDetail", (SnapshotTaskDetail.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.snapshot_task_detail
              (fun f ->
                 ("snapshot_task_detail", (SnapshotTaskDetail.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          snapshot_task_detail =
            (Util.option_bind (Xml.member "snapshotTaskDetail" xml)
               SnapshotTaskDetail.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
            @
            [Util.option_map v.import_task_id
               (fun f ->
                  Ezxmlm.make_tag "importTaskId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.snapshot_task_detail
              (fun f ->
                 Ezxmlm.make_tag "snapshotTaskDetail"
                   ([], (SnapshotTaskDetail.to_xml f)))])
  end
module DescribeVolumesResult =
  struct
    type t =
      {
      volumes: VolumeList.t
        [@ocaml.doc "<p>Information about the volumes.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The <code>NextToken</code> value to include in a future <code>DescribeVolumes</code> request. When the results of a <code>DescribeVolumes</code> request exceed <code>MaxResults</code>, this value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(volumes= [])  ?next_token  () = { volumes; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("VolumeSet", (VolumeList.to_query v.volumes)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("volumes", (VolumeList.to_json v.volumes))])
    let parse xml =
      Some
        {
          volumes =
            (Util.of_option []
               (Util.option_bind (Xml.member "volumeSet" xml)
                  VolumeList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "volumeSet"
                       ([], (VolumeList.to_xml [x])))) v.volumes))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeClientVpnConnectionsResult =
  struct
    type t =
      {
      connections: ClientVpnConnectionSet.t
        [@ocaml.doc
          "<p>Information about the active and terminated client connections.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(connections= [])  ?next_token  () =
      { connections; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("Connections",
                  (ClientVpnConnectionSet.to_query v.connections)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("connections", (ClientVpnConnectionSet.to_json v.connections))])
    let parse xml =
      Some
        {
          connections =
            (Util.of_option []
               (Util.option_bind (Xml.member "connections" xml)
                  ClientVpnConnectionSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "connections"
                       ([], (ClientVpnConnectionSet.to_xml [x]))))
               v.connections))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeFleetInstancesResult =
  struct
    type t =
      {
      active_instances: ActiveInstanceSet.t
        [@ocaml.doc
          "<p>The running instances. This list is refreshed periodically and might be out of date.</p>"];
      next_token: String.t option
        [@ocaml.doc "<p>The token for the next set of results.</p>"];
      fleet_id: String.t option
        [@ocaml.doc "<p>The ID of the EC2 Fleet.</p>"]}
    let make ?(active_instances= [])  ?next_token  ?fleet_id  () =
      { active_instances; next_token; fleet_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> Query.Pair ("FleetId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ActiveInstanceSet",
                  (ActiveInstanceSet.to_query v.active_instances)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> ("fleet_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("active_instances",
               (ActiveInstanceSet.to_json v.active_instances))])
    let parse xml =
      Some
        {
          active_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "activeInstanceSet" xml)
                  ActiveInstanceSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "activeInstanceSet"
                        ([], (ActiveInstanceSet.to_xml [x]))))
                v.active_instances))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.fleet_id
              (fun f -> Ezxmlm.make_tag "fleetId" ([], (String.to_xml f)))])
  end
module AttachNetworkInterfaceResult =
  struct
    type t =
      {
      attachment_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface attachment.</p>"]}
    [@@ocaml.doc "<p>Contains the output of AttachNetworkInterface.</p>"]
    let make ?attachment_id  () = { attachment_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.attachment_id
              (fun f -> Query.Pair ("AttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.attachment_id
              (fun f -> ("attachment_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          attachment_id =
            (Util.option_bind (Xml.member "attachmentId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.attachment_id
              (fun f ->
                 Ezxmlm.make_tag "attachmentId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of AttachNetworkInterface.</p>"]
module DescribeLocalGatewayRouteTablesResult =
  struct
    type t =
      {
      local_gateway_route_tables: LocalGatewayRouteTableSet.t
        [@ocaml.doc
          "<p>Information about the local gateway route tables.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(local_gateway_route_tables= [])  ?next_token  () =
      { local_gateway_route_tables; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableSet",
                  (LocalGatewayRouteTableSet.to_query
                     v.local_gateway_route_tables)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateway_route_tables",
               (LocalGatewayRouteTableSet.to_json
                  v.local_gateway_route_tables))])
    let parse xml =
      Some
        {
          local_gateway_route_tables =
            (Util.of_option []
               (Util.option_bind (Xml.member "localGatewayRouteTableSet" xml)
                  LocalGatewayRouteTableSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "localGatewayRouteTableSet"
                       ([], (LocalGatewayRouteTableSet.to_xml [x]))))
               v.local_gateway_route_tables))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module ModifyVpnTunnelOptionsResult =
  struct
    type t = {
      vpn_connection: VpnConnection.t option }
    let make ?vpn_connection  () = { vpn_connection }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f ->
                 Query.Pair ("VpnConnection", (VpnConnection.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f -> ("vpn_connection", (VpnConnection.to_json f)))])
    let parse xml =
      Some
        {
          vpn_connection =
            (Util.option_bind (Xml.member "vpnConnection" xml)
               VpnConnection.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpn_connection
              (fun f ->
                 Ezxmlm.make_tag "vpnConnection"
                   ([], (VpnConnection.to_xml f)))])
  end
module DeleteTransitGatewayPeeringAttachmentResult =
  struct
    type t =
      {
      transit_gateway_peering_attachment:
        TransitGatewayPeeringAttachment.t option
        [@ocaml.doc "<p>The transit gateway peering attachment.</p>"]}
    let make ?transit_gateway_peering_attachment  () =
      { transit_gateway_peering_attachment }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayPeeringAttachment",
                     (TransitGatewayPeeringAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 ("transit_gateway_peering_attachment",
                   (TransitGatewayPeeringAttachment.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_peering_attachment =
            (Util.option_bind
               (Xml.member "transitGatewayPeeringAttachment" xml)
               TransitGatewayPeeringAttachment.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayPeeringAttachment"
                   ([], (TransitGatewayPeeringAttachment.to_xml f)))])
  end
module DescribeRegionsResult =
  struct
    type t =
      {
      regions: RegionList.t
        [@ocaml.doc "<p>Information about the Regions.</p>"]}
    let make ?(regions= [])  () = { regions }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("RegionInfo", (RegionList.to_query v.regions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("regions", (RegionList.to_json v.regions))])
    let parse xml =
      Some
        {
          regions =
            (Util.of_option []
               (Util.option_bind (Xml.member "regionInfo" xml)
                  RegionList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "regionInfo"
                      ([], (RegionList.to_xml [x])))) v.regions))
  end
module ExportImageResult =
  struct
    type t =
      {
      description: String.t option
        [@ocaml.doc "<p>A description of the image being exported.</p>"];
      disk_image_format: DiskImageFormat.t option
        [@ocaml.doc "<p>The disk image format for the exported image.</p>"];
      export_image_task_id: String.t option
        [@ocaml.doc "<p>The ID of the export image task.</p>"];
      image_id: String.t option [@ocaml.doc "<p>The ID of the image.</p>"];
      role_name: String.t option
        [@ocaml.doc
          "<p>The name of the role that grants VM Import/Export permission to export images to your S3 bucket.</p>"];
      progress: String.t option
        [@ocaml.doc "<p>The percent complete of the export image task.</p>"];
      s3_export_location: ExportTaskS3Location.t option
        [@ocaml.doc "<p>Information about the destination S3 bucket.</p>"];
      status: String.t option
        [@ocaml.doc
          "<p>The status of the export image task. The possible values are <code>active</code>, <code>completed</code>, <code>deleting</code>, and <code>deleted</code>.</p>"];
      status_message: String.t option
        [@ocaml.doc "<p>The status message for the export image task.</p>"]}
    let make ?description  ?disk_image_format  ?export_image_task_id 
      ?image_id  ?role_name  ?progress  ?s3_export_location  ?status 
      ?status_message  () =
      {
        description;
        disk_image_format;
        export_image_task_id;
        image_id;
        role_name;
        progress;
        s3_export_location;
        status;
        status_message
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.s3_export_location
             (fun f ->
                Query.Pair
                  ("S3ExportLocation", (ExportTaskS3Location.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.role_name
             (fun f -> Query.Pair ("RoleName", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.export_image_task_id
             (fun f -> Query.Pair ("ExportImageTaskId", (String.to_query f)));
           Util.option_map v.disk_image_format
             (fun f ->
                Query.Pair ("DiskImageFormat", (DiskImageFormat.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.s3_export_location
             (fun f ->
                ("s3_export_location", (ExportTaskS3Location.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.role_name
             (fun f -> ("role_name", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.export_image_task_id
             (fun f -> ("export_image_task_id", (String.to_json f)));
           Util.option_map v.disk_image_format
             (fun f -> ("disk_image_format", (DiskImageFormat.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          disk_image_format =
            (Util.option_bind (Xml.member "diskImageFormat" xml)
               DiskImageFormat.parse);
          export_image_task_id =
            (Util.option_bind (Xml.member "exportImageTaskId" xml)
               String.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          role_name =
            (Util.option_bind (Xml.member "roleName" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          s3_export_location =
            (Util.option_bind (Xml.member "s3ExportLocation" xml)
               ExportTaskS3Location.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.description
                      (fun f ->
                         Ezxmlm.make_tag "description"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.disk_image_format
                     (fun f ->
                        Ezxmlm.make_tag "diskImageFormat"
                          ([], (DiskImageFormat.to_xml f)))])
                 @
                 [Util.option_map v.export_image_task_id
                    (fun f ->
                       Ezxmlm.make_tag "exportImageTaskId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.image_id
                   (fun f ->
                      Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.role_name
                  (fun f ->
                     Ezxmlm.make_tag "roleName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.progress
                 (fun f -> Ezxmlm.make_tag "progress" ([], (String.to_xml f)))])
             @
             [Util.option_map v.s3_export_location
                (fun f ->
                   Ezxmlm.make_tag "s3ExportLocation"
                     ([], (ExportTaskS3Location.to_xml f)))])
            @
            [Util.option_map v.status
               (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status_message
              (fun f ->
                 Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
  end
module CreateDhcpOptionsResult =
  struct
    type t =
      {
      dhcp_options: DhcpOptions.t option
        [@ocaml.doc "<p>A set of DHCP options.</p>"]}
    let make ?dhcp_options  () = { dhcp_options }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dhcp_options
              (fun f -> Query.Pair ("DhcpOptions", (DhcpOptions.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dhcp_options
              (fun f -> ("dhcp_options", (DhcpOptions.to_json f)))])
    let parse xml =
      Some
        {
          dhcp_options =
            (Util.option_bind (Xml.member "dhcpOptions" xml)
               DhcpOptions.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.dhcp_options
              (fun f ->
                 Ezxmlm.make_tag "dhcpOptions" ([], (DhcpOptions.to_xml f)))])
  end
module ConfirmProductInstanceResult =
  struct
    type t =
      {
      owner_id: String.t option
        [@ocaml.doc
          "<p>The AWS account ID of the instance owner. This is only present if the product code is attached to the instance.</p>"];
      return: Boolean.t option
        [@ocaml.doc
          "<p>The return value of the request. Returns <code>true</code> if the specified product code is owned by the requester and associated with the specified instance.</p>"]}
    let make ?owner_id  ?return  () = { owner_id; return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.owner_id
               (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module DeleteTransitGatewayRouteTableResult =
  struct
    type t =
      {
      transit_gateway_route_table: TransitGatewayRouteTable.t option
        [@ocaml.doc
          "<p>Information about the deleted transit gateway route table.</p>"]}
    let make ?transit_gateway_route_table  () =
      { transit_gateway_route_table }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_route_table
              (fun f ->
                 Query.Pair
                   ("TransitGatewayRouteTable",
                     (TransitGatewayRouteTable.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_route_table
              (fun f ->
                 ("transit_gateway_route_table",
                   (TransitGatewayRouteTable.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_route_table =
            (Util.option_bind (Xml.member "transitGatewayRouteTable" xml)
               TransitGatewayRouteTable.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_route_table
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayRouteTable"
                   ([], (TransitGatewayRouteTable.to_xml f)))])
  end
module AssociateVpcCidrBlockResult =
  struct
    type t =
      {
      ipv6_cidr_block_association: VpcIpv6CidrBlockAssociation.t option
        [@ocaml.doc
          "<p>Information about the IPv6 CIDR block association.</p>"];
      cidr_block_association: VpcCidrBlockAssociation.t option
        [@ocaml.doc
          "<p>Information about the IPv4 CIDR block association.</p>"];
      vpc_id: String.t option [@ocaml.doc "<p>The ID of the VPC.</p>"]}
    let make ?ipv6_cidr_block_association  ?cidr_block_association  ?vpc_id 
      () = { ipv6_cidr_block_association; cidr_block_association; vpc_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.cidr_block_association
             (fun f ->
                Query.Pair
                  ("CidrBlockAssociation",
                    (VpcCidrBlockAssociation.to_query f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockAssociation",
                    (VpcIpv6CidrBlockAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.cidr_block_association
             (fun f ->
                ("cidr_block_association",
                  (VpcCidrBlockAssociation.to_json f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                ("ipv6_cidr_block_association",
                  (VpcIpv6CidrBlockAssociation.to_json f)))])
    let parse xml =
      Some
        {
          ipv6_cidr_block_association =
            (Util.option_bind (Xml.member "ipv6CidrBlockAssociation" xml)
               VpcIpv6CidrBlockAssociation.parse);
          cidr_block_association =
            (Util.option_bind (Xml.member "cidrBlockAssociation" xml)
               VpcCidrBlockAssociation.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.ipv6_cidr_block_association
                (fun f ->
                   Ezxmlm.make_tag "ipv6CidrBlockAssociation"
                     ([], (VpcIpv6CidrBlockAssociation.to_xml f)))])
            @
            [Util.option_map v.cidr_block_association
               (fun f ->
                  Ezxmlm.make_tag "cidrBlockAssociation"
                    ([], (VpcCidrBlockAssociation.to_xml f)))])
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
  end
module DescribeAddressesResult =
  struct
    type t =
      {
      addresses: AddressList.t
        [@ocaml.doc "<p>Information about the Elastic IP addresses.</p>"]}
    let make ?(addresses= [])  () = { addresses }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AddressesSet", (AddressList.to_query v.addresses)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("addresses", (AddressList.to_json v.addresses))])
    let parse xml =
      Some
        {
          addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "addressesSet" xml)
                  AddressList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "addressesSet"
                      ([], (AddressList.to_xml [x])))) v.addresses))
  end
module DescribeInstanceTypesResult =
  struct
    type t =
      {
      instance_types: InstanceTypeInfoList.t
        [@ocaml.doc
          "<p>The instance type. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html\">Instance Types</a> in the <i>Amazon Elastic Compute Cloud User Guide</i>.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(instance_types= [])  ?next_token  () =
      { instance_types; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceTypeSet",
                  (InstanceTypeInfoList.to_query v.instance_types)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_types",
               (InstanceTypeInfoList.to_json v.instance_types))])
    let parse xml =
      Some
        {
          instance_types =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceTypeSet" xml)
                  InstanceTypeInfoList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "instanceTypeSet"
                       ([], (InstanceTypeInfoList.to_xml [x]))))
               v.instance_types))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module CreateSubnetResult =
  struct
    type t =
      {
      subnet: Subnet.t option
        [@ocaml.doc "<p>Information about the subnet.</p>"]}
    let make ?subnet  () = { subnet }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> Query.Pair ("Subnet", (Subnet.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> ("subnet", (Subnet.to_json f)))])
    let parse xml =
      Some
        { subnet = (Util.option_bind (Xml.member "subnet" xml) Subnet.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.subnet
              (fun f -> Ezxmlm.make_tag "subnet" ([], (Subnet.to_xml f)))])
  end
module DescribeClientVpnRoutesResult =
  struct
    type t =
      {
      routes: ClientVpnRouteSet.t
        [@ocaml.doc
          "<p>Information about the Client VPN endpoint routes.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(routes= [])  ?next_token  () = { routes; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair ("Routes", (ClientVpnRouteSet.to_query v.routes)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("routes", (ClientVpnRouteSet.to_json v.routes))])
    let parse xml =
      Some
        {
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routes" xml)
                  ClientVpnRouteSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "routes"
                       ([], (ClientVpnRouteSet.to_xml [x])))) v.routes))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module ApplySecurityGroupsToClientVpnTargetNetworkResult =
  struct
    type t =
      {
      security_group_ids: ClientVpnSecurityGroupIdSet.t
        [@ocaml.doc "<p>The IDs of the applied security groups.</p>"]}
    let make ?(security_group_ids= [])  () = { security_group_ids }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SecurityGroupIds",
                   (ClientVpnSecurityGroupIdSet.to_query v.security_group_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("security_group_ids",
                (ClientVpnSecurityGroupIdSet.to_json v.security_group_ids))])
    let parse xml =
      Some
        {
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupIds" xml)
                  ClientVpnSecurityGroupIdSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "securityGroupIds"
                      ([], (ClientVpnSecurityGroupIdSet.to_xml [x]))))
              v.security_group_ids))
  end
module DescribeVpnConnectionsResult =
  struct
    type t =
      {
      vpn_connections: VpnConnectionList.t
        [@ocaml.doc "<p>Information about one or more VPN connections.</p>"]}
    [@@ocaml.doc "<p>Contains the output of DescribeVpnConnections.</p>"]
    let make ?(vpn_connections= [])  () = { vpn_connections }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpnConnectionSet",
                   (VpnConnectionList.to_query v.vpn_connections)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpn_connections",
                (VpnConnectionList.to_json v.vpn_connections))])
    let parse xml =
      Some
        {
          vpn_connections =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpnConnectionSet" xml)
                  VpnConnectionList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "vpnConnectionSet"
                      ([], (VpnConnectionList.to_xml [x]))))
              v.vpn_connections))
  end[@@ocaml.doc "<p>Contains the output of DescribeVpnConnections.</p>"]
module DeleteVpcEndpointConnectionNotificationsResult =
  struct
    type t =
      {
      unsuccessful: UnsuccessfulItemSet.t
        [@ocaml.doc
          "<p>Information about the notifications that could not be deleted successfully.</p>"]}
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemSet.to_xml [x])))) v.unsuccessful))
  end
module AcceptTransitGatewayVpcAttachmentResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.t option
        [@ocaml.doc "<p>The VPC attachment.</p>"]}
    let make ?transit_gateway_vpc_attachment  () =
      { transit_gateway_vpc_attachment }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayVpcAttachment",
                     (TransitGatewayVpcAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 ("transit_gateway_vpc_attachment",
                   (TransitGatewayVpcAttachment.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachment =
            (Util.option_bind (Xml.member "transitGatewayVpcAttachment" xml)
               TransitGatewayVpcAttachment.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayVpcAttachment"
                   ([], (TransitGatewayVpcAttachment.to_xml f)))])
  end
module CreateLocalGatewayRouteTableVpcAssociationResult =
  struct
    type t =
      {
      local_gateway_route_table_vpc_association:
        LocalGatewayRouteTableVpcAssociation.t option
        [@ocaml.doc "<p>Information about the association.</p>"]}
    let make ?local_gateway_route_table_vpc_association  () =
      { local_gateway_route_table_vpc_association }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_vpc_association
              (fun f ->
                 Query.Pair
                   ("LocalGatewayRouteTableVpcAssociation",
                     (LocalGatewayRouteTableVpcAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_vpc_association
              (fun f ->
                 ("local_gateway_route_table_vpc_association",
                   (LocalGatewayRouteTableVpcAssociation.to_json f)))])
    let parse xml =
      Some
        {
          local_gateway_route_table_vpc_association =
            (Util.option_bind
               (Xml.member "localGatewayRouteTableVpcAssociation" xml)
               LocalGatewayRouteTableVpcAssociation.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.local_gateway_route_table_vpc_association
              (fun f ->
                 Ezxmlm.make_tag "localGatewayRouteTableVpcAssociation"
                   ([], (LocalGatewayRouteTableVpcAssociation.to_xml f)))])
  end
module GetPasswordDataResult =
  struct
    type t =
      {
      instance_id: String.t
        [@ocaml.doc "<p>The ID of the Windows instance.</p>"];
      password_data: String.t
        [@ocaml.doc
          "<p>The password of the instance. Returns an empty string if the password is not available.</p>"];
      timestamp: DateTime.t
        [@ocaml.doc "<p>The time the data was last updated.</p>"]}
    let make ~instance_id  ~password_data  ~timestamp  () =
      { instance_id; password_data; timestamp }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Timestamp", (DateTime.to_query v.timestamp)));
           Some
             (Query.Pair ("PasswordData", (String.to_query v.password_data)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("timestamp", (DateTime.to_json v.timestamp));
           Some ("password_data", (String.to_json v.password_data));
           Some ("instance_id", (String.to_json v.instance_id))])
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          password_data =
            (Xml.required "passwordData"
               (Util.option_bind (Xml.member "passwordData" xml) String.parse));
          timestamp =
            (Xml.required "timestamp"
               (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "instanceId"
                   ([], (String.to_xml v.instance_id)))])
            @
            [Some
               (Ezxmlm.make_tag "passwordData"
                  ([], (String.to_xml v.password_data)))])
           @
           [Some
              (Ezxmlm.make_tag "timestamp"
                 ([], (DateTime.to_xml v.timestamp)))])
  end
module DescribeClientVpnTargetNetworksResult =
  struct
    type t =
      {
      client_vpn_target_networks: TargetNetworkSet.t
        [@ocaml.doc
          "<p>Information about the associated target networks.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(client_vpn_target_networks= [])  ?next_token  () =
      { client_vpn_target_networks; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnTargetNetworks",
                  (TargetNetworkSet.to_query v.client_vpn_target_networks)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("client_vpn_target_networks",
               (TargetNetworkSet.to_json v.client_vpn_target_networks))])
    let parse xml =
      Some
        {
          client_vpn_target_networks =
            (Util.of_option []
               (Util.option_bind (Xml.member "clientVpnTargetNetworks" xml)
                  TargetNetworkSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "clientVpnTargetNetworks"
                       ([], (TargetNetworkSet.to_xml [x]))))
               v.client_vpn_target_networks))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module ModifyVpcEndpointServicePermissionsResult =
  struct
    type t =
      {
      return_value: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return_value  () = { return_value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> ("return_value", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          return_value =
            (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return_value
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module ImportInstanceResult =
  struct
    type t =
      {
      conversion_task: ConversionTask.t option
        [@ocaml.doc "<p>Information about the conversion task.</p>"]}
    let make ?conversion_task  () = { conversion_task }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.conversion_task
              (fun f ->
                 Query.Pair ("ConversionTask", (ConversionTask.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.conversion_task
              (fun f -> ("conversion_task", (ConversionTask.to_json f)))])
    let parse xml =
      Some
        {
          conversion_task =
            (Util.option_bind (Xml.member "conversionTask" xml)
               ConversionTask.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.conversion_task
              (fun f ->
                 Ezxmlm.make_tag "conversionTask"
                   ([], (ConversionTask.to_xml f)))])
  end
module DescribeVpcPeeringConnectionsResult =
  struct
    type t =
      {
      vpc_peering_connections: VpcPeeringConnectionList.t
        [@ocaml.doc "<p>Information about the VPC peering connections.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(vpc_peering_connections= [])  ?next_token  () =
      { vpc_peering_connections; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("VpcPeeringConnectionSet",
                  (VpcPeeringConnectionList.to_query
                     v.vpc_peering_connections)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("vpc_peering_connections",
               (VpcPeeringConnectionList.to_json v.vpc_peering_connections))])
    let parse xml =
      Some
        {
          vpc_peering_connections =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcPeeringConnectionSet" xml)
                  VpcPeeringConnectionList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "vpcPeeringConnectionSet"
                       ([], (VpcPeeringConnectionList.to_xml [x]))))
               v.vpc_peering_connections))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeNetworkAclsResult =
  struct
    type t =
      {
      network_acls: NetworkAclList.t
        [@ocaml.doc "<p>Information about one or more network ACLs.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(network_acls= [])  ?next_token  () =
      { network_acls; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkAclSet", (NetworkAclList.to_query v.network_acls)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("network_acls", (NetworkAclList.to_json v.network_acls))])
    let parse xml =
      Some
        {
          network_acls =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkAclSet" xml)
                  NetworkAclList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "networkAclSet"
                       ([], (NetworkAclList.to_xml [x])))) v.network_acls))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DeleteTrafficMirrorTargetResult =
  struct
    type t =
      {
      traffic_mirror_target_id: String.t option
        [@ocaml.doc "<p>The ID of the deleted Traffic Mirror target.</p>"]}
    let make ?traffic_mirror_target_id  () = { traffic_mirror_target_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_target_id
              (fun f ->
                 Query.Pair ("TrafficMirrorTargetId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_target_id
              (fun f -> ("traffic_mirror_target_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          traffic_mirror_target_id =
            (Util.option_bind (Xml.member "trafficMirrorTargetId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.traffic_mirror_target_id
              (fun f ->
                 Ezxmlm.make_tag "trafficMirrorTargetId"
                   ([], (String.to_xml f)))])
  end
module DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult =
  struct
    type t =
      {
      local_gateway_route_table_virtual_interface_group_associations:
        LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.t
        [@ocaml.doc "<p>Information about the associations.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make
      ?(local_gateway_route_table_virtual_interface_group_associations= []) 
      ?next_token  () =
      {
        local_gateway_route_table_virtual_interface_group_associations;
        next_token
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet",
                  (LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.to_query
                     v.local_gateway_route_table_virtual_interface_group_associations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateway_route_table_virtual_interface_group_associations",
               (LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.to_json
                  v.local_gateway_route_table_virtual_interface_group_associations))])
    let parse xml =
      Some
        {
          local_gateway_route_table_virtual_interface_group_associations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member
                     "localGatewayRouteTableVirtualInterfaceGroupAssociationSet"
                     xml)
                  LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag
                       "localGatewayRouteTableVirtualInterfaceGroupAssociationSet"
                       ([],
                         (LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.to_xml
                            [x]))))
               v.local_gateway_route_table_virtual_interface_group_associations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module EnableEbsEncryptionByDefaultResult =
  struct
    type t =
      {
      ebs_encryption_by_default: Boolean.t option
        [@ocaml.doc "<p>The updated status of encryption by default.</p>"]}
    let make ?ebs_encryption_by_default  () = { ebs_encryption_by_default }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f ->
                 Query.Pair ("EbsEncryptionByDefault", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f -> ("ebs_encryption_by_default", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          ebs_encryption_by_default =
            (Util.option_bind (Xml.member "ebsEncryptionByDefault" xml)
               Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ebs_encryption_by_default
              (fun f ->
                 Ezxmlm.make_tag "ebsEncryptionByDefault"
                   ([], (Boolean.to_xml f)))])
  end
module CancelSpotFleetRequestsResponse =
  struct
    type t =
      {
      successful_fleet_requests: CancelSpotFleetRequestsSuccessSet.t
        [@ocaml.doc
          "<p>Information about the Spot Fleet requests that are successfully canceled.</p>"];
      unsuccessful_fleet_requests: CancelSpotFleetRequestsErrorSet.t
        [@ocaml.doc
          "<p>Information about the Spot Fleet requests that are not successfully canceled.</p>"]}
    [@@ocaml.doc "<p>Contains the output of CancelSpotFleetRequests.</p>"]
    let make ?(successful_fleet_requests= [])  ?(unsuccessful_fleet_requests=
      [])  () = { successful_fleet_requests; unsuccessful_fleet_requests }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnsuccessfulFleetRequestSet",
                   (CancelSpotFleetRequestsErrorSet.to_query
                      v.unsuccessful_fleet_requests)));
           Some
             (Query.Pair
                ("SuccessfulFleetRequestSet",
                  (CancelSpotFleetRequestsSuccessSet.to_query
                     v.successful_fleet_requests)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful_fleet_requests",
                (CancelSpotFleetRequestsErrorSet.to_json
                   v.unsuccessful_fleet_requests));
           Some
             ("successful_fleet_requests",
               (CancelSpotFleetRequestsSuccessSet.to_json
                  v.successful_fleet_requests))])
    let parse xml =
      Some
        {
          successful_fleet_requests =
            (Util.of_option []
               (Util.option_bind (Xml.member "successfulFleetRequestSet" xml)
                  CancelSpotFleetRequestsSuccessSet.parse));
          unsuccessful_fleet_requests =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "unsuccessfulFleetRequestSet" xml)
                  CancelSpotFleetRequestsErrorSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "successfulFleetRequestSet"
                       ([], (CancelSpotFleetRequestsSuccessSet.to_xml [x]))))
               v.successful_fleet_requests))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessfulFleetRequestSet"
                      ([], (CancelSpotFleetRequestsErrorSet.to_xml [x]))))
              v.unsuccessful_fleet_requests))
  end[@@ocaml.doc "<p>Contains the output of CancelSpotFleetRequests.</p>"]
module DescribeAccountAttributesResult =
  struct
    type t =
      {
      account_attributes: AccountAttributeList.t
        [@ocaml.doc "<p>Information about the account attributes.</p>"]}
    let make ?(account_attributes= [])  () = { account_attributes }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AccountAttributeSet",
                   (AccountAttributeList.to_query v.account_attributes)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("account_attributes",
                (AccountAttributeList.to_json v.account_attributes))])
    let parse xml =
      Some
        {
          account_attributes =
            (Util.of_option []
               (Util.option_bind (Xml.member "accountAttributeSet" xml)
                  AccountAttributeList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "accountAttributeSet"
                      ([], (AccountAttributeList.to_xml [x]))))
              v.account_attributes))
  end
module CreateTransitGatewayPeeringAttachmentResult =
  struct
    type t =
      {
      transit_gateway_peering_attachment:
        TransitGatewayPeeringAttachment.t option
        [@ocaml.doc "<p>The transit gateway peering attachment.</p>"]}
    let make ?transit_gateway_peering_attachment  () =
      { transit_gateway_peering_attachment }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayPeeringAttachment",
                     (TransitGatewayPeeringAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 ("transit_gateway_peering_attachment",
                   (TransitGatewayPeeringAttachment.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_peering_attachment =
            (Util.option_bind
               (Xml.member "transitGatewayPeeringAttachment" xml)
               TransitGatewayPeeringAttachment.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayPeeringAttachment"
                   ([], (TransitGatewayPeeringAttachment.to_xml f)))])
  end
module ReplaceRouteTableAssociationResult =
  struct
    type t =
      {
      new_association_id: String.t option
        [@ocaml.doc "<p>The ID of the new association.</p>"];
      association_state: RouteTableAssociationState.t option
        [@ocaml.doc "<p>The state of the association.</p>"]}
    let make ?new_association_id  ?association_state  () =
      { new_association_id; association_state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 Query.Pair
                   ("AssociationState",
                     (RouteTableAssociationState.to_query f)));
           Util.option_map v.new_association_id
             (fun f -> Query.Pair ("NewAssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 ("association_state",
                   (RouteTableAssociationState.to_json f)));
           Util.option_map v.new_association_id
             (fun f -> ("new_association_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          new_association_id =
            (Util.option_bind (Xml.member "newAssociationId" xml)
               String.parse);
          association_state =
            (Util.option_bind (Xml.member "associationState" xml)
               RouteTableAssociationState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.new_association_id
               (fun f ->
                  Ezxmlm.make_tag "newAssociationId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.association_state
              (fun f ->
                 Ezxmlm.make_tag "associationState"
                   ([], (RouteTableAssociationState.to_xml f)))])
  end
module CreateLocalGatewayRouteResult =
  struct
    type t =
      {
      route: LocalGatewayRoute.t option
        [@ocaml.doc "<p>Information about the route.</p>"]}
    let make ?route  () = { route }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> Query.Pair ("Route", (LocalGatewayRoute.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> ("route", (LocalGatewayRoute.to_json f)))])
    let parse xml =
      Some
        {
          route =
            (Util.option_bind (Xml.member "route" xml)
               LocalGatewayRoute.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.route
              (fun f ->
                 Ezxmlm.make_tag "route" ([], (LocalGatewayRoute.to_xml f)))])
  end
module ModifyVpcPeeringConnectionOptionsResult =
  struct
    type t =
      {
      accepter_peering_connection_options: PeeringConnectionOptions.t option
        [@ocaml.doc
          "<p>Information about the VPC peering connection options for the accepter VPC.</p>"];
      requester_peering_connection_options: PeeringConnectionOptions.t option
        [@ocaml.doc
          "<p>Information about the VPC peering connection options for the requester VPC.</p>"]}
    let make ?accepter_peering_connection_options 
      ?requester_peering_connection_options  () =
      {
        accepter_peering_connection_options;
        requester_peering_connection_options
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.requester_peering_connection_options
              (fun f ->
                 Query.Pair
                   ("RequesterPeeringConnectionOptions",
                     (PeeringConnectionOptions.to_query f)));
           Util.option_map v.accepter_peering_connection_options
             (fun f ->
                Query.Pair
                  ("AccepterPeeringConnectionOptions",
                    (PeeringConnectionOptions.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.requester_peering_connection_options
              (fun f ->
                 ("requester_peering_connection_options",
                   (PeeringConnectionOptions.to_json f)));
           Util.option_map v.accepter_peering_connection_options
             (fun f ->
                ("accepter_peering_connection_options",
                  (PeeringConnectionOptions.to_json f)))])
    let parse xml =
      Some
        {
          accepter_peering_connection_options =
            (Util.option_bind
               (Xml.member "accepterPeeringConnectionOptions" xml)
               PeeringConnectionOptions.parse);
          requester_peering_connection_options =
            (Util.option_bind
               (Xml.member "requesterPeeringConnectionOptions" xml)
               PeeringConnectionOptions.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.accepter_peering_connection_options
               (fun f ->
                  Ezxmlm.make_tag "accepterPeeringConnectionOptions"
                    ([], (PeeringConnectionOptions.to_xml f)))])
           @
           [Util.option_map v.requester_peering_connection_options
              (fun f ->
                 Ezxmlm.make_tag "requesterPeeringConnectionOptions"
                   ([], (PeeringConnectionOptions.to_xml f)))])
  end
module RevokeClientVpnIngressResult =
  struct
    type t =
      {
      status: ClientVpnAuthorizationRuleStatus.t option
        [@ocaml.doc "<p>The current state of the authorization rule.</p>"]}
    let make ?status  () = { status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair
                   ("Status", (ClientVpnAuthorizationRuleStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 ("status", (ClientVpnAuthorizationRuleStatus.to_json f)))])
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnAuthorizationRuleStatus.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status"
                   ([], (ClientVpnAuthorizationRuleStatus.to_xml f)))])
  end
module DeleteTrafficMirrorFilterRuleResult =
  struct
    type t =
      {
      traffic_mirror_filter_rule_id: String.t option
        [@ocaml.doc "<p>The ID of the deleted Traffic Mirror rule.</p>"]}
    let make ?traffic_mirror_filter_rule_id  () =
      { traffic_mirror_filter_rule_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_rule_id
              (fun f ->
                 Query.Pair
                   ("TrafficMirrorFilterRuleId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_rule_id
              (fun f -> ("traffic_mirror_filter_rule_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          traffic_mirror_filter_rule_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterRuleId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.traffic_mirror_filter_rule_id
              (fun f ->
                 Ezxmlm.make_tag "trafficMirrorFilterRuleId"
                   ([], (String.to_xml f)))])
  end
module ModifyDefaultCreditSpecificationResult =
  struct
    type t =
      {
      instance_family_credit_specification:
        InstanceFamilyCreditSpecification.t option
        [@ocaml.doc
          "<p>The default credit option for CPU usage of the instance family.</p>"]}
    let make ?instance_family_credit_specification  () =
      { instance_family_credit_specification }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_family_credit_specification
              (fun f ->
                 Query.Pair
                   ("InstanceFamilyCreditSpecification",
                     (InstanceFamilyCreditSpecification.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_family_credit_specification
              (fun f ->
                 ("instance_family_credit_specification",
                   (InstanceFamilyCreditSpecification.to_json f)))])
    let parse xml =
      Some
        {
          instance_family_credit_specification =
            (Util.option_bind
               (Xml.member "instanceFamilyCreditSpecification" xml)
               InstanceFamilyCreditSpecification.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.instance_family_credit_specification
              (fun f ->
                 Ezxmlm.make_tag "instanceFamilyCreditSpecification"
                   ([], (InstanceFamilyCreditSpecification.to_xml f)))])
  end
module ModifyClientVpnEndpointResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module DescribeVpcEndpointsResult =
  struct
    type t =
      {
      vpc_endpoints: VpcEndpointSet.t
        [@ocaml.doc "<p>Information about the endpoints.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>"]}
    [@@ocaml.doc "<p>Contains the output of DescribeVpcEndpoints.</p>"]
    let make ?(vpc_endpoints= [])  ?next_token  () =
      { vpc_endpoints; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("VpcEndpointSet", (VpcEndpointSet.to_query v.vpc_endpoints)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("vpc_endpoints", (VpcEndpointSet.to_json v.vpc_endpoints))])
    let parse xml =
      Some
        {
          vpc_endpoints =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcEndpointSet" xml)
                  VpcEndpointSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "vpcEndpointSet"
                       ([], (VpcEndpointSet.to_xml [x])))) v.vpc_endpoints))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of DescribeVpcEndpoints.</p>"]
module DescribeClassicLinkInstancesResult =
  struct
    type t =
      {
      instances: ClassicLinkInstanceList.t
        [@ocaml.doc
          "<p>Information about one or more linked EC2-Classic instances.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(instances= [])  ?next_token  () = { instances; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstancesSet",
                  (ClassicLinkInstanceList.to_query v.instances)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("instances", (ClassicLinkInstanceList.to_json v.instances))])
    let parse xml =
      Some
        {
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  ClassicLinkInstanceList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "instancesSet"
                       ([], (ClassicLinkInstanceList.to_xml [x]))))
               v.instances))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module GetHostReservationPurchasePreviewResult =
  struct
    type t =
      {
      currency_code: CurrencyCodeValues.t option
        [@ocaml.doc
          "<p>The currency in which the <code>totalUpfrontPrice</code> and <code>totalHourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>"];
      purchase: PurchaseSet.t
        [@ocaml.doc
          "<p>The purchase information of the Dedicated Host reservation and the Dedicated Hosts associated with it.</p>"];
      total_hourly_price: String.t option
        [@ocaml.doc
          "<p>The potential total hourly price of the reservation per hour.</p>"];
      total_upfront_price: String.t option
        [@ocaml.doc
          "<p>The potential total upfront price. This is billed immediately.</p>"]}
    let make ?currency_code  ?(purchase= [])  ?total_hourly_price 
      ?total_upfront_price  () =
      { currency_code; purchase; total_hourly_price; total_upfront_price }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_upfront_price
              (fun f -> Query.Pair ("TotalUpfrontPrice", (String.to_query f)));
           Util.option_map v.total_hourly_price
             (fun f -> Query.Pair ("TotalHourlyPrice", (String.to_query f)));
           Some (Query.Pair ("Purchase", (PurchaseSet.to_query v.purchase)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_upfront_price
              (fun f -> ("total_upfront_price", (String.to_json f)));
           Util.option_map v.total_hourly_price
             (fun f -> ("total_hourly_price", (String.to_json f)));
           Some ("purchase", (PurchaseSet.to_json v.purchase));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)))])
    let parse xml =
      Some
        {
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          purchase =
            (Util.of_option []
               (Util.option_bind (Xml.member "purchase" xml)
                  PurchaseSet.parse));
          total_hourly_price =
            (Util.option_bind (Xml.member "totalHourlyPrice" xml)
               String.parse);
          total_upfront_price =
            (Util.option_bind (Xml.member "totalUpfrontPrice" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.currency_code
                 (fun f ->
                    Ezxmlm.make_tag "currencyCode"
                      ([], (CurrencyCodeValues.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "purchase"
                        ([], (PurchaseSet.to_xml [x])))) v.purchase))
            @
            [Util.option_map v.total_hourly_price
               (fun f ->
                  Ezxmlm.make_tag "totalHourlyPrice" ([], (String.to_xml f)))])
           @
           [Util.option_map v.total_upfront_price
              (fun f ->
                 Ezxmlm.make_tag "totalUpfrontPrice" ([], (String.to_xml f)))])
  end
module DescribeTransitGatewayAttachmentsResult =
  struct
    type t =
      {
      transit_gateway_attachments: TransitGatewayAttachmentList.t
        [@ocaml.doc "<p>Information about the attachments.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(transit_gateway_attachments= [])  ?next_token  () =
      { transit_gateway_attachments; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachments",
                  (TransitGatewayAttachmentList.to_query
                     v.transit_gateway_attachments)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_attachments",
               (TransitGatewayAttachmentList.to_json
                  v.transit_gateway_attachments))])
    let parse xml =
      Some
        {
          transit_gateway_attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "transitGatewayAttachments" xml)
                  TransitGatewayAttachmentList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "transitGatewayAttachments"
                       ([], (TransitGatewayAttachmentList.to_xml [x]))))
               v.transit_gateway_attachments))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module ModifyVpnTunnelCertificateResult =
  struct
    type t = {
      vpn_connection: VpnConnection.t option }
    let make ?vpn_connection  () = { vpn_connection }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f ->
                 Query.Pair ("VpnConnection", (VpnConnection.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f -> ("vpn_connection", (VpnConnection.to_json f)))])
    let parse xml =
      Some
        {
          vpn_connection =
            (Util.option_bind (Xml.member "vpnConnection" xml)
               VpnConnection.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpn_connection
              (fun f ->
                 Ezxmlm.make_tag "vpnConnection"
                   ([], (VpnConnection.to_xml f)))])
  end
module DescribeSnapshotsResult =
  struct
    type t =
      {
      snapshots: SnapshotList.t
        [@ocaml.doc "<p>Information about the snapshots.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The <code>NextToken</code> value to include in a future <code>DescribeSnapshots</code> request. When the results of a <code>DescribeSnapshots</code> request exceed <code>MaxResults</code>, this value can be used to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(snapshots= [])  ?next_token  () = { snapshots; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair ("SnapshotSet", (SnapshotList.to_query v.snapshots)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("snapshots", (SnapshotList.to_json v.snapshots))])
    let parse xml =
      Some
        {
          snapshots =
            (Util.of_option []
               (Util.option_bind (Xml.member "snapshotSet" xml)
                  SnapshotList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "snapshotSet"
                       ([], (SnapshotList.to_xml [x])))) v.snapshots))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module GetEbsEncryptionByDefaultResult =
  struct
    type t =
      {
      ebs_encryption_by_default: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether encryption by default is enabled.</p>"]}
    let make ?ebs_encryption_by_default  () = { ebs_encryption_by_default }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f ->
                 Query.Pair ("EbsEncryptionByDefault", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f -> ("ebs_encryption_by_default", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          ebs_encryption_by_default =
            (Util.option_bind (Xml.member "ebsEncryptionByDefault" xml)
               Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ebs_encryption_by_default
              (fun f ->
                 Ezxmlm.make_tag "ebsEncryptionByDefault"
                   ([], (Boolean.to_xml f)))])
  end
module AssociateIamInstanceProfileResult =
  struct
    type t =
      {
      iam_instance_profile_association:
        IamInstanceProfileAssociation.t option
        [@ocaml.doc
          "<p>Information about the IAM instance profile association.</p>"]}
    let make ?iam_instance_profile_association  () =
      { iam_instance_profile_association }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 Query.Pair
                   ("IamInstanceProfileAssociation",
                     (IamInstanceProfileAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 ("iam_instance_profile_association",
                   (IamInstanceProfileAssociation.to_json f)))])
    let parse xml =
      Some
        {
          iam_instance_profile_association =
            (Util.option_bind
               (Xml.member "iamInstanceProfileAssociation" xml)
               IamInstanceProfileAssociation.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 Ezxmlm.make_tag "iamInstanceProfileAssociation"
                   ([], (IamInstanceProfileAssociation.to_xml f)))])
  end
module CreateTransitGatewayMulticastDomainResult =
  struct
    type t =
      {
      transit_gateway_multicast_domain:
        TransitGatewayMulticastDomain.t option
        [@ocaml.doc
          "<p>Information about the transit gateway multicast domain.</p>"]}
    let make ?transit_gateway_multicast_domain  () =
      { transit_gateway_multicast_domain }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_multicast_domain
              (fun f ->
                 Query.Pair
                   ("TransitGatewayMulticastDomain",
                     (TransitGatewayMulticastDomain.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_multicast_domain
              (fun f ->
                 ("transit_gateway_multicast_domain",
                   (TransitGatewayMulticastDomain.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomain" xml)
               TransitGatewayMulticastDomain.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_multicast_domain
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayMulticastDomain"
                   ([], (TransitGatewayMulticastDomain.to_xml f)))])
  end
module PurchaseScheduledInstancesResult =
  struct
    type t =
      {
      scheduled_instance_set: PurchasedScheduledInstanceSet.t
        [@ocaml.doc "<p>Information about the Scheduled Instances.</p>"]}
    [@@ocaml.doc "<p>Contains the output of PurchaseScheduledInstances.</p>"]
    let make ?(scheduled_instance_set= [])  () = { scheduled_instance_set }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ScheduledInstanceSet",
                   (PurchasedScheduledInstanceSet.to_query
                      v.scheduled_instance_set)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("scheduled_instance_set",
                (PurchasedScheduledInstanceSet.to_json
                   v.scheduled_instance_set))])
    let parse xml =
      Some
        {
          scheduled_instance_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "scheduledInstanceSet" xml)
                  PurchasedScheduledInstanceSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "scheduledInstanceSet"
                      ([], (PurchasedScheduledInstanceSet.to_xml [x]))))
              v.scheduled_instance_set))
  end[@@ocaml.doc
       "<p>Contains the output of PurchaseScheduledInstances.</p>"]
module CreateFleetResult =
  struct
    type t =
      {
      fleet_id: String.t option
        [@ocaml.doc "<p>The ID of the EC2 Fleet.</p>"];
      errors: CreateFleetErrorsSet.t
        [@ocaml.doc
          "<p>Information about the instances that could not be launched by the fleet. Valid only when <b>Type</b> is set to <code>instant</code>.</p>"];
      instances: CreateFleetInstancesSet.t
        [@ocaml.doc
          "<p>Information about the instances that were launched by the fleet. Valid only when <b>Type</b> is set to <code>instant</code>.</p>"]}
    let make ?fleet_id  ?(errors= [])  ?(instances= [])  () =
      { fleet_id; errors; instances }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FleetInstanceSet",
                   (CreateFleetInstancesSet.to_query v.instances)));
           Some
             (Query.Pair
                ("ErrorSet", (CreateFleetErrorsSet.to_query v.errors)));
           Util.option_map v.fleet_id
             (fun f -> Query.Pair ("FleetId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instances", (CreateFleetInstancesSet.to_json v.instances));
           Some ("errors", (CreateFleetErrorsSet.to_json v.errors));
           Util.option_map v.fleet_id
             (fun f -> ("fleet_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse);
          errors =
            (Util.of_option []
               (Util.option_bind (Xml.member "errorSet" xml)
                  CreateFleetErrorsSet.parse));
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "fleetInstanceSet" xml)
                  CreateFleetInstancesSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.fleet_id
                (fun f -> Ezxmlm.make_tag "fleetId" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "errorSet"
                       ([], (CreateFleetErrorsSet.to_xml [x])))) v.errors))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "fleetInstanceSet"
                      ([], (CreateFleetInstancesSet.to_xml [x]))))
              v.instances))
  end
module CreateSnapshotsResult =
  struct
    type t =
      {
      snapshots: SnapshotSet.t [@ocaml.doc "<p>List of snapshots.</p>"]}
    let make ?(snapshots= [])  () = { snapshots }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("SnapshotSet", (SnapshotSet.to_query v.snapshots)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("snapshots", (SnapshotSet.to_json v.snapshots))])
    let parse xml =
      Some
        {
          snapshots =
            (Util.of_option []
               (Util.option_bind (Xml.member "snapshotSet" xml)
                  SnapshotSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "snapshotSet"
                      ([], (SnapshotSet.to_xml [x])))) v.snapshots))
  end
module DescribeTrafficMirrorTargetsResult =
  struct
    type t =
      {
      traffic_mirror_targets: TrafficMirrorTargetSet.t
        [@ocaml.doc
          "<p>Information about one or more Traffic Mirror targets.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. The value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(traffic_mirror_targets= [])  ?next_token  () =
      { traffic_mirror_targets; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorTargetSet",
                  (TrafficMirrorTargetSet.to_query v.traffic_mirror_targets)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("traffic_mirror_targets",
               (TrafficMirrorTargetSet.to_json v.traffic_mirror_targets))])
    let parse xml =
      Some
        {
          traffic_mirror_targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "trafficMirrorTargetSet" xml)
                  TrafficMirrorTargetSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "trafficMirrorTargetSet"
                       ([], (TrafficMirrorTargetSet.to_xml [x]))))
               v.traffic_mirror_targets))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module EnableVpcClassicLinkDnsSupportResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module CreateClientVpnEndpointResult =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option
        [@ocaml.doc "<p>The ID of the Client VPN endpoint.</p>"];
      status: ClientVpnEndpointStatus.t option
        [@ocaml.doc "<p>The current state of the Client VPN endpoint.</p>"];
      dns_name: String.t option
        [@ocaml.doc
          "<p>The DNS name to be used by clients when establishing their VPN session.</p>"]}
    let make ?client_vpn_endpoint_id  ?status  ?dns_name  () =
      { client_vpn_endpoint_id; status; dns_name }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dns_name
              (fun f -> Query.Pair ("DnsName", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (ClientVpnEndpointStatus.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dns_name
              (fun f -> ("dns_name", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ClientVpnEndpointStatus.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnEndpointStatus.parse);
          dns_name =
            (Util.option_bind (Xml.member "dnsName" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.client_vpn_endpoint_id
                (fun f ->
                   Ezxmlm.make_tag "clientVpnEndpointId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.status
               (fun f ->
                  Ezxmlm.make_tag "status"
                    ([], (ClientVpnEndpointStatus.to_xml f)))])
           @
           [Util.option_map v.dns_name
              (fun f -> Ezxmlm.make_tag "dnsName" ([], (String.to_xml f)))])
  end
module CreateVpcEndpointResult =
  struct
    type t =
      {
      vpc_endpoint: VpcEndpoint.t option
        [@ocaml.doc "<p>Information about the endpoint.</p>"];
      client_token: String.t option
        [@ocaml.doc
          "<p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request.</p>"]}
    [@@ocaml.doc "<p>Contains the output of CreateVpcEndpoint.</p>"]
    let make ?vpc_endpoint  ?client_token  () =
      { vpc_endpoint; client_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.vpc_endpoint
             (fun f -> Query.Pair ("VpcEndpoint", (VpcEndpoint.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.vpc_endpoint
             (fun f -> ("vpc_endpoint", (VpcEndpoint.to_json f)))])
    let parse xml =
      Some
        {
          vpc_endpoint =
            (Util.option_bind (Xml.member "vpcEndpoint" xml)
               VpcEndpoint.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.vpc_endpoint
               (fun f ->
                  Ezxmlm.make_tag "vpcEndpoint" ([], (VpcEndpoint.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of CreateVpcEndpoint.</p>"]
module DescribeVolumesModificationsResult =
  struct
    type t =
      {
      volumes_modifications: VolumeModificationList.t
        [@ocaml.doc "<p>Information about the volume modifications.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>Token for pagination, null if there are no more results </p>"]}
    let make ?(volumes_modifications= [])  ?next_token  () =
      { volumes_modifications; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("VolumeModificationSet",
                  (VolumeModificationList.to_query v.volumes_modifications)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("volumes_modifications",
               (VolumeModificationList.to_json v.volumes_modifications))])
    let parse xml =
      Some
        {
          volumes_modifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "volumeModificationSet" xml)
                  VolumeModificationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "volumeModificationSet"
                       ([], (VolumeModificationList.to_xml [x]))))
               v.volumes_modifications))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module ResetEbsDefaultKmsKeyIdResult =
  struct
    type t =
      {
      kms_key_id: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the default CMK for EBS encryption by default.</p>"]}
    let make ?kms_key_id  () = { kms_key_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> ("kms_key_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.kms_key_id
              (fun f -> Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
  end
module CancelCapacityReservationResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module UpdateSecurityGroupRuleDescriptionsIngressResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module GetConsoleScreenshotResult =
  struct
    type t =
      {
      image_data: String.t option
        [@ocaml.doc "<p>The data that comprises the image.</p>"];
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"]}
    let make ?image_data  ?instance_id  () = { image_data; instance_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.image_data
             (fun f -> Query.Pair ("ImageData", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.image_data
             (fun f -> ("image_data", (String.to_json f)))])
    let parse xml =
      Some
        {
          image_data =
            (Util.option_bind (Xml.member "imageData" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.image_data
               (fun f -> Ezxmlm.make_tag "imageData" ([], (String.to_xml f)))])
           @
           [Util.option_map v.instance_id
              (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
  end
module DescribeNetworkInterfacesResult =
  struct
    type t =
      {
      network_interfaces: NetworkInterfaceList.t
        [@ocaml.doc
          "<p>Information about one or more network interfaces.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    [@@ocaml.doc "<p>Contains the output of DescribeNetworkInterfaces.</p>"]
    let make ?(network_interfaces= [])  ?next_token  () =
      { network_interfaces; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (NetworkInterfaceList.to_query v.network_interfaces)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("network_interfaces",
               (NetworkInterfaceList.to_json v.network_interfaces))])
    let parse xml =
      Some
        {
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  NetworkInterfaceList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "networkInterfaceSet"
                       ([], (NetworkInterfaceList.to_xml [x]))))
               v.network_interfaces))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of DescribeNetworkInterfaces.</p>"]
module DescribeVpcEndpointConnectionNotificationsResult =
  struct
    type t =
      {
      connection_notification_set: ConnectionNotificationSet.t
        [@ocaml.doc "<p>One or more notifications.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(connection_notification_set= [])  ?next_token  () =
      { connection_notification_set; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ConnectionNotificationSet",
                  (ConnectionNotificationSet.to_query
                     v.connection_notification_set)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("connection_notification_set",
               (ConnectionNotificationSet.to_json
                  v.connection_notification_set))])
    let parse xml =
      Some
        {
          connection_notification_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "connectionNotificationSet" xml)
                  ConnectionNotificationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "connectionNotificationSet"
                       ([], (ConnectionNotificationSet.to_xml [x]))))
               v.connection_notification_set))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module CreateImageResult =
  struct
    type t =
      {
      image_id: String.t option [@ocaml.doc "<p>The ID of the new AMI.</p>"]}
    let make ?image_id  () = { image_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> Query.Pair ("ImageId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> ("image_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.image_id
              (fun f -> Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
  end
module RejectTransitGatewayVpcAttachmentResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.t option
        [@ocaml.doc "<p>Information about the attachment.</p>"]}
    let make ?transit_gateway_vpc_attachment  () =
      { transit_gateway_vpc_attachment }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayVpcAttachment",
                     (TransitGatewayVpcAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 ("transit_gateway_vpc_attachment",
                   (TransitGatewayVpcAttachment.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachment =
            (Util.option_bind (Xml.member "transitGatewayVpcAttachment" xml)
               TransitGatewayVpcAttachment.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayVpcAttachment"
                   ([], (TransitGatewayVpcAttachment.to_xml f)))])
  end
module DescribeNetworkInterfaceAttributeResult =
  struct
    type t =
      {
      attachment: NetworkInterfaceAttachment.t option
        [@ocaml.doc
          "<p>The attachment (if any) of the network interface.</p>"];
      description: AttributeValue.t option
        [@ocaml.doc "<p>The description of the network interface.</p>"];
      groups: GroupIdentifierList.t
        [@ocaml.doc
          "<p>The security groups associated with the network interface.</p>"];
      network_interface_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface.</p>"];
      source_dest_check: AttributeBooleanValue.t option
        [@ocaml.doc
          "<p>Indicates whether source/destination checking is enabled.</p>"]}
    [@@ocaml.doc
      "<p>Contains the output of DescribeNetworkInterfaceAttribute.</p>"]
    let make ?attachment  ?description  ?(groups= [])  ?network_interface_id 
      ?source_dest_check  () =
      {
        attachment;
        description;
        groups;
        network_interface_id;
        source_dest_check
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.source_dest_check
              (fun f ->
                 Query.Pair
                   ("SourceDestCheck", (AttributeBooleanValue.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)));
           Util.option_map v.description
             (fun f ->
                Query.Pair ("Description", (AttributeValue.to_query f)));
           Util.option_map v.attachment
             (fun f ->
                Query.Pair
                  ("Attachment", (NetworkInterfaceAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.source_dest_check
              (fun f ->
                 ("source_dest_check", (AttributeBooleanValue.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Some ("groups", (GroupIdentifierList.to_json v.groups));
           Util.option_map v.description
             (fun f -> ("description", (AttributeValue.to_json f)));
           Util.option_map v.attachment
             (fun f -> ("attachment", (NetworkInterfaceAttachment.to_json f)))])
    let parse xml =
      Some
        {
          attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               NetworkInterfaceAttachment.parse);
          description =
            (Util.option_bind (Xml.member "description" xml)
               AttributeValue.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               AttributeBooleanValue.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.attachment
                  (fun f ->
                     Ezxmlm.make_tag "attachment"
                       ([], (NetworkInterfaceAttachment.to_xml f)))])
              @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "description"
                      ([], (AttributeValue.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "groupSet"
                        ([], (GroupIdentifierList.to_xml [x])))) v.groups))
            @
            [Util.option_map v.network_interface_id
               (fun f ->
                  Ezxmlm.make_tag "networkInterfaceId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.source_dest_check
              (fun f ->
                 Ezxmlm.make_tag "sourceDestCheck"
                   ([], (AttributeBooleanValue.to_xml f)))])
  end[@@ocaml.doc
       "<p>Contains the output of DescribeNetworkInterfaceAttribute.</p>"]
module DescribeReservedInstancesResult =
  struct
    type t =
      {
      reserved_instances: ReservedInstancesList.t
        [@ocaml.doc "<p>A list of Reserved Instances.</p>"]}[@@ocaml.doc
                                                              "<p>Contains the output for DescribeReservedInstances.</p>"]
    let make ?(reserved_instances= [])  () = { reserved_instances }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesSet",
                   (ReservedInstancesList.to_query v.reserved_instances)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances",
                (ReservedInstancesList.to_json v.reserved_instances))])
    let parse xml =
      Some
        {
          reserved_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "reservedInstancesSet" xml)
                  ReservedInstancesList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "reservedInstancesSet"
                      ([], (ReservedInstancesList.to_xml [x]))))
              v.reserved_instances))
  end[@@ocaml.doc
       "<p>Contains the output for DescribeReservedInstances.</p>"]
module CreateNatGatewayResult =
  struct
    type t =
      {
      client_token: String.t option
        [@ocaml.doc
          "<p>Unique, case-sensitive identifier to ensure the idempotency of the request. Only returned if a client token was provided in the request.</p>"];
      nat_gateway: NatGateway.t option
        [@ocaml.doc "<p>Information about the NAT gateway.</p>"]}
    let make ?client_token  ?nat_gateway  () = { client_token; nat_gateway }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.nat_gateway
              (fun f -> Query.Pair ("NatGateway", (NatGateway.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.nat_gateway
              (fun f -> ("nat_gateway", (NatGateway.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          nat_gateway =
            (Util.option_bind (Xml.member "natGateway" xml) NatGateway.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.client_token
               (fun f ->
                  Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.nat_gateway
              (fun f ->
                 Ezxmlm.make_tag "natGateway" ([], (NatGateway.to_xml f)))])
  end
module DescribeTransitGatewayPeeringAttachmentsResult =
  struct
    type t =
      {
      transit_gateway_peering_attachments:
        TransitGatewayPeeringAttachmentList.t
        [@ocaml.doc "<p>The transit gateway peering attachments.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(transit_gateway_peering_attachments= [])  ?next_token  () =
      { transit_gateway_peering_attachments; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayPeeringAttachments",
                  (TransitGatewayPeeringAttachmentList.to_query
                     v.transit_gateway_peering_attachments)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_peering_attachments",
               (TransitGatewayPeeringAttachmentList.to_json
                  v.transit_gateway_peering_attachments))])
    let parse xml =
      Some
        {
          transit_gateway_peering_attachments =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "transitGatewayPeeringAttachments" xml)
                  TransitGatewayPeeringAttachmentList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "transitGatewayPeeringAttachments"
                       ([], (TransitGatewayPeeringAttachmentList.to_xml [x]))))
               v.transit_gateway_peering_attachments))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module CancelSpotInstanceRequestsResult =
  struct
    type t =
      {
      cancelled_spot_instance_requests: CancelledSpotInstanceRequestList.t
        [@ocaml.doc "<p>One or more Spot Instance requests.</p>"]}[@@ocaml.doc
                                                                    "<p>Contains the output of CancelSpotInstanceRequests.</p>"]
    let make ?(cancelled_spot_instance_requests= [])  () =
      { cancelled_spot_instance_requests }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotInstanceRequestSet",
                   (CancelledSpotInstanceRequestList.to_query
                      v.cancelled_spot_instance_requests)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("cancelled_spot_instance_requests",
                (CancelledSpotInstanceRequestList.to_json
                   v.cancelled_spot_instance_requests))])
    let parse xml =
      Some
        {
          cancelled_spot_instance_requests =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotInstanceRequestSet" xml)
                  CancelledSpotInstanceRequestList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "spotInstanceRequestSet"
                      ([], (CancelledSpotInstanceRequestList.to_xml [x]))))
              v.cancelled_spot_instance_requests))
  end[@@ocaml.doc
       "<p>Contains the output of CancelSpotInstanceRequests.</p>"]
module CreateSpotDatafeedSubscriptionResult =
  struct
    type t =
      {
      spot_datafeed_subscription: SpotDatafeedSubscription.t option
        [@ocaml.doc "<p>The Spot Instance data feed subscription.</p>"]}
    [@@ocaml.doc
      "<p>Contains the output of CreateSpotDatafeedSubscription.</p>"]
    let make ?spot_datafeed_subscription  () = { spot_datafeed_subscription }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 Query.Pair
                   ("SpotDatafeedSubscription",
                     (SpotDatafeedSubscription.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 ("spot_datafeed_subscription",
                   (SpotDatafeedSubscription.to_json f)))])
    let parse xml =
      Some
        {
          spot_datafeed_subscription =
            (Util.option_bind (Xml.member "spotDatafeedSubscription" xml)
               SpotDatafeedSubscription.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 Ezxmlm.make_tag "spotDatafeedSubscription"
                   ([], (SpotDatafeedSubscription.to_xml f)))])
  end[@@ocaml.doc
       "<p>Contains the output of CreateSpotDatafeedSubscription.</p>"]
module DescribeVpcEndpointServiceConfigurationsResult =
  struct
    type t =
      {
      service_configurations: ServiceConfigurationSet.t
        [@ocaml.doc "<p>Information about one or more services.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(service_configurations= [])  ?next_token  () =
      { service_configurations; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ServiceConfigurationSet",
                  (ServiceConfigurationSet.to_query v.service_configurations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("service_configurations",
               (ServiceConfigurationSet.to_json v.service_configurations))])
    let parse xml =
      Some
        {
          service_configurations =
            (Util.of_option []
               (Util.option_bind (Xml.member "serviceConfigurationSet" xml)
                  ServiceConfigurationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "serviceConfigurationSet"
                       ([], (ServiceConfigurationSet.to_xml [x]))))
               v.service_configurations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeConversionTasksResult =
  struct
    type t =
      {
      conversion_tasks: DescribeConversionTaskList.t
        [@ocaml.doc "<p>Information about the conversion tasks.</p>"]}
    let make ?(conversion_tasks= [])  () = { conversion_tasks }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ConversionTasks",
                   (DescribeConversionTaskList.to_query v.conversion_tasks)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("conversion_tasks",
                (DescribeConversionTaskList.to_json v.conversion_tasks))])
    let parse xml =
      Some
        {
          conversion_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "conversionTasks" xml)
                  DescribeConversionTaskList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "conversionTasks"
                      ([], (DescribeConversionTaskList.to_xml [x]))))
              v.conversion_tasks))
  end
module DescribeTransitGatewayVpcAttachmentsResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachments: TransitGatewayVpcAttachmentList.t
        [@ocaml.doc "<p>Information about the VPC attachments.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(transit_gateway_vpc_attachments= [])  ?next_token  () =
      { transit_gateway_vpc_attachments; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayVpcAttachments",
                  (TransitGatewayVpcAttachmentList.to_query
                     v.transit_gateway_vpc_attachments)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_vpc_attachments",
               (TransitGatewayVpcAttachmentList.to_json
                  v.transit_gateway_vpc_attachments))])
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachments =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "transitGatewayVpcAttachments" xml)
                  TransitGatewayVpcAttachmentList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "transitGatewayVpcAttachments"
                       ([], (TransitGatewayVpcAttachmentList.to_xml [x]))))
               v.transit_gateway_vpc_attachments))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module GetReservedInstancesExchangeQuoteResult =
  struct
    type t =
      {
      currency_code: String.t option
        [@ocaml.doc "<p>The currency of the transaction.</p>"];
      is_valid_exchange: Boolean.t option
        [@ocaml.doc
          "<p>If <code>true</code>, the exchange is valid. If <code>false</code>, the exchange cannot be completed.</p>"];
      output_reserved_instances_will_expire_at: DateTime.t option
        [@ocaml.doc "<p>The new end date of the reservation term.</p>"];
      payment_due: String.t option
        [@ocaml.doc "<p>The total true upfront charge for the exchange.</p>"];
      reserved_instance_value_rollup: ReservationValue.t option
        [@ocaml.doc "<p>The cost associated with the Reserved Instance.</p>"];
      reserved_instance_value_set: ReservedInstanceReservationValueSet.t
        [@ocaml.doc
          "<p>The configuration of your Convertible Reserved Instances.</p>"];
      target_configuration_value_rollup: ReservationValue.t option
        [@ocaml.doc "<p>The cost associated with the Reserved Instance.</p>"];
      target_configuration_value_set: TargetReservationValueSet.t
        [@ocaml.doc
          "<p>The values of the target Convertible Reserved Instances.</p>"];
      validation_failure_reason: String.t option
        [@ocaml.doc
          "<p>Describes the reason why the exchange cannot be completed.</p>"]}
    [@@ocaml.doc
      "<p>Contains the output of GetReservedInstancesExchangeQuote.</p>"]
    let make ?currency_code  ?is_valid_exchange 
      ?output_reserved_instances_will_expire_at  ?payment_due 
      ?reserved_instance_value_rollup  ?(reserved_instance_value_set= []) 
      ?target_configuration_value_rollup  ?(target_configuration_value_set=
      [])  ?validation_failure_reason  () =
      {
        currency_code;
        is_valid_exchange;
        output_reserved_instances_will_expire_at;
        payment_due;
        reserved_instance_value_rollup;
        reserved_instance_value_set;
        target_configuration_value_rollup;
        target_configuration_value_set;
        validation_failure_reason
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.validation_failure_reason
              (fun f ->
                 Query.Pair ("ValidationFailureReason", (String.to_query f)));
           Some
             (Query.Pair
                ("TargetConfigurationValueSet",
                  (TargetReservationValueSet.to_query
                     v.target_configuration_value_set)));
           Util.option_map v.target_configuration_value_rollup
             (fun f ->
                Query.Pair
                  ("TargetConfigurationValueRollup",
                    (ReservationValue.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstanceValueSet",
                  (ReservedInstanceReservationValueSet.to_query
                     v.reserved_instance_value_set)));
           Util.option_map v.reserved_instance_value_rollup
             (fun f ->
                Query.Pair
                  ("ReservedInstanceValueRollup",
                    (ReservationValue.to_query f)));
           Util.option_map v.payment_due
             (fun f -> Query.Pair ("PaymentDue", (String.to_query f)));
           Util.option_map v.output_reserved_instances_will_expire_at
             (fun f ->
                Query.Pair
                  ("OutputReservedInstancesWillExpireAt",
                    (DateTime.to_query f)));
           Util.option_map v.is_valid_exchange
             (fun f -> Query.Pair ("IsValidExchange", (Boolean.to_query f)));
           Util.option_map v.currency_code
             (fun f -> Query.Pair ("CurrencyCode", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.validation_failure_reason
              (fun f -> ("validation_failure_reason", (String.to_json f)));
           Some
             ("target_configuration_value_set",
               (TargetReservationValueSet.to_json
                  v.target_configuration_value_set));
           Util.option_map v.target_configuration_value_rollup
             (fun f ->
                ("target_configuration_value_rollup",
                  (ReservationValue.to_json f)));
           Some
             ("reserved_instance_value_set",
               (ReservedInstanceReservationValueSet.to_json
                  v.reserved_instance_value_set));
           Util.option_map v.reserved_instance_value_rollup
             (fun f ->
                ("reserved_instance_value_rollup",
                  (ReservationValue.to_json f)));
           Util.option_map v.payment_due
             (fun f -> ("payment_due", (String.to_json f)));
           Util.option_map v.output_reserved_instances_will_expire_at
             (fun f ->
                ("output_reserved_instances_will_expire_at",
                  (DateTime.to_json f)));
           Util.option_map v.is_valid_exchange
             (fun f -> ("is_valid_exchange", (Boolean.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (String.to_json f)))])
    let parse xml =
      Some
        {
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml) String.parse);
          is_valid_exchange =
            (Util.option_bind (Xml.member "isValidExchange" xml)
               Boolean.parse);
          output_reserved_instances_will_expire_at =
            (Util.option_bind
               (Xml.member "outputReservedInstancesWillExpireAt" xml)
               DateTime.parse);
          payment_due =
            (Util.option_bind (Xml.member "paymentDue" xml) String.parse);
          reserved_instance_value_rollup =
            (Util.option_bind (Xml.member "reservedInstanceValueRollup" xml)
               ReservationValue.parse);
          reserved_instance_value_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "reservedInstanceValueSet" xml)
                  ReservedInstanceReservationValueSet.parse));
          target_configuration_value_rollup =
            (Util.option_bind
               (Xml.member "targetConfigurationValueRollup" xml)
               ReservationValue.parse);
          target_configuration_value_set =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "targetConfigurationValueSet" xml)
                  TargetReservationValueSet.parse));
          validation_failure_reason =
            (Util.option_bind (Xml.member "validationFailureReason" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.currency_code
                      (fun f ->
                         Ezxmlm.make_tag "currencyCode"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.is_valid_exchange
                     (fun f ->
                        Ezxmlm.make_tag "isValidExchange"
                          ([], (Boolean.to_xml f)))])
                 @
                 [Util.option_map v.output_reserved_instances_will_expire_at
                    (fun f ->
                       Ezxmlm.make_tag "outputReservedInstancesWillExpireAt"
                         ([], (DateTime.to_xml f)))])
                @
                [Util.option_map v.payment_due
                   (fun f ->
                      Ezxmlm.make_tag "paymentDue" ([], (String.to_xml f)))])
               @
               [Util.option_map v.reserved_instance_value_rollup
                  (fun f ->
                     Ezxmlm.make_tag "reservedInstanceValueRollup"
                       ([], (ReservationValue.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "reservedInstanceValueSet"
                         ([],
                           (ReservedInstanceReservationValueSet.to_xml [x]))))
                 v.reserved_instance_value_set))
             @
             [Util.option_map v.target_configuration_value_rollup
                (fun f ->
                   Ezxmlm.make_tag "targetConfigurationValueRollup"
                     ([], (ReservationValue.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "targetConfigurationValueSet"
                       ([], (TargetReservationValueSet.to_xml [x]))))
               v.target_configuration_value_set))
           @
           [Util.option_map v.validation_failure_reason
              (fun f ->
                 Ezxmlm.make_tag "validationFailureReason"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Contains the output of GetReservedInstancesExchangeQuote.</p>"]
module SearchTransitGatewayRoutesResult =
  struct
    type t =
      {
      routes: TransitGatewayRouteList.t
        [@ocaml.doc "<p>Information about the routes.</p>"];
      additional_routes_available: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether there are additional routes available.</p>"]}
    let make ?(routes= [])  ?additional_routes_available  () =
      { routes; additional_routes_available }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.additional_routes_available
              (fun f ->
                 Query.Pair
                   ("AdditionalRoutesAvailable", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("RouteSet", (TransitGatewayRouteList.to_query v.routes)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.additional_routes_available
              (fun f -> ("additional_routes_available", (Boolean.to_json f)));
           Some ("routes", (TransitGatewayRouteList.to_json v.routes))])
    let parse xml =
      Some
        {
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeSet" xml)
                  TransitGatewayRouteList.parse));
          additional_routes_available =
            (Util.option_bind (Xml.member "additionalRoutesAvailable" xml)
               Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "routeSet"
                       ([], (TransitGatewayRouteList.to_xml [x])))) v.routes))
           @
           [Util.option_map v.additional_routes_available
              (fun f ->
                 Ezxmlm.make_tag "additionalRoutesAvailable"
                   ([], (Boolean.to_xml f)))])
  end
module CreateSecurityGroupResult =
  struct
    type t =
      {
      group_id: String.t [@ocaml.doc "<p>The ID of the security group.</p>"]}
    let make ~group_id  () = { group_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("GroupId", (String.to_query v.group_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("group_id", (String.to_json v.group_id))])
    let parse xml =
      Some
        {
          group_id =
            (Xml.required "groupId"
               (Util.option_bind (Xml.member "groupId" xml) String.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some (Ezxmlm.make_tag "groupId" ([], (String.to_xml v.group_id)))])
  end
module DescribeSpotFleetRequestHistoryResponse =
  struct
    type t =
      {
      history_records: HistoryRecords.t
        [@ocaml.doc
          "<p>Information about the events in the history of the Spot Fleet request.</p>"];
      last_evaluated_time: DateTime.t option
        [@ocaml.doc
          "<p>The last date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z). All records up to this time were retrieved.</p> <p>If <code>nextToken</code> indicates that there are more results, this value is not present.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>"];
      spot_fleet_request_id: String.t option
        [@ocaml.doc "<p>The ID of the Spot Fleet request.</p>"];
      start_time: DateTime.t option
        [@ocaml.doc
          "<p>The starting date and time for the events, in UTC format (for example, <i>YYYY</i>-<i>MM</i>-<i>DD</i>T<i>HH</i>:<i>MM</i>:<i>SS</i>Z).</p>"]}
    [@@ocaml.doc
      "<p>Contains the output of DescribeSpotFleetRequestHistory.</p>"]
    let make ?(history_records= [])  ?last_evaluated_time  ?next_token 
      ?spot_fleet_request_id  ?start_time  () =
      {
        history_records;
        last_evaluated_time;
        next_token;
        spot_fleet_request_id;
        start_time
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.start_time
              (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Util.option_map v.spot_fleet_request_id
             (fun f -> Query.Pair ("SpotFleetRequestId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.last_evaluated_time
             (fun f ->
                Query.Pair ("LastEvaluatedTime", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("HistoryRecordSet",
                  (HistoryRecords.to_query v.history_records)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.start_time
              (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.spot_fleet_request_id
             (fun f -> ("spot_fleet_request_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.last_evaluated_time
             (fun f -> ("last_evaluated_time", (DateTime.to_json f)));
           Some
             ("history_records", (HistoryRecords.to_json v.history_records))])
    let parse xml =
      Some
        {
          history_records =
            (Util.of_option []
               (Util.option_bind (Xml.member "historyRecordSet" xml)
                  HistoryRecords.parse));
          last_evaluated_time =
            (Util.option_bind (Xml.member "lastEvaluatedTime" xml)
               DateTime.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse);
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "historyRecordSet"
                          ([], (HistoryRecords.to_xml [x]))))
                  v.history_records))
              @
              [Util.option_map v.last_evaluated_time
                 (fun f ->
                    Ezxmlm.make_tag "lastEvaluatedTime"
                      ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
            @
            [Util.option_map v.spot_fleet_request_id
               (fun f ->
                  Ezxmlm.make_tag "spotFleetRequestId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.start_time
              (fun f -> Ezxmlm.make_tag "startTime" ([], (DateTime.to_xml f)))])
  end[@@ocaml.doc
       "<p>Contains the output of DescribeSpotFleetRequestHistory.</p>"]
module DescribeFpgaImagesResult =
  struct
    type t =
      {
      fpga_images: FpgaImageList.t
        [@ocaml.doc "<p>Information about the FPGA images.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(fpga_images= [])  ?next_token  () =
      { fpga_images; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("FpgaImageSet", (FpgaImageList.to_query v.fpga_images)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("fpga_images", (FpgaImageList.to_json v.fpga_images))])
    let parse xml =
      Some
        {
          fpga_images =
            (Util.of_option []
               (Util.option_bind (Xml.member "fpgaImageSet" xml)
                  FpgaImageList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "fpgaImageSet"
                       ([], (FpgaImageList.to_xml [x])))) v.fpga_images))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module UnassignIpv6AddressesResult =
  struct
    type t =
      {
      network_interface_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface.</p>"];
      unassigned_ipv6_addresses: Ipv6AddressList.t
        [@ocaml.doc
          "<p>The IPv6 addresses that have been unassigned from the network interface.</p>"]}
    let make ?network_interface_id  ?(unassigned_ipv6_addresses= [])  () =
      { network_interface_id; unassigned_ipv6_addresses }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnassignedIpv6Addresses",
                   (Ipv6AddressList.to_query v.unassigned_ipv6_addresses)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unassigned_ipv6_addresses",
                (Ipv6AddressList.to_json v.unassigned_ipv6_addresses));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          unassigned_ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "unassignedIpv6Addresses" xml)
                  Ipv6AddressList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.network_interface_id
               (fun f ->
                  Ezxmlm.make_tag "networkInterfaceId"
                    ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unassignedIpv6Addresses"
                      ([], (Ipv6AddressList.to_xml [x]))))
              v.unassigned_ipv6_addresses))
  end
module EnableFastSnapshotRestoresResult =
  struct
    type t =
      {
      successful: EnableFastSnapshotRestoreSuccessSet.t
        [@ocaml.doc
          "<p>Information about the snapshots for which fast snapshot restores were successfully enabled.</p>"];
      unsuccessful: EnableFastSnapshotRestoreErrorSet.t
        [@ocaml.doc
          "<p>Information about the snapshots for which fast snapshot restores could not be enabled.</p>"]}
    let make ?(successful= [])  ?(unsuccessful= [])  () =
      { successful; unsuccessful }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (EnableFastSnapshotRestoreErrorSet.to_query v.unsuccessful)));
           Some
             (Query.Pair
                ("Successful",
                  (EnableFastSnapshotRestoreSuccessSet.to_query v.successful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful",
                (EnableFastSnapshotRestoreErrorSet.to_json v.unsuccessful));
           Some
             ("successful",
               (EnableFastSnapshotRestoreSuccessSet.to_json v.successful))])
    let parse xml =
      Some
        {
          successful =
            (Util.of_option []
               (Util.option_bind (Xml.member "successful" xml)
                  EnableFastSnapshotRestoreSuccessSet.parse));
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  EnableFastSnapshotRestoreErrorSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "successful"
                       ([], (EnableFastSnapshotRestoreSuccessSet.to_xml [x]))))
               v.successful))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (EnableFastSnapshotRestoreErrorSet.to_xml [x]))))
              v.unsuccessful))
  end
module RunScheduledInstancesResult =
  struct
    type t =
      {
      instance_id_set: InstanceIdSet.t
        [@ocaml.doc "<p>The IDs of the newly launched instances.</p>"]}
    [@@ocaml.doc "<p>Contains the output of RunScheduledInstances.</p>"]
    let make ?(instance_id_set= [])  () = { instance_id_set }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstanceIdSet",
                   (InstanceIdSet.to_query v.instance_id_set)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_id_set", (InstanceIdSet.to_json v.instance_id_set))])
    let parse xml =
      Some
        {
          instance_id_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceIdSet" xml)
                  InstanceIdSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "instanceIdSet"
                      ([], (InstanceIdSet.to_xml [x])))) v.instance_id_set))
  end[@@ocaml.doc "<p>Contains the output of RunScheduledInstances.</p>"]
module DescribeRouteTablesResult =
  struct
    type t =
      {
      route_tables: RouteTableList.t
        [@ocaml.doc "<p>Information about one or more route tables.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    [@@ocaml.doc "<p>Contains the output of DescribeRouteTables.</p>"]
    let make ?(route_tables= [])  ?next_token  () =
      { route_tables; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("RouteTableSet", (RouteTableList.to_query v.route_tables)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("route_tables", (RouteTableList.to_json v.route_tables))])
    let parse xml =
      Some
        {
          route_tables =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeTableSet" xml)
                  RouteTableList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "routeTableSet"
                       ([], (RouteTableList.to_xml [x])))) v.route_tables))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of DescribeRouteTables.</p>"]
module DescribeSnapshotAttributeResult =
  struct
    type t =
      {
      create_volume_permissions: CreateVolumePermissionList.t
        [@ocaml.doc
          "<p>The users and groups that have the permissions for creating volumes from the snapshot.</p>"];
      product_codes: ProductCodeList.t
        [@ocaml.doc "<p>The product codes.</p>"];
      snapshot_id: String.t option
        [@ocaml.doc "<p>The ID of the EBS snapshot.</p>"]}
    let make ?(create_volume_permissions= [])  ?(product_codes= []) 
      ?snapshot_id  () =
      { create_volume_permissions; product_codes; snapshot_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.snapshot_id
              (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Some
             (Query.Pair
                ("CreateVolumePermission",
                  (CreateVolumePermissionList.to_query
                     v.create_volume_permissions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.snapshot_id
              (fun f -> ("snapshot_id", (String.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Some
             ("create_volume_permissions",
               (CreateVolumePermissionList.to_json
                  v.create_volume_permissions))])
    let parse xml =
      Some
        {
          create_volume_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "createVolumePermission" xml)
                  CreateVolumePermissionList.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "createVolumePermission"
                        ([], (CreateVolumePermissionList.to_xml [x]))))
                v.create_volume_permissions))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "productCodes"
                       ([], (ProductCodeList.to_xml [x])))) v.product_codes))
           @
           [Util.option_map v.snapshot_id
              (fun f -> Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
  end
module WithdrawByoipCidrResult =
  struct
    type t =
      {
      byoip_cidr: ByoipCidr.t option
        [@ocaml.doc "<p>Information about the address pool.</p>"]}
    let make ?byoip_cidr  () = { byoip_cidr }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> Query.Pair ("ByoipCidr", (ByoipCidr.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> ("byoip_cidr", (ByoipCidr.to_json f)))])
    let parse xml =
      Some
        {
          byoip_cidr =
            (Util.option_bind (Xml.member "byoipCidr" xml) ByoipCidr.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.byoip_cidr
              (fun f ->
                 Ezxmlm.make_tag "byoipCidr" ([], (ByoipCidr.to_xml f)))])
  end
module DeleteTransitGatewayResult =
  struct
    type t =
      {
      transit_gateway: TransitGateway.t option
        [@ocaml.doc "<p>Information about the deleted transit gateway.</p>"]}
    let make ?transit_gateway  () = { transit_gateway }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway
              (fun f ->
                 Query.Pair ("TransitGateway", (TransitGateway.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway
              (fun f -> ("transit_gateway", (TransitGateway.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway =
            (Util.option_bind (Xml.member "transitGateway" xml)
               TransitGateway.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway
              (fun f ->
                 Ezxmlm.make_tag "transitGateway"
                   ([], (TransitGateway.to_xml f)))])
  end
module DisassociateSubnetCidrBlockResult =
  struct
    type t =
      {
      ipv6_cidr_block_association: SubnetIpv6CidrBlockAssociation.t option
        [@ocaml.doc
          "<p>Information about the IPv6 CIDR block association.</p>"];
      subnet_id: String.t option [@ocaml.doc "<p>The ID of the subnet.</p>"]}
    let make ?ipv6_cidr_block_association  ?subnet_id  () =
      { ipv6_cidr_block_association; subnet_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockAssociation",
                    (SubnetIpv6CidrBlockAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                ("ipv6_cidr_block_association",
                  (SubnetIpv6CidrBlockAssociation.to_json f)))])
    let parse xml =
      Some
        {
          ipv6_cidr_block_association =
            (Util.option_bind (Xml.member "ipv6CidrBlockAssociation" xml)
               SubnetIpv6CidrBlockAssociation.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.ipv6_cidr_block_association
               (fun f ->
                  Ezxmlm.make_tag "ipv6CidrBlockAssociation"
                    ([], (SubnetIpv6CidrBlockAssociation.to_xml f)))])
           @
           [Util.option_map v.subnet_id
              (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
  end
module ModifyVpcEndpointConnectionNotificationResult =
  struct
    type t =
      {
      return_value: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return_value  () = { return_value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> ("return_value", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          return_value =
            (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return_value
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module ReleaseHostsResult =
  struct
    type t =
      {
      successful: ResponseHostIdList.t
        [@ocaml.doc
          "<p>The IDs of the Dedicated Hosts that were successfully released.</p>"];
      unsuccessful: UnsuccessfulItemList.t
        [@ocaml.doc
          "<p>The IDs of the Dedicated Hosts that could not be released, including an error message.</p>"]}
    let make ?(successful= [])  ?(unsuccessful= [])  () =
      { successful; unsuccessful }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemList.to_query v.unsuccessful)));
           Some
             (Query.Pair
                ("Successful", (ResponseHostIdList.to_query v.successful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemList.to_json v.unsuccessful));
           Some ("successful", (ResponseHostIdList.to_json v.successful))])
    let parse xml =
      Some
        {
          successful =
            (Util.of_option []
               (Util.option_bind (Xml.member "successful" xml)
                  ResponseHostIdList.parse));
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "successful"
                       ([], (ResponseHostIdList.to_xml [x])))) v.successful))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemList.to_xml [x]))))
              v.unsuccessful))
  end
module EnableVpcClassicLinkResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module PurchaseReservedInstancesOfferingResult =
  struct
    type t =
      {
      reserved_instances_id: String.t option
        [@ocaml.doc "<p>The IDs of the purchased Reserved Instances.</p>"]}
    [@@ocaml.doc
      "<p>Contains the output of PurchaseReservedInstancesOffering.</p>"]
    let make ?reserved_instances_id  () = { reserved_instances_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Ezxmlm.make_tag "reservedInstancesId"
                   ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Contains the output of PurchaseReservedInstancesOffering.</p>"]
module RejectVpcPeeringConnectionResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module DescribeIamInstanceProfileAssociationsResult =
  struct
    type t =
      {
      iam_instance_profile_associations: IamInstanceProfileAssociationSet.t
        [@ocaml.doc
          "<p>Information about the IAM instance profile associations.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(iam_instance_profile_associations= [])  ?next_token  () =
      { iam_instance_profile_associations; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("IamInstanceProfileAssociationSet",
                  (IamInstanceProfileAssociationSet.to_query
                     v.iam_instance_profile_associations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("iam_instance_profile_associations",
               (IamInstanceProfileAssociationSet.to_json
                  v.iam_instance_profile_associations))])
    let parse xml =
      Some
        {
          iam_instance_profile_associations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "iamInstanceProfileAssociationSet" xml)
                  IamInstanceProfileAssociationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "iamInstanceProfileAssociationSet"
                       ([], (IamInstanceProfileAssociationSet.to_xml [x]))))
               v.iam_instance_profile_associations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module ModifyVpcEndpointResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module CreateRouteResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module DeleteVpcEndpointsResult =
  struct
    type t =
      {
      unsuccessful: UnsuccessfulItemSet.t
        [@ocaml.doc
          "<p>Information about the VPC endpoints that were not successfully deleted.</p>"]}
    [@@ocaml.doc "<p>Contains the output of DeleteVpcEndpoints.</p>"]
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemSet.to_xml [x])))) v.unsuccessful))
  end[@@ocaml.doc "<p>Contains the output of DeleteVpcEndpoints.</p>"]
module DescribeLaunchTemplateVersionsResult =
  struct
    type t =
      {
      launch_template_versions: LaunchTemplateVersionSet.t
        [@ocaml.doc "<p>Information about the launch template versions.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(launch_template_versions= [])  ?next_token  () =
      { launch_template_versions; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LaunchTemplateVersionSet",
                  (LaunchTemplateVersionSet.to_query
                     v.launch_template_versions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("launch_template_versions",
               (LaunchTemplateVersionSet.to_json v.launch_template_versions))])
    let parse xml =
      Some
        {
          launch_template_versions =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchTemplateVersionSet" xml)
                  LaunchTemplateVersionSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "launchTemplateVersionSet"
                       ([], (LaunchTemplateVersionSet.to_xml [x]))))
               v.launch_template_versions))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module AcceptTransitGatewayPeeringAttachmentResult =
  struct
    type t =
      {
      transit_gateway_peering_attachment:
        TransitGatewayPeeringAttachment.t option
        [@ocaml.doc "<p>The transit gateway peering attachment.</p>"]}
    let make ?transit_gateway_peering_attachment  () =
      { transit_gateway_peering_attachment }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayPeeringAttachment",
                     (TransitGatewayPeeringAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 ("transit_gateway_peering_attachment",
                   (TransitGatewayPeeringAttachment.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_peering_attachment =
            (Util.option_bind
               (Xml.member "transitGatewayPeeringAttachment" xml)
               TransitGatewayPeeringAttachment.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayPeeringAttachment"
                   ([], (TransitGatewayPeeringAttachment.to_xml f)))])
  end
module SearchTransitGatewayMulticastGroupsResult =
  struct
    type t =
      {
      multicast_groups: TransitGatewayMulticastGroupList.t
        [@ocaml.doc
          "<p>Information about the transit gateway multicast group.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(multicast_groups= [])  ?next_token  () =
      { multicast_groups; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("MulticastGroups",
                  (TransitGatewayMulticastGroupList.to_query
                     v.multicast_groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("multicast_groups",
               (TransitGatewayMulticastGroupList.to_json v.multicast_groups))])
    let parse xml =
      Some
        {
          multicast_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "multicastGroups" xml)
                  TransitGatewayMulticastGroupList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "multicastGroups"
                       ([], (TransitGatewayMulticastGroupList.to_xml [x]))))
               v.multicast_groups))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeLocalGatewayVirtualInterfacesResult =
  struct
    type t =
      {
      local_gateway_virtual_interfaces: LocalGatewayVirtualInterfaceSet.t
        [@ocaml.doc "<p>Information about the virtual interfaces.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(local_gateway_virtual_interfaces= [])  ?next_token  () =
      { local_gateway_virtual_interfaces; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayVirtualInterfaceSet",
                  (LocalGatewayVirtualInterfaceSet.to_query
                     v.local_gateway_virtual_interfaces)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateway_virtual_interfaces",
               (LocalGatewayVirtualInterfaceSet.to_json
                  v.local_gateway_virtual_interfaces))])
    let parse xml =
      Some
        {
          local_gateway_virtual_interfaces =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "localGatewayVirtualInterfaceSet" xml)
                  LocalGatewayVirtualInterfaceSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "localGatewayVirtualInterfaceSet"
                       ([], (LocalGatewayVirtualInterfaceSet.to_xml [x]))))
               v.local_gateway_virtual_interfaces))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module StartInstancesResult =
  struct
    type t =
      {
      starting_instances: InstanceStateChangeList.t
        [@ocaml.doc "<p>Information about the started instances.</p>"]}
    let make ?(starting_instances= [])  () = { starting_instances }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceStateChangeList.to_query v.starting_instances)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("starting_instances",
                (InstanceStateChangeList.to_json v.starting_instances))])
    let parse xml =
      Some
        {
          starting_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceStateChangeList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "instancesSet"
                      ([], (InstanceStateChangeList.to_xml [x]))))
              v.starting_instances))
  end
module DescribeLocalGatewayVirtualInterfaceGroupsResult =
  struct
    type t =
      {
      local_gateway_virtual_interface_groups:
        LocalGatewayVirtualInterfaceGroupSet.t
        [@ocaml.doc "<p>The virtual interface groups.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(local_gateway_virtual_interface_groups= [])  ?next_token  () =
      { local_gateway_virtual_interface_groups; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayVirtualInterfaceGroupSet",
                  (LocalGatewayVirtualInterfaceGroupSet.to_query
                     v.local_gateway_virtual_interface_groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateway_virtual_interface_groups",
               (LocalGatewayVirtualInterfaceGroupSet.to_json
                  v.local_gateway_virtual_interface_groups))])
    let parse xml =
      Some
        {
          local_gateway_virtual_interface_groups =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "localGatewayVirtualInterfaceGroupSet" xml)
                  LocalGatewayVirtualInterfaceGroupSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "localGatewayVirtualInterfaceGroupSet"
                       ([],
                         (LocalGatewayVirtualInterfaceGroupSet.to_xml [x]))))
               v.local_gateway_virtual_interface_groups))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module CreateTransitGatewayVpcAttachmentResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.t option
        [@ocaml.doc "<p>Information about the VPC attachment.</p>"]}
    let make ?transit_gateway_vpc_attachment  () =
      { transit_gateway_vpc_attachment }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayVpcAttachment",
                     (TransitGatewayVpcAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 ("transit_gateway_vpc_attachment",
                   (TransitGatewayVpcAttachment.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachment =
            (Util.option_bind (Xml.member "transitGatewayVpcAttachment" xml)
               TransitGatewayVpcAttachment.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayVpcAttachment"
                   ([], (TransitGatewayVpcAttachment.to_xml f)))])
  end
module DisassociateTransitGatewayRouteTableResult =
  struct
    type t =
      {
      association: TransitGatewayAssociation.t option
        [@ocaml.doc "<p>Information about the association.</p>"]}
    let make ?association  () = { association }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association
              (fun f ->
                 Query.Pair
                   ("Association", (TransitGatewayAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association
              (fun f ->
                 ("association", (TransitGatewayAssociation.to_json f)))])
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               TransitGatewayAssociation.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.association
              (fun f ->
                 Ezxmlm.make_tag "association"
                   ([], (TransitGatewayAssociation.to_xml f)))])
  end
module DescribeMovingAddressesResult =
  struct
    type t =
      {
      moving_address_statuses: MovingAddressStatusSet.t
        [@ocaml.doc "<p>The status for each Elastic IP address.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(moving_address_statuses= [])  ?next_token  () =
      { moving_address_statuses; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("MovingAddressStatusSet",
                  (MovingAddressStatusSet.to_query v.moving_address_statuses)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("moving_address_statuses",
               (MovingAddressStatusSet.to_json v.moving_address_statuses))])
    let parse xml =
      Some
        {
          moving_address_statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "movingAddressStatusSet" xml)
                  MovingAddressStatusSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "movingAddressStatusSet"
                       ([], (MovingAddressStatusSet.to_xml [x]))))
               v.moving_address_statuses))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module CreateVpcPeeringConnectionResult =
  struct
    type t =
      {
      vpc_peering_connection: VpcPeeringConnection.t option
        [@ocaml.doc "<p>Information about the VPC peering connection.</p>"]}
    let make ?vpc_peering_connection  () = { vpc_peering_connection }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 Query.Pair
                   ("VpcPeeringConnection",
                     (VpcPeeringConnection.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 ("vpc_peering_connection", (VpcPeeringConnection.to_json f)))])
    let parse xml =
      Some
        {
          vpc_peering_connection =
            (Util.option_bind (Xml.member "vpcPeeringConnection" xml)
               VpcPeeringConnection.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 Ezxmlm.make_tag "vpcPeeringConnection"
                   ([], (VpcPeeringConnection.to_xml f)))])
  end
module DescribeTrafficMirrorSessionsResult =
  struct
    type t =
      {
      traffic_mirror_sessions: TrafficMirrorSessionSet.t
        [@ocaml.doc
          "<p>Describes one or more Traffic Mirror sessions. By default, all Traffic Mirror sessions are described. Alternatively, you can filter the results.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. The value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(traffic_mirror_sessions= [])  ?next_token  () =
      { traffic_mirror_sessions; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorSessionSet",
                  (TrafficMirrorSessionSet.to_query v.traffic_mirror_sessions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("traffic_mirror_sessions",
               (TrafficMirrorSessionSet.to_json v.traffic_mirror_sessions))])
    let parse xml =
      Some
        {
          traffic_mirror_sessions =
            (Util.of_option []
               (Util.option_bind (Xml.member "trafficMirrorSessionSet" xml)
                  TrafficMirrorSessionSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "trafficMirrorSessionSet"
                       ([], (TrafficMirrorSessionSet.to_xml [x]))))
               v.traffic_mirror_sessions))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module ModifyCapacityReservationResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module DeleteClientVpnEndpointResult =
  struct
    type t =
      {
      status: ClientVpnEndpointStatus.t option
        [@ocaml.doc "<p>The current state of the Client VPN endpoint.</p>"]}
    let make ?status  () = { status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair ("Status", (ClientVpnEndpointStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (ClientVpnEndpointStatus.to_json f)))])
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnEndpointStatus.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status"
                   ([], (ClientVpnEndpointStatus.to_xml f)))])
  end
module AdvertiseByoipCidrResult =
  struct
    type t =
      {
      byoip_cidr: ByoipCidr.t option
        [@ocaml.doc "<p>Information about the address range.</p>"]}
    let make ?byoip_cidr  () = { byoip_cidr }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> Query.Pair ("ByoipCidr", (ByoipCidr.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> ("byoip_cidr", (ByoipCidr.to_json f)))])
    let parse xml =
      Some
        {
          byoip_cidr =
            (Util.option_bind (Xml.member "byoipCidr" xml) ByoipCidr.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.byoip_cidr
              (fun f ->
                 Ezxmlm.make_tag "byoipCidr" ([], (ByoipCidr.to_xml f)))])
  end
module CreateTransitGatewayRouteTableResult =
  struct
    type t =
      {
      transit_gateway_route_table: TransitGatewayRouteTable.t option
        [@ocaml.doc
          "<p>Information about the transit gateway route table.</p>"]}
    let make ?transit_gateway_route_table  () =
      { transit_gateway_route_table }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_route_table
              (fun f ->
                 Query.Pair
                   ("TransitGatewayRouteTable",
                     (TransitGatewayRouteTable.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_route_table
              (fun f ->
                 ("transit_gateway_route_table",
                   (TransitGatewayRouteTable.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_route_table =
            (Util.option_bind (Xml.member "transitGatewayRouteTable" xml)
               TransitGatewayRouteTable.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_route_table
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayRouteTable"
                   ([], (TransitGatewayRouteTable.to_xml f)))])
  end
module DeleteFpgaImageResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Is <code>true</code> if the request succeeds, and an error otherwise.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module ResetFpgaImageAttributeResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Is <code>true</code> if the request succeeds, and an error otherwise.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module DeleteLaunchTemplateVersionsResult =
  struct
    type t =
      {
      successfully_deleted_launch_template_versions:
        DeleteLaunchTemplateVersionsResponseSuccessSet.t
        [@ocaml.doc
          "<p>Information about the launch template versions that were successfully deleted.</p>"];
      unsuccessfully_deleted_launch_template_versions:
        DeleteLaunchTemplateVersionsResponseErrorSet.t
        [@ocaml.doc
          "<p>Information about the launch template versions that could not be deleted.</p>"]}
    let make ?(successfully_deleted_launch_template_versions= []) 
      ?(unsuccessfully_deleted_launch_template_versions= [])  () =
      {
        successfully_deleted_launch_template_versions;
        unsuccessfully_deleted_launch_template_versions
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnsuccessfullyDeletedLaunchTemplateVersionSet",
                   (DeleteLaunchTemplateVersionsResponseErrorSet.to_query
                      v.unsuccessfully_deleted_launch_template_versions)));
           Some
             (Query.Pair
                ("SuccessfullyDeletedLaunchTemplateVersionSet",
                  (DeleteLaunchTemplateVersionsResponseSuccessSet.to_query
                     v.successfully_deleted_launch_template_versions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessfully_deleted_launch_template_versions",
                (DeleteLaunchTemplateVersionsResponseErrorSet.to_json
                   v.unsuccessfully_deleted_launch_template_versions));
           Some
             ("successfully_deleted_launch_template_versions",
               (DeleteLaunchTemplateVersionsResponseSuccessSet.to_json
                  v.successfully_deleted_launch_template_versions))])
    let parse xml =
      Some
        {
          successfully_deleted_launch_template_versions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "successfullyDeletedLaunchTemplateVersionSet"
                     xml)
                  DeleteLaunchTemplateVersionsResponseSuccessSet.parse));
          unsuccessfully_deleted_launch_template_versions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "unsuccessfullyDeletedLaunchTemplateVersionSet"
                     xml) DeleteLaunchTemplateVersionsResponseErrorSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag
                       "successfullyDeletedLaunchTemplateVersionSet"
                       ([],
                         (DeleteLaunchTemplateVersionsResponseSuccessSet.to_xml
                            [x]))))
               v.successfully_deleted_launch_template_versions))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag
                      "unsuccessfullyDeletedLaunchTemplateVersionSet"
                      ([],
                        (DeleteLaunchTemplateVersionsResponseErrorSet.to_xml
                           [x]))))
              v.unsuccessfully_deleted_launch_template_versions))
  end
module RegisterTransitGatewayMulticastGroupSourcesResult =
  struct
    type t =
      {
      registered_multicast_group_sources:
        TransitGatewayMulticastRegisteredGroupSources.t option
        [@ocaml.doc
          "<p>Information about the transit gateway multicast group sources.</p>"]}
    let make ?registered_multicast_group_sources  () =
      { registered_multicast_group_sources }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.registered_multicast_group_sources
              (fun f ->
                 Query.Pair
                   ("RegisteredMulticastGroupSources",
                     (TransitGatewayMulticastRegisteredGroupSources.to_query
                        f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.registered_multicast_group_sources
              (fun f ->
                 ("registered_multicast_group_sources",
                   (TransitGatewayMulticastRegisteredGroupSources.to_json f)))])
    let parse xml =
      Some
        {
          registered_multicast_group_sources =
            (Util.option_bind
               (Xml.member "registeredMulticastGroupSources" xml)
               TransitGatewayMulticastRegisteredGroupSources.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.registered_multicast_group_sources
              (fun f ->
                 Ezxmlm.make_tag "registeredMulticastGroupSources"
                   ([],
                     (TransitGatewayMulticastRegisteredGroupSources.to_xml f)))])
  end
module RequestSpotInstancesResult =
  struct
    type t =
      {
      spot_instance_requests: SpotInstanceRequestList.t
        [@ocaml.doc "<p>One or more Spot Instance requests.</p>"]}[@@ocaml.doc
                                                                    "<p>Contains the output of RequestSpotInstances.</p>"]
    let make ?(spot_instance_requests= [])  () = { spot_instance_requests }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotInstanceRequestSet",
                   (SpotInstanceRequestList.to_query v.spot_instance_requests)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_instance_requests",
                (SpotInstanceRequestList.to_json v.spot_instance_requests))])
    let parse xml =
      Some
        {
          spot_instance_requests =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotInstanceRequestSet" xml)
                  SpotInstanceRequestList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "spotInstanceRequestSet"
                      ([], (SpotInstanceRequestList.to_xml [x]))))
              v.spot_instance_requests))
  end[@@ocaml.doc "<p>Contains the output of RequestSpotInstances.</p>"]
module MoveAddressToVpcResult =
  struct
    type t =
      {
      allocation_id: String.t option
        [@ocaml.doc "<p>The allocation ID for the Elastic IP address.</p>"];
      status: Status.t option
        [@ocaml.doc "<p>The status of the move of the IP address.</p>"]}
    let make ?allocation_id  ?status  () = { allocation_id; status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (Status.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (Status.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) Status.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.allocation_id
               (fun f ->
                  Ezxmlm.make_tag "allocationId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f -> Ezxmlm.make_tag "status" ([], (Status.to_xml f)))])
  end
module DeleteQueuedReservedInstancesResult =
  struct
    type t =
      {
      successful_queued_purchase_deletions:
        SuccessfulQueuedPurchaseDeletionSet.t
        [@ocaml.doc
          "<p>Information about the queued purchases that were successfully deleted.</p>"];
      failed_queued_purchase_deletions: FailedQueuedPurchaseDeletionSet.t
        [@ocaml.doc
          "<p>Information about the queued purchases that could not be deleted.</p>"]}
    let make ?(successful_queued_purchase_deletions= []) 
      ?(failed_queued_purchase_deletions= [])  () =
      {
        successful_queued_purchase_deletions;
        failed_queued_purchase_deletions
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FailedQueuedPurchaseDeletionSet",
                   (FailedQueuedPurchaseDeletionSet.to_query
                      v.failed_queued_purchase_deletions)));
           Some
             (Query.Pair
                ("SuccessfulQueuedPurchaseDeletionSet",
                  (SuccessfulQueuedPurchaseDeletionSet.to_query
                     v.successful_queued_purchase_deletions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("failed_queued_purchase_deletions",
                (FailedQueuedPurchaseDeletionSet.to_json
                   v.failed_queued_purchase_deletions));
           Some
             ("successful_queued_purchase_deletions",
               (SuccessfulQueuedPurchaseDeletionSet.to_json
                  v.successful_queued_purchase_deletions))])
    let parse xml =
      Some
        {
          successful_queued_purchase_deletions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "successfulQueuedPurchaseDeletionSet" xml)
                  SuccessfulQueuedPurchaseDeletionSet.parse));
          failed_queued_purchase_deletions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "failedQueuedPurchaseDeletionSet" xml)
                  FailedQueuedPurchaseDeletionSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "successfulQueuedPurchaseDeletionSet"
                       ([], (SuccessfulQueuedPurchaseDeletionSet.to_xml [x]))))
               v.successful_queued_purchase_deletions))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "failedQueuedPurchaseDeletionSet"
                      ([], (FailedQueuedPurchaseDeletionSet.to_xml [x]))))
              v.failed_queued_purchase_deletions))
  end
module GetLaunchTemplateDataResult =
  struct
    type t =
      {
      launch_template_data: ResponseLaunchTemplateData.t option
        [@ocaml.doc "<p>The instance data.</p>"]}
    let make ?launch_template_data  () = { launch_template_data }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template_data
              (fun f ->
                 Query.Pair
                   ("LaunchTemplateData",
                     (ResponseLaunchTemplateData.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template_data
              (fun f ->
                 ("launch_template_data",
                   (ResponseLaunchTemplateData.to_json f)))])
    let parse xml =
      Some
        {
          launch_template_data =
            (Util.option_bind (Xml.member "launchTemplateData" xml)
               ResponseLaunchTemplateData.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.launch_template_data
              (fun f ->
                 Ezxmlm.make_tag "launchTemplateData"
                   ([], (ResponseLaunchTemplateData.to_xml f)))])
  end
module AssociateTransitGatewayMulticastDomainResult =
  struct
    type t =
      {
      associations: TransitGatewayMulticastDomainAssociations.t option
        [@ocaml.doc
          "<p>Information about the transit gateway multicast domain associations.</p>"]}
    let make ?associations  () = { associations }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.associations
              (fun f ->
                 Query.Pair
                   ("Associations",
                     (TransitGatewayMulticastDomainAssociations.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.associations
              (fun f ->
                 ("associations",
                   (TransitGatewayMulticastDomainAssociations.to_json f)))])
    let parse xml =
      Some
        {
          associations =
            (Util.option_bind (Xml.member "associations" xml)
               TransitGatewayMulticastDomainAssociations.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.associations
              (fun f ->
                 Ezxmlm.make_tag "associations"
                   ([], (TransitGatewayMulticastDomainAssociations.to_xml f)))])
  end
module DeleteNetworkInterfacePermissionResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds, otherwise returns an error.</p>"]}
    [@@ocaml.doc
      "<p>Contains the output for DeleteNetworkInterfacePermission.</p>"]
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc
       "<p>Contains the output for DeleteNetworkInterfacePermission.</p>"]
module DescribeExportTasksResult =
  struct
    type t =
      {
      export_tasks: ExportTaskList.t
        [@ocaml.doc "<p>Information about the export tasks.</p>"]}
    let make ?(export_tasks= [])  () = { export_tasks }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ExportTaskSet", (ExportTaskList.to_query v.export_tasks)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("export_tasks", (ExportTaskList.to_json v.export_tasks))])
    let parse xml =
      Some
        {
          export_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "exportTaskSet" xml)
                  ExportTaskList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "exportTaskSet"
                      ([], (ExportTaskList.to_xml [x])))) v.export_tasks))
  end
module UnmonitorInstancesResult =
  struct
    type t =
      {
      instance_monitorings: InstanceMonitoringList.t
        [@ocaml.doc "<p>The monitoring information.</p>"]}
    let make ?(instance_monitorings= [])  () = { instance_monitorings }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceMonitoringList.to_query v.instance_monitorings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_monitorings",
                (InstanceMonitoringList.to_json v.instance_monitorings))])
    let parse xml =
      Some
        {
          instance_monitorings =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceMonitoringList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "instancesSet"
                      ([], (InstanceMonitoringList.to_xml [x]))))
              v.instance_monitorings))
  end
module CreateTransitGatewayRouteResult =
  struct
    type t =
      {
      route: TransitGatewayRoute.t option
        [@ocaml.doc "<p>Information about the route.</p>"]}
    let make ?route  () = { route }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f ->
                 Query.Pair ("Route", (TransitGatewayRoute.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> ("route", (TransitGatewayRoute.to_json f)))])
    let parse xml =
      Some
        {
          route =
            (Util.option_bind (Xml.member "route" xml)
               TransitGatewayRoute.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.route
              (fun f ->
                 Ezxmlm.make_tag "route" ([], (TransitGatewayRoute.to_xml f)))])
  end
module DescribeSecurityGroupsResult =
  struct
    type t =
      {
      security_groups: SecurityGroupList.t
        [@ocaml.doc "<p>Information about the security groups.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(security_groups= [])  ?next_token  () =
      { security_groups; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupInfo",
                  (SecurityGroupList.to_query v.security_groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("security_groups",
               (SecurityGroupList.to_json v.security_groups))])
    let parse xml =
      Some
        {
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupInfo" xml)
                  SecurityGroupList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "securityGroupInfo"
                       ([], (SecurityGroupList.to_xml [x]))))
               v.security_groups))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DeleteLocalGatewayRouteTableVpcAssociationResult =
  struct
    type t =
      {
      local_gateway_route_table_vpc_association:
        LocalGatewayRouteTableVpcAssociation.t option
        [@ocaml.doc "<p>Information about the association.</p>"]}
    let make ?local_gateway_route_table_vpc_association  () =
      { local_gateway_route_table_vpc_association }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_vpc_association
              (fun f ->
                 Query.Pair
                   ("LocalGatewayRouteTableVpcAssociation",
                     (LocalGatewayRouteTableVpcAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_vpc_association
              (fun f ->
                 ("local_gateway_route_table_vpc_association",
                   (LocalGatewayRouteTableVpcAssociation.to_json f)))])
    let parse xml =
      Some
        {
          local_gateway_route_table_vpc_association =
            (Util.option_bind
               (Xml.member "localGatewayRouteTableVpcAssociation" xml)
               LocalGatewayRouteTableVpcAssociation.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.local_gateway_route_table_vpc_association
              (fun f ->
                 Ezxmlm.make_tag "localGatewayRouteTableVpcAssociation"
                   ([], (LocalGatewayRouteTableVpcAssociation.to_xml f)))])
  end
module CreateTrafficMirrorTargetResult =
  struct
    type t =
      {
      traffic_mirror_target: TrafficMirrorTarget.t option
        [@ocaml.doc "<p>Information about the Traffic Mirror target.</p>"];
      client_token: String.t option
        [@ocaml.doc
          "<p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html\">How to Ensure Idempotency</a>.</p>"]}
    let make ?traffic_mirror_target  ?client_token  () =
      { traffic_mirror_target; client_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.traffic_mirror_target
             (fun f ->
                Query.Pair
                  ("TrafficMirrorTarget", (TrafficMirrorTarget.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.traffic_mirror_target
             (fun f ->
                ("traffic_mirror_target", (TrafficMirrorTarget.to_json f)))])
    let parse xml =
      Some
        {
          traffic_mirror_target =
            (Util.option_bind (Xml.member "trafficMirrorTarget" xml)
               TrafficMirrorTarget.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.traffic_mirror_target
               (fun f ->
                  Ezxmlm.make_tag "trafficMirrorTarget"
                    ([], (TrafficMirrorTarget.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
  end
module DescribeVpcEndpointServicesResult =
  struct
    type t =
      {
      service_names: ValueStringList.t
        [@ocaml.doc "<p>A list of supported services.</p>"];
      service_details: ServiceDetailSet.t
        [@ocaml.doc "<p>Information about the service.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use when requesting the next set of items. If there are no additional items to return, the string is empty.</p>"]}
    [@@ocaml.doc
      "<p>Contains the output of DescribeVpcEndpointServices.</p>"]
    let make ?(service_names= [])  ?(service_details= [])  ?next_token  () =
      { service_names; service_details; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ServiceDetailSet",
                  (ServiceDetailSet.to_query v.service_details)));
           Some
             (Query.Pair
                ("ServiceNameSet",
                  (ValueStringList.to_query v.service_names)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("service_details",
               (ServiceDetailSet.to_json v.service_details));
           Some ("service_names", (ValueStringList.to_json v.service_names))])
    let parse xml =
      Some
        {
          service_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "serviceNameSet" xml)
                  ValueStringList.parse));
          service_details =
            (Util.of_option []
               (Util.option_bind (Xml.member "serviceDetailSet" xml)
                  ServiceDetailSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "serviceNameSet"
                        ([], (ValueStringList.to_xml [x])))) v.service_names))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "serviceDetailSet"
                       ([], (ServiceDetailSet.to_xml [x]))))
               v.service_details))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Contains the output of DescribeVpcEndpointServices.</p>"]
module DeleteTransitGatewayVpcAttachmentResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.t option
        [@ocaml.doc "<p>Information about the deleted VPC attachment.</p>"]}
    let make ?transit_gateway_vpc_attachment  () =
      { transit_gateway_vpc_attachment }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayVpcAttachment",
                     (TransitGatewayVpcAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 ("transit_gateway_vpc_attachment",
                   (TransitGatewayVpcAttachment.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachment =
            (Util.option_bind (Xml.member "transitGatewayVpcAttachment" xml)
               TransitGatewayVpcAttachment.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayVpcAttachment"
                   ([], (TransitGatewayVpcAttachment.to_xml f)))])
  end
module GetConsoleOutputResult =
  struct
    type t =
      {
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"];
      output: String.t option
        [@ocaml.doc
          "<p>The console output, base64-encoded. If you are using a command line tool, the tool decodes the output for you.</p>"];
      timestamp: DateTime.t option
        [@ocaml.doc "<p>The time at which the output was last updated.</p>"]}
    let make ?instance_id  ?output  ?timestamp  () =
      { instance_id; output; timestamp }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.output
             (fun f -> Query.Pair ("Output", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.output (fun f -> ("output", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          output = (Util.option_bind (Xml.member "output" xml) String.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.instance_id
                (fun f ->
                   Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.output
               (fun f -> Ezxmlm.make_tag "output" ([], (String.to_xml f)))])
           @
           [Util.option_map v.timestamp
              (fun f -> Ezxmlm.make_tag "timestamp" ([], (DateTime.to_xml f)))])
  end
module DescribeClientVpnEndpointsResult =
  struct
    type t =
      {
      client_vpn_endpoints: EndpointSet.t
        [@ocaml.doc "<p>Information about the Client VPN endpoints.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(client_vpn_endpoints= [])  ?next_token  () =
      { client_vpn_endpoints; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpoint",
                  (EndpointSet.to_query v.client_vpn_endpoints)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("client_vpn_endpoints",
               (EndpointSet.to_json v.client_vpn_endpoints))])
    let parse xml =
      Some
        {
          client_vpn_endpoints =
            (Util.of_option []
               (Util.option_bind (Xml.member "clientVpnEndpoint" xml)
                  EndpointSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "clientVpnEndpoint"
                       ([], (EndpointSet.to_xml [x]))))
               v.client_vpn_endpoints))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module ModifyInstanceCapacityReservationAttributesResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module RejectVpcEndpointConnectionsResult =
  struct
    type t =
      {
      unsuccessful: UnsuccessfulItemSet.t
        [@ocaml.doc
          "<p>Information about the endpoints that were not rejected, if applicable.</p>"]}
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemSet.to_xml [x])))) v.unsuccessful))
  end
module DeregisterTransitGatewayMulticastGroupSourcesResult =
  struct
    type t =
      {
      deregistered_multicast_group_sources:
        TransitGatewayMulticastDeregisteredGroupSources.t option
        [@ocaml.doc
          "<p>Information about the deregistered group sources.</p>"]}
    let make ?deregistered_multicast_group_sources  () =
      { deregistered_multicast_group_sources }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.deregistered_multicast_group_sources
              (fun f ->
                 Query.Pair
                   ("DeregisteredMulticastGroupSources",
                     (TransitGatewayMulticastDeregisteredGroupSources.to_query
                        f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.deregistered_multicast_group_sources
              (fun f ->
                 ("deregistered_multicast_group_sources",
                   (TransitGatewayMulticastDeregisteredGroupSources.to_json f)))])
    let parse xml =
      Some
        {
          deregistered_multicast_group_sources =
            (Util.option_bind
               (Xml.member "deregisteredMulticastGroupSources" xml)
               TransitGatewayMulticastDeregisteredGroupSources.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.deregistered_multicast_group_sources
              (fun f ->
                 Ezxmlm.make_tag "deregisteredMulticastGroupSources"
                   ([],
                     (TransitGatewayMulticastDeregisteredGroupSources.to_xml
                        f)))])
  end
module DescribeInternetGatewaysResult =
  struct
    type t =
      {
      internet_gateways: InternetGatewayList.t
        [@ocaml.doc
          "<p>Information about one or more internet gateways.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(internet_gateways= [])  ?next_token  () =
      { internet_gateways; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InternetGatewaySet",
                  (InternetGatewayList.to_query v.internet_gateways)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("internet_gateways",
               (InternetGatewayList.to_json v.internet_gateways))])
    let parse xml =
      Some
        {
          internet_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "internetGatewaySet" xml)
                  InternetGatewayList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "internetGatewaySet"
                       ([], (InternetGatewayList.to_xml [x]))))
               v.internet_gateways))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module CreateTrafficMirrorSessionResult =
  struct
    type t =
      {
      traffic_mirror_session: TrafficMirrorSession.t option
        [@ocaml.doc "<p>Information about the Traffic Mirror session.</p>"];
      client_token: String.t option
        [@ocaml.doc
          "<p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html\">How to Ensure Idempotency</a>.</p>"]}
    let make ?traffic_mirror_session  ?client_token  () =
      { traffic_mirror_session; client_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.traffic_mirror_session
             (fun f ->
                Query.Pair
                  ("TrafficMirrorSession", (TrafficMirrorSession.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.traffic_mirror_session
             (fun f ->
                ("traffic_mirror_session", (TrafficMirrorSession.to_json f)))])
    let parse xml =
      Some
        {
          traffic_mirror_session =
            (Util.option_bind (Xml.member "trafficMirrorSession" xml)
               TrafficMirrorSession.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.traffic_mirror_session
               (fun f ->
                  Ezxmlm.make_tag "trafficMirrorSession"
                    ([], (TrafficMirrorSession.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
  end
module DescribeFleetsResult =
  struct
    type t =
      {
      next_token: String.t option
        [@ocaml.doc "<p>The token for the next set of results.</p>"];
      fleets: FleetSet.t
        [@ocaml.doc "<p>Information about the EC2 Fleets.</p>"]}
    let make ?next_token  ?(fleets= [])  () = { next_token; fleets }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("FleetSet", (FleetSet.to_query v.fleets)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("fleets", (FleetSet.to_json v.fleets));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          fleets =
            (Util.of_option []
               (Util.option_bind (Xml.member "fleetSet" xml) FleetSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "fleetSet" ([], (FleetSet.to_xml [x]))))
              v.fleets))
  end
module DeleteTrafficMirrorSessionResult =
  struct
    type t =
      {
      traffic_mirror_session_id: String.t option
        [@ocaml.doc "<p>The ID of the deleted Traffic Mirror session.</p>"]}
    let make ?traffic_mirror_session_id  () = { traffic_mirror_session_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_session_id
              (fun f ->
                 Query.Pair ("TrafficMirrorSessionId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_session_id
              (fun f -> ("traffic_mirror_session_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          traffic_mirror_session_id =
            (Util.option_bind (Xml.member "trafficMirrorSessionId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.traffic_mirror_session_id
              (fun f ->
                 Ezxmlm.make_tag "trafficMirrorSessionId"
                   ([], (String.to_xml f)))])
  end
module DeleteVpcPeeringConnectionResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module DescribeSpotFleetRequestsResponse =
  struct
    type t =
      {
      next_token: String.t option
        [@ocaml.doc
          "<p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>"];
      spot_fleet_request_configs: SpotFleetRequestConfigSet.t
        [@ocaml.doc
          "<p>Information about the configuration of your Spot Fleet.</p>"]}
    [@@ocaml.doc "<p>Contains the output of DescribeSpotFleetRequests.</p>"]
    let make ?next_token  ?(spot_fleet_request_configs= [])  () =
      { next_token; spot_fleet_request_configs }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotFleetRequestConfigSet",
                   (SpotFleetRequestConfigSet.to_query
                      v.spot_fleet_request_configs)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_fleet_request_configs",
                (SpotFleetRequestConfigSet.to_json
                   v.spot_fleet_request_configs));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_fleet_request_configs =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotFleetRequestConfigSet" xml)
                  SpotFleetRequestConfigSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "spotFleetRequestConfigSet"
                      ([], (SpotFleetRequestConfigSet.to_xml [x]))))
              v.spot_fleet_request_configs))
  end[@@ocaml.doc "<p>Contains the output of DescribeSpotFleetRequests.</p>"]
module ImportVolumeResult =
  struct
    type t =
      {
      conversion_task: ConversionTask.t option
        [@ocaml.doc "<p>Information about the conversion task.</p>"]}
    let make ?conversion_task  () = { conversion_task }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.conversion_task
              (fun f ->
                 Query.Pair ("ConversionTask", (ConversionTask.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.conversion_task
              (fun f -> ("conversion_task", (ConversionTask.to_json f)))])
    let parse xml =
      Some
        {
          conversion_task =
            (Util.option_bind (Xml.member "conversionTask" xml)
               ConversionTask.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.conversion_task
              (fun f ->
                 Ezxmlm.make_tag "conversionTask"
                   ([], (ConversionTask.to_xml f)))])
  end
module CreateNetworkAclResult =
  struct
    type t =
      {
      network_acl: NetworkAcl.t option
        [@ocaml.doc "<p>Information about the network ACL.</p>"]}
    let make ?network_acl  () = { network_acl }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_acl
              (fun f -> Query.Pair ("NetworkAcl", (NetworkAcl.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_acl
              (fun f -> ("network_acl", (NetworkAcl.to_json f)))])
    let parse xml =
      Some
        {
          network_acl =
            (Util.option_bind (Xml.member "networkAcl" xml) NetworkAcl.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.network_acl
              (fun f ->
                 Ezxmlm.make_tag "networkAcl" ([], (NetworkAcl.to_xml f)))])
  end
module DisassociateIamInstanceProfileResult =
  struct
    type t =
      {
      iam_instance_profile_association:
        IamInstanceProfileAssociation.t option
        [@ocaml.doc
          "<p>Information about the IAM instance profile association.</p>"]}
    let make ?iam_instance_profile_association  () =
      { iam_instance_profile_association }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 Query.Pair
                   ("IamInstanceProfileAssociation",
                     (IamInstanceProfileAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 ("iam_instance_profile_association",
                   (IamInstanceProfileAssociation.to_json f)))])
    let parse xml =
      Some
        {
          iam_instance_profile_association =
            (Util.option_bind
               (Xml.member "iamInstanceProfileAssociation" xml)
               IamInstanceProfileAssociation.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 Ezxmlm.make_tag "iamInstanceProfileAssociation"
                   ([], (IamInstanceProfileAssociation.to_xml f)))])
  end
module CreateRouteTableResult =
  struct
    type t =
      {
      route_table: RouteTable.t option
        [@ocaml.doc "<p>Information about the route table.</p>"]}
    let make ?route_table  () = { route_table }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route_table
              (fun f -> Query.Pair ("RouteTable", (RouteTable.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route_table
              (fun f -> ("route_table", (RouteTable.to_json f)))])
    let parse xml =
      Some
        {
          route_table =
            (Util.option_bind (Xml.member "routeTable" xml) RouteTable.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.route_table
              (fun f ->
                 Ezxmlm.make_tag "routeTable" ([], (RouteTable.to_xml f)))])
  end
module DescribeAvailabilityZonesResult =
  struct
    type t =
      {
      availability_zones: AvailabilityZoneList.t
        [@ocaml.doc
          "<p>Information about the Availability Zones and Local Zones.</p>"]}
    let make ?(availability_zones= [])  () = { availability_zones }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AvailabilityZoneInfo",
                   (AvailabilityZoneList.to_query v.availability_zones)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("availability_zones",
                (AvailabilityZoneList.to_json v.availability_zones))])
    let parse xml =
      Some
        {
          availability_zones =
            (Util.of_option []
               (Util.option_bind (Xml.member "availabilityZoneInfo" xml)
                  AvailabilityZoneList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "availabilityZoneInfo"
                      ([], (AvailabilityZoneList.to_xml [x]))))
              v.availability_zones))
  end
module ImportImageResult =
  struct
    type t =
      {
      architecture: String.t option
        [@ocaml.doc "<p>The architecture of the virtual machine.</p>"];
      description: String.t option
        [@ocaml.doc "<p>A description of the import task.</p>"];
      encrypted: Boolean.t option
        [@ocaml.doc "<p>Indicates whether the AMI is encypted.</p>"];
      hypervisor: String.t option
        [@ocaml.doc "<p>The target hypervisor of the import task.</p>"];
      image_id: String.t option
        [@ocaml.doc
          "<p>The ID of the Amazon Machine Image (AMI) created by the import task.</p>"];
      import_task_id: String.t option
        [@ocaml.doc "<p>The task ID of the import image task.</p>"];
      kms_key_id: String.t option
        [@ocaml.doc
          "<p>The identifier for the symmetric AWS Key Management Service (AWS KMS) customer master key (CMK) that was used to create the encrypted AMI.</p>"];
      license_type: String.t option
        [@ocaml.doc "<p>The license type of the virtual machine.</p>"];
      platform: String.t option
        [@ocaml.doc "<p>The operating system of the virtual machine.</p>"];
      progress: String.t option
        [@ocaml.doc "<p>The progress of the task.</p>"];
      snapshot_details: SnapshotDetailList.t
        [@ocaml.doc "<p>Information about the snapshots.</p>"];
      status: String.t option
        [@ocaml.doc "<p>A brief status of the task.</p>"];
      status_message: String.t option
        [@ocaml.doc "<p>A detailed status message of the import task.</p>"];
      license_specifications: ImportImageLicenseSpecificationListResponse.t
        [@ocaml.doc "<p>The ARNs of the license configurations.</p>"]}
    let make ?architecture  ?description  ?encrypted  ?hypervisor  ?image_id 
      ?import_task_id  ?kms_key_id  ?license_type  ?platform  ?progress 
      ?(snapshot_details= [])  ?status  ?status_message 
      ?(license_specifications= [])  () =
      {
        architecture;
        description;
        encrypted;
        hypervisor;
        image_id;
        import_task_id;
        kms_key_id;
        license_type;
        platform;
        progress;
        snapshot_details;
        status;
        status_message;
        license_specifications
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("LicenseSpecifications",
                   (ImportImageLicenseSpecificationListResponse.to_query
                      v.license_specifications)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Some
             (Query.Pair
                ("SnapshotDetailSet",
                  (SnapshotDetailList.to_query v.snapshot_details)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.license_type
             (fun f -> Query.Pair ("LicenseType", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.hypervisor
             (fun f -> Query.Pair ("Hypervisor", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.architecture
             (fun f -> Query.Pair ("Architecture", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("license_specifications",
                (ImportImageLicenseSpecificationListResponse.to_json
                   v.license_specifications));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Some
             ("snapshot_details",
               (SnapshotDetailList.to_json v.snapshot_details));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.license_type
             (fun f -> ("license_type", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.hypervisor
             (fun f -> ("hypervisor", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.architecture
             (fun f -> ("architecture", (String.to_json f)))])
    let parse xml =
      Some
        {
          architecture =
            (Util.option_bind (Xml.member "architecture" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          hypervisor =
            (Util.option_bind (Xml.member "hypervisor" xml) String.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          license_type =
            (Util.option_bind (Xml.member "licenseType" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          snapshot_details =
            (Util.of_option []
               (Util.option_bind (Xml.member "snapshotDetailSet" xml)
                  SnapshotDetailList.parse));
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          license_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "licenseSpecifications" xml)
                  ImportImageLicenseSpecificationListResponse.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        [Util.option_map v.architecture
                           (fun f ->
                              Ezxmlm.make_tag "architecture"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.description
                          (fun f ->
                             Ezxmlm.make_tag "description"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.encrypted
                         (fun f ->
                            Ezxmlm.make_tag "encrypted"
                              ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.hypervisor
                        (fun f ->
                           Ezxmlm.make_tag "hypervisor"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.image_id
                       (fun f ->
                          Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.import_task_id
                      (fun f ->
                         Ezxmlm.make_tag "importTaskId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.kms_key_id
                     (fun f ->
                        Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.license_type
                    (fun f ->
                       Ezxmlm.make_tag "licenseType" ([], (String.to_xml f)))])
                @
                [Util.option_map v.platform
                   (fun f ->
                      Ezxmlm.make_tag "platform" ([], (String.to_xml f)))])
               @
               [Util.option_map v.progress
                  (fun f ->
                     Ezxmlm.make_tag "progress" ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "snapshotDetailSet"
                         ([], (SnapshotDetailList.to_xml [x]))))
                 v.snapshot_details))
             @
             [Util.option_map v.status
                (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
            @
            [Util.option_map v.status_message
               (fun f ->
                  Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "licenseSpecifications"
                      ([],
                        (ImportImageLicenseSpecificationListResponse.to_xml
                           [x])))) v.license_specifications))
  end
module DescribeCustomerGatewaysResult =
  struct
    type t =
      {
      customer_gateways: CustomerGatewayList.t
        [@ocaml.doc
          "<p>Information about one or more customer gateways.</p>"]}
    [@@ocaml.doc "<p>Contains the output of DescribeCustomerGateways.</p>"]
    let make ?(customer_gateways= [])  () = { customer_gateways }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("CustomerGatewaySet",
                   (CustomerGatewayList.to_query v.customer_gateways)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("customer_gateways",
                (CustomerGatewayList.to_json v.customer_gateways))])
    let parse xml =
      Some
        {
          customer_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "customerGatewaySet" xml)
                  CustomerGatewayList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "customerGatewaySet"
                      ([], (CustomerGatewayList.to_xml [x]))))
              v.customer_gateways))
  end[@@ocaml.doc "<p>Contains the output of DescribeCustomerGateways.</p>"]
module ModifyVpnConnectionResult =
  struct
    type t = {
      vpn_connection: VpnConnection.t option }
    let make ?vpn_connection  () = { vpn_connection }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f ->
                 Query.Pair ("VpnConnection", (VpnConnection.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f -> ("vpn_connection", (VpnConnection.to_json f)))])
    let parse xml =
      Some
        {
          vpn_connection =
            (Util.option_bind (Xml.member "vpnConnection" xml)
               VpnConnection.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpn_connection
              (fun f ->
                 Ezxmlm.make_tag "vpnConnection"
                   ([], (VpnConnection.to_xml f)))])
  end
module ReplaceIamInstanceProfileAssociationResult =
  struct
    type t =
      {
      iam_instance_profile_association:
        IamInstanceProfileAssociation.t option
        [@ocaml.doc
          "<p>Information about the IAM instance profile association.</p>"]}
    let make ?iam_instance_profile_association  () =
      { iam_instance_profile_association }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 Query.Pair
                   ("IamInstanceProfileAssociation",
                     (IamInstanceProfileAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 ("iam_instance_profile_association",
                   (IamInstanceProfileAssociation.to_json f)))])
    let parse xml =
      Some
        {
          iam_instance_profile_association =
            (Util.option_bind
               (Xml.member "iamInstanceProfileAssociation" xml)
               IamInstanceProfileAssociation.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 Ezxmlm.make_tag "iamInstanceProfileAssociation"
                   ([], (IamInstanceProfileAssociation.to_xml f)))])
  end
module DescribeVolumeStatusResult =
  struct
    type t =
      {
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"];
      volume_statuses: VolumeStatusList.t
        [@ocaml.doc "<p>Information about the status of the volumes.</p>"]}
    let make ?next_token  ?(volume_statuses= [])  () =
      { next_token; volume_statuses }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VolumeStatusSet",
                   (VolumeStatusList.to_query v.volume_statuses)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("volume_statuses",
                (VolumeStatusList.to_json v.volume_statuses));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          volume_statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "volumeStatusSet" xml)
                  VolumeStatusList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "volumeStatusSet"
                      ([], (VolumeStatusList.to_xml [x])))) v.volume_statuses))
  end
module AssociateClientVpnTargetNetworkResult =
  struct
    type t =
      {
      association_id: String.t option
        [@ocaml.doc
          "<p>The unique ID of the target network association.</p>"];
      status: AssociationStatus.t option
        [@ocaml.doc
          "<p>The current state of the target network association.</p>"]}
    let make ?association_id  ?status  () = { association_id; status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (AssociationStatus.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (AssociationStatus.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AssociationStatus.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.association_id
               (fun f ->
                  Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status" ([], (AssociationStatus.to_xml f)))])
  end
module ReplaceTransitGatewayRouteResult =
  struct
    type t =
      {
      route: TransitGatewayRoute.t option
        [@ocaml.doc "<p>Information about the modified route.</p>"]}
    let make ?route  () = { route }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f ->
                 Query.Pair ("Route", (TransitGatewayRoute.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> ("route", (TransitGatewayRoute.to_json f)))])
    let parse xml =
      Some
        {
          route =
            (Util.option_bind (Xml.member "route" xml)
               TransitGatewayRoute.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.route
              (fun f ->
                 Ezxmlm.make_tag "route" ([], (TransitGatewayRoute.to_xml f)))])
  end
module DeleteVpcEndpointServiceConfigurationsResult =
  struct
    type t =
      {
      unsuccessful: UnsuccessfulItemSet.t
        [@ocaml.doc
          "<p>Information about the service configurations that were not deleted, if applicable.</p>"]}
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemSet.to_xml [x])))) v.unsuccessful))
  end
module ModifyEbsDefaultKmsKeyIdResult =
  struct
    type t =
      {
      kms_key_id: String.t option
        [@ocaml.doc
          "<p>The Amazon Resource Name (ARN) of the default CMK for encryption by default.</p>"]}
    let make ?kms_key_id  () = { kms_key_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> ("kms_key_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.kms_key_id
              (fun f -> Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
  end
module DisableVpcClassicLinkResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module DeleteFlowLogsResult =
  struct
    type t =
      {
      unsuccessful: UnsuccessfulItemSet.t
        [@ocaml.doc
          "<p>Information about the flow logs that could not be deleted successfully.</p>"]}
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemSet.to_xml [x])))) v.unsuccessful))
  end
module AttachVpnGatewayResult =
  struct
    type t =
      {
      vpc_attachment: VpcAttachment.t option
        [@ocaml.doc "<p>Information about the attachment.</p>"]}[@@ocaml.doc
                                                                  "<p>Contains the output of AttachVpnGateway.</p>"]
    let make ?vpc_attachment  () = { vpc_attachment }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_attachment
              (fun f -> Query.Pair ("Attachment", (VpcAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_attachment
              (fun f -> ("vpc_attachment", (VpcAttachment.to_json f)))])
    let parse xml =
      Some
        {
          vpc_attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               VpcAttachment.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpc_attachment
              (fun f ->
                 Ezxmlm.make_tag "attachment" ([], (VpcAttachment.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of AttachVpnGateway.</p>"]
module ImageAttribute =
  struct
    type t =
      {
      block_device_mappings: BlockDeviceMappingList.t
        [@ocaml.doc "<p>The block device mapping entries.</p>"];
      image_id: String.t option [@ocaml.doc "<p>The ID of the AMI.</p>"];
      launch_permissions: LaunchPermissionList.t
        [@ocaml.doc "<p>The launch permissions.</p>"];
      product_codes: ProductCodeList.t
        [@ocaml.doc "<p>The product codes.</p>"];
      description: AttributeValue.t option
        [@ocaml.doc "<p>A description for the AMI.</p>"];
      kernel_id: AttributeValue.t option [@ocaml.doc "<p>The kernel ID.</p>"];
      ramdisk_id: AttributeValue.t option
        [@ocaml.doc "<p>The RAM disk ID.</p>"];
      sriov_net_support: AttributeValue.t option
        [@ocaml.doc
          "<p>Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>"]}
    [@@ocaml.doc "<p>Describes an image attribute.</p>"]
    let make ?(block_device_mappings= [])  ?image_id  ?(launch_permissions=
      [])  ?(product_codes= [])  ?description  ?kernel_id  ?ramdisk_id 
      ?sriov_net_support  () =
      {
        block_device_mappings;
        image_id;
        launch_permissions;
        product_codes;
        description;
        kernel_id;
        ramdisk_id;
        sriov_net_support
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.sriov_net_support
              (fun f ->
                 Query.Pair ("SriovNetSupport", (AttributeValue.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("Ramdisk", (AttributeValue.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("Kernel", (AttributeValue.to_query f)));
           Util.option_map v.description
             (fun f ->
                Query.Pair ("Description", (AttributeValue.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Some
             (Query.Pair
                ("LaunchPermission",
                  (LaunchPermissionList.to_query v.launch_permissions)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.sriov_net_support
              (fun f -> ("sriov_net_support", (AttributeValue.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (AttributeValue.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (AttributeValue.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (AttributeValue.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Some
             ("launch_permissions",
               (LaunchPermissionList.to_json v.launch_permissions));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings))])
    let parse xml =
      Some
        {
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          launch_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchPermission" xml)
                  LaunchPermissionList.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          description =
            (Util.option_bind (Xml.member "description" xml)
               AttributeValue.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernel" xml) AttributeValue.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdisk" xml) AttributeValue.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml)
               AttributeValue.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "blockDeviceMapping"
                             ([], (BlockDeviceMappingList.to_xml [x]))))
                     v.block_device_mappings))
                 @
                 [Util.option_map v.image_id
                    (fun f ->
                       Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "launchPermission"
                           ([], (LaunchPermissionList.to_xml [x]))))
                   v.launch_permissions))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "productCodes"
                          ([], (ProductCodeList.to_xml [x]))))
                  v.product_codes))
              @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "description"
                      ([], (AttributeValue.to_xml f)))])
             @
             [Util.option_map v.kernel_id
                (fun f ->
                   Ezxmlm.make_tag "kernel" ([], (AttributeValue.to_xml f)))])
            @
            [Util.option_map v.ramdisk_id
               (fun f ->
                  Ezxmlm.make_tag "ramdisk" ([], (AttributeValue.to_xml f)))])
           @
           [Util.option_map v.sriov_net_support
              (fun f ->
                 Ezxmlm.make_tag "sriovNetSupport"
                   ([], (AttributeValue.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an image attribute.</p>"]
module DetachClassicLinkVpcResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module GetTransitGatewayRouteTableAssociationsResult =
  struct
    type t =
      {
      associations: TransitGatewayRouteTableAssociationList.t
        [@ocaml.doc "<p>Information about the associations.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(associations= [])  ?next_token  () =
      { associations; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("Associations",
                  (TransitGatewayRouteTableAssociationList.to_query
                     v.associations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("associations",
               (TransitGatewayRouteTableAssociationList.to_json
                  v.associations))])
    let parse xml =
      Some
        {
          associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "associations" xml)
                  TransitGatewayRouteTableAssociationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "associations"
                       ([],
                         (TransitGatewayRouteTableAssociationList.to_xml [x]))))
               v.associations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeHostReservationOfferingsResult =
  struct
    type t =
      {
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"];
      offering_set: HostOfferingSet.t
        [@ocaml.doc "<p>Information about the offerings.</p>"]}
    let make ?next_token  ?(offering_set= [])  () =
      { next_token; offering_set }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("OfferingSet", (HostOfferingSet.to_query v.offering_set)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("offering_set", (HostOfferingSet.to_json v.offering_set));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          offering_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "offeringSet" xml)
                  HostOfferingSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "offeringSet"
                      ([], (HostOfferingSet.to_xml [x])))) v.offering_set))
  end
module DescribeSpotInstanceRequestsResult =
  struct
    type t =
      {
      spot_instance_requests: SpotInstanceRequestList.t
        [@ocaml.doc "<p>One or more Spot Instance requests.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    [@@ocaml.doc
      "<p>Contains the output of DescribeSpotInstanceRequests.</p>"]
    let make ?(spot_instance_requests= [])  ?next_token  () =
      { spot_instance_requests; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("SpotInstanceRequestSet",
                  (SpotInstanceRequestList.to_query v.spot_instance_requests)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("spot_instance_requests",
               (SpotInstanceRequestList.to_json v.spot_instance_requests))])
    let parse xml =
      Some
        {
          spot_instance_requests =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotInstanceRequestSet" xml)
                  SpotInstanceRequestList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "spotInstanceRequestSet"
                       ([], (SpotInstanceRequestList.to_xml [x]))))
               v.spot_instance_requests))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Contains the output of DescribeSpotInstanceRequests.</p>"]
module ModifyTransitGatewayVpcAttachmentResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.t option
        [@ocaml.doc "<p>Information about the modified attachment.</p>"]}
    let make ?transit_gateway_vpc_attachment  () =
      { transit_gateway_vpc_attachment }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayVpcAttachment",
                     (TransitGatewayVpcAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 ("transit_gateway_vpc_attachment",
                   (TransitGatewayVpcAttachment.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachment =
            (Util.option_bind (Xml.member "transitGatewayVpcAttachment" xml)
               TransitGatewayVpcAttachment.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayVpcAttachment"
                   ([], (TransitGatewayVpcAttachment.to_xml f)))])
  end
module ModifyFpgaImageAttributeResult =
  struct
    type t =
      {
      fpga_image_attribute: FpgaImageAttribute.t option
        [@ocaml.doc "<p>Information about the attribute.</p>"]}
    let make ?fpga_image_attribute  () = { fpga_image_attribute }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_attribute
              (fun f ->
                 Query.Pair
                   ("FpgaImageAttribute", (FpgaImageAttribute.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_attribute
              (fun f ->
                 ("fpga_image_attribute", (FpgaImageAttribute.to_json f)))])
    let parse xml =
      Some
        {
          fpga_image_attribute =
            (Util.option_bind (Xml.member "fpgaImageAttribute" xml)
               FpgaImageAttribute.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.fpga_image_attribute
              (fun f ->
                 Ezxmlm.make_tag "fpgaImageAttribute"
                   ([], (FpgaImageAttribute.to_xml f)))])
  end
module AcceptVpcPeeringConnectionResult =
  struct
    type t =
      {
      vpc_peering_connection: VpcPeeringConnection.t option
        [@ocaml.doc "<p>Information about the VPC peering connection.</p>"]}
    let make ?vpc_peering_connection  () = { vpc_peering_connection }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 Query.Pair
                   ("VpcPeeringConnection",
                     (VpcPeeringConnection.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 ("vpc_peering_connection", (VpcPeeringConnection.to_json f)))])
    let parse xml =
      Some
        {
          vpc_peering_connection =
            (Util.option_bind (Xml.member "vpcPeeringConnection" xml)
               VpcPeeringConnection.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 Ezxmlm.make_tag "vpcPeeringConnection"
                   ([], (VpcPeeringConnection.to_xml f)))])
  end
module CreateNetworkInterfacePermissionResult =
  struct
    type t =
      {
      interface_permission: NetworkInterfacePermission.t option
        [@ocaml.doc
          "<p>Information about the permission for the network interface.</p>"]}
    [@@ocaml.doc
      "<p>Contains the output of CreateNetworkInterfacePermission.</p>"]
    let make ?interface_permission  () = { interface_permission }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.interface_permission
              (fun f ->
                 Query.Pair
                   ("InterfacePermission",
                     (NetworkInterfacePermission.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.interface_permission
              (fun f ->
                 ("interface_permission",
                   (NetworkInterfacePermission.to_json f)))])
    let parse xml =
      Some
        {
          interface_permission =
            (Util.option_bind (Xml.member "interfacePermission" xml)
               NetworkInterfacePermission.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.interface_permission
              (fun f ->
                 Ezxmlm.make_tag "interfacePermission"
                   ([], (NetworkInterfacePermission.to_xml f)))])
  end[@@ocaml.doc
       "<p>Contains the output of CreateNetworkInterfacePermission.</p>"]
module ModifyTrafficMirrorSessionResult =
  struct
    type t =
      {
      traffic_mirror_session: TrafficMirrorSession.t option
        [@ocaml.doc "<p>Information about the Traffic Mirror session.</p>"]}
    let make ?traffic_mirror_session  () = { traffic_mirror_session }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_session
              (fun f ->
                 Query.Pair
                   ("TrafficMirrorSession",
                     (TrafficMirrorSession.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_session
              (fun f ->
                 ("traffic_mirror_session", (TrafficMirrorSession.to_json f)))])
    let parse xml =
      Some
        {
          traffic_mirror_session =
            (Util.option_bind (Xml.member "trafficMirrorSession" xml)
               TrafficMirrorSession.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.traffic_mirror_session
              (fun f ->
                 Ezxmlm.make_tag "trafficMirrorSession"
                   ([], (TrafficMirrorSession.to_xml f)))])
  end
module DisableVpcClassicLinkDnsSupportResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module RegisterImageResult =
  struct
    type t =
      {
      image_id: String.t option
        [@ocaml.doc "<p>The ID of the newly registered AMI.</p>"]}[@@ocaml.doc
                                                                    "<p>Contains the output of RegisterImage.</p>"]
    let make ?image_id  () = { image_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> Query.Pair ("ImageId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> ("image_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.image_id
              (fun f -> Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of RegisterImage.</p>"]
module DeleteLocalGatewayRouteResult =
  struct
    type t =
      {
      route: LocalGatewayRoute.t option
        [@ocaml.doc "<p>Information about the route.</p>"]}
    let make ?route  () = { route }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> Query.Pair ("Route", (LocalGatewayRoute.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> ("route", (LocalGatewayRoute.to_json f)))])
    let parse xml =
      Some
        {
          route =
            (Util.option_bind (Xml.member "route" xml)
               LocalGatewayRoute.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.route
              (fun f ->
                 Ezxmlm.make_tag "route" ([], (LocalGatewayRoute.to_xml f)))])
  end
module CancelReservedInstancesListingResult =
  struct
    type t =
      {
      reserved_instances_listings: ReservedInstancesListingList.t
        [@ocaml.doc "<p>The Reserved Instance listing.</p>"]}[@@ocaml.doc
                                                               "<p>Contains the output of CancelReservedInstancesListing.</p>"]
    let make ?(reserved_instances_listings= [])  () =
      { reserved_instances_listings }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesListingsSet",
                   (ReservedInstancesListingList.to_query
                      v.reserved_instances_listings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_listings",
                (ReservedInstancesListingList.to_json
                   v.reserved_instances_listings))])
    let parse xml =
      Some
        {
          reserved_instances_listings =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesListingsSet" xml)
                  ReservedInstancesListingList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "reservedInstancesListingsSet"
                      ([], (ReservedInstancesListingList.to_xml [x]))))
              v.reserved_instances_listings))
  end[@@ocaml.doc
       "<p>Contains the output of CancelReservedInstancesListing.</p>"]
module BundleInstanceResult =
  struct
    type t =
      {
      bundle_task: BundleTask.t option
        [@ocaml.doc "<p>Information about the bundle task.</p>"]}[@@ocaml.doc
                                                                   "<p>Contains the output of BundleInstance.</p>"]
    let make ?bundle_task  () = { bundle_task }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.bundle_task
              (fun f ->
                 Query.Pair ("BundleInstanceTask", (BundleTask.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.bundle_task
              (fun f -> ("bundle_task", (BundleTask.to_json f)))])
    let parse xml =
      Some
        {
          bundle_task =
            (Util.option_bind (Xml.member "bundleInstanceTask" xml)
               BundleTask.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.bundle_task
              (fun f ->
                 Ezxmlm.make_tag "bundleInstanceTask"
                   ([], (BundleTask.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of BundleInstance.</p>"]
module DescribeTransitGatewayRouteTablesResult =
  struct
    type t =
      {
      transit_gateway_route_tables: TransitGatewayRouteTableList.t
        [@ocaml.doc
          "<p>Information about the transit gateway route tables.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(transit_gateway_route_tables= [])  ?next_token  () =
      { transit_gateway_route_tables; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTables",
                  (TransitGatewayRouteTableList.to_query
                     v.transit_gateway_route_tables)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_route_tables",
               (TransitGatewayRouteTableList.to_json
                  v.transit_gateway_route_tables))])
    let parse xml =
      Some
        {
          transit_gateway_route_tables =
            (Util.of_option []
               (Util.option_bind (Xml.member "transitGatewayRouteTables" xml)
                  TransitGatewayRouteTableList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "transitGatewayRouteTables"
                       ([], (TransitGatewayRouteTableList.to_xml [x]))))
               v.transit_gateway_route_tables))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module AssociateSubnetCidrBlockResult =
  struct
    type t =
      {
      ipv6_cidr_block_association: SubnetIpv6CidrBlockAssociation.t option
        [@ocaml.doc
          "<p>Information about the IPv6 CIDR block association.</p>"];
      subnet_id: String.t option [@ocaml.doc "<p>The ID of the subnet.</p>"]}
    let make ?ipv6_cidr_block_association  ?subnet_id  () =
      { ipv6_cidr_block_association; subnet_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockAssociation",
                    (SubnetIpv6CidrBlockAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                ("ipv6_cidr_block_association",
                  (SubnetIpv6CidrBlockAssociation.to_json f)))])
    let parse xml =
      Some
        {
          ipv6_cidr_block_association =
            (Util.option_bind (Xml.member "ipv6CidrBlockAssociation" xml)
               SubnetIpv6CidrBlockAssociation.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.ipv6_cidr_block_association
               (fun f ->
                  Ezxmlm.make_tag "ipv6CidrBlockAssociation"
                    ([], (SubnetIpv6CidrBlockAssociation.to_xml f)))])
           @
           [Util.option_map v.subnet_id
              (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
  end
module InstanceAttribute =
  struct
    type t =
      {
      groups: GroupIdentifierList.t
        [@ocaml.doc
          "<p>The security groups associated with the instance.</p>"];
      block_device_mappings: InstanceBlockDeviceMappingList.t
        [@ocaml.doc "<p>The block device mapping of the instance.</p>"];
      disable_api_termination: AttributeBooleanValue.t option
        [@ocaml.doc
          "<p>If the value is <code>true</code>, you can't terminate the instance through the Amazon EC2 console, CLI, or API; otherwise, you can.</p>"];
      ena_support: AttributeBooleanValue.t option
        [@ocaml.doc
          "<p>Indicates whether enhanced networking with ENA is enabled.</p>"];
      ebs_optimized: AttributeBooleanValue.t option
        [@ocaml.doc
          "<p>Indicates whether the instance is optimized for Amazon EBS I/O.</p>"];
      instance_id: String.t option
        [@ocaml.doc "<p>The ID of the instance.</p>"];
      instance_initiated_shutdown_behavior: AttributeValue.t option
        [@ocaml.doc
          "<p>Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).</p>"];
      instance_type: AttributeValue.t option
        [@ocaml.doc "<p>The instance type.</p>"];
      kernel_id: AttributeValue.t option [@ocaml.doc "<p>The kernel ID.</p>"];
      product_codes: ProductCodeList.t
        [@ocaml.doc "<p>A list of product codes.</p>"];
      ramdisk_id: AttributeValue.t option
        [@ocaml.doc "<p>The RAM disk ID.</p>"];
      root_device_name: AttributeValue.t option
        [@ocaml.doc
          "<p>The device name of the root device volume (for example, <code>/dev/sda1</code>).</p>"];
      source_dest_check: AttributeBooleanValue.t option
        [@ocaml.doc
          "<p>Indicates whether source/destination checking is enabled. A value of <code>true</code> means that checking is enabled, and <code>false</code> means that checking is disabled. This value must be <code>false</code> for a NAT instance to perform NAT.</p>"];
      sriov_net_support: AttributeValue.t option
        [@ocaml.doc
          "<p>Indicates whether enhanced networking with the Intel 82599 Virtual Function interface is enabled.</p>"];
      user_data: AttributeValue.t option [@ocaml.doc "<p>The user data.</p>"]}
    [@@ocaml.doc "<p>Describes an instance attribute.</p>"]
    let make ?(groups= [])  ?(block_device_mappings= []) 
      ?disable_api_termination  ?ena_support  ?ebs_optimized  ?instance_id 
      ?instance_initiated_shutdown_behavior  ?instance_type  ?kernel_id 
      ?(product_codes= [])  ?ramdisk_id  ?root_device_name 
      ?source_dest_check  ?sriov_net_support  ?user_data  () =
      {
        groups;
        block_device_mappings;
        disable_api_termination;
        ena_support;
        ebs_optimized;
        instance_id;
        instance_initiated_shutdown_behavior;
        instance_type;
        kernel_id;
        product_codes;
        ramdisk_id;
        root_device_name;
        source_dest_check;
        sriov_net_support;
        user_data
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> Query.Pair ("UserData", (AttributeValue.to_query f)));
           Util.option_map v.sriov_net_support
             (fun f ->
                Query.Pair ("SriovNetSupport", (AttributeValue.to_query f)));
           Util.option_map v.source_dest_check
             (fun f ->
                Query.Pair
                  ("SourceDestCheck", (AttributeBooleanValue.to_query f)));
           Util.option_map v.root_device_name
             (fun f ->
                Query.Pair ("RootDeviceName", (AttributeValue.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("Ramdisk", (AttributeValue.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("Kernel", (AttributeValue.to_query f)));
           Util.option_map v.instance_type
             (fun f ->
                Query.Pair ("InstanceType", (AttributeValue.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (AttributeValue.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f ->
                Query.Pair
                  ("EbsOptimized", (AttributeBooleanValue.to_query f)));
           Util.option_map v.ena_support
             (fun f ->
                Query.Pair ("EnaSupport", (AttributeBooleanValue.to_query f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                Query.Pair
                  ("DisableApiTermination",
                    (AttributeBooleanValue.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (InstanceBlockDeviceMappingList.to_query
                     v.block_device_mappings)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> ("user_data", (AttributeValue.to_json f)));
           Util.option_map v.sriov_net_support
             (fun f -> ("sriov_net_support", (AttributeValue.to_json f)));
           Util.option_map v.source_dest_check
             (fun f ->
                ("source_dest_check", (AttributeBooleanValue.to_json f)));
           Util.option_map v.root_device_name
             (fun f -> ("root_device_name", (AttributeValue.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (AttributeValue.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (AttributeValue.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (AttributeValue.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (AttributeValue.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (AttributeBooleanValue.to_json f)));
           Util.option_map v.ena_support
             (fun f -> ("ena_support", (AttributeBooleanValue.to_json f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                ("disable_api_termination",
                  (AttributeBooleanValue.to_json f)));
           Some
             ("block_device_mappings",
               (InstanceBlockDeviceMappingList.to_json
                  v.block_device_mappings));
           Some ("groups", (GroupIdentifierList.to_json v.groups))])
    let parse xml =
      Some
        {
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  InstanceBlockDeviceMappingList.parse));
          disable_api_termination =
            (Util.option_bind (Xml.member "disableApiTermination" xml)
               AttributeBooleanValue.parse);
          ena_support =
            (Util.option_bind (Xml.member "enaSupport" xml)
               AttributeBooleanValue.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml)
               AttributeBooleanValue.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               AttributeValue.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               AttributeValue.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernel" xml) AttributeValue.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdisk" xml) AttributeValue.parse);
          root_device_name =
            (Util.option_bind (Xml.member "rootDeviceName" xml)
               AttributeValue.parse);
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               AttributeBooleanValue.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml)
               AttributeValue.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml)
               AttributeValue.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         (List.map
                            (fun x ->
                               Some
                                 (Ezxmlm.make_tag "groupSet"
                                    ([], (GroupIdentifierList.to_xml [x]))))
                            v.groups))
                        @
                        (List.map
                           (fun x ->
                              Some
                                (Ezxmlm.make_tag "blockDeviceMapping"
                                   ([],
                                     (InstanceBlockDeviceMappingList.to_xml
                                        [x])))) v.block_device_mappings))
                       @
                       [Util.option_map v.disable_api_termination
                          (fun f ->
                             Ezxmlm.make_tag "disableApiTermination"
                               ([], (AttributeBooleanValue.to_xml f)))])
                      @
                      [Util.option_map v.ena_support
                         (fun f ->
                            Ezxmlm.make_tag "enaSupport"
                              ([], (AttributeBooleanValue.to_xml f)))])
                     @
                     [Util.option_map v.ebs_optimized
                        (fun f ->
                           Ezxmlm.make_tag "ebsOptimized"
                             ([], (AttributeBooleanValue.to_xml f)))])
                    @
                    [Util.option_map v.instance_id
                       (fun f ->
                          Ezxmlm.make_tag "instanceId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.instance_initiated_shutdown_behavior
                      (fun f ->
                         Ezxmlm.make_tag "instanceInitiatedShutdownBehavior"
                           ([], (AttributeValue.to_xml f)))])
                  @
                  [Util.option_map v.instance_type
                     (fun f ->
                        Ezxmlm.make_tag "instanceType"
                          ([], (AttributeValue.to_xml f)))])
                 @
                 [Util.option_map v.kernel_id
                    (fun f ->
                       Ezxmlm.make_tag "kernel"
                         ([], (AttributeValue.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "productCodes"
                           ([], (ProductCodeList.to_xml [x]))))
                   v.product_codes))
               @
               [Util.option_map v.ramdisk_id
                  (fun f ->
                     Ezxmlm.make_tag "ramdisk"
                       ([], (AttributeValue.to_xml f)))])
              @
              [Util.option_map v.root_device_name
                 (fun f ->
                    Ezxmlm.make_tag "rootDeviceName"
                      ([], (AttributeValue.to_xml f)))])
             @
             [Util.option_map v.source_dest_check
                (fun f ->
                   Ezxmlm.make_tag "sourceDestCheck"
                     ([], (AttributeBooleanValue.to_xml f)))])
            @
            [Util.option_map v.sriov_net_support
               (fun f ->
                  Ezxmlm.make_tag "sriovNetSupport"
                    ([], (AttributeValue.to_xml f)))])
           @
           [Util.option_map v.user_data
              (fun f ->
                 Ezxmlm.make_tag "userData" ([], (AttributeValue.to_xml f)))])
  end[@@ocaml.doc "<p>Describes an instance attribute.</p>"]
module ModifyHostsResult =
  struct
    type t =
      {
      successful: ResponseHostIdList.t
        [@ocaml.doc
          "<p>The IDs of the Dedicated Hosts that were successfully modified.</p>"];
      unsuccessful: UnsuccessfulItemList.t
        [@ocaml.doc
          "<p>The IDs of the Dedicated Hosts that could not be modified. Check whether the setting you requested can be used.</p>"]}
    let make ?(successful= [])  ?(unsuccessful= [])  () =
      { successful; unsuccessful }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemList.to_query v.unsuccessful)));
           Some
             (Query.Pair
                ("Successful", (ResponseHostIdList.to_query v.successful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemList.to_json v.unsuccessful));
           Some ("successful", (ResponseHostIdList.to_json v.successful))])
    let parse xml =
      Some
        {
          successful =
            (Util.of_option []
               (Util.option_bind (Xml.member "successful" xml)
                  ResponseHostIdList.parse));
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "successful"
                       ([], (ResponseHostIdList.to_xml [x])))) v.successful))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemList.to_xml [x]))))
              v.unsuccessful))
  end
module DeregisterTransitGatewayMulticastGroupMembersResult =
  struct
    type t =
      {
      deregistered_multicast_group_members:
        TransitGatewayMulticastDeregisteredGroupMembers.t option
        [@ocaml.doc "<p>Information about the deregistered members.</p>"]}
    let make ?deregistered_multicast_group_members  () =
      { deregistered_multicast_group_members }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.deregistered_multicast_group_members
              (fun f ->
                 Query.Pair
                   ("DeregisteredMulticastGroupMembers",
                     (TransitGatewayMulticastDeregisteredGroupMembers.to_query
                        f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.deregistered_multicast_group_members
              (fun f ->
                 ("deregistered_multicast_group_members",
                   (TransitGatewayMulticastDeregisteredGroupMembers.to_json f)))])
    let parse xml =
      Some
        {
          deregistered_multicast_group_members =
            (Util.option_bind
               (Xml.member "deregisteredMulticastGroupMembers" xml)
               TransitGatewayMulticastDeregisteredGroupMembers.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.deregistered_multicast_group_members
              (fun f ->
                 Ezxmlm.make_tag "deregisteredMulticastGroupMembers"
                   ([],
                     (TransitGatewayMulticastDeregisteredGroupMembers.to_xml
                        f)))])
  end
module DescribeClientVpnAuthorizationRulesResult =
  struct
    type t =
      {
      authorization_rules: AuthorizationRuleSet.t
        [@ocaml.doc "<p>Information about the authorization rules.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(authorization_rules= [])  ?next_token  () =
      { authorization_rules; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("AuthorizationRule",
                  (AuthorizationRuleSet.to_query v.authorization_rules)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("authorization_rules",
               (AuthorizationRuleSet.to_json v.authorization_rules))])
    let parse xml =
      Some
        {
          authorization_rules =
            (Util.of_option []
               (Util.option_bind (Xml.member "authorizationRule" xml)
                  AuthorizationRuleSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "authorizationRule"
                       ([], (AuthorizationRuleSet.to_xml [x]))))
               v.authorization_rules))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module StopInstancesResult =
  struct
    type t =
      {
      stopping_instances: InstanceStateChangeList.t
        [@ocaml.doc "<p>Information about the stopped instances.</p>"]}
    let make ?(stopping_instances= [])  () = { stopping_instances }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceStateChangeList.to_query v.stopping_instances)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("stopping_instances",
                (InstanceStateChangeList.to_json v.stopping_instances))])
    let parse xml =
      Some
        {
          stopping_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceStateChangeList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "instancesSet"
                      ([], (InstanceStateChangeList.to_xml [x]))))
              v.stopping_instances))
  end
module RequestSpotFleetResponse =
  struct
    type t =
      {
      spot_fleet_request_id: String.t option
        [@ocaml.doc "<p>The ID of the Spot Fleet request.</p>"]}[@@ocaml.doc
                                                                  "<p>Contains the output of RequestSpotFleet.</p>"]
    let make ?spot_fleet_request_id  () = { spot_fleet_request_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Query.Pair ("SpotFleetRequestId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f -> ("spot_fleet_request_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Ezxmlm.make_tag "spotFleetRequestId" ([], (String.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of RequestSpotFleet.</p>"]
module GetTransitGatewayMulticastDomainAssociationsResult =
  struct
    type t =
      {
      multicast_domain_associations:
        TransitGatewayMulticastDomainAssociationList.t
        [@ocaml.doc
          "<p>Information about the multicast domain associations.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(multicast_domain_associations= [])  ?next_token  () =
      { multicast_domain_associations; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("MulticastDomainAssociations",
                  (TransitGatewayMulticastDomainAssociationList.to_query
                     v.multicast_domain_associations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("multicast_domain_associations",
               (TransitGatewayMulticastDomainAssociationList.to_json
                  v.multicast_domain_associations))])
    let parse xml =
      Some
        {
          multicast_domain_associations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "multicastDomainAssociations" xml)
                  TransitGatewayMulticastDomainAssociationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "multicastDomainAssociations"
                       ([],
                         (TransitGatewayMulticastDomainAssociationList.to_xml
                            [x])))) v.multicast_domain_associations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module ModifyInstanceCreditSpecificationResult =
  struct
    type t =
      {
      successful_instance_credit_specifications:
        SuccessfulInstanceCreditSpecificationSet.t
        [@ocaml.doc
          "<p>Information about the instances whose credit option for CPU usage was successfully modified.</p>"];
      unsuccessful_instance_credit_specifications:
        UnsuccessfulInstanceCreditSpecificationSet.t
        [@ocaml.doc
          "<p>Information about the instances whose credit option for CPU usage was not modified.</p>"]}
    let make ?(successful_instance_credit_specifications= []) 
      ?(unsuccessful_instance_credit_specifications= [])  () =
      {
        successful_instance_credit_specifications;
        unsuccessful_instance_credit_specifications
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnsuccessfulInstanceCreditSpecificationSet",
                   (UnsuccessfulInstanceCreditSpecificationSet.to_query
                      v.unsuccessful_instance_credit_specifications)));
           Some
             (Query.Pair
                ("SuccessfulInstanceCreditSpecificationSet",
                  (SuccessfulInstanceCreditSpecificationSet.to_query
                     v.successful_instance_credit_specifications)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful_instance_credit_specifications",
                (UnsuccessfulInstanceCreditSpecificationSet.to_json
                   v.unsuccessful_instance_credit_specifications));
           Some
             ("successful_instance_credit_specifications",
               (SuccessfulInstanceCreditSpecificationSet.to_json
                  v.successful_instance_credit_specifications))])
    let parse xml =
      Some
        {
          successful_instance_credit_specifications =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "successfulInstanceCreditSpecificationSet" xml)
                  SuccessfulInstanceCreditSpecificationSet.parse));
          unsuccessful_instance_credit_specifications =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "unsuccessfulInstanceCreditSpecificationSet"
                     xml) UnsuccessfulInstanceCreditSpecificationSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag
                       "successfulInstanceCreditSpecificationSet"
                       ([],
                         (SuccessfulInstanceCreditSpecificationSet.to_xml [x]))))
               v.successful_instance_credit_specifications))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag
                      "unsuccessfulInstanceCreditSpecificationSet"
                      ([],
                        (UnsuccessfulInstanceCreditSpecificationSet.to_xml
                           [x]))))
              v.unsuccessful_instance_credit_specifications))
  end
module DescribeReservedInstancesOfferingsResult =
  struct
    type t =
      {
      reserved_instances_offerings: ReservedInstancesOfferingList.t
        [@ocaml.doc "<p>A list of Reserved Instances offerings.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    [@@ocaml.doc
      "<p>Contains the output of DescribeReservedInstancesOfferings.</p>"]
    let make ?(reserved_instances_offerings= [])  ?next_token  () =
      { reserved_instances_offerings; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesOfferingsSet",
                  (ReservedInstancesOfferingList.to_query
                     v.reserved_instances_offerings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("reserved_instances_offerings",
               (ReservedInstancesOfferingList.to_json
                  v.reserved_instances_offerings))])
    let parse xml =
      Some
        {
          reserved_instances_offerings =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesOfferingsSet" xml)
                  ReservedInstancesOfferingList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "reservedInstancesOfferingsSet"
                       ([], (ReservedInstancesOfferingList.to_xml [x]))))
               v.reserved_instances_offerings))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>Contains the output of DescribeReservedInstancesOfferings.</p>"]
module AuthorizeClientVpnIngressResult =
  struct
    type t =
      {
      status: ClientVpnAuthorizationRuleStatus.t option
        [@ocaml.doc "<p>The current state of the authorization rule.</p>"]}
    let make ?status  () = { status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair
                   ("Status", (ClientVpnAuthorizationRuleStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 ("status", (ClientVpnAuthorizationRuleStatus.to_json f)))])
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnAuthorizationRuleStatus.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status"
                   ([], (ClientVpnAuthorizationRuleStatus.to_xml f)))])
  end
module DescribeScheduledInstanceAvailabilityResult =
  struct
    type t =
      {
      next_token: String.t option
        [@ocaml.doc
          "<p>The token required to retrieve the next set of results. This value is <code>null</code> when there are no more results to return.</p>"];
      scheduled_instance_availability_set: ScheduledInstanceAvailabilitySet.t
        [@ocaml.doc
          "<p>Information about the available Scheduled Instances.</p>"]}
    [@@ocaml.doc
      "<p>Contains the output of DescribeScheduledInstanceAvailability.</p>"]
    let make ?next_token  ?(scheduled_instance_availability_set= [])  () =
      { next_token; scheduled_instance_availability_set }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ScheduledInstanceAvailabilitySet",
                   (ScheduledInstanceAvailabilitySet.to_query
                      v.scheduled_instance_availability_set)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("scheduled_instance_availability_set",
                (ScheduledInstanceAvailabilitySet.to_json
                   v.scheduled_instance_availability_set));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          scheduled_instance_availability_set =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "scheduledInstanceAvailabilitySet" xml)
                  ScheduledInstanceAvailabilitySet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "scheduledInstanceAvailabilitySet"
                      ([], (ScheduledInstanceAvailabilitySet.to_xml [x]))))
              v.scheduled_instance_availability_set))
  end[@@ocaml.doc
       "<p>Contains the output of DescribeScheduledInstanceAvailability.</p>"]
module DescribeInstancesResult =
  struct
    type t =
      {
      reservations: ReservationList.t
        [@ocaml.doc "<p>Information about the reservations.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(reservations= [])  ?next_token  () =
      { reservations; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservationSet", (ReservationList.to_query v.reservations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("reservations", (ReservationList.to_json v.reservations))])
    let parse xml =
      Some
        {
          reservations =
            (Util.of_option []
               (Util.option_bind (Xml.member "reservationSet" xml)
                  ReservationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "reservationSet"
                       ([], (ReservationList.to_xml [x])))) v.reservations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DeleteClientVpnRouteResult =
  struct
    type t =
      {
      status: ClientVpnRouteStatus.t option
        [@ocaml.doc "<p>The current state of the route.</p>"]}
    let make ?status  () = { status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair ("Status", (ClientVpnRouteStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (ClientVpnRouteStatus.to_json f)))])
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnRouteStatus.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status"
                   ([], (ClientVpnRouteStatus.to_xml f)))])
  end
module DescribeIdentityIdFormatResult =
  struct
    type t =
      {
      statuses: IdFormatList.t
        [@ocaml.doc
          "<p>Information about the ID format for the resources.</p>"]}
    let make ?(statuses= [])  () = { statuses }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("StatusSet", (IdFormatList.to_query v.statuses)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("statuses", (IdFormatList.to_json v.statuses))])
    let parse xml =
      Some
        {
          statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "statusSet" xml)
                  IdFormatList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "statusSet"
                      ([], (IdFormatList.to_xml [x])))) v.statuses))
  end
module CreateVpcResult =
  struct
    type t =
      {
      vpc: Vpc.t option [@ocaml.doc "<p>Information about the VPC.</p>"]}
    let make ?vpc  () = { vpc }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc
              (fun f -> Query.Pair ("Vpc", (Vpc.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc (fun f -> ("vpc", (Vpc.to_json f)))])
    let parse xml =
      Some { vpc = (Util.option_bind (Xml.member "vpc" xml) Vpc.parse) }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpc
              (fun f -> Ezxmlm.make_tag "vpc" ([], (Vpc.to_xml f)))])
  end
module PurchaseHostReservationResult =
  struct
    type t =
      {
      client_token: String.t option
        [@ocaml.doc
          "<p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html\">How to Ensure Idempotency</a>.</p>"];
      currency_code: CurrencyCodeValues.t option
        [@ocaml.doc
          "<p>The currency in which the <code>totalUpfrontPrice</code> and <code>totalHourlyPrice</code> amounts are specified. At this time, the only supported currency is <code>USD</code>.</p>"];
      purchase: PurchaseSet.t
        [@ocaml.doc "<p>Describes the details of the purchase.</p>"];
      total_hourly_price: String.t option
        [@ocaml.doc
          "<p>The total hourly price of the reservation calculated per hour.</p>"];
      total_upfront_price: String.t option
        [@ocaml.doc
          "<p>The total amount charged to your account when you purchase the reservation.</p>"]}
    let make ?client_token  ?currency_code  ?(purchase= []) 
      ?total_hourly_price  ?total_upfront_price  () =
      {
        client_token;
        currency_code;
        purchase;
        total_hourly_price;
        total_upfront_price
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_upfront_price
              (fun f -> Query.Pair ("TotalUpfrontPrice", (String.to_query f)));
           Util.option_map v.total_hourly_price
             (fun f -> Query.Pair ("TotalHourlyPrice", (String.to_query f)));
           Some (Query.Pair ("Purchase", (PurchaseSet.to_query v.purchase)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_upfront_price
              (fun f -> ("total_upfront_price", (String.to_json f)));
           Util.option_map v.total_hourly_price
             (fun f -> ("total_hourly_price", (String.to_json f)));
           Some ("purchase", (PurchaseSet.to_json v.purchase));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          purchase =
            (Util.of_option []
               (Util.option_bind (Xml.member "purchase" xml)
                  PurchaseSet.parse));
          total_hourly_price =
            (Util.option_bind (Xml.member "totalHourlyPrice" xml)
               String.parse);
          total_upfront_price =
            (Util.option_bind (Xml.member "totalUpfrontPrice" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.client_token
                  (fun f ->
                     Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
              @
              [Util.option_map v.currency_code
                 (fun f ->
                    Ezxmlm.make_tag "currencyCode"
                      ([], (CurrencyCodeValues.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "purchase"
                        ([], (PurchaseSet.to_xml [x])))) v.purchase))
            @
            [Util.option_map v.total_hourly_price
               (fun f ->
                  Ezxmlm.make_tag "totalHourlyPrice" ([], (String.to_xml f)))])
           @
           [Util.option_map v.total_upfront_price
              (fun f ->
                 Ezxmlm.make_tag "totalUpfrontPrice" ([], (String.to_xml f)))])
  end
module CreateClientVpnRouteResult =
  struct
    type t =
      {
      status: ClientVpnRouteStatus.t option
        [@ocaml.doc "<p>The current state of the route.</p>"]}
    let make ?status  () = { status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair ("Status", (ClientVpnRouteStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (ClientVpnRouteStatus.to_json f)))])
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnRouteStatus.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status"
                   ([], (ClientVpnRouteStatus.to_xml f)))])
  end
module DescribePublicIpv4PoolsResult =
  struct
    type t =
      {
      public_ipv4_pools: PublicIpv4PoolSet.t
        [@ocaml.doc "<p>Information about the address pools.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(public_ipv4_pools= [])  ?next_token  () =
      { public_ipv4_pools; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("PublicIpv4PoolSet",
                  (PublicIpv4PoolSet.to_query v.public_ipv4_pools)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("public_ipv4_pools",
               (PublicIpv4PoolSet.to_json v.public_ipv4_pools))])
    let parse xml =
      Some
        {
          public_ipv4_pools =
            (Util.of_option []
               (Util.option_bind (Xml.member "publicIpv4PoolSet" xml)
                  PublicIpv4PoolSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "publicIpv4PoolSet"
                       ([], (PublicIpv4PoolSet.to_xml [x]))))
               v.public_ipv4_pools))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeVolumeAttributeResult =
  struct
    type t =
      {
      auto_enable_i_o: AttributeBooleanValue.t option
        [@ocaml.doc
          "<p>The state of <code>autoEnableIO</code> attribute.</p>"];
      product_codes: ProductCodeList.t
        [@ocaml.doc "<p>A list of product codes.</p>"];
      volume_id: String.t option [@ocaml.doc "<p>The ID of the volume.</p>"]}
    let make ?auto_enable_i_o  ?(product_codes= [])  ?volume_id  () =
      { auto_enable_i_o; product_codes; volume_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Util.option_map v.auto_enable_i_o
             (fun f ->
                Query.Pair
                  ("AutoEnableIO", (AttributeBooleanValue.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> ("volume_id", (String.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Util.option_map v.auto_enable_i_o
             (fun f -> ("auto_enable_i_o", (AttributeBooleanValue.to_json f)))])
    let parse xml =
      Some
        {
          auto_enable_i_o =
            (Util.option_bind (Xml.member "autoEnableIO" xml)
               AttributeBooleanValue.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.auto_enable_i_o
                (fun f ->
                   Ezxmlm.make_tag "autoEnableIO"
                     ([], (AttributeBooleanValue.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "productCodes"
                       ([], (ProductCodeList.to_xml [x])))) v.product_codes))
           @
           [Util.option_map v.volume_id
              (fun f -> Ezxmlm.make_tag "volumeId" ([], (String.to_xml f)))])
  end
module DescribeVpcsResult =
  struct
    type t =
      {
      vpcs: VpcList.t
        [@ocaml.doc "<p>Information about one or more VPCs.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(vpcs= [])  ?next_token  () = { vpcs; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("VpcSet", (VpcList.to_query v.vpcs)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("vpcs", (VpcList.to_json v.vpcs))])
    let parse xml =
      Some
        {
          vpcs =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcSet" xml) VpcList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "vpcSet" ([], (VpcList.to_xml [x]))))
               v.vpcs))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DescribeLocalGatewaysResult =
  struct
    type t =
      {
      local_gateways: LocalGatewaySet.t
        [@ocaml.doc "<p>Information about the local gateways.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(local_gateways= [])  ?next_token  () =
      { local_gateways; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewaySet",
                  (LocalGatewaySet.to_query v.local_gateways)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateways", (LocalGatewaySet.to_json v.local_gateways))])
    let parse xml =
      Some
        {
          local_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "localGatewaySet" xml)
                  LocalGatewaySet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "localGatewaySet"
                       ([], (LocalGatewaySet.to_xml [x])))) v.local_gateways))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module ModifyLaunchTemplateResult =
  struct
    type t =
      {
      launch_template: LaunchTemplate.t option
        [@ocaml.doc "<p>Information about the launch template.</p>"]}
    let make ?launch_template  () = { launch_template }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template
              (fun f ->
                 Query.Pair ("LaunchTemplate", (LaunchTemplate.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template
              (fun f -> ("launch_template", (LaunchTemplate.to_json f)))])
    let parse xml =
      Some
        {
          launch_template =
            (Util.option_bind (Xml.member "launchTemplate" xml)
               LaunchTemplate.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.launch_template
              (fun f ->
                 Ezxmlm.make_tag "launchTemplate"
                   ([], (LaunchTemplate.to_xml f)))])
  end
module DescribeSubnetsResult =
  struct
    type t =
      {
      subnets: SubnetList.t
        [@ocaml.doc "<p>Information about one or more subnets.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(subnets= [])  ?next_token  () = { subnets; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("SubnetSet", (SubnetList.to_query v.subnets)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("subnets", (SubnetList.to_json v.subnets))])
    let parse xml =
      Some
        {
          subnets =
            (Util.of_option []
               (Util.option_bind (Xml.member "subnetSet" xml)
                  SubnetList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "subnetSet"
                       ([], (SubnetList.to_xml [x])))) v.subnets))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module CancelBundleTaskResult =
  struct
    type t =
      {
      bundle_task: BundleTask.t option
        [@ocaml.doc "<p>Information about the bundle task.</p>"]}[@@ocaml.doc
                                                                   "<p>Contains the output of CancelBundleTask.</p>"]
    let make ?bundle_task  () = { bundle_task }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.bundle_task
              (fun f ->
                 Query.Pair ("BundleInstanceTask", (BundleTask.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.bundle_task
              (fun f -> ("bundle_task", (BundleTask.to_json f)))])
    let parse xml =
      Some
        {
          bundle_task =
            (Util.option_bind (Xml.member "bundleInstanceTask" xml)
               BundleTask.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.bundle_task
              (fun f ->
                 Ezxmlm.make_tag "bundleInstanceTask"
                   ([], (BundleTask.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of CancelBundleTask.</p>"]
module AssignIpv6AddressesResult =
  struct
    type t =
      {
      assigned_ipv6_addresses: Ipv6AddressList.t
        [@ocaml.doc
          "<p>The IPv6 addresses assigned to the network interface.</p>"];
      network_interface_id: String.t option
        [@ocaml.doc "<p>The ID of the network interface.</p>"]}
    let make ?(assigned_ipv6_addresses= [])  ?network_interface_id  () =
      { assigned_ipv6_addresses; network_interface_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_interface_id
              (fun f ->
                 Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("AssignedIpv6Addresses",
                  (Ipv6AddressList.to_query v.assigned_ipv6_addresses)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_interface_id
              (fun f -> ("network_interface_id", (String.to_json f)));
           Some
             ("assigned_ipv6_addresses",
               (Ipv6AddressList.to_json v.assigned_ipv6_addresses))])
    let parse xml =
      Some
        {
          assigned_ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "assignedIpv6Addresses" xml)
                  Ipv6AddressList.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "assignedIpv6Addresses"
                       ([], (Ipv6AddressList.to_xml [x]))))
               v.assigned_ipv6_addresses))
           @
           [Util.option_map v.network_interface_id
              (fun f ->
                 Ezxmlm.make_tag "networkInterfaceId" ([], (String.to_xml f)))])
  end
module DescribeElasticGpusResult =
  struct
    type t =
      {
      elastic_gpu_set: ElasticGpuSet.t
        [@ocaml.doc
          "<p>Information about the Elastic Graphics accelerators.</p>"];
      max_results: Integer.t option
        [@ocaml.doc
          "<p>The total number of items to return. If the total number of items available is more than the value specified in max-items then a Next-Token will be provided in the output that you can use to resume pagination.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(elastic_gpu_set= [])  ?max_results  ?next_token  () =
      { elastic_gpu_set; max_results; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("ElasticGpuSet", (ElasticGpuSet.to_query v.elastic_gpu_set)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("elastic_gpu_set", (ElasticGpuSet.to_json v.elastic_gpu_set))])
    let parse xml =
      Some
        {
          elastic_gpu_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "elasticGpuSet" xml)
                  ElasticGpuSet.parse));
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "elasticGpuSet"
                        ([], (ElasticGpuSet.to_xml [x])))) v.elastic_gpu_set))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "maxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DisassociateClientVpnTargetNetworkResult =
  struct
    type t =
      {
      association_id: String.t option
        [@ocaml.doc "<p>The ID of the target network association.</p>"];
      status: AssociationStatus.t option
        [@ocaml.doc
          "<p>The current state of the target network association.</p>"]}
    let make ?association_id  ?status  () = { association_id; status }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (AssociationStatus.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (AssociationStatus.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AssociationStatus.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.association_id
               (fun f ->
                  Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status" ([], (AssociationStatus.to_xml f)))])
  end
module DescribeVpcClassicLinkResult =
  struct
    type t =
      {
      vpcs: VpcClassicLinkList.t
        [@ocaml.doc "<p>The ClassicLink status of one or more VPCs.</p>"]}
    let make ?(vpcs= [])  () = { vpcs }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("VpcSet", (VpcClassicLinkList.to_query v.vpcs)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpcs", (VpcClassicLinkList.to_json v.vpcs))])
    let parse xml =
      Some
        {
          vpcs =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcSet" xml)
                  VpcClassicLinkList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "vpcSet"
                      ([], (VpcClassicLinkList.to_xml [x])))) v.vpcs))
  end
module DescribeImportImageTasksResult =
  struct
    type t =
      {
      import_image_tasks: ImportImageTaskList.t
        [@ocaml.doc
          "<p>A list of zero or more import image tasks that are currently active or were completed or canceled in the previous 7 days.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to get the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(import_image_tasks= [])  ?next_token  () =
      { import_image_tasks; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ImportImageTaskSet",
                  (ImportImageTaskList.to_query v.import_image_tasks)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("import_image_tasks",
               (ImportImageTaskList.to_json v.import_image_tasks))])
    let parse xml =
      Some
        {
          import_image_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "importImageTaskSet" xml)
                  ImportImageTaskList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "importImageTaskSet"
                       ([], (ImportImageTaskList.to_xml [x]))))
               v.import_image_tasks))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DisableEbsEncryptionByDefaultResult =
  struct
    type t =
      {
      ebs_encryption_by_default: Boolean.t option
        [@ocaml.doc "<p>The updated status of encryption by default.</p>"]}
    let make ?ebs_encryption_by_default  () = { ebs_encryption_by_default }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f ->
                 Query.Pair ("EbsEncryptionByDefault", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f -> ("ebs_encryption_by_default", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          ebs_encryption_by_default =
            (Util.option_bind (Xml.member "ebsEncryptionByDefault" xml)
               Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ebs_encryption_by_default
              (fun f ->
                 Ezxmlm.make_tag "ebsEncryptionByDefault"
                   ([], (Boolean.to_xml f)))])
  end
module ProvisionByoipCidrResult =
  struct
    type t =
      {
      byoip_cidr: ByoipCidr.t option
        [@ocaml.doc "<p>Information about the address pool.</p>"]}
    let make ?byoip_cidr  () = { byoip_cidr }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> Query.Pair ("ByoipCidr", (ByoipCidr.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> ("byoip_cidr", (ByoipCidr.to_json f)))])
    let parse xml =
      Some
        {
          byoip_cidr =
            (Util.option_bind (Xml.member "byoipCidr" xml) ByoipCidr.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.byoip_cidr
              (fun f ->
                 Ezxmlm.make_tag "byoipCidr" ([], (ByoipCidr.to_xml f)))])
  end
module CreateEgressOnlyInternetGatewayResult =
  struct
    type t =
      {
      client_token: String.t option
        [@ocaml.doc
          "<p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.</p>"];
      egress_only_internet_gateway: EgressOnlyInternetGateway.t option
        [@ocaml.doc
          "<p>Information about the egress-only internet gateway.</p>"]}
    let make ?client_token  ?egress_only_internet_gateway  () =
      { client_token; egress_only_internet_gateway }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.egress_only_internet_gateway
              (fun f ->
                 Query.Pair
                   ("EgressOnlyInternetGateway",
                     (EgressOnlyInternetGateway.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.egress_only_internet_gateway
              (fun f ->
                 ("egress_only_internet_gateway",
                   (EgressOnlyInternetGateway.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          egress_only_internet_gateway =
            (Util.option_bind (Xml.member "egressOnlyInternetGateway" xml)
               EgressOnlyInternetGateway.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.client_token
               (fun f ->
                  Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.egress_only_internet_gateway
              (fun f ->
                 Ezxmlm.make_tag "egressOnlyInternetGateway"
                   ([], (EgressOnlyInternetGateway.to_xml f)))])
  end
module ModifySpotFleetRequestResponse =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Is <code>true</code> if the request succeeds, and an error otherwise.</p>"]}
    [@@ocaml.doc "<p>Contains the output of ModifySpotFleetRequest.</p>"]
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the output of ModifySpotFleetRequest.</p>"]
module CopyFpgaImageResult =
  struct
    type t =
      {
      fpga_image_id: String.t option
        [@ocaml.doc "<p>The ID of the new AFI.</p>"]}
    let make ?fpga_image_id  () = { fpga_image_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_id
              (fun f -> Query.Pair ("FpgaImageId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_id
              (fun f -> ("fpga_image_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          fpga_image_id =
            (Util.option_bind (Xml.member "fpgaImageId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.fpga_image_id
              (fun f -> Ezxmlm.make_tag "fpgaImageId" ([], (String.to_xml f)))])
  end
module AcceptReservedInstancesExchangeQuoteResult =
  struct
    type t =
      {
      exchange_id: String.t option
        [@ocaml.doc "<p>The ID of the successful exchange.</p>"]}[@@ocaml.doc
                                                                   "<p>The result of the exchange and whether it was <code>successful</code>.</p>"]
    let make ?exchange_id  () = { exchange_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.exchange_id
              (fun f -> Query.Pair ("ExchangeId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.exchange_id
              (fun f -> ("exchange_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          exchange_id =
            (Util.option_bind (Xml.member "exchangeId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.exchange_id
              (fun f -> Ezxmlm.make_tag "exchangeId" ([], (String.to_xml f)))])
  end[@@ocaml.doc
       "<p>The result of the exchange and whether it was <code>successful</code>.</p>"]
module DescribeAggregateIdFormatResult =
  struct
    type t =
      {
      use_long_ids_aggregated: Boolean.t option
        [@ocaml.doc
          "<p>Indicates whether all resource types in the Region are configured to use longer IDs. This value is only <code>true</code> if all users are configured to use longer IDs for all resources types in the Region.</p>"];
      statuses: IdFormatList.t
        [@ocaml.doc "<p>Information about each resource's ID format.</p>"]}
    let make ?use_long_ids_aggregated  ?(statuses= [])  () =
      { use_long_ids_aggregated; statuses }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("StatusSet", (IdFormatList.to_query v.statuses)));
           Util.option_map v.use_long_ids_aggregated
             (fun f ->
                Query.Pair ("UseLongIdsAggregated", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("statuses", (IdFormatList.to_json v.statuses));
           Util.option_map v.use_long_ids_aggregated
             (fun f -> ("use_long_ids_aggregated", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          use_long_ids_aggregated =
            (Util.option_bind (Xml.member "useLongIdsAggregated" xml)
               Boolean.parse);
          statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "statusSet" xml)
                  IdFormatList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.use_long_ids_aggregated
               (fun f ->
                  Ezxmlm.make_tag "useLongIdsAggregated"
                    ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "statusSet"
                      ([], (IdFormatList.to_xml [x])))) v.statuses))
  end
module DescribeSpotPriceHistoryResult =
  struct
    type t =
      {
      next_token: String.t option
        [@ocaml.doc
          "<p>The token required to retrieve the next set of results. This value is null or an empty string when there are no more results to return.</p>"];
      spot_price_history: SpotPriceHistoryList.t
        [@ocaml.doc "<p>The historical Spot prices.</p>"]}[@@ocaml.doc
                                                            "<p>Contains the output of DescribeSpotPriceHistory.</p>"]
    let make ?next_token  ?(spot_price_history= [])  () =
      { next_token; spot_price_history }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotPriceHistorySet",
                   (SpotPriceHistoryList.to_query v.spot_price_history)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_price_history",
                (SpotPriceHistoryList.to_json v.spot_price_history));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_price_history =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotPriceHistorySet" xml)
                  SpotPriceHistoryList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "spotPriceHistorySet"
                      ([], (SpotPriceHistoryList.to_xml [x]))))
              v.spot_price_history))
  end[@@ocaml.doc "<p>Contains the output of DescribeSpotPriceHistory.</p>"]
module ImportClientVpnClientCertificateRevocationListResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, it returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module AssociateRouteTableResult =
  struct
    type t =
      {
      association_id: String.t option
        [@ocaml.doc
          "<p>The route table association ID. This ID is required for disassociating the route table.</p>"];
      association_state: RouteTableAssociationState.t option
        [@ocaml.doc "<p>The state of the association.</p>"]}
    let make ?association_id  ?association_state  () =
      { association_id; association_state }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 Query.Pair
                   ("AssociationState",
                     (RouteTableAssociationState.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 ("association_state",
                   (RouteTableAssociationState.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          association_state =
            (Util.option_bind (Xml.member "associationState" xml)
               RouteTableAssociationState.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.association_id
               (fun f ->
                  Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.association_state
              (fun f ->
                 Ezxmlm.make_tag "associationState"
                   ([], (RouteTableAssociationState.to_xml f)))])
  end
module CreateVpcEndpointConnectionNotificationResult =
  struct
    type t =
      {
      connection_notification: ConnectionNotification.t option
        [@ocaml.doc "<p>Information about the notification.</p>"];
      client_token: String.t option
        [@ocaml.doc
          "<p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request.</p>"]}
    let make ?connection_notification  ?client_token  () =
      { connection_notification; client_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.connection_notification
             (fun f ->
                Query.Pair
                  ("ConnectionNotification",
                    (ConnectionNotification.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.connection_notification
             (fun f ->
                ("connection_notification",
                  (ConnectionNotification.to_json f)))])
    let parse xml =
      Some
        {
          connection_notification =
            (Util.option_bind (Xml.member "connectionNotification" xml)
               ConnectionNotification.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.connection_notification
               (fun f ->
                  Ezxmlm.make_tag "connectionNotification"
                    ([], (ConnectionNotification.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
  end
module DeleteTransitGatewayRouteResult =
  struct
    type t =
      {
      route: TransitGatewayRoute.t option
        [@ocaml.doc "<p>Information about the route.</p>"]}
    let make ?route  () = { route }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f ->
                 Query.Pair ("Route", (TransitGatewayRoute.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> ("route", (TransitGatewayRoute.to_json f)))])
    let parse xml =
      Some
        {
          route =
            (Util.option_bind (Xml.member "route" xml)
               TransitGatewayRoute.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.route
              (fun f ->
                 Ezxmlm.make_tag "route" ([], (TransitGatewayRoute.to_xml f)))])
  end
module CreateInternetGatewayResult =
  struct
    type t =
      {
      internet_gateway: InternetGateway.t option
        [@ocaml.doc "<p>Information about the internet gateway.</p>"]}
    let make ?internet_gateway  () = { internet_gateway }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.internet_gateway
              (fun f ->
                 Query.Pair ("InternetGateway", (InternetGateway.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.internet_gateway
              (fun f -> ("internet_gateway", (InternetGateway.to_json f)))])
    let parse xml =
      Some
        {
          internet_gateway =
            (Util.option_bind (Xml.member "internetGateway" xml)
               InternetGateway.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.internet_gateway
              (fun f ->
                 Ezxmlm.make_tag "internetGateway"
                   ([], (InternetGateway.to_xml f)))])
  end
module DescribeIdFormatResult =
  struct
    type t =
      {
      statuses: IdFormatList.t
        [@ocaml.doc
          "<p>Information about the ID format for the resource.</p>"]}
    let make ?(statuses= [])  () = { statuses }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("StatusSet", (IdFormatList.to_query v.statuses)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("statuses", (IdFormatList.to_json v.statuses))])
    let parse xml =
      Some
        {
          statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "statusSet" xml)
                  IdFormatList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "statusSet"
                      ([], (IdFormatList.to_xml [x])))) v.statuses))
  end
module EnableTransitGatewayRouteTablePropagationResult =
  struct
    type t =
      {
      propagation: TransitGatewayPropagation.t option
        [@ocaml.doc "<p>Information about route propagation.</p>"]}
    let make ?propagation  () = { propagation }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.propagation
              (fun f ->
                 Query.Pair
                   ("Propagation", (TransitGatewayPropagation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.propagation
              (fun f ->
                 ("propagation", (TransitGatewayPropagation.to_json f)))])
    let parse xml =
      Some
        {
          propagation =
            (Util.option_bind (Xml.member "propagation" xml)
               TransitGatewayPropagation.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.propagation
              (fun f ->
                 Ezxmlm.make_tag "propagation"
                   ([], (TransitGatewayPropagation.to_xml f)))])
  end
module MonitorInstancesResult =
  struct
    type t =
      {
      instance_monitorings: InstanceMonitoringList.t
        [@ocaml.doc "<p>The monitoring information.</p>"]}
    let make ?(instance_monitorings= [])  () = { instance_monitorings }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceMonitoringList.to_query v.instance_monitorings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_monitorings",
                (InstanceMonitoringList.to_json v.instance_monitorings))])
    let parse xml =
      Some
        {
          instance_monitorings =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceMonitoringList.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "instancesSet"
                      ([], (InstanceMonitoringList.to_xml [x]))))
              v.instance_monitorings))
  end
module DeleteTransitGatewayMulticastDomainResult =
  struct
    type t =
      {
      transit_gateway_multicast_domain:
        TransitGatewayMulticastDomain.t option
        [@ocaml.doc
          "<p>Information about the deleted transit gateway multicast domain.</p>"]}
    let make ?transit_gateway_multicast_domain  () =
      { transit_gateway_multicast_domain }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_multicast_domain
              (fun f ->
                 Query.Pair
                   ("TransitGatewayMulticastDomain",
                     (TransitGatewayMulticastDomain.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_multicast_domain
              (fun f ->
                 ("transit_gateway_multicast_domain",
                   (TransitGatewayMulticastDomain.to_json f)))])
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomain" xml)
               TransitGatewayMulticastDomain.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_multicast_domain
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayMulticastDomain"
                   ([], (TransitGatewayMulticastDomain.to_xml f)))])
  end
module SearchLocalGatewayRoutesResult =
  struct
    type t =
      {
      routes: LocalGatewayRouteList.t
        [@ocaml.doc "<p>Information about the routes.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(routes= [])  ?next_token  () = { routes; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("RouteSet", (LocalGatewayRouteList.to_query v.routes)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("routes", (LocalGatewayRouteList.to_json v.routes))])
    let parse xml =
      Some
        {
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeSet" xml)
                  LocalGatewayRouteList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "routeSet"
                       ([], (LocalGatewayRouteList.to_xml [x])))) v.routes))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module UpdateSecurityGroupRuleDescriptionsEgressResult =
  struct
    type t =
      {
      return: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, returns an error.</p>"]}
    let make ?return  () = { return }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module DescribeVpcAttributeResult =
  struct
    type t =
      {
      vpc_id: String.t option [@ocaml.doc "<p>The ID of the VPC.</p>"];
      enable_dns_hostnames: AttributeBooleanValue.t option
        [@ocaml.doc
          "<p>Indicates whether the instances launched in the VPC get DNS hostnames. If this attribute is <code>true</code>, instances in the VPC get DNS hostnames; otherwise, they do not.</p>"];
      enable_dns_support: AttributeBooleanValue.t option
        [@ocaml.doc
          "<p>Indicates whether DNS resolution is enabled for the VPC. If this attribute is <code>true</code>, the Amazon DNS server resolves DNS hostnames for your instances to their corresponding IP addresses; otherwise, it does not.</p>"]}
    let make ?vpc_id  ?enable_dns_hostnames  ?enable_dns_support  () =
      { vpc_id; enable_dns_hostnames; enable_dns_support }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enable_dns_support
              (fun f ->
                 Query.Pair
                   ("EnableDnsSupport", (AttributeBooleanValue.to_query f)));
           Util.option_map v.enable_dns_hostnames
             (fun f ->
                Query.Pair
                  ("EnableDnsHostnames", (AttributeBooleanValue.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enable_dns_support
              (fun f ->
                 ("enable_dns_support", (AttributeBooleanValue.to_json f)));
           Util.option_map v.enable_dns_hostnames
             (fun f ->
                ("enable_dns_hostnames", (AttributeBooleanValue.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          enable_dns_hostnames =
            (Util.option_bind (Xml.member "enableDnsHostnames" xml)
               AttributeBooleanValue.parse);
          enable_dns_support =
            (Util.option_bind (Xml.member "enableDnsSupport" xml)
               AttributeBooleanValue.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.vpc_id
                (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.enable_dns_hostnames
               (fun f ->
                  Ezxmlm.make_tag "enableDnsHostnames"
                    ([], (AttributeBooleanValue.to_xml f)))])
           @
           [Util.option_map v.enable_dns_support
              (fun f ->
                 Ezxmlm.make_tag "enableDnsSupport"
                   ([], (AttributeBooleanValue.to_xml f)))])
  end
module DescribeNatGatewaysResult =
  struct
    type t =
      {
      nat_gateways: NatGatewayList.t
        [@ocaml.doc "<p>Information about the NAT gateways.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(nat_gateways= [])  ?next_token  () =
      { nat_gateways; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NatGatewaySet", (NatGatewayList.to_query v.nat_gateways)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("nat_gateways", (NatGatewayList.to_json v.nat_gateways))])
    let parse xml =
      Some
        {
          nat_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "natGatewaySet" xml)
                  NatGatewayList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "natGatewaySet"
                       ([], (NatGatewayList.to_xml [x])))) v.nat_gateways))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module GetCapacityReservationUsageResult =
  struct
    type t =
      {
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"];
      capacity_reservation_id: String.t option
        [@ocaml.doc "<p>The ID of the Capacity Reservation.</p>"];
      instance_type: String.t option
        [@ocaml.doc
          "<p>The type of instance for which the Capacity Reservation reserves capacity.</p>"];
      total_instance_count: Integer.t option
        [@ocaml.doc
          "<p>The number of instances for which the Capacity Reservation reserves capacity.</p>"];
      available_instance_count: Integer.t option
        [@ocaml.doc
          "<p>The remaining capacity. Indicates the number of instances that can be launched in the Capacity Reservation.</p>"];
      state: CapacityReservationState.t option
        [@ocaml.doc
          "<p>The current state of the Capacity Reservation. A Capacity Reservation can be in one of the following states:</p> <ul> <li> <p> <code>active</code> - The Capacity Reservation is active and the capacity is available for your use.</p> </li> <li> <p> <code>expired</code> - The Capacity Reservation expired automatically at the date and time specified in your request. The reserved capacity is no longer available for your use.</p> </li> <li> <p> <code>cancelled</code> - The Capacity Reservation was manually cancelled. The reserved capacity is no longer available for your use.</p> </li> <li> <p> <code>pending</code> - The Capacity Reservation request was successful but the capacity provisioning is still pending.</p> </li> <li> <p> <code>failed</code> - The Capacity Reservation request has failed. A request might fail due to invalid request parameters, capacity constraints, or instance limit constraints. Failed requests are retained for 60 minutes.</p> </li> </ul>"];
      instance_usages: InstanceUsageSet.t
        [@ocaml.doc
          "<p>Information about the Capacity Reservation usage.</p>"]}
    let make ?next_token  ?capacity_reservation_id  ?instance_type 
      ?total_instance_count  ?available_instance_count  ?state 
      ?(instance_usages= [])  () =
      {
        next_token;
        capacity_reservation_id;
        instance_type;
        total_instance_count;
        available_instance_count;
        state;
        instance_usages
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstanceUsageSet",
                   (InstanceUsageSet.to_query v.instance_usages)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (CapacityReservationState.to_query f)));
           Util.option_map v.available_instance_count
             (fun f ->
                Query.Pair ("AvailableInstanceCount", (Integer.to_query f)));
           Util.option_map v.total_instance_count
             (fun f ->
                Query.Pair ("TotalInstanceCount", (Integer.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.capacity_reservation_id
             (fun f ->
                Query.Pair ("CapacityReservationId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_usages",
                (InstanceUsageSet.to_json v.instance_usages));
           Util.option_map v.state
             (fun f -> ("state", (CapacityReservationState.to_json f)));
           Util.option_map v.available_instance_count
             (fun f -> ("available_instance_count", (Integer.to_json f)));
           Util.option_map v.total_instance_count
             (fun f -> ("total_instance_count", (Integer.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.capacity_reservation_id
             (fun f -> ("capacity_reservation_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          capacity_reservation_id =
            (Util.option_bind (Xml.member "capacityReservationId" xml)
               String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          total_instance_count =
            (Util.option_bind (Xml.member "totalInstanceCount" xml)
               Integer.parse);
          available_instance_count =
            (Util.option_bind (Xml.member "availableInstanceCount" xml)
               Integer.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               CapacityReservationState.parse);
          instance_usages =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceUsageSet" xml)
                  InstanceUsageSet.parse))
        }
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.next_token
                    (fun f ->
                       Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
                @
                [Util.option_map v.capacity_reservation_id
                   (fun f ->
                      Ezxmlm.make_tag "capacityReservationId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.instance_type
                  (fun f ->
                     Ezxmlm.make_tag "instanceType" ([], (String.to_xml f)))])
              @
              [Util.option_map v.total_instance_count
                 (fun f ->
                    Ezxmlm.make_tag "totalInstanceCount"
                      ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.available_instance_count
                (fun f ->
                   Ezxmlm.make_tag "availableInstanceCount"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.state
               (fun f ->
                  Ezxmlm.make_tag "state"
                    ([], (CapacityReservationState.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "instanceUsageSet"
                      ([], (InstanceUsageSet.to_xml [x])))) v.instance_usages))
  end
module DescribeFastSnapshotRestoresResult =
  struct
    type t =
      {
      fast_snapshot_restores: DescribeFastSnapshotRestoreSuccessSet.t
        [@ocaml.doc
          "<p>Information about the state of fast snapshot restores.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(fast_snapshot_restores= [])  ?next_token  () =
      { fast_snapshot_restores; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("FastSnapshotRestoreSet",
                  (DescribeFastSnapshotRestoreSuccessSet.to_query
                     v.fast_snapshot_restores)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("fast_snapshot_restores",
               (DescribeFastSnapshotRestoreSuccessSet.to_json
                  v.fast_snapshot_restores))])
    let parse xml =
      Some
        {
          fast_snapshot_restores =
            (Util.of_option []
               (Util.option_bind (Xml.member "fastSnapshotRestoreSet" xml)
                  DescribeFastSnapshotRestoreSuccessSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "fastSnapshotRestoreSet"
                       ([],
                         (DescribeFastSnapshotRestoreSuccessSet.to_xml [x]))))
               v.fast_snapshot_restores))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module DeleteNatGatewayResult =
  struct
    type t =
      {
      nat_gateway_id: String.t option
        [@ocaml.doc "<p>The ID of the NAT gateway.</p>"]}
    let make ?nat_gateway_id  () = { nat_gateway_id }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.nat_gateway_id
              (fun f -> Query.Pair ("NatGatewayId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.nat_gateway_id
              (fun f -> ("nat_gateway_id", (String.to_json f)))])
    let parse xml =
      Some
        {
          nat_gateway_id =
            (Util.option_bind (Xml.member "natGatewayId" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.nat_gateway_id
              (fun f ->
                 Ezxmlm.make_tag "natGatewayId" ([], (String.to_xml f)))])
  end
module ExportClientVpnClientConfigurationResult =
  struct
    type t =
      {
      client_configuration: String.t option
        [@ocaml.doc
          "<p>The contents of the Client VPN endpoint configuration file.</p>"]}
    let make ?client_configuration  () = { client_configuration }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_configuration
              (fun f ->
                 Query.Pair ("ClientConfiguration", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_configuration
              (fun f -> ("client_configuration", (String.to_json f)))])
    let parse xml =
      Some
        {
          client_configuration =
            (Util.option_bind (Xml.member "clientConfiguration" xml)
               String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.client_configuration
              (fun f ->
                 Ezxmlm.make_tag "clientConfiguration"
                   ([], (String.to_xml f)))])
  end
module DescribeEgressOnlyInternetGatewaysResult =
  struct
    type t =
      {
      egress_only_internet_gateways: EgressOnlyInternetGatewayList.t
        [@ocaml.doc
          "<p>Information about the egress-only internet gateways.</p>"];
      next_token: String.t option
        [@ocaml.doc
          "<p>The token to use to retrieve the next page of results. This value is <code>null</code> when there are no more results to return.</p>"]}
    let make ?(egress_only_internet_gateways= [])  ?next_token  () =
      { egress_only_internet_gateways; next_token }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("EgressOnlyInternetGatewaySet",
                  (EgressOnlyInternetGatewayList.to_query
                     v.egress_only_internet_gateways)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("egress_only_internet_gateways",
               (EgressOnlyInternetGatewayList.to_json
                  v.egress_only_internet_gateways))])
    let parse xml =
      Some
        {
          egress_only_internet_gateways =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "egressOnlyInternetGatewaySet" xml)
                  EgressOnlyInternetGatewayList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "egressOnlyInternetGatewaySet"
                       ([], (EgressOnlyInternetGatewayList.to_xml [x]))))
               v.egress_only_internet_gateways))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
  end
module ModifyVpcTenancyResult =
  struct
    type t =
      {
      return_value: Boolean.t option
        [@ocaml.doc
          "<p>Returns <code>true</code> if the request succeeds; otherwise, returns an error.</p>"]}
    let make ?return_value  () = { return_value }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> ("return_value", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          return_value =
            (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return_value
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
  end
module ExportTransitGatewayRoutesResult =
  struct
    type t =
      {
      s3_location: String.t option
        [@ocaml.doc
          "<p>The URL of the exported file in Amazon S3. For example, s3://<i>bucket_name</i>/VPCTransitGateway/TransitGatewayRouteTables/<i>file_name</i>.</p>"]}
    let make ?s3_location  () = { s3_location }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_location
              (fun f -> Query.Pair ("S3Location", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_location
              (fun f -> ("s3_location", (String.to_json f)))])
    let parse xml =
      Some
        {
          s3_location =
            (Util.option_bind (Xml.member "s3Location" xml) String.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.s3_location
              (fun f -> Ezxmlm.make_tag "s3Location" ([], (String.to_xml f)))])
  end