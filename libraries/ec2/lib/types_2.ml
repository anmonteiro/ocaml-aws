open Aws
open Aws.BaseTypes
open CalendarLib
type calendar = Calendar.t
open Types_1
module ImageAttributeName =
  struct
    type t =
      | Description 
      | Kernel 
      | Ramdisk 
      | LaunchPermission 
      | ProductCodes 
      | BlockDeviceMapping 
      | SriovNetSupport 
    let str_to_t =
      [("sriovNetSupport", SriovNetSupport);
      ("blockDeviceMapping", BlockDeviceMapping);
      ("productCodes", ProductCodes);
      ("launchPermission", LaunchPermission);
      ("ramdisk", Ramdisk);
      ("kernel", Kernel);
      ("description", Description)]
    let t_to_str =
      [(SriovNetSupport, "sriovNetSupport");
      (BlockDeviceMapping, "blockDeviceMapping");
      (ProductCodes, "productCodes");
      (LaunchPermission, "launchPermission");
      (Ramdisk, "ramdisk");
      (Kernel, "kernel");
      (Description, "description")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SnapshotList =
  struct
    type t = Snapshot.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Snapshot.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Snapshot.to_query v
    let to_headers v = Headers.to_headers_list Snapshot.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Snapshot.to_xml x)))
        v
    let to_json v = `List (List.map Snapshot.to_json v)
    let of_json j = Json.to_list Snapshot.of_json j
  end
module TransitGatewayMulticastDomainIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PurchasedScheduledInstanceSet =
  struct
    type t = ScheduledInstance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ScheduledInstance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ScheduledInstance.to_query v
    let to_headers v = Headers.to_headers_list ScheduledInstance.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ScheduledInstance.to_xml x)))
        v
    let to_json v = `List (List.map ScheduledInstance.to_json v)
    let of_json j = Json.to_list ScheduledInstance.of_json j
  end
module CreateFleetErrorsSet =
  struct
    type t = CreateFleetError.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CreateFleetError.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CreateFleetError.to_query v
    let to_headers v = Headers.to_headers_list CreateFleetError.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (CreateFleetError.to_xml x)))
        v
    let to_json v = `List (List.map CreateFleetError.to_json v)
    let of_json j = Json.to_list CreateFleetError.of_json j
  end
module CreateFleetInstancesSet =
  struct
    type t = CreateFleetInstance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CreateFleetInstance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CreateFleetInstance.to_query v
    let to_headers v =
      Headers.to_headers_list CreateFleetInstance.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (CreateFleetInstance.to_xml x))) v
    let to_json v = `List (List.map CreateFleetInstance.to_json v)
    let of_json j = Json.to_list CreateFleetInstance.of_json j
  end
module SnapshotSet =
  struct
    type t = SnapshotInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map SnapshotInfo.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SnapshotInfo.to_query v
    let to_headers v = Headers.to_headers_list SnapshotInfo.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (SnapshotInfo.to_xml x))) v
    let to_json v = `List (List.map SnapshotInfo.to_json v)
    let of_json j = Json.to_list SnapshotInfo.of_json j
  end
module TrafficMirrorTargetSet =
  struct
    type t = TrafficMirrorTarget.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorTarget.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TrafficMirrorTarget.to_query v
    let to_headers v =
      Headers.to_headers_list TrafficMirrorTarget.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (TrafficMirrorTarget.to_xml x))) v
    let to_json v = `List (List.map TrafficMirrorTarget.to_json v)
    let of_json j = Json.to_list TrafficMirrorTarget.of_json j
  end
module NetworkInterfaceAttribute =
  struct
    type t =
      | Description 
      | GroupSet 
      | SourceDestCheck 
      | Attachment 
    let str_to_t =
      [("attachment", Attachment);
      ("sourceDestCheck", SourceDestCheck);
      ("groupSet", GroupSet);
      ("description", Description)]
    let t_to_str =
      [(Attachment, "attachment");
      (SourceDestCheck, "sourceDestCheck");
      (GroupSet, "groupSet");
      (Description, "description")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TrafficMirrorFilterRuleFieldList =
  struct
    type t = TrafficMirrorFilterRuleField.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorFilterRuleField.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list TrafficMirrorFilterRuleField.to_query v
    let to_headers v =
      Headers.to_headers_list TrafficMirrorFilterRuleField.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TrafficMirrorFilterRuleField.to_xml x))) v
    let to_json v = `List (List.map TrafficMirrorFilterRuleField.to_json v)
    let of_json j = Json.to_list TrafficMirrorFilterRuleField.of_json j
  end
module VolumeModificationList =
  struct
    type t = VolumeModification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeModification.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeModification.to_query v
    let to_headers v =
      Headers.to_headers_list VolumeModification.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (VolumeModification.to_xml x))) v
    let to_json v = `List (List.map VolumeModification.to_json v)
    let of_json j = Json.to_list VolumeModification.of_json j
  end
module ResetImageAttributeName =
  struct
    type t =
      | LaunchPermission 
    let str_to_t = [("launchPermission", LaunchPermission)]
    let t_to_str = [(LaunchPermission, "launchPermission")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NewDhcpConfigurationList =
  struct
    type t = NewDhcpConfiguration.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NewDhcpConfiguration.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NewDhcpConfiguration.to_query v
    let to_headers v =
      Headers.to_headers_list NewDhcpConfiguration.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (NewDhcpConfiguration.to_xml x))) v
    let to_json v = `List (List.map NewDhcpConfiguration.to_json v)
    let of_json j = Json.to_list NewDhcpConfiguration.of_json j
  end
module VpcAttributeName =
  struct
    type t =
      | EnableDnsSupport 
      | EnableDnsHostnames 
    let str_to_t =
      [("enableDnsHostnames", EnableDnsHostnames);
      ("enableDnsSupport", EnableDnsSupport)]
    let t_to_str =
      [(EnableDnsHostnames, "enableDnsHostnames");
      (EnableDnsSupport, "enableDnsSupport")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NetworkInterfaceList =
  struct
    type t = NetworkInterface.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkInterface.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NetworkInterface.to_query v
    let to_headers v = Headers.to_headers_list NetworkInterface.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (NetworkInterface.to_xml x)))
        v
    let to_json v = `List (List.map NetworkInterface.to_json v)
    let of_json j = Json.to_list NetworkInterface.of_json j
  end
module ConnectionNotificationSet =
  struct
    type t = ConnectionNotification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ConnectionNotification.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ConnectionNotification.to_query v
    let to_headers v =
      Headers.to_headers_list ConnectionNotification.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ConnectionNotification.to_xml x)))
        v
    let to_json v = `List (List.map ConnectionNotification.to_json v)
    let of_json j = Json.to_list ConnectionNotification.of_json j
  end
module ResetFpgaImageAttributeName =
  struct
    type t =
      | LoadPermission 
    let str_to_t = [("loadPermission", LoadPermission)]
    let t_to_str = [(LoadPermission, "loadPermission")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ReservedInstancesList =
  struct
    type t = ReservedInstances.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstances.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ReservedInstances.to_query v
    let to_headers v = Headers.to_headers_list ReservedInstances.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ReservedInstances.to_xml x)))
        v
    let to_json v = `List (List.map ReservedInstances.to_json v)
    let of_json j = Json.to_list ReservedInstances.of_json j
  end
module GroupIds =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ResourceList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayPeeringAttachmentList =
  struct
    type t = TransitGatewayPeeringAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayPeeringAttachment.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayPeeringAttachment.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayPeeringAttachment.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayPeeringAttachment.to_xml x))) v
    let to_json v =
      `List (List.map TransitGatewayPeeringAttachment.to_json v)
    let of_json j = Json.to_list TransitGatewayPeeringAttachment.of_json j
  end
module CancelledSpotInstanceRequestList =
  struct
    type t = CancelledSpotInstanceRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CancelledSpotInstanceRequest.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list CancelledSpotInstanceRequest.to_query v
    let to_headers v =
      Headers.to_headers_list CancelledSpotInstanceRequest.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (CancelledSpotInstanceRequest.to_xml x))) v
    let to_json v = `List (List.map CancelledSpotInstanceRequest.to_json v)
    let of_json j = Json.to_list CancelledSpotInstanceRequest.of_json j
  end
module ServiceConfigurationSet =
  struct
    type t = ServiceConfiguration.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ServiceConfiguration.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ServiceConfiguration.to_query v
    let to_headers v =
      Headers.to_headers_list ServiceConfiguration.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ServiceConfiguration.to_xml x))) v
    let to_json v = `List (List.map ServiceConfiguration.to_json v)
    let of_json j = Json.to_list ServiceConfiguration.of_json j
  end
module StorageLocation =
  struct
    type t = {
      bucket: String.t option ;
      key: String.t option }
    let make ?bucket  ?key  () = { bucket; key }
    let parse xml =
      Some
        {
          bucket = (Util.option_bind (Xml.member "Bucket" xml) String.parse);
          key = (Util.option_bind (Xml.member "Key" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.key
              (fun f -> Query.Pair ("Key", (String.to_query f)));
           Util.option_map v.bucket
             (fun f -> Query.Pair ("Bucket", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.bucket
               (fun f -> Ezxmlm.make_tag "Bucket" ([], (String.to_xml f)))])
           @
           [Util.option_map v.key
              (fun f -> Ezxmlm.make_tag "Key" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.key (fun f -> ("key", (String.to_json f)));
           Util.option_map v.bucket (fun f -> ("bucket", (String.to_json f)))])
    let of_json j =
      {
        bucket = (Util.option_map (Json.lookup j "bucket") String.of_json);
        key = (Util.option_map (Json.lookup j "key") String.of_json)
      }
  end
module BundleIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "BundleId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module DescribeConversionTaskList =
  struct
    type t = ConversionTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ConversionTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ConversionTask.to_query v
    let to_headers v = Headers.to_headers_list ConversionTask.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ConversionTask.to_xml x))) v
    let to_json v = `List (List.map ConversionTask.to_json v)
    let of_json j = Json.to_list ConversionTask.of_json j
  end
module LocalGatewayRouteTableIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayVpcAttachmentList =
  struct
    type t = TransitGatewayVpcAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayVpcAttachment.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayVpcAttachment.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayVpcAttachment.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayVpcAttachment.to_xml x))) v
    let to_json v = `List (List.map TransitGatewayVpcAttachment.to_json v)
    let of_json j = Json.to_list TransitGatewayVpcAttachment.of_json j
  end
module ExportToS3TaskSpecification =
  struct
    type t =
      {
      container_format: ContainerFormat.t option ;
      disk_image_format: DiskImageFormat.t option ;
      s3_bucket: String.t option ;
      s3_prefix: String.t option }
    let make ?container_format  ?disk_image_format  ?s3_bucket  ?s3_prefix 
      () = { container_format; disk_image_format; s3_bucket; s3_prefix }
    let parse xml =
      Some
        {
          container_format =
            (Util.option_bind (Xml.member "containerFormat" xml)
               ContainerFormat.parse);
          disk_image_format =
            (Util.option_bind (Xml.member "diskImageFormat" xml)
               DiskImageFormat.parse);
          s3_bucket =
            (Util.option_bind (Xml.member "s3Bucket" xml) String.parse);
          s3_prefix =
            (Util.option_bind (Xml.member "s3Prefix" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> Query.Pair ("S3Prefix", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)));
           Util.option_map v.disk_image_format
             (fun f ->
                Query.Pair ("DiskImageFormat", (DiskImageFormat.to_query f)));
           Util.option_map v.container_format
             (fun f ->
                Query.Pair ("ContainerFormat", (ContainerFormat.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.container_format
                 (fun f ->
                    Ezxmlm.make_tag "containerFormat"
                      ([], (ContainerFormat.to_xml f)))])
             @
             [Util.option_map v.disk_image_format
                (fun f ->
                   Ezxmlm.make_tag "diskImageFormat"
                     ([], (DiskImageFormat.to_xml f)))])
            @
            [Util.option_map v.s3_bucket
               (fun f -> Ezxmlm.make_tag "s3Bucket" ([], (String.to_xml f)))])
           @
           [Util.option_map v.s3_prefix
              (fun f -> Ezxmlm.make_tag "s3Prefix" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> ("s3_prefix", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)));
           Util.option_map v.disk_image_format
             (fun f -> ("disk_image_format", (DiskImageFormat.to_json f)));
           Util.option_map v.container_format
             (fun f -> ("container_format", (ContainerFormat.to_json f)))])
    let of_json j =
      {
        container_format =
          (Util.option_map (Json.lookup j "container_format")
             ContainerFormat.of_json);
        disk_image_format =
          (Util.option_map (Json.lookup j "disk_image_format")
             DiskImageFormat.of_json);
        s3_bucket =
          (Util.option_map (Json.lookup j "s3_bucket") String.of_json);
        s3_prefix =
          (Util.option_map (Json.lookup j "s3_prefix") String.of_json)
      }
  end
module ReservedInstanceReservationValueSet =
  struct
    type t = ReservedInstanceReservationValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstanceReservationValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ReservedInstanceReservationValue.to_query v
    let to_headers v =
      Headers.to_headers_list ReservedInstanceReservationValue.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ReservedInstanceReservationValue.to_xml x))) v
    let to_json v =
      `List (List.map ReservedInstanceReservationValue.to_json v)
    let of_json j = Json.to_list ReservedInstanceReservationValue.of_json j
  end
module TargetReservationValueSet =
  struct
    type t = TargetReservationValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TargetReservationValue.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TargetReservationValue.to_query v
    let to_headers v =
      Headers.to_headers_list TargetReservationValue.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (TargetReservationValue.to_xml x)))
        v
    let to_json v = `List (List.map TargetReservationValue.to_json v)
    let of_json j = Json.to_list TargetReservationValue.of_json j
  end
module TransitGatewayRouteList =
  struct
    type t = TransitGatewayRoute.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayRoute.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TransitGatewayRoute.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayRoute.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (TransitGatewayRoute.to_xml x))) v
    let to_json v = `List (List.map TransitGatewayRoute.to_json v)
    let of_json j = Json.to_list TransitGatewayRoute.of_json j
  end
module HistoryRecords =
  struct
    type t = HistoryRecord.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map HistoryRecord.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list HistoryRecord.to_query v
    let to_headers v = Headers.to_headers_list HistoryRecord.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (HistoryRecord.to_xml x))) v
    let to_json v = `List (List.map HistoryRecord.to_json v)
    let of_json j = Json.to_list HistoryRecord.of_json j
  end
module FpgaImageList =
  struct
    type t = FpgaImage.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map FpgaImage.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list FpgaImage.to_query v
    let to_headers v = Headers.to_headers_list FpgaImage.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (FpgaImage.to_xml x)))
        v
    let to_json v = `List (List.map FpgaImage.to_json v)
    let of_json j = Json.to_list FpgaImage.of_json j
  end
module OwnerStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "Owner" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module RestorableByStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module EnableFastSnapshotRestoreErrorSet =
  struct
    type t = EnableFastSnapshotRestoreErrorItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map EnableFastSnapshotRestoreErrorItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list EnableFastSnapshotRestoreErrorItem.to_query v
    let to_headers v =
      Headers.to_headers_list EnableFastSnapshotRestoreErrorItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (EnableFastSnapshotRestoreErrorItem.to_xml x))) v
    let to_json v =
      `List (List.map EnableFastSnapshotRestoreErrorItem.to_json v)
    let of_json j = Json.to_list EnableFastSnapshotRestoreErrorItem.of_json j
  end
module EnableFastSnapshotRestoreSuccessSet =
  struct
    type t = EnableFastSnapshotRestoreSuccessItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map EnableFastSnapshotRestoreSuccessItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list EnableFastSnapshotRestoreSuccessItem.to_query v
    let to_headers v =
      Headers.to_headers_list EnableFastSnapshotRestoreSuccessItem.to_headers
        v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (EnableFastSnapshotRestoreSuccessItem.to_xml x))) v
    let to_json v =
      `List (List.map EnableFastSnapshotRestoreSuccessItem.to_json v)
    let of_json j =
      Json.to_list EnableFastSnapshotRestoreSuccessItem.of_json j
  end
module InstanceIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module RouteTableList =
  struct
    type t = RouteTable.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map RouteTable.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list RouteTable.to_query v
    let to_headers v = Headers.to_headers_list RouteTable.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (RouteTable.to_xml x))) v
    let to_json v = `List (List.map RouteTable.to_json v)
    let of_json j = Json.to_list RouteTable.of_json j
  end
module LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module UnsuccessfulItemList =
  struct
    type t = UnsuccessfulItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map UnsuccessfulItem.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list UnsuccessfulItem.to_query v
    let to_headers v = Headers.to_headers_list UnsuccessfulItem.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (UnsuccessfulItem.to_xml x)))
        v
    let to_json v = `List (List.map UnsuccessfulItem.to_json v)
    let of_json j = Json.to_list UnsuccessfulItem.of_json j
  end
module IamInstanceProfileAssociationSet =
  struct
    type t = IamInstanceProfileAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map IamInstanceProfileAssociation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list IamInstanceProfileAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list IamInstanceProfileAssociation.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (IamInstanceProfileAssociation.to_xml x))) v
    let to_json v = `List (List.map IamInstanceProfileAssociation.to_json v)
    let of_json j = Json.to_list IamInstanceProfileAssociation.of_json j
  end
module LaunchTemplateVersionSet =
  struct
    type t = LaunchTemplateVersion.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateVersion.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LaunchTemplateVersion.to_query v
    let to_headers v =
      Headers.to_headers_list LaunchTemplateVersion.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (LaunchTemplateVersion.to_xml x))) v
    let to_json v = `List (List.map LaunchTemplateVersion.to_json v)
    let of_json j = Json.to_list LaunchTemplateVersion.of_json j
  end
module TransitGatewayAttachmentIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayMulticastGroupList =
  struct
    type t = TransitGatewayMulticastGroup.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayMulticastGroup.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayMulticastGroup.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayMulticastGroup.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayMulticastGroup.to_xml x))) v
    let to_json v = `List (List.map TransitGatewayMulticastGroup.to_json v)
    let of_json j = Json.to_list TransitGatewayMulticastGroup.of_json j
  end
module ScheduledInstanceIdRequestSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ScheduledInstanceId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module SlotStartTimeRangeRequest =
  struct
    type t =
      {
      earliest_time: DateTime.t option ;
      latest_time: DateTime.t option }
    let make ?earliest_time  ?latest_time  () =
      { earliest_time; latest_time }
    let parse xml =
      Some
        {
          earliest_time =
            (Util.option_bind (Xml.member "EarliestTime" xml) DateTime.parse);
          latest_time =
            (Util.option_bind (Xml.member "LatestTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.latest_time
              (fun f -> Query.Pair ("LatestTime", (DateTime.to_query f)));
           Util.option_map v.earliest_time
             (fun f -> Query.Pair ("EarliestTime", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.earliest_time
               (fun f ->
                  Ezxmlm.make_tag "EarliestTime" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.latest_time
              (fun f ->
                 Ezxmlm.make_tag "LatestTime" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.latest_time
              (fun f -> ("latest_time", (DateTime.to_json f)));
           Util.option_map v.earliest_time
             (fun f -> ("earliest_time", (DateTime.to_json f)))])
    let of_json j =
      {
        earliest_time =
          (Util.option_map (Json.lookup j "earliest_time") DateTime.of_json);
        latest_time =
          (Util.option_map (Json.lookup j "latest_time") DateTime.of_json)
      }
  end
module LocalGatewayVirtualInterfaceSet =
  struct
    type t = LocalGatewayVirtualInterface.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LocalGatewayVirtualInterface.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LocalGatewayVirtualInterface.to_query v
    let to_headers v =
      Headers.to_headers_list LocalGatewayVirtualInterface.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LocalGatewayVirtualInterface.to_xml x))) v
    let to_json v = `List (List.map LocalGatewayVirtualInterface.to_json v)
    let of_json j = Json.to_list LocalGatewayVirtualInterface.of_json j
  end
module CpuOptionsRequest =
  struct
    type t =
      {
      core_count: Integer.t option ;
      threads_per_core: Integer.t option }
    let make ?core_count  ?threads_per_core  () =
      { core_count; threads_per_core }
    let parse xml =
      Some
        {
          core_count =
            (Util.option_bind (Xml.member "CoreCount" xml) Integer.parse);
          threads_per_core =
            (Util.option_bind (Xml.member "ThreadsPerCore" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> Query.Pair ("ThreadsPerCore", (Integer.to_query f)));
           Util.option_map v.core_count
             (fun f -> Query.Pair ("CoreCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.core_count
               (fun f -> Ezxmlm.make_tag "CoreCount" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.threads_per_core
              (fun f ->
                 Ezxmlm.make_tag "ThreadsPerCore" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> ("threads_per_core", (Integer.to_json f)));
           Util.option_map v.core_count
             (fun f -> ("core_count", (Integer.to_json f)))])
    let of_json j =
      {
        core_count =
          (Util.option_map (Json.lookup j "core_count") Integer.of_json);
        threads_per_core =
          (Util.option_map (Json.lookup j "threads_per_core") Integer.of_json)
      }
  end
module ElasticGpuSpecifications =
  struct
    type t = ElasticGpuSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ElasticGpuSpecification.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ElasticGpuSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list ElasticGpuSpecification.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ElasticGpuSpecification.to_xml x)))
        v
    let to_json v = `List (List.map ElasticGpuSpecification.to_json v)
    let of_json j = Json.to_list ElasticGpuSpecification.of_json j
  end
module ElasticInferenceAccelerators =
  struct
    type t = ElasticInferenceAccelerator.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ElasticInferenceAccelerator.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ElasticInferenceAccelerator.to_query v
    let to_headers v =
      Headers.to_headers_list ElasticInferenceAccelerator.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ElasticInferenceAccelerator.to_xml x))) v
    let to_json v = `List (List.map ElasticInferenceAccelerator.to_json v)
    let of_json j = Json.to_list ElasticInferenceAccelerator.of_json j
  end
module HibernationOptionsRequest =
  struct
    type t = {
      configured: Boolean.t option }
    let make ?configured  () = { configured }
    let parse xml =
      Some
        {
          configured =
            (Util.option_bind (Xml.member "Configured" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> Query.Pair ("Configured", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.configured
              (fun f -> Ezxmlm.make_tag "Configured" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> ("configured", (Boolean.to_json f)))])
    let of_json j =
      {
        configured =
          (Util.option_map (Json.lookup j "configured") Boolean.of_json)
      }
  end
module InstanceMarketOptionsRequest =
  struct
    type t =
      {
      market_type: MarketType.t option ;
      spot_options: SpotMarketOptions.t option }
    let make ?market_type  ?spot_options  () = { market_type; spot_options }
    let parse xml =
      Some
        {
          market_type =
            (Util.option_bind (Xml.member "MarketType" xml) MarketType.parse);
          spot_options =
            (Util.option_bind (Xml.member "SpotOptions" xml)
               SpotMarketOptions.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f ->
                 Query.Pair ("SpotOptions", (SpotMarketOptions.to_query f)));
           Util.option_map v.market_type
             (fun f -> Query.Pair ("MarketType", (MarketType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.market_type
               (fun f ->
                  Ezxmlm.make_tag "MarketType" ([], (MarketType.to_xml f)))])
           @
           [Util.option_map v.spot_options
              (fun f ->
                 Ezxmlm.make_tag "SpotOptions"
                   ([], (SpotMarketOptions.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f -> ("spot_options", (SpotMarketOptions.to_json f)));
           Util.option_map v.market_type
             (fun f -> ("market_type", (MarketType.to_json f)))])
    let of_json j =
      {
        market_type =
          (Util.option_map (Json.lookup j "market_type") MarketType.of_json);
        spot_options =
          (Util.option_map (Json.lookup j "spot_options")
             SpotMarketOptions.of_json)
      }
  end
module InstanceMetadataOptionsRequest =
  struct
    type t =
      {
      http_tokens: HttpTokensState.t option ;
      http_put_response_hop_limit: Integer.t option ;
      http_endpoint: InstanceMetadataEndpointState.t option }
    let make ?http_tokens  ?http_put_response_hop_limit  ?http_endpoint  () =
      { http_tokens; http_put_response_hop_limit; http_endpoint }
    let parse xml =
      Some
        {
          http_tokens =
            (Util.option_bind (Xml.member "HttpTokens" xml)
               HttpTokensState.parse);
          http_put_response_hop_limit =
            (Util.option_bind (Xml.member "HttpPutResponseHopLimit" xml)
               Integer.parse);
          http_endpoint =
            (Util.option_bind (Xml.member "HttpEndpoint" xml)
               InstanceMetadataEndpointState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.http_endpoint
              (fun f ->
                 Query.Pair
                   ("HttpEndpoint",
                     (InstanceMetadataEndpointState.to_query f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f ->
                Query.Pair ("HttpPutResponseHopLimit", (Integer.to_query f)));
           Util.option_map v.http_tokens
             (fun f ->
                Query.Pair ("HttpTokens", (HttpTokensState.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.http_tokens
                (fun f ->
                   Ezxmlm.make_tag "HttpTokens"
                     ([], (HttpTokensState.to_xml f)))])
            @
            [Util.option_map v.http_put_response_hop_limit
               (fun f ->
                  Ezxmlm.make_tag "HttpPutResponseHopLimit"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.http_endpoint
              (fun f ->
                 Ezxmlm.make_tag "HttpEndpoint"
                   ([], (InstanceMetadataEndpointState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.http_endpoint
              (fun f ->
                 ("http_endpoint", (InstanceMetadataEndpointState.to_json f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f -> ("http_put_response_hop_limit", (Integer.to_json f)));
           Util.option_map v.http_tokens
             (fun f -> ("http_tokens", (HttpTokensState.to_json f)))])
    let of_json j =
      {
        http_tokens =
          (Util.option_map (Json.lookup j "http_tokens")
             HttpTokensState.of_json);
        http_put_response_hop_limit =
          (Util.option_map (Json.lookup j "http_put_response_hop_limit")
             Integer.of_json);
        http_endpoint =
          (Util.option_map (Json.lookup j "http_endpoint")
             InstanceMetadataEndpointState.of_json)
      }
  end
module LaunchTemplateSpecification =
  struct
    type t =
      {
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      version: String.t option }
    let make ?launch_template_id  ?launch_template_name  ?version  () =
      { launch_template_id; launch_template_name; version }
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "LaunchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "LaunchTemplateName" xml)
               String.parse);
          version =
            (Util.option_bind (Xml.member "Version" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> Query.Pair ("Version", (String.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.launch_template_id
                (fun f ->
                   Ezxmlm.make_tag "LaunchTemplateId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.launch_template_name
               (fun f ->
                  Ezxmlm.make_tag "LaunchTemplateName"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.version
              (fun f -> Ezxmlm.make_tag "Version" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> ("version", (String.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let of_json j =
      {
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        version = (Util.option_map (Json.lookup j "version") String.of_json)
      }
  end
module LicenseSpecificationListRequest =
  struct
    type t = LicenseConfigurationRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LicenseConfigurationRequest.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LicenseConfigurationRequest.to_query v
    let to_headers v =
      Headers.to_headers_list LicenseConfigurationRequest.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LicenseConfigurationRequest.to_xml x))) v
    let to_json v = `List (List.map LicenseConfigurationRequest.to_json v)
    let of_json j = Json.to_list LicenseConfigurationRequest.of_json j
  end
module LocalGatewayVirtualInterfaceGroupSet =
  struct
    type t = LocalGatewayVirtualInterfaceGroup.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LocalGatewayVirtualInterfaceGroup.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LocalGatewayVirtualInterfaceGroup.to_query v
    let to_headers v =
      Headers.to_headers_list LocalGatewayVirtualInterfaceGroup.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LocalGatewayVirtualInterfaceGroup.to_xml x))) v
    let to_json v =
      `List (List.map LocalGatewayVirtualInterfaceGroup.to_json v)
    let of_json j = Json.to_list LocalGatewayVirtualInterfaceGroup.of_json j
  end
module ExecutableByStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ExecutableBy" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ImageIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "ImageId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module MovingAddressStatusSet =
  struct
    type t = MovingAddressStatus.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map MovingAddressStatus.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list MovingAddressStatus.to_query v
    let to_headers v =
      Headers.to_headers_list MovingAddressStatus.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (MovingAddressStatus.to_xml x))) v
    let to_json v = `List (List.map MovingAddressStatus.to_json v)
    let of_json j = Json.to_list MovingAddressStatus.of_json j
  end
module ExportTaskIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ExportTaskId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ReservedInstancesOfferingIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module RequestLaunchTemplateData =
  struct
    type t =
      {
      kernel_id: String.t option ;
      ebs_optimized: Boolean.t option ;
      iam_instance_profile:
        LaunchTemplateIamInstanceProfileSpecificationRequest.t option ;
      block_device_mappings: LaunchTemplateBlockDeviceMappingRequestList.t ;
      network_interfaces:
        LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.t ;
      image_id: String.t option ;
      instance_type: InstanceType.t option ;
      key_name: String.t option ;
      monitoring: LaunchTemplatesMonitoringRequest.t option ;
      placement: LaunchTemplatePlacementRequest.t option ;
      ram_disk_id: String.t option ;
      disable_api_termination: Boolean.t option ;
      instance_initiated_shutdown_behavior: ShutdownBehavior.t option ;
      user_data: String.t option ;
      tag_specifications: LaunchTemplateTagSpecificationRequestList.t ;
      elastic_gpu_specifications: ElasticGpuSpecificationList.t ;
      elastic_inference_accelerators:
        LaunchTemplateElasticInferenceAcceleratorList.t ;
      security_group_ids: SecurityGroupIdStringList.t ;
      security_groups: SecurityGroupStringList.t ;
      instance_market_options:
        LaunchTemplateInstanceMarketOptionsRequest.t option ;
      credit_specification: CreditSpecificationRequest.t option ;
      cpu_options: LaunchTemplateCpuOptionsRequest.t option ;
      capacity_reservation_specification:
        LaunchTemplateCapacityReservationSpecificationRequest.t option ;
      license_specifications: LaunchTemplateLicenseSpecificationListRequest.t ;
      hibernation_options: LaunchTemplateHibernationOptionsRequest.t option }
    let make ?kernel_id  ?ebs_optimized  ?iam_instance_profile 
      ?(block_device_mappings= [])  ?(network_interfaces= [])  ?image_id 
      ?instance_type  ?key_name  ?monitoring  ?placement  ?ram_disk_id 
      ?disable_api_termination  ?instance_initiated_shutdown_behavior 
      ?user_data  ?(tag_specifications= [])  ?(elastic_gpu_specifications=
      [])  ?(elastic_inference_accelerators= [])  ?(security_group_ids= []) 
      ?(security_groups= [])  ?instance_market_options  ?credit_specification
       ?cpu_options  ?capacity_reservation_specification 
      ?(license_specifications= [])  ?hibernation_options  () =
      {
        kernel_id;
        ebs_optimized;
        iam_instance_profile;
        block_device_mappings;
        network_interfaces;
        image_id;
        instance_type;
        key_name;
        monitoring;
        placement;
        ram_disk_id;
        disable_api_termination;
        instance_initiated_shutdown_behavior;
        user_data;
        tag_specifications;
        elastic_gpu_specifications;
        elastic_inference_accelerators;
        security_group_ids;
        security_groups;
        instance_market_options;
        credit_specification;
        cpu_options;
        capacity_reservation_specification;
        license_specifications;
        hibernation_options
      }
    let parse xml =
      Some
        {
          kernel_id =
            (Util.option_bind (Xml.member "KernelId" xml) String.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "EbsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "IamInstanceProfile" xml)
               LaunchTemplateIamInstanceProfileSpecificationRequest.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "BlockDeviceMapping" xml)
                  LaunchTemplateBlockDeviceMappingRequestList.parse));
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterface" xml)
                  LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.parse));
          image_id =
            (Util.option_bind (Xml.member "ImageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml)
               InstanceType.parse);
          key_name =
            (Util.option_bind (Xml.member "KeyName" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "Monitoring" xml)
               LaunchTemplatesMonitoringRequest.parse);
          placement =
            (Util.option_bind (Xml.member "Placement" xml)
               LaunchTemplatePlacementRequest.parse);
          ram_disk_id =
            (Util.option_bind (Xml.member "RamDiskId" xml) String.parse);
          disable_api_termination =
            (Util.option_bind (Xml.member "DisableApiTermination" xml)
               Boolean.parse);
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "InstanceInitiatedShutdownBehavior" xml)
               ShutdownBehavior.parse);
          user_data =
            (Util.option_bind (Xml.member "UserData" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  LaunchTemplateTagSpecificationRequestList.parse));
          elastic_gpu_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "ElasticGpuSpecification" xml)
                  ElasticGpuSpecificationList.parse));
          elastic_inference_accelerators =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ElasticInferenceAccelerator" xml)
                  LaunchTemplateElasticInferenceAcceleratorList.parse));
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroup" xml)
                  SecurityGroupStringList.parse));
          instance_market_options =
            (Util.option_bind (Xml.member "InstanceMarketOptions" xml)
               LaunchTemplateInstanceMarketOptionsRequest.parse);
          credit_specification =
            (Util.option_bind (Xml.member "CreditSpecification" xml)
               CreditSpecificationRequest.parse);
          cpu_options =
            (Util.option_bind (Xml.member "CpuOptions" xml)
               LaunchTemplateCpuOptionsRequest.parse);
          capacity_reservation_specification =
            (Util.option_bind
               (Xml.member "CapacityReservationSpecification" xml)
               LaunchTemplateCapacityReservationSpecificationRequest.parse);
          license_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "LicenseSpecification" xml)
                  LaunchTemplateLicenseSpecificationListRequest.parse));
          hibernation_options =
            (Util.option_bind (Xml.member "HibernationOptions" xml)
               LaunchTemplateHibernationOptionsRequest.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.hibernation_options
              (fun f ->
                 Query.Pair
                   ("HibernationOptions",
                     (LaunchTemplateHibernationOptionsRequest.to_query f)));
           Some
             (Query.Pair
                ("LicenseSpecification",
                  (LaunchTemplateLicenseSpecificationListRequest.to_query
                     v.license_specifications)));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                Query.Pair
                  ("CapacityReservationSpecification",
                    (LaunchTemplateCapacityReservationSpecificationRequest.to_query
                       f)));
           Util.option_map v.cpu_options
             (fun f ->
                Query.Pair
                  ("CpuOptions",
                    (LaunchTemplateCpuOptionsRequest.to_query f)));
           Util.option_map v.credit_specification
             (fun f ->
                Query.Pair
                  ("CreditSpecification",
                    (CreditSpecificationRequest.to_query f)));
           Util.option_map v.instance_market_options
             (fun f ->
                Query.Pair
                  ("InstanceMarketOptions",
                    (LaunchTemplateInstanceMarketOptionsRequest.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroup",
                  (SecurityGroupStringList.to_query v.security_groups)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.security_group_ids)));
           Some
             (Query.Pair
                ("ElasticInferenceAccelerator",
                  (LaunchTemplateElasticInferenceAcceleratorList.to_query
                     v.elastic_inference_accelerators)));
           Some
             (Query.Pair
                ("ElasticGpuSpecification",
                  (ElasticGpuSpecificationList.to_query
                     v.elastic_gpu_specifications)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (LaunchTemplateTagSpecificationRequestList.to_query
                     v.tag_specifications)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (ShutdownBehavior.to_query f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                Query.Pair ("DisableApiTermination", (Boolean.to_query f)));
           Util.option_map v.ram_disk_id
             (fun f -> Query.Pair ("RamDiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f ->
                Query.Pair
                  ("Placement", (LaunchTemplatePlacementRequest.to_query f)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair
                  ("Monitoring",
                    (LaunchTemplatesMonitoringRequest.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterface",
                  (LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.to_query
                     v.network_interfaces)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (LaunchTemplateBlockDeviceMappingRequestList.to_query
                     v.block_device_mappings)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (LaunchTemplateIamInstanceProfileSpecificationRequest.to_query
                       f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((((((((((([] @
                                   [Util.option_map v.kernel_id
                                      (fun f ->
                                         Ezxmlm.make_tag "KernelId"
                                           ([], (String.to_xml f)))])
                                  @
                                  [Util.option_map v.ebs_optimized
                                     (fun f ->
                                        Ezxmlm.make_tag "EbsOptimized"
                                          ([], (Boolean.to_xml f)))])
                                 @
                                 [Util.option_map v.iam_instance_profile
                                    (fun f ->
                                       Ezxmlm.make_tag "IamInstanceProfile"
                                         ([],
                                           (LaunchTemplateIamInstanceProfileSpecificationRequest.to_xml
                                              f)))])
                                @
                                (List.map
                                   (fun x ->
                                      Some
                                        (Ezxmlm.make_tag "BlockDeviceMapping"
                                           ([],
                                             (LaunchTemplateBlockDeviceMappingRequestList.to_xml
                                                [x]))))
                                   v.block_device_mappings))
                               @
                               (List.map
                                  (fun x ->
                                     Some
                                       (Ezxmlm.make_tag "NetworkInterface"
                                          ([],
                                            (LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.to_xml
                                               [x])))) v.network_interfaces))
                              @
                              [Util.option_map v.image_id
                                 (fun f ->
                                    Ezxmlm.make_tag "ImageId"
                                      ([], (String.to_xml f)))])
                             @
                             [Util.option_map v.instance_type
                                (fun f ->
                                   Ezxmlm.make_tag "InstanceType"
                                     ([], (InstanceType.to_xml f)))])
                            @
                            [Util.option_map v.key_name
                               (fun f ->
                                  Ezxmlm.make_tag "KeyName"
                                    ([], (String.to_xml f)))])
                           @
                           [Util.option_map v.monitoring
                              (fun f ->
                                 Ezxmlm.make_tag "Monitoring"
                                   ([],
                                     (LaunchTemplatesMonitoringRequest.to_xml
                                        f)))])
                          @
                          [Util.option_map v.placement
                             (fun f ->
                                Ezxmlm.make_tag "Placement"
                                  ([],
                                    (LaunchTemplatePlacementRequest.to_xml f)))])
                         @
                         [Util.option_map v.ram_disk_id
                            (fun f ->
                               Ezxmlm.make_tag "RamDiskId"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.disable_api_termination
                           (fun f ->
                              Ezxmlm.make_tag "DisableApiTermination"
                                ([], (Boolean.to_xml f)))])
                       @
                       [Util.option_map
                          v.instance_initiated_shutdown_behavior
                          (fun f ->
                             Ezxmlm.make_tag
                               "InstanceInitiatedShutdownBehavior"
                               ([], (ShutdownBehavior.to_xml f)))])
                      @
                      [Util.option_map v.user_data
                         (fun f ->
                            Ezxmlm.make_tag "UserData"
                              ([], (String.to_xml f)))])
                     @
                     (List.map
                        (fun x ->
                           Some
                             (Ezxmlm.make_tag "TagSpecification"
                                ([],
                                  (LaunchTemplateTagSpecificationRequestList.to_xml
                                     [x])))) v.tag_specifications))
                    @
                    (List.map
                       (fun x ->
                          Some
                            (Ezxmlm.make_tag "ElasticGpuSpecification"
                               ([], (ElasticGpuSpecificationList.to_xml [x]))))
                       v.elastic_gpu_specifications))
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "ElasticInferenceAccelerator"
                              ([],
                                (LaunchTemplateElasticInferenceAcceleratorList.to_xml
                                   [x])))) v.elastic_inference_accelerators))
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "SecurityGroupId"
                             ([], (SecurityGroupIdStringList.to_xml [x]))))
                     v.security_group_ids))
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "SecurityGroup"
                            ([], (SecurityGroupStringList.to_xml [x]))))
                    v.security_groups))
                @
                [Util.option_map v.instance_market_options
                   (fun f ->
                      Ezxmlm.make_tag "InstanceMarketOptions"
                        ([],
                          (LaunchTemplateInstanceMarketOptionsRequest.to_xml
                             f)))])
               @
               [Util.option_map v.credit_specification
                  (fun f ->
                     Ezxmlm.make_tag "CreditSpecification"
                       ([], (CreditSpecificationRequest.to_xml f)))])
              @
              [Util.option_map v.cpu_options
                 (fun f ->
                    Ezxmlm.make_tag "CpuOptions"
                      ([], (LaunchTemplateCpuOptionsRequest.to_xml f)))])
             @
             [Util.option_map v.capacity_reservation_specification
                (fun f ->
                   Ezxmlm.make_tag "CapacityReservationSpecification"
                     ([],
                       (LaunchTemplateCapacityReservationSpecificationRequest.to_xml
                          f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "LicenseSpecification"
                       ([],
                         (LaunchTemplateLicenseSpecificationListRequest.to_xml
                            [x])))) v.license_specifications))
           @
           [Util.option_map v.hibernation_options
              (fun f ->
                 Ezxmlm.make_tag "HibernationOptions"
                   ([], (LaunchTemplateHibernationOptionsRequest.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.hibernation_options
              (fun f ->
                 ("hibernation_options",
                   (LaunchTemplateHibernationOptionsRequest.to_json f)));
           Some
             ("license_specifications",
               (LaunchTemplateLicenseSpecificationListRequest.to_json
                  v.license_specifications));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                ("capacity_reservation_specification",
                  (LaunchTemplateCapacityReservationSpecificationRequest.to_json
                     f)));
           Util.option_map v.cpu_options
             (fun f ->
                ("cpu_options", (LaunchTemplateCpuOptionsRequest.to_json f)));
           Util.option_map v.credit_specification
             (fun f ->
                ("credit_specification",
                  (CreditSpecificationRequest.to_json f)));
           Util.option_map v.instance_market_options
             (fun f ->
                ("instance_market_options",
                  (LaunchTemplateInstanceMarketOptionsRequest.to_json f)));
           Some
             ("security_groups",
               (SecurityGroupStringList.to_json v.security_groups));
           Some
             ("security_group_ids",
               (SecurityGroupIdStringList.to_json v.security_group_ids));
           Some
             ("elastic_inference_accelerators",
               (LaunchTemplateElasticInferenceAcceleratorList.to_json
                  v.elastic_inference_accelerators));
           Some
             ("elastic_gpu_specifications",
               (ElasticGpuSpecificationList.to_json
                  v.elastic_gpu_specifications));
           Some
             ("tag_specifications",
               (LaunchTemplateTagSpecificationRequestList.to_json
                  v.tag_specifications));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (ShutdownBehavior.to_json f)));
           Util.option_map v.disable_api_termination
             (fun f -> ("disable_api_termination", (Boolean.to_json f)));
           Util.option_map v.ram_disk_id
             (fun f -> ("ram_disk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f ->
                ("placement", (LaunchTemplatePlacementRequest.to_json f)));
           Util.option_map v.monitoring
             (fun f ->
                ("monitoring", (LaunchTemplatesMonitoringRequest.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Some
             ("network_interfaces",
               (LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.to_json
                  v.network_interfaces));
           Some
             ("block_device_mappings",
               (LaunchTemplateBlockDeviceMappingRequestList.to_json
                  v.block_device_mappings));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (LaunchTemplateIamInstanceProfileSpecificationRequest.to_json
                     f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)))])
    let of_json j =
      {
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             LaunchTemplateIamInstanceProfileSpecificationRequest.of_json);
        block_device_mappings =
          (LaunchTemplateBlockDeviceMappingRequestList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        network_interfaces =
          (LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             LaunchTemplatesMonitoringRequest.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement")
             LaunchTemplatePlacementRequest.of_json);
        ram_disk_id =
          (Util.option_map (Json.lookup j "ram_disk_id") String.of_json);
        disable_api_termination =
          (Util.option_map (Json.lookup j "disable_api_termination")
             Boolean.of_json);
        instance_initiated_shutdown_behavior =
          (Util.option_map
             (Json.lookup j "instance_initiated_shutdown_behavior")
             ShutdownBehavior.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json);
        tag_specifications =
          (LaunchTemplateTagSpecificationRequestList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        elastic_gpu_specifications =
          (ElasticGpuSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "elastic_gpu_specifications")));
        elastic_inference_accelerators =
          (LaunchTemplateElasticInferenceAcceleratorList.of_json
             (Util.of_option_exn
                (Json.lookup j "elastic_inference_accelerators")));
        security_group_ids =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        security_groups =
          (SecurityGroupStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        instance_market_options =
          (Util.option_map (Json.lookup j "instance_market_options")
             LaunchTemplateInstanceMarketOptionsRequest.of_json);
        credit_specification =
          (Util.option_map (Json.lookup j "credit_specification")
             CreditSpecificationRequest.of_json);
        cpu_options =
          (Util.option_map (Json.lookup j "cpu_options")
             LaunchTemplateCpuOptionsRequest.of_json);
        capacity_reservation_specification =
          (Util.option_map
             (Json.lookup j "capacity_reservation_specification")
             LaunchTemplateCapacityReservationSpecificationRequest.of_json);
        license_specifications =
          (LaunchTemplateLicenseSpecificationListRequest.of_json
             (Util.of_option_exn (Json.lookup j "license_specifications")));
        hibernation_options =
          (Util.option_map (Json.lookup j "hibernation_options")
             LaunchTemplateHibernationOptionsRequest.of_json)
      }
  end
module TrafficMirrorSessionSet =
  struct
    type t = TrafficMirrorSession.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorSession.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TrafficMirrorSession.to_query v
    let to_headers v =
      Headers.to_headers_list TrafficMirrorSession.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (TrafficMirrorSession.to_xml x))) v
    let to_json v = `List (List.map TrafficMirrorSession.to_json v)
    let of_json j = Json.to_list TrafficMirrorSession.of_json j
  end
module NetworkInterfaceAttachmentChanges =
  struct
    type t =
      {
      attachment_id: String.t option ;
      delete_on_termination: Boolean.t option }
    let make ?attachment_id  ?delete_on_termination  () =
      { attachment_id; delete_on_termination }
    let parse xml =
      Some
        {
          attachment_id =
            (Util.option_bind (Xml.member "attachmentId" xml) String.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f ->
                 Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attachment_id
             (fun f -> Query.Pair ("AttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.attachment_id
               (fun f ->
                  Ezxmlm.make_tag "attachmentId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.delete_on_termination
              (fun f ->
                 Ezxmlm.make_tag "deleteOnTermination"
                   ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attachment_id
             (fun f -> ("attachment_id", (String.to_json f)))])
    let of_json j =
      {
        attachment_id =
          (Util.option_map (Json.lookup j "attachment_id") String.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json)
      }
  end
module DeleteLaunchTemplateVersionsResponseErrorSet =
  struct
    type t = DeleteLaunchTemplateVersionsResponseErrorItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DeleteLaunchTemplateVersionsResponseErrorItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list
        DeleteLaunchTemplateVersionsResponseErrorItem.to_query v
    let to_headers v =
      Headers.to_headers_list
        DeleteLaunchTemplateVersionsResponseErrorItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (DeleteLaunchTemplateVersionsResponseErrorItem.to_xml x)))
        v
    let to_json v =
      `List
        (List.map DeleteLaunchTemplateVersionsResponseErrorItem.to_json v)
    let of_json j =
      Json.to_list DeleteLaunchTemplateVersionsResponseErrorItem.of_json j
  end
module DeleteLaunchTemplateVersionsResponseSuccessSet =
  struct
    type t = DeleteLaunchTemplateVersionsResponseSuccessItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DeleteLaunchTemplateVersionsResponseSuccessItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list
        DeleteLaunchTemplateVersionsResponseSuccessItem.to_query v
    let to_headers v =
      Headers.to_headers_list
        DeleteLaunchTemplateVersionsResponseSuccessItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (DeleteLaunchTemplateVersionsResponseSuccessItem.to_xml x)))
        v
    let to_json v =
      `List
        (List.map DeleteLaunchTemplateVersionsResponseSuccessItem.to_json v)
    let of_json j =
      Json.to_list DeleteLaunchTemplateVersionsResponseSuccessItem.of_json j
  end
module KeyNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "KeyName" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module KeyPairIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "KeyPairId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayMulticastRegisteredGroupSources =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      registered_network_interface_ids: ValueStringList.t ;
      group_ip_address: String.t option }
    let make ?transit_gateway_multicast_domain_id 
      ?(registered_network_interface_ids= [])  ?group_ip_address  () =
      {
        transit_gateway_multicast_domain_id;
        registered_network_interface_ids;
        group_ip_address
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          registered_network_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "registeredNetworkInterfaceIds" xml)
                  ValueStringList.parse));
          group_ip_address =
            (Util.option_bind (Xml.member "groupIpAddress" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("RegisteredNetworkInterfaceIds",
                  (ValueStringList.to_query
                     v.registered_network_interface_ids)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.transit_gateway_multicast_domain_id
                (fun f ->
                   Ezxmlm.make_tag "transitGatewayMulticastDomainId"
                     ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "registeredNetworkInterfaceIds"
                       ([], (ValueStringList.to_xml [x]))))
               v.registered_network_interface_ids))
           @
           [Util.option_map v.group_ip_address
              (fun f ->
                 Ezxmlm.make_tag "groupIpAddress" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> ("group_ip_address", (String.to_json f)));
           Some
             ("registered_network_interface_ids",
               (ValueStringList.to_json v.registered_network_interface_ids));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        registered_network_interface_ids =
          (ValueStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "registered_network_interface_ids")));
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json)
      }
  end
module SpotInstanceRequestList =
  struct
    type t = SpotInstanceRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SpotInstanceRequest.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SpotInstanceRequest.to_query v
    let to_headers v =
      Headers.to_headers_list SpotInstanceRequest.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (SpotInstanceRequest.to_xml x))) v
    let to_json v = `List (List.map SpotInstanceRequest.to_json v)
    let of_json j = Json.to_list SpotInstanceRequest.of_json j
  end
module FailedQueuedPurchaseDeletionSet =
  struct
    type t = FailedQueuedPurchaseDeletion.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map FailedQueuedPurchaseDeletion.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list FailedQueuedPurchaseDeletion.to_query v
    let to_headers v =
      Headers.to_headers_list FailedQueuedPurchaseDeletion.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (FailedQueuedPurchaseDeletion.to_xml x))) v
    let to_json v = `List (List.map FailedQueuedPurchaseDeletion.to_json v)
    let of_json j = Json.to_list FailedQueuedPurchaseDeletion.of_json j
  end
module SuccessfulQueuedPurchaseDeletionSet =
  struct
    type t = SuccessfulQueuedPurchaseDeletion.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SuccessfulQueuedPurchaseDeletion.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list SuccessfulQueuedPurchaseDeletion.to_query v
    let to_headers v =
      Headers.to_headers_list SuccessfulQueuedPurchaseDeletion.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (SuccessfulQueuedPurchaseDeletion.to_xml x))) v
    let to_json v =
      `List (List.map SuccessfulQueuedPurchaseDeletion.to_json v)
    let of_json j = Json.to_list SuccessfulQueuedPurchaseDeletion.of_json j
  end
module ExportTaskList =
  struct
    type t = ExportTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map ExportTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ExportTask.to_query v
    let to_headers v = Headers.to_headers_list ExportTask.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ExportTask.to_xml x))) v
    let to_json v = `List (List.map ExportTask.to_json v)
    let of_json j = Json.to_list ExportTask.of_json j
  end
module InstanceMonitoringList =
  struct
    type t = InstanceMonitoring.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceMonitoring.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceMonitoring.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceMonitoring.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstanceMonitoring.to_xml x))) v
    let to_json v = `List (List.map InstanceMonitoring.to_json v)
    let of_json j = Json.to_list InstanceMonitoring.of_json j
  end
module SecurityGroupList =
  struct
    type t = SecurityGroup.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map SecurityGroup.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SecurityGroup.to_query v
    let to_headers v = Headers.to_headers_list SecurityGroup.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (SecurityGroup.to_xml x))) v
    let to_json v = `List (List.map SecurityGroup.to_json v)
    let of_json j = Json.to_list SecurityGroup.of_json j
  end
module ServiceDetailSet =
  struct
    type t = ServiceDetail.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map ServiceDetail.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ServiceDetail.to_query v
    let to_headers v = Headers.to_headers_list ServiceDetail.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ServiceDetail.to_xml x))) v
    let to_json v = `List (List.map ServiceDetail.to_json v)
    let of_json j = Json.to_list ServiceDetail.of_json j
  end
module EndpointSet =
  struct
    type t = ClientVpnEndpoint.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClientVpnEndpoint.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ClientVpnEndpoint.to_query v
    let to_headers v = Headers.to_headers_list ClientVpnEndpoint.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ClientVpnEndpoint.to_xml x)))
        v
    let to_json v = `List (List.map ClientVpnEndpoint.to_json v)
    let of_json j = Json.to_list ClientVpnEndpoint.of_json j
  end
module FleetLaunchTemplateConfigListRequest =
  struct
    type t = FleetLaunchTemplateConfigRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map FleetLaunchTemplateConfigRequest.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list FleetLaunchTemplateConfigRequest.to_query v
    let to_headers v =
      Headers.to_headers_list FleetLaunchTemplateConfigRequest.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (FleetLaunchTemplateConfigRequest.to_xml x))) v
    let to_json v =
      `List (List.map FleetLaunchTemplateConfigRequest.to_json v)
    let of_json j = Json.to_list FleetLaunchTemplateConfigRequest.of_json j
  end
module OnDemandOptionsRequest =
  struct
    type t =
      {
      allocation_strategy: FleetOnDemandAllocationStrategy.t option ;
      capacity_reservation_options:
        CapacityReservationOptionsRequest.t option ;
      single_instance_type: Boolean.t option ;
      single_availability_zone: Boolean.t option ;
      min_target_capacity: Integer.t option ;
      max_total_price: String.t option }
    let make ?allocation_strategy  ?capacity_reservation_options 
      ?single_instance_type  ?single_availability_zone  ?min_target_capacity 
      ?max_total_price  () =
      {
        allocation_strategy;
        capacity_reservation_options;
        single_instance_type;
        single_availability_zone;
        min_target_capacity;
        max_total_price
      }
    let parse xml =
      Some
        {
          allocation_strategy =
            (Util.option_bind (Xml.member "AllocationStrategy" xml)
               FleetOnDemandAllocationStrategy.parse);
          capacity_reservation_options =
            (Util.option_bind (Xml.member "CapacityReservationOptions" xml)
               CapacityReservationOptionsRequest.parse);
          single_instance_type =
            (Util.option_bind (Xml.member "SingleInstanceType" xml)
               Boolean.parse);
          single_availability_zone =
            (Util.option_bind (Xml.member "SingleAvailabilityZone" xml)
               Boolean.parse);
          min_target_capacity =
            (Util.option_bind (Xml.member "MinTargetCapacity" xml)
               Integer.parse);
          max_total_price =
            (Util.option_bind (Xml.member "MaxTotalPrice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> Query.Pair ("MaxTotalPrice", (String.to_query f)));
           Util.option_map v.min_target_capacity
             (fun f -> Query.Pair ("MinTargetCapacity", (Integer.to_query f)));
           Util.option_map v.single_availability_zone
             (fun f ->
                Query.Pair ("SingleAvailabilityZone", (Boolean.to_query f)));
           Util.option_map v.single_instance_type
             (fun f ->
                Query.Pair ("SingleInstanceType", (Boolean.to_query f)));
           Util.option_map v.capacity_reservation_options
             (fun f ->
                Query.Pair
                  ("CapacityReservationOptions",
                    (CapacityReservationOptionsRequest.to_query f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                Query.Pair
                  ("AllocationStrategy",
                    (FleetOnDemandAllocationStrategy.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.allocation_strategy
                   (fun f ->
                      Ezxmlm.make_tag "AllocationStrategy"
                        ([], (FleetOnDemandAllocationStrategy.to_xml f)))])
               @
               [Util.option_map v.capacity_reservation_options
                  (fun f ->
                     Ezxmlm.make_tag "CapacityReservationOptions"
                       ([], (CapacityReservationOptionsRequest.to_xml f)))])
              @
              [Util.option_map v.single_instance_type
                 (fun f ->
                    Ezxmlm.make_tag "SingleInstanceType"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.single_availability_zone
                (fun f ->
                   Ezxmlm.make_tag "SingleAvailabilityZone"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.min_target_capacity
               (fun f ->
                  Ezxmlm.make_tag "MinTargetCapacity"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.max_total_price
              (fun f ->
                 Ezxmlm.make_tag "MaxTotalPrice" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> ("max_total_price", (String.to_json f)));
           Util.option_map v.min_target_capacity
             (fun f -> ("min_target_capacity", (Integer.to_json f)));
           Util.option_map v.single_availability_zone
             (fun f -> ("single_availability_zone", (Boolean.to_json f)));
           Util.option_map v.single_instance_type
             (fun f -> ("single_instance_type", (Boolean.to_json f)));
           Util.option_map v.capacity_reservation_options
             (fun f ->
                ("capacity_reservation_options",
                  (CapacityReservationOptionsRequest.to_json f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                ("allocation_strategy",
                  (FleetOnDemandAllocationStrategy.to_json f)))])
    let of_json j =
      {
        allocation_strategy =
          (Util.option_map (Json.lookup j "allocation_strategy")
             FleetOnDemandAllocationStrategy.of_json);
        capacity_reservation_options =
          (Util.option_map (Json.lookup j "capacity_reservation_options")
             CapacityReservationOptionsRequest.of_json);
        single_instance_type =
          (Util.option_map (Json.lookup j "single_instance_type")
             Boolean.of_json);
        single_availability_zone =
          (Util.option_map (Json.lookup j "single_availability_zone")
             Boolean.of_json);
        min_target_capacity =
          (Util.option_map (Json.lookup j "min_target_capacity")
             Integer.of_json);
        max_total_price =
          (Util.option_map (Json.lookup j "max_total_price") String.of_json)
      }
  end
module SpotOptionsRequest =
  struct
    type t =
      {
      allocation_strategy: SpotAllocationStrategy.t option ;
      instance_interruption_behavior:
        SpotInstanceInterruptionBehavior.t option ;
      instance_pools_to_use_count: Integer.t option ;
      single_instance_type: Boolean.t option ;
      single_availability_zone: Boolean.t option ;
      min_target_capacity: Integer.t option ;
      max_total_price: String.t option }
    let make ?allocation_strategy  ?instance_interruption_behavior 
      ?instance_pools_to_use_count  ?single_instance_type 
      ?single_availability_zone  ?min_target_capacity  ?max_total_price  () =
      {
        allocation_strategy;
        instance_interruption_behavior;
        instance_pools_to_use_count;
        single_instance_type;
        single_availability_zone;
        min_target_capacity;
        max_total_price
      }
    let parse xml =
      Some
        {
          allocation_strategy =
            (Util.option_bind (Xml.member "AllocationStrategy" xml)
               SpotAllocationStrategy.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "InstanceInterruptionBehavior" xml)
               SpotInstanceInterruptionBehavior.parse);
          instance_pools_to_use_count =
            (Util.option_bind (Xml.member "InstancePoolsToUseCount" xml)
               Integer.parse);
          single_instance_type =
            (Util.option_bind (Xml.member "SingleInstanceType" xml)
               Boolean.parse);
          single_availability_zone =
            (Util.option_bind (Xml.member "SingleAvailabilityZone" xml)
               Boolean.parse);
          min_target_capacity =
            (Util.option_bind (Xml.member "MinTargetCapacity" xml)
               Integer.parse);
          max_total_price =
            (Util.option_bind (Xml.member "MaxTotalPrice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> Query.Pair ("MaxTotalPrice", (String.to_query f)));
           Util.option_map v.min_target_capacity
             (fun f -> Query.Pair ("MinTargetCapacity", (Integer.to_query f)));
           Util.option_map v.single_availability_zone
             (fun f ->
                Query.Pair ("SingleAvailabilityZone", (Boolean.to_query f)));
           Util.option_map v.single_instance_type
             (fun f ->
                Query.Pair ("SingleInstanceType", (Boolean.to_query f)));
           Util.option_map v.instance_pools_to_use_count
             (fun f ->
                Query.Pair ("InstancePoolsToUseCount", (Integer.to_query f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInterruptionBehavior",
                    (SpotInstanceInterruptionBehavior.to_query f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                Query.Pair
                  ("AllocationStrategy", (SpotAllocationStrategy.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.allocation_strategy
                    (fun f ->
                       Ezxmlm.make_tag "AllocationStrategy"
                         ([], (SpotAllocationStrategy.to_xml f)))])
                @
                [Util.option_map v.instance_interruption_behavior
                   (fun f ->
                      Ezxmlm.make_tag "InstanceInterruptionBehavior"
                        ([], (SpotInstanceInterruptionBehavior.to_xml f)))])
               @
               [Util.option_map v.instance_pools_to_use_count
                  (fun f ->
                     Ezxmlm.make_tag "InstancePoolsToUseCount"
                       ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.single_instance_type
                 (fun f ->
                    Ezxmlm.make_tag "SingleInstanceType"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.single_availability_zone
                (fun f ->
                   Ezxmlm.make_tag "SingleAvailabilityZone"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.min_target_capacity
               (fun f ->
                  Ezxmlm.make_tag "MinTargetCapacity"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.max_total_price
              (fun f ->
                 Ezxmlm.make_tag "MaxTotalPrice" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> ("max_total_price", (String.to_json f)));
           Util.option_map v.min_target_capacity
             (fun f -> ("min_target_capacity", (Integer.to_json f)));
           Util.option_map v.single_availability_zone
             (fun f -> ("single_availability_zone", (Boolean.to_json f)));
           Util.option_map v.single_instance_type
             (fun f -> ("single_instance_type", (Boolean.to_json f)));
           Util.option_map v.instance_pools_to_use_count
             (fun f -> ("instance_pools_to_use_count", (Integer.to_json f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                ("instance_interruption_behavior",
                  (SpotInstanceInterruptionBehavior.to_json f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                ("allocation_strategy", (SpotAllocationStrategy.to_json f)))])
    let of_json j =
      {
        allocation_strategy =
          (Util.option_map (Json.lookup j "allocation_strategy")
             SpotAllocationStrategy.of_json);
        instance_interruption_behavior =
          (Util.option_map (Json.lookup j "instance_interruption_behavior")
             SpotInstanceInterruptionBehavior.of_json);
        instance_pools_to_use_count =
          (Util.option_map (Json.lookup j "instance_pools_to_use_count")
             Integer.of_json);
        single_instance_type =
          (Util.option_map (Json.lookup j "single_instance_type")
             Boolean.of_json);
        single_availability_zone =
          (Util.option_map (Json.lookup j "single_availability_zone")
             Boolean.of_json);
        min_target_capacity =
          (Util.option_map (Json.lookup j "min_target_capacity")
             Integer.of_json);
        max_total_price =
          (Util.option_map (Json.lookup j "max_total_price") String.of_json)
      }
  end
module TargetCapacitySpecificationRequest =
  struct
    type t =
      {
      total_target_capacity: Integer.t ;
      on_demand_target_capacity: Integer.t option ;
      spot_target_capacity: Integer.t option ;
      default_target_capacity_type: DefaultTargetCapacityType.t option }
    let make ~total_target_capacity  ?on_demand_target_capacity 
      ?spot_target_capacity  ?default_target_capacity_type  () =
      {
        total_target_capacity;
        on_demand_target_capacity;
        spot_target_capacity;
        default_target_capacity_type
      }
    let parse xml =
      Some
        {
          total_target_capacity =
            (Xml.required "TotalTargetCapacity"
               (Util.option_bind (Xml.member "TotalTargetCapacity" xml)
                  Integer.parse));
          on_demand_target_capacity =
            (Util.option_bind (Xml.member "OnDemandTargetCapacity" xml)
               Integer.parse);
          spot_target_capacity =
            (Util.option_bind (Xml.member "SpotTargetCapacity" xml)
               Integer.parse);
          default_target_capacity_type =
            (Util.option_bind (Xml.member "DefaultTargetCapacityType" xml)
               DefaultTargetCapacityType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.default_target_capacity_type
              (fun f ->
                 Query.Pair
                   ("DefaultTargetCapacityType",
                     (DefaultTargetCapacityType.to_query f)));
           Util.option_map v.spot_target_capacity
             (fun f ->
                Query.Pair ("SpotTargetCapacity", (Integer.to_query f)));
           Util.option_map v.on_demand_target_capacity
             (fun f ->
                Query.Pair ("OnDemandTargetCapacity", (Integer.to_query f)));
           Some
             (Query.Pair
                ("TotalTargetCapacity",
                  (Integer.to_query v.total_target_capacity)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "TotalTargetCapacity"
                    ([], (Integer.to_xml v.total_target_capacity)))])
             @
             [Util.option_map v.on_demand_target_capacity
                (fun f ->
                   Ezxmlm.make_tag "OnDemandTargetCapacity"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.spot_target_capacity
               (fun f ->
                  Ezxmlm.make_tag "SpotTargetCapacity"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.default_target_capacity_type
              (fun f ->
                 Ezxmlm.make_tag "DefaultTargetCapacityType"
                   ([], (DefaultTargetCapacityType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.default_target_capacity_type
              (fun f ->
                 ("default_target_capacity_type",
                   (DefaultTargetCapacityType.to_json f)));
           Util.option_map v.spot_target_capacity
             (fun f -> ("spot_target_capacity", (Integer.to_json f)));
           Util.option_map v.on_demand_target_capacity
             (fun f -> ("on_demand_target_capacity", (Integer.to_json f)));
           Some
             ("total_target_capacity",
               (Integer.to_json v.total_target_capacity))])
    let of_json j =
      {
        total_target_capacity =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "total_target_capacity")));
        on_demand_target_capacity =
          (Util.option_map (Json.lookup j "on_demand_target_capacity")
             Integer.of_json);
        spot_target_capacity =
          (Util.option_map (Json.lookup j "spot_target_capacity")
             Integer.of_json);
        default_target_capacity_type =
          (Util.option_map (Json.lookup j "default_target_capacity_type")
             DefaultTargetCapacityType.of_json)
      }
  end
module TransitGatewayMulticastDeregisteredGroupSources =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      deregistered_network_interface_ids: ValueStringList.t ;
      group_ip_address: String.t option }
    let make ?transit_gateway_multicast_domain_id 
      ?(deregistered_network_interface_ids= [])  ?group_ip_address  () =
      {
        transit_gateway_multicast_domain_id;
        deregistered_network_interface_ids;
        group_ip_address
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          deregistered_network_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "deregisteredNetworkInterfaceIds" xml)
                  ValueStringList.parse));
          group_ip_address =
            (Util.option_bind (Xml.member "groupIpAddress" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("DeregisteredNetworkInterfaceIds",
                  (ValueStringList.to_query
                     v.deregistered_network_interface_ids)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.transit_gateway_multicast_domain_id
                (fun f ->
                   Ezxmlm.make_tag "transitGatewayMulticastDomainId"
                     ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "deregisteredNetworkInterfaceIds"
                       ([], (ValueStringList.to_xml [x]))))
               v.deregistered_network_interface_ids))
           @
           [Util.option_map v.group_ip_address
              (fun f ->
                 Ezxmlm.make_tag "groupIpAddress" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> ("group_ip_address", (String.to_json f)));
           Some
             ("deregistered_network_interface_ids",
               (ValueStringList.to_json v.deregistered_network_interface_ids));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        deregistered_network_interface_ids =
          (ValueStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "deregistered_network_interface_ids")));
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json)
      }
  end
module InternetGatewayList =
  struct
    type t = InternetGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InternetGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InternetGateway.to_query v
    let to_headers v = Headers.to_headers_list InternetGateway.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InternetGateway.to_xml x)))
        v
    let to_json v = `List (List.map InternetGateway.to_json v)
    let of_json j = Json.to_list InternetGateway.of_json j
  end
module NetworkInterfaceIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AccountAttributeNameStringList =
  struct
    type t = AccountAttributeName.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AccountAttributeName.parse
           (Xml.members "attributeName" xml))
    let to_query v = Query.to_query_list AccountAttributeName.to_query v
    let to_headers v =
      Headers.to_headers_list AccountAttributeName.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (AccountAttributeName.to_xml x))) v
    let to_json v = `List (List.map AccountAttributeName.to_json v)
    let of_json j = Json.to_list AccountAttributeName.of_json j
  end
module ConversionIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module FleetSet =
  struct
    type t = FleetData.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map FleetData.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list FleetData.to_query v
    let to_headers v = Headers.to_headers_list FleetData.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (FleetData.to_xml x)))
        v
    let to_json v = `List (List.map FleetData.to_json v)
    let of_json j = Json.to_list FleetData.of_json j
  end
module DeleteQueuedReservedInstancesIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module SpotFleetRequestConfigSet =
  struct
    type t = SpotFleetRequestConfig.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SpotFleetRequestConfig.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SpotFleetRequestConfig.to_query v
    let to_headers v =
      Headers.to_headers_list SpotFleetRequestConfig.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (SpotFleetRequestConfig.to_xml x)))
        v
    let to_json v = `List (List.map SpotFleetRequestConfig.to_json v)
    let of_json j = Json.to_list SpotFleetRequestConfig.of_json j
  end
module FpgaImageAttributeName =
  struct
    type t =
      | Description 
      | Name 
      | LoadPermission 
      | ProductCodes 
    let str_to_t =
      [("productCodes", ProductCodes);
      ("loadPermission", LoadPermission);
      ("name", Name);
      ("description", Description)]
    let t_to_str =
      [(ProductCodes, "productCodes");
      (LoadPermission, "loadPermission");
      (Name, "name");
      (Description, "description")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VolumeAttributeName =
  struct
    type t =
      | AutoEnableIO 
      | ProductCodes 
    let str_to_t =
      [("productCodes", ProductCodes); ("autoEnableIO", AutoEnableIO)]
    let t_to_str =
      [(ProductCodes, "productCodes"); (AutoEnableIO, "autoEnableIO")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PurchaseRequestSet =
  struct
    type t = PurchaseRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PurchaseRequest.parse (Xml.members "PurchaseRequest" xml))
    let to_query v = Query.to_query_list PurchaseRequest.to_query v
    let to_headers v = Headers.to_headers_list PurchaseRequest.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PurchaseRequest.to_xml x)))
        v
    let to_json v = `List (List.map PurchaseRequest.to_json v)
    let of_json j = Json.to_list PurchaseRequest.of_json j
  end
module AvailabilityZoneList =
  struct
    type t = AvailabilityZone.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AvailabilityZone.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AvailabilityZone.to_query v
    let to_headers v = Headers.to_headers_list AvailabilityZone.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (AvailabilityZone.to_xml x)))
        v
    let to_json v = `List (List.map AvailabilityZone.to_json v)
    let of_json j = Json.to_list AvailabilityZone.of_json j
  end
module CoipPoolIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module CustomerGatewayList =
  struct
    type t = CustomerGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CustomerGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CustomerGateway.to_query v
    let to_headers v = Headers.to_headers_list CustomerGateway.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (CustomerGateway.to_xml x)))
        v
    let to_json v = `List (List.map CustomerGateway.to_json v)
    let of_json j = Json.to_list CustomerGateway.of_json j
  end
module VolumeStatusList =
  struct
    type t = VolumeStatusItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeStatusItem.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeStatusItem.to_query v
    let to_headers v = Headers.to_headers_list VolumeStatusItem.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VolumeStatusItem.to_xml x)))
        v
    let to_json v = `List (List.map VolumeStatusItem.to_json v)
    let of_json j = Json.to_list VolumeStatusItem.of_json j
  end
module TransitGatewayRequestOptions =
  struct
    type t =
      {
      amazon_side_asn: Long.t option ;
      auto_accept_shared_attachments:
        AutoAcceptSharedAttachmentsValue.t option ;
      default_route_table_association:
        DefaultRouteTableAssociationValue.t option ;
      default_route_table_propagation:
        DefaultRouteTablePropagationValue.t option ;
      vpn_ecmp_support: VpnEcmpSupportValue.t option ;
      dns_support: DnsSupportValue.t option ;
      multicast_support: MulticastSupportValue.t option }
    let make ?amazon_side_asn  ?auto_accept_shared_attachments 
      ?default_route_table_association  ?default_route_table_propagation 
      ?vpn_ecmp_support  ?dns_support  ?multicast_support  () =
      {
        amazon_side_asn;
        auto_accept_shared_attachments;
        default_route_table_association;
        default_route_table_propagation;
        vpn_ecmp_support;
        dns_support;
        multicast_support
      }
    let parse xml =
      Some
        {
          amazon_side_asn =
            (Util.option_bind (Xml.member "AmazonSideAsn" xml) Long.parse);
          auto_accept_shared_attachments =
            (Util.option_bind (Xml.member "AutoAcceptSharedAttachments" xml)
               AutoAcceptSharedAttachmentsValue.parse);
          default_route_table_association =
            (Util.option_bind (Xml.member "DefaultRouteTableAssociation" xml)
               DefaultRouteTableAssociationValue.parse);
          default_route_table_propagation =
            (Util.option_bind (Xml.member "DefaultRouteTablePropagation" xml)
               DefaultRouteTablePropagationValue.parse);
          vpn_ecmp_support =
            (Util.option_bind (Xml.member "VpnEcmpSupport" xml)
               VpnEcmpSupportValue.parse);
          dns_support =
            (Util.option_bind (Xml.member "DnsSupport" xml)
               DnsSupportValue.parse);
          multicast_support =
            (Util.option_bind (Xml.member "MulticastSupport" xml)
               MulticastSupportValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.multicast_support
              (fun f ->
                 Query.Pair
                   ("MulticastSupport", (MulticastSupportValue.to_query f)));
           Util.option_map v.dns_support
             (fun f ->
                Query.Pair ("DnsSupport", (DnsSupportValue.to_query f)));
           Util.option_map v.vpn_ecmp_support
             (fun f ->
                Query.Pair
                  ("VpnEcmpSupport", (VpnEcmpSupportValue.to_query f)));
           Util.option_map v.default_route_table_propagation
             (fun f ->
                Query.Pair
                  ("DefaultRouteTablePropagation",
                    (DefaultRouteTablePropagationValue.to_query f)));
           Util.option_map v.default_route_table_association
             (fun f ->
                Query.Pair
                  ("DefaultRouteTableAssociation",
                    (DefaultRouteTableAssociationValue.to_query f)));
           Util.option_map v.auto_accept_shared_attachments
             (fun f ->
                Query.Pair
                  ("AutoAcceptSharedAttachments",
                    (AutoAcceptSharedAttachmentsValue.to_query f)));
           Util.option_map v.amazon_side_asn
             (fun f -> Query.Pair ("AmazonSideAsn", (Long.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.amazon_side_asn
                    (fun f ->
                       Ezxmlm.make_tag "AmazonSideAsn" ([], (Long.to_xml f)))])
                @
                [Util.option_map v.auto_accept_shared_attachments
                   (fun f ->
                      Ezxmlm.make_tag "AutoAcceptSharedAttachments"
                        ([], (AutoAcceptSharedAttachmentsValue.to_xml f)))])
               @
               [Util.option_map v.default_route_table_association
                  (fun f ->
                     Ezxmlm.make_tag "DefaultRouteTableAssociation"
                       ([], (DefaultRouteTableAssociationValue.to_xml f)))])
              @
              [Util.option_map v.default_route_table_propagation
                 (fun f ->
                    Ezxmlm.make_tag "DefaultRouteTablePropagation"
                      ([], (DefaultRouteTablePropagationValue.to_xml f)))])
             @
             [Util.option_map v.vpn_ecmp_support
                (fun f ->
                   Ezxmlm.make_tag "VpnEcmpSupport"
                     ([], (VpnEcmpSupportValue.to_xml f)))])
            @
            [Util.option_map v.dns_support
               (fun f ->
                  Ezxmlm.make_tag "DnsSupport"
                    ([], (DnsSupportValue.to_xml f)))])
           @
           [Util.option_map v.multicast_support
              (fun f ->
                 Ezxmlm.make_tag "MulticastSupport"
                   ([], (MulticastSupportValue.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.multicast_support
              (fun f ->
                 ("multicast_support", (MulticastSupportValue.to_json f)));
           Util.option_map v.dns_support
             (fun f -> ("dns_support", (DnsSupportValue.to_json f)));
           Util.option_map v.vpn_ecmp_support
             (fun f -> ("vpn_ecmp_support", (VpnEcmpSupportValue.to_json f)));
           Util.option_map v.default_route_table_propagation
             (fun f ->
                ("default_route_table_propagation",
                  (DefaultRouteTablePropagationValue.to_json f)));
           Util.option_map v.default_route_table_association
             (fun f ->
                ("default_route_table_association",
                  (DefaultRouteTableAssociationValue.to_json f)));
           Util.option_map v.auto_accept_shared_attachments
             (fun f ->
                ("auto_accept_shared_attachments",
                  (AutoAcceptSharedAttachmentsValue.to_json f)));
           Util.option_map v.amazon_side_asn
             (fun f -> ("amazon_side_asn", (Long.to_json f)))])
    let of_json j =
      {
        amazon_side_asn =
          (Util.option_map (Json.lookup j "amazon_side_asn") Long.of_json);
        auto_accept_shared_attachments =
          (Util.option_map (Json.lookup j "auto_accept_shared_attachments")
             AutoAcceptSharedAttachmentsValue.of_json);
        default_route_table_association =
          (Util.option_map (Json.lookup j "default_route_table_association")
             DefaultRouteTableAssociationValue.of_json);
        default_route_table_propagation =
          (Util.option_map (Json.lookup j "default_route_table_propagation")
             DefaultRouteTablePropagationValue.of_json);
        vpn_ecmp_support =
          (Util.option_map (Json.lookup j "vpn_ecmp_support")
             VpnEcmpSupportValue.of_json);
        dns_support =
          (Util.option_map (Json.lookup j "dns_support")
             DnsSupportValue.of_json);
        multicast_support =
          (Util.option_map (Json.lookup j "multicast_support")
             MulticastSupportValue.of_json)
      }
  end
module TransitGatewayRouteTableAssociationList =
  struct
    type t = TransitGatewayRouteTableAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayRouteTableAssociation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayRouteTableAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayRouteTableAssociation.to_headers
        v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayRouteTableAssociation.to_xml x))) v
    let to_json v =
      `List (List.map TransitGatewayRouteTableAssociation.to_json v)
    let of_json j =
      Json.to_list TransitGatewayRouteTableAssociation.of_json j
  end
module HostOfferingSet =
  struct
    type t = HostOffering.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map HostOffering.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list HostOffering.to_query v
    let to_headers v = Headers.to_headers_list HostOffering.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (HostOffering.to_xml x))) v
    let to_json v = `List (List.map HostOffering.to_json v)
    let of_json j = Json.to_list HostOffering.of_json j
  end
module TransitGatewayIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module Affinity =
  struct
    type t =
      | Default 
      | Host 
    let str_to_t = [("host", Host); ("default", Default)]
    let t_to_str = [(Host, "host"); (Default, "default")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module HostTenancy =
  struct
    type t =
      | Dedicated 
      | Host 
    let str_to_t = [("host", Host); ("dedicated", Dedicated)]
    let t_to_str = [(Host, "host"); (Dedicated, "dedicated")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EgressOnlyInternetGatewayIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module NetworkInterfacePermissionIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ModifyVpnTunnelOptionsSpecification =
  struct
    type t =
      {
      tunnel_inside_cidr: String.t option ;
      pre_shared_key: String.t option ;
      phase1_lifetime_seconds: Integer.t option ;
      phase2_lifetime_seconds: Integer.t option ;
      rekey_margin_time_seconds: Integer.t option ;
      rekey_fuzz_percentage: Integer.t option ;
      replay_window_size: Integer.t option ;
      d_p_d_timeout_seconds: Integer.t option ;
      phase1_encryption_algorithms: Phase1EncryptionAlgorithmsRequestList.t ;
      phase2_encryption_algorithms: Phase2EncryptionAlgorithmsRequestList.t ;
      phase1_integrity_algorithms: Phase1IntegrityAlgorithmsRequestList.t ;
      phase2_integrity_algorithms: Phase2IntegrityAlgorithmsRequestList.t ;
      phase1_d_h_group_numbers: Phase1DHGroupNumbersRequestList.t ;
      phase2_d_h_group_numbers: Phase2DHGroupNumbersRequestList.t ;
      i_k_e_versions: IKEVersionsRequestList.t }
    let make ?tunnel_inside_cidr  ?pre_shared_key  ?phase1_lifetime_seconds 
      ?phase2_lifetime_seconds  ?rekey_margin_time_seconds 
      ?rekey_fuzz_percentage  ?replay_window_size  ?d_p_d_timeout_seconds 
      ?(phase1_encryption_algorithms= [])  ?(phase2_encryption_algorithms=
      [])  ?(phase1_integrity_algorithms= [])  ?(phase2_integrity_algorithms=
      [])  ?(phase1_d_h_group_numbers= [])  ?(phase2_d_h_group_numbers= []) 
      ?(i_k_e_versions= [])  () =
      {
        tunnel_inside_cidr;
        pre_shared_key;
        phase1_lifetime_seconds;
        phase2_lifetime_seconds;
        rekey_margin_time_seconds;
        rekey_fuzz_percentage;
        replay_window_size;
        d_p_d_timeout_seconds;
        phase1_encryption_algorithms;
        phase2_encryption_algorithms;
        phase1_integrity_algorithms;
        phase2_integrity_algorithms;
        phase1_d_h_group_numbers;
        phase2_d_h_group_numbers;
        i_k_e_versions
      }
    let parse xml =
      Some
        {
          tunnel_inside_cidr =
            (Util.option_bind (Xml.member "TunnelInsideCidr" xml)
               String.parse);
          pre_shared_key =
            (Util.option_bind (Xml.member "PreSharedKey" xml) String.parse);
          phase1_lifetime_seconds =
            (Util.option_bind (Xml.member "Phase1LifetimeSeconds" xml)
               Integer.parse);
          phase2_lifetime_seconds =
            (Util.option_bind (Xml.member "Phase2LifetimeSeconds" xml)
               Integer.parse);
          rekey_margin_time_seconds =
            (Util.option_bind (Xml.member "RekeyMarginTimeSeconds" xml)
               Integer.parse);
          rekey_fuzz_percentage =
            (Util.option_bind (Xml.member "RekeyFuzzPercentage" xml)
               Integer.parse);
          replay_window_size =
            (Util.option_bind (Xml.member "ReplayWindowSize" xml)
               Integer.parse);
          d_p_d_timeout_seconds =
            (Util.option_bind (Xml.member "DPDTimeoutSeconds" xml)
               Integer.parse);
          phase1_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1EncryptionAlgorithm" xml)
                  Phase1EncryptionAlgorithmsRequestList.parse));
          phase2_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2EncryptionAlgorithm" xml)
                  Phase2EncryptionAlgorithmsRequestList.parse));
          phase1_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1IntegrityAlgorithm" xml)
                  Phase1IntegrityAlgorithmsRequestList.parse));
          phase2_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2IntegrityAlgorithm" xml)
                  Phase2IntegrityAlgorithmsRequestList.parse));
          phase1_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1DHGroupNumber" xml)
                  Phase1DHGroupNumbersRequestList.parse));
          phase2_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2DHGroupNumber" xml)
                  Phase2DHGroupNumbersRequestList.parse));
          i_k_e_versions =
            (Util.of_option []
               (Util.option_bind (Xml.member "IKEVersion" xml)
                  IKEVersionsRequestList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("IKEVersion",
                   (IKEVersionsRequestList.to_query v.i_k_e_versions)));
           Some
             (Query.Pair
                ("Phase2DHGroupNumber",
                  (Phase2DHGroupNumbersRequestList.to_query
                     v.phase2_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase1DHGroupNumber",
                  (Phase1DHGroupNumbersRequestList.to_query
                     v.phase1_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase2IntegrityAlgorithm",
                  (Phase2IntegrityAlgorithmsRequestList.to_query
                     v.phase2_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase1IntegrityAlgorithm",
                  (Phase1IntegrityAlgorithmsRequestList.to_query
                     v.phase1_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase2EncryptionAlgorithm",
                  (Phase2EncryptionAlgorithmsRequestList.to_query
                     v.phase2_encryption_algorithms)));
           Some
             (Query.Pair
                ("Phase1EncryptionAlgorithm",
                  (Phase1EncryptionAlgorithmsRequestList.to_query
                     v.phase1_encryption_algorithms)));
           Util.option_map v.d_p_d_timeout_seconds
             (fun f -> Query.Pair ("DPDTimeoutSeconds", (Integer.to_query f)));
           Util.option_map v.replay_window_size
             (fun f -> Query.Pair ("ReplayWindowSize", (Integer.to_query f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f ->
                Query.Pair ("RekeyFuzzPercentage", (Integer.to_query f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f ->
                Query.Pair ("RekeyMarginTimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase2LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase1LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.pre_shared_key
             (fun f -> Query.Pair ("PreSharedKey", (String.to_query f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> Query.Pair ("TunnelInsideCidr", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Util.option_map v.tunnel_inside_cidr
                            (fun f ->
                               Ezxmlm.make_tag "TunnelInsideCidr"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.pre_shared_key
                           (fun f ->
                              Ezxmlm.make_tag "PreSharedKey"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.phase1_lifetime_seconds
                          (fun f ->
                             Ezxmlm.make_tag "Phase1LifetimeSeconds"
                               ([], (Integer.to_xml f)))])
                      @
                      [Util.option_map v.phase2_lifetime_seconds
                         (fun f ->
                            Ezxmlm.make_tag "Phase2LifetimeSeconds"
                              ([], (Integer.to_xml f)))])
                     @
                     [Util.option_map v.rekey_margin_time_seconds
                        (fun f ->
                           Ezxmlm.make_tag "RekeyMarginTimeSeconds"
                             ([], (Integer.to_xml f)))])
                    @
                    [Util.option_map v.rekey_fuzz_percentage
                       (fun f ->
                          Ezxmlm.make_tag "RekeyFuzzPercentage"
                            ([], (Integer.to_xml f)))])
                   @
                   [Util.option_map v.replay_window_size
                      (fun f ->
                         Ezxmlm.make_tag "ReplayWindowSize"
                           ([], (Integer.to_xml f)))])
                  @
                  [Util.option_map v.d_p_d_timeout_seconds
                     (fun f ->
                        Ezxmlm.make_tag "DPDTimeoutSeconds"
                          ([], (Integer.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "Phase1EncryptionAlgorithm"
                            ([],
                              (Phase1EncryptionAlgorithmsRequestList.to_xml
                                 [x])))) v.phase1_encryption_algorithms))
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "Phase2EncryptionAlgorithm"
                           ([],
                             (Phase2EncryptionAlgorithmsRequestList.to_xml
                                [x])))) v.phase2_encryption_algorithms))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Phase1IntegrityAlgorithm"
                          ([],
                            (Phase1IntegrityAlgorithmsRequestList.to_xml [x]))))
                  v.phase1_integrity_algorithms))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Phase2IntegrityAlgorithm"
                         ([],
                           (Phase2IntegrityAlgorithmsRequestList.to_xml [x]))))
                 v.phase2_integrity_algorithms))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Phase1DHGroupNumber"
                        ([], (Phase1DHGroupNumbersRequestList.to_xml [x]))))
                v.phase1_d_h_group_numbers))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Phase2DHGroupNumber"
                       ([], (Phase2DHGroupNumbersRequestList.to_xml [x]))))
               v.phase2_d_h_group_numbers))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "IKEVersion"
                      ([], (IKEVersionsRequestList.to_xml [x]))))
              v.i_k_e_versions))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("i_k_e_versions",
                (IKEVersionsRequestList.to_json v.i_k_e_versions));
           Some
             ("phase2_d_h_group_numbers",
               (Phase2DHGroupNumbersRequestList.to_json
                  v.phase2_d_h_group_numbers));
           Some
             ("phase1_d_h_group_numbers",
               (Phase1DHGroupNumbersRequestList.to_json
                  v.phase1_d_h_group_numbers));
           Some
             ("phase2_integrity_algorithms",
               (Phase2IntegrityAlgorithmsRequestList.to_json
                  v.phase2_integrity_algorithms));
           Some
             ("phase1_integrity_algorithms",
               (Phase1IntegrityAlgorithmsRequestList.to_json
                  v.phase1_integrity_algorithms));
           Some
             ("phase2_encryption_algorithms",
               (Phase2EncryptionAlgorithmsRequestList.to_json
                  v.phase2_encryption_algorithms));
           Some
             ("phase1_encryption_algorithms",
               (Phase1EncryptionAlgorithmsRequestList.to_json
                  v.phase1_encryption_algorithms));
           Util.option_map v.d_p_d_timeout_seconds
             (fun f -> ("d_p_d_timeout_seconds", (Integer.to_json f)));
           Util.option_map v.replay_window_size
             (fun f -> ("replay_window_size", (Integer.to_json f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f -> ("rekey_fuzz_percentage", (Integer.to_json f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f -> ("rekey_margin_time_seconds", (Integer.to_json f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f -> ("phase2_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f -> ("phase1_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.pre_shared_key
             (fun f -> ("pre_shared_key", (String.to_json f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> ("tunnel_inside_cidr", (String.to_json f)))])
    let of_json j =
      {
        tunnel_inside_cidr =
          (Util.option_map (Json.lookup j "tunnel_inside_cidr")
             String.of_json);
        pre_shared_key =
          (Util.option_map (Json.lookup j "pre_shared_key") String.of_json);
        phase1_lifetime_seconds =
          (Util.option_map (Json.lookup j "phase1_lifetime_seconds")
             Integer.of_json);
        phase2_lifetime_seconds =
          (Util.option_map (Json.lookup j "phase2_lifetime_seconds")
             Integer.of_json);
        rekey_margin_time_seconds =
          (Util.option_map (Json.lookup j "rekey_margin_time_seconds")
             Integer.of_json);
        rekey_fuzz_percentage =
          (Util.option_map (Json.lookup j "rekey_fuzz_percentage")
             Integer.of_json);
        replay_window_size =
          (Util.option_map (Json.lookup j "replay_window_size")
             Integer.of_json);
        d_p_d_timeout_seconds =
          (Util.option_map (Json.lookup j "d_p_d_timeout_seconds")
             Integer.of_json);
        phase1_encryption_algorithms =
          (Phase1EncryptionAlgorithmsRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase1_encryption_algorithms")));
        phase2_encryption_algorithms =
          (Phase2EncryptionAlgorithmsRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase2_encryption_algorithms")));
        phase1_integrity_algorithms =
          (Phase1IntegrityAlgorithmsRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase1_integrity_algorithms")));
        phase2_integrity_algorithms =
          (Phase2IntegrityAlgorithmsRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase2_integrity_algorithms")));
        phase1_d_h_group_numbers =
          (Phase1DHGroupNumbersRequestList.of_json
             (Util.of_option_exn (Json.lookup j "phase1_d_h_group_numbers")));
        phase2_d_h_group_numbers =
          (Phase2DHGroupNumbersRequestList.of_json
             (Util.of_option_exn (Json.lookup j "phase2_d_h_group_numbers")));
        i_k_e_versions =
          (IKEVersionsRequestList.of_json
             (Util.of_option_exn (Json.lookup j "i_k_e_versions")))
      }
  end
module TransitGatewayRouteTableList =
  struct
    type t = TransitGatewayRouteTable.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayRouteTable.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TransitGatewayRouteTable.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayRouteTable.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (TransitGatewayRouteTable.to_xml x)))
        v
    let to_json v = `List (List.map TransitGatewayRouteTable.to_json v)
    let of_json j = Json.to_list TransitGatewayRouteTable.of_json j
  end
module ClientData =
  struct
    type t =
      {
      comment: String.t option ;
      upload_end: DateTime.t option ;
      upload_size: Double.t option ;
      upload_start: DateTime.t option }
    let make ?comment  ?upload_end  ?upload_size  ?upload_start  () =
      { comment; upload_end; upload_size; upload_start }
    let parse xml =
      Some
        {
          comment =
            (Util.option_bind (Xml.member "Comment" xml) String.parse);
          upload_end =
            (Util.option_bind (Xml.member "UploadEnd" xml) DateTime.parse);
          upload_size =
            (Util.option_bind (Xml.member "UploadSize" xml) Double.parse);
          upload_start =
            (Util.option_bind (Xml.member "UploadStart" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.upload_start
              (fun f -> Query.Pair ("UploadStart", (DateTime.to_query f)));
           Util.option_map v.upload_size
             (fun f -> Query.Pair ("UploadSize", (Double.to_query f)));
           Util.option_map v.upload_end
             (fun f -> Query.Pair ("UploadEnd", (DateTime.to_query f)));
           Util.option_map v.comment
             (fun f -> Query.Pair ("Comment", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.comment
                 (fun f -> Ezxmlm.make_tag "Comment" ([], (String.to_xml f)))])
             @
             [Util.option_map v.upload_end
                (fun f ->
                   Ezxmlm.make_tag "UploadEnd" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.upload_size
               (fun f -> Ezxmlm.make_tag "UploadSize" ([], (Double.to_xml f)))])
           @
           [Util.option_map v.upload_start
              (fun f ->
                 Ezxmlm.make_tag "UploadStart" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.upload_start
              (fun f -> ("upload_start", (DateTime.to_json f)));
           Util.option_map v.upload_size
             (fun f -> ("upload_size", (Double.to_json f)));
           Util.option_map v.upload_end
             (fun f -> ("upload_end", (DateTime.to_json f)));
           Util.option_map v.comment
             (fun f -> ("comment", (String.to_json f)))])
    let of_json j =
      {
        comment = (Util.option_map (Json.lookup j "comment") String.of_json);
        upload_end =
          (Util.option_map (Json.lookup j "upload_end") DateTime.of_json);
        upload_size =
          (Util.option_map (Json.lookup j "upload_size") Double.of_json);
        upload_start =
          (Util.option_map (Json.lookup j "upload_start") DateTime.of_json)
      }
  end
module SnapshotDiskContainer =
  struct
    type t =
      {
      description: String.t option ;
      format: String.t option ;
      url: String.t option ;
      user_bucket: UserBucket.t option }
    let make ?description  ?format  ?url  ?user_bucket  () =
      { description; format; url; user_bucket }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          format = (Util.option_bind (Xml.member "Format" xml) String.parse);
          url = (Util.option_bind (Xml.member "Url" xml) String.parse);
          user_bucket =
            (Util.option_bind (Xml.member "UserBucket" xml) UserBucket.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> Query.Pair ("UserBucket", (UserBucket.to_query f)));
           Util.option_map v.url
             (fun f -> Query.Pair ("Url", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
             @
             [Util.option_map v.format
                (fun f -> Ezxmlm.make_tag "Format" ([], (String.to_xml f)))])
            @
            [Util.option_map v.url
               (fun f -> Ezxmlm.make_tag "Url" ([], (String.to_xml f)))])
           @
           [Util.option_map v.user_bucket
              (fun f ->
                 Ezxmlm.make_tag "UserBucket" ([], (UserBucket.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> ("user_bucket", (UserBucket.to_json f)));
           Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.format (fun f -> ("format", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        format = (Util.option_map (Json.lookup j "format") String.of_json);
        url = (Util.option_map (Json.lookup j "url") String.of_json);
        user_bucket =
          (Util.option_map (Json.lookup j "user_bucket") UserBucket.of_json)
      }
  end
module TransitGatewayMulticastDeregisteredGroupMembers =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      deregistered_network_interface_ids: ValueStringList.t ;
      group_ip_address: String.t option }
    let make ?transit_gateway_multicast_domain_id 
      ?(deregistered_network_interface_ids= [])  ?group_ip_address  () =
      {
        transit_gateway_multicast_domain_id;
        deregistered_network_interface_ids;
        group_ip_address
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          deregistered_network_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "deregisteredNetworkInterfaceIds" xml)
                  ValueStringList.parse));
          group_ip_address =
            (Util.option_bind (Xml.member "groupIpAddress" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("DeregisteredNetworkInterfaceIds",
                  (ValueStringList.to_query
                     v.deregistered_network_interface_ids)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.transit_gateway_multicast_domain_id
                (fun f ->
                   Ezxmlm.make_tag "transitGatewayMulticastDomainId"
                     ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "deregisteredNetworkInterfaceIds"
                       ([], (ValueStringList.to_xml [x]))))
               v.deregistered_network_interface_ids))
           @
           [Util.option_map v.group_ip_address
              (fun f ->
                 Ezxmlm.make_tag "groupIpAddress" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> ("group_ip_address", (String.to_json f)));
           Some
             ("deregistered_network_interface_ids",
               (ValueStringList.to_json v.deregistered_network_interface_ids));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        deregistered_network_interface_ids =
          (ValueStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "deregistered_network_interface_ids")));
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json)
      }
  end
module AuthorizationRuleSet =
  struct
    type t = AuthorizationRule.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AuthorizationRule.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AuthorizationRule.to_query v
    let to_headers v = Headers.to_headers_list AuthorizationRule.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (AuthorizationRule.to_xml x)))
        v
    let to_json v = `List (List.map AuthorizationRule.to_json v)
    let of_json j = Json.to_list AuthorizationRule.of_json j
  end
module TransitGatewayMulticastDomainAssociationList =
  struct
    type t = TransitGatewayMulticastDomainAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayMulticastDomainAssociation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayMulticastDomainAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list
        TransitGatewayMulticastDomainAssociation.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayMulticastDomainAssociation.to_xml x))) v
    let to_json v =
      `List (List.map TransitGatewayMulticastDomainAssociation.to_json v)
    let of_json j =
      Json.to_list TransitGatewayMulticastDomainAssociation.of_json j
  end
module TrafficMirrorSessionFieldList =
  struct
    type t = TrafficMirrorSessionField.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorSessionField.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list TrafficMirrorSessionField.to_query v
    let to_headers v =
      Headers.to_headers_list TrafficMirrorSessionField.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TrafficMirrorSessionField.to_xml x))) v
    let to_json v = `List (List.map TrafficMirrorSessionField.to_json v)
    let of_json j = Json.to_list TrafficMirrorSessionField.of_json j
  end
module SuccessfulInstanceCreditSpecificationSet =
  struct
    type t = SuccessfulInstanceCreditSpecificationItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SuccessfulInstanceCreditSpecificationItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list SuccessfulInstanceCreditSpecificationItem.to_query
        v
    let to_headers v =
      Headers.to_headers_list
        SuccessfulInstanceCreditSpecificationItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (SuccessfulInstanceCreditSpecificationItem.to_xml x))) v
    let to_json v =
      `List (List.map SuccessfulInstanceCreditSpecificationItem.to_json v)
    let of_json j =
      Json.to_list SuccessfulInstanceCreditSpecificationItem.of_json j
  end
module UnsuccessfulInstanceCreditSpecificationSet =
  struct
    type t = UnsuccessfulInstanceCreditSpecificationItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map UnsuccessfulInstanceCreditSpecificationItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list
        UnsuccessfulInstanceCreditSpecificationItem.to_query v
    let to_headers v =
      Headers.to_headers_list
        UnsuccessfulInstanceCreditSpecificationItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (UnsuccessfulInstanceCreditSpecificationItem.to_xml x))) v
    let to_json v =
      `List (List.map UnsuccessfulInstanceCreditSpecificationItem.to_json v)
    let of_json j =
      Json.to_list UnsuccessfulInstanceCreditSpecificationItem.of_json j
  end
module ReservedInstancesOfferingList =
  struct
    type t = ReservedInstancesOffering.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesOffering.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ReservedInstancesOffering.to_query v
    let to_headers v =
      Headers.to_headers_list ReservedInstancesOffering.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ReservedInstancesOffering.to_xml x))) v
    let to_json v = `List (List.map ReservedInstancesOffering.to_json v)
    let of_json j = Json.to_list ReservedInstancesOffering.of_json j
  end
module ScheduledInstanceAvailabilitySet =
  struct
    type t = ScheduledInstanceAvailability.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ScheduledInstanceAvailability.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ScheduledInstanceAvailability.to_query v
    let to_headers v =
      Headers.to_headers_list ScheduledInstanceAvailability.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ScheduledInstanceAvailability.to_xml x))) v
    let to_json v = `List (List.map ScheduledInstanceAvailability.to_json v)
    let of_json j = Json.to_list ScheduledInstanceAvailability.of_json j
  end
module ReservationList =
  struct
    type t = Reservation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Reservation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Reservation.to_query v
    let to_headers v = Headers.to_headers_list Reservation.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (Reservation.to_xml x))) v
    let to_json v = `List (List.map Reservation.to_json v)
    let of_json j = Json.to_list Reservation.of_json j
  end
module LocalGatewayVirtualInterfaceGroupIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PublicIpv4PoolSet =
  struct
    type t = PublicIpv4Pool.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PublicIpv4Pool.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PublicIpv4Pool.to_query v
    let to_headers v = Headers.to_headers_list PublicIpv4Pool.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PublicIpv4Pool.to_xml x))) v
    let to_json v = `List (List.map PublicIpv4Pool.to_json v)
    let of_json j = Json.to_list PublicIpv4Pool.of_json j
  end
module VpcList =
  struct
    type t = Vpc.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Vpc.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Vpc.to_query v
    let to_headers v = Headers.to_headers_list Vpc.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Vpc.to_xml x))) v
    let to_json v = `List (List.map Vpc.to_json v)
    let of_json j = Json.to_list Vpc.of_json j
  end
module LocalGatewaySet =
  struct
    type t = LocalGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map LocalGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LocalGateway.to_query v
    let to_headers v = Headers.to_headers_list LocalGateway.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (LocalGateway.to_xml x))) v
    let to_json v = `List (List.map LocalGateway.to_json v)
    let of_json j = Json.to_list LocalGateway.of_json j
  end
module SubnetList =
  struct
    type t = Subnet.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Subnet.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Subnet.to_query v
    let to_headers v = Headers.to_headers_list Subnet.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Subnet.to_xml x))) v
    let to_json v = `List (List.map Subnet.to_json v)
    let of_json j = Json.to_list Subnet.of_json j
  end
module ElasticGpuSet =
  struct
    type t = ElasticGpus.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map ElasticGpus.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ElasticGpus.to_query v
    let to_headers v = Headers.to_headers_list ElasticGpus.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ElasticGpus.to_xml x))) v
    let to_json v = `List (List.map ElasticGpus.to_json v)
    let of_json j = Json.to_list ElasticGpus.of_json j
  end
module VpcClassicLinkList =
  struct
    type t = VpcClassicLink.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpcClassicLink.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpcClassicLink.to_query v
    let to_headers v = Headers.to_headers_list VpcClassicLink.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VpcClassicLink.to_xml x))) v
    let to_json v = `List (List.map VpcClassicLink.to_json v)
    let of_json j = Json.to_list VpcClassicLink.of_json j
  end
module ImportImageTaskList =
  struct
    type t = ImportImageTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ImportImageTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ImportImageTask.to_query v
    let to_headers v = Headers.to_headers_list ImportImageTask.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ImportImageTask.to_xml x)))
        v
    let to_json v = `List (List.map ImportImageTask.to_json v)
    let of_json j = Json.to_list ImportImageTask.of_json j
  end
module FlowLogsResourceType =
  struct
    type t =
      | VPC 
      | Subnet 
      | NetworkInterface 
    let str_to_t =
      [("NetworkInterface", NetworkInterface);
      ("Subnet", Subnet);
      ("VPC", VPC)]
    let t_to_str =
      [(NetworkInterface, "NetworkInterface");
      (Subnet, "Subnet");
      (VPC, "VPC")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpcTenancy =
  struct
    type t =
      | Default 
    let str_to_t = [("default", Default)]
    let t_to_str = [(Default, "default")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FpgaImageIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module DhcpOptionsIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "DhcpOptionsId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module SpotPriceHistoryList =
  struct
    type t = SpotPrice.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map SpotPrice.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SpotPrice.to_query v
    let to_headers v = Headers.to_headers_list SpotPrice.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (SpotPrice.to_xml x)))
        v
    let to_json v = `List (List.map SpotPrice.to_json v)
    let of_json j = Json.to_list SpotPrice.of_json j
  end
module ReasonCodesList =
  struct
    type t = ReportInstanceReasonCodes.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReportInstanceReasonCodes.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ReportInstanceReasonCodes.to_query v
    let to_headers v =
      Headers.to_headers_list ReportInstanceReasonCodes.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ReportInstanceReasonCodes.to_xml x))) v
    let to_json v = `List (List.map ReportInstanceReasonCodes.to_json v)
    let of_json j = Json.to_list ReportInstanceReasonCodes.of_json j
  end
module ReportStatusType =
  struct
    type t =
      | Ok 
      | Impaired 
    let str_to_t = [("impaired", Impaired); ("ok", Ok)]
    let t_to_str = [(Impaired, "impaired"); (Ok, "ok")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceCreditSpecificationListRequest =
  struct
    type t = InstanceCreditSpecificationRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceCreditSpecificationRequest.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list InstanceCreditSpecificationRequest.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceCreditSpecificationRequest.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InstanceCreditSpecificationRequest.to_xml x))) v
    let to_json v =
      `List (List.map InstanceCreditSpecificationRequest.to_json v)
    let of_json j = Json.to_list InstanceCreditSpecificationRequest.of_json j
  end
module VersionStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module NetworkInterfaceCreationType =
  struct
    type t =
      | Efa 
    let str_to_t = [("efa", Efa)]
    let t_to_str = [(Efa, "efa")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module HostReservationIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ScheduledInstanceRecurrenceRequest =
  struct
    type t =
      {
      frequency: String.t option ;
      interval: Integer.t option ;
      occurrence_days: OccurrenceDayRequestSet.t ;
      occurrence_relative_to_end: Boolean.t option ;
      occurrence_unit: String.t option }
    let make ?frequency  ?interval  ?(occurrence_days= []) 
      ?occurrence_relative_to_end  ?occurrence_unit  () =
      {
        frequency;
        interval;
        occurrence_days;
        occurrence_relative_to_end;
        occurrence_unit
      }
    let parse xml =
      Some
        {
          frequency =
            (Util.option_bind (Xml.member "Frequency" xml) String.parse);
          interval =
            (Util.option_bind (Xml.member "Interval" xml) Integer.parse);
          occurrence_days =
            (Util.of_option []
               (Util.option_bind (Xml.member "OccurrenceDay" xml)
                  OccurrenceDayRequestSet.parse));
          occurrence_relative_to_end =
            (Util.option_bind (Xml.member "OccurrenceRelativeToEnd" xml)
               Boolean.parse);
          occurrence_unit =
            (Util.option_bind (Xml.member "OccurrenceUnit" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.occurrence_unit
              (fun f -> Query.Pair ("OccurrenceUnit", (String.to_query f)));
           Util.option_map v.occurrence_relative_to_end
             (fun f ->
                Query.Pair ("OccurrenceRelativeToEnd", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("OccurrenceDay",
                  (OccurrenceDayRequestSet.to_query v.occurrence_days)));
           Util.option_map v.interval
             (fun f -> Query.Pair ("Interval", (Integer.to_query f)));
           Util.option_map v.frequency
             (fun f -> Query.Pair ("Frequency", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.frequency
                  (fun f ->
                     Ezxmlm.make_tag "Frequency" ([], (String.to_xml f)))])
              @
              [Util.option_map v.interval
                 (fun f ->
                    Ezxmlm.make_tag "Interval" ([], (Integer.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "OccurrenceDay"
                        ([], (OccurrenceDayRequestSet.to_xml [x]))))
                v.occurrence_days))
            @
            [Util.option_map v.occurrence_relative_to_end
               (fun f ->
                  Ezxmlm.make_tag "OccurrenceRelativeToEnd"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.occurrence_unit
              (fun f ->
                 Ezxmlm.make_tag "OccurrenceUnit" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.occurrence_unit
              (fun f -> ("occurrence_unit", (String.to_json f)));
           Util.option_map v.occurrence_relative_to_end
             (fun f -> ("occurrence_relative_to_end", (Boolean.to_json f)));
           Some
             ("occurrence_days",
               (OccurrenceDayRequestSet.to_json v.occurrence_days));
           Util.option_map v.interval
             (fun f -> ("interval", (Integer.to_json f)));
           Util.option_map v.frequency
             (fun f -> ("frequency", (String.to_json f)))])
    let of_json j =
      {
        frequency =
          (Util.option_map (Json.lookup j "frequency") String.of_json);
        interval =
          (Util.option_map (Json.lookup j "interval") Integer.of_json);
        occurrence_days =
          (OccurrenceDayRequestSet.of_json
             (Util.of_option_exn (Json.lookup j "occurrence_days")));
        occurrence_relative_to_end =
          (Util.option_map (Json.lookup j "occurrence_relative_to_end")
             Boolean.of_json);
        occurrence_unit =
          (Util.option_map (Json.lookup j "occurrence_unit") String.of_json)
      }
  end
module SlotDateTimeRangeRequest =
  struct
    type t = {
      earliest_time: DateTime.t ;
      latest_time: DateTime.t }
    let make ~earliest_time  ~latest_time  () =
      { earliest_time; latest_time }
    let parse xml =
      Some
        {
          earliest_time =
            (Xml.required "EarliestTime"
               (Util.option_bind (Xml.member "EarliestTime" xml)
                  DateTime.parse));
          latest_time =
            (Xml.required "LatestTime"
               (Util.option_bind (Xml.member "LatestTime" xml) DateTime.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("LatestTime", (DateTime.to_query v.latest_time)));
           Some
             (Query.Pair
                ("EarliestTime", (DateTime.to_query v.earliest_time)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "EarliestTime"
                  ([], (DateTime.to_xml v.earliest_time)))])
           @
           [Some
              (Ezxmlm.make_tag "LatestTime"
                 ([], (DateTime.to_xml v.latest_time)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("latest_time", (DateTime.to_json v.latest_time));
           Some ("earliest_time", (DateTime.to_json v.earliest_time))])
    let of_json j =
      {
        earliest_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "earliest_time")));
        latest_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "latest_time")))
      }
  end
module ImageDiskContainerList =
  struct
    type t = ImageDiskContainer.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ImageDiskContainer.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ImageDiskContainer.to_query v
    let to_headers v =
      Headers.to_headers_list ImageDiskContainer.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ImageDiskContainer.to_xml x))) v
    let to_json v = `List (List.map ImageDiskContainer.to_json v)
    let of_json j = Json.to_list ImageDiskContainer.of_json j
  end
module ImportImageLicenseSpecificationListRequest =
  struct
    type t = ImportImageLicenseConfigurationRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ImportImageLicenseConfigurationRequest.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ImportImageLicenseConfigurationRequest.to_query v
    let to_headers v =
      Headers.to_headers_list
        ImportImageLicenseConfigurationRequest.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ImportImageLicenseConfigurationRequest.to_xml x))) v
    let to_json v =
      `List (List.map ImportImageLicenseConfigurationRequest.to_json v)
    let of_json j =
      Json.to_list ImportImageLicenseConfigurationRequest.of_json j
  end
module LocalGatewayRouteList =
  struct
    type t = LocalGatewayRoute.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LocalGatewayRoute.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LocalGatewayRoute.to_query v
    let to_headers v = Headers.to_headers_list LocalGatewayRoute.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (LocalGatewayRoute.to_xml x)))
        v
    let to_json v = `List (List.map LocalGatewayRoute.to_json v)
    let of_json j = Json.to_list LocalGatewayRoute.of_json j
  end
module ScheduledInstancesLaunchSpecification =
  struct
    type t =
      {
      block_device_mappings: ScheduledInstancesBlockDeviceMappingSet.t ;
      ebs_optimized: Boolean.t option ;
      iam_instance_profile: ScheduledInstancesIamInstanceProfile.t option ;
      image_id: String.t ;
      instance_type: String.t option ;
      kernel_id: String.t option ;
      key_name: String.t option ;
      monitoring: ScheduledInstancesMonitoring.t option ;
      network_interfaces: ScheduledInstancesNetworkInterfaceSet.t ;
      placement: ScheduledInstancesPlacement.t option ;
      ramdisk_id: String.t option ;
      security_group_ids: ScheduledInstancesSecurityGroupIdSet.t ;
      subnet_id: String.t option ;
      user_data: String.t option }
    let make ?(block_device_mappings= [])  ?ebs_optimized 
      ?iam_instance_profile  ~image_id  ?instance_type  ?kernel_id  ?key_name
       ?monitoring  ?(network_interfaces= [])  ?placement  ?ramdisk_id 
      ?(security_group_ids= [])  ?subnet_id  ?user_data  () =
      {
        block_device_mappings;
        ebs_optimized;
        iam_instance_profile;
        image_id;
        instance_type;
        kernel_id;
        key_name;
        monitoring;
        network_interfaces;
        placement;
        ramdisk_id;
        security_group_ids;
        subnet_id;
        user_data
      }
    let parse xml =
      Some
        {
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "BlockDeviceMapping" xml)
                  ScheduledInstancesBlockDeviceMappingSet.parse));
          ebs_optimized =
            (Util.option_bind (Xml.member "EbsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "IamInstanceProfile" xml)
               ScheduledInstancesIamInstanceProfile.parse);
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml) String.parse);
          kernel_id =
            (Util.option_bind (Xml.member "KernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "KeyName" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "Monitoring" xml)
               ScheduledInstancesMonitoring.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterface" xml)
                  ScheduledInstancesNetworkInterfaceSet.parse));
          placement =
            (Util.option_bind (Xml.member "Placement" xml)
               ScheduledInstancesPlacement.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "RamdiskId" xml) String.parse);
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  ScheduledInstancesSecurityGroupIdSet.parse));
          subnet_id =
            (Util.option_bind (Xml.member "SubnetId" xml) String.parse);
          user_data =
            (Util.option_bind (Xml.member "UserData" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (ScheduledInstancesSecurityGroupIdSet.to_query
                     v.security_group_ids)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f ->
                Query.Pair
                  ("Placement", (ScheduledInstancesPlacement.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterface",
                  (ScheduledInstancesNetworkInterfaceSet.to_query
                     v.network_interfaces)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair
                  ("Monitoring", (ScheduledInstancesMonitoring.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (ScheduledInstancesIamInstanceProfile.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (ScheduledInstancesBlockDeviceMappingSet.to_query
                     v.block_device_mappings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        (List.map
                           (fun x ->
                              Some
                                (Ezxmlm.make_tag "BlockDeviceMapping"
                                   ([],
                                     (ScheduledInstancesBlockDeviceMappingSet.to_xml
                                        [x])))) v.block_device_mappings))
                       @
                       [Util.option_map v.ebs_optimized
                          (fun f ->
                             Ezxmlm.make_tag "EbsOptimized"
                               ([], (Boolean.to_xml f)))])
                      @
                      [Util.option_map v.iam_instance_profile
                         (fun f ->
                            Ezxmlm.make_tag "IamInstanceProfile"
                              ([],
                                (ScheduledInstancesIamInstanceProfile.to_xml
                                   f)))])
                     @
                     [Some
                        (Ezxmlm.make_tag "ImageId"
                           ([], (String.to_xml v.image_id)))])
                    @
                    [Util.option_map v.instance_type
                       (fun f ->
                          Ezxmlm.make_tag "InstanceType"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.kernel_id
                      (fun f ->
                         Ezxmlm.make_tag "KernelId" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.key_name
                     (fun f ->
                        Ezxmlm.make_tag "KeyName" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.monitoring
                    (fun f ->
                       Ezxmlm.make_tag "Monitoring"
                         ([], (ScheduledInstancesMonitoring.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "NetworkInterface"
                           ([],
                             (ScheduledInstancesNetworkInterfaceSet.to_xml
                                [x])))) v.network_interfaces))
               @
               [Util.option_map v.placement
                  (fun f ->
                     Ezxmlm.make_tag "Placement"
                       ([], (ScheduledInstancesPlacement.to_xml f)))])
              @
              [Util.option_map v.ramdisk_id
                 (fun f ->
                    Ezxmlm.make_tag "RamdiskId" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "SecurityGroupId"
                        ([],
                          (ScheduledInstancesSecurityGroupIdSet.to_xml [x]))))
                v.security_group_ids))
            @
            [Util.option_map v.subnet_id
               (fun f -> Ezxmlm.make_tag "SubnetId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.user_data
              (fun f -> Ezxmlm.make_tag "UserData" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Some
             ("security_group_ids",
               (ScheduledInstancesSecurityGroupIdSet.to_json
                  v.security_group_ids));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (ScheduledInstancesPlacement.to_json f)));
           Some
             ("network_interfaces",
               (ScheduledInstancesNetworkInterfaceSet.to_json
                  v.network_interfaces));
           Util.option_map v.monitoring
             (fun f ->
                ("monitoring", (ScheduledInstancesMonitoring.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Some ("image_id", (String.to_json v.image_id));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (ScheduledInstancesIamInstanceProfile.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Some
             ("block_device_mappings",
               (ScheduledInstancesBlockDeviceMappingSet.to_json
                  v.block_device_mappings))])
    let of_json j =
      {
        block_device_mappings =
          (ScheduledInstancesBlockDeviceMappingSet.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             ScheduledInstancesIamInstanceProfile.of_json);
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             ScheduledInstancesMonitoring.of_json);
        network_interfaces =
          (ScheduledInstancesNetworkInterfaceSet.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        placement =
          (Util.option_map (Json.lookup j "placement")
             ScheduledInstancesPlacement.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        security_group_ids =
          (ScheduledInstancesSecurityGroupIdSet.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json)
      }
  end
module ExportImageTaskIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ExportImageTaskId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module NatGatewayList =
  struct
    type t = NatGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map NatGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NatGateway.to_query v
    let to_headers v = Headers.to_headers_list NatGateway.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (NatGateway.to_xml x))) v
    let to_json v = `List (List.map NatGateway.to_json v)
    let of_json j = Json.to_list NatGateway.of_json j
  end
module InstanceUsageSet =
  struct
    type t = InstanceUsage.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map InstanceUsage.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceUsage.to_query v
    let to_headers v = Headers.to_headers_list InstanceUsage.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InstanceUsage.to_xml x))) v
    let to_json v = `List (List.map InstanceUsage.to_json v)
    let of_json j = Json.to_list InstanceUsage.of_json j
  end
module DescribeFastSnapshotRestoreSuccessSet =
  struct
    type t = DescribeFastSnapshotRestoreSuccessItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DescribeFastSnapshotRestoreSuccessItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list DescribeFastSnapshotRestoreSuccessItem.to_query v
    let to_headers v =
      Headers.to_headers_list
        DescribeFastSnapshotRestoreSuccessItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (DescribeFastSnapshotRestoreSuccessItem.to_xml x))) v
    let to_json v =
      `List (List.map DescribeFastSnapshotRestoreSuccessItem.to_json v)
    let of_json j =
      Json.to_list DescribeFastSnapshotRestoreSuccessItem.of_json j
  end
module ReservedInstanceLimitPrice =
  struct
    type t =
      {
      amount: Double.t option ;
      currency_code: CurrencyCodeValues.t option }
    let make ?amount  ?currency_code  () = { amount; currency_code }
    let parse xml =
      Some
        {
          amount = (Util.option_bind (Xml.member "amount" xml) Double.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.currency_code
              (fun f ->
                 Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.amount
             (fun f -> Query.Pair ("Amount", (Double.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.amount
               (fun f -> Ezxmlm.make_tag "amount" ([], (Double.to_xml f)))])
           @
           [Util.option_map v.currency_code
              (fun f ->
                 Ezxmlm.make_tag "currencyCode"
                   ([], (CurrencyCodeValues.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.currency_code
              (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.amount (fun f -> ("amount", (Double.to_json f)))])
    let of_json j =
      {
        amount = (Util.option_map (Json.lookup j "amount") Double.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json)
      }
  end
module EgressOnlyInternetGatewayList =
  struct
    type t = EgressOnlyInternetGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map EgressOnlyInternetGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list EgressOnlyInternetGateway.to_query v
    let to_headers v =
      Headers.to_headers_list EgressOnlyInternetGateway.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (EgressOnlyInternetGateway.to_xml x))) v
    let to_json v = `List (List.map EgressOnlyInternetGateway.to_json v)
    let of_json j = Json.to_list EgressOnlyInternetGateway.of_json j
  end
module LoadPermissionModifications =
  struct
    type t =
      {
      add: LoadPermissionListRequest.t ;
      remove: LoadPermissionListRequest.t }
    let make ?(add= [])  ?(remove= [])  () = { add; remove }
    let parse xml =
      Some
        {
          add =
            (Util.of_option []
               (Util.option_bind (Xml.member "Add" xml)
                  LoadPermissionListRequest.parse));
          remove =
            (Util.of_option []
               (Util.option_bind (Xml.member "Remove" xml)
                  LoadPermissionListRequest.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Remove", (LoadPermissionListRequest.to_query v.remove)));
           Some
             (Query.Pair ("Add", (LoadPermissionListRequest.to_query v.add)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Add"
                       ([], (LoadPermissionListRequest.to_xml [x])))) v.add))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Remove"
                      ([], (LoadPermissionListRequest.to_xml [x])))) v.remove))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("remove", (LoadPermissionListRequest.to_json v.remove));
           Some ("add", (LoadPermissionListRequest.to_json v.add))])
    let of_json j =
      {
        add =
          (LoadPermissionListRequest.of_json
             (Util.of_option_exn (Json.lookup j "add")));
        remove =
          (LoadPermissionListRequest.of_json
             (Util.of_option_exn (Json.lookup j "remove")))
      }
  end
module DescribeCapacityReservationsRequest =
  struct
    type t =
      {
      capacity_reservation_ids: CapacityReservationIdSet.t ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      filters: FilterList.t ;
      dry_run: Boolean.t option }
    let make ?(capacity_reservation_ids= [])  ?next_token  ?max_results 
      ?(filters= [])  ?dry_run  () =
      { capacity_reservation_ids; next_token; max_results; filters; dry_run }
    let parse xml =
      Some
        {
          capacity_reservation_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "CapacityReservationId" xml)
                  CapacityReservationIdSet.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("CapacityReservationId",
                  (CapacityReservationIdSet.to_query
                     v.capacity_reservation_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "CapacityReservationId"
                          ([], (CapacityReservationIdSet.to_xml [x]))))
                  v.capacity_reservation_ids))
              @
              [Util.option_map v.next_token
                 (fun f ->
                    Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
               v.filters))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("capacity_reservation_ids",
               (CapacityReservationIdSet.to_json v.capacity_reservation_ids))])
    let of_json j =
      {
        capacity_reservation_ids =
          (CapacityReservationIdSet.of_json
             (Util.of_option_exn (Json.lookup j "capacity_reservation_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteNetworkAclRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      network_acl_id: String.t }
    let make ?dry_run  ~network_acl_id  () = { dry_run; network_acl_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_acl_id =
            (Xml.required "networkAclId"
               (Util.option_bind (Xml.member "networkAclId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkAclId", (String.to_query v.network_acl_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "networkAclId"
                 ([], (String.to_xml v.network_acl_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("network_acl_id", (String.to_json v.network_acl_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_acl_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_id")))
      }
  end
module CreateImageRequest =
  struct
    type t =
      {
      block_device_mappings: BlockDeviceMappingRequestList.t ;
      description: String.t option ;
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      name: String.t ;
      no_reboot: Boolean.t option }
    let make ?(block_device_mappings= [])  ?description  ?dry_run 
      ~instance_id  ~name  ?no_reboot  () =
      {
        block_device_mappings;
        description;
        dry_run;
        instance_id;
        name;
        no_reboot
      }
    let parse xml =
      Some
        {
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingRequestList.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          name =
            (Xml.required "name"
               (Util.option_bind (Xml.member "name" xml) String.parse));
          no_reboot =
            (Util.option_bind (Xml.member "noReboot" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.no_reboot
              (fun f -> Query.Pair ("NoReboot", (Boolean.to_query f)));
           Some (Query.Pair ("Name", (String.to_query v.name)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingRequestList.to_query
                     v.block_device_mappings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "blockDeviceMapping"
                           ([], (BlockDeviceMappingRequestList.to_xml [x]))))
                   v.block_device_mappings))
               @
               [Util.option_map v.description
                  (fun f ->
                     Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "instanceId"
                   ([], (String.to_xml v.instance_id)))])
            @ [Some (Ezxmlm.make_tag "name" ([], (String.to_xml v.name)))])
           @
           [Util.option_map v.no_reboot
              (fun f -> Ezxmlm.make_tag "noReboot" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.no_reboot
              (fun f -> ("no_reboot", (Boolean.to_json f)));
           Some ("name", (String.to_json v.name));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingRequestList.to_json v.block_device_mappings))])
    let of_json j =
      {
        block_device_mappings =
          (BlockDeviceMappingRequestList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        no_reboot =
          (Util.option_map (Json.lookup j "no_reboot") Boolean.of_json)
      }
  end
module CreateCapacityReservationRequest =
  struct
    type t =
      {
      client_token: String.t option ;
      instance_type: String.t ;
      instance_platform: CapacityReservationInstancePlatform.t ;
      availability_zone: String.t option ;
      availability_zone_id: String.t option ;
      tenancy: CapacityReservationTenancy.t option ;
      instance_count: Integer.t ;
      ebs_optimized: Boolean.t option ;
      ephemeral_storage: Boolean.t option ;
      end_date: DateTime.t option ;
      end_date_type: EndDateType.t option ;
      instance_match_criteria: InstanceMatchCriteria.t option ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ?client_token  ~instance_type  ~instance_platform 
      ?availability_zone  ?availability_zone_id  ?tenancy  ~instance_count 
      ?ebs_optimized  ?ephemeral_storage  ?end_date  ?end_date_type 
      ?instance_match_criteria  ?(tag_specifications= [])  ?dry_run  () =
      {
        client_token;
        instance_type;
        instance_platform;
        availability_zone;
        availability_zone_id;
        tenancy;
        instance_count;
        ebs_optimized;
        ephemeral_storage;
        end_date;
        end_date_type;
        instance_match_criteria;
        tag_specifications;
        dry_run
      }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          instance_type =
            (Xml.required "InstanceType"
               (Util.option_bind (Xml.member "InstanceType" xml) String.parse));
          instance_platform =
            (Xml.required "InstancePlatform"
               (Util.option_bind (Xml.member "InstancePlatform" xml)
                  CapacityReservationInstancePlatform.parse));
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          availability_zone_id =
            (Util.option_bind (Xml.member "AvailabilityZoneId" xml)
               String.parse);
          tenancy =
            (Util.option_bind (Xml.member "Tenancy" xml)
               CapacityReservationTenancy.parse);
          instance_count =
            (Xml.required "InstanceCount"
               (Util.option_bind (Xml.member "InstanceCount" xml)
                  Integer.parse));
          ebs_optimized =
            (Util.option_bind (Xml.member "EbsOptimized" xml) Boolean.parse);
          ephemeral_storage =
            (Util.option_bind (Xml.member "EphemeralStorage" xml)
               Boolean.parse);
          end_date =
            (Util.option_bind (Xml.member "EndDate" xml) DateTime.parse);
          end_date_type =
            (Util.option_bind (Xml.member "EndDateType" xml)
               EndDateType.parse);
          instance_match_criteria =
            (Util.option_bind (Xml.member "InstanceMatchCriteria" xml)
               InstanceMatchCriteria.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecifications" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecifications",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.instance_match_criteria
             (fun f ->
                Query.Pair
                  ("InstanceMatchCriteria",
                    (InstanceMatchCriteria.to_query f)));
           Util.option_map v.end_date_type
             (fun f -> Query.Pair ("EndDateType", (EndDateType.to_query f)));
           Util.option_map v.end_date
             (fun f -> Query.Pair ("EndDate", (DateTime.to_query f)));
           Util.option_map v.ephemeral_storage
             (fun f -> Query.Pair ("EphemeralStorage", (Boolean.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceCount", (Integer.to_query v.instance_count)));
           Util.option_map v.tenancy
             (fun f ->
                Query.Pair
                  ("Tenancy", (CapacityReservationTenancy.to_query f)));
           Util.option_map v.availability_zone_id
             (fun f -> Query.Pair ("AvailabilityZoneId", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Some
             (Query.Pair
                ("InstancePlatform",
                  (CapacityReservationInstancePlatform.to_query
                     v.instance_platform)));
           Some
             (Query.Pair ("InstanceType", (String.to_query v.instance_type)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        [Util.option_map v.client_token
                           (fun f ->
                              Ezxmlm.make_tag "ClientToken"
                                ([], (String.to_xml f)))])
                       @
                       [Some
                          (Ezxmlm.make_tag "InstanceType"
                             ([], (String.to_xml v.instance_type)))])
                      @
                      [Some
                         (Ezxmlm.make_tag "InstancePlatform"
                            ([],
                              (CapacityReservationInstancePlatform.to_xml
                                 v.instance_platform)))])
                     @
                     [Util.option_map v.availability_zone
                        (fun f ->
                           Ezxmlm.make_tag "AvailabilityZone"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.availability_zone_id
                       (fun f ->
                          Ezxmlm.make_tag "AvailabilityZoneId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.tenancy
                      (fun f ->
                         Ezxmlm.make_tag "Tenancy"
                           ([], (CapacityReservationTenancy.to_xml f)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "InstanceCount"
                        ([], (Integer.to_xml v.instance_count)))])
                 @
                 [Util.option_map v.ebs_optimized
                    (fun f ->
                       Ezxmlm.make_tag "EbsOptimized"
                         ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.ephemeral_storage
                   (fun f ->
                      Ezxmlm.make_tag "EphemeralStorage"
                        ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.end_date
                  (fun f ->
                     Ezxmlm.make_tag "EndDate" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.end_date_type
                 (fun f ->
                    Ezxmlm.make_tag "EndDateType"
                      ([], (EndDateType.to_xml f)))])
             @
             [Util.option_map v.instance_match_criteria
                (fun f ->
                   Ezxmlm.make_tag "InstanceMatchCriteria"
                     ([], (InstanceMatchCriteria.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "TagSpecifications"
                       ([], (TagSpecificationList.to_xml [x]))))
               v.tag_specifications))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.instance_match_criteria
             (fun f ->
                ("instance_match_criteria",
                  (InstanceMatchCriteria.to_json f)));
           Util.option_map v.end_date_type
             (fun f -> ("end_date_type", (EndDateType.to_json f)));
           Util.option_map v.end_date
             (fun f -> ("end_date", (DateTime.to_json f)));
           Util.option_map v.ephemeral_storage
             (fun f -> ("ephemeral_storage", (Boolean.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Some ("instance_count", (Integer.to_json v.instance_count));
           Util.option_map v.tenancy
             (fun f -> ("tenancy", (CapacityReservationTenancy.to_json f)));
           Util.option_map v.availability_zone_id
             (fun f -> ("availability_zone_id", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Some
             ("instance_platform",
               (CapacityReservationInstancePlatform.to_json
                  v.instance_platform));
           Some ("instance_type", (String.to_json v.instance_type));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        instance_type =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "instance_type")));
        instance_platform =
          (CapacityReservationInstancePlatform.of_json
             (Util.of_option_exn (Json.lookup j "instance_platform")));
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        availability_zone_id =
          (Util.option_map (Json.lookup j "availability_zone_id")
             String.of_json);
        tenancy =
          (Util.option_map (Json.lookup j "tenancy")
             CapacityReservationTenancy.of_json);
        instance_count =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "instance_count")));
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        ephemeral_storage =
          (Util.option_map (Json.lookup j "ephemeral_storage")
             Boolean.of_json);
        end_date =
          (Util.option_map (Json.lookup j "end_date") DateTime.of_json);
        end_date_type =
          (Util.option_map (Json.lookup j "end_date_type")
             EndDateType.of_json);
        instance_match_criteria =
          (Util.option_map (Json.lookup j "instance_match_criteria")
             InstanceMatchCriteria.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateTrafficMirrorFilterResult =
  struct
    type t =
      {
      traffic_mirror_filter: TrafficMirrorFilter.t option ;
      client_token: String.t option }
    let make ?traffic_mirror_filter  ?client_token  () =
      { traffic_mirror_filter; client_token }
    let parse xml =
      Some
        {
          traffic_mirror_filter =
            (Util.option_bind (Xml.member "trafficMirrorFilter" xml)
               TrafficMirrorFilter.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.traffic_mirror_filter
             (fun f ->
                Query.Pair
                  ("TrafficMirrorFilter", (TrafficMirrorFilter.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.traffic_mirror_filter
               (fun f ->
                  Ezxmlm.make_tag "trafficMirrorFilter"
                    ([], (TrafficMirrorFilter.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.traffic_mirror_filter
             (fun f ->
                ("traffic_mirror_filter", (TrafficMirrorFilter.to_json f)))])
    let of_json j =
      {
        traffic_mirror_filter =
          (Util.option_map (Json.lookup j "traffic_mirror_filter")
             TrafficMirrorFilter.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeTagsResult =
  struct
    type t = {
      next_token: String.t option ;
      tags: TagDescriptionList.t }
    let make ?next_token  ?(tags= [])  () = { next_token; tags }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml)
                  TagDescriptionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("TagSet", (TagDescriptionList.to_query v.tags)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "tagSet"
                      ([], (TagDescriptionList.to_xml [x])))) v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagDescriptionList.to_json v.tags));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        tags =
          (TagDescriptionList.of_json
             (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module DescribeDhcpOptionsResult =
  struct
    type t = {
      dhcp_options: DhcpOptionsList.t ;
      next_token: String.t option }
    let make ?(dhcp_options= [])  ?next_token  () =
      { dhcp_options; next_token }
    let parse xml =
      Some
        {
          dhcp_options =
            (Util.of_option []
               (Util.option_bind (Xml.member "dhcpOptionsSet" xml)
                  DhcpOptionsList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("DhcpOptionsSet", (DhcpOptionsList.to_query v.dhcp_options)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "dhcpOptionsSet"
                       ([], (DhcpOptionsList.to_xml [x])))) v.dhcp_options))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("dhcp_options", (DhcpOptionsList.to_json v.dhcp_options))])
    let of_json j =
      {
        dhcp_options =
          (DhcpOptionsList.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_options")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeVpnGatewaysResult =
  struct
    type t = {
      vpn_gateways: VpnGatewayList.t }
    let make ?(vpn_gateways= [])  () = { vpn_gateways }
    let parse xml =
      Some
        {
          vpn_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpnGatewaySet" xml)
                  VpnGatewayList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpnGatewaySet", (VpnGatewayList.to_query v.vpn_gateways)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "vpnGatewaySet"
                      ([], (VpnGatewayList.to_xml [x])))) v.vpn_gateways))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpn_gateways", (VpnGatewayList.to_json v.vpn_gateways))])
    let of_json j =
      {
        vpn_gateways =
          (VpnGatewayList.of_json
             (Util.of_option_exn (Json.lookup j "vpn_gateways")))
      }
  end
module GetTransitGatewayAttachmentPropagationsResult =
  struct
    type t =
      {
      transit_gateway_attachment_propagations:
        TransitGatewayAttachmentPropagationList.t ;
      next_token: String.t option }
    let make ?(transit_gateway_attachment_propagations= [])  ?next_token  ()
      = { transit_gateway_attachment_propagations; next_token }
    let parse xml =
      Some
        {
          transit_gateway_attachment_propagations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "transitGatewayAttachmentPropagations" xml)
                  TransitGatewayAttachmentPropagationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentPropagations",
                  (TransitGatewayAttachmentPropagationList.to_query
                     v.transit_gateway_attachment_propagations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "transitGatewayAttachmentPropagations"
                       ([],
                         (TransitGatewayAttachmentPropagationList.to_xml [x]))))
               v.transit_gateway_attachment_propagations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_attachment_propagations",
               (TransitGatewayAttachmentPropagationList.to_json
                  v.transit_gateway_attachment_propagations))])
    let of_json j =
      {
        transit_gateway_attachment_propagations =
          (TransitGatewayAttachmentPropagationList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_propagations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeCapacityReservationsResult =
  struct
    type t =
      {
      next_token: String.t option ;
      capacity_reservations: CapacityReservationSet.t }
    let make ?next_token  ?(capacity_reservations= [])  () =
      { next_token; capacity_reservations }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          capacity_reservations =
            (Util.of_option []
               (Util.option_bind (Xml.member "capacityReservationSet" xml)
                  CapacityReservationSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("CapacityReservationSet",
                   (CapacityReservationSet.to_query v.capacity_reservations)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "capacityReservationSet"
                      ([], (CapacityReservationSet.to_xml [x]))))
              v.capacity_reservations))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("capacity_reservations",
                (CapacityReservationSet.to_json v.capacity_reservations));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        capacity_reservations =
          (CapacityReservationSet.of_json
             (Util.of_option_exn (Json.lookup j "capacity_reservations")))
      }
  end
module DescribeElasticGpusRequest =
  struct
    type t =
      {
      elastic_gpu_ids: ElasticGpuIdSet.t ;
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(elastic_gpu_ids= [])  ?dry_run  ?(filters= [])  ?max_results 
      ?next_token  () =
      { elastic_gpu_ids; dry_run; filters; max_results; next_token }
    let parse xml =
      Some
        {
          elastic_gpu_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ElasticGpuId" xml)
                  ElasticGpuIdSet.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ElasticGpuId",
                  (ElasticGpuIdSet.to_query v.elastic_gpu_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "ElasticGpuId"
                          ([], (ElasticGpuIdSet.to_xml [x]))))
                  v.elastic_gpu_ids))
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("elastic_gpu_ids", (ElasticGpuIdSet.to_json v.elastic_gpu_ids))])
    let of_json j =
      {
        elastic_gpu_ids =
          (ElasticGpuIdSet.of_json
             (Util.of_option_exn (Json.lookup j "elastic_gpu_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteLocalGatewayRouteTableVpcAssociationRequest =
  struct
    type t =
      {
      local_gateway_route_table_vpc_association_id: String.t ;
      dry_run: Boolean.t option }
    let make ~local_gateway_route_table_vpc_association_id  ?dry_run  () =
      { local_gateway_route_table_vpc_association_id; dry_run }
    let parse xml =
      Some
        {
          local_gateway_route_table_vpc_association_id =
            (Xml.required "LocalGatewayRouteTableVpcAssociationId"
               (Util.option_bind
                  (Xml.member "LocalGatewayRouteTableVpcAssociationId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableVpcAssociationId",
                  (String.to_query
                     v.local_gateway_route_table_vpc_association_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "LocalGatewayRouteTableVpcAssociationId"
                  ([],
                    (String.to_xml
                       v.local_gateway_route_table_vpc_association_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("local_gateway_route_table_vpc_association_id",
               (String.to_json v.local_gateway_route_table_vpc_association_id))])
    let of_json j =
      {
        local_gateway_route_table_vpc_association_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_route_table_vpc_association_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AuthorizeSecurityGroupEgressRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_id: String.t ;
      ip_permissions: IpPermissionList.t ;
      cidr_ip: String.t option ;
      from_port: Integer.t option ;
      ip_protocol: String.t option ;
      to_port: Integer.t option ;
      source_security_group_name: String.t option ;
      source_security_group_owner_id: String.t option }
    let make ?dry_run  ~group_id  ?(ip_permissions= [])  ?cidr_ip  ?from_port
       ?ip_protocol  ?to_port  ?source_security_group_name 
      ?source_security_group_owner_id  () =
      {
        dry_run;
        group_id;
        ip_permissions;
        cidr_ip;
        from_port;
        ip_protocol;
        to_port;
        source_security_group_name;
        source_security_group_owner_id
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_id =
            (Xml.required "groupId"
               (Util.option_bind (Xml.member "groupId" xml) String.parse));
          ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipPermissions" xml)
                  IpPermissionList.parse));
          cidr_ip = (Util.option_bind (Xml.member "cidrIp" xml) String.parse);
          from_port =
            (Util.option_bind (Xml.member "fromPort" xml) Integer.parse);
          ip_protocol =
            (Util.option_bind (Xml.member "ipProtocol" xml) String.parse);
          to_port =
            (Util.option_bind (Xml.member "toPort" xml) Integer.parse);
          source_security_group_name =
            (Util.option_bind (Xml.member "sourceSecurityGroupName" xml)
               String.parse);
          source_security_group_owner_id =
            (Util.option_bind (Xml.member "sourceSecurityGroupOwnerId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.source_security_group_owner_id
              (fun f ->
                 Query.Pair
                   ("SourceSecurityGroupOwnerId", (String.to_query f)));
           Util.option_map v.source_security_group_name
             (fun f ->
                Query.Pair ("SourceSecurityGroupName", (String.to_query f)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.ip_protocol
             (fun f -> Query.Pair ("IpProtocol", (String.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)));
           Util.option_map v.cidr_ip
             (fun f -> Query.Pair ("CidrIp", (String.to_query f)));
           Some
             (Query.Pair
                ("IpPermissions",
                  (IpPermissionList.to_query v.ip_permissions)));
           Some (Query.Pair ("GroupId", (String.to_query v.group_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.dry_run
                      (fun f ->
                         Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "groupId"
                        ([], (String.to_xml v.group_id)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "ipPermissions"
                            ([], (IpPermissionList.to_xml [x]))))
                    v.ip_permissions))
                @
                [Util.option_map v.cidr_ip
                   (fun f -> Ezxmlm.make_tag "cidrIp" ([], (String.to_xml f)))])
               @
               [Util.option_map v.from_port
                  (fun f ->
                     Ezxmlm.make_tag "fromPort" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.ip_protocol
                 (fun f ->
                    Ezxmlm.make_tag "ipProtocol" ([], (String.to_xml f)))])
             @
             [Util.option_map v.to_port
                (fun f -> Ezxmlm.make_tag "toPort" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.source_security_group_name
               (fun f ->
                  Ezxmlm.make_tag "sourceSecurityGroupName"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.source_security_group_owner_id
              (fun f ->
                 Ezxmlm.make_tag "sourceSecurityGroupOwnerId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.source_security_group_owner_id
              (fun f ->
                 ("source_security_group_owner_id", (String.to_json f)));
           Util.option_map v.source_security_group_name
             (fun f -> ("source_security_group_name", (String.to_json f)));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.ip_protocol
             (fun f -> ("ip_protocol", (String.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)));
           Util.option_map v.cidr_ip
             (fun f -> ("cidr_ip", (String.to_json f)));
           Some
             ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Some ("group_id", (String.to_json v.group_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_id")));
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")));
        cidr_ip = (Util.option_map (Json.lookup j "cidr_ip") String.of_json);
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        ip_protocol =
          (Util.option_map (Json.lookup j "ip_protocol") String.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        source_security_group_name =
          (Util.option_map (Json.lookup j "source_security_group_name")
             String.of_json);
        source_security_group_owner_id =
          (Util.option_map (Json.lookup j "source_security_group_owner_id")
             String.of_json)
      }
  end
module DescribeReservedInstancesModificationsResult =
  struct
    type t =
      {
      next_token: String.t option ;
      reserved_instances_modifications: ReservedInstancesModificationList.t }
    let make ?next_token  ?(reserved_instances_modifications= [])  () =
      { next_token; reserved_instances_modifications }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          reserved_instances_modifications =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesModificationsSet" xml)
                  ReservedInstancesModificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesModificationsSet",
                   (ReservedInstancesModificationList.to_query
                      v.reserved_instances_modifications)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "reservedInstancesModificationsSet"
                      ([], (ReservedInstancesModificationList.to_xml [x]))))
              v.reserved_instances_modifications))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_modifications",
                (ReservedInstancesModificationList.to_json
                   v.reserved_instances_modifications));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        reserved_instances_modifications =
          (ReservedInstancesModificationList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_modifications")))
      }
  end
module CreateNetworkAclEntryRequest =
  struct
    type t =
      {
      cidr_block: String.t option ;
      dry_run: Boolean.t option ;
      egress: Boolean.t ;
      icmp_type_code: IcmpTypeCode.t option ;
      ipv6_cidr_block: String.t option ;
      network_acl_id: String.t ;
      port_range: PortRange.t option ;
      protocol: String.t ;
      rule_action: RuleAction.t ;
      rule_number: Integer.t }
    let make ?cidr_block  ?dry_run  ~egress  ?icmp_type_code 
      ?ipv6_cidr_block  ~network_acl_id  ?port_range  ~protocol  ~rule_action
       ~rule_number  () =
      {
        cidr_block;
        dry_run;
        egress;
        icmp_type_code;
        ipv6_cidr_block;
        network_acl_id;
        port_range;
        protocol;
        rule_action;
        rule_number
      }
    let parse xml =
      Some
        {
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          egress =
            (Xml.required "egress"
               (Util.option_bind (Xml.member "egress" xml) Boolean.parse));
          icmp_type_code =
            (Util.option_bind (Xml.member "Icmp" xml) IcmpTypeCode.parse);
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "ipv6CidrBlock" xml) String.parse);
          network_acl_id =
            (Xml.required "networkAclId"
               (Util.option_bind (Xml.member "networkAclId" xml) String.parse));
          port_range =
            (Util.option_bind (Xml.member "portRange" xml) PortRange.parse);
          protocol =
            (Xml.required "protocol"
               (Util.option_bind (Xml.member "protocol" xml) String.parse));
          rule_action =
            (Xml.required "ruleAction"
               (Util.option_bind (Xml.member "ruleAction" xml)
                  RuleAction.parse));
          rule_number =
            (Xml.required "ruleNumber"
               (Util.option_bind (Xml.member "ruleNumber" xml) Integer.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("RuleNumber", (Integer.to_query v.rule_number)));
           Some
             (Query.Pair ("RuleAction", (RuleAction.to_query v.rule_action)));
           Some (Query.Pair ("Protocol", (String.to_query v.protocol)));
           Util.option_map v.port_range
             (fun f -> Query.Pair ("PortRange", (PortRange.to_query f)));
           Some
             (Query.Pair ("NetworkAclId", (String.to_query v.network_acl_id)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Util.option_map v.icmp_type_code
             (fun f -> Query.Pair ("Icmp", (IcmpTypeCode.to_query f)));
           Some (Query.Pair ("Egress", (Boolean.to_query v.egress)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.cidr_block
                       (fun f ->
                          Ezxmlm.make_tag "cidrBlock" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.dry_run
                      (fun f ->
                         Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "egress"
                        ([], (Boolean.to_xml v.egress)))])
                 @
                 [Util.option_map v.icmp_type_code
                    (fun f ->
                       Ezxmlm.make_tag "Icmp" ([], (IcmpTypeCode.to_xml f)))])
                @
                [Util.option_map v.ipv6_cidr_block
                   (fun f ->
                      Ezxmlm.make_tag "ipv6CidrBlock" ([], (String.to_xml f)))])
               @
               [Some
                  (Ezxmlm.make_tag "networkAclId"
                     ([], (String.to_xml v.network_acl_id)))])
              @
              [Util.option_map v.port_range
                 (fun f ->
                    Ezxmlm.make_tag "portRange" ([], (PortRange.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "protocol" ([], (String.to_xml v.protocol)))])
            @
            [Some
               (Ezxmlm.make_tag "ruleAction"
                  ([], (RuleAction.to_xml v.rule_action)))])
           @
           [Some
              (Ezxmlm.make_tag "ruleNumber"
                 ([], (Integer.to_xml v.rule_number)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("rule_number", (Integer.to_json v.rule_number));
           Some ("rule_action", (RuleAction.to_json v.rule_action));
           Some ("protocol", (String.to_json v.protocol));
           Util.option_map v.port_range
             (fun f -> ("port_range", (PortRange.to_json f)));
           Some ("network_acl_id", (String.to_json v.network_acl_id));
           Util.option_map v.ipv6_cidr_block
             (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.icmp_type_code
             (fun f -> ("icmp_type_code", (IcmpTypeCode.to_json f)));
           Some ("egress", (Boolean.to_json v.egress));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)))])
    let of_json j =
      {
        cidr_block =
          (Util.option_map (Json.lookup j "cidr_block") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        egress =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "egress")));
        icmp_type_code =
          (Util.option_map (Json.lookup j "icmp_type_code")
             IcmpTypeCode.of_json);
        ipv6_cidr_block =
          (Util.option_map (Json.lookup j "ipv6_cidr_block") String.of_json);
        network_acl_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_id")));
        port_range =
          (Util.option_map (Json.lookup j "port_range") PortRange.of_json);
        protocol =
          (String.of_json (Util.of_option_exn (Json.lookup j "protocol")));
        rule_action =
          (RuleAction.of_json
             (Util.of_option_exn (Json.lookup j "rule_action")));
        rule_number =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "rule_number")))
      }
  end
module DescribeTagsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(filters= [])  ?max_results  ?next_token  () =
      { dry_run; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "maxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribePlacementGroupsResult =
  struct
    type t = {
      placement_groups: PlacementGroupList.t }
    let make ?(placement_groups= [])  () = { placement_groups }
    let parse xml =
      Some
        {
          placement_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "placementGroupSet" xml)
                  PlacementGroupList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PlacementGroupSet",
                   (PlacementGroupList.to_query v.placement_groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "placementGroupSet"
                      ([], (PlacementGroupList.to_xml [x]))))
              v.placement_groups))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("placement_groups",
                (PlacementGroupList.to_json v.placement_groups))])
    let of_json j =
      {
        placement_groups =
          (PlacementGroupList.of_json
             (Util.of_option_exn (Json.lookup j "placement_groups")))
      }
  end
module GetTransitGatewayRouteTablePropagationsResult =
  struct
    type t =
      {
      transit_gateway_route_table_propagations:
        TransitGatewayRouteTablePropagationList.t ;
      next_token: String.t option }
    let make ?(transit_gateway_route_table_propagations= [])  ?next_token  ()
      = { transit_gateway_route_table_propagations; next_token }
    let parse xml =
      Some
        {
          transit_gateway_route_table_propagations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "transitGatewayRouteTablePropagations" xml)
                  TransitGatewayRouteTablePropagationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTablePropagations",
                  (TransitGatewayRouteTablePropagationList.to_query
                     v.transit_gateway_route_table_propagations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "transitGatewayRouteTablePropagations"
                       ([],
                         (TransitGatewayRouteTablePropagationList.to_xml [x]))))
               v.transit_gateway_route_table_propagations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_route_table_propagations",
               (TransitGatewayRouteTablePropagationList.to_json
                  v.transit_gateway_route_table_propagations))])
    let of_json j =
      {
        transit_gateway_route_table_propagations =
          (TransitGatewayRouteTablePropagationList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_propagations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateSubnetRequest =
  struct
    type t =
      {
      availability_zone: String.t option ;
      availability_zone_id: String.t option ;
      cidr_block: String.t ;
      ipv6_cidr_block: String.t option ;
      outpost_arn: String.t option ;
      vpc_id: String.t ;
      dry_run: Boolean.t option }
    let make ?availability_zone  ?availability_zone_id  ~cidr_block 
      ?ipv6_cidr_block  ?outpost_arn  ~vpc_id  ?dry_run  () =
      {
        availability_zone;
        availability_zone_id;
        cidr_block;
        ipv6_cidr_block;
        outpost_arn;
        vpc_id;
        dry_run
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          availability_zone_id =
            (Util.option_bind (Xml.member "AvailabilityZoneId" xml)
               String.parse);
          cidr_block =
            (Xml.required "CidrBlock"
               (Util.option_bind (Xml.member "CidrBlock" xml) String.parse));
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "Ipv6CidrBlock" xml) String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "OutpostArn" xml) String.parse);
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Some (Query.Pair ("CidrBlock", (String.to_query v.cidr_block)));
           Util.option_map v.availability_zone_id
             (fun f -> Query.Pair ("AvailabilityZoneId", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.availability_zone
                    (fun f ->
                       Ezxmlm.make_tag "AvailabilityZone"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.availability_zone_id
                   (fun f ->
                      Ezxmlm.make_tag "AvailabilityZoneId"
                        ([], (String.to_xml f)))])
               @
               [Some
                  (Ezxmlm.make_tag "CidrBlock"
                     ([], (String.to_xml v.cidr_block)))])
              @
              [Util.option_map v.ipv6_cidr_block
                 (fun f ->
                    Ezxmlm.make_tag "Ipv6CidrBlock" ([], (String.to_xml f)))])
             @
             [Util.option_map v.outpost_arn
                (fun f ->
                   Ezxmlm.make_tag "OutpostArn" ([], (String.to_xml f)))])
            @ [Some (Ezxmlm.make_tag "VpcId" ([], (String.to_xml v.vpc_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Some ("cidr_block", (String.to_json v.cidr_block));
           Util.option_map v.availability_zone_id
             (fun f -> ("availability_zone_id", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        availability_zone_id =
          (Util.option_map (Json.lookup j "availability_zone_id")
             String.of_json);
        cidr_block =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_block")));
        ipv6_cidr_block =
          (Util.option_map (Json.lookup j "ipv6_cidr_block") String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeletePlacementGroupRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      group_name: String.t }
    let make ?dry_run  ~group_name  () = { dry_run; group_name }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_name =
            (Xml.required "groupName"
               (Util.option_bind (Xml.member "groupName" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("GroupName", (String.to_query v.group_name)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "groupName" ([], (String.to_xml v.group_name)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("group_name", (String.to_json v.group_name));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_name")))
      }
  end
module DescribeKeyPairsResult =
  struct
    type t = {
      key_pairs: KeyPairList.t }
    let make ?(key_pairs= [])  () = { key_pairs }
    let parse xml =
      Some
        {
          key_pairs =
            (Util.of_option []
               (Util.option_bind (Xml.member "keySet" xml) KeyPairList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("KeySet", (KeyPairList.to_query v.key_pairs)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "keySet" ([], (KeyPairList.to_xml [x]))))
              v.key_pairs))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("key_pairs", (KeyPairList.to_json v.key_pairs))])
    let of_json j =
      {
        key_pairs =
          (KeyPairList.of_json
             (Util.of_option_exn (Json.lookup j "key_pairs")))
      }
  end
module CreateLaunchTemplateResult =
  struct
    type t = {
      launch_template: LaunchTemplate.t option }
    let make ?launch_template  () = { launch_template }
    let parse xml =
      Some
        {
          launch_template =
            (Util.option_bind (Xml.member "launchTemplate" xml)
               LaunchTemplate.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template
              (fun f ->
                 Query.Pair ("LaunchTemplate", (LaunchTemplate.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.launch_template
              (fun f ->
                 Ezxmlm.make_tag "launchTemplate"
                   ([], (LaunchTemplate.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template
              (fun f -> ("launch_template", (LaunchTemplate.to_json f)))])
    let of_json j =
      {
        launch_template =
          (Util.option_map (Json.lookup j "launch_template")
             LaunchTemplate.of_json)
      }
  end
module DescribeFleetHistoryResult =
  struct
    type t =
      {
      history_records: HistoryRecordSet.t ;
      last_evaluated_time: DateTime.t option ;
      next_token: String.t option ;
      fleet_id: String.t option ;
      start_time: DateTime.t option }
    let make ?(history_records= [])  ?last_evaluated_time  ?next_token 
      ?fleet_id  ?start_time  () =
      {
        history_records;
        last_evaluated_time;
        next_token;
        fleet_id;
        start_time
      }
    let parse xml =
      Some
        {
          history_records =
            (Util.of_option []
               (Util.option_bind (Xml.member "historyRecordSet" xml)
                  HistoryRecordSet.parse));
          last_evaluated_time =
            (Util.option_bind (Xml.member "lastEvaluatedTime" xml)
               DateTime.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse);
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.start_time
              (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Util.option_map v.fleet_id
             (fun f -> Query.Pair ("FleetId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.last_evaluated_time
             (fun f ->
                Query.Pair ("LastEvaluatedTime", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("HistoryRecordSet",
                  (HistoryRecordSet.to_query v.history_records)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "historyRecordSet"
                          ([], (HistoryRecordSet.to_xml [x]))))
                  v.history_records))
              @
              [Util.option_map v.last_evaluated_time
                 (fun f ->
                    Ezxmlm.make_tag "lastEvaluatedTime"
                      ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
            @
            [Util.option_map v.fleet_id
               (fun f -> Ezxmlm.make_tag "fleetId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.start_time
              (fun f -> Ezxmlm.make_tag "startTime" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.start_time
              (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.fleet_id
             (fun f -> ("fleet_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.last_evaluated_time
             (fun f -> ("last_evaluated_time", (DateTime.to_json f)));
           Some
             ("history_records",
               (HistoryRecordSet.to_json v.history_records))])
    let of_json j =
      {
        history_records =
          (HistoryRecordSet.of_json
             (Util.of_option_exn (Json.lookup j "history_records")));
        last_evaluated_time =
          (Util.option_map (Json.lookup j "last_evaluated_time")
             DateTime.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        fleet_id =
          (Util.option_map (Json.lookup j "fleet_id") String.of_json);
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json)
      }
  end
module DescribeHostReservationsResult =
  struct
    type t =
      {
      host_reservation_set: HostReservationSet.t ;
      next_token: String.t option }
    let make ?(host_reservation_set= [])  ?next_token  () =
      { host_reservation_set; next_token }
    let parse xml =
      Some
        {
          host_reservation_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostReservationSet" xml)
                  HostReservationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("HostReservationSet",
                  (HostReservationSet.to_query v.host_reservation_set)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "hostReservationSet"
                       ([], (HostReservationSet.to_xml [x]))))
               v.host_reservation_set))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("host_reservation_set",
               (HostReservationSet.to_json v.host_reservation_set))])
    let of_json j =
      {
        host_reservation_set =
          (HostReservationSet.of_json
             (Util.of_option_exn (Json.lookup j "host_reservation_set")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyImageAttributeRequest =
  struct
    type t =
      {
      attribute: String.t option ;
      description: AttributeValue.t option ;
      image_id: String.t ;
      launch_permission: LaunchPermissionModifications.t option ;
      operation_type: OperationType.t option ;
      product_codes: ProductCodeStringList.t ;
      user_groups: UserGroupStringList.t ;
      user_ids: UserIdStringList.t ;
      value: String.t option ;
      dry_run: Boolean.t option }
    let make ?attribute  ?description  ~image_id  ?launch_permission 
      ?operation_type  ?(product_codes= [])  ?(user_groups= [])  ?(user_ids=
      [])  ?value  ?dry_run  () =
      {
        attribute;
        description;
        image_id;
        launch_permission;
        operation_type;
        product_codes;
        user_groups;
        user_ids;
        value;
        dry_run
      }
    let parse xml =
      Some
        {
          attribute =
            (Util.option_bind (Xml.member "Attribute" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml)
               AttributeValue.parse);
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          launch_permission =
            (Util.option_bind (Xml.member "LaunchPermission" xml)
               LaunchPermissionModifications.parse);
          operation_type =
            (Util.option_bind (Xml.member "OperationType" xml)
               OperationType.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "ProductCode" xml)
                  ProductCodeStringList.parse));
          user_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "UserGroup" xml)
                  UserGroupStringList.parse));
          user_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "UserId" xml)
                  UserIdStringList.parse));
          value = (Util.option_bind (Xml.member "Value" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.value
             (fun f -> Query.Pair ("Value", (String.to_query f)));
           Some
             (Query.Pair ("UserId", (UserIdStringList.to_query v.user_ids)));
           Some
             (Query.Pair
                ("UserGroup", (UserGroupStringList.to_query v.user_groups)));
           Some
             (Query.Pair
                ("ProductCode",
                  (ProductCodeStringList.to_query v.product_codes)));
           Util.option_map v.operation_type
             (fun f ->
                Query.Pair ("OperationType", (OperationType.to_query f)));
           Util.option_map v.launch_permission
             (fun f ->
                Query.Pair
                  ("LaunchPermission",
                    (LaunchPermissionModifications.to_query f)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Util.option_map v.description
             (fun f ->
                Query.Pair ("Description", (AttributeValue.to_query f)));
           Util.option_map v.attribute
             (fun f -> Query.Pair ("Attribute", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.attribute
                       (fun f ->
                          Ezxmlm.make_tag "Attribute" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.description
                      (fun f ->
                         Ezxmlm.make_tag "Description"
                           ([], (AttributeValue.to_xml f)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "ImageId"
                        ([], (String.to_xml v.image_id)))])
                 @
                 [Util.option_map v.launch_permission
                    (fun f ->
                       Ezxmlm.make_tag "LaunchPermission"
                         ([], (LaunchPermissionModifications.to_xml f)))])
                @
                [Util.option_map v.operation_type
                   (fun f ->
                      Ezxmlm.make_tag "OperationType"
                        ([], (OperationType.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "ProductCode"
                          ([], (ProductCodeStringList.to_xml [x]))))
                  v.product_codes))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "UserGroup"
                         ([], (UserGroupStringList.to_xml [x]))))
                 v.user_groups))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "UserId"
                        ([], (UserIdStringList.to_xml [x])))) v.user_ids))
            @
            [Util.option_map v.value
               (fun f -> Ezxmlm.make_tag "Value" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.value (fun f -> ("value", (String.to_json f)));
           Some ("user_ids", (UserIdStringList.to_json v.user_ids));
           Some ("user_groups", (UserGroupStringList.to_json v.user_groups));
           Some
             ("product_codes",
               (ProductCodeStringList.to_json v.product_codes));
           Util.option_map v.operation_type
             (fun f -> ("operation_type", (OperationType.to_json f)));
           Util.option_map v.launch_permission
             (fun f ->
                ("launch_permission",
                  (LaunchPermissionModifications.to_json f)));
           Some ("image_id", (String.to_json v.image_id));
           Util.option_map v.description
             (fun f -> ("description", (AttributeValue.to_json f)));
           Util.option_map v.attribute
             (fun f -> ("attribute", (String.to_json f)))])
    let of_json j =
      {
        attribute =
          (Util.option_map (Json.lookup j "attribute") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description")
             AttributeValue.of_json);
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        launch_permission =
          (Util.option_map (Json.lookup j "launch_permission")
             LaunchPermissionModifications.of_json);
        operation_type =
          (Util.option_map (Json.lookup j "operation_type")
             OperationType.of_json);
        product_codes =
          (ProductCodeStringList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        user_groups =
          (UserGroupStringList.of_json
             (Util.of_option_exn (Json.lookup j "user_groups")));
        user_ids =
          (UserIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "user_ids")));
        value = (Util.option_map (Json.lookup j "value") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeInstanceAttributeRequest =
  struct
    type t =
      {
      attribute: InstanceAttributeName.t ;
      dry_run: Boolean.t option ;
      instance_id: String.t }
    let make ~attribute  ?dry_run  ~instance_id  () =
      { attribute; dry_run; instance_id }
    let parse xml =
      Some
        {
          attribute =
            (Xml.required "attribute"
               (Util.option_bind (Xml.member "attribute" xml)
                  InstanceAttributeName.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("Attribute", (InstanceAttributeName.to_query v.attribute)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "attribute"
                   ([], (InstanceAttributeName.to_xml v.attribute)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "instanceId"
                 ([], (String.to_xml v.instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("attribute", (InstanceAttributeName.to_json v.attribute))])
    let of_json j =
      {
        attribute =
          (InstanceAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")))
      }
  end
module DeprovisionByoipCidrRequest =
  struct
    type t = {
      cidr: String.t ;
      dry_run: Boolean.t option }
    let make ~cidr  ?dry_run  () = { cidr; dry_run }
    let parse xml =
      Some
        {
          cidr =
            (Xml.required "Cidr"
               (Util.option_bind (Xml.member "Cidr" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Cidr", (String.to_query v.cidr)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Cidr" ([], (String.to_xml v.cidr)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("cidr", (String.to_json v.cidr))])
    let of_json j =
      {
        cidr = (String.of_json (Util.of_option_exn (Json.lookup j "cidr")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ResetNetworkInterfaceAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      network_interface_id: String.t ;
      source_dest_check: String.t option }
    let make ?dry_run  ~network_interface_id  ?source_dest_check  () =
      { dry_run; network_interface_id; source_dest_check }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse));
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.source_dest_check
              (fun f -> Query.Pair ("SourceDestCheck", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "networkInterfaceId"
                  ([], (String.to_xml v.network_interface_id)))])
           @
           [Util.option_map v.source_dest_check
              (fun f ->
                 Ezxmlm.make_tag "sourceDestCheck" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.source_dest_check
              (fun f -> ("source_dest_check", (String.to_json f)));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check") String.of_json)
      }
  end
module ReleaseHostsRequest =
  struct
    type t = {
      host_ids: RequestHostIdList.t }
    let make ~host_ids  () = { host_ids }
    let parse xml =
      Some
        {
          host_ids =
            (Xml.required "hostId"
               (Util.option_bind (Xml.member "hostId" xml)
                  RequestHostIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("HostId", (RequestHostIdList.to_query v.host_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "hostId"
                      ([], (RequestHostIdList.to_xml [x])))) v.host_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("host_ids", (RequestHostIdList.to_json v.host_ids))])
    let of_json j =
      {
        host_ids =
          (RequestHostIdList.of_json
             (Util.of_option_exn (Json.lookup j "host_ids")))
      }
  end
module CreateTransitGatewayVpcAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_id: String.t ;
      vpc_id: String.t ;
      subnet_ids: ValueStringList.t ;
      options: CreateTransitGatewayVpcAttachmentRequestOptions.t option ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_id  ~vpc_id  ~subnet_ids  ?options 
      ?(tag_specifications= [])  ?dry_run  () =
      {
        transit_gateway_id;
        vpc_id;
        subnet_ids;
        options;
        tag_specifications;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Xml.required "TransitGatewayId"
               (Util.option_bind (Xml.member "TransitGatewayId" xml)
                  String.parse));
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          subnet_ids =
            (Xml.required "SubnetIds"
               (Util.option_bind (Xml.member "SubnetIds" xml)
                  ValueStringList.parse));
          options =
            (Util.option_bind (Xml.member "Options" xml)
               CreateTransitGatewayVpcAttachmentRequestOptions.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecifications" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecifications",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.options
             (fun f ->
                Query.Pair
                  ("Options",
                    (CreateTransitGatewayVpcAttachmentRequestOptions.to_query
                       f)));
           Some
             (Query.Pair
                ("SubnetIds", (ValueStringList.to_query v.subnet_ids)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("TransitGatewayId", (String.to_query v.transit_gateway_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Some
                   (Ezxmlm.make_tag "TransitGatewayId"
                      ([], (String.to_xml v.transit_gateway_id)))])
               @
               [Some (Ezxmlm.make_tag "VpcId" ([], (String.to_xml v.vpc_id)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "SubnetIds"
                         ([], (ValueStringList.to_xml [x])))) v.subnet_ids))
             @
             [Util.option_map v.options
                (fun f ->
                   Ezxmlm.make_tag "Options"
                     ([],
                       (CreateTransitGatewayVpcAttachmentRequestOptions.to_xml
                          f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "TagSpecifications"
                       ([], (TagSpecificationList.to_xml [x]))))
               v.tag_specifications))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.options
             (fun f ->
                ("options",
                  (CreateTransitGatewayVpcAttachmentRequestOptions.to_json f)));
           Some ("subnet_ids", (ValueStringList.to_json v.subnet_ids));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("transit_gateway_id", (String.to_json v.transit_gateway_id))])
    let of_json j =
      {
        transit_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "transit_gateway_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        subnet_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "subnet_ids")));
        options =
          (Util.option_map (Json.lookup j "options")
             CreateTransitGatewayVpcAttachmentRequestOptions.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeLocalGatewaysRequest =
  struct
    type t =
      {
      local_gateway_ids: LocalGatewayIdSet.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(local_gateway_ids= [])  ?(filters= [])  ?max_results 
      ?next_token  ?dry_run  () =
      { local_gateway_ids; filters; max_results; next_token; dry_run }
    let parse xml =
      Some
        {
          local_gateway_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "LocalGatewayId" xml)
                  LocalGatewayIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("LocalGatewayId",
                  (LocalGatewayIdSet.to_query v.local_gateway_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "LocalGatewayId"
                          ([], (LocalGatewayIdSet.to_xml [x]))))
                  v.local_gateway_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("local_gateway_ids",
               (LocalGatewayIdSet.to_json v.local_gateway_ids))])
    let of_json j =
      {
        local_gateway_ids =
          (LocalGatewayIdSet.of_json
             (Util.of_option_exn (Json.lookup j "local_gateway_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyReservedInstancesRequest =
  struct
    type t =
      {
      reserved_instances_ids: ReservedInstancesIdStringList.t ;
      client_token: String.t option ;
      target_configurations: ReservedInstancesConfigurationList.t }
    let make ~reserved_instances_ids  ?client_token  ~target_configurations 
      () = { reserved_instances_ids; client_token; target_configurations }
    let parse xml =
      Some
        {
          reserved_instances_ids =
            (Xml.required "ReservedInstancesId"
               (Util.option_bind (Xml.member "ReservedInstancesId" xml)
                  ReservedInstancesIdStringList.parse));
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          target_configurations =
            (Xml.required "ReservedInstancesConfigurationSetItemType"
               (Util.option_bind
                  (Xml.member "ReservedInstancesConfigurationSetItemType" xml)
                  ReservedInstancesConfigurationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesConfigurationSetItemType",
                   (ReservedInstancesConfigurationList.to_query
                      v.target_configurations)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesId",
                  (ReservedInstancesIdStringList.to_query
                     v.reserved_instances_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "ReservedInstancesId"
                        ([], (ReservedInstancesIdStringList.to_xml [x]))))
                v.reserved_instances_ids))
            @
            [Util.option_map v.client_token
               (fun f ->
                  Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag
                      "ReservedInstancesConfigurationSetItemType"
                      ([], (ReservedInstancesConfigurationList.to_xml [x]))))
              v.target_configurations))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("target_configurations",
                (ReservedInstancesConfigurationList.to_json
                   v.target_configurations));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some
             ("reserved_instances_ids",
               (ReservedInstancesIdStringList.to_json
                  v.reserved_instances_ids))])
    let of_json j =
      {
        reserved_instances_ids =
          (ReservedInstancesIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances_ids")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        target_configurations =
          (ReservedInstancesConfigurationList.of_json
             (Util.of_option_exn (Json.lookup j "target_configurations")))
      }
  end
module DescribeVpcEndpointConnectionsResult =
  struct
    type t =
      {
      vpc_endpoint_connections: VpcEndpointConnectionSet.t ;
      next_token: String.t option }
    let make ?(vpc_endpoint_connections= [])  ?next_token  () =
      { vpc_endpoint_connections; next_token }
    let parse xml =
      Some
        {
          vpc_endpoint_connections =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcEndpointConnectionSet" xml)
                  VpcEndpointConnectionSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("VpcEndpointConnectionSet",
                  (VpcEndpointConnectionSet.to_query
                     v.vpc_endpoint_connections)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "vpcEndpointConnectionSet"
                       ([], (VpcEndpointConnectionSet.to_xml [x]))))
               v.vpc_endpoint_connections))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("vpc_endpoint_connections",
               (VpcEndpointConnectionSet.to_json v.vpc_endpoint_connections))])
    let of_json j =
      {
        vpc_endpoint_connections =
          (VpcEndpointConnectionSet.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoint_connections")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module AssociateRouteTableRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      route_table_id: String.t ;
      subnet_id: String.t option ;
      gateway_id: String.t option }
    let make ?dry_run  ~route_table_id  ?subnet_id  ?gateway_id  () =
      { dry_run; route_table_id; subnet_id; gateway_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse));
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          gateway_id =
            (Util.option_bind (Xml.member "GatewayId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.gateway_id
              (fun f -> Query.Pair ("GatewayId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Some
             (Query.Pair ("RouteTableId", (String.to_query v.route_table_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "routeTableId"
                   ([], (String.to_xml v.route_table_id)))])
            @
            [Util.option_map v.subnet_id
               (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.gateway_id
              (fun f -> Ezxmlm.make_tag "GatewayId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.gateway_id
              (fun f -> ("gateway_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Some ("route_table_id", (String.to_json v.route_table_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")));
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        gateway_id =
          (Util.option_map (Json.lookup j "gateway_id") String.of_json)
      }
  end
module CreateLocalGatewayRouteTableVpcAssociationRequest =
  struct
    type t =
      {
      local_gateway_route_table_id: String.t ;
      vpc_id: String.t ;
      dry_run: Boolean.t option }
    let make ~local_gateway_route_table_id  ~vpc_id  ?dry_run  () =
      { local_gateway_route_table_id; vpc_id; dry_run }
    let parse xml =
      Some
        {
          local_gateway_route_table_id =
            (Xml.required "LocalGatewayRouteTableId"
               (Util.option_bind (Xml.member "LocalGatewayRouteTableId" xml)
                  String.parse));
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableId",
                  (String.to_query v.local_gateway_route_table_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "LocalGatewayRouteTableId"
                   ([], (String.to_xml v.local_gateway_route_table_id)))])
            @ [Some (Ezxmlm.make_tag "VpcId" ([], (String.to_xml v.vpc_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some
             ("local_gateway_route_table_id",
               (String.to_json v.local_gateway_route_table_id))])
    let of_json j =
      {
        local_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_route_table_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AssociateAddressResult =
  struct
    type t = {
      association_id: String.t option }
    let make ?association_id  () = { association_id }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association_id
              (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.association_id
              (fun f ->
                 Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_id
              (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json)
      }
  end
module CreateCustomerGatewayRequest =
  struct
    type t =
      {
      bgp_asn: Integer.t ;
      public_ip: String.t option ;
      certificate_arn: String.t option ;
      type_: GatewayType.t ;
      device_name: String.t option ;
      dry_run: Boolean.t option }
    let make ~bgp_asn  ?public_ip  ?certificate_arn  ~type_  ?device_name 
      ?dry_run  () =
      { bgp_asn; public_ip; certificate_arn; type_; device_name; dry_run }
    let parse xml =
      Some
        {
          bgp_asn =
            (Xml.required "BgpAsn"
               (Util.option_bind (Xml.member "BgpAsn" xml) Integer.parse));
          public_ip =
            (Util.option_bind (Xml.member "IpAddress" xml) String.parse);
          certificate_arn =
            (Util.option_bind (Xml.member "CertificateArn" xml) String.parse);
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) GatewayType.parse));
          device_name =
            (Util.option_bind (Xml.member "DeviceName" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)));
           Some (Query.Pair ("Type", (GatewayType.to_query v.type_)));
           Util.option_map v.certificate_arn
             (fun f -> Query.Pair ("CertificateArn", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("IpAddress", (String.to_query f)));
           Some (Query.Pair ("BgpAsn", (Integer.to_query v.bgp_asn)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Some
                   (Ezxmlm.make_tag "BgpAsn" ([], (Integer.to_xml v.bgp_asn)))])
               @
               [Util.option_map v.public_ip
                  (fun f ->
                     Ezxmlm.make_tag "IpAddress" ([], (String.to_xml f)))])
              @
              [Util.option_map v.certificate_arn
                 (fun f ->
                    Ezxmlm.make_tag "CertificateArn" ([], (String.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "Type" ([], (GatewayType.to_xml v.type_)))])
            @
            [Util.option_map v.device_name
               (fun f -> Ezxmlm.make_tag "DeviceName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)));
           Some ("type_", (GatewayType.to_json v.type_));
           Util.option_map v.certificate_arn
             (fun f -> ("certificate_arn", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)));
           Some ("bgp_asn", (Integer.to_json v.bgp_asn))])
    let of_json j =
      {
        bgp_asn =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "bgp_asn")));
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        certificate_arn =
          (Util.option_map (Json.lookup j "certificate_arn") String.of_json);
        type_ =
          (GatewayType.of_json (Util.of_option_exn (Json.lookup j "type_")));
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeVpcEndpointConnectionNotificationsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      connection_notification_id: String.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?connection_notification_id  ?(filters= []) 
      ?max_results  ?next_token  () =
      { dry_run; connection_notification_id; filters; max_results; next_token
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          connection_notification_id =
            (Util.option_bind (Xml.member "ConnectionNotificationId" xml)
               String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.connection_notification_id
             (fun f ->
                Query.Pair ("ConnectionNotificationId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.connection_notification_id
                 (fun f ->
                    Ezxmlm.make_tag "ConnectionNotificationId"
                      ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.connection_notification_id
             (fun f -> ("connection_notification_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        connection_notification_id =
          (Util.option_map (Json.lookup j "connection_notification_id")
             String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeSecurityGroupsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      group_ids: GroupIdStringList.t ;
      group_names: GroupNameStringList.t ;
      dry_run: Boolean.t option ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?(group_ids= [])  ?(group_names= [])  ?dry_run 
      ?next_token  ?max_results  () =
      { filters; group_ids; group_names; dry_run; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupId" xml)
                  GroupIdStringList.parse));
          group_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupName" xml)
                  GroupNameStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("GroupName", (GroupNameStringList.to_query v.group_names)));
           Some
             (Query.Pair
                ("GroupId", (GroupIdStringList.to_query v.group_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "Filter"
                           ([], (FilterList.to_xml [x])))) v.filters))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "GroupId"
                          ([], (GroupIdStringList.to_xml [x])))) v.group_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "GroupName"
                         ([], (GroupNameStringList.to_xml [x]))))
                 v.group_names))
             @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("group_names", (GroupNameStringList.to_json v.group_names));
           Some ("group_ids", (GroupIdStringList.to_json v.group_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        group_ids =
          (GroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_ids")));
        group_names =
          (GroupNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_names")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DescribeExportImageTasksResult =
  struct
    type t =
      {
      export_image_tasks: ExportImageTaskList.t ;
      next_token: String.t option }
    let make ?(export_image_tasks= [])  ?next_token  () =
      { export_image_tasks; next_token }
    let parse xml =
      Some
        {
          export_image_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "exportImageTaskSet" xml)
                  ExportImageTaskList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ExportImageTaskSet",
                  (ExportImageTaskList.to_query v.export_image_tasks)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "exportImageTaskSet"
                       ([], (ExportImageTaskList.to_xml [x]))))
               v.export_image_tasks))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("export_image_tasks",
               (ExportImageTaskList.to_json v.export_image_tasks))])
    let of_json j =
      {
        export_image_tasks =
          (ExportImageTaskList.of_json
             (Util.of_option_exn (Json.lookup j "export_image_tasks")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ExportImageRequest =
  struct
    type t =
      {
      client_token: String.t option ;
      description: String.t option ;
      disk_image_format: DiskImageFormat.t ;
      dry_run: Boolean.t option ;
      image_id: String.t ;
      s3_export_location: ExportTaskS3LocationRequest.t ;
      role_name: String.t option }
    let make ?client_token  ?description  ~disk_image_format  ?dry_run 
      ~image_id  ~s3_export_location  ?role_name  () =
      {
        client_token;
        description;
        disk_image_format;
        dry_run;
        image_id;
        s3_export_location;
        role_name
      }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          disk_image_format =
            (Xml.required "DiskImageFormat"
               (Util.option_bind (Xml.member "DiskImageFormat" xml)
                  DiskImageFormat.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          s3_export_location =
            (Xml.required "S3ExportLocation"
               (Util.option_bind (Xml.member "S3ExportLocation" xml)
                  ExportTaskS3LocationRequest.parse));
          role_name =
            (Util.option_bind (Xml.member "RoleName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.role_name
              (fun f -> Query.Pair ("RoleName", (String.to_query f)));
           Some
             (Query.Pair
                ("S3ExportLocation",
                  (ExportTaskS3LocationRequest.to_query v.s3_export_location)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("DiskImageFormat",
                  (DiskImageFormat.to_query v.disk_image_format)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.client_token
                    (fun f ->
                       Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
                @
                [Util.option_map v.description
                   (fun f ->
                      Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
               @
               [Some
                  (Ezxmlm.make_tag "DiskImageFormat"
                     ([], (DiskImageFormat.to_xml v.disk_image_format)))])
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "ImageId" ([], (String.to_xml v.image_id)))])
            @
            [Some
               (Ezxmlm.make_tag "S3ExportLocation"
                  ([],
                    (ExportTaskS3LocationRequest.to_xml v.s3_export_location)))])
           @
           [Util.option_map v.role_name
              (fun f -> Ezxmlm.make_tag "RoleName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.role_name
              (fun f -> ("role_name", (String.to_json f)));
           Some
             ("s3_export_location",
               (ExportTaskS3LocationRequest.to_json v.s3_export_location));
           Some ("image_id", (String.to_json v.image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("disk_image_format",
               (DiskImageFormat.to_json v.disk_image_format));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        disk_image_format =
          (DiskImageFormat.of_json
             (Util.of_option_exn (Json.lookup j "disk_image_format")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        s3_export_location =
          (ExportTaskS3LocationRequest.of_json
             (Util.of_option_exn (Json.lookup j "s3_export_location")));
        role_name =
          (Util.option_map (Json.lookup j "role_name") String.of_json)
      }
  end
module RequestSpotInstancesRequest =
  struct
    type t =
      {
      availability_zone_group: String.t option ;
      block_duration_minutes: Integer.t option ;
      client_token: String.t option ;
      dry_run: Boolean.t option ;
      instance_count: Integer.t option ;
      launch_group: String.t option ;
      launch_specification: RequestSpotLaunchSpecification.t option ;
      spot_price: String.t option ;
      type_: SpotInstanceType.t option ;
      valid_from: DateTime.t option ;
      valid_until: DateTime.t option ;
      instance_interruption_behavior: InstanceInterruptionBehavior.t option }
    let make ?availability_zone_group  ?block_duration_minutes  ?client_token
       ?dry_run  ?instance_count  ?launch_group  ?launch_specification 
      ?spot_price  ?type_  ?valid_from  ?valid_until 
      ?instance_interruption_behavior  () =
      {
        availability_zone_group;
        block_duration_minutes;
        client_token;
        dry_run;
        instance_count;
        launch_group;
        launch_specification;
        spot_price;
        type_;
        valid_from;
        valid_until;
        instance_interruption_behavior
      }
    let parse xml =
      Some
        {
          availability_zone_group =
            (Util.option_bind (Xml.member "availabilityZoneGroup" xml)
               String.parse);
          block_duration_minutes =
            (Util.option_bind (Xml.member "blockDurationMinutes" xml)
               Integer.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          launch_group =
            (Util.option_bind (Xml.member "launchGroup" xml) String.parse);
          launch_specification =
            (Util.option_bind (Xml.member "LaunchSpecification" xml)
               RequestSpotLaunchSpecification.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          type_ =
            (Util.option_bind (Xml.member "type" xml) SpotInstanceType.parse);
          valid_from =
            (Util.option_bind (Xml.member "validFrom" xml) DateTime.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "InstanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Query.Pair
                   ("InstanceInterruptionBehavior",
                     (InstanceInterruptionBehavior.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.valid_from
             (fun f -> Query.Pair ("ValidFrom", (DateTime.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (SpotInstanceType.to_query f)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.launch_specification
             (fun f ->
                Query.Pair
                  ("LaunchSpecification",
                    (RequestSpotLaunchSpecification.to_query f)));
           Util.option_map v.launch_group
             (fun f -> Query.Pair ("LaunchGroup", (String.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.block_duration_minutes
             (fun f ->
                Query.Pair ("BlockDurationMinutes", (Integer.to_query f)));
           Util.option_map v.availability_zone_group
             (fun f ->
                Query.Pair ("AvailabilityZoneGroup", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Util.option_map v.availability_zone_group
                         (fun f ->
                            Ezxmlm.make_tag "availabilityZoneGroup"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.block_duration_minutes
                        (fun f ->
                           Ezxmlm.make_tag "blockDurationMinutes"
                             ([], (Integer.to_xml f)))])
                    @
                    [Util.option_map v.client_token
                       (fun f ->
                          Ezxmlm.make_tag "clientToken"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.dry_run
                      (fun f ->
                         Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
                  @
                  [Util.option_map v.instance_count
                     (fun f ->
                        Ezxmlm.make_tag "instanceCount"
                          ([], (Integer.to_xml f)))])
                 @
                 [Util.option_map v.launch_group
                    (fun f ->
                       Ezxmlm.make_tag "launchGroup" ([], (String.to_xml f)))])
                @
                [Util.option_map v.launch_specification
                   (fun f ->
                      Ezxmlm.make_tag "LaunchSpecification"
                        ([], (RequestSpotLaunchSpecification.to_xml f)))])
               @
               [Util.option_map v.spot_price
                  (fun f ->
                     Ezxmlm.make_tag "spotPrice" ([], (String.to_xml f)))])
              @
              [Util.option_map v.type_
                 (fun f ->
                    Ezxmlm.make_tag "type" ([], (SpotInstanceType.to_xml f)))])
             @
             [Util.option_map v.valid_from
                (fun f ->
                   Ezxmlm.make_tag "validFrom" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.valid_until
               (fun f ->
                  Ezxmlm.make_tag "validUntil" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Ezxmlm.make_tag "InstanceInterruptionBehavior"
                   ([], (InstanceInterruptionBehavior.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 ("instance_interruption_behavior",
                   (InstanceInterruptionBehavior.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.valid_from
             (fun f -> ("valid_from", (DateTime.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (SpotInstanceType.to_json f)));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.launch_specification
             (fun f ->
                ("launch_specification",
                  (RequestSpotLaunchSpecification.to_json f)));
           Util.option_map v.launch_group
             (fun f -> ("launch_group", (String.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.block_duration_minutes
             (fun f -> ("block_duration_minutes", (Integer.to_json f)));
           Util.option_map v.availability_zone_group
             (fun f -> ("availability_zone_group", (String.to_json f)))])
    let of_json j =
      {
        availability_zone_group =
          (Util.option_map (Json.lookup j "availability_zone_group")
             String.of_json);
        block_duration_minutes =
          (Util.option_map (Json.lookup j "block_duration_minutes")
             Integer.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        launch_group =
          (Util.option_map (Json.lookup j "launch_group") String.of_json);
        launch_specification =
          (Util.option_map (Json.lookup j "launch_specification")
             RequestSpotLaunchSpecification.of_json);
        spot_price =
          (Util.option_map (Json.lookup j "spot_price") String.of_json);
        type_ =
          (Util.option_map (Json.lookup j "type_") SpotInstanceType.of_json);
        valid_from =
          (Util.option_map (Json.lookup j "valid_from") DateTime.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        instance_interruption_behavior =
          (Util.option_map (Json.lookup j "instance_interruption_behavior")
             InstanceInterruptionBehavior.of_json)
      }
  end
module CreateFlowLogsResult =
  struct
    type t =
      {
      client_token: String.t option ;
      flow_log_ids: ValueStringList.t ;
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?client_token  ?(flow_log_ids= [])  ?(unsuccessful= [])  () =
      { client_token; flow_log_ids; unsuccessful }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          flow_log_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "flowLogIdSet" xml)
                  ValueStringList.parse));
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)));
           Some
             (Query.Pair
                ("FlowLogIdSet", (ValueStringList.to_query v.flow_log_ids)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.client_token
                (fun f ->
                   Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "flowLogIdSet"
                       ([], (ValueStringList.to_xml [x])))) v.flow_log_ids))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemSet.to_xml [x])))) v.unsuccessful))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful));
           Some ("flow_log_ids", (ValueStringList.to_json v.flow_log_ids));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        flow_log_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "flow_log_ids")));
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module CreateNetworkInterfaceResult =
  struct
    type t = {
      network_interface: NetworkInterface.t option }
    let make ?network_interface  () = { network_interface }
    let parse xml =
      Some
        {
          network_interface =
            (Util.option_bind (Xml.member "networkInterface" xml)
               NetworkInterface.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_interface
              (fun f ->
                 Query.Pair
                   ("NetworkInterface", (NetworkInterface.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.network_interface
              (fun f ->
                 Ezxmlm.make_tag "networkInterface"
                   ([], (NetworkInterface.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_interface
              (fun f -> ("network_interface", (NetworkInterface.to_json f)))])
    let of_json j =
      {
        network_interface =
          (Util.option_map (Json.lookup j "network_interface")
             NetworkInterface.of_json)
      }
  end
module RestoreAddressToClassicResult =
  struct
    type t = {
      public_ip: String.t option ;
      status: Status.t option }
    let make ?public_ip  ?status  () = { public_ip; status }
    let parse xml =
      Some
        {
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) Status.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (Status.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.public_ip
               (fun f -> Ezxmlm.make_tag "publicIp" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f -> Ezxmlm.make_tag "status" ([], (Status.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (Status.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)))])
    let of_json j =
      {
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        status = (Util.option_map (Json.lookup j "status") Status.of_json)
      }
  end
module DescribeTransitGatewayRouteTablesRequest =
  struct
    type t =
      {
      transit_gateway_route_table_ids: TransitGatewayRouteTableIdStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(transit_gateway_route_table_ids= [])  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        transit_gateway_route_table_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableIds" xml)
                  TransitGatewayRouteTableIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableIds",
                  (TransitGatewayRouteTableIdStringList.to_query
                     v.transit_gateway_route_table_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "TransitGatewayRouteTableIds"
                          ([],
                            (TransitGatewayRouteTableIdStringList.to_xml [x]))))
                  v.transit_gateway_route_table_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_route_table_ids",
               (TransitGatewayRouteTableIdStringList.to_json
                  v.transit_gateway_route_table_ids))])
    let of_json j =
      {
        transit_gateway_route_table_ids =
          (TransitGatewayRouteTableIdStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisassociateTransitGatewayRouteTableRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ~transit_gateway_attachment_id 
      ?dry_run  () =
      {
        transit_gateway_route_table_id;
        transit_gateway_attachment_id;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "TransitGatewayRouteTableId"
                   ([], (String.to_xml v.transit_gateway_route_table_id)))])
            @
            [Some
               (Ezxmlm.make_tag "TransitGatewayAttachmentId"
                  ([], (String.to_xml v.transit_gateway_attachment_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisassociateIamInstanceProfileRequest =
  struct
    type t = {
      association_id: String.t }
    let make ~association_id  () = { association_id }
    let parse xml =
      Some
        {
          association_id =
            (Xml.required "AssociationId"
               (Util.option_bind (Xml.member "AssociationId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AssociationId", (String.to_query v.association_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "AssociationId"
                 ([], (String.to_xml v.association_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("association_id", (String.to_json v.association_id))])
    let of_json j =
      {
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")))
      }
  end
module RejectTransitGatewayPeeringAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_attachment_id  ?dry_run  () =
      { transit_gateway_attachment_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "TransitGatewayAttachmentId"
                  ([], (String.to_xml v.transit_gateway_attachment_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisassociateClientVpnTargetNetworkRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      association_id: String.t ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ~association_id  ?dry_run  () =
      { client_vpn_endpoint_id; association_id; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          association_id =
            (Xml.required "AssociationId"
               (Util.option_bind (Xml.member "AssociationId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AssociationId", (String.to_query v.association_id)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "ClientVpnEndpointId"
                   ([], (String.to_xml v.client_vpn_endpoint_id)))])
            @
            [Some
               (Ezxmlm.make_tag "AssociationId"
                  ([], (String.to_xml v.association_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("association_id", (String.to_json v.association_id));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteVpnGatewayRequest =
  struct
    type t = {
      vpn_gateway_id: String.t ;
      dry_run: Boolean.t option }
    let make ~vpn_gateway_id  ?dry_run  () = { vpn_gateway_id; dry_run }
    let parse xml =
      Some
        {
          vpn_gateway_id =
            (Xml.required "VpnGatewayId"
               (Util.option_bind (Xml.member "VpnGatewayId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("VpnGatewayId", (String.to_query v.vpn_gateway_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "VpnGatewayId"
                  ([], (String.to_xml v.vpn_gateway_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpn_gateway_id", (String.to_json v.vpn_gateway_id))])
    let of_json j =
      {
        vpn_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_gateway_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeTrafficMirrorFiltersResult =
  struct
    type t =
      {
      traffic_mirror_filters: TrafficMirrorFilterSet.t ;
      next_token: String.t option }
    let make ?(traffic_mirror_filters= [])  ?next_token  () =
      { traffic_mirror_filters; next_token }
    let parse xml =
      Some
        {
          traffic_mirror_filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "trafficMirrorFilterSet" xml)
                  TrafficMirrorFilterSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterSet",
                  (TrafficMirrorFilterSet.to_query v.traffic_mirror_filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "trafficMirrorFilterSet"
                       ([], (TrafficMirrorFilterSet.to_xml [x]))))
               v.traffic_mirror_filters))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("traffic_mirror_filters",
               (TrafficMirrorFilterSet.to_json v.traffic_mirror_filters))])
    let of_json j =
      {
        traffic_mirror_filters =
          (TrafficMirrorFilterSet.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeTrafficMirrorTargetsRequest =
  struct
    type t =
      {
      traffic_mirror_target_ids: ValueStringList.t ;
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(traffic_mirror_target_ids= [])  ?dry_run  ?(filters= []) 
      ?max_results  ?next_token  () =
      { traffic_mirror_target_ids; dry_run; filters; max_results; next_token
      }
    let parse xml =
      Some
        {
          traffic_mirror_target_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "TrafficMirrorTargetId" xml)
                  ValueStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorTargetId",
                  (ValueStringList.to_query v.traffic_mirror_target_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "TrafficMirrorTargetId"
                          ([], (ValueStringList.to_xml [x]))))
                  v.traffic_mirror_target_ids))
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("traffic_mirror_target_ids",
               (ValueStringList.to_json v.traffic_mirror_target_ids))])
    let of_json j =
      {
        traffic_mirror_target_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_target_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module UnassignPrivateIpAddressesRequest =
  struct
    type t =
      {
      network_interface_id: String.t ;
      private_ip_addresses: PrivateIpAddressStringList.t }
    let make ~network_interface_id  ~private_ip_addresses  () =
      { network_interface_id; private_ip_addresses }
    let parse xml =
      Some
        {
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse));
          private_ip_addresses =
            (Xml.required "privateIpAddress"
               (Util.option_bind (Xml.member "privateIpAddress" xml)
                  PrivateIpAddressStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PrivateIpAddress",
                   (PrivateIpAddressStringList.to_query
                      v.private_ip_addresses)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "networkInterfaceId"
                  ([], (String.to_xml v.network_interface_id)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "privateIpAddress"
                      ([], (PrivateIpAddressStringList.to_xml [x]))))
              v.private_ip_addresses))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("private_ip_addresses",
                (PrivateIpAddressStringList.to_json v.private_ip_addresses));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id))])
    let of_json j =
      {
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        private_ip_addresses =
          (PrivateIpAddressStringList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")))
      }
  end
module DeleteTransitGatewayPeeringAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_attachment_id  ?dry_run  () =
      { transit_gateway_attachment_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "TransitGatewayAttachmentId"
                  ([], (String.to_xml v.transit_gateway_attachment_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ReplaceNetworkAclAssociationResult =
  struct
    type t = {
      new_association_id: String.t option }
    let make ?new_association_id  () = { new_association_id }
    let parse xml =
      Some
        {
          new_association_id =
            (Util.option_bind (Xml.member "newAssociationId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.new_association_id
              (fun f -> Query.Pair ("NewAssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.new_association_id
              (fun f ->
                 Ezxmlm.make_tag "newAssociationId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.new_association_id
              (fun f -> ("new_association_id", (String.to_json f)))])
    let of_json j =
      {
        new_association_id =
          (Util.option_map (Json.lookup j "new_association_id")
             String.of_json)
      }
  end
module AttachClassicLinkVpcResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DeleteSpotDatafeedSubscriptionRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteRouteTableRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      route_table_id: String.t }
    let make ?dry_run  ~route_table_id  () = { dry_run; route_table_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RouteTableId", (String.to_query v.route_table_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "routeTableId"
                 ([], (String.to_xml v.route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("route_table_id", (String.to_json v.route_table_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")))
      }
  end
module GetDefaultCreditSpecificationRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_family: UnlimitedSupportedInstanceFamily.t }
    let make ?dry_run  ~instance_family  () = { dry_run; instance_family }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          instance_family =
            (Xml.required "InstanceFamily"
               (Util.option_bind (Xml.member "InstanceFamily" xml)
                  UnlimitedSupportedInstanceFamily.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstanceFamily",
                   (UnlimitedSupportedInstanceFamily.to_query
                      v.instance_family)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "InstanceFamily"
                 ([],
                   (UnlimitedSupportedInstanceFamily.to_xml v.instance_family)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_family",
                (UnlimitedSupportedInstanceFamily.to_json v.instance_family));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_family =
          (UnlimitedSupportedInstanceFamily.of_json
             (Util.of_option_exn (Json.lookup j "instance_family")))
      }
  end
module DisassociateVpcCidrBlockRequest =
  struct
    type t = {
      association_id: String.t }
    let make ~association_id  () = { association_id }
    let parse xml =
      Some
        {
          association_id =
            (Xml.required "associationId"
               (Util.option_bind (Xml.member "associationId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AssociationId", (String.to_query v.association_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "associationId"
                 ([], (String.to_xml v.association_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("association_id", (String.to_json v.association_id))])
    let of_json j =
      {
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")))
      }
  end
module AssociateTransitGatewayMulticastDomainRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      transit_gateway_attachment_id: String.t option ;
      subnet_ids: ValueStringList.t ;
      dry_run: Boolean.t option }
    let make ?transit_gateway_multicast_domain_id 
      ?transit_gateway_attachment_id  ?(subnet_ids= [])  ?dry_run  () =
      {
        transit_gateway_multicast_domain_id;
        transit_gateway_attachment_id;
        subnet_ids;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse);
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "TransitGatewayAttachmentId" xml)
               String.parse);
          subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SubnetIds" xml)
                  ValueStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SubnetIds", (ValueStringList.to_query v.subnet_ids)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.transit_gateway_multicast_domain_id
                 (fun f ->
                    Ezxmlm.make_tag "TransitGatewayMulticastDomainId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.transit_gateway_attachment_id
                (fun f ->
                   Ezxmlm.make_tag "TransitGatewayAttachmentId"
                     ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "SubnetIds"
                       ([], (ValueStringList.to_xml [x])))) v.subnet_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("subnet_ids", (ValueStringList.to_json v.subnet_ids));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        subnet_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "subnet_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CancelSpotFleetRequestsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      spot_fleet_request_ids: ValueStringList.t ;
      terminate_instances: Boolean.t }
    let make ?dry_run  ~spot_fleet_request_ids  ~terminate_instances  () =
      { dry_run; spot_fleet_request_ids; terminate_instances }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          spot_fleet_request_ids =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  ValueStringList.parse));
          terminate_instances =
            (Xml.required "terminateInstances"
               (Util.option_bind (Xml.member "terminateInstances" xml)
                  Boolean.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TerminateInstances",
                   (Boolean.to_query v.terminate_instances)));
           Some
             (Query.Pair
                ("SpotFleetRequestId",
                  (ValueStringList.to_query v.spot_fleet_request_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "spotFleetRequestId"
                       ([], (ValueStringList.to_xml [x]))))
               v.spot_fleet_request_ids))
           @
           [Some
              (Ezxmlm.make_tag "terminateInstances"
                 ([], (Boolean.to_xml v.terminate_instances)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("terminate_instances",
                (Boolean.to_json v.terminate_instances));
           Some
             ("spot_fleet_request_ids",
               (ValueStringList.to_json v.spot_fleet_request_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        spot_fleet_request_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_ids")));
        terminate_instances =
          (Boolean.of_json
             (Util.of_option_exn (Json.lookup j "terminate_instances")))
      }
  end
module DescribeTransitGatewaysResult =
  struct
    type t =
      {
      transit_gateways: TransitGatewayList.t ;
      next_token: String.t option }
    let make ?(transit_gateways= [])  ?next_token  () =
      { transit_gateways; next_token }
    let parse xml =
      Some
        {
          transit_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "transitGatewaySet" xml)
                  TransitGatewayList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewaySet",
                  (TransitGatewayList.to_query v.transit_gateways)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "transitGatewaySet"
                       ([], (TransitGatewayList.to_xml [x]))))
               v.transit_gateways))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateways",
               (TransitGatewayList.to_json v.transit_gateways))])
    let of_json j =
      {
        transit_gateways =
          (TransitGatewayList.of_json
             (Util.of_option_exn (Json.lookup j "transit_gateways")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyVpcEndpointServiceConfigurationResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module CancelBundleTaskRequest =
  struct
    type t = {
      bundle_id: String.t ;
      dry_run: Boolean.t option }
    let make ~bundle_id  ?dry_run  () = { bundle_id; dry_run }
    let parse xml =
      Some
        {
          bundle_id =
            (Xml.required "BundleId"
               (Util.option_bind (Xml.member "BundleId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("BundleId", (String.to_query v.bundle_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "BundleId" ([], (String.to_xml v.bundle_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("bundle_id", (String.to_json v.bundle_id))])
    let of_json j =
      {
        bundle_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "bundle_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CopyImageResult =
  struct
    type t = {
      image_id: String.t option }
    let make ?image_id  () = { image_id }
    let parse xml =
      Some
        {
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> Query.Pair ("ImageId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.image_id
              (fun f -> Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> ("image_id", (String.to_json f)))])
    let of_json j =
      {
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json)
      }
  end
module CreateClientVpnEndpointRequest =
  struct
    type t =
      {
      client_cidr_block: String.t ;
      server_certificate_arn: String.t ;
      authentication_options: ClientVpnAuthenticationRequestList.t ;
      connection_log_options: ConnectionLogOptions.t ;
      dns_servers: ValueStringList.t ;
      transport_protocol: TransportProtocol.t option ;
      description: String.t option ;
      split_tunnel: Boolean.t option ;
      dry_run: Boolean.t option ;
      client_token: String.t option ;
      tag_specifications: TagSpecificationList.t }
    let make ~client_cidr_block  ~server_certificate_arn 
      ~authentication_options  ~connection_log_options  ?(dns_servers= []) 
      ?transport_protocol  ?description  ?split_tunnel  ?dry_run 
      ?client_token  ?(tag_specifications= [])  () =
      {
        client_cidr_block;
        server_certificate_arn;
        authentication_options;
        connection_log_options;
        dns_servers;
        transport_protocol;
        description;
        split_tunnel;
        dry_run;
        client_token;
        tag_specifications
      }
    let parse xml =
      Some
        {
          client_cidr_block =
            (Xml.required "ClientCidrBlock"
               (Util.option_bind (Xml.member "ClientCidrBlock" xml)
                  String.parse));
          server_certificate_arn =
            (Xml.required "ServerCertificateArn"
               (Util.option_bind (Xml.member "ServerCertificateArn" xml)
                  String.parse));
          authentication_options =
            (Xml.required "Authentication"
               (Util.option_bind (Xml.member "Authentication" xml)
                  ClientVpnAuthenticationRequestList.parse));
          connection_log_options =
            (Xml.required "ConnectionLogOptions"
               (Util.option_bind (Xml.member "ConnectionLogOptions" xml)
                  ConnectionLogOptions.parse));
          dns_servers =
            (Util.of_option []
               (Util.option_bind (Xml.member "DnsServers" xml)
                  ValueStringList.parse));
          transport_protocol =
            (Util.option_bind (Xml.member "TransportProtocol" xml)
               TransportProtocol.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          split_tunnel =
            (Util.option_bind (Xml.member "SplitTunnel" xml) Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.split_tunnel
             (fun f -> Query.Pair ("SplitTunnel", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.transport_protocol
             (fun f ->
                Query.Pair
                  ("TransportProtocol", (TransportProtocol.to_query f)));
           Some
             (Query.Pair
                ("DnsServers", (ValueStringList.to_query v.dns_servers)));
           Some
             (Query.Pair
                ("ConnectionLogOptions",
                  (ConnectionLogOptions.to_query v.connection_log_options)));
           Some
             (Query.Pair
                ("Authentication",
                  (ClientVpnAuthenticationRequestList.to_query
                     v.authentication_options)));
           Some
             (Query.Pair
                ("ServerCertificateArn",
                  (String.to_query v.server_certificate_arn)));
           Some
             (Query.Pair
                ("ClientCidrBlock", (String.to_query v.client_cidr_block)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Some
                        (Ezxmlm.make_tag "ClientCidrBlock"
                           ([], (String.to_xml v.client_cidr_block)))])
                    @
                    [Some
                       (Ezxmlm.make_tag "ServerCertificateArn"
                          ([], (String.to_xml v.server_certificate_arn)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "Authentication"
                              ([],
                                (ClientVpnAuthenticationRequestList.to_xml
                                   [x])))) v.authentication_options))
                  @
                  [Some
                     (Ezxmlm.make_tag "ConnectionLogOptions"
                        ([],
                          (ConnectionLogOptions.to_xml
                             v.connection_log_options)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "DnsServers"
                            ([], (ValueStringList.to_xml [x]))))
                    v.dns_servers))
                @
                [Util.option_map v.transport_protocol
                   (fun f ->
                      Ezxmlm.make_tag "TransportProtocol"
                        ([], (TransportProtocol.to_xml f)))])
               @
               [Util.option_map v.description
                  (fun f ->
                     Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
              @
              [Util.option_map v.split_tunnel
                 (fun f ->
                    Ezxmlm.make_tag "SplitTunnel" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.client_token
               (fun f ->
                  Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "TagSpecification"
                      ([], (TagSpecificationList.to_xml [x]))))
              v.tag_specifications))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.split_tunnel
             (fun f -> ("split_tunnel", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.transport_protocol
             (fun f -> ("transport_protocol", (TransportProtocol.to_json f)));
           Some ("dns_servers", (ValueStringList.to_json v.dns_servers));
           Some
             ("connection_log_options",
               (ConnectionLogOptions.to_json v.connection_log_options));
           Some
             ("authentication_options",
               (ClientVpnAuthenticationRequestList.to_json
                  v.authentication_options));
           Some
             ("server_certificate_arn",
               (String.to_json v.server_certificate_arn));
           Some ("client_cidr_block", (String.to_json v.client_cidr_block))])
    let of_json j =
      {
        client_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_cidr_block")));
        server_certificate_arn =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "server_certificate_arn")));
        authentication_options =
          (ClientVpnAuthenticationRequestList.of_json
             (Util.of_option_exn (Json.lookup j "authentication_options")));
        connection_log_options =
          (ConnectionLogOptions.of_json
             (Util.of_option_exn (Json.lookup j "connection_log_options")));
        dns_servers =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "dns_servers")));
        transport_protocol =
          (Util.option_map (Json.lookup j "transport_protocol")
             TransportProtocol.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        split_tunnel =
          (Util.option_map (Json.lookup j "split_tunnel") Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module CreateInstanceExportTaskResult =
  struct
    type t = {
      export_task: ExportTask.t option }
    let make ?export_task  () = { export_task }
    let parse xml =
      Some
        {
          export_task =
            (Util.option_bind (Xml.member "exportTask" xml) ExportTask.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.export_task
              (fun f -> Query.Pair ("ExportTask", (ExportTask.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.export_task
              (fun f ->
                 Ezxmlm.make_tag "exportTask" ([], (ExportTask.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.export_task
              (fun f -> ("export_task", (ExportTask.to_json f)))])
    let of_json j =
      {
        export_task =
          (Util.option_map (Json.lookup j "export_task") ExportTask.of_json)
      }
  end
module DisableTransitGatewayRouteTablePropagationResult =
  struct
    type t = {
      propagation: TransitGatewayPropagation.t option }
    let make ?propagation  () = { propagation }
    let parse xml =
      Some
        {
          propagation =
            (Util.option_bind (Xml.member "propagation" xml)
               TransitGatewayPropagation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.propagation
              (fun f ->
                 Query.Pair
                   ("Propagation", (TransitGatewayPropagation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.propagation
              (fun f ->
                 Ezxmlm.make_tag "propagation"
                   ([], (TransitGatewayPropagation.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.propagation
              (fun f ->
                 ("propagation", (TransitGatewayPropagation.to_json f)))])
    let of_json j =
      {
        propagation =
          (Util.option_map (Json.lookup j "propagation")
             TransitGatewayPropagation.of_json)
      }
  end
module DeleteTransitGatewayRouteTableRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ?dry_run  () =
      { transit_gateway_route_table_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "TransitGatewayRouteTableId"
                  ([], (String.to_xml v.transit_gateway_route_table_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeVpcClassicLinkDnsSupportResult =
  struct
    type t =
      {
      next_token: String.t option ;
      vpcs: ClassicLinkDnsSupportList.t }
    let make ?next_token  ?(vpcs= [])  () = { next_token; vpcs }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          vpcs =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcs" xml)
                  ClassicLinkDnsSupportList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Vpcs", (ClassicLinkDnsSupportList.to_query v.vpcs)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "vpcs"
                      ([], (ClassicLinkDnsSupportList.to_xml [x])))) v.vpcs))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpcs", (ClassicLinkDnsSupportList.to_json v.vpcs));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        vpcs =
          (ClassicLinkDnsSupportList.of_json
             (Util.of_option_exn (Json.lookup j "vpcs")))
      }
  end
module ModifyLaunchTemplateRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      client_token: String.t option ;
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      default_version: String.t option }
    let make ?dry_run  ?client_token  ?launch_template_id 
      ?launch_template_name  ?default_version  () =
      {
        dry_run;
        client_token;
        launch_template_id;
        launch_template_name;
        default_version
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          launch_template_id =
            (Util.option_bind (Xml.member "LaunchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "LaunchTemplateName" xml)
               String.parse);
          default_version =
            (Util.option_bind (Xml.member "SetDefaultVersion" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.default_version
              (fun f -> Query.Pair ("SetDefaultVersion", (String.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.client_token
                 (fun f ->
                    Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
             @
             [Util.option_map v.launch_template_id
                (fun f ->
                   Ezxmlm.make_tag "LaunchTemplateId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.launch_template_name
               (fun f ->
                  Ezxmlm.make_tag "LaunchTemplateName"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.default_version
              (fun f ->
                 Ezxmlm.make_tag "SetDefaultVersion" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.default_version
              (fun f -> ("default_version", (String.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        default_version =
          (Util.option_map (Json.lookup j "default_version") String.of_json)
      }
  end
module DisassociateVpcCidrBlockResult =
  struct
    type t =
      {
      ipv6_cidr_block_association: VpcIpv6CidrBlockAssociation.t option ;
      cidr_block_association: VpcCidrBlockAssociation.t option ;
      vpc_id: String.t option }
    let make ?ipv6_cidr_block_association  ?cidr_block_association  ?vpc_id 
      () = { ipv6_cidr_block_association; cidr_block_association; vpc_id }
    let parse xml =
      Some
        {
          ipv6_cidr_block_association =
            (Util.option_bind (Xml.member "ipv6CidrBlockAssociation" xml)
               VpcIpv6CidrBlockAssociation.parse);
          cidr_block_association =
            (Util.option_bind (Xml.member "cidrBlockAssociation" xml)
               VpcCidrBlockAssociation.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.cidr_block_association
             (fun f ->
                Query.Pair
                  ("CidrBlockAssociation",
                    (VpcCidrBlockAssociation.to_query f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockAssociation",
                    (VpcIpv6CidrBlockAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.ipv6_cidr_block_association
                (fun f ->
                   Ezxmlm.make_tag "ipv6CidrBlockAssociation"
                     ([], (VpcIpv6CidrBlockAssociation.to_xml f)))])
            @
            [Util.option_map v.cidr_block_association
               (fun f ->
                  Ezxmlm.make_tag "cidrBlockAssociation"
                    ([], (VpcCidrBlockAssociation.to_xml f)))])
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.cidr_block_association
             (fun f ->
                ("cidr_block_association",
                  (VpcCidrBlockAssociation.to_json f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                ("ipv6_cidr_block_association",
                  (VpcIpv6CidrBlockAssociation.to_json f)))])
    let of_json j =
      {
        ipv6_cidr_block_association =
          (Util.option_map (Json.lookup j "ipv6_cidr_block_association")
             VpcIpv6CidrBlockAssociation.of_json);
        cidr_block_association =
          (Util.option_map (Json.lookup j "cidr_block_association")
             VpcCidrBlockAssociation.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module DescribeImportSnapshotTasksRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      import_task_ids: ImportTaskIdList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(filters= [])  ?(import_task_ids= [])  ?max_results 
      ?next_token  () =
      { dry_run; filters; import_task_ids; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml) FilterList.parse));
          import_task_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ImportTaskId" xml)
                  ImportTaskIdList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("ImportTaskId",
                  (ImportTaskIdList.to_query v.import_task_ids)));
           Some (Query.Pair ("Filters", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filters"
                         ([], (FilterList.to_xml [x])))) v.filters))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "ImportTaskId"
                        ([], (ImportTaskIdList.to_xml [x]))))
                v.import_task_ids))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("import_task_ids",
               (ImportTaskIdList.to_json v.import_task_ids));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        import_task_ids =
          (ImportTaskIdList.of_json
             (Util.of_option_exn (Json.lookup j "import_task_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module RequestSpotFleetRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      spot_fleet_request_config: SpotFleetRequestConfigData.t }
    let make ?dry_run  ~spot_fleet_request_config  () =
      { dry_run; spot_fleet_request_config }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          spot_fleet_request_config =
            (Xml.required "spotFleetRequestConfig"
               (Util.option_bind (Xml.member "spotFleetRequestConfig" xml)
                  SpotFleetRequestConfigData.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotFleetRequestConfig",
                   (SpotFleetRequestConfigData.to_query
                      v.spot_fleet_request_config)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "spotFleetRequestConfig"
                 ([],
                   (SpotFleetRequestConfigData.to_xml
                      v.spot_fleet_request_config)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_fleet_request_config",
                (SpotFleetRequestConfigData.to_json
                   v.spot_fleet_request_config));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        spot_fleet_request_config =
          (SpotFleetRequestConfigData.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_config")))
      }
  end
module DescribeReservedInstancesListingsResult =
  struct
    type t = {
      reserved_instances_listings: ReservedInstancesListingList.t }
    let make ?(reserved_instances_listings= [])  () =
      { reserved_instances_listings }
    let parse xml =
      Some
        {
          reserved_instances_listings =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesListingsSet" xml)
                  ReservedInstancesListingList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesListingsSet",
                   (ReservedInstancesListingList.to_query
                      v.reserved_instances_listings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "reservedInstancesListingsSet"
                      ([], (ReservedInstancesListingList.to_xml [x]))))
              v.reserved_instances_listings))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_listings",
                (ReservedInstancesListingList.to_json
                   v.reserved_instances_listings))])
    let of_json j =
      {
        reserved_instances_listings =
          (ReservedInstancesListingList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_listings")))
      }
  end
module ModifyVpnTunnelCertificateRequest =
  struct
    type t =
      {
      vpn_connection_id: String.t ;
      vpn_tunnel_outside_ip_address: String.t ;
      dry_run: Boolean.t option }
    let make ~vpn_connection_id  ~vpn_tunnel_outside_ip_address  ?dry_run  ()
      = { vpn_connection_id; vpn_tunnel_outside_ip_address; dry_run }
    let parse xml =
      Some
        {
          vpn_connection_id =
            (Xml.required "VpnConnectionId"
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  String.parse));
          vpn_tunnel_outside_ip_address =
            (Xml.required "VpnTunnelOutsideIpAddress"
               (Util.option_bind (Xml.member "VpnTunnelOutsideIpAddress" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("VpnTunnelOutsideIpAddress",
                  (String.to_query v.vpn_tunnel_outside_ip_address)));
           Some
             (Query.Pair
                ("VpnConnectionId", (String.to_query v.vpn_connection_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "VpnConnectionId"
                   ([], (String.to_xml v.vpn_connection_id)))])
            @
            [Some
               (Ezxmlm.make_tag "VpnTunnelOutsideIpAddress"
                  ([], (String.to_xml v.vpn_tunnel_outside_ip_address)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("vpn_tunnel_outside_ip_address",
               (String.to_json v.vpn_tunnel_outside_ip_address));
           Some ("vpn_connection_id", (String.to_json v.vpn_connection_id))])
    let of_json j =
      {
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")));
        vpn_tunnel_outside_ip_address =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "vpn_tunnel_outside_ip_address")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeClientVpnRoutesRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?(filters= [])  ?max_results 
      ?next_token  ?dry_run  () =
      { client_vpn_endpoint_id; filters; max_results; next_token; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "ClientVpnEndpointId"
                     ([], (String.to_xml v.client_vpn_endpoint_id)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteVpcEndpointsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_endpoint_ids: ValueStringList.t }
    let make ?dry_run  ~vpc_endpoint_ids  () = { dry_run; vpc_endpoint_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          vpc_endpoint_ids =
            (Xml.required "VpcEndpointId"
               (Util.option_bind (Xml.member "VpcEndpointId" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcEndpointId",
                   (ValueStringList.to_query v.vpc_endpoint_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "VpcEndpointId"
                      ([], (ValueStringList.to_xml [x])))) v.vpc_endpoint_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpc_endpoint_ids",
                (ValueStringList.to_json v.vpc_endpoint_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_endpoint_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoint_ids")))
      }
  end
module CreateVpcEndpointServiceConfigurationResult =
  struct
    type t =
      {
      service_configuration: ServiceConfiguration.t option ;
      client_token: String.t option }
    let make ?service_configuration  ?client_token  () =
      { service_configuration; client_token }
    let parse xml =
      Some
        {
          service_configuration =
            (Util.option_bind (Xml.member "serviceConfiguration" xml)
               ServiceConfiguration.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.service_configuration
             (fun f ->
                Query.Pair
                  ("ServiceConfiguration", (ServiceConfiguration.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.service_configuration
               (fun f ->
                  Ezxmlm.make_tag "serviceConfiguration"
                    ([], (ServiceConfiguration.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.service_configuration
             (fun f ->
                ("service_configuration", (ServiceConfiguration.to_json f)))])
    let of_json j =
      {
        service_configuration =
          (Util.option_map (Json.lookup j "service_configuration")
             ServiceConfiguration.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module SearchLocalGatewayRoutesRequest =
  struct
    type t =
      {
      local_gateway_route_table_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~local_gateway_route_table_id  ~filters  ?max_results 
      ?next_token  ?dry_run  () =
      {
        local_gateway_route_table_id;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          local_gateway_route_table_id =
            (Xml.required "LocalGatewayRouteTableId"
               (Util.option_bind (Xml.member "LocalGatewayRouteTableId" xml)
                  String.parse));
          filters =
            (Xml.required "Filter"
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableId",
                  (String.to_query v.local_gateway_route_table_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "LocalGatewayRouteTableId"
                     ([], (String.to_xml v.local_gateway_route_table_id)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("local_gateway_route_table_id",
               (String.to_json v.local_gateway_route_table_id))])
    let of_json j =
      {
        local_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_route_table_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisableVpcClassicLinkRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      vpc_id: String.t }
    let make ?dry_run  ~vpc_id  () = { dry_run; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @ [Some (Ezxmlm.make_tag "vpcId" ([], (String.to_xml v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DeleteNetworkAclEntryRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      egress: Boolean.t ;
      network_acl_id: String.t ;
      rule_number: Integer.t }
    let make ?dry_run  ~egress  ~network_acl_id  ~rule_number  () =
      { dry_run; egress; network_acl_id; rule_number }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          egress =
            (Xml.required "egress"
               (Util.option_bind (Xml.member "egress" xml) Boolean.parse));
          network_acl_id =
            (Xml.required "networkAclId"
               (Util.option_bind (Xml.member "networkAclId" xml) String.parse));
          rule_number =
            (Xml.required "ruleNumber"
               (Util.option_bind (Xml.member "ruleNumber" xml) Integer.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("RuleNumber", (Integer.to_query v.rule_number)));
           Some
             (Query.Pair ("NetworkAclId", (String.to_query v.network_acl_id)));
           Some (Query.Pair ("Egress", (Boolean.to_query v.egress)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             [Some (Ezxmlm.make_tag "egress" ([], (Boolean.to_xml v.egress)))])
            @
            [Some
               (Ezxmlm.make_tag "networkAclId"
                  ([], (String.to_xml v.network_acl_id)))])
           @
           [Some
              (Ezxmlm.make_tag "ruleNumber"
                 ([], (Integer.to_xml v.rule_number)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("rule_number", (Integer.to_json v.rule_number));
           Some ("network_acl_id", (String.to_json v.network_acl_id));
           Some ("egress", (Boolean.to_json v.egress));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        egress =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "egress")));
        network_acl_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_id")));
        rule_number =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "rule_number")))
      }
  end
module AllocateAddressResult =
  struct
    type t =
      {
      public_ip: String.t option ;
      allocation_id: String.t option ;
      public_ipv4_pool: String.t option ;
      network_border_group: String.t option ;
      domain: DomainType.t option ;
      customer_owned_ip: String.t option ;
      customer_owned_ipv4_pool: String.t option }
    let make ?public_ip  ?allocation_id  ?public_ipv4_pool 
      ?network_border_group  ?domain  ?customer_owned_ip 
      ?customer_owned_ipv4_pool  () =
      {
        public_ip;
        allocation_id;
        public_ipv4_pool;
        network_border_group;
        domain;
        customer_owned_ip;
        customer_owned_ipv4_pool
      }
    let parse xml =
      Some
        {
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse);
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          public_ipv4_pool =
            (Util.option_bind (Xml.member "publicIpv4Pool" xml) String.parse);
          network_border_group =
            (Util.option_bind (Xml.member "networkBorderGroup" xml)
               String.parse);
          domain =
            (Util.option_bind (Xml.member "domain" xml) DomainType.parse);
          customer_owned_ip =
            (Util.option_bind (Xml.member "customerOwnedIp" xml) String.parse);
          customer_owned_ipv4_pool =
            (Util.option_bind (Xml.member "customerOwnedIpv4Pool" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.customer_owned_ipv4_pool
              (fun f ->
                 Query.Pair ("CustomerOwnedIpv4Pool", (String.to_query f)));
           Util.option_map v.customer_owned_ip
             (fun f -> Query.Pair ("CustomerOwnedIp", (String.to_query f)));
           Util.option_map v.domain
             (fun f -> Query.Pair ("Domain", (DomainType.to_query f)));
           Util.option_map v.network_border_group
             (fun f -> Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.public_ipv4_pool
             (fun f -> Query.Pair ("PublicIpv4Pool", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.public_ip
                    (fun f ->
                       Ezxmlm.make_tag "publicIp" ([], (String.to_xml f)))])
                @
                [Util.option_map v.allocation_id
                   (fun f ->
                      Ezxmlm.make_tag "allocationId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.public_ipv4_pool
                  (fun f ->
                     Ezxmlm.make_tag "publicIpv4Pool" ([], (String.to_xml f)))])
              @
              [Util.option_map v.network_border_group
                 (fun f ->
                    Ezxmlm.make_tag "networkBorderGroup"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.domain
                (fun f ->
                   Ezxmlm.make_tag "domain" ([], (DomainType.to_xml f)))])
            @
            [Util.option_map v.customer_owned_ip
               (fun f ->
                  Ezxmlm.make_tag "customerOwnedIp" ([], (String.to_xml f)))])
           @
           [Util.option_map v.customer_owned_ipv4_pool
              (fun f ->
                 Ezxmlm.make_tag "customerOwnedIpv4Pool"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.customer_owned_ipv4_pool
              (fun f -> ("customer_owned_ipv4_pool", (String.to_json f)));
           Util.option_map v.customer_owned_ip
             (fun f -> ("customer_owned_ip", (String.to_json f)));
           Util.option_map v.domain
             (fun f -> ("domain", (DomainType.to_json f)));
           Util.option_map v.network_border_group
             (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.public_ipv4_pool
             (fun f -> ("public_ipv4_pool", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)))])
    let of_json j =
      {
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        public_ipv4_pool =
          (Util.option_map (Json.lookup j "public_ipv4_pool") String.of_json);
        network_border_group =
          (Util.option_map (Json.lookup j "network_border_group")
             String.of_json);
        domain =
          (Util.option_map (Json.lookup j "domain") DomainType.of_json);
        customer_owned_ip =
          (Util.option_map (Json.lookup j "customer_owned_ip") String.of_json);
        customer_owned_ipv4_pool =
          (Util.option_map (Json.lookup j "customer_owned_ipv4_pool")
             String.of_json)
      }
  end
module DescribeClientVpnTargetNetworksRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      association_ids: ValueStringList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      filters: FilterList.t ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?(association_ids= [])  ?max_results 
      ?next_token  ?(filters= [])  ?dry_run  () =
      {
        client_vpn_endpoint_id;
        association_ids;
        max_results;
        next_token;
        filters;
        dry_run
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          association_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AssociationIds" xml)
                  ValueStringList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("AssociationIds",
                  (ValueStringList.to_query v.association_ids)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Some
                   (Ezxmlm.make_tag "ClientVpnEndpointId"
                      ([], (String.to_xml v.client_vpn_endpoint_id)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "AssociationIds"
                          ([], (ValueStringList.to_xml [x]))))
                  v.association_ids))
              @
              [Util.option_map v.max_results
                 (fun f ->
                    Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
               v.filters))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("association_ids", (ValueStringList.to_json v.association_ids));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        association_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "association_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyTrafficMirrorFilterRuleResult =
  struct
    type t = {
      traffic_mirror_filter_rule: TrafficMirrorFilterRule.t option }
    let make ?traffic_mirror_filter_rule  () = { traffic_mirror_filter_rule }
    let parse xml =
      Some
        {
          traffic_mirror_filter_rule =
            (Util.option_bind (Xml.member "trafficMirrorFilterRule" xml)
               TrafficMirrorFilterRule.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_rule
              (fun f ->
                 Query.Pair
                   ("TrafficMirrorFilterRule",
                     (TrafficMirrorFilterRule.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.traffic_mirror_filter_rule
              (fun f ->
                 Ezxmlm.make_tag "trafficMirrorFilterRule"
                   ([], (TrafficMirrorFilterRule.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_rule
              (fun f ->
                 ("traffic_mirror_filter_rule",
                   (TrafficMirrorFilterRule.to_json f)))])
    let of_json j =
      {
        traffic_mirror_filter_rule =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_rule")
             TrafficMirrorFilterRule.of_json)
      }
  end
module CreateDefaultVpcResult =
  struct
    type t = {
      vpc: Vpc.t option }
    let make ?vpc  () = { vpc }
    let parse xml =
      Some { vpc = (Util.option_bind (Xml.member "vpc" xml) Vpc.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc
              (fun f -> Query.Pair ("Vpc", (Vpc.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpc
              (fun f -> Ezxmlm.make_tag "vpc" ([], (Vpc.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc (fun f -> ("vpc", (Vpc.to_json f)))])
    let of_json j =
      { vpc = (Util.option_map (Json.lookup j "vpc") Vpc.of_json) }
  end
module CreateVpcEndpointConnectionNotificationRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_id: String.t option ;
      vpc_endpoint_id: String.t option ;
      connection_notification_arn: String.t ;
      connection_events: ValueStringList.t ;
      client_token: String.t option }
    let make ?dry_run  ?service_id  ?vpc_endpoint_id 
      ~connection_notification_arn  ~connection_events  ?client_token  () =
      {
        dry_run;
        service_id;
        vpc_endpoint_id;
        connection_notification_arn;
        connection_events;
        client_token
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_id =
            (Util.option_bind (Xml.member "ServiceId" xml) String.parse);
          vpc_endpoint_id =
            (Util.option_bind (Xml.member "VpcEndpointId" xml) String.parse);
          connection_notification_arn =
            (Xml.required "ConnectionNotificationArn"
               (Util.option_bind (Xml.member "ConnectionNotificationArn" xml)
                  String.parse));
          connection_events =
            (Xml.required "ConnectionEvents"
               (Util.option_bind (Xml.member "ConnectionEvents" xml)
                  ValueStringList.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ConnectionEvents",
                  (ValueStringList.to_query v.connection_events)));
           Some
             (Query.Pair
                ("ConnectionNotificationArn",
                  (String.to_query v.connection_notification_arn)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> Query.Pair ("VpcEndpointId", (String.to_query f)));
           Util.option_map v.service_id
             (fun f -> Query.Pair ("ServiceId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.dry_run
                   (fun f ->
                      Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.service_id
                  (fun f ->
                     Ezxmlm.make_tag "ServiceId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.vpc_endpoint_id
                 (fun f ->
                    Ezxmlm.make_tag "VpcEndpointId" ([], (String.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "ConnectionNotificationArn"
                   ([], (String.to_xml v.connection_notification_arn)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ConnectionEvents"
                       ([], (ValueStringList.to_xml [x]))))
               v.connection_events))
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Some
             ("connection_events",
               (ValueStringList.to_json v.connection_events));
           Some
             ("connection_notification_arn",
               (String.to_json v.connection_notification_arn));
           Util.option_map v.vpc_endpoint_id
             (fun f -> ("vpc_endpoint_id", (String.to_json f)));
           Util.option_map v.service_id
             (fun f -> ("service_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_id =
          (Util.option_map (Json.lookup j "service_id") String.of_json);
        vpc_endpoint_id =
          (Util.option_map (Json.lookup j "vpc_endpoint_id") String.of_json);
        connection_notification_arn =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "connection_notification_arn")));
        connection_events =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "connection_events")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module ExportClientVpnClientConfigurationRequest =
  struct
    type t = {
      client_vpn_endpoint_id: String.t ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?dry_run  () =
      { client_vpn_endpoint_id; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "ClientVpnEndpointId"
                  ([], (String.to_xml v.client_vpn_endpoint_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module TerminateInstancesResult =
  struct
    type t = {
      terminating_instances: InstanceStateChangeList.t }
    let make ?(terminating_instances= [])  () = { terminating_instances }
    let parse xml =
      Some
        {
          terminating_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceStateChangeList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceStateChangeList.to_query v.terminating_instances)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "instancesSet"
                      ([], (InstanceStateChangeList.to_xml [x]))))
              v.terminating_instances))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("terminating_instances",
                (InstanceStateChangeList.to_json v.terminating_instances))])
    let of_json j =
      {
        terminating_instances =
          (InstanceStateChangeList.of_json
             (Util.of_option_exn (Json.lookup j "terminating_instances")))
      }
  end
module CreateClientVpnRouteRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      destination_cidr_block: String.t ;
      target_vpc_subnet_id: String.t ;
      description: String.t option ;
      client_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ~destination_cidr_block 
      ~target_vpc_subnet_id  ?description  ?client_token  ?dry_run  () =
      {
        client_vpn_endpoint_id;
        destination_cidr_block;
        target_vpc_subnet_id;
        description;
        client_token;
        dry_run
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          target_vpc_subnet_id =
            (Xml.required "TargetVpcSubnetId"
               (Util.option_bind (Xml.member "TargetVpcSubnetId" xml)
                  String.parse));
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("TargetVpcSubnetId",
                  (String.to_query v.target_vpc_subnet_id)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Some
                   (Ezxmlm.make_tag "ClientVpnEndpointId"
                      ([], (String.to_xml v.client_vpn_endpoint_id)))])
               @
               [Some
                  (Ezxmlm.make_tag "DestinationCidrBlock"
                     ([], (String.to_xml v.destination_cidr_block)))])
              @
              [Some
                 (Ezxmlm.make_tag "TargetVpcSubnetId"
                    ([], (String.to_xml v.target_vpc_subnet_id)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
            @
            [Util.option_map v.client_token
               (fun f ->
                  Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some
             ("target_vpc_subnet_id",
               (String.to_json v.target_vpc_subnet_id));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        target_vpc_subnet_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "target_vpc_subnet_id")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ExportClientVpnClientCertificateRevocationListResult =
  struct
    type t =
      {
      certificate_revocation_list: String.t option ;
      status: ClientCertificateRevocationListStatus.t option }
    let make ?certificate_revocation_list  ?status  () =
      { certificate_revocation_list; status }
    let parse xml =
      Some
        {
          certificate_revocation_list =
            (Util.option_bind (Xml.member "certificateRevocationList" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientCertificateRevocationListStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair
                   ("Status",
                     (ClientCertificateRevocationListStatus.to_query f)));
           Util.option_map v.certificate_revocation_list
             (fun f ->
                Query.Pair ("CertificateRevocationList", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.certificate_revocation_list
               (fun f ->
                  Ezxmlm.make_tag "certificateRevocationList"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status"
                   ([], (ClientCertificateRevocationListStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 ("status",
                   (ClientCertificateRevocationListStatus.to_json f)));
           Util.option_map v.certificate_revocation_list
             (fun f -> ("certificate_revocation_list", (String.to_json f)))])
    let of_json j =
      {
        certificate_revocation_list =
          (Util.option_map (Json.lookup j "certificate_revocation_list")
             String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             ClientCertificateRevocationListStatus.of_json)
      }
  end
module TerminateClientVpnConnectionsResult =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option ;
      username: String.t option ;
      connection_statuses: TerminateConnectionStatusSet.t }
    let make ?client_vpn_endpoint_id  ?username  ?(connection_statuses= []) 
      () = { client_vpn_endpoint_id; username; connection_statuses }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          username =
            (Util.option_bind (Xml.member "username" xml) String.parse);
          connection_statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "connectionStatuses" xml)
                  TerminateConnectionStatusSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ConnectionStatuses",
                   (TerminateConnectionStatusSet.to_query
                      v.connection_statuses)));
           Util.option_map v.username
             (fun f -> Query.Pair ("Username", (String.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.client_vpn_endpoint_id
                (fun f ->
                   Ezxmlm.make_tag "clientVpnEndpointId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.username
               (fun f -> Ezxmlm.make_tag "username" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "connectionStatuses"
                      ([], (TerminateConnectionStatusSet.to_xml [x]))))
              v.connection_statuses))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("connection_statuses",
                (TerminateConnectionStatusSet.to_json v.connection_statuses));
           Util.option_map v.username
             (fun f -> ("username", (String.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (Util.option_map (Json.lookup j "client_vpn_endpoint_id")
             String.of_json);
        username =
          (Util.option_map (Json.lookup j "username") String.of_json);
        connection_statuses =
          (TerminateConnectionStatusSet.of_json
             (Util.of_option_exn (Json.lookup j "connection_statuses")))
      }
  end
module DescribeInstanceTypeOfferingsResult =
  struct
    type t =
      {
      instance_type_offerings: InstanceTypeOfferingsList.t ;
      next_token: String.t option }
    let make ?(instance_type_offerings= [])  ?next_token  () =
      { instance_type_offerings; next_token }
    let parse xml =
      Some
        {
          instance_type_offerings =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceTypeOfferingSet" xml)
                  InstanceTypeOfferingsList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceTypeOfferingSet",
                  (InstanceTypeOfferingsList.to_query
                     v.instance_type_offerings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "instanceTypeOfferingSet"
                       ([], (InstanceTypeOfferingsList.to_xml [x]))))
               v.instance_type_offerings))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_type_offerings",
               (InstanceTypeOfferingsList.to_json v.instance_type_offerings))])
    let of_json j =
      {
        instance_type_offerings =
          (InstanceTypeOfferingsList.of_json
             (Util.of_option_exn (Json.lookup j "instance_type_offerings")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeInstanceStatusResult =
  struct
    type t =
      {
      instance_statuses: InstanceStatusList.t ;
      next_token: String.t option }
    let make ?(instance_statuses= [])  ?next_token  () =
      { instance_statuses; next_token }
    let parse xml =
      Some
        {
          instance_statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceStatusSet" xml)
                  InstanceStatusList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceStatusSet",
                  (InstanceStatusList.to_query v.instance_statuses)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "instanceStatusSet"
                       ([], (InstanceStatusList.to_xml [x]))))
               v.instance_statuses))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_statuses",
               (InstanceStatusList.to_json v.instance_statuses))])
    let of_json j =
      {
        instance_statuses =
          (InstanceStatusList.of_json
             (Util.of_option_exn (Json.lookup j "instance_statuses")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateReservedInstancesListingResult =
  struct
    type t = {
      reserved_instances_listings: ReservedInstancesListingList.t }
    let make ?(reserved_instances_listings= [])  () =
      { reserved_instances_listings }
    let parse xml =
      Some
        {
          reserved_instances_listings =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesListingsSet" xml)
                  ReservedInstancesListingList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesListingsSet",
                   (ReservedInstancesListingList.to_query
                      v.reserved_instances_listings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "reservedInstancesListingsSet"
                      ([], (ReservedInstancesListingList.to_xml [x]))))
              v.reserved_instances_listings))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_listings",
                (ReservedInstancesListingList.to_json
                   v.reserved_instances_listings))])
    let of_json j =
      {
        reserved_instances_listings =
          (ReservedInstancesListingList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_listings")))
      }
  end
module RejectTransitGatewayPeeringAttachmentResult =
  struct
    type t =
      {
      transit_gateway_peering_attachment:
        TransitGatewayPeeringAttachment.t option }
    let make ?transit_gateway_peering_attachment  () =
      { transit_gateway_peering_attachment }
    let parse xml =
      Some
        {
          transit_gateway_peering_attachment =
            (Util.option_bind
               (Xml.member "transitGatewayPeeringAttachment" xml)
               TransitGatewayPeeringAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayPeeringAttachment",
                     (TransitGatewayPeeringAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayPeeringAttachment"
                   ([], (TransitGatewayPeeringAttachment.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 ("transit_gateway_peering_attachment",
                   (TransitGatewayPeeringAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_peering_attachment =
          (Util.option_map
             (Json.lookup j "transit_gateway_peering_attachment")
             TransitGatewayPeeringAttachment.of_json)
      }
  end
module DeleteInternetGatewayRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      internet_gateway_id: String.t }
    let make ?dry_run  ~internet_gateway_id  () =
      { dry_run; internet_gateway_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          internet_gateway_id =
            (Xml.required "internetGatewayId"
               (Util.option_bind (Xml.member "internetGatewayId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InternetGatewayId",
                   (String.to_query v.internet_gateway_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "internetGatewayId"
                 ([], (String.to_xml v.internet_gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("internet_gateway_id", (String.to_json v.internet_gateway_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        internet_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateway_id")))
      }
  end
module CreateVpnConnectionRouteRequest =
  struct
    type t = {
      destination_cidr_block: String.t ;
      vpn_connection_id: String.t }
    let make ~destination_cidr_block  ~vpn_connection_id  () =
      { destination_cidr_block; vpn_connection_id }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          vpn_connection_id =
            (Xml.required "VpnConnectionId"
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpnConnectionId", (String.to_query v.vpn_connection_id)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "DestinationCidrBlock"
                  ([], (String.to_xml v.destination_cidr_block)))])
           @
           [Some
              (Ezxmlm.make_tag "VpnConnectionId"
                 ([], (String.to_xml v.vpn_connection_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpn_connection_id", (String.to_json v.vpn_connection_id));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block))])
    let of_json j =
      {
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")))
      }
  end
module ModifyFleetResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module ConfirmProductInstanceRequest =
  struct
    type t =
      {
      instance_id: String.t ;
      product_code: String.t ;
      dry_run: Boolean.t option }
    let make ~instance_id  ~product_code  ?dry_run  () =
      { instance_id; product_code; dry_run }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          product_code =
            (Xml.required "ProductCode"
               (Util.option_bind (Xml.member "ProductCode" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("ProductCode", (String.to_query v.product_code)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "InstanceId"
                   ([], (String.to_xml v.instance_id)))])
            @
            [Some
               (Ezxmlm.make_tag "ProductCode"
                  ([], (String.to_xml v.product_code)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("product_code", (String.to_json v.product_code));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        product_code =
          (String.of_json (Util.of_option_exn (Json.lookup j "product_code")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateFpgaImageResult =
  struct
    type t =
      {
      fpga_image_id: String.t option ;
      fpga_image_global_id: String.t option }
    let make ?fpga_image_id  ?fpga_image_global_id  () =
      { fpga_image_id; fpga_image_global_id }
    let parse xml =
      Some
        {
          fpga_image_id =
            (Util.option_bind (Xml.member "fpgaImageId" xml) String.parse);
          fpga_image_global_id =
            (Util.option_bind (Xml.member "fpgaImageGlobalId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_global_id
              (fun f -> Query.Pair ("FpgaImageGlobalId", (String.to_query f)));
           Util.option_map v.fpga_image_id
             (fun f -> Query.Pair ("FpgaImageId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.fpga_image_id
               (fun f ->
                  Ezxmlm.make_tag "fpgaImageId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.fpga_image_global_id
              (fun f ->
                 Ezxmlm.make_tag "fpgaImageGlobalId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_global_id
              (fun f -> ("fpga_image_global_id", (String.to_json f)));
           Util.option_map v.fpga_image_id
             (fun f -> ("fpga_image_id", (String.to_json f)))])
    let of_json j =
      {
        fpga_image_id =
          (Util.option_map (Json.lookup j "fpga_image_id") String.of_json);
        fpga_image_global_id =
          (Util.option_map (Json.lookup j "fpga_image_global_id")
             String.of_json)
      }
  end
module DescribeImagesResult =
  struct
    type t = {
      images: ImageList.t }
    let make ?(images= [])  () = { images }
    let parse xml =
      Some
        {
          images =
            (Util.of_option []
               (Util.option_bind (Xml.member "imagesSet" xml) ImageList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("ImagesSet", (ImageList.to_query v.images)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "imagesSet" ([], (ImageList.to_xml [x]))))
              v.images))
    let to_json v =
      `Assoc
        (Util.list_filter_opt [Some ("images", (ImageList.to_json v.images))])
    let of_json j =
      {
        images =
          (ImageList.of_json (Util.of_option_exn (Json.lookup j "images")))
      }
  end
module CopyFpgaImageRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      source_fpga_image_id: String.t ;
      description: String.t option ;
      name: String.t option ;
      source_region: String.t ;
      client_token: String.t option }
    let make ?dry_run  ~source_fpga_image_id  ?description  ?name 
      ~source_region  ?client_token  () =
      {
        dry_run;
        source_fpga_image_id;
        description;
        name;
        source_region;
        client_token
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          source_fpga_image_id =
            (Xml.required "SourceFpgaImageId"
               (Util.option_bind (Xml.member "SourceFpgaImageId" xml)
                  String.parse));
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          source_region =
            (Xml.required "SourceRegion"
               (Util.option_bind (Xml.member "SourceRegion" xml) String.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair ("SourceRegion", (String.to_query v.source_region)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("SourceFpgaImageId",
                  (String.to_query v.source_fpga_image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.dry_run
                   (fun f ->
                      Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
               @
               [Some
                  (Ezxmlm.make_tag "SourceFpgaImageId"
                     ([], (String.to_xml v.source_fpga_image_id)))])
              @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
             @
             [Util.option_map v.name
                (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "SourceRegion"
                  ([], (String.to_xml v.source_region)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Some ("source_region", (String.to_json v.source_region));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some
             ("source_fpga_image_id",
               (String.to_json v.source_fpga_image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        source_fpga_image_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_fpga_image_id")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        source_region =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_region")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DeleteVpcEndpointServiceConfigurationsRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      service_ids: ValueStringList.t }
    let make ?dry_run  ~service_ids  () = { dry_run; service_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_ids =
            (Xml.required "ServiceId"
               (Util.option_bind (Xml.member "ServiceId" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ServiceId", (ValueStringList.to_query v.service_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "ServiceId"
                      ([], (ValueStringList.to_xml [x])))) v.service_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("service_ids", (ValueStringList.to_json v.service_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "service_ids")))
      }
  end
module CreateReservedInstancesListingRequest =
  struct
    type t =
      {
      client_token: String.t ;
      instance_count: Integer.t ;
      price_schedules: PriceScheduleSpecificationList.t ;
      reserved_instances_id: String.t }
    let make ~client_token  ~instance_count  ~price_schedules 
      ~reserved_instances_id  () =
      { client_token; instance_count; price_schedules; reserved_instances_id
      }
    let parse xml =
      Some
        {
          client_token =
            (Xml.required "clientToken"
               (Util.option_bind (Xml.member "clientToken" xml) String.parse));
          instance_count =
            (Xml.required "instanceCount"
               (Util.option_bind (Xml.member "instanceCount" xml)
                  Integer.parse));
          price_schedules =
            (Xml.required "priceSchedules"
               (Util.option_bind (Xml.member "priceSchedules" xml)
                  PriceScheduleSpecificationList.parse));
          reserved_instances_id =
            (Xml.required "reservedInstancesId"
               (Util.option_bind (Xml.member "reservedInstancesId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesId",
                   (String.to_query v.reserved_instances_id)));
           Some
             (Query.Pair
                ("PriceSchedules",
                  (PriceScheduleSpecificationList.to_query v.price_schedules)));
           Some
             (Query.Pair
                ("InstanceCount", (Integer.to_query v.instance_count)));
           Some
             (Query.Pair ("ClientToken", (String.to_query v.client_token)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "clientToken"
                    ([], (String.to_xml v.client_token)))])
             @
             [Some
                (Ezxmlm.make_tag "instanceCount"
                   ([], (Integer.to_xml v.instance_count)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "priceSchedules"
                       ([], (PriceScheduleSpecificationList.to_xml [x]))))
               v.price_schedules))
           @
           [Some
              (Ezxmlm.make_tag "reservedInstancesId"
                 ([], (String.to_xml v.reserved_instances_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_id",
                (String.to_json v.reserved_instances_id));
           Some
             ("price_schedules",
               (PriceScheduleSpecificationList.to_json v.price_schedules));
           Some ("instance_count", (Integer.to_json v.instance_count));
           Some ("client_token", (String.to_json v.client_token))])
    let of_json j =
      {
        client_token =
          (String.of_json (Util.of_option_exn (Json.lookup j "client_token")));
        instance_count =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "instance_count")));
        price_schedules =
          (PriceScheduleSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "price_schedules")));
        reserved_instances_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances_id")))
      }
  end
module DescribeImportSnapshotTasksResult =
  struct
    type t =
      {
      import_snapshot_tasks: ImportSnapshotTaskList.t ;
      next_token: String.t option }
    let make ?(import_snapshot_tasks= [])  ?next_token  () =
      { import_snapshot_tasks; next_token }
    let parse xml =
      Some
        {
          import_snapshot_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "importSnapshotTaskSet" xml)
                  ImportSnapshotTaskList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ImportSnapshotTaskSet",
                  (ImportSnapshotTaskList.to_query v.import_snapshot_tasks)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "importSnapshotTaskSet"
                       ([], (ImportSnapshotTaskList.to_xml [x]))))
               v.import_snapshot_tasks))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("import_snapshot_tasks",
               (ImportSnapshotTaskList.to_json v.import_snapshot_tasks))])
    let of_json j =
      {
        import_snapshot_tasks =
          (ImportSnapshotTaskList.of_json
             (Util.of_option_exn (Json.lookup j "import_snapshot_tasks")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateTrafficMirrorFilterRuleResult =
  struct
    type t =
      {
      traffic_mirror_filter_rule: TrafficMirrorFilterRule.t option ;
      client_token: String.t option }
    let make ?traffic_mirror_filter_rule  ?client_token  () =
      { traffic_mirror_filter_rule; client_token }
    let parse xml =
      Some
        {
          traffic_mirror_filter_rule =
            (Util.option_bind (Xml.member "trafficMirrorFilterRule" xml)
               TrafficMirrorFilterRule.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.traffic_mirror_filter_rule
             (fun f ->
                Query.Pair
                  ("TrafficMirrorFilterRule",
                    (TrafficMirrorFilterRule.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.traffic_mirror_filter_rule
               (fun f ->
                  Ezxmlm.make_tag "trafficMirrorFilterRule"
                    ([], (TrafficMirrorFilterRule.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.traffic_mirror_filter_rule
             (fun f ->
                ("traffic_mirror_filter_rule",
                  (TrafficMirrorFilterRule.to_json f)))])
    let of_json j =
      {
        traffic_mirror_filter_rule =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_rule")
             TrafficMirrorFilterRule.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeNetworkInterfacePermissionsResult =
  struct
    type t =
      {
      network_interface_permissions: NetworkInterfacePermissionList.t ;
      next_token: String.t option }
    let make ?(network_interface_permissions= [])  ?next_token  () =
      { network_interface_permissions; next_token }
    let parse xml =
      Some
        {
          network_interface_permissions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "networkInterfacePermissions" xml)
                  NetworkInterfacePermissionList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfacePermissions",
                  (NetworkInterfacePermissionList.to_query
                     v.network_interface_permissions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "networkInterfacePermissions"
                       ([], (NetworkInterfacePermissionList.to_xml [x]))))
               v.network_interface_permissions))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("network_interface_permissions",
               (NetworkInterfacePermissionList.to_json
                  v.network_interface_permissions))])
    let of_json j =
      {
        network_interface_permissions =
          (NetworkInterfacePermissionList.of_json
             (Util.of_option_exn
                (Json.lookup j "network_interface_permissions")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateTransitGatewayResult =
  struct
    type t = {
      transit_gateway: TransitGateway.t option }
    let make ?transit_gateway  () = { transit_gateway }
    let parse xml =
      Some
        {
          transit_gateway =
            (Util.option_bind (Xml.member "transitGateway" xml)
               TransitGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway
              (fun f ->
                 Query.Pair ("TransitGateway", (TransitGateway.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway
              (fun f ->
                 Ezxmlm.make_tag "transitGateway"
                   ([], (TransitGateway.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway
              (fun f -> ("transit_gateway", (TransitGateway.to_json f)))])
    let of_json j =
      {
        transit_gateway =
          (Util.option_map (Json.lookup j "transit_gateway")
             TransitGateway.of_json)
      }
  end
module DeleteVpnConnectionRequest =
  struct
    type t = {
      vpn_connection_id: String.t ;
      dry_run: Boolean.t option }
    let make ~vpn_connection_id  ?dry_run  () =
      { vpn_connection_id; dry_run }
    let parse xml =
      Some
        {
          vpn_connection_id =
            (Xml.required "VpnConnectionId"
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("VpnConnectionId", (String.to_query v.vpn_connection_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "VpnConnectionId"
                  ([], (String.to_xml v.vpn_connection_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpn_connection_id", (String.to_json v.vpn_connection_id))])
    let of_json j =
      {
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateTrafficMirrorTargetRequest =
  struct
    type t =
      {
      network_interface_id: String.t option ;
      network_load_balancer_arn: String.t option ;
      description: String.t option ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option ;
      client_token: String.t option }
    let make ?network_interface_id  ?network_load_balancer_arn  ?description 
      ?(tag_specifications= [])  ?dry_run  ?client_token  () =
      {
        network_interface_id;
        network_load_balancer_arn;
        description;
        tag_specifications;
        dry_run;
        client_token
      }
    let parse xml =
      Some
        {
          network_interface_id =
            (Util.option_bind (Xml.member "NetworkInterfaceId" xml)
               String.parse);
          network_load_balancer_arn =
            (Util.option_bind (Xml.member "NetworkLoadBalancerArn" xml)
               String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.network_load_balancer_arn
             (fun f ->
                Query.Pair ("NetworkLoadBalancerArn", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.network_interface_id
                   (fun f ->
                      Ezxmlm.make_tag "NetworkInterfaceId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.network_load_balancer_arn
                  (fun f ->
                     Ezxmlm.make_tag "NetworkLoadBalancerArn"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "TagSpecification"
                        ([], (TagSpecificationList.to_xml [x]))))
                v.tag_specifications))
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.network_load_balancer_arn
             (fun f -> ("network_load_balancer_arn", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)))])
    let of_json j =
      {
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        network_load_balancer_arn =
          (Util.option_map (Json.lookup j "network_load_balancer_arn")
             String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module CancelSpotInstanceRequestsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      spot_instance_request_ids: SpotInstanceRequestIdList.t }
    let make ?dry_run  ~spot_instance_request_ids  () =
      { dry_run; spot_instance_request_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          spot_instance_request_ids =
            (Xml.required "SpotInstanceRequestId"
               (Util.option_bind (Xml.member "SpotInstanceRequestId" xml)
                  SpotInstanceRequestIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotInstanceRequestId",
                   (SpotInstanceRequestIdList.to_query
                      v.spot_instance_request_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "SpotInstanceRequestId"
                      ([], (SpotInstanceRequestIdList.to_xml [x]))))
              v.spot_instance_request_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_instance_request_ids",
                (SpotInstanceRequestIdList.to_json
                   v.spot_instance_request_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        spot_instance_request_ids =
          (SpotInstanceRequestIdList.of_json
             (Util.of_option_exn (Json.lookup j "spot_instance_request_ids")))
      }
  end
module AssociateTransitGatewayRouteTableResult =
  struct
    type t = {
      association: TransitGatewayAssociation.t option }
    let make ?association  () = { association }
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               TransitGatewayAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association
              (fun f ->
                 Query.Pair
                   ("Association", (TransitGatewayAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.association
              (fun f ->
                 Ezxmlm.make_tag "association"
                   ([], (TransitGatewayAssociation.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association
              (fun f ->
                 ("association", (TransitGatewayAssociation.to_json f)))])
    let of_json j =
      {
        association =
          (Util.option_map (Json.lookup j "association")
             TransitGatewayAssociation.of_json)
      }
  end
module DescribeSpotPriceHistoryRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      availability_zone: String.t option ;
      dry_run: Boolean.t option ;
      end_time: DateTime.t option ;
      instance_types: InstanceTypeList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      product_descriptions: ProductDescriptionList.t ;
      start_time: DateTime.t option }
    let make ?(filters= [])  ?availability_zone  ?dry_run  ?end_time 
      ?(instance_types= [])  ?max_results  ?next_token 
      ?(product_descriptions= [])  ?start_time  () =
      {
        filters;
        availability_zone;
        dry_run;
        end_time;
        instance_types;
        max_results;
        next_token;
        product_descriptions;
        start_time
      }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          end_time =
            (Util.option_bind (Xml.member "endTime" xml) DateTime.parse);
          instance_types =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceType" xml)
                  InstanceTypeList.parse));
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          product_descriptions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ProductDescription" xml)
                  ProductDescriptionList.parse));
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.start_time
              (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("ProductDescription",
                  (ProductDescriptionList.to_query v.product_descriptions)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("InstanceType",
                  (InstanceTypeList.to_query v.instance_types)));
           Util.option_map v.end_time
             (fun f -> Query.Pair ("EndTime", (DateTime.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "Filter"
                              ([], (FilterList.to_xml [x])))) v.filters))
                  @
                  [Util.option_map v.availability_zone
                     (fun f ->
                        Ezxmlm.make_tag "availabilityZone"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.dry_run
                    (fun f ->
                       Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.end_time
                   (fun f ->
                      Ezxmlm.make_tag "endTime" ([], (DateTime.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "InstanceType"
                          ([], (InstanceTypeList.to_xml [x]))))
                  v.instance_types))
              @
              [Util.option_map v.max_results
                 (fun f ->
                    Ezxmlm.make_tag "maxResults" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ProductDescription"
                       ([], (ProductDescriptionList.to_xml [x]))))
               v.product_descriptions))
           @
           [Util.option_map v.start_time
              (fun f -> Ezxmlm.make_tag "startTime" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.start_time
              (fun f -> ("start_time", (DateTime.to_json f)));
           Some
             ("product_descriptions",
               (ProductDescriptionList.to_json v.product_descriptions));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("instance_types", (InstanceTypeList.to_json v.instance_types));
           Util.option_map v.end_time
             (fun f -> ("end_time", (DateTime.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        end_time =
          (Util.option_map (Json.lookup j "end_time") DateTime.of_json);
        instance_types =
          (InstanceTypeList.of_json
             (Util.of_option_exn (Json.lookup j "instance_types")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        product_descriptions =
          (ProductDescriptionList.of_json
             (Util.of_option_exn (Json.lookup j "product_descriptions")));
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json)
      }
  end
module CancelImportTaskResult =
  struct
    type t =
      {
      import_task_id: String.t option ;
      previous_state: String.t option ;
      state: String.t option }
    let make ?import_task_id  ?previous_state  ?state  () =
      { import_task_id; previous_state; state }
    let parse xml =
      Some
        {
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          previous_state =
            (Util.option_bind (Xml.member "previousState" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (String.to_query f)));
           Util.option_map v.previous_state
             (fun f -> Query.Pair ("PreviousState", (String.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.import_task_id
                (fun f ->
                   Ezxmlm.make_tag "importTaskId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.previous_state
               (fun f ->
                  Ezxmlm.make_tag "previousState" ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f -> Ezxmlm.make_tag "state" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.previous_state
             (fun f -> ("previous_state", (String.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)))])
    let of_json j =
      {
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json);
        previous_state =
          (Util.option_map (Json.lookup j "previous_state") String.of_json);
        state = (Util.option_map (Json.lookup j "state") String.of_json)
      }
  end
module DisassociateSubnetCidrBlockRequest =
  struct
    type t = {
      association_id: String.t }
    let make ~association_id  () = { association_id }
    let parse xml =
      Some
        {
          association_id =
            (Xml.required "associationId"
               (Util.option_bind (Xml.member "associationId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AssociationId", (String.to_query v.association_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "associationId"
                 ([], (String.to_xml v.association_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("association_id", (String.to_json v.association_id))])
    let of_json j =
      {
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")))
      }
  end
module ModifyTrafficMirrorFilterNetworkServicesResult =
  struct
    type t = {
      traffic_mirror_filter: TrafficMirrorFilter.t option }
    let make ?traffic_mirror_filter  () = { traffic_mirror_filter }
    let parse xml =
      Some
        {
          traffic_mirror_filter =
            (Util.option_bind (Xml.member "trafficMirrorFilter" xml)
               TrafficMirrorFilter.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter
              (fun f ->
                 Query.Pair
                   ("TrafficMirrorFilter", (TrafficMirrorFilter.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.traffic_mirror_filter
              (fun f ->
                 Ezxmlm.make_tag "trafficMirrorFilter"
                   ([], (TrafficMirrorFilter.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter
              (fun f ->
                 ("traffic_mirror_filter", (TrafficMirrorFilter.to_json f)))])
    let of_json j =
      {
        traffic_mirror_filter =
          (Util.option_map (Json.lookup j "traffic_mirror_filter")
             TrafficMirrorFilter.of_json)
      }
  end
module ResetInstanceAttributeRequest =
  struct
    type t =
      {
      attribute: InstanceAttributeName.t ;
      dry_run: Boolean.t option ;
      instance_id: String.t }
    let make ~attribute  ?dry_run  ~instance_id  () =
      { attribute; dry_run; instance_id }
    let parse xml =
      Some
        {
          attribute =
            (Xml.required "attribute"
               (Util.option_bind (Xml.member "attribute" xml)
                  InstanceAttributeName.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("Attribute", (InstanceAttributeName.to_query v.attribute)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "attribute"
                   ([], (InstanceAttributeName.to_xml v.attribute)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "instanceId"
                 ([], (String.to_xml v.instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("attribute", (InstanceAttributeName.to_json v.attribute))])
    let of_json j =
      {
        attribute =
          (InstanceAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")))
      }
  end
module CopySnapshotResult =
  struct
    type t = {
      snapshot_id: String.t option ;
      tags: TagList.t }
    let make ?snapshot_id  ?(tags= [])  () = { snapshot_id; tags }
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.snapshot_id
               (fun f -> Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let of_json j =
      {
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module AllocateHostsResult =
  struct
    type t = {
      host_ids: ResponseHostIdList.t }
    let make ?(host_ids= [])  () = { host_ids }
    let parse xml =
      Some
        {
          host_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostIdSet" xml)
                  ResponseHostIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("HostIdSet", (ResponseHostIdList.to_query v.host_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "hostIdSet"
                      ([], (ResponseHostIdList.to_xml [x])))) v.host_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("host_ids", (ResponseHostIdList.to_json v.host_ids))])
    let of_json j =
      {
        host_ids =
          (ResponseHostIdList.of_json
             (Util.of_option_exn (Json.lookup j "host_ids")))
      }
  end
module DeleteTrafficMirrorTargetRequest =
  struct
    type t = {
      traffic_mirror_target_id: String.t ;
      dry_run: Boolean.t option }
    let make ~traffic_mirror_target_id  ?dry_run  () =
      { traffic_mirror_target_id; dry_run }
    let parse xml =
      Some
        {
          traffic_mirror_target_id =
            (Xml.required "TrafficMirrorTargetId"
               (Util.option_bind (Xml.member "TrafficMirrorTargetId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorTargetId",
                  (String.to_query v.traffic_mirror_target_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "TrafficMirrorTargetId"
                  ([], (String.to_xml v.traffic_mirror_target_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("traffic_mirror_target_id",
               (String.to_json v.traffic_mirror_target_id))])
    let of_json j =
      {
        traffic_mirror_target_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_target_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AdvertiseByoipCidrRequest =
  struct
    type t = {
      cidr: String.t ;
      dry_run: Boolean.t option }
    let make ~cidr  ?dry_run  () = { cidr; dry_run }
    let parse xml =
      Some
        {
          cidr =
            (Xml.required "Cidr"
               (Util.option_bind (Xml.member "Cidr" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Cidr", (String.to_query v.cidr)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Cidr" ([], (String.to_xml v.cidr)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("cidr", (String.to_json v.cidr))])
    let of_json j =
      {
        cidr = (String.of_json (Util.of_option_exn (Json.lookup j "cidr")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module SearchTransitGatewayMulticastGroupsRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?transit_gateway_multicast_domain_id  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        transit_gateway_multicast_domain_id;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.transit_gateway_multicast_domain_id
                  (fun f ->
                     Ezxmlm.make_tag "TransitGatewayMulticastDomainId"
                       ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateVpnGatewayResult =
  struct
    type t = {
      vpn_gateway: VpnGateway.t option }
    let make ?vpn_gateway  () = { vpn_gateway }
    let parse xml =
      Some
        {
          vpn_gateway =
            (Util.option_bind (Xml.member "vpnGateway" xml) VpnGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_gateway
              (fun f -> Query.Pair ("VpnGateway", (VpnGateway.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpn_gateway
              (fun f ->
                 Ezxmlm.make_tag "vpnGateway" ([], (VpnGateway.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_gateway
              (fun f -> ("vpn_gateway", (VpnGateway.to_json f)))])
    let of_json j =
      {
        vpn_gateway =
          (Util.option_map (Json.lookup j "vpn_gateway") VpnGateway.of_json)
      }
  end
module CreateCapacityReservationResult =
  struct
    type t = {
      capacity_reservation: CapacityReservation.t option }
    let make ?capacity_reservation  () = { capacity_reservation }
    let parse xml =
      Some
        {
          capacity_reservation =
            (Util.option_bind (Xml.member "capacityReservation" xml)
               CapacityReservation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation
              (fun f ->
                 Query.Pair
                   ("CapacityReservation", (CapacityReservation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.capacity_reservation
              (fun f ->
                 Ezxmlm.make_tag "capacityReservation"
                   ([], (CapacityReservation.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation
              (fun f ->
                 ("capacity_reservation", (CapacityReservation.to_json f)))])
    let of_json j =
      {
        capacity_reservation =
          (Util.option_map (Json.lookup j "capacity_reservation")
             CapacityReservation.of_json)
      }
  end
module CreateLaunchTemplateVersionResult =
  struct
    type t = {
      launch_template_version: LaunchTemplateVersion.t option }
    let make ?launch_template_version  () = { launch_template_version }
    let parse xml =
      Some
        {
          launch_template_version =
            (Util.option_bind (Xml.member "launchTemplateVersion" xml)
               LaunchTemplateVersion.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template_version
              (fun f ->
                 Query.Pair
                   ("LaunchTemplateVersion",
                     (LaunchTemplateVersion.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.launch_template_version
              (fun f ->
                 Ezxmlm.make_tag "launchTemplateVersion"
                   ([], (LaunchTemplateVersion.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template_version
              (fun f ->
                 ("launch_template_version",
                   (LaunchTemplateVersion.to_json f)))])
    let of_json j =
      {
        launch_template_version =
          (Util.option_map (Json.lookup j "launch_template_version")
             LaunchTemplateVersion.of_json)
      }
  end
module DescribeHostsResult =
  struct
    type t = {
      hosts: HostList.t ;
      next_token: String.t option }
    let make ?(hosts= [])  ?next_token  () = { hosts; next_token }
    let parse xml =
      Some
        {
          hosts =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostSet" xml) HostList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("HostSet", (HostList.to_query v.hosts)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "hostSet" ([], (HostList.to_xml [x]))))
               v.hosts))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("hosts", (HostList.to_json v.hosts))])
    let of_json j =
      {
        hosts =
          (HostList.of_json (Util.of_option_exn (Json.lookup j "hosts")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeCustomerGatewaysRequest =
  struct
    type t =
      {
      customer_gateway_ids: CustomerGatewayIdStringList.t ;
      filters: FilterList.t ;
      dry_run: Boolean.t option }
    let make ?(customer_gateway_ids= [])  ?(filters= [])  ?dry_run  () =
      { customer_gateway_ids; filters; dry_run }
    let parse xml =
      Some
        {
          customer_gateway_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "CustomerGatewayId" xml)
                  CustomerGatewayIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("CustomerGatewayId",
                  (CustomerGatewayIdStringList.to_query
                     v.customer_gateway_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "CustomerGatewayId"
                        ([], (CustomerGatewayIdStringList.to_xml [x]))))
                v.customer_gateway_ids))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
               v.filters))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("customer_gateway_ids",
               (CustomerGatewayIdStringList.to_json v.customer_gateway_ids))])
    let of_json j =
      {
        customer_gateway_ids =
          (CustomerGatewayIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateway_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisassociateTransitGatewayMulticastDomainResult =
  struct
    type t =
      {
      associations: TransitGatewayMulticastDomainAssociations.t option }
    let make ?associations  () = { associations }
    let parse xml =
      Some
        {
          associations =
            (Util.option_bind (Xml.member "associations" xml)
               TransitGatewayMulticastDomainAssociations.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.associations
              (fun f ->
                 Query.Pair
                   ("Associations",
                     (TransitGatewayMulticastDomainAssociations.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.associations
              (fun f ->
                 Ezxmlm.make_tag "associations"
                   ([], (TransitGatewayMulticastDomainAssociations.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.associations
              (fun f ->
                 ("associations",
                   (TransitGatewayMulticastDomainAssociations.to_json f)))])
    let of_json j =
      {
        associations =
          (Util.option_map (Json.lookup j "associations")
             TransitGatewayMulticastDomainAssociations.of_json)
      }
  end
module DescribeLaunchTemplatesResult =
  struct
    type t =
      {
      launch_templates: LaunchTemplateSet.t ;
      next_token: String.t option }
    let make ?(launch_templates= [])  ?next_token  () =
      { launch_templates; next_token }
    let parse xml =
      Some
        {
          launch_templates =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchTemplates" xml)
                  LaunchTemplateSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LaunchTemplates",
                  (LaunchTemplateSet.to_query v.launch_templates)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "launchTemplates"
                       ([], (LaunchTemplateSet.to_xml [x]))))
               v.launch_templates))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("launch_templates",
               (LaunchTemplateSet.to_json v.launch_templates))])
    let of_json j =
      {
        launch_templates =
          (LaunchTemplateSet.of_json
             (Util.of_option_exn (Json.lookup j "launch_templates")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribePrefixListsResult =
  struct
    type t = {
      next_token: String.t option ;
      prefix_lists: PrefixListSet.t }
    let make ?next_token  ?(prefix_lists= [])  () =
      { next_token; prefix_lists }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          prefix_lists =
            (Util.of_option []
               (Util.option_bind (Xml.member "prefixListSet" xml)
                  PrefixListSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PrefixListSet", (PrefixListSet.to_query v.prefix_lists)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "prefixListSet"
                      ([], (PrefixListSet.to_xml [x])))) v.prefix_lists))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("prefix_lists", (PrefixListSet.to_json v.prefix_lists));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        prefix_lists =
          (PrefixListSet.of_json
             (Util.of_option_exn (Json.lookup j "prefix_lists")))
      }
  end
module GetTransitGatewayAttachmentPropagationsRequest =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_attachment_id  ?(filters= [])  ?max_results 
      ?next_token  ?dry_run  () =
      {
        transit_gateway_attachment_id;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "TransitGatewayAttachmentId"
                     ([], (String.to_xml v.transit_gateway_attachment_id)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateTransitGatewayMulticastDomainRequest =
  struct
    type t =
      {
      transit_gateway_id: String.t ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_id  ?(tag_specifications= [])  ?dry_run  () =
      { transit_gateway_id; tag_specifications; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Xml.required "TransitGatewayId"
               (Util.option_bind (Xml.member "TransitGatewayId" xml)
                  String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some
             (Query.Pair
                ("TransitGatewayId", (String.to_query v.transit_gateway_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "TransitGatewayId"
                   ([], (String.to_xml v.transit_gateway_id)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "TagSpecification"
                       ([], (TagSpecificationList.to_xml [x]))))
               v.tag_specifications))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("transit_gateway_id", (String.to_json v.transit_gateway_id))])
    let of_json j =
      {
        transit_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "transit_gateway_id")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteLocalGatewayRouteRequest =
  struct
    type t =
      {
      destination_cidr_block: String.t ;
      local_gateway_route_table_id: String.t ;
      dry_run: Boolean.t option }
    let make ~destination_cidr_block  ~local_gateway_route_table_id  ?dry_run
       () = { destination_cidr_block; local_gateway_route_table_id; dry_run }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          local_gateway_route_table_id =
            (Xml.required "LocalGatewayRouteTableId"
               (Util.option_bind (Xml.member "LocalGatewayRouteTableId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableId",
                  (String.to_query v.local_gateway_route_table_id)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "DestinationCidrBlock"
                   ([], (String.to_xml v.destination_cidr_block)))])
            @
            [Some
               (Ezxmlm.make_tag "LocalGatewayRouteTableId"
                  ([], (String.to_xml v.local_gateway_route_table_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("local_gateway_route_table_id",
               (String.to_json v.local_gateway_route_table_id));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block))])
    let of_json j =
      {
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        local_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_route_table_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeTrafficMirrorSessionsRequest =
  struct
    type t =
      {
      traffic_mirror_session_ids: ValueStringList.t ;
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(traffic_mirror_session_ids= [])  ?dry_run  ?(filters= []) 
      ?max_results  ?next_token  () =
      { traffic_mirror_session_ids; dry_run; filters; max_results; next_token
      }
    let parse xml =
      Some
        {
          traffic_mirror_session_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "TrafficMirrorSessionId" xml)
                  ValueStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorSessionId",
                  (ValueStringList.to_query v.traffic_mirror_session_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "TrafficMirrorSessionId"
                          ([], (ValueStringList.to_xml [x]))))
                  v.traffic_mirror_session_ids))
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("traffic_mirror_session_ids",
               (ValueStringList.to_json v.traffic_mirror_session_ids))])
    let of_json j =
      {
        traffic_mirror_session_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_session_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeprovisionByoipCidrResult =
  struct
    type t = {
      byoip_cidr: ByoipCidr.t option }
    let make ?byoip_cidr  () = { byoip_cidr }
    let parse xml =
      Some
        {
          byoip_cidr =
            (Util.option_bind (Xml.member "byoipCidr" xml) ByoipCidr.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> Query.Pair ("ByoipCidr", (ByoipCidr.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.byoip_cidr
              (fun f ->
                 Ezxmlm.make_tag "byoipCidr" ([], (ByoipCidr.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> ("byoip_cidr", (ByoipCidr.to_json f)))])
    let of_json j =
      {
        byoip_cidr =
          (Util.option_map (Json.lookup j "byoip_cidr") ByoipCidr.of_json)
      }
  end
module DescribeVpnConnectionsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      vpn_connection_ids: VpnConnectionIdStringList.t ;
      dry_run: Boolean.t option }
    let make ?(filters= [])  ?(vpn_connection_ids= [])  ?dry_run  () =
      { filters; vpn_connection_ids; dry_run }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          vpn_connection_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  VpnConnectionIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("VpnConnectionId",
                  (VpnConnectionIdStringList.to_query v.vpn_connection_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "VpnConnectionId"
                       ([], (VpnConnectionIdStringList.to_xml [x]))))
               v.vpn_connection_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("vpn_connection_ids",
               (VpnConnectionIdStringList.to_json v.vpn_connection_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        vpn_connection_ids =
          (VpnConnectionIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyInstancePlacementResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module ModifyVolumeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      volume_id: String.t ;
      size: Integer.t option ;
      volume_type: VolumeType.t option ;
      iops: Integer.t option }
    let make ?dry_run  ~volume_id  ?size  ?volume_type  ?iops  () =
      { dry_run; volume_id; size; volume_type; iops }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          size = (Util.option_bind (Xml.member "Size" xml) Integer.parse);
          volume_type =
            (Util.option_bind (Xml.member "VolumeType" xml) VolumeType.parse);
          iops = (Util.option_bind (Xml.member "Iops" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.iops
              (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.volume_type
             (fun f -> Query.Pair ("VolumeType", (VolumeType.to_query f)));
           Util.option_map v.size
             (fun f -> Query.Pair ("Size", (Integer.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              [Some
                 (Ezxmlm.make_tag "VolumeId"
                    ([], (String.to_xml v.volume_id)))])
             @
             [Util.option_map v.size
                (fun f -> Ezxmlm.make_tag "Size" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.volume_type
               (fun f ->
                  Ezxmlm.make_tag "VolumeType" ([], (VolumeType.to_xml f)))])
           @
           [Util.option_map v.iops
              (fun f -> Ezxmlm.make_tag "Iops" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.volume_type
             (fun f -> ("volume_type", (VolumeType.to_json f)));
           Util.option_map v.size (fun f -> ("size", (Integer.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        size = (Util.option_map (Json.lookup j "size") Integer.of_json);
        volume_type =
          (Util.option_map (Json.lookup j "volume_type") VolumeType.of_json);
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json)
      }
  end
module GetDefaultCreditSpecificationResult =
  struct
    type t =
      {
      instance_family_credit_specification:
        InstanceFamilyCreditSpecification.t option }
    let make ?instance_family_credit_specification  () =
      { instance_family_credit_specification }
    let parse xml =
      Some
        {
          instance_family_credit_specification =
            (Util.option_bind
               (Xml.member "instanceFamilyCreditSpecification" xml)
               InstanceFamilyCreditSpecification.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_family_credit_specification
              (fun f ->
                 Query.Pair
                   ("InstanceFamilyCreditSpecification",
                     (InstanceFamilyCreditSpecification.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.instance_family_credit_specification
              (fun f ->
                 Ezxmlm.make_tag "instanceFamilyCreditSpecification"
                   ([], (InstanceFamilyCreditSpecification.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_family_credit_specification
              (fun f ->
                 ("instance_family_credit_specification",
                   (InstanceFamilyCreditSpecification.to_json f)))])
    let of_json j =
      {
        instance_family_credit_specification =
          (Util.option_map
             (Json.lookup j "instance_family_credit_specification")
             InstanceFamilyCreditSpecification.of_json)
      }
  end
module DeleteLaunchTemplateResult =
  struct
    type t = {
      launch_template: LaunchTemplate.t option }
    let make ?launch_template  () = { launch_template }
    let parse xml =
      Some
        {
          launch_template =
            (Util.option_bind (Xml.member "launchTemplate" xml)
               LaunchTemplate.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template
              (fun f ->
                 Query.Pair ("LaunchTemplate", (LaunchTemplate.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.launch_template
              (fun f ->
                 Ezxmlm.make_tag "launchTemplate"
                   ([], (LaunchTemplate.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template
              (fun f -> ("launch_template", (LaunchTemplate.to_json f)))])
    let of_json j =
      {
        launch_template =
          (Util.option_map (Json.lookup j "launch_template")
             LaunchTemplate.of_json)
      }
  end
module DescribeSpotFleetInstancesResponse =
  struct
    type t =
      {
      active_instances: ActiveInstanceSet.t ;
      next_token: String.t option ;
      spot_fleet_request_id: String.t option }
    let make ?(active_instances= [])  ?next_token  ?spot_fleet_request_id  ()
      = { active_instances; next_token; spot_fleet_request_id }
    let parse xml =
      Some
        {
          active_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "activeInstanceSet" xml)
                  ActiveInstanceSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Query.Pair ("SpotFleetRequestId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ActiveInstanceSet",
                  (ActiveInstanceSet.to_query v.active_instances)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "activeInstanceSet"
                        ([], (ActiveInstanceSet.to_xml [x]))))
                v.active_instances))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Ezxmlm.make_tag "spotFleetRequestId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f -> ("spot_fleet_request_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("active_instances",
               (ActiveInstanceSet.to_json v.active_instances))])
    let of_json j =
      {
        active_instances =
          (ActiveInstanceSet.of_json
             (Util.of_option_exn (Json.lookup j "active_instances")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        spot_fleet_request_id =
          (Util.option_map (Json.lookup j "spot_fleet_request_id")
             String.of_json)
      }
  end
module DescribeSnapshotAttributeRequest =
  struct
    type t =
      {
      attribute: SnapshotAttributeName.t ;
      snapshot_id: String.t ;
      dry_run: Boolean.t option }
    let make ~attribute  ~snapshot_id  ?dry_run  () =
      { attribute; snapshot_id; dry_run }
    let parse xml =
      Some
        {
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  SnapshotAttributeName.parse));
          snapshot_id =
            (Xml.required "SnapshotId"
               (Util.option_bind (Xml.member "SnapshotId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Some
             (Query.Pair
                ("Attribute", (SnapshotAttributeName.to_query v.attribute)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "Attribute"
                   ([], (SnapshotAttributeName.to_xml v.attribute)))])
            @
            [Some
               (Ezxmlm.make_tag "SnapshotId"
                  ([], (String.to_xml v.snapshot_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("snapshot_id", (String.to_json v.snapshot_id));
           Some ("attribute", (SnapshotAttributeName.to_json v.attribute))])
    let of_json j =
      {
        attribute =
          (SnapshotAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")));
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DetachClassicLinkVpcRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      vpc_id: String.t }
    let make ?dry_run  ~instance_id  ~vpc_id  () =
      { dry_run; instance_id; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "instanceId"
                  ([], (String.to_xml v.instance_id)))])
           @ [Some (Ezxmlm.make_tag "vpcId" ([], (String.to_xml v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module AttachClassicLinkVpcRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      groups: GroupIdStringList.t ;
      instance_id: String.t ;
      vpc_id: String.t }
    let make ?dry_run  ~groups  ~instance_id  ~vpc_id  () =
      { dry_run; groups; instance_id; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          groups =
            (Xml.required "SecurityGroupId"
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  GroupIdStringList.parse));
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Some
             (Query.Pair
                ("SecurityGroupId", (GroupIdStringList.to_query v.groups)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "SecurityGroupId"
                        ([], (GroupIdStringList.to_xml [x])))) v.groups))
            @
            [Some
               (Ezxmlm.make_tag "instanceId"
                  ([], (String.to_xml v.instance_id)))])
           @ [Some (Ezxmlm.make_tag "vpcId" ([], (String.to_xml v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("instance_id", (String.to_json v.instance_id));
           Some ("groups", (GroupIdStringList.to_json v.groups));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        groups =
          (GroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module ModifyInstanceAttributeRequest =
  struct
    type t =
      {
      source_dest_check: AttributeBooleanValue.t option ;
      attribute: InstanceAttributeName.t option ;
      block_device_mappings: InstanceBlockDeviceMappingSpecificationList.t ;
      disable_api_termination: AttributeBooleanValue.t option ;
      dry_run: Boolean.t option ;
      ebs_optimized: AttributeBooleanValue.t option ;
      ena_support: AttributeBooleanValue.t option ;
      groups: GroupIdStringList.t ;
      instance_id: String.t ;
      instance_initiated_shutdown_behavior: AttributeValue.t option ;
      instance_type: AttributeValue.t option ;
      kernel: AttributeValue.t option ;
      ramdisk: AttributeValue.t option ;
      sriov_net_support: AttributeValue.t option ;
      user_data: BlobAttributeValue.t option ;
      value: String.t option }
    let make ?source_dest_check  ?attribute  ?(block_device_mappings= []) 
      ?disable_api_termination  ?dry_run  ?ebs_optimized  ?ena_support 
      ?(groups= [])  ~instance_id  ?instance_initiated_shutdown_behavior 
      ?instance_type  ?kernel  ?ramdisk  ?sriov_net_support  ?user_data 
      ?value  () =
      {
        source_dest_check;
        attribute;
        block_device_mappings;
        disable_api_termination;
        dry_run;
        ebs_optimized;
        ena_support;
        groups;
        instance_id;
        instance_initiated_shutdown_behavior;
        instance_type;
        kernel;
        ramdisk;
        sriov_net_support;
        user_data;
        value
      }
    let parse xml =
      Some
        {
          source_dest_check =
            (Util.option_bind (Xml.member "SourceDestCheck" xml)
               AttributeBooleanValue.parse);
          attribute =
            (Util.option_bind (Xml.member "attribute" xml)
               InstanceAttributeName.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  InstanceBlockDeviceMappingSpecificationList.parse));
          disable_api_termination =
            (Util.option_bind (Xml.member "disableApiTermination" xml)
               AttributeBooleanValue.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml)
               AttributeBooleanValue.parse);
          ena_support =
            (Util.option_bind (Xml.member "enaSupport" xml)
               AttributeBooleanValue.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupId" xml)
                  GroupIdStringList.parse));
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               AttributeValue.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               AttributeValue.parse);
          kernel =
            (Util.option_bind (Xml.member "kernel" xml) AttributeValue.parse);
          ramdisk =
            (Util.option_bind (Xml.member "ramdisk" xml) AttributeValue.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml)
               AttributeValue.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml)
               BlobAttributeValue.parse);
          value = (Util.option_bind (Xml.member "value" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)));
           Util.option_map v.user_data
             (fun f ->
                Query.Pair ("UserData", (BlobAttributeValue.to_query f)));
           Util.option_map v.sriov_net_support
             (fun f ->
                Query.Pair ("SriovNetSupport", (AttributeValue.to_query f)));
           Util.option_map v.ramdisk
             (fun f -> Query.Pair ("Ramdisk", (AttributeValue.to_query f)));
           Util.option_map v.kernel
             (fun f -> Query.Pair ("Kernel", (AttributeValue.to_query f)));
           Util.option_map v.instance_type
             (fun f ->
                Query.Pair ("InstanceType", (AttributeValue.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (AttributeValue.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Some
             (Query.Pair ("GroupId", (GroupIdStringList.to_query v.groups)));
           Util.option_map v.ena_support
             (fun f ->
                Query.Pair ("EnaSupport", (AttributeBooleanValue.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f ->
                Query.Pair
                  ("EbsOptimized", (AttributeBooleanValue.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                Query.Pair
                  ("DisableApiTermination",
                    (AttributeBooleanValue.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (InstanceBlockDeviceMappingSpecificationList.to_query
                     v.block_device_mappings)));
           Util.option_map v.attribute
             (fun f ->
                Query.Pair ("Attribute", (InstanceAttributeName.to_query f)));
           Util.option_map v.source_dest_check
             (fun f ->
                Query.Pair
                  ("SourceDestCheck", (AttributeBooleanValue.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((([] @
                          [Util.option_map v.source_dest_check
                             (fun f ->
                                Ezxmlm.make_tag "SourceDestCheck"
                                  ([], (AttributeBooleanValue.to_xml f)))])
                         @
                         [Util.option_map v.attribute
                            (fun f ->
                               Ezxmlm.make_tag "attribute"
                                 ([], (InstanceAttributeName.to_xml f)))])
                        @
                        (List.map
                           (fun x ->
                              Some
                                (Ezxmlm.make_tag "blockDeviceMapping"
                                   ([],
                                     (InstanceBlockDeviceMappingSpecificationList.to_xml
                                        [x])))) v.block_device_mappings))
                       @
                       [Util.option_map v.disable_api_termination
                          (fun f ->
                             Ezxmlm.make_tag "disableApiTermination"
                               ([], (AttributeBooleanValue.to_xml f)))])
                      @
                      [Util.option_map v.dry_run
                         (fun f ->
                            Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.ebs_optimized
                        (fun f ->
                           Ezxmlm.make_tag "ebsOptimized"
                             ([], (AttributeBooleanValue.to_xml f)))])
                    @
                    [Util.option_map v.ena_support
                       (fun f ->
                          Ezxmlm.make_tag "enaSupport"
                            ([], (AttributeBooleanValue.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "GroupId"
                              ([], (GroupIdStringList.to_xml [x])))) v.groups))
                  @
                  [Some
                     (Ezxmlm.make_tag "instanceId"
                        ([], (String.to_xml v.instance_id)))])
                 @
                 [Util.option_map v.instance_initiated_shutdown_behavior
                    (fun f ->
                       Ezxmlm.make_tag "instanceInitiatedShutdownBehavior"
                         ([], (AttributeValue.to_xml f)))])
                @
                [Util.option_map v.instance_type
                   (fun f ->
                      Ezxmlm.make_tag "instanceType"
                        ([], (AttributeValue.to_xml f)))])
               @
               [Util.option_map v.kernel
                  (fun f ->
                     Ezxmlm.make_tag "kernel" ([], (AttributeValue.to_xml f)))])
              @
              [Util.option_map v.ramdisk
                 (fun f ->
                    Ezxmlm.make_tag "ramdisk" ([], (AttributeValue.to_xml f)))])
             @
             [Util.option_map v.sriov_net_support
                (fun f ->
                   Ezxmlm.make_tag "sriovNetSupport"
                     ([], (AttributeValue.to_xml f)))])
            @
            [Util.option_map v.user_data
               (fun f ->
                  Ezxmlm.make_tag "userData"
                    ([], (BlobAttributeValue.to_xml f)))])
           @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)));
           Util.option_map v.user_data
             (fun f -> ("user_data", (BlobAttributeValue.to_json f)));
           Util.option_map v.sriov_net_support
             (fun f -> ("sriov_net_support", (AttributeValue.to_json f)));
           Util.option_map v.ramdisk
             (fun f -> ("ramdisk", (AttributeValue.to_json f)));
           Util.option_map v.kernel
             (fun f -> ("kernel", (AttributeValue.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (AttributeValue.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (AttributeValue.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id));
           Some ("groups", (GroupIdStringList.to_json v.groups));
           Util.option_map v.ena_support
             (fun f -> ("ena_support", (AttributeBooleanValue.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (AttributeBooleanValue.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                ("disable_api_termination",
                  (AttributeBooleanValue.to_json f)));
           Some
             ("block_device_mappings",
               (InstanceBlockDeviceMappingSpecificationList.to_json
                  v.block_device_mappings));
           Util.option_map v.attribute
             (fun f -> ("attribute", (InstanceAttributeName.to_json f)));
           Util.option_map v.source_dest_check
             (fun f ->
                ("source_dest_check", (AttributeBooleanValue.to_json f)))])
    let of_json j =
      {
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             AttributeBooleanValue.of_json);
        attribute =
          (Util.option_map (Json.lookup j "attribute")
             InstanceAttributeName.of_json);
        block_device_mappings =
          (InstanceBlockDeviceMappingSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        disable_api_termination =
          (Util.option_map (Json.lookup j "disable_api_termination")
             AttributeBooleanValue.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized")
             AttributeBooleanValue.of_json);
        ena_support =
          (Util.option_map (Json.lookup j "ena_support")
             AttributeBooleanValue.of_json);
        groups =
          (GroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        instance_initiated_shutdown_behavior =
          (Util.option_map
             (Json.lookup j "instance_initiated_shutdown_behavior")
             AttributeValue.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             AttributeValue.of_json);
        kernel =
          (Util.option_map (Json.lookup j "kernel") AttributeValue.of_json);
        ramdisk =
          (Util.option_map (Json.lookup j "ramdisk") AttributeValue.of_json);
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support")
             AttributeValue.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data")
             BlobAttributeValue.of_json);
        value = (Util.option_map (Json.lookup j "value") String.of_json)
      }
  end
module DescribeFpgaImageAttributeResult =
  struct
    type t = {
      fpga_image_attribute: FpgaImageAttribute.t option }
    let make ?fpga_image_attribute  () = { fpga_image_attribute }
    let parse xml =
      Some
        {
          fpga_image_attribute =
            (Util.option_bind (Xml.member "fpgaImageAttribute" xml)
               FpgaImageAttribute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_attribute
              (fun f ->
                 Query.Pair
                   ("FpgaImageAttribute", (FpgaImageAttribute.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.fpga_image_attribute
              (fun f ->
                 Ezxmlm.make_tag "fpgaImageAttribute"
                   ([], (FpgaImageAttribute.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_attribute
              (fun f ->
                 ("fpga_image_attribute", (FpgaImageAttribute.to_json f)))])
    let of_json j =
      {
        fpga_image_attribute =
          (Util.option_map (Json.lookup j "fpga_image_attribute")
             FpgaImageAttribute.of_json)
      }
  end
module CreateSnapshotsRequest =
  struct
    type t =
      {
      description: String.t option ;
      instance_specification: InstanceSpecification.t ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option ;
      copy_tags_from_source: CopyTagsFromSource.t option }
    let make ?description  ~instance_specification  ?(tag_specifications= [])
       ?dry_run  ?copy_tags_from_source  () =
      {
        description;
        instance_specification;
        tag_specifications;
        dry_run;
        copy_tags_from_source
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          instance_specification =
            (Xml.required "InstanceSpecification"
               (Util.option_bind (Xml.member "InstanceSpecification" xml)
                  InstanceSpecification.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          copy_tags_from_source =
            (Util.option_bind (Xml.member "CopyTagsFromSource" xml)
               CopyTagsFromSource.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.copy_tags_from_source
              (fun f ->
                 Query.Pair
                   ("CopyTagsFromSource", (CopyTagsFromSource.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some
             (Query.Pair
                ("InstanceSpecification",
                  (InstanceSpecification.to_query v.instance_specification)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.description
                  (fun f ->
                     Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
              @
              [Some
                 (Ezxmlm.make_tag "InstanceSpecification"
                    ([],
                      (InstanceSpecification.to_xml v.instance_specification)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "TagSpecification"
                        ([], (TagSpecificationList.to_xml [x]))))
                v.tag_specifications))
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.copy_tags_from_source
              (fun f ->
                 Ezxmlm.make_tag "CopyTagsFromSource"
                   ([], (CopyTagsFromSource.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.copy_tags_from_source
              (fun f ->
                 ("copy_tags_from_source", (CopyTagsFromSource.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some
             ("instance_specification",
               (InstanceSpecification.to_json v.instance_specification));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        instance_specification =
          (InstanceSpecification.of_json
             (Util.of_option_exn (Json.lookup j "instance_specification")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        copy_tags_from_source =
          (Util.option_map (Json.lookup j "copy_tags_from_source")
             CopyTagsFromSource.of_json)
      }
  end
module CreateDefaultSubnetResult =
  struct
    type t = {
      subnet: Subnet.t option }
    let make ?subnet  () = { subnet }
    let parse xml =
      Some
        { subnet = (Util.option_bind (Xml.member "subnet" xml) Subnet.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> Query.Pair ("Subnet", (Subnet.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.subnet
              (fun f -> Ezxmlm.make_tag "subnet" ([], (Subnet.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> ("subnet", (Subnet.to_json f)))])
    let of_json j =
      { subnet = (Util.option_map (Json.lookup j "subnet") Subnet.of_json) }
  end
module AssociateTransitGatewayRouteTableRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ~transit_gateway_attachment_id 
      ?dry_run  () =
      {
        transit_gateway_route_table_id;
        transit_gateway_attachment_id;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "TransitGatewayRouteTableId"
                   ([], (String.to_xml v.transit_gateway_route_table_id)))])
            @
            [Some
               (Ezxmlm.make_tag "TransitGatewayAttachmentId"
                  ([], (String.to_xml v.transit_gateway_attachment_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AttachVpnGatewayRequest =
  struct
    type t =
      {
      vpc_id: String.t ;
      vpn_gateway_id: String.t ;
      dry_run: Boolean.t option }
    let make ~vpc_id  ~vpn_gateway_id  ?dry_run  () =
      { vpc_id; vpn_gateway_id; dry_run }
    let parse xml =
      Some
        {
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          vpn_gateway_id =
            (Xml.required "VpnGatewayId"
               (Util.option_bind (Xml.member "VpnGatewayId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("VpnGatewayId", (String.to_query v.vpn_gateway_id)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some (Ezxmlm.make_tag "VpcId" ([], (String.to_xml v.vpc_id)))])
            @
            [Some
               (Ezxmlm.make_tag "VpnGatewayId"
                  ([], (String.to_xml v.vpn_gateway_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpn_gateway_id", (String.to_json v.vpn_gateway_id));
           Some ("vpc_id", (String.to_json v.vpc_id))])
    let of_json j =
      {
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        vpn_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_gateway_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeInstanceTypeOfferingsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      location_type: LocationType.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?location_type  ?(filters= [])  ?max_results 
      ?next_token  () =
      { dry_run; location_type; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          location_type =
            (Util.option_bind (Xml.member "LocationType" xml)
               LocationType.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.location_type
             (fun f -> Query.Pair ("LocationType", (LocationType.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.location_type
                 (fun f ->
                    Ezxmlm.make_tag "LocationType"
                      ([], (LocationType.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.location_type
             (fun f -> ("location_type", (LocationType.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        location_type =
          (Util.option_map (Json.lookup j "location_type")
             LocationType.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteEgressOnlyInternetGatewayResult =
  struct
    type t = {
      return_code: Boolean.t option }
    let make ?return_code  () = { return_code }
    let parse xml =
      Some
        {
          return_code =
            (Util.option_bind (Xml.member "returnCode" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return_code
              (fun f -> Query.Pair ("ReturnCode", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return_code
              (fun f -> Ezxmlm.make_tag "returnCode" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return_code
              (fun f -> ("return_code", (Boolean.to_json f)))])
    let of_json j =
      {
        return_code =
          (Util.option_map (Json.lookup j "return_code") Boolean.of_json)
      }
  end
module ResetSnapshotAttributeRequest =
  struct
    type t =
      {
      attribute: SnapshotAttributeName.t ;
      snapshot_id: String.t ;
      dry_run: Boolean.t option }
    let make ~attribute  ~snapshot_id  ?dry_run  () =
      { attribute; snapshot_id; dry_run }
    let parse xml =
      Some
        {
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  SnapshotAttributeName.parse));
          snapshot_id =
            (Xml.required "SnapshotId"
               (Util.option_bind (Xml.member "SnapshotId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Some
             (Query.Pair
                ("Attribute", (SnapshotAttributeName.to_query v.attribute)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "Attribute"
                   ([], (SnapshotAttributeName.to_xml v.attribute)))])
            @
            [Some
               (Ezxmlm.make_tag "SnapshotId"
                  ([], (String.to_xml v.snapshot_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("snapshot_id", (String.to_json v.snapshot_id));
           Some ("attribute", (SnapshotAttributeName.to_json v.attribute))])
    let of_json j =
      {
        attribute =
          (SnapshotAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")));
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeAvailabilityZonesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      zone_names: ZoneNameStringList.t ;
      zone_ids: ZoneIdStringList.t ;
      all_availability_zones: Boolean.t option ;
      dry_run: Boolean.t option }
    let make ?(filters= [])  ?(zone_names= [])  ?(zone_ids= []) 
      ?all_availability_zones  ?dry_run  () =
      { filters; zone_names; zone_ids; all_availability_zones; dry_run }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          zone_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "ZoneName" xml)
                  ZoneNameStringList.parse));
          zone_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ZoneId" xml)
                  ZoneIdStringList.parse));
          all_availability_zones =
            (Util.option_bind (Xml.member "AllAvailabilityZones" xml)
               Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.all_availability_zones
             (fun f ->
                Query.Pair ("AllAvailabilityZones", (Boolean.to_query f)));
           Some
             (Query.Pair ("ZoneId", (ZoneIdStringList.to_query v.zone_ids)));
           Some
             (Query.Pair
                ("ZoneName", (ZoneNameStringList.to_query v.zone_names)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filter"
                          ([], (FilterList.to_xml [x])))) v.filters))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "ZoneName"
                         ([], (ZoneNameStringList.to_xml [x])))) v.zone_names))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "ZoneId"
                        ([], (ZoneIdStringList.to_xml [x])))) v.zone_ids))
            @
            [Util.option_map v.all_availability_zones
               (fun f ->
                  Ezxmlm.make_tag "AllAvailabilityZones"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.all_availability_zones
             (fun f -> ("all_availability_zones", (Boolean.to_json f)));
           Some ("zone_ids", (ZoneIdStringList.to_json v.zone_ids));
           Some ("zone_names", (ZoneNameStringList.to_json v.zone_names));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        zone_names =
          (ZoneNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "zone_names")));
        zone_ids =
          (ZoneIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "zone_ids")));
        all_availability_zones =
          (Util.option_map (Json.lookup j "all_availability_zones")
             Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module StopInstancesRequest =
  struct
    type t =
      {
      instance_ids: InstanceIdStringList.t ;
      hibernate: Boolean.t option ;
      dry_run: Boolean.t option ;
      force: Boolean.t option }
    let make ~instance_ids  ?hibernate  ?dry_run  ?force  () =
      { instance_ids; hibernate; dry_run; force }
    let parse xml =
      Some
        {
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          hibernate =
            (Util.option_bind (Xml.member "Hibernate" xml) Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          force = (Util.option_bind (Xml.member "force" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.force
              (fun f -> Query.Pair ("Force", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.hibernate
             (fun f -> Query.Pair ("Hibernate", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "InstanceId"
                         ([], (InstanceIdStringList.to_xml [x]))))
                 v.instance_ids))
             @
             [Util.option_map v.hibernate
                (fun f ->
                   Ezxmlm.make_tag "Hibernate" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.force
              (fun f -> Ezxmlm.make_tag "force" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.force (fun f -> ("force", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.hibernate
             (fun f -> ("hibernate", (Boolean.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids))])
    let of_json j =
      {
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        hibernate =
          (Util.option_map (Json.lookup j "hibernate") Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        force = (Util.option_map (Json.lookup j "force") Boolean.of_json)
      }
  end
module DescribeTransitGatewayMulticastDomainsResult =
  struct
    type t =
      {
      transit_gateway_multicast_domains: TransitGatewayMulticastDomainList.t ;
      next_token: String.t option }
    let make ?(transit_gateway_multicast_domains= [])  ?next_token  () =
      { transit_gateway_multicast_domains; next_token }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domains =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "transitGatewayMulticastDomains" xml)
                  TransitGatewayMulticastDomainList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayMulticastDomains",
                  (TransitGatewayMulticastDomainList.to_query
                     v.transit_gateway_multicast_domains)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "transitGatewayMulticastDomains"
                       ([], (TransitGatewayMulticastDomainList.to_xml [x]))))
               v.transit_gateway_multicast_domains))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_multicast_domains",
               (TransitGatewayMulticastDomainList.to_json
                  v.transit_gateway_multicast_domains))])
    let of_json j =
      {
        transit_gateway_multicast_domains =
          (TransitGatewayMulticastDomainList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_multicast_domains")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteTransitGatewayVpcAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_attachment_id  ?dry_run  () =
      { transit_gateway_attachment_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "TransitGatewayAttachmentId"
                  ([], (String.to_xml v.transit_gateway_attachment_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribePrincipalIdFormatResult =
  struct
    type t =
      {
      principals: PrincipalIdFormatList.t ;
      next_token: String.t option }
    let make ?(principals= [])  ?next_token  () = { principals; next_token }
    let parse xml =
      Some
        {
          principals =
            (Util.of_option []
               (Util.option_bind (Xml.member "principalSet" xml)
                  PrincipalIdFormatList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("PrincipalSet",
                  (PrincipalIdFormatList.to_query v.principals)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "principalSet"
                       ([], (PrincipalIdFormatList.to_xml [x]))))
               v.principals))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("principals", (PrincipalIdFormatList.to_json v.principals))])
    let of_json j =
      {
        principals =
          (PrincipalIdFormatList.of_json
             (Util.of_option_exn (Json.lookup j "principals")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeregisterTransitGatewayMulticastGroupSourcesRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      group_ip_address: String.t option ;
      network_interface_ids: ValueStringList.t ;
      dry_run: Boolean.t option }
    let make ?transit_gateway_multicast_domain_id  ?group_ip_address 
      ?(network_interface_ids= [])  ?dry_run  () =
      {
        transit_gateway_multicast_domain_id;
        group_ip_address;
        network_interface_ids;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse);
          group_ip_address =
            (Util.option_bind (Xml.member "GroupIpAddress" xml) String.parse);
          network_interface_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterfaceIds" xml)
                  ValueStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceIds",
                  (ValueStringList.to_query v.network_interface_ids)));
           Util.option_map v.group_ip_address
             (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.transit_gateway_multicast_domain_id
                 (fun f ->
                    Ezxmlm.make_tag "TransitGatewayMulticastDomainId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.group_ip_address
                (fun f ->
                   Ezxmlm.make_tag "GroupIpAddress" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "NetworkInterfaceIds"
                       ([], (ValueStringList.to_xml [x]))))
               v.network_interface_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("network_interface_ids",
               (ValueStringList.to_json v.network_interface_ids));
           Util.option_map v.group_ip_address
             (fun f -> ("group_ip_address", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json);
        network_interface_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeInstancesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      instance_ids: InstanceIdStringList.t ;
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(filters= [])  ?(instance_ids= [])  ?dry_run  ?max_results 
      ?next_token  () =
      { filters; instance_ids; dry_run; max_results; next_token }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filter"
                          ([], (FilterList.to_xml [x])))) v.filters))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "InstanceId"
                         ([], (InstanceIdStringList.to_xml [x]))))
                 v.instance_ids))
             @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "maxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeVpnGatewaysRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      vpn_gateway_ids: VpnGatewayIdStringList.t ;
      dry_run: Boolean.t option }
    let make ?(filters= [])  ?(vpn_gateway_ids= [])  ?dry_run  () =
      { filters; vpn_gateway_ids; dry_run }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          vpn_gateway_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpnGatewayId" xml)
                  VpnGatewayIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("VpnGatewayId",
                  (VpnGatewayIdStringList.to_query v.vpn_gateway_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "VpnGatewayId"
                       ([], (VpnGatewayIdStringList.to_xml [x]))))
               v.vpn_gateway_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("vpn_gateway_ids",
               (VpnGatewayIdStringList.to_json v.vpn_gateway_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        vpn_gateway_ids =
          (VpnGatewayIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpn_gateway_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AcceptVpcEndpointConnectionsResult =
  struct
    type t = {
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemSet.to_xml [x])))) v.unsuccessful))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let of_json j =
      {
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module DescribeSpotFleetRequestsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      spot_fleet_request_ids: ValueStringList.t }
    let make ?dry_run  ?max_results  ?next_token  ?(spot_fleet_request_ids=
      [])  () = { dry_run; max_results; next_token; spot_fleet_request_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_fleet_request_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotFleetRequestId",
                   (ValueStringList.to_query v.spot_fleet_request_ids)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "maxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "spotFleetRequestId"
                      ([], (ValueStringList.to_xml [x]))))
              v.spot_fleet_request_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_fleet_request_ids",
                (ValueStringList.to_json v.spot_fleet_request_ids));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        spot_fleet_request_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_ids")))
      }
  end
module DescribeVpcEndpointServicePermissionsResult =
  struct
    type t =
      {
      allowed_principals: AllowedPrincipalSet.t ;
      next_token: String.t option }
    let make ?(allowed_principals= [])  ?next_token  () =
      { allowed_principals; next_token }
    let parse xml =
      Some
        {
          allowed_principals =
            (Util.of_option []
               (Util.option_bind (Xml.member "allowedPrincipals" xml)
                  AllowedPrincipalSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("AllowedPrincipals",
                  (AllowedPrincipalSet.to_query v.allowed_principals)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "allowedPrincipals"
                       ([], (AllowedPrincipalSet.to_xml [x]))))
               v.allowed_principals))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("allowed_principals",
               (AllowedPrincipalSet.to_json v.allowed_principals))])
    let of_json j =
      {
        allowed_principals =
          (AllowedPrincipalSet.of_json
             (Util.of_option_exn (Json.lookup j "allowed_principals")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeByoipCidrsResult =
  struct
    type t = {
      byoip_cidrs: ByoipCidrSet.t ;
      next_token: String.t option }
    let make ?(byoip_cidrs= [])  ?next_token  () =
      { byoip_cidrs; next_token }
    let parse xml =
      Some
        {
          byoip_cidrs =
            (Util.of_option []
               (Util.option_bind (Xml.member "byoipCidrSet" xml)
                  ByoipCidrSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ByoipCidrSet", (ByoipCidrSet.to_query v.byoip_cidrs)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "byoipCidrSet"
                       ([], (ByoipCidrSet.to_xml [x])))) v.byoip_cidrs))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("byoip_cidrs", (ByoipCidrSet.to_json v.byoip_cidrs))])
    let of_json j =
      {
        byoip_cidrs =
          (ByoipCidrSet.of_json
             (Util.of_option_exn (Json.lookup j "byoip_cidrs")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeCoipPoolsResult =
  struct
    type t = {
      coip_pools: CoipPoolSet.t ;
      next_token: String.t option }
    let make ?(coip_pools= [])  ?next_token  () = { coip_pools; next_token }
    let parse xml =
      Some
        {
          coip_pools =
            (Util.of_option []
               (Util.option_bind (Xml.member "coipPoolSet" xml)
                  CoipPoolSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair ("CoipPoolSet", (CoipPoolSet.to_query v.coip_pools)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "coipPoolSet"
                       ([], (CoipPoolSet.to_xml [x])))) v.coip_pools))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("coip_pools", (CoipPoolSet.to_json v.coip_pools))])
    let of_json j =
      {
        coip_pools =
          (CoipPoolSet.of_json
             (Util.of_option_exn (Json.lookup j "coip_pools")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeSpotDatafeedSubscriptionResult =
  struct
    type t = {
      spot_datafeed_subscription: SpotDatafeedSubscription.t option }
    let make ?spot_datafeed_subscription  () = { spot_datafeed_subscription }
    let parse xml =
      Some
        {
          spot_datafeed_subscription =
            (Util.option_bind (Xml.member "spotDatafeedSubscription" xml)
               SpotDatafeedSubscription.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 Query.Pair
                   ("SpotDatafeedSubscription",
                     (SpotDatafeedSubscription.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 Ezxmlm.make_tag "spotDatafeedSubscription"
                   ([], (SpotDatafeedSubscription.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 ("spot_datafeed_subscription",
                   (SpotDatafeedSubscription.to_json f)))])
    let of_json j =
      {
        spot_datafeed_subscription =
          (Util.option_map (Json.lookup j "spot_datafeed_subscription")
             SpotDatafeedSubscription.of_json)
      }
  end
module RevokeSecurityGroupEgressRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_id: String.t ;
      ip_permissions: IpPermissionList.t ;
      cidr_ip: String.t option ;
      from_port: Integer.t option ;
      ip_protocol: String.t option ;
      to_port: Integer.t option ;
      source_security_group_name: String.t option ;
      source_security_group_owner_id: String.t option }
    let make ?dry_run  ~group_id  ?(ip_permissions= [])  ?cidr_ip  ?from_port
       ?ip_protocol  ?to_port  ?source_security_group_name 
      ?source_security_group_owner_id  () =
      {
        dry_run;
        group_id;
        ip_permissions;
        cidr_ip;
        from_port;
        ip_protocol;
        to_port;
        source_security_group_name;
        source_security_group_owner_id
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_id =
            (Xml.required "groupId"
               (Util.option_bind (Xml.member "groupId" xml) String.parse));
          ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipPermissions" xml)
                  IpPermissionList.parse));
          cidr_ip = (Util.option_bind (Xml.member "cidrIp" xml) String.parse);
          from_port =
            (Util.option_bind (Xml.member "fromPort" xml) Integer.parse);
          ip_protocol =
            (Util.option_bind (Xml.member "ipProtocol" xml) String.parse);
          to_port =
            (Util.option_bind (Xml.member "toPort" xml) Integer.parse);
          source_security_group_name =
            (Util.option_bind (Xml.member "sourceSecurityGroupName" xml)
               String.parse);
          source_security_group_owner_id =
            (Util.option_bind (Xml.member "sourceSecurityGroupOwnerId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.source_security_group_owner_id
              (fun f ->
                 Query.Pair
                   ("SourceSecurityGroupOwnerId", (String.to_query f)));
           Util.option_map v.source_security_group_name
             (fun f ->
                Query.Pair ("SourceSecurityGroupName", (String.to_query f)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.ip_protocol
             (fun f -> Query.Pair ("IpProtocol", (String.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)));
           Util.option_map v.cidr_ip
             (fun f -> Query.Pair ("CidrIp", (String.to_query f)));
           Some
             (Query.Pair
                ("IpPermissions",
                  (IpPermissionList.to_query v.ip_permissions)));
           Some (Query.Pair ("GroupId", (String.to_query v.group_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.dry_run
                      (fun f ->
                         Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "groupId"
                        ([], (String.to_xml v.group_id)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "ipPermissions"
                            ([], (IpPermissionList.to_xml [x]))))
                    v.ip_permissions))
                @
                [Util.option_map v.cidr_ip
                   (fun f -> Ezxmlm.make_tag "cidrIp" ([], (String.to_xml f)))])
               @
               [Util.option_map v.from_port
                  (fun f ->
                     Ezxmlm.make_tag "fromPort" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.ip_protocol
                 (fun f ->
                    Ezxmlm.make_tag "ipProtocol" ([], (String.to_xml f)))])
             @
             [Util.option_map v.to_port
                (fun f -> Ezxmlm.make_tag "toPort" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.source_security_group_name
               (fun f ->
                  Ezxmlm.make_tag "sourceSecurityGroupName"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.source_security_group_owner_id
              (fun f ->
                 Ezxmlm.make_tag "sourceSecurityGroupOwnerId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.source_security_group_owner_id
              (fun f ->
                 ("source_security_group_owner_id", (String.to_json f)));
           Util.option_map v.source_security_group_name
             (fun f -> ("source_security_group_name", (String.to_json f)));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.ip_protocol
             (fun f -> ("ip_protocol", (String.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)));
           Util.option_map v.cidr_ip
             (fun f -> ("cidr_ip", (String.to_json f)));
           Some
             ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Some ("group_id", (String.to_json v.group_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_id")));
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")));
        cidr_ip = (Util.option_map (Json.lookup j "cidr_ip") String.of_json);
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        ip_protocol =
          (Util.option_map (Json.lookup j "ip_protocol") String.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        source_security_group_name =
          (Util.option_map (Json.lookup j "source_security_group_name")
             String.of_json);
        source_security_group_owner_id =
          (Util.option_map (Json.lookup j "source_security_group_owner_id")
             String.of_json)
      }
  end
module DeleteFleetsResult =
  struct
    type t =
      {
      successful_fleet_deletions: DeleteFleetSuccessSet.t ;
      unsuccessful_fleet_deletions: DeleteFleetErrorSet.t }
    let make ?(successful_fleet_deletions= []) 
      ?(unsuccessful_fleet_deletions= [])  () =
      { successful_fleet_deletions; unsuccessful_fleet_deletions }
    let parse xml =
      Some
        {
          successful_fleet_deletions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "successfulFleetDeletionSet" xml)
                  DeleteFleetSuccessSet.parse));
          unsuccessful_fleet_deletions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "unsuccessfulFleetDeletionSet" xml)
                  DeleteFleetErrorSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnsuccessfulFleetDeletionSet",
                   (DeleteFleetErrorSet.to_query
                      v.unsuccessful_fleet_deletions)));
           Some
             (Query.Pair
                ("SuccessfulFleetDeletionSet",
                  (DeleteFleetSuccessSet.to_query
                     v.successful_fleet_deletions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "successfulFleetDeletionSet"
                       ([], (DeleteFleetSuccessSet.to_xml [x]))))
               v.successful_fleet_deletions))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessfulFleetDeletionSet"
                      ([], (DeleteFleetErrorSet.to_xml [x]))))
              v.unsuccessful_fleet_deletions))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful_fleet_deletions",
                (DeleteFleetErrorSet.to_json v.unsuccessful_fleet_deletions));
           Some
             ("successful_fleet_deletions",
               (DeleteFleetSuccessSet.to_json v.successful_fleet_deletions))])
    let of_json j =
      {
        successful_fleet_deletions =
          (DeleteFleetSuccessSet.of_json
             (Util.of_option_exn (Json.lookup j "successful_fleet_deletions")));
        unsuccessful_fleet_deletions =
          (DeleteFleetErrorSet.of_json
             (Util.of_option_exn
                (Json.lookup j "unsuccessful_fleet_deletions")))
      }
  end
module DisableFastSnapshotRestoresResult =
  struct
    type t =
      {
      successful: DisableFastSnapshotRestoreSuccessSet.t ;
      unsuccessful: DisableFastSnapshotRestoreErrorSet.t }
    let make ?(successful= [])  ?(unsuccessful= [])  () =
      { successful; unsuccessful }
    let parse xml =
      Some
        {
          successful =
            (Util.of_option []
               (Util.option_bind (Xml.member "successful" xml)
                  DisableFastSnapshotRestoreSuccessSet.parse));
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  DisableFastSnapshotRestoreErrorSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (DisableFastSnapshotRestoreErrorSet.to_query
                      v.unsuccessful)));
           Some
             (Query.Pair
                ("Successful",
                  (DisableFastSnapshotRestoreSuccessSet.to_query v.successful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "successful"
                       ([],
                         (DisableFastSnapshotRestoreSuccessSet.to_xml [x]))))
               v.successful))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (DisableFastSnapshotRestoreErrorSet.to_xml [x]))))
              v.unsuccessful))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful",
                (DisableFastSnapshotRestoreErrorSet.to_json v.unsuccessful));
           Some
             ("successful",
               (DisableFastSnapshotRestoreSuccessSet.to_json v.successful))])
    let of_json j =
      {
        successful =
          (DisableFastSnapshotRestoreSuccessSet.of_json
             (Util.of_option_exn (Json.lookup j "successful")));
        unsuccessful =
          (DisableFastSnapshotRestoreErrorSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module GetEbsDefaultKmsKeyIdResult =
  struct
    type t = {
      kms_key_id: String.t option }
    let make ?kms_key_id  () = { kms_key_id }
    let parse xml =
      Some
        {
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.kms_key_id
              (fun f -> Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> ("kms_key_id", (String.to_json f)))])
    let of_json j =
      {
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json)
      }
  end
module DeleteTrafficMirrorFilterResult =
  struct
    type t = {
      traffic_mirror_filter_id: String.t option }
    let make ?traffic_mirror_filter_id  () = { traffic_mirror_filter_id }
    let parse xml =
      Some
        {
          traffic_mirror_filter_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_id
              (fun f ->
                 Query.Pair ("TrafficMirrorFilterId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.traffic_mirror_filter_id
              (fun f ->
                 Ezxmlm.make_tag "trafficMirrorFilterId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_id
              (fun f -> ("traffic_mirror_filter_id", (String.to_json f)))])
    let of_json j =
      {
        traffic_mirror_filter_id =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_id")
             String.of_json)
      }
  end
module DescribeReservedInstancesModificationsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      reserved_instances_modification_ids:
        ReservedInstancesModificationIdStringList.t ;
      next_token: String.t option }
    let make ?(filters= [])  ?(reserved_instances_modification_ids= []) 
      ?next_token  () =
      { filters; reserved_instances_modification_ids; next_token }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          reserved_instances_modification_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ReservedInstancesModificationId" xml)
                  ReservedInstancesModificationIdStringList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesModificationId",
                  (ReservedInstancesModificationIdStringList.to_query
                     v.reserved_instances_modification_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ReservedInstancesModificationId"
                       ([],
                         (ReservedInstancesModificationIdStringList.to_xml
                            [x])))) v.reserved_instances_modification_ids))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("reserved_instances_modification_ids",
               (ReservedInstancesModificationIdStringList.to_json
                  v.reserved_instances_modification_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        reserved_instances_modification_ids =
          (ReservedInstancesModificationIdStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_modification_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeInstanceTypesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_types: RequestInstanceTypeList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(instance_types= [])  ?(filters= [])  ?max_results 
      ?next_token  () =
      { dry_run; instance_types; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          instance_types =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceType" xml)
                  RequestInstanceTypeList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("InstanceType",
                  (RequestInstanceTypeList.to_query v.instance_types)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "InstanceType"
                         ([], (RequestInstanceTypeList.to_xml [x]))))
                 v.instance_types))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("instance_types",
               (RequestInstanceTypeList.to_json v.instance_types));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_types =
          (RequestInstanceTypeList.of_json
             (Util.of_option_exn (Json.lookup j "instance_types")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteNatGatewayRequest =
  struct
    type t = {
      nat_gateway_id: String.t }
    let make ~nat_gateway_id  () = { nat_gateway_id }
    let parse xml =
      Some
        {
          nat_gateway_id =
            (Xml.required "NatGatewayId"
               (Util.option_bind (Xml.member "NatGatewayId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NatGatewayId", (String.to_query v.nat_gateway_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "NatGatewayId"
                 ([], (String.to_xml v.nat_gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("nat_gateway_id", (String.to_json v.nat_gateway_id))])
    let of_json j =
      {
        nat_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "nat_gateway_id")))
      }
  end
module DescribeSpotInstanceRequestsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      spot_instance_request_ids: SpotInstanceRequestIdList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?dry_run  ?(spot_instance_request_ids= []) 
      ?next_token  ?max_results  () =
      { filters; dry_run; spot_instance_request_ids; next_token; max_results
      }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          spot_instance_request_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SpotInstanceRequestId" xml)
                  SpotInstanceRequestIdList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("SpotInstanceRequestId",
                  (SpotInstanceRequestIdList.to_query
                     v.spot_instance_request_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filter"
                          ([], (FilterList.to_xml [x])))) v.filters))
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "SpotInstanceRequestId"
                        ([], (SpotInstanceRequestIdList.to_xml [x]))))
                v.spot_instance_request_ids))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("spot_instance_request_ids",
               (SpotInstanceRequestIdList.to_json v.spot_instance_request_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        spot_instance_request_ids =
          (SpotInstanceRequestIdList.of_json
             (Util.of_option_exn (Json.lookup j "spot_instance_request_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DescribePlacementGroupsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      group_names: PlacementGroupStringList.t ;
      group_ids: PlacementGroupIdStringList.t }
    let make ?(filters= [])  ?dry_run  ?(group_names= [])  ?(group_ids= []) 
      () = { filters; dry_run; group_names; group_ids }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupName" xml)
                  PlacementGroupStringList.parse));
          group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupId" xml)
                  PlacementGroupIdStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("GroupId",
                   (PlacementGroupIdStringList.to_query v.group_ids)));
           Some
             (Query.Pair
                ("GroupName",
                  (PlacementGroupStringList.to_query v.group_names)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "groupName"
                       ([], (PlacementGroupStringList.to_xml [x]))))
               v.group_names))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "GroupId"
                      ([], (PlacementGroupIdStringList.to_xml [x]))))
              v.group_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("group_ids", (PlacementGroupIdStringList.to_json v.group_ids));
           Some
             ("group_names",
               (PlacementGroupStringList.to_json v.group_names));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_names =
          (PlacementGroupStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_names")));
        group_ids =
          (PlacementGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_ids")))
      }
  end
module AssignIpv6AddressesRequest =
  struct
    type t =
      {
      ipv6_address_count: Integer.t option ;
      ipv6_addresses: Ipv6AddressList.t ;
      network_interface_id: String.t }
    let make ?ipv6_address_count  ?(ipv6_addresses= []) 
      ~network_interface_id  () =
      { ipv6_address_count; ipv6_addresses; network_interface_id }
    let parse xml =
      Some
        {
          ipv6_address_count =
            (Util.option_bind (Xml.member "ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6Addresses" xml)
                  Ipv6AddressList.parse));
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkInterfaceId",
                   (String.to_query v.network_interface_id)));
           Some
             (Query.Pair
                ("Ipv6Addresses",
                  (Ipv6AddressList.to_query v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.ipv6_address_count
                (fun f ->
                   Ezxmlm.make_tag "ipv6AddressCount"
                     ([], (Integer.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ipv6Addresses"
                       ([], (Ipv6AddressList.to_xml [x])))) v.ipv6_addresses))
           @
           [Some
              (Ezxmlm.make_tag "networkInterfaceId"
                 ([], (String.to_xml v.network_interface_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("network_interface_id",
                (String.to_json v.network_interface_id));
           Some
             ("ipv6_addresses", (Ipv6AddressList.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)))])
    let of_json j =
      {
        ipv6_address_count =
          (Util.option_map (Json.lookup j "ipv6_address_count")
             Integer.of_json);
        ipv6_addresses =
          (Ipv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")))
      }
  end
module DescribeVpcEndpointServicesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_names: ValueStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(service_names= [])  ?(filters= [])  ?max_results 
      ?next_token  () =
      { dry_run; service_names; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "ServiceName" xml)
                  ValueStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("ServiceName", (ValueStringList.to_query v.service_names)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "ServiceName"
                         ([], (ValueStringList.to_xml [x])))) v.service_names))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("service_names", (ValueStringList.to_json v.service_names));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_names =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "service_names")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeScheduledInstancesResult =
  struct
    type t =
      {
      next_token: String.t option ;
      scheduled_instance_set: ScheduledInstanceSet.t }
    let make ?next_token  ?(scheduled_instance_set= [])  () =
      { next_token; scheduled_instance_set }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          scheduled_instance_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "scheduledInstanceSet" xml)
                  ScheduledInstanceSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ScheduledInstanceSet",
                   (ScheduledInstanceSet.to_query v.scheduled_instance_set)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "scheduledInstanceSet"
                      ([], (ScheduledInstanceSet.to_xml [x]))))
              v.scheduled_instance_set))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("scheduled_instance_set",
                (ScheduledInstanceSet.to_json v.scheduled_instance_set));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        scheduled_instance_set =
          (ScheduledInstanceSet.of_json
             (Util.of_option_exn (Json.lookup j "scheduled_instance_set")))
      }
  end
module ModifyInstanceMetadataOptionsResult =
  struct
    type t =
      {
      instance_id: String.t option ;
      instance_metadata_options: InstanceMetadataOptionsResponse.t option }
    let make ?instance_id  ?instance_metadata_options  () =
      { instance_id; instance_metadata_options }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_metadata_options =
            (Util.option_bind (Xml.member "instanceMetadataOptions" xml)
               InstanceMetadataOptionsResponse.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_metadata_options
              (fun f ->
                 Query.Pair
                   ("InstanceMetadataOptions",
                     (InstanceMetadataOptionsResponse.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.instance_metadata_options
              (fun f ->
                 Ezxmlm.make_tag "instanceMetadataOptions"
                   ([], (InstanceMetadataOptionsResponse.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_metadata_options
              (fun f ->
                 ("instance_metadata_options",
                   (InstanceMetadataOptionsResponse.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_metadata_options =
          (Util.option_map (Json.lookup j "instance_metadata_options")
             InstanceMetadataOptionsResponse.of_json)
      }
  end
module DescribeFlowLogsResult =
  struct
    type t = {
      flow_logs: FlowLogSet.t ;
      next_token: String.t option }
    let make ?(flow_logs= [])  ?next_token  () = { flow_logs; next_token }
    let parse xml =
      Some
        {
          flow_logs =
            (Util.of_option []
               (Util.option_bind (Xml.member "flowLogSet" xml)
                  FlowLogSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair ("FlowLogSet", (FlowLogSet.to_query v.flow_logs)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "flowLogSet"
                       ([], (FlowLogSet.to_xml [x])))) v.flow_logs))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("flow_logs", (FlowLogSet.to_json v.flow_logs))])
    let of_json j =
      {
        flow_logs =
          (FlowLogSet.of_json
             (Util.of_option_exn (Json.lookup j "flow_logs")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateVpcEndpointServiceConfigurationRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      acceptance_required: Boolean.t option ;
      network_load_balancer_arns: ValueStringList.t ;
      client_token: String.t option }
    let make ?dry_run  ?acceptance_required  ~network_load_balancer_arns 
      ?client_token  () =
      {
        dry_run;
        acceptance_required;
        network_load_balancer_arns;
        client_token
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          acceptance_required =
            (Util.option_bind (Xml.member "AcceptanceRequired" xml)
               Boolean.parse);
          network_load_balancer_arns =
            (Xml.required "NetworkLoadBalancerArn"
               (Util.option_bind (Xml.member "NetworkLoadBalancerArn" xml)
                  ValueStringList.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkLoadBalancerArn",
                  (ValueStringList.to_query v.network_load_balancer_arns)));
           Util.option_map v.acceptance_required
             (fun f ->
                Query.Pair ("AcceptanceRequired", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.acceptance_required
                (fun f ->
                   Ezxmlm.make_tag "AcceptanceRequired"
                     ([], (Boolean.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "NetworkLoadBalancerArn"
                       ([], (ValueStringList.to_xml [x]))))
               v.network_load_balancer_arns))
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Some
             ("network_load_balancer_arns",
               (ValueStringList.to_json v.network_load_balancer_arns));
           Util.option_map v.acceptance_required
             (fun f -> ("acceptance_required", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        acceptance_required =
          (Util.option_map (Json.lookup j "acceptance_required")
             Boolean.of_json);
        network_load_balancer_arns =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "network_load_balancer_arns")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeBundleTasksResult =
  struct
    type t = {
      bundle_tasks: BundleTaskList.t }
    let make ?(bundle_tasks= [])  () = { bundle_tasks }
    let parse xml =
      Some
        {
          bundle_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "bundleInstanceTasksSet" xml)
                  BundleTaskList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("BundleInstanceTasksSet",
                   (BundleTaskList.to_query v.bundle_tasks)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "bundleInstanceTasksSet"
                      ([], (BundleTaskList.to_xml [x])))) v.bundle_tasks))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("bundle_tasks", (BundleTaskList.to_json v.bundle_tasks))])
    let of_json j =
      {
        bundle_tasks =
          (BundleTaskList.of_json
             (Util.of_option_exn (Json.lookup j "bundle_tasks")))
      }
  end
module DescribeInstanceCreditSpecificationsResult =
  struct
    type t =
      {
      instance_credit_specifications: InstanceCreditSpecificationList.t ;
      next_token: String.t option }
    let make ?(instance_credit_specifications= [])  ?next_token  () =
      { instance_credit_specifications; next_token }
    let parse xml =
      Some
        {
          instance_credit_specifications =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "instanceCreditSpecificationSet" xml)
                  InstanceCreditSpecificationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceCreditSpecificationSet",
                  (InstanceCreditSpecificationList.to_query
                     v.instance_credit_specifications)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "instanceCreditSpecificationSet"
                       ([], (InstanceCreditSpecificationList.to_xml [x]))))
               v.instance_credit_specifications))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_credit_specifications",
               (InstanceCreditSpecificationList.to_json
                  v.instance_credit_specifications))])
    let of_json j =
      {
        instance_credit_specifications =
          (InstanceCreditSpecificationList.of_json
             (Util.of_option_exn
                (Json.lookup j "instance_credit_specifications")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ExportClientVpnClientCertificateRevocationListRequest =
  struct
    type t = {
      client_vpn_endpoint_id: String.t ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?dry_run  () =
      { client_vpn_endpoint_id; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "ClientVpnEndpointId"
                  ([], (String.to_xml v.client_vpn_endpoint_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeSubnetsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      subnet_ids: SubnetIdStringList.t ;
      dry_run: Boolean.t option ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?(subnet_ids= [])  ?dry_run  ?next_token 
      ?max_results  () =
      { filters; subnet_ids; dry_run; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SubnetId" xml)
                  SubnetIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SubnetId", (SubnetIdStringList.to_query v.subnet_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filter"
                          ([], (FilterList.to_xml [x])))) v.filters))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "SubnetId"
                         ([], (SubnetIdStringList.to_xml [x])))) v.subnet_ids))
             @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("subnet_ids", (SubnetIdStringList.to_json v.subnet_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        subnet_ids =
          (SubnetIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "subnet_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module GetCoipPoolUsageResult =
  struct
    type t =
      {
      coip_pool_id: String.t option ;
      coip_address_usages: CoipAddressUsageSet.t ;
      local_gateway_route_table_id: String.t option }
    let make ?coip_pool_id  ?(coip_address_usages= []) 
      ?local_gateway_route_table_id  () =
      { coip_pool_id; coip_address_usages; local_gateway_route_table_id }
    let parse xml =
      Some
        {
          coip_pool_id =
            (Util.option_bind (Xml.member "coipPoolId" xml) String.parse);
          coip_address_usages =
            (Util.of_option []
               (Util.option_bind (Xml.member "coipAddressUsageSet" xml)
                  CoipAddressUsageSet.parse));
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_id
              (fun f ->
                 Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)));
           Some
             (Query.Pair
                ("CoipAddressUsageSet",
                  (CoipAddressUsageSet.to_query v.coip_address_usages)));
           Util.option_map v.coip_pool_id
             (fun f -> Query.Pair ("CoipPoolId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.coip_pool_id
                (fun f ->
                   Ezxmlm.make_tag "coipPoolId" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "coipAddressUsageSet"
                       ([], (CoipAddressUsageSet.to_xml [x]))))
               v.coip_address_usages))
           @
           [Util.option_map v.local_gateway_route_table_id
              (fun f ->
                 Ezxmlm.make_tag "localGatewayRouteTableId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_id
              (fun f -> ("local_gateway_route_table_id", (String.to_json f)));
           Some
             ("coip_address_usages",
               (CoipAddressUsageSet.to_json v.coip_address_usages));
           Util.option_map v.coip_pool_id
             (fun f -> ("coip_pool_id", (String.to_json f)))])
    let of_json j =
      {
        coip_pool_id =
          (Util.option_map (Json.lookup j "coip_pool_id") String.of_json);
        coip_address_usages =
          (CoipAddressUsageSet.of_json
             (Util.of_option_exn (Json.lookup j "coip_address_usages")));
        local_gateway_route_table_id =
          (Util.option_map (Json.lookup j "local_gateway_route_table_id")
             String.of_json)
      }
  end
module ImportKeyPairResult =
  struct
    type t = {
      key_fingerprint: String.t option ;
      key_name: String.t option }
    let make ?key_fingerprint  ?key_name  () = { key_fingerprint; key_name }
    let parse xml =
      Some
        {
          key_fingerprint =
            (Util.option_bind (Xml.member "keyFingerprint" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.key_name
              (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.key_fingerprint
             (fun f -> Query.Pair ("KeyFingerprint", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.key_fingerprint
               (fun f ->
                  Ezxmlm.make_tag "keyFingerprint" ([], (String.to_xml f)))])
           @
           [Util.option_map v.key_name
              (fun f -> Ezxmlm.make_tag "keyName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.key_name
              (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.key_fingerprint
             (fun f -> ("key_fingerprint", (String.to_json f)))])
    let of_json j =
      {
        key_fingerprint =
          (Util.option_map (Json.lookup j "key_fingerprint") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json)
      }
  end
module AcceptReservedInstancesExchangeQuoteRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      reserved_instance_ids: ReservedInstanceIdSet.t ;
      target_configurations: TargetConfigurationRequestSet.t }
    let make ?dry_run  ~reserved_instance_ids  ?(target_configurations= []) 
      () = { dry_run; reserved_instance_ids; target_configurations }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          reserved_instance_ids =
            (Xml.required "ReservedInstanceId"
               (Util.option_bind (Xml.member "ReservedInstanceId" xml)
                  ReservedInstanceIdSet.parse));
          target_configurations =
            (Util.of_option []
               (Util.option_bind (Xml.member "TargetConfiguration" xml)
                  TargetConfigurationRequestSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TargetConfiguration",
                   (TargetConfigurationRequestSet.to_query
                      v.target_configurations)));
           Some
             (Query.Pair
                ("ReservedInstanceId",
                  (ReservedInstanceIdSet.to_query v.reserved_instance_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ReservedInstanceId"
                       ([], (ReservedInstanceIdSet.to_xml [x]))))
               v.reserved_instance_ids))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "TargetConfiguration"
                      ([], (TargetConfigurationRequestSet.to_xml [x]))))
              v.target_configurations))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("target_configurations",
                (TargetConfigurationRequestSet.to_json
                   v.target_configurations));
           Some
             ("reserved_instance_ids",
               (ReservedInstanceIdSet.to_json v.reserved_instance_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        reserved_instance_ids =
          (ReservedInstanceIdSet.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instance_ids")));
        target_configurations =
          (TargetConfigurationRequestSet.of_json
             (Util.of_option_exn (Json.lookup j "target_configurations")))
      }
  end
module DescribeLocalGatewayRouteTableVpcAssociationsRequest =
  struct
    type t =
      {
      local_gateway_route_table_vpc_association_ids:
        LocalGatewayRouteTableVpcAssociationIdSet.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(local_gateway_route_table_vpc_association_ids= [])  ?(filters=
      [])  ?max_results  ?next_token  ?dry_run  () =
      {
        local_gateway_route_table_vpc_association_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          local_gateway_route_table_vpc_association_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "LocalGatewayRouteTableVpcAssociationId" xml)
                  LocalGatewayRouteTableVpcAssociationIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableVpcAssociationId",
                  (LocalGatewayRouteTableVpcAssociationIdSet.to_query
                     v.local_gateway_route_table_vpc_association_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag
                          "LocalGatewayRouteTableVpcAssociationId"
                          ([],
                            (LocalGatewayRouteTableVpcAssociationIdSet.to_xml
                               [x]))))
                  v.local_gateway_route_table_vpc_association_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("local_gateway_route_table_vpc_association_ids",
               (LocalGatewayRouteTableVpcAssociationIdSet.to_json
                  v.local_gateway_route_table_vpc_association_ids))])
    let of_json j =
      {
        local_gateway_route_table_vpc_association_ids =
          (LocalGatewayRouteTableVpcAssociationIdSet.of_json
             (Util.of_option_exn
                (Json.lookup j
                   "local_gateway_route_table_vpc_association_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeStaleSecurityGroupsResult =
  struct
    type t =
      {
      next_token: String.t option ;
      stale_security_group_set: StaleSecurityGroupSet.t }
    let make ?next_token  ?(stale_security_group_set= [])  () =
      { next_token; stale_security_group_set }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          stale_security_group_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "staleSecurityGroupSet" xml)
                  StaleSecurityGroupSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("StaleSecurityGroupSet",
                   (StaleSecurityGroupSet.to_query v.stale_security_group_set)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "staleSecurityGroupSet"
                      ([], (StaleSecurityGroupSet.to_xml [x]))))
              v.stale_security_group_set))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("stale_security_group_set",
                (StaleSecurityGroupSet.to_json v.stale_security_group_set));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        stale_security_group_set =
          (StaleSecurityGroupSet.of_json
             (Util.of_option_exn (Json.lookup j "stale_security_group_set")))
      }
  end
module CreateKeyPairRequest =
  struct
    type t = {
      key_name: String.t ;
      dry_run: Boolean.t option }
    let make ~key_name  ?dry_run  () = { key_name; dry_run }
    let parse xml =
      Some
        {
          key_name =
            (Xml.required "KeyName"
               (Util.option_bind (Xml.member "KeyName" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("KeyName", (String.to_query v.key_name)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "KeyName" ([], (String.to_xml v.key_name)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("key_name", (String.to_json v.key_name))])
    let of_json j =
      {
        key_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "key_name")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisassociateAddressRequest =
  struct
    type t =
      {
      association_id: String.t option ;
      public_ip: String.t option ;
      dry_run: Boolean.t option }
    let make ?association_id  ?public_ip  ?dry_run  () =
      { association_id; public_ip; dry_run }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "AssociationId" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "PublicIp" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.association_id
                (fun f ->
                   Ezxmlm.make_tag "AssociationId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.public_ip
               (fun f -> Ezxmlm.make_tag "PublicIp" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeSecurityGroupReferencesResult =
  struct
    type t = {
      security_group_reference_set: SecurityGroupReferences.t }
    let make ?(security_group_reference_set= [])  () =
      { security_group_reference_set }
    let parse xml =
      Some
        {
          security_group_reference_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupReferenceSet" xml)
                  SecurityGroupReferences.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SecurityGroupReferenceSet",
                   (SecurityGroupReferences.to_query
                      v.security_group_reference_set)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "securityGroupReferenceSet"
                      ([], (SecurityGroupReferences.to_xml [x]))))
              v.security_group_reference_set))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("security_group_reference_set",
                (SecurityGroupReferences.to_json
                   v.security_group_reference_set))])
    let of_json j =
      {
        security_group_reference_set =
          (SecurityGroupReferences.of_json
             (Util.of_option_exn
                (Json.lookup j "security_group_reference_set")))
      }
  end
module ReplaceRouteRequest =
  struct
    type t =
      {
      destination_cidr_block: String.t option ;
      destination_ipv6_cidr_block: String.t option ;
      dry_run: Boolean.t option ;
      egress_only_internet_gateway_id: String.t option ;
      gateway_id: String.t option ;
      instance_id: String.t option ;
      local_target: Boolean.t option ;
      nat_gateway_id: String.t option ;
      transit_gateway_id: String.t option ;
      local_gateway_id: String.t option ;
      network_interface_id: String.t option ;
      route_table_id: String.t ;
      vpc_peering_connection_id: String.t option }
    let make ?destination_cidr_block  ?destination_ipv6_cidr_block  ?dry_run 
      ?egress_only_internet_gateway_id  ?gateway_id  ?instance_id 
      ?local_target  ?nat_gateway_id  ?transit_gateway_id  ?local_gateway_id 
      ?network_interface_id  ~route_table_id  ?vpc_peering_connection_id  ()
      =
      {
        destination_cidr_block;
        destination_ipv6_cidr_block;
        dry_run;
        egress_only_internet_gateway_id;
        gateway_id;
        instance_id;
        local_target;
        nat_gateway_id;
        transit_gateway_id;
        local_gateway_id;
        network_interface_id;
        route_table_id;
        vpc_peering_connection_id
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          destination_ipv6_cidr_block =
            (Util.option_bind (Xml.member "destinationIpv6CidrBlock" xml)
               String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          egress_only_internet_gateway_id =
            (Util.option_bind (Xml.member "egressOnlyInternetGatewayId" xml)
               String.parse);
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          local_target =
            (Util.option_bind (Xml.member "LocalTarget" xml) Boolean.parse);
          nat_gateway_id =
            (Util.option_bind (Xml.member "natGatewayId" xml) String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "TransitGatewayId" xml)
               String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "LocalGatewayId" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse));
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Some
             (Query.Pair ("RouteTableId", (String.to_query v.route_table_id)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.nat_gateway_id
             (fun f -> Query.Pair ("NatGatewayId", (String.to_query f)));
           Util.option_map v.local_target
             (fun f -> Query.Pair ("LocalTarget", (Boolean.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.gateway_id
             (fun f -> Query.Pair ("GatewayId", (String.to_query f)));
           Util.option_map v.egress_only_internet_gateway_id
             (fun f ->
                Query.Pair
                  ("EgressOnlyInternetGatewayId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f ->
                Query.Pair ("DestinationIpv6CidrBlock", (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.destination_cidr_block
                          (fun f ->
                             Ezxmlm.make_tag "destinationCidrBlock"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.destination_ipv6_cidr_block
                         (fun f ->
                            Ezxmlm.make_tag "destinationIpv6CidrBlock"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.dry_run
                        (fun f ->
                           Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
                    @
                    [Util.option_map v.egress_only_internet_gateway_id
                       (fun f ->
                          Ezxmlm.make_tag "egressOnlyInternetGatewayId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.gateway_id
                      (fun f ->
                         Ezxmlm.make_tag "gatewayId" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.instance_id
                     (fun f ->
                        Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.local_target
                    (fun f ->
                       Ezxmlm.make_tag "LocalTarget" ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.nat_gateway_id
                   (fun f ->
                      Ezxmlm.make_tag "natGatewayId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.transit_gateway_id
                  (fun f ->
                     Ezxmlm.make_tag "TransitGatewayId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.local_gateway_id
                 (fun f ->
                    Ezxmlm.make_tag "LocalGatewayId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.network_interface_id
                (fun f ->
                   Ezxmlm.make_tag "networkInterfaceId"
                     ([], (String.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "routeTableId"
                  ([], (String.to_xml v.route_table_id)))])
           @
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Ezxmlm.make_tag "vpcPeeringConnectionId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Some ("route_table_id", (String.to_json v.route_table_id));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.nat_gateway_id
             (fun f -> ("nat_gateway_id", (String.to_json f)));
           Util.option_map v.local_target
             (fun f -> ("local_target", (Boolean.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.gateway_id
             (fun f -> ("gateway_id", (String.to_json f)));
           Util.option_map v.egress_only_internet_gateway_id
             (fun f ->
                ("egress_only_internet_gateway_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f -> ("destination_ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        destination_ipv6_cidr_block =
          (Util.option_map (Json.lookup j "destination_ipv6_cidr_block")
             String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        egress_only_internet_gateway_id =
          (Util.option_map (Json.lookup j "egress_only_internet_gateway_id")
             String.of_json);
        gateway_id =
          (Util.option_map (Json.lookup j "gateway_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        local_target =
          (Util.option_map (Json.lookup j "local_target") Boolean.of_json);
        nat_gateway_id =
          (Util.option_map (Json.lookup j "nat_gateway_id") String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")));
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module GetConsoleOutputRequest =
  struct
    type t =
      {
      instance_id: String.t ;
      dry_run: Boolean.t option ;
      latest: Boolean.t option }
    let make ~instance_id  ?dry_run  ?latest  () =
      { instance_id; dry_run; latest }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          latest = (Util.option_bind (Xml.member "Latest" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.latest
              (fun f -> Query.Pair ("Latest", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "InstanceId"
                   ([], (String.to_xml v.instance_id)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.latest
              (fun f -> Ezxmlm.make_tag "Latest" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.latest
              (fun f -> ("latest", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        latest = (Util.option_map (Json.lookup j "latest") Boolean.of_json)
      }
  end
module CreateTransitGatewayRouteTableRequest =
  struct
    type t =
      {
      transit_gateway_id: String.t ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_id  ?(tag_specifications= [])  ?dry_run  () =
      { transit_gateway_id; tag_specifications; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Xml.required "TransitGatewayId"
               (Util.option_bind (Xml.member "TransitGatewayId" xml)
                  String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecifications" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecifications",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some
             (Query.Pair
                ("TransitGatewayId", (String.to_query v.transit_gateway_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "TransitGatewayId"
                   ([], (String.to_xml v.transit_gateway_id)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "TagSpecifications"
                       ([], (TagSpecificationList.to_xml [x]))))
               v.tag_specifications))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("transit_gateway_id", (String.to_json v.transit_gateway_id))])
    let of_json j =
      {
        transit_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "transit_gateway_id")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateVpnConnectionResult =
  struct
    type t = {
      vpn_connection: VpnConnection.t option }
    let make ?vpn_connection  () = { vpn_connection }
    let parse xml =
      Some
        {
          vpn_connection =
            (Util.option_bind (Xml.member "vpnConnection" xml)
               VpnConnection.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f ->
                 Query.Pair ("VpnConnection", (VpnConnection.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpn_connection
              (fun f ->
                 Ezxmlm.make_tag "vpnConnection"
                   ([], (VpnConnection.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f -> ("vpn_connection", (VpnConnection.to_json f)))])
    let of_json j =
      {
        vpn_connection =
          (Util.option_map (Json.lookup j "vpn_connection")
             VpnConnection.of_json)
      }
  end
module KeyPair =
  struct
    type t =
      {
      key_fingerprint: String.t ;
      key_material: String.t ;
      key_name: String.t ;
      key_pair_id: String.t option }
    let make ~key_fingerprint  ~key_material  ~key_name  ?key_pair_id  () =
      { key_fingerprint; key_material; key_name; key_pair_id }
    let parse xml =
      Some
        {
          key_fingerprint =
            (Xml.required "keyFingerprint"
               (Util.option_bind (Xml.member "keyFingerprint" xml)
                  String.parse));
          key_material =
            (Xml.required "keyMaterial"
               (Util.option_bind (Xml.member "keyMaterial" xml) String.parse));
          key_name =
            (Xml.required "keyName"
               (Util.option_bind (Xml.member "keyName" xml) String.parse));
          key_pair_id =
            (Util.option_bind (Xml.member "keyPairId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.key_pair_id
              (fun f -> Query.Pair ("KeyPairId", (String.to_query f)));
           Some (Query.Pair ("KeyName", (String.to_query v.key_name)));
           Some
             (Query.Pair ("KeyMaterial", (String.to_query v.key_material)));
           Some
             (Query.Pair
                ("KeyFingerprint", (String.to_query v.key_fingerprint)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "keyFingerprint"
                    ([], (String.to_xml v.key_fingerprint)))])
             @
             [Some
                (Ezxmlm.make_tag "keyMaterial"
                   ([], (String.to_xml v.key_material)))])
            @
            [Some
               (Ezxmlm.make_tag "keyName" ([], (String.to_xml v.key_name)))])
           @
           [Util.option_map v.key_pair_id
              (fun f -> Ezxmlm.make_tag "keyPairId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.key_pair_id
              (fun f -> ("key_pair_id", (String.to_json f)));
           Some ("key_name", (String.to_json v.key_name));
           Some ("key_material", (String.to_json v.key_material));
           Some ("key_fingerprint", (String.to_json v.key_fingerprint))])
    let of_json j =
      {
        key_fingerprint =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "key_fingerprint")));
        key_material =
          (String.of_json (Util.of_option_exn (Json.lookup j "key_material")));
        key_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "key_name")));
        key_pair_id =
          (Util.option_map (Json.lookup j "key_pair_id") String.of_json)
      }
  end
module ModifyVpcEndpointServicePermissionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_id: String.t ;
      add_allowed_principals: ValueStringList.t ;
      remove_allowed_principals: ValueStringList.t }
    let make ?dry_run  ~service_id  ?(add_allowed_principals= []) 
      ?(remove_allowed_principals= [])  () =
      {
        dry_run;
        service_id;
        add_allowed_principals;
        remove_allowed_principals
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_id =
            (Xml.required "ServiceId"
               (Util.option_bind (Xml.member "ServiceId" xml) String.parse));
          add_allowed_principals =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddAllowedPrincipals" xml)
                  ValueStringList.parse));
          remove_allowed_principals =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveAllowedPrincipals" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RemoveAllowedPrincipals",
                   (ValueStringList.to_query v.remove_allowed_principals)));
           Some
             (Query.Pair
                ("AddAllowedPrincipals",
                  (ValueStringList.to_query v.add_allowed_principals)));
           Some (Query.Pair ("ServiceId", (String.to_query v.service_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "ServiceId"
                   ([], (String.to_xml v.service_id)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "AddAllowedPrincipals"
                       ([], (ValueStringList.to_xml [x]))))
               v.add_allowed_principals))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "RemoveAllowedPrincipals"
                      ([], (ValueStringList.to_xml [x]))))
              v.remove_allowed_principals))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("remove_allowed_principals",
                (ValueStringList.to_json v.remove_allowed_principals));
           Some
             ("add_allowed_principals",
               (ValueStringList.to_json v.add_allowed_principals));
           Some ("service_id", (String.to_json v.service_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "service_id")));
        add_allowed_principals =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "add_allowed_principals")));
        remove_allowed_principals =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "remove_allowed_principals")))
      }
  end
module RestoreAddressToClassicRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      public_ip: String.t }
    let make ?dry_run  ~public_ip  () = { dry_run; public_ip }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          public_ip =
            (Xml.required "publicIp"
               (Util.option_bind (Xml.member "publicIp" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("PublicIp", (String.to_query v.public_ip)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "publicIp" ([], (String.to_xml v.public_ip)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("public_ip", (String.to_json v.public_ip));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        public_ip =
          (String.of_json (Util.of_option_exn (Json.lookup j "public_ip")))
      }
  end
module AssignPrivateIpAddressesResult =
  struct
    type t =
      {
      network_interface_id: String.t option ;
      assigned_private_ip_addresses: AssignedPrivateIpAddressList.t }
    let make ?network_interface_id  ?(assigned_private_ip_addresses= [])  ()
      = { network_interface_id; assigned_private_ip_addresses }
    let parse xml =
      Some
        {
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          assigned_private_ip_addresses =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "assignedPrivateIpAddressesSet" xml)
                  AssignedPrivateIpAddressList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AssignedPrivateIpAddressesSet",
                   (AssignedPrivateIpAddressList.to_query
                      v.assigned_private_ip_addresses)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.network_interface_id
               (fun f ->
                  Ezxmlm.make_tag "networkInterfaceId"
                    ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "assignedPrivateIpAddressesSet"
                      ([], (AssignedPrivateIpAddressList.to_xml [x]))))
              v.assigned_private_ip_addresses))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("assigned_private_ip_addresses",
                (AssignedPrivateIpAddressList.to_json
                   v.assigned_private_ip_addresses));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)))])
    let of_json j =
      {
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        assigned_private_ip_addresses =
          (AssignedPrivateIpAddressList.of_json
             (Util.of_option_exn
                (Json.lookup j "assigned_private_ip_addresses")))
      }
  end
module DescribeIdentityIdFormatRequest =
  struct
    type t = {
      principal_arn: String.t ;
      resource: String.t option }
    let make ~principal_arn  ?resource  () = { principal_arn; resource }
    let parse xml =
      Some
        {
          principal_arn =
            (Xml.required "principalArn"
               (Util.option_bind (Xml.member "principalArn" xml) String.parse));
          resource =
            (Util.option_bind (Xml.member "resource" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.resource
              (fun f -> Query.Pair ("Resource", (String.to_query f)));
           Some
             (Query.Pair ("PrincipalArn", (String.to_query v.principal_arn)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "principalArn"
                  ([], (String.to_xml v.principal_arn)))])
           @
           [Util.option_map v.resource
              (fun f -> Ezxmlm.make_tag "resource" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.resource
              (fun f -> ("resource", (String.to_json f)));
           Some ("principal_arn", (String.to_json v.principal_arn))])
    let of_json j =
      {
        principal_arn =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "principal_arn")));
        resource =
          (Util.option_map (Json.lookup j "resource") String.of_json)
      }
  end
module DeleteVpcPeeringConnectionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_peering_connection_id: String.t }
    let make ?dry_run  ~vpc_peering_connection_id  () =
      { dry_run; vpc_peering_connection_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_peering_connection_id =
            (Xml.required "vpcPeeringConnectionId"
               (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcPeeringConnectionId",
                   (String.to_query v.vpc_peering_connection_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "vpcPeeringConnectionId"
                 ([], (String.to_xml v.vpc_peering_connection_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpc_peering_connection_id",
                (String.to_json v.vpc_peering_connection_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_peering_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpc_peering_connection_id")))
      }
  end
module ModifyInstanceEventStartTimeResult =
  struct
    type t = {
      event: InstanceStatusEvent.t option }
    let make ?event  () = { event }
    let parse xml =
      Some
        {
          event =
            (Util.option_bind (Xml.member "event" xml)
               InstanceStatusEvent.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.event
              (fun f ->
                 Query.Pair ("Event", (InstanceStatusEvent.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.event
              (fun f ->
                 Ezxmlm.make_tag "event" ([], (InstanceStatusEvent.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.event
              (fun f -> ("event", (InstanceStatusEvent.to_json f)))])
    let of_json j =
      {
        event =
          (Util.option_map (Json.lookup j "event")
             InstanceStatusEvent.of_json)
      }
  end
module RegisterTransitGatewayMulticastGroupMembersResult =
  struct
    type t =
      {
      registered_multicast_group_members:
        TransitGatewayMulticastRegisteredGroupMembers.t option }
    let make ?registered_multicast_group_members  () =
      { registered_multicast_group_members }
    let parse xml =
      Some
        {
          registered_multicast_group_members =
            (Util.option_bind
               (Xml.member "registeredMulticastGroupMembers" xml)
               TransitGatewayMulticastRegisteredGroupMembers.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.registered_multicast_group_members
              (fun f ->
                 Query.Pair
                   ("RegisteredMulticastGroupMembers",
                     (TransitGatewayMulticastRegisteredGroupMembers.to_query
                        f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.registered_multicast_group_members
              (fun f ->
                 Ezxmlm.make_tag "registeredMulticastGroupMembers"
                   ([],
                     (TransitGatewayMulticastRegisteredGroupMembers.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.registered_multicast_group_members
              (fun f ->
                 ("registered_multicast_group_members",
                   (TransitGatewayMulticastRegisteredGroupMembers.to_json f)))])
    let of_json j =
      {
        registered_multicast_group_members =
          (Util.option_map
             (Json.lookup j "registered_multicast_group_members")
             TransitGatewayMulticastRegisteredGroupMembers.of_json)
      }
  end
module CreateCustomerGatewayResult =
  struct
    type t = {
      customer_gateway: CustomerGateway.t option }
    let make ?customer_gateway  () = { customer_gateway }
    let parse xml =
      Some
        {
          customer_gateway =
            (Util.option_bind (Xml.member "customerGateway" xml)
               CustomerGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.customer_gateway
              (fun f ->
                 Query.Pair ("CustomerGateway", (CustomerGateway.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.customer_gateway
              (fun f ->
                 Ezxmlm.make_tag "customerGateway"
                   ([], (CustomerGateway.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.customer_gateway
              (fun f -> ("customer_gateway", (CustomerGateway.to_json f)))])
    let of_json j =
      {
        customer_gateway =
          (Util.option_map (Json.lookup j "customer_gateway")
             CustomerGateway.of_json)
      }
  end
module ModifyReservedInstancesResult =
  struct
    type t = {
      reserved_instances_modification_id: String.t option }
    let make ?reserved_instances_modification_id  () =
      { reserved_instances_modification_id }
    let parse xml =
      Some
        {
          reserved_instances_modification_id =
            (Util.option_bind
               (Xml.member "reservedInstancesModificationId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_modification_id
              (fun f ->
                 Query.Pair
                   ("ReservedInstancesModificationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.reserved_instances_modification_id
              (fun f ->
                 Ezxmlm.make_tag "reservedInstancesModificationId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_modification_id
              (fun f ->
                 ("reserved_instances_modification_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_modification_id =
          (Util.option_map
             (Json.lookup j "reserved_instances_modification_id")
             String.of_json)
      }
  end
module DescribeLocalGatewayRouteTableVpcAssociationsResult =
  struct
    type t =
      {
      local_gateway_route_table_vpc_associations:
        LocalGatewayRouteTableVpcAssociationSet.t ;
      next_token: String.t option }
    let make ?(local_gateway_route_table_vpc_associations= [])  ?next_token 
      () = { local_gateway_route_table_vpc_associations; next_token }
    let parse xml =
      Some
        {
          local_gateway_route_table_vpc_associations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "localGatewayRouteTableVpcAssociationSet" xml)
                  LocalGatewayRouteTableVpcAssociationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableVpcAssociationSet",
                  (LocalGatewayRouteTableVpcAssociationSet.to_query
                     v.local_gateway_route_table_vpc_associations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag
                       "localGatewayRouteTableVpcAssociationSet"
                       ([],
                         (LocalGatewayRouteTableVpcAssociationSet.to_xml [x]))))
               v.local_gateway_route_table_vpc_associations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateway_route_table_vpc_associations",
               (LocalGatewayRouteTableVpcAssociationSet.to_json
                  v.local_gateway_route_table_vpc_associations))])
    let of_json j =
      {
        local_gateway_route_table_vpc_associations =
          (LocalGatewayRouteTableVpcAssociationSet.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_route_table_vpc_associations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateLocalGatewayRouteRequest =
  struct
    type t =
      {
      destination_cidr_block: String.t ;
      local_gateway_route_table_id: String.t ;
      local_gateway_virtual_interface_group_id: String.t ;
      dry_run: Boolean.t option }
    let make ~destination_cidr_block  ~local_gateway_route_table_id 
      ~local_gateway_virtual_interface_group_id  ?dry_run  () =
      {
        destination_cidr_block;
        local_gateway_route_table_id;
        local_gateway_virtual_interface_group_id;
        dry_run
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          local_gateway_route_table_id =
            (Xml.required "LocalGatewayRouteTableId"
               (Util.option_bind (Xml.member "LocalGatewayRouteTableId" xml)
                  String.parse));
          local_gateway_virtual_interface_group_id =
            (Xml.required "LocalGatewayVirtualInterfaceGroupId"
               (Util.option_bind
                  (Xml.member "LocalGatewayVirtualInterfaceGroupId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayVirtualInterfaceGroupId",
                  (String.to_query v.local_gateway_virtual_interface_group_id)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableId",
                  (String.to_query v.local_gateway_route_table_id)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "DestinationCidrBlock"
                    ([], (String.to_xml v.destination_cidr_block)))])
             @
             [Some
                (Ezxmlm.make_tag "LocalGatewayRouteTableId"
                   ([], (String.to_xml v.local_gateway_route_table_id)))])
            @
            [Some
               (Ezxmlm.make_tag "LocalGatewayVirtualInterfaceGroupId"
                  ([],
                    (String.to_xml v.local_gateway_virtual_interface_group_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("local_gateway_virtual_interface_group_id",
               (String.to_json v.local_gateway_virtual_interface_group_id));
           Some
             ("local_gateway_route_table_id",
               (String.to_json v.local_gateway_route_table_id));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block))])
    let of_json j =
      {
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        local_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_route_table_id")));
        local_gateway_virtual_interface_group_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_virtual_interface_group_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeIamInstanceProfileAssociationsRequest =
  struct
    type t =
      {
      association_ids: AssociationIdList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(association_ids= [])  ?(filters= [])  ?max_results 
      ?next_token  () = { association_ids; filters; max_results; next_token }
    let parse xml =
      Some
        {
          association_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AssociationId" xml)
                  AssociationIdList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("AssociationId",
                  (AssociationIdList.to_query v.association_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "AssociationId"
                         ([], (AssociationIdList.to_xml [x]))))
                 v.association_ids))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("association_ids",
               (AssociationIdList.to_json v.association_ids))])
    let of_json j =
      {
        association_ids =
          (AssociationIdList.of_json
             (Util.of_option_exn (Json.lookup j "association_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifySnapshotAttributeRequest =
  struct
    type t =
      {
      attribute: SnapshotAttributeName.t option ;
      create_volume_permission: CreateVolumePermissionModifications.t option ;
      group_names: GroupNameStringList.t ;
      operation_type: OperationType.t option ;
      snapshot_id: String.t ;
      user_ids: UserIdStringList.t ;
      dry_run: Boolean.t option }
    let make ?attribute  ?create_volume_permission  ?(group_names= []) 
      ?operation_type  ~snapshot_id  ?(user_ids= [])  ?dry_run  () =
      {
        attribute;
        create_volume_permission;
        group_names;
        operation_type;
        snapshot_id;
        user_ids;
        dry_run
      }
    let parse xml =
      Some
        {
          attribute =
            (Util.option_bind (Xml.member "Attribute" xml)
               SnapshotAttributeName.parse);
          create_volume_permission =
            (Util.option_bind (Xml.member "CreateVolumePermission" xml)
               CreateVolumePermissionModifications.parse);
          group_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "UserGroup" xml)
                  GroupNameStringList.parse));
          operation_type =
            (Util.option_bind (Xml.member "OperationType" xml)
               OperationType.parse);
          snapshot_id =
            (Xml.required "SnapshotId"
               (Util.option_bind (Xml.member "SnapshotId" xml) String.parse));
          user_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "UserId" xml)
                  UserIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("UserId", (UserIdStringList.to_query v.user_ids)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Util.option_map v.operation_type
             (fun f ->
                Query.Pair ("OperationType", (OperationType.to_query f)));
           Some
             (Query.Pair
                ("UserGroup", (GroupNameStringList.to_query v.group_names)));
           Util.option_map v.create_volume_permission
             (fun f ->
                Query.Pair
                  ("CreateVolumePermission",
                    (CreateVolumePermissionModifications.to_query f)));
           Util.option_map v.attribute
             (fun f ->
                Query.Pair ("Attribute", (SnapshotAttributeName.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.attribute
                    (fun f ->
                       Ezxmlm.make_tag "Attribute"
                         ([], (SnapshotAttributeName.to_xml f)))])
                @
                [Util.option_map v.create_volume_permission
                   (fun f ->
                      Ezxmlm.make_tag "CreateVolumePermission"
                        ([], (CreateVolumePermissionModifications.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "UserGroup"
                          ([], (GroupNameStringList.to_xml [x]))))
                  v.group_names))
              @
              [Util.option_map v.operation_type
                 (fun f ->
                    Ezxmlm.make_tag "OperationType"
                      ([], (OperationType.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "SnapshotId"
                   ([], (String.to_xml v.snapshot_id)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "UserId"
                       ([], (UserIdStringList.to_xml [x])))) v.user_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("user_ids", (UserIdStringList.to_json v.user_ids));
           Some ("snapshot_id", (String.to_json v.snapshot_id));
           Util.option_map v.operation_type
             (fun f -> ("operation_type", (OperationType.to_json f)));
           Some ("group_names", (GroupNameStringList.to_json v.group_names));
           Util.option_map v.create_volume_permission
             (fun f ->
                ("create_volume_permission",
                  (CreateVolumePermissionModifications.to_json f)));
           Util.option_map v.attribute
             (fun f -> ("attribute", (SnapshotAttributeName.to_json f)))])
    let of_json j =
      {
        attribute =
          (Util.option_map (Json.lookup j "attribute")
             SnapshotAttributeName.of_json);
        create_volume_permission =
          (Util.option_map (Json.lookup j "create_volume_permission")
             CreateVolumePermissionModifications.of_json);
        group_names =
          (GroupNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_names")));
        operation_type =
          (Util.option_map (Json.lookup j "operation_type")
             OperationType.of_json);
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        user_ids =
          (UserIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "user_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyVolumeResult =
  struct
    type t = {
      volume_modification: VolumeModification.t option }
    let make ?volume_modification  () = { volume_modification }
    let parse xml =
      Some
        {
          volume_modification =
            (Util.option_bind (Xml.member "volumeModification" xml)
               VolumeModification.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_modification
              (fun f ->
                 Query.Pair
                   ("VolumeModification", (VolumeModification.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.volume_modification
              (fun f ->
                 Ezxmlm.make_tag "volumeModification"
                   ([], (VolumeModification.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_modification
              (fun f ->
                 ("volume_modification", (VolumeModification.to_json f)))])
    let of_json j =
      {
        volume_modification =
          (Util.option_map (Json.lookup j "volume_modification")
             VolumeModification.of_json)
      }
  end
module ReleaseAddressRequest =
  struct
    type t =
      {
      allocation_id: String.t option ;
      public_ip: String.t option ;
      network_border_group: String.t option ;
      dry_run: Boolean.t option }
    let make ?allocation_id  ?public_ip  ?network_border_group  ?dry_run  ()
      = { allocation_id; public_ip; network_border_group; dry_run }
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "AllocationId" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "PublicIp" xml) String.parse);
          network_border_group =
            (Util.option_bind (Xml.member "NetworkBorderGroup" xml)
               String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.network_border_group
             (fun f -> Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.allocation_id
                 (fun f ->
                    Ezxmlm.make_tag "AllocationId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.public_ip
                (fun f -> Ezxmlm.make_tag "PublicIp" ([], (String.to_xml f)))])
            @
            [Util.option_map v.network_border_group
               (fun f ->
                  Ezxmlm.make_tag "NetworkBorderGroup"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.network_border_group
             (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let of_json j =
      {
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        network_border_group =
          (Util.option_map (Json.lookup j "network_border_group")
             String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ImportSnapshotResult =
  struct
    type t =
      {
      description: String.t option ;
      import_task_id: String.t option ;
      snapshot_task_detail: SnapshotTaskDetail.t option }
    let make ?description  ?import_task_id  ?snapshot_task_detail  () =
      { description; import_task_id; snapshot_task_detail }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          snapshot_task_detail =
            (Util.option_bind (Xml.member "snapshotTaskDetail" xml)
               SnapshotTaskDetail.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.snapshot_task_detail
              (fun f ->
                 Query.Pair
                   ("SnapshotTaskDetail", (SnapshotTaskDetail.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
            @
            [Util.option_map v.import_task_id
               (fun f ->
                  Ezxmlm.make_tag "importTaskId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.snapshot_task_detail
              (fun f ->
                 Ezxmlm.make_tag "snapshotTaskDetail"
                   ([], (SnapshotTaskDetail.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.snapshot_task_detail
              (fun f ->
                 ("snapshot_task_detail", (SnapshotTaskDetail.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json);
        snapshot_task_detail =
          (Util.option_map (Json.lookup j "snapshot_task_detail")
             SnapshotTaskDetail.of_json)
      }
  end
module DescribeVolumesResult =
  struct
    type t = {
      volumes: VolumeList.t ;
      next_token: String.t option }
    let make ?(volumes= [])  ?next_token  () = { volumes; next_token }
    let parse xml =
      Some
        {
          volumes =
            (Util.of_option []
               (Util.option_bind (Xml.member "volumeSet" xml)
                  VolumeList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("VolumeSet", (VolumeList.to_query v.volumes)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "volumeSet"
                       ([], (VolumeList.to_xml [x])))) v.volumes))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("volumes", (VolumeList.to_json v.volumes))])
    let of_json j =
      {
        volumes =
          (VolumeList.of_json (Util.of_option_exn (Json.lookup j "volumes")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module EnableFastSnapshotRestoresRequest =
  struct
    type t =
      {
      availability_zones: AvailabilityZoneStringList.t ;
      source_snapshot_ids: SnapshotIdStringList.t ;
      dry_run: Boolean.t option }
    let make ~availability_zones  ~source_snapshot_ids  ?dry_run  () =
      { availability_zones; source_snapshot_ids; dry_run }
    let parse xml =
      Some
        {
          availability_zones =
            (Xml.required "AvailabilityZone"
               (Util.option_bind (Xml.member "AvailabilityZone" xml)
                  AvailabilityZoneStringList.parse));
          source_snapshot_ids =
            (Xml.required "SourceSnapshotId"
               (Util.option_bind (Xml.member "SourceSnapshotId" xml)
                  SnapshotIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SourceSnapshotId",
                  (SnapshotIdStringList.to_query v.source_snapshot_ids)));
           Some
             (Query.Pair
                ("AvailabilityZone",
                  (AvailabilityZoneStringList.to_query v.availability_zones)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "AvailabilityZone"
                        ([], (AvailabilityZoneStringList.to_xml [x]))))
                v.availability_zones))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "SourceSnapshotId"
                       ([], (SnapshotIdStringList.to_xml [x]))))
               v.source_snapshot_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("source_snapshot_ids",
               (SnapshotIdStringList.to_json v.source_snapshot_ids));
           Some
             ("availability_zones",
               (AvailabilityZoneStringList.to_json v.availability_zones))])
    let of_json j =
      {
        availability_zones =
          (AvailabilityZoneStringList.of_json
             (Util.of_option_exn (Json.lookup j "availability_zones")));
        source_snapshot_ids =
          (SnapshotIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "source_snapshot_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeClientVpnConnectionsResult =
  struct
    type t =
      {
      connections: ClientVpnConnectionSet.t ;
      next_token: String.t option }
    let make ?(connections= [])  ?next_token  () =
      { connections; next_token }
    let parse xml =
      Some
        {
          connections =
            (Util.of_option []
               (Util.option_bind (Xml.member "connections" xml)
                  ClientVpnConnectionSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("Connections",
                  (ClientVpnConnectionSet.to_query v.connections)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "connections"
                       ([], (ClientVpnConnectionSet.to_xml [x]))))
               v.connections))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("connections", (ClientVpnConnectionSet.to_json v.connections))])
    let of_json j =
      {
        connections =
          (ClientVpnConnectionSet.of_json
             (Util.of_option_exn (Json.lookup j "connections")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeFleetInstancesResult =
  struct
    type t =
      {
      active_instances: ActiveInstanceSet.t ;
      next_token: String.t option ;
      fleet_id: String.t option }
    let make ?(active_instances= [])  ?next_token  ?fleet_id  () =
      { active_instances; next_token; fleet_id }
    let parse xml =
      Some
        {
          active_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "activeInstanceSet" xml)
                  ActiveInstanceSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> Query.Pair ("FleetId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ActiveInstanceSet",
                  (ActiveInstanceSet.to_query v.active_instances)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "activeInstanceSet"
                        ([], (ActiveInstanceSet.to_xml [x]))))
                v.active_instances))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.fleet_id
              (fun f -> Ezxmlm.make_tag "fleetId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> ("fleet_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("active_instances",
               (ActiveInstanceSet.to_json v.active_instances))])
    let of_json j =
      {
        active_instances =
          (ActiveInstanceSet.of_json
             (Util.of_option_exn (Json.lookup j "active_instances")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        fleet_id =
          (Util.option_map (Json.lookup j "fleet_id") String.of_json)
      }
  end
module AttachNetworkInterfaceResult =
  struct
    type t = {
      attachment_id: String.t option }
    let make ?attachment_id  () = { attachment_id }
    let parse xml =
      Some
        {
          attachment_id =
            (Util.option_bind (Xml.member "attachmentId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.attachment_id
              (fun f -> Query.Pair ("AttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.attachment_id
              (fun f ->
                 Ezxmlm.make_tag "attachmentId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.attachment_id
              (fun f -> ("attachment_id", (String.to_json f)))])
    let of_json j =
      {
        attachment_id =
          (Util.option_map (Json.lookup j "attachment_id") String.of_json)
      }
  end
module CreateTrafficMirrorFilterRuleRequest =
  struct
    type t =
      {
      traffic_mirror_filter_id: String.t ;
      traffic_direction: TrafficDirection.t ;
      rule_number: Integer.t ;
      rule_action: TrafficMirrorRuleAction.t ;
      destination_port_range: TrafficMirrorPortRangeRequest.t option ;
      source_port_range: TrafficMirrorPortRangeRequest.t option ;
      protocol: Integer.t option ;
      destination_cidr_block: String.t ;
      source_cidr_block: String.t ;
      description: String.t option ;
      dry_run: Boolean.t option ;
      client_token: String.t option }
    let make ~traffic_mirror_filter_id  ~traffic_direction  ~rule_number 
      ~rule_action  ?destination_port_range  ?source_port_range  ?protocol 
      ~destination_cidr_block  ~source_cidr_block  ?description  ?dry_run 
      ?client_token  () =
      {
        traffic_mirror_filter_id;
        traffic_direction;
        rule_number;
        rule_action;
        destination_port_range;
        source_port_range;
        protocol;
        destination_cidr_block;
        source_cidr_block;
        description;
        dry_run;
        client_token
      }
    let parse xml =
      Some
        {
          traffic_mirror_filter_id =
            (Xml.required "TrafficMirrorFilterId"
               (Util.option_bind (Xml.member "TrafficMirrorFilterId" xml)
                  String.parse));
          traffic_direction =
            (Xml.required "TrafficDirection"
               (Util.option_bind (Xml.member "TrafficDirection" xml)
                  TrafficDirection.parse));
          rule_number =
            (Xml.required "RuleNumber"
               (Util.option_bind (Xml.member "RuleNumber" xml) Integer.parse));
          rule_action =
            (Xml.required "RuleAction"
               (Util.option_bind (Xml.member "RuleAction" xml)
                  TrafficMirrorRuleAction.parse));
          destination_port_range =
            (Util.option_bind (Xml.member "DestinationPortRange" xml)
               TrafficMirrorPortRangeRequest.parse);
          source_port_range =
            (Util.option_bind (Xml.member "SourcePortRange" xml)
               TrafficMirrorPortRangeRequest.parse);
          protocol =
            (Util.option_bind (Xml.member "Protocol" xml) Integer.parse);
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          source_cidr_block =
            (Xml.required "SourceCidrBlock"
               (Util.option_bind (Xml.member "SourceCidrBlock" xml)
                  String.parse));
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("SourceCidrBlock", (String.to_query v.source_cidr_block)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)));
           Util.option_map v.protocol
             (fun f -> Query.Pair ("Protocol", (Integer.to_query f)));
           Util.option_map v.source_port_range
             (fun f ->
                Query.Pair
                  ("SourcePortRange",
                    (TrafficMirrorPortRangeRequest.to_query f)));
           Util.option_map v.destination_port_range
             (fun f ->
                Query.Pair
                  ("DestinationPortRange",
                    (TrafficMirrorPortRangeRequest.to_query f)));
           Some
             (Query.Pair
                ("RuleAction",
                  (TrafficMirrorRuleAction.to_query v.rule_action)));
           Some (Query.Pair ("RuleNumber", (Integer.to_query v.rule_number)));
           Some
             (Query.Pair
                ("TrafficDirection",
                  (TrafficDirection.to_query v.traffic_direction)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterId",
                  (String.to_query v.traffic_mirror_filter_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Some
                         (Ezxmlm.make_tag "TrafficMirrorFilterId"
                            ([], (String.to_xml v.traffic_mirror_filter_id)))])
                     @
                     [Some
                        (Ezxmlm.make_tag "TrafficDirection"
                           ([],
                             (TrafficDirection.to_xml v.traffic_direction)))])
                    @
                    [Some
                       (Ezxmlm.make_tag "RuleNumber"
                          ([], (Integer.to_xml v.rule_number)))])
                   @
                   [Some
                      (Ezxmlm.make_tag "RuleAction"
                         ([], (TrafficMirrorRuleAction.to_xml v.rule_action)))])
                  @
                  [Util.option_map v.destination_port_range
                     (fun f ->
                        Ezxmlm.make_tag "DestinationPortRange"
                          ([], (TrafficMirrorPortRangeRequest.to_xml f)))])
                 @
                 [Util.option_map v.source_port_range
                    (fun f ->
                       Ezxmlm.make_tag "SourcePortRange"
                         ([], (TrafficMirrorPortRangeRequest.to_xml f)))])
                @
                [Util.option_map v.protocol
                   (fun f ->
                      Ezxmlm.make_tag "Protocol" ([], (Integer.to_xml f)))])
               @
               [Some
                  (Ezxmlm.make_tag "DestinationCidrBlock"
                     ([], (String.to_xml v.destination_cidr_block)))])
              @
              [Some
                 (Ezxmlm.make_tag "SourceCidrBlock"
                    ([], (String.to_xml v.source_cidr_block)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some ("source_cidr_block", (String.to_json v.source_cidr_block));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block));
           Util.option_map v.protocol
             (fun f -> ("protocol", (Integer.to_json f)));
           Util.option_map v.source_port_range
             (fun f ->
                ("source_port_range",
                  (TrafficMirrorPortRangeRequest.to_json f)));
           Util.option_map v.destination_port_range
             (fun f ->
                ("destination_port_range",
                  (TrafficMirrorPortRangeRequest.to_json f)));
           Some
             ("rule_action", (TrafficMirrorRuleAction.to_json v.rule_action));
           Some ("rule_number", (Integer.to_json v.rule_number));
           Some
             ("traffic_direction",
               (TrafficDirection.to_json v.traffic_direction));
           Some
             ("traffic_mirror_filter_id",
               (String.to_json v.traffic_mirror_filter_id))])
    let of_json j =
      {
        traffic_mirror_filter_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_filter_id")));
        traffic_direction =
          (TrafficDirection.of_json
             (Util.of_option_exn (Json.lookup j "traffic_direction")));
        rule_number =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "rule_number")));
        rule_action =
          (TrafficMirrorRuleAction.of_json
             (Util.of_option_exn (Json.lookup j "rule_action")));
        destination_port_range =
          (Util.option_map (Json.lookup j "destination_port_range")
             TrafficMirrorPortRangeRequest.of_json);
        source_port_range =
          (Util.option_map (Json.lookup j "source_port_range")
             TrafficMirrorPortRangeRequest.of_json);
        protocol =
          (Util.option_map (Json.lookup j "protocol") Integer.of_json);
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        source_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_cidr_block")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeVolumesModificationsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      volume_ids: VolumeIdStringList.t ;
      filters: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?dry_run  ?(volume_ids= [])  ?(filters= [])  ?next_token 
      ?max_results  () =
      { dry_run; volume_ids; filters; next_token; max_results }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          volume_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VolumeId" xml)
                  VolumeIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("VolumeId", (VolumeIdStringList.to_query v.volume_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "VolumeId"
                         ([], (VolumeIdStringList.to_xml [x])))) v.volume_ids))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("volume_ids", (VolumeIdStringList.to_json v.volume_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        volume_ids =
          (VolumeIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "volume_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DescribeLocalGatewayRouteTablesResult =
  struct
    type t =
      {
      local_gateway_route_tables: LocalGatewayRouteTableSet.t ;
      next_token: String.t option }
    let make ?(local_gateway_route_tables= [])  ?next_token  () =
      { local_gateway_route_tables; next_token }
    let parse xml =
      Some
        {
          local_gateway_route_tables =
            (Util.of_option []
               (Util.option_bind (Xml.member "localGatewayRouteTableSet" xml)
                  LocalGatewayRouteTableSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableSet",
                  (LocalGatewayRouteTableSet.to_query
                     v.local_gateway_route_tables)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "localGatewayRouteTableSet"
                       ([], (LocalGatewayRouteTableSet.to_xml [x]))))
               v.local_gateway_route_tables))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateway_route_tables",
               (LocalGatewayRouteTableSet.to_json
                  v.local_gateway_route_tables))])
    let of_json j =
      {
        local_gateway_route_tables =
          (LocalGatewayRouteTableSet.of_json
             (Util.of_option_exn (Json.lookup j "local_gateway_route_tables")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeReservedInstancesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      offering_class: OfferingClassType.t option ;
      reserved_instances_ids: ReservedInstancesIdStringList.t ;
      dry_run: Boolean.t option ;
      offering_type: OfferingTypeValues.t option }
    let make ?(filters= [])  ?offering_class  ?(reserved_instances_ids= []) 
      ?dry_run  ?offering_type  () =
      {
        filters;
        offering_class;
        reserved_instances_ids;
        dry_run;
        offering_type
      }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          offering_class =
            (Util.option_bind (Xml.member "OfferingClass" xml)
               OfferingClassType.parse);
          reserved_instances_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ReservedInstancesId" xml)
                  ReservedInstancesIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          offering_type =
            (Util.option_bind (Xml.member "offeringType" xml)
               OfferingTypeValues.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.offering_type
              (fun f ->
                 Query.Pair ("OfferingType", (OfferingTypeValues.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesId",
                  (ReservedInstancesIdStringList.to_query
                     v.reserved_instances_ids)));
           Util.option_map v.offering_class
             (fun f ->
                Query.Pair ("OfferingClass", (OfferingClassType.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filter"
                          ([], (FilterList.to_xml [x])))) v.filters))
              @
              [Util.option_map v.offering_class
                 (fun f ->
                    Ezxmlm.make_tag "OfferingClass"
                      ([], (OfferingClassType.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "ReservedInstancesId"
                        ([], (ReservedInstancesIdStringList.to_xml [x]))))
                v.reserved_instances_ids))
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.offering_type
              (fun f ->
                 Ezxmlm.make_tag "offeringType"
                   ([], (OfferingTypeValues.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.offering_type
              (fun f -> ("offering_type", (OfferingTypeValues.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("reserved_instances_ids",
               (ReservedInstancesIdStringList.to_json
                  v.reserved_instances_ids));
           Util.option_map v.offering_class
             (fun f -> ("offering_class", (OfferingClassType.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        offering_class =
          (Util.option_map (Json.lookup j "offering_class")
             OfferingClassType.of_json);
        reserved_instances_ids =
          (ReservedInstancesIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        offering_type =
          (Util.option_map (Json.lookup j "offering_type")
             OfferingTypeValues.of_json)
      }
  end
module DescribeVpcClassicLinkRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      vpc_ids: VpcClassicLinkIdList.t }
    let make ?(filters= [])  ?dry_run  ?(vpc_ids= [])  () =
      { filters; dry_run; vpc_ids }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpcId" xml)
                  VpcClassicLinkIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcId", (VpcClassicLinkIdList.to_query v.vpc_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "VpcId"
                      ([], (VpcClassicLinkIdList.to_xml [x])))) v.vpc_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_ids", (VpcClassicLinkIdList.to_json v.vpc_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_ids =
          (VpcClassicLinkIdList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_ids")))
      }
  end
module EnableVpcClassicLinkDnsSupportRequest =
  struct
    type t = {
      vpc_id: String.t option }
    let make ?vpc_id  () = { vpc_id }
    let parse xml =
      Some
        { vpc_id = (Util.option_bind (Xml.member "VpcId" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "VpcId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)))])
    let of_json j =
      { vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json) }
  end
module ModifyVpnTunnelOptionsResult =
  struct
    type t = {
      vpn_connection: VpnConnection.t option }
    let make ?vpn_connection  () = { vpn_connection }
    let parse xml =
      Some
        {
          vpn_connection =
            (Util.option_bind (Xml.member "vpnConnection" xml)
               VpnConnection.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f ->
                 Query.Pair ("VpnConnection", (VpnConnection.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpn_connection
              (fun f ->
                 Ezxmlm.make_tag "vpnConnection"
                   ([], (VpnConnection.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f -> ("vpn_connection", (VpnConnection.to_json f)))])
    let of_json j =
      {
        vpn_connection =
          (Util.option_map (Json.lookup j "vpn_connection")
             VpnConnection.of_json)
      }
  end
module DeleteTransitGatewayPeeringAttachmentResult =
  struct
    type t =
      {
      transit_gateway_peering_attachment:
        TransitGatewayPeeringAttachment.t option }
    let make ?transit_gateway_peering_attachment  () =
      { transit_gateway_peering_attachment }
    let parse xml =
      Some
        {
          transit_gateway_peering_attachment =
            (Util.option_bind
               (Xml.member "transitGatewayPeeringAttachment" xml)
               TransitGatewayPeeringAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayPeeringAttachment",
                     (TransitGatewayPeeringAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayPeeringAttachment"
                   ([], (TransitGatewayPeeringAttachment.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 ("transit_gateway_peering_attachment",
                   (TransitGatewayPeeringAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_peering_attachment =
          (Util.option_map
             (Json.lookup j "transit_gateway_peering_attachment")
             TransitGatewayPeeringAttachment.of_json)
      }
  end
module DescribeRegionsResult =
  struct
    type t = {
      regions: RegionList.t }
    let make ?(regions= [])  () = { regions }
    let parse xml =
      Some
        {
          regions =
            (Util.of_option []
               (Util.option_bind (Xml.member "regionInfo" xml)
                  RegionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("RegionInfo", (RegionList.to_query v.regions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "regionInfo"
                      ([], (RegionList.to_xml [x])))) v.regions))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("regions", (RegionList.to_json v.regions))])
    let of_json j =
      {
        regions =
          (RegionList.of_json (Util.of_option_exn (Json.lookup j "regions")))
      }
  end
module CreateVpnConnectionRequest =
  struct
    type t =
      {
      customer_gateway_id: String.t ;
      type_: String.t ;
      vpn_gateway_id: String.t option ;
      transit_gateway_id: String.t option ;
      dry_run: Boolean.t option ;
      options: VpnConnectionOptionsSpecification.t option }
    let make ~customer_gateway_id  ~type_  ?vpn_gateway_id 
      ?transit_gateway_id  ?dry_run  ?options  () =
      {
        customer_gateway_id;
        type_;
        vpn_gateway_id;
        transit_gateway_id;
        dry_run;
        options
      }
    let parse xml =
      Some
        {
          customer_gateway_id =
            (Xml.required "CustomerGatewayId"
               (Util.option_bind (Xml.member "CustomerGatewayId" xml)
                  String.parse));
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) String.parse));
          vpn_gateway_id =
            (Util.option_bind (Xml.member "VpnGatewayId" xml) String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "TransitGatewayId" xml)
               String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          options =
            (Util.option_bind (Xml.member "options" xml)
               VpnConnectionOptionsSpecification.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.options
              (fun f ->
                 Query.Pair
                   ("Options",
                     (VpnConnectionOptionsSpecification.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> Query.Pair ("VpnGatewayId", (String.to_query f)));
           Some (Query.Pair ("Type", (String.to_query v.type_)));
           Some
             (Query.Pair
                ("CustomerGatewayId",
                  (String.to_query v.customer_gateway_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Some
                   (Ezxmlm.make_tag "CustomerGatewayId"
                      ([], (String.to_xml v.customer_gateway_id)))])
               @
               [Some (Ezxmlm.make_tag "Type" ([], (String.to_xml v.type_)))])
              @
              [Util.option_map v.vpn_gateway_id
                 (fun f ->
                    Ezxmlm.make_tag "VpnGatewayId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.transit_gateway_id
                (fun f ->
                   Ezxmlm.make_tag "TransitGatewayId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.options
              (fun f ->
                 Ezxmlm.make_tag "options"
                   ([], (VpnConnectionOptionsSpecification.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.options
              (fun f ->
                 ("options", (VpnConnectionOptionsSpecification.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> ("vpn_gateway_id", (String.to_json f)));
           Some ("type_", (String.to_json v.type_));
           Some
             ("customer_gateway_id", (String.to_json v.customer_gateway_id))])
    let of_json j =
      {
        customer_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateway_id")));
        type_ = (String.of_json (Util.of_option_exn (Json.lookup j "type_")));
        vpn_gateway_id =
          (Util.option_map (Json.lookup j "vpn_gateway_id") String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        options =
          (Util.option_map (Json.lookup j "options")
             VpnConnectionOptionsSpecification.of_json)
      }
  end
module ExportImageResult =
  struct
    type t =
      {
      description: String.t option ;
      disk_image_format: DiskImageFormat.t option ;
      export_image_task_id: String.t option ;
      image_id: String.t option ;
      role_name: String.t option ;
      progress: String.t option ;
      s3_export_location: ExportTaskS3Location.t option ;
      status: String.t option ;
      status_message: String.t option }
    let make ?description  ?disk_image_format  ?export_image_task_id 
      ?image_id  ?role_name  ?progress  ?s3_export_location  ?status 
      ?status_message  () =
      {
        description;
        disk_image_format;
        export_image_task_id;
        image_id;
        role_name;
        progress;
        s3_export_location;
        status;
        status_message
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          disk_image_format =
            (Util.option_bind (Xml.member "diskImageFormat" xml)
               DiskImageFormat.parse);
          export_image_task_id =
            (Util.option_bind (Xml.member "exportImageTaskId" xml)
               String.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          role_name =
            (Util.option_bind (Xml.member "roleName" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          s3_export_location =
            (Util.option_bind (Xml.member "s3ExportLocation" xml)
               ExportTaskS3Location.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.s3_export_location
             (fun f ->
                Query.Pair
                  ("S3ExportLocation", (ExportTaskS3Location.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.role_name
             (fun f -> Query.Pair ("RoleName", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.export_image_task_id
             (fun f -> Query.Pair ("ExportImageTaskId", (String.to_query f)));
           Util.option_map v.disk_image_format
             (fun f ->
                Query.Pair ("DiskImageFormat", (DiskImageFormat.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.description
                      (fun f ->
                         Ezxmlm.make_tag "description"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.disk_image_format
                     (fun f ->
                        Ezxmlm.make_tag "diskImageFormat"
                          ([], (DiskImageFormat.to_xml f)))])
                 @
                 [Util.option_map v.export_image_task_id
                    (fun f ->
                       Ezxmlm.make_tag "exportImageTaskId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.image_id
                   (fun f ->
                      Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.role_name
                  (fun f ->
                     Ezxmlm.make_tag "roleName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.progress
                 (fun f -> Ezxmlm.make_tag "progress" ([], (String.to_xml f)))])
             @
             [Util.option_map v.s3_export_location
                (fun f ->
                   Ezxmlm.make_tag "s3ExportLocation"
                     ([], (ExportTaskS3Location.to_xml f)))])
            @
            [Util.option_map v.status
               (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status_message
              (fun f ->
                 Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.s3_export_location
             (fun f ->
                ("s3_export_location", (ExportTaskS3Location.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.role_name
             (fun f -> ("role_name", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.export_image_task_id
             (fun f -> ("export_image_task_id", (String.to_json f)));
           Util.option_map v.disk_image_format
             (fun f -> ("disk_image_format", (DiskImageFormat.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        disk_image_format =
          (Util.option_map (Json.lookup j "disk_image_format")
             DiskImageFormat.of_json);
        export_image_task_id =
          (Util.option_map (Json.lookup j "export_image_task_id")
             String.of_json);
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        role_name =
          (Util.option_map (Json.lookup j "role_name") String.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        s3_export_location =
          (Util.option_map (Json.lookup j "s3_export_location")
             ExportTaskS3Location.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json)
      }
  end
module DeleteClientVpnEndpointRequest =
  struct
    type t = {
      client_vpn_endpoint_id: String.t ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?dry_run  () =
      { client_vpn_endpoint_id; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "ClientVpnEndpointId"
                  ([], (String.to_xml v.client_vpn_endpoint_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AllocateHostsRequest =
  struct
    type t =
      {
      auto_placement: AutoPlacement.t option ;
      availability_zone: String.t ;
      client_token: String.t option ;
      instance_type: String.t option ;
      instance_family: String.t option ;
      quantity: Integer.t ;
      tag_specifications: TagSpecificationList.t ;
      host_recovery: HostRecovery.t option }
    let make ?auto_placement  ~availability_zone  ?client_token 
      ?instance_type  ?instance_family  ~quantity  ?(tag_specifications= []) 
      ?host_recovery  () =
      {
        auto_placement;
        availability_zone;
        client_token;
        instance_type;
        instance_family;
        quantity;
        tag_specifications;
        host_recovery
      }
    let parse xml =
      Some
        {
          auto_placement =
            (Util.option_bind (Xml.member "autoPlacement" xml)
               AutoPlacement.parse);
          availability_zone =
            (Xml.required "availabilityZone"
               (Util.option_bind (Xml.member "availabilityZone" xml)
                  String.parse));
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          instance_family =
            (Util.option_bind (Xml.member "InstanceFamily" xml) String.parse);
          quantity =
            (Xml.required "quantity"
               (Util.option_bind (Xml.member "quantity" xml) Integer.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          host_recovery =
            (Util.option_bind (Xml.member "HostRecovery" xml)
               HostRecovery.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.host_recovery
              (fun f ->
                 Query.Pair ("HostRecovery", (HostRecovery.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("Quantity", (Integer.to_query v.quantity)));
           Util.option_map v.instance_family
             (fun f -> Query.Pair ("InstanceFamily", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)));
           Util.option_map v.auto_placement
             (fun f ->
                Query.Pair ("AutoPlacement", (AutoPlacement.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.auto_placement
                     (fun f ->
                        Ezxmlm.make_tag "autoPlacement"
                          ([], (AutoPlacement.to_xml f)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "availabilityZone"
                       ([], (String.to_xml v.availability_zone)))])
                @
                [Util.option_map v.client_token
                   (fun f ->
                      Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
               @
               [Util.option_map v.instance_type
                  (fun f ->
                     Ezxmlm.make_tag "instanceType" ([], (String.to_xml f)))])
              @
              [Util.option_map v.instance_family
                 (fun f ->
                    Ezxmlm.make_tag "InstanceFamily" ([], (String.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "quantity" ([], (Integer.to_xml v.quantity)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "TagSpecification"
                       ([], (TagSpecificationList.to_xml [x]))))
               v.tag_specifications))
           @
           [Util.option_map v.host_recovery
              (fun f ->
                 Ezxmlm.make_tag "HostRecovery" ([], (HostRecovery.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.host_recovery
              (fun f -> ("host_recovery", (HostRecovery.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("quantity", (Integer.to_json v.quantity));
           Util.option_map v.instance_family
             (fun f -> ("instance_family", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some ("availability_zone", (String.to_json v.availability_zone));
           Util.option_map v.auto_placement
             (fun f -> ("auto_placement", (AutoPlacement.to_json f)))])
    let of_json j =
      {
        auto_placement =
          (Util.option_map (Json.lookup j "auto_placement")
             AutoPlacement.of_json);
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        instance_family =
          (Util.option_map (Json.lookup j "instance_family") String.of_json);
        quantity =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "quantity")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        host_recovery =
          (Util.option_map (Json.lookup j "host_recovery")
             HostRecovery.of_json)
      }
  end
module ModifyCapacityReservationRequest =
  struct
    type t =
      {
      capacity_reservation_id: String.t ;
      instance_count: Integer.t option ;
      end_date: DateTime.t option ;
      end_date_type: EndDateType.t option ;
      dry_run: Boolean.t option }
    let make ~capacity_reservation_id  ?instance_count  ?end_date 
      ?end_date_type  ?dry_run  () =
      {
        capacity_reservation_id;
        instance_count;
        end_date;
        end_date_type;
        dry_run
      }
    let parse xml =
      Some
        {
          capacity_reservation_id =
            (Xml.required "CapacityReservationId"
               (Util.option_bind (Xml.member "CapacityReservationId" xml)
                  String.parse));
          instance_count =
            (Util.option_bind (Xml.member "InstanceCount" xml) Integer.parse);
          end_date =
            (Util.option_bind (Xml.member "EndDate" xml) DateTime.parse);
          end_date_type =
            (Util.option_bind (Xml.member "EndDateType" xml)
               EndDateType.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.end_date_type
             (fun f -> Query.Pair ("EndDateType", (EndDateType.to_query f)));
           Util.option_map v.end_date
             (fun f -> Query.Pair ("EndDate", (DateTime.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("CapacityReservationId",
                  (String.to_query v.capacity_reservation_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "CapacityReservationId"
                     ([], (String.to_xml v.capacity_reservation_id)))])
              @
              [Util.option_map v.instance_count
                 (fun f ->
                    Ezxmlm.make_tag "InstanceCount" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.end_date
                (fun f -> Ezxmlm.make_tag "EndDate" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.end_date_type
               (fun f ->
                  Ezxmlm.make_tag "EndDateType" ([], (EndDateType.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.end_date_type
             (fun f -> ("end_date_type", (EndDateType.to_json f)));
           Util.option_map v.end_date
             (fun f -> ("end_date", (DateTime.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Some
             ("capacity_reservation_id",
               (String.to_json v.capacity_reservation_id))])
    let of_json j =
      {
        capacity_reservation_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "capacity_reservation_id")));
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        end_date =
          (Util.option_map (Json.lookup j "end_date") DateTime.of_json);
        end_date_type =
          (Util.option_map (Json.lookup j "end_date_type")
             EndDateType.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateDhcpOptionsResult =
  struct
    type t = {
      dhcp_options: DhcpOptions.t option }
    let make ?dhcp_options  () = { dhcp_options }
    let parse xml =
      Some
        {
          dhcp_options =
            (Util.option_bind (Xml.member "dhcpOptions" xml)
               DhcpOptions.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dhcp_options
              (fun f -> Query.Pair ("DhcpOptions", (DhcpOptions.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.dhcp_options
              (fun f ->
                 Ezxmlm.make_tag "dhcpOptions" ([], (DhcpOptions.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dhcp_options
              (fun f -> ("dhcp_options", (DhcpOptions.to_json f)))])
    let of_json j =
      {
        dhcp_options =
          (Util.option_map (Json.lookup j "dhcp_options") DhcpOptions.of_json)
      }
  end
module ProvisionByoipCidrRequest =
  struct
    type t =
      {
      cidr: String.t ;
      cidr_authorization_context: CidrAuthorizationContext.t option ;
      description: String.t option ;
      dry_run: Boolean.t option }
    let make ~cidr  ?cidr_authorization_context  ?description  ?dry_run  () =
      { cidr; cidr_authorization_context; description; dry_run }
    let parse xml =
      Some
        {
          cidr =
            (Xml.required "Cidr"
               (Util.option_bind (Xml.member "Cidr" xml) String.parse));
          cidr_authorization_context =
            (Util.option_bind (Xml.member "CidrAuthorizationContext" xml)
               CidrAuthorizationContext.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.cidr_authorization_context
             (fun f ->
                Query.Pair
                  ("CidrAuthorizationContext",
                    (CidrAuthorizationContext.to_query f)));
           Some (Query.Pair ("Cidr", (String.to_query v.cidr)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @ [Some (Ezxmlm.make_tag "Cidr" ([], (String.to_xml v.cidr)))])
             @
             [Util.option_map v.cidr_authorization_context
                (fun f ->
                   Ezxmlm.make_tag "CidrAuthorizationContext"
                     ([], (CidrAuthorizationContext.to_xml f)))])
            @
            [Util.option_map v.description
               (fun f ->
                  Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.cidr_authorization_context
             (fun f ->
                ("cidr_authorization_context",
                  (CidrAuthorizationContext.to_json f)));
           Some ("cidr", (String.to_json v.cidr))])
    let of_json j =
      {
        cidr = (String.of_json (Util.of_option_exn (Json.lookup j "cidr")));
        cidr_authorization_context =
          (Util.option_map (Json.lookup j "cidr_authorization_context")
             CidrAuthorizationContext.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ConfirmProductInstanceResult =
  struct
    type t = {
      owner_id: String.t option ;
      return: Boolean.t option }
    let make ?owner_id  ?return  () = { owner_id; return }
    let parse xml =
      Some
        {
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.owner_id
               (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)))])
    let of_json j =
      {
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        return = (Util.option_map (Json.lookup j "return") Boolean.of_json)
      }
  end
module ModifyTransitGatewayVpcAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t ;
      add_subnet_ids: ValueStringList.t ;
      remove_subnet_ids: ValueStringList.t ;
      options: ModifyTransitGatewayVpcAttachmentRequestOptions.t option ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_attachment_id  ?(add_subnet_ids= []) 
      ?(remove_subnet_ids= [])  ?options  ?dry_run  () =
      {
        transit_gateway_attachment_id;
        add_subnet_ids;
        remove_subnet_ids;
        options;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          add_subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddSubnetIds" xml)
                  ValueStringList.parse));
          remove_subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveSubnetIds" xml)
                  ValueStringList.parse));
          options =
            (Util.option_bind (Xml.member "Options" xml)
               ModifyTransitGatewayVpcAttachmentRequestOptions.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.options
             (fun f ->
                Query.Pair
                  ("Options",
                    (ModifyTransitGatewayVpcAttachmentRequestOptions.to_query
                       f)));
           Some
             (Query.Pair
                ("RemoveSubnetIds",
                  (ValueStringList.to_query v.remove_subnet_ids)));
           Some
             (Query.Pair
                ("AddSubnetIds", (ValueStringList.to_query v.add_subnet_ids)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "TransitGatewayAttachmentId"
                     ([], (String.to_xml v.transit_gateway_attachment_id)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "AddSubnetIds"
                         ([], (ValueStringList.to_xml [x]))))
                 v.add_subnet_ids))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "RemoveSubnetIds"
                        ([], (ValueStringList.to_xml [x]))))
                v.remove_subnet_ids))
            @
            [Util.option_map v.options
               (fun f ->
                  Ezxmlm.make_tag "Options"
                    ([],
                      (ModifyTransitGatewayVpcAttachmentRequestOptions.to_xml
                         f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.options
             (fun f ->
                ("options",
                  (ModifyTransitGatewayVpcAttachmentRequestOptions.to_json f)));
           Some
             ("remove_subnet_ids",
               (ValueStringList.to_json v.remove_subnet_ids));
           Some
             ("add_subnet_ids", (ValueStringList.to_json v.add_subnet_ids));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        add_subnet_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "add_subnet_ids")));
        remove_subnet_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "remove_subnet_ids")));
        options =
          (Util.option_map (Json.lookup j "options")
             ModifyTransitGatewayVpcAttachmentRequestOptions.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateRouteRequest =
  struct
    type t =
      {
      destination_cidr_block: String.t option ;
      destination_ipv6_cidr_block: String.t option ;
      dry_run: Boolean.t option ;
      egress_only_internet_gateway_id: String.t option ;
      gateway_id: String.t option ;
      instance_id: String.t option ;
      nat_gateway_id: String.t option ;
      transit_gateway_id: String.t option ;
      local_gateway_id: String.t option ;
      network_interface_id: String.t option ;
      route_table_id: String.t ;
      vpc_peering_connection_id: String.t option }
    let make ?destination_cidr_block  ?destination_ipv6_cidr_block  ?dry_run 
      ?egress_only_internet_gateway_id  ?gateway_id  ?instance_id 
      ?nat_gateway_id  ?transit_gateway_id  ?local_gateway_id 
      ?network_interface_id  ~route_table_id  ?vpc_peering_connection_id  ()
      =
      {
        destination_cidr_block;
        destination_ipv6_cidr_block;
        dry_run;
        egress_only_internet_gateway_id;
        gateway_id;
        instance_id;
        nat_gateway_id;
        transit_gateway_id;
        local_gateway_id;
        network_interface_id;
        route_table_id;
        vpc_peering_connection_id
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          destination_ipv6_cidr_block =
            (Util.option_bind (Xml.member "destinationIpv6CidrBlock" xml)
               String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          egress_only_internet_gateway_id =
            (Util.option_bind (Xml.member "egressOnlyInternetGatewayId" xml)
               String.parse);
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          nat_gateway_id =
            (Util.option_bind (Xml.member "natGatewayId" xml) String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "TransitGatewayId" xml)
               String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "LocalGatewayId" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse));
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Some
             (Query.Pair ("RouteTableId", (String.to_query v.route_table_id)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.nat_gateway_id
             (fun f -> Query.Pair ("NatGatewayId", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.gateway_id
             (fun f -> Query.Pair ("GatewayId", (String.to_query f)));
           Util.option_map v.egress_only_internet_gateway_id
             (fun f ->
                Query.Pair
                  ("EgressOnlyInternetGatewayId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f ->
                Query.Pair ("DestinationIpv6CidrBlock", (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Util.option_map v.destination_cidr_block
                         (fun f ->
                            Ezxmlm.make_tag "destinationCidrBlock"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.destination_ipv6_cidr_block
                        (fun f ->
                           Ezxmlm.make_tag "destinationIpv6CidrBlock"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.dry_run
                       (fun f ->
                          Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
                   @
                   [Util.option_map v.egress_only_internet_gateway_id
                      (fun f ->
                         Ezxmlm.make_tag "egressOnlyInternetGatewayId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.gateway_id
                     (fun f ->
                        Ezxmlm.make_tag "gatewayId" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.instance_id
                    (fun f ->
                       Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.nat_gateway_id
                   (fun f ->
                      Ezxmlm.make_tag "natGatewayId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.transit_gateway_id
                  (fun f ->
                     Ezxmlm.make_tag "TransitGatewayId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.local_gateway_id
                 (fun f ->
                    Ezxmlm.make_tag "LocalGatewayId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.network_interface_id
                (fun f ->
                   Ezxmlm.make_tag "networkInterfaceId"
                     ([], (String.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "routeTableId"
                  ([], (String.to_xml v.route_table_id)))])
           @
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Ezxmlm.make_tag "vpcPeeringConnectionId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Some ("route_table_id", (String.to_json v.route_table_id));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.nat_gateway_id
             (fun f -> ("nat_gateway_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.gateway_id
             (fun f -> ("gateway_id", (String.to_json f)));
           Util.option_map v.egress_only_internet_gateway_id
             (fun f ->
                ("egress_only_internet_gateway_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f -> ("destination_ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        destination_ipv6_cidr_block =
          (Util.option_map (Json.lookup j "destination_ipv6_cidr_block")
             String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        egress_only_internet_gateway_id =
          (Util.option_map (Json.lookup j "egress_only_internet_gateway_id")
             String.of_json);
        gateway_id =
          (Util.option_map (Json.lookup j "gateway_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        nat_gateway_id =
          (Util.option_map (Json.lookup j "nat_gateway_id") String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")));
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module DisableEbsEncryptionByDefaultRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeAddressesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      public_ips: PublicIpStringList.t ;
      allocation_ids: AllocationIdList.t ;
      dry_run: Boolean.t option }
    let make ?(filters= [])  ?(public_ips= [])  ?(allocation_ids= []) 
      ?dry_run  () = { filters; public_ips; allocation_ids; dry_run }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          public_ips =
            (Util.of_option []
               (Util.option_bind (Xml.member "PublicIp" xml)
                  PublicIpStringList.parse));
          allocation_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AllocationId" xml)
                  AllocationIdList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AllocationId",
                  (AllocationIdList.to_query v.allocation_ids)));
           Some
             (Query.Pair
                ("PublicIp", (PublicIpStringList.to_query v.public_ips)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "PublicIp"
                        ([], (PublicIpStringList.to_xml [x])))) v.public_ips))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "AllocationId"
                       ([], (AllocationIdList.to_xml [x])))) v.allocation_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("allocation_ids", (AllocationIdList.to_json v.allocation_ids));
           Some ("public_ips", (PublicIpStringList.to_json v.public_ips));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        public_ips =
          (PublicIpStringList.of_json
             (Util.of_option_exn (Json.lookup j "public_ips")));
        allocation_ids =
          (AllocationIdList.of_json
             (Util.of_option_exn (Json.lookup j "allocation_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteTransitGatewayRouteTableResult =
  struct
    type t =
      {
      transit_gateway_route_table: TransitGatewayRouteTable.t option }
    let make ?transit_gateway_route_table  () =
      { transit_gateway_route_table }
    let parse xml =
      Some
        {
          transit_gateway_route_table =
            (Util.option_bind (Xml.member "transitGatewayRouteTable" xml)
               TransitGatewayRouteTable.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_route_table
              (fun f ->
                 Query.Pair
                   ("TransitGatewayRouteTable",
                     (TransitGatewayRouteTable.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_route_table
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayRouteTable"
                   ([], (TransitGatewayRouteTable.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_route_table
              (fun f ->
                 ("transit_gateway_route_table",
                   (TransitGatewayRouteTable.to_json f)))])
    let of_json j =
      {
        transit_gateway_route_table =
          (Util.option_map (Json.lookup j "transit_gateway_route_table")
             TransitGatewayRouteTable.of_json)
      }
  end
module AssociateVpcCidrBlockResult =
  struct
    type t =
      {
      ipv6_cidr_block_association: VpcIpv6CidrBlockAssociation.t option ;
      cidr_block_association: VpcCidrBlockAssociation.t option ;
      vpc_id: String.t option }
    let make ?ipv6_cidr_block_association  ?cidr_block_association  ?vpc_id 
      () = { ipv6_cidr_block_association; cidr_block_association; vpc_id }
    let parse xml =
      Some
        {
          ipv6_cidr_block_association =
            (Util.option_bind (Xml.member "ipv6CidrBlockAssociation" xml)
               VpcIpv6CidrBlockAssociation.parse);
          cidr_block_association =
            (Util.option_bind (Xml.member "cidrBlockAssociation" xml)
               VpcCidrBlockAssociation.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.cidr_block_association
             (fun f ->
                Query.Pair
                  ("CidrBlockAssociation",
                    (VpcCidrBlockAssociation.to_query f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockAssociation",
                    (VpcIpv6CidrBlockAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.ipv6_cidr_block_association
                (fun f ->
                   Ezxmlm.make_tag "ipv6CidrBlockAssociation"
                     ([], (VpcIpv6CidrBlockAssociation.to_xml f)))])
            @
            [Util.option_map v.cidr_block_association
               (fun f ->
                  Ezxmlm.make_tag "cidrBlockAssociation"
                    ([], (VpcCidrBlockAssociation.to_xml f)))])
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.cidr_block_association
             (fun f ->
                ("cidr_block_association",
                  (VpcCidrBlockAssociation.to_json f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                ("ipv6_cidr_block_association",
                  (VpcIpv6CidrBlockAssociation.to_json f)))])
    let of_json j =
      {
        ipv6_cidr_block_association =
          (Util.option_map (Json.lookup j "ipv6_cidr_block_association")
             VpcIpv6CidrBlockAssociation.of_json);
        cidr_block_association =
          (Util.option_map (Json.lookup j "cidr_block_association")
             VpcCidrBlockAssociation.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module ModifyVpcPeeringConnectionOptionsRequest =
  struct
    type t =
      {
      accepter_peering_connection_options:
        PeeringConnectionOptionsRequest.t option ;
      dry_run: Boolean.t option ;
      requester_peering_connection_options:
        PeeringConnectionOptionsRequest.t option ;
      vpc_peering_connection_id: String.t }
    let make ?accepter_peering_connection_options  ?dry_run 
      ?requester_peering_connection_options  ~vpc_peering_connection_id  () =
      {
        accepter_peering_connection_options;
        dry_run;
        requester_peering_connection_options;
        vpc_peering_connection_id
      }
    let parse xml =
      Some
        {
          accepter_peering_connection_options =
            (Util.option_bind
               (Xml.member "AccepterPeeringConnectionOptions" xml)
               PeeringConnectionOptionsRequest.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          requester_peering_connection_options =
            (Util.option_bind
               (Xml.member "RequesterPeeringConnectionOptions" xml)
               PeeringConnectionOptionsRequest.parse);
          vpc_peering_connection_id =
            (Xml.required "VpcPeeringConnectionId"
               (Util.option_bind (Xml.member "VpcPeeringConnectionId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcPeeringConnectionId",
                   (String.to_query v.vpc_peering_connection_id)));
           Util.option_map v.requester_peering_connection_options
             (fun f ->
                Query.Pair
                  ("RequesterPeeringConnectionOptions",
                    (PeeringConnectionOptionsRequest.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.accepter_peering_connection_options
             (fun f ->
                Query.Pair
                  ("AccepterPeeringConnectionOptions",
                    (PeeringConnectionOptionsRequest.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.accepter_peering_connection_options
                 (fun f ->
                    Ezxmlm.make_tag "AccepterPeeringConnectionOptions"
                      ([], (PeeringConnectionOptionsRequest.to_xml f)))])
             @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.requester_peering_connection_options
               (fun f ->
                  Ezxmlm.make_tag "RequesterPeeringConnectionOptions"
                    ([], (PeeringConnectionOptionsRequest.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "VpcPeeringConnectionId"
                 ([], (String.to_xml v.vpc_peering_connection_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpc_peering_connection_id",
                (String.to_json v.vpc_peering_connection_id));
           Util.option_map v.requester_peering_connection_options
             (fun f ->
                ("requester_peering_connection_options",
                  (PeeringConnectionOptionsRequest.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.accepter_peering_connection_options
             (fun f ->
                ("accepter_peering_connection_options",
                  (PeeringConnectionOptionsRequest.to_json f)))])
    let of_json j =
      {
        accepter_peering_connection_options =
          (Util.option_map
             (Json.lookup j "accepter_peering_connection_options")
             PeeringConnectionOptionsRequest.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        requester_peering_connection_options =
          (Util.option_map
             (Json.lookup j "requester_peering_connection_options")
             PeeringConnectionOptionsRequest.of_json);
        vpc_peering_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpc_peering_connection_id")))
      }
  end
module DeregisterTransitGatewayMulticastGroupMembersRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      group_ip_address: String.t option ;
      network_interface_ids: ValueStringList.t ;
      dry_run: Boolean.t option }
    let make ?transit_gateway_multicast_domain_id  ?group_ip_address 
      ?(network_interface_ids= [])  ?dry_run  () =
      {
        transit_gateway_multicast_domain_id;
        group_ip_address;
        network_interface_ids;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse);
          group_ip_address =
            (Util.option_bind (Xml.member "GroupIpAddress" xml) String.parse);
          network_interface_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterfaceIds" xml)
                  ValueStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceIds",
                  (ValueStringList.to_query v.network_interface_ids)));
           Util.option_map v.group_ip_address
             (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.transit_gateway_multicast_domain_id
                 (fun f ->
                    Ezxmlm.make_tag "TransitGatewayMulticastDomainId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.group_ip_address
                (fun f ->
                   Ezxmlm.make_tag "GroupIpAddress" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "NetworkInterfaceIds"
                       ([], (ValueStringList.to_xml [x]))))
               v.network_interface_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("network_interface_ids",
               (ValueStringList.to_json v.network_interface_ids));
           Util.option_map v.group_ip_address
             (fun f -> ("group_ip_address", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json);
        network_interface_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DetachVolumeRequest =
  struct
    type t =
      {
      device: String.t option ;
      force: Boolean.t option ;
      instance_id: String.t option ;
      volume_id: String.t ;
      dry_run: Boolean.t option }
    let make ?device  ?force  ?instance_id  ~volume_id  ?dry_run  () =
      { device; force; instance_id; volume_id; dry_run }
    let parse xml =
      Some
        {
          device = (Util.option_bind (Xml.member "Device" xml) String.parse);
          force = (Util.option_bind (Xml.member "Force" xml) Boolean.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.force
             (fun f -> Query.Pair ("Force", (Boolean.to_query f)));
           Util.option_map v.device
             (fun f -> Query.Pair ("Device", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.device
                  (fun f -> Ezxmlm.make_tag "Device" ([], (String.to_xml f)))])
              @
              [Util.option_map v.force
                 (fun f -> Ezxmlm.make_tag "Force" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.instance_id
                (fun f ->
                   Ezxmlm.make_tag "InstanceId" ([], (String.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "VolumeId" ([], (String.to_xml v.volume_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.force (fun f -> ("force", (Boolean.to_json f)));
           Util.option_map v.device (fun f -> ("device", (String.to_json f)))])
    let of_json j =
      {
        device = (Util.option_map (Json.lookup j "device") String.of_json);
        force = (Util.option_map (Json.lookup j "force") Boolean.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeAddressesResult =
  struct
    type t = {
      addresses: AddressList.t }
    let make ?(addresses= [])  () = { addresses }
    let parse xml =
      Some
        {
          addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "addressesSet" xml)
                  AddressList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AddressesSet", (AddressList.to_query v.addresses)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "addressesSet"
                      ([], (AddressList.to_xml [x])))) v.addresses))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("addresses", (AddressList.to_json v.addresses))])
    let of_json j =
      {
        addresses =
          (AddressList.of_json
             (Util.of_option_exn (Json.lookup j "addresses")))
      }
  end
module DescribeInstanceTypesResult =
  struct
    type t =
      {
      instance_types: InstanceTypeInfoList.t ;
      next_token: String.t option }
    let make ?(instance_types= [])  ?next_token  () =
      { instance_types; next_token }
    let parse xml =
      Some
        {
          instance_types =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceTypeSet" xml)
                  InstanceTypeInfoList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceTypeSet",
                  (InstanceTypeInfoList.to_query v.instance_types)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "instanceTypeSet"
                       ([], (InstanceTypeInfoList.to_xml [x]))))
               v.instance_types))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_types",
               (InstanceTypeInfoList.to_json v.instance_types))])
    let of_json j =
      {
        instance_types =
          (InstanceTypeInfoList.of_json
             (Util.of_option_exn (Json.lookup j "instance_types")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateNatGatewayRequest =
  struct
    type t =
      {
      allocation_id: String.t ;
      client_token: String.t option ;
      subnet_id: String.t }
    let make ~allocation_id  ?client_token  ~subnet_id  () =
      { allocation_id; client_token; subnet_id }
    let parse xml =
      Some
        {
          allocation_id =
            (Xml.required "AllocationId"
               (Util.option_bind (Xml.member "AllocationId" xml) String.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          subnet_id =
            (Xml.required "SubnetId"
               (Util.option_bind (Xml.member "SubnetId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair ("AllocationId", (String.to_query v.allocation_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "AllocationId"
                   ([], (String.to_xml v.allocation_id)))])
            @
            [Util.option_map v.client_token
               (fun f ->
                  Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "SubnetId" ([], (String.to_xml v.subnet_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("subnet_id", (String.to_json v.subnet_id));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some ("allocation_id", (String.to_json v.allocation_id))])
    let of_json j =
      {
        allocation_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "allocation_id")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")))
      }
  end
module CreateSubnetResult =
  struct
    type t = {
      subnet: Subnet.t option }
    let make ?subnet  () = { subnet }
    let parse xml =
      Some
        { subnet = (Util.option_bind (Xml.member "subnet" xml) Subnet.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> Query.Pair ("Subnet", (Subnet.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.subnet
              (fun f -> Ezxmlm.make_tag "subnet" ([], (Subnet.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> ("subnet", (Subnet.to_json f)))])
    let of_json j =
      { subnet = (Util.option_map (Json.lookup j "subnet") Subnet.of_json) }
  end
module DescribeClientVpnRoutesResult =
  struct
    type t = {
      routes: ClientVpnRouteSet.t ;
      next_token: String.t option }
    let make ?(routes= [])  ?next_token  () = { routes; next_token }
    let parse xml =
      Some
        {
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routes" xml)
                  ClientVpnRouteSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair ("Routes", (ClientVpnRouteSet.to_query v.routes)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "routes"
                       ([], (ClientVpnRouteSet.to_xml [x])))) v.routes))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("routes", (ClientVpnRouteSet.to_json v.routes))])
    let of_json j =
      {
        routes =
          (ClientVpnRouteSet.of_json
             (Util.of_option_exn (Json.lookup j "routes")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyInstanceCapacityReservationAttributesRequest =
  struct
    type t =
      {
      instance_id: String.t ;
      capacity_reservation_specification: CapacityReservationSpecification.t ;
      dry_run: Boolean.t option }
    let make ~instance_id  ~capacity_reservation_specification  ?dry_run  ()
      = { instance_id; capacity_reservation_specification; dry_run }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          capacity_reservation_specification =
            (Xml.required "CapacityReservationSpecification"
               (Util.option_bind
                  (Xml.member "CapacityReservationSpecification" xml)
                  CapacityReservationSpecification.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("CapacityReservationSpecification",
                  (CapacityReservationSpecification.to_query
                     v.capacity_reservation_specification)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "InstanceId"
                   ([], (String.to_xml v.instance_id)))])
            @
            [Some
               (Ezxmlm.make_tag "CapacityReservationSpecification"
                  ([],
                    (CapacityReservationSpecification.to_xml
                       v.capacity_reservation_specification)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("capacity_reservation_specification",
               (CapacityReservationSpecification.to_json
                  v.capacity_reservation_specification));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        capacity_reservation_specification =
          (CapacityReservationSpecification.of_json
             (Util.of_option_exn
                (Json.lookup j "capacity_reservation_specification")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ApplySecurityGroupsToClientVpnTargetNetworkResult =
  struct
    type t = {
      security_group_ids: ClientVpnSecurityGroupIdSet.t }
    let make ?(security_group_ids= [])  () = { security_group_ids }
    let parse xml =
      Some
        {
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupIds" xml)
                  ClientVpnSecurityGroupIdSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SecurityGroupIds",
                   (ClientVpnSecurityGroupIdSet.to_query v.security_group_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "securityGroupIds"
                      ([], (ClientVpnSecurityGroupIdSet.to_xml [x]))))
              v.security_group_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("security_group_ids",
                (ClientVpnSecurityGroupIdSet.to_json v.security_group_ids))])
    let of_json j =
      {
        security_group_ids =
          (ClientVpnSecurityGroupIdSet.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")))
      }
  end
module DescribeVpnConnectionsResult =
  struct
    type t = {
      vpn_connections: VpnConnectionList.t }
    let make ?(vpn_connections= [])  () = { vpn_connections }
    let parse xml =
      Some
        {
          vpn_connections =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpnConnectionSet" xml)
                  VpnConnectionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpnConnectionSet",
                   (VpnConnectionList.to_query v.vpn_connections)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "vpnConnectionSet"
                      ([], (VpnConnectionList.to_xml [x]))))
              v.vpn_connections))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpn_connections",
                (VpnConnectionList.to_json v.vpn_connections))])
    let of_json j =
      {
        vpn_connections =
          (VpnConnectionList.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connections")))
      }
  end
module AssociateSubnetCidrBlockRequest =
  struct
    type t = {
      ipv6_cidr_block: String.t ;
      subnet_id: String.t }
    let make ~ipv6_cidr_block  ~subnet_id  () =
      { ipv6_cidr_block; subnet_id }
    let parse xml =
      Some
        {
          ipv6_cidr_block =
            (Xml.required "ipv6CidrBlock"
               (Util.option_bind (Xml.member "ipv6CidrBlock" xml)
                  String.parse));
          subnet_id =
            (Xml.required "subnetId"
               (Util.option_bind (Xml.member "subnetId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)));
           Some
             (Query.Pair
                ("Ipv6CidrBlock", (String.to_query v.ipv6_cidr_block)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "ipv6CidrBlock"
                  ([], (String.to_xml v.ipv6_cidr_block)))])
           @
           [Some
              (Ezxmlm.make_tag "subnetId" ([], (String.to_xml v.subnet_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("subnet_id", (String.to_json v.subnet_id));
           Some ("ipv6_cidr_block", (String.to_json v.ipv6_cidr_block))])
    let of_json j =
      {
        ipv6_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_cidr_block")));
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")))
      }
  end
module GetHostReservationPurchasePreviewRequest =
  struct
    type t = {
      host_id_set: RequestHostIdSet.t ;
      offering_id: String.t }
    let make ~host_id_set  ~offering_id  () = { host_id_set; offering_id }
    let parse xml =
      Some
        {
          host_id_set =
            (Xml.required "HostIdSet"
               (Util.option_bind (Xml.member "HostIdSet" xml)
                  RequestHostIdSet.parse));
          offering_id =
            (Xml.required "OfferingId"
               (Util.option_bind (Xml.member "OfferingId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("OfferingId", (String.to_query v.offering_id)));
           Some
             (Query.Pair
                ("HostIdSet", (RequestHostIdSet.to_query v.host_id_set)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "HostIdSet"
                       ([], (RequestHostIdSet.to_xml [x])))) v.host_id_set))
           @
           [Some
              (Ezxmlm.make_tag "OfferingId"
                 ([], (String.to_xml v.offering_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("offering_id", (String.to_json v.offering_id));
           Some ("host_id_set", (RequestHostIdSet.to_json v.host_id_set))])
    let of_json j =
      {
        host_id_set =
          (RequestHostIdSet.of_json
             (Util.of_option_exn (Json.lookup j "host_id_set")));
        offering_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "offering_id")))
      }
  end
module DeleteVpcEndpointConnectionNotificationsResult =
  struct
    type t = {
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemSet.to_xml [x])))) v.unsuccessful))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let of_json j =
      {
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module AcceptTransitGatewayVpcAttachmentResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.t option }
    let make ?transit_gateway_vpc_attachment  () =
      { transit_gateway_vpc_attachment }
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachment =
            (Util.option_bind (Xml.member "transitGatewayVpcAttachment" xml)
               TransitGatewayVpcAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayVpcAttachment",
                     (TransitGatewayVpcAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayVpcAttachment"
                   ([], (TransitGatewayVpcAttachment.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 ("transit_gateway_vpc_attachment",
                   (TransitGatewayVpcAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_vpc_attachment =
          (Util.option_map (Json.lookup j "transit_gateway_vpc_attachment")
             TransitGatewayVpcAttachment.of_json)
      }
  end
module ModifyIdentityIdFormatRequest =
  struct
    type t =
      {
      principal_arn: String.t ;
      resource: String.t ;
      use_long_ids: Boolean.t }
    let make ~principal_arn  ~resource  ~use_long_ids  () =
      { principal_arn; resource; use_long_ids }
    let parse xml =
      Some
        {
          principal_arn =
            (Xml.required "principalArn"
               (Util.option_bind (Xml.member "principalArn" xml) String.parse));
          resource =
            (Xml.required "resource"
               (Util.option_bind (Xml.member "resource" xml) String.parse));
          use_long_ids =
            (Xml.required "useLongIds"
               (Util.option_bind (Xml.member "useLongIds" xml) Boolean.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("UseLongIds", (Boolean.to_query v.use_long_ids)));
           Some (Query.Pair ("Resource", (String.to_query v.resource)));
           Some
             (Query.Pair ("PrincipalArn", (String.to_query v.principal_arn)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "principalArn"
                   ([], (String.to_xml v.principal_arn)))])
            @
            [Some
               (Ezxmlm.make_tag "resource" ([], (String.to_xml v.resource)))])
           @
           [Some
              (Ezxmlm.make_tag "useLongIds"
                 ([], (Boolean.to_xml v.use_long_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("use_long_ids", (Boolean.to_json v.use_long_ids));
           Some ("resource", (String.to_json v.resource));
           Some ("principal_arn", (String.to_json v.principal_arn))])
    let of_json j =
      {
        principal_arn =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "principal_arn")));
        resource =
          (String.of_json (Util.of_option_exn (Json.lookup j "resource")));
        use_long_ids =
          (Boolean.of_json
             (Util.of_option_exn (Json.lookup j "use_long_ids")))
      }
  end
module CreateLocalGatewayRouteTableVpcAssociationResult =
  struct
    type t =
      {
      local_gateway_route_table_vpc_association:
        LocalGatewayRouteTableVpcAssociation.t option }
    let make ?local_gateway_route_table_vpc_association  () =
      { local_gateway_route_table_vpc_association }
    let parse xml =
      Some
        {
          local_gateway_route_table_vpc_association =
            (Util.option_bind
               (Xml.member "localGatewayRouteTableVpcAssociation" xml)
               LocalGatewayRouteTableVpcAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_vpc_association
              (fun f ->
                 Query.Pair
                   ("LocalGatewayRouteTableVpcAssociation",
                     (LocalGatewayRouteTableVpcAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.local_gateway_route_table_vpc_association
              (fun f ->
                 Ezxmlm.make_tag "localGatewayRouteTableVpcAssociation"
                   ([], (LocalGatewayRouteTableVpcAssociation.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_vpc_association
              (fun f ->
                 ("local_gateway_route_table_vpc_association",
                   (LocalGatewayRouteTableVpcAssociation.to_json f)))])
    let of_json j =
      {
        local_gateway_route_table_vpc_association =
          (Util.option_map
             (Json.lookup j "local_gateway_route_table_vpc_association")
             LocalGatewayRouteTableVpcAssociation.of_json)
      }
  end
module ModifyClientVpnEndpointRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      server_certificate_arn: String.t option ;
      connection_log_options: ConnectionLogOptions.t option ;
      dns_servers: DnsServersOptionsModifyStructure.t option ;
      description: String.t option ;
      split_tunnel: Boolean.t option ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?server_certificate_arn 
      ?connection_log_options  ?dns_servers  ?description  ?split_tunnel 
      ?dry_run  () =
      {
        client_vpn_endpoint_id;
        server_certificate_arn;
        connection_log_options;
        dns_servers;
        description;
        split_tunnel;
        dry_run
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          server_certificate_arn =
            (Util.option_bind (Xml.member "ServerCertificateArn" xml)
               String.parse);
          connection_log_options =
            (Util.option_bind (Xml.member "ConnectionLogOptions" xml)
               ConnectionLogOptions.parse);
          dns_servers =
            (Util.option_bind (Xml.member "DnsServers" xml)
               DnsServersOptionsModifyStructure.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          split_tunnel =
            (Util.option_bind (Xml.member "SplitTunnel" xml) Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.split_tunnel
             (fun f -> Query.Pair ("SplitTunnel", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.dns_servers
             (fun f ->
                Query.Pair
                  ("DnsServers",
                    (DnsServersOptionsModifyStructure.to_query f)));
           Util.option_map v.connection_log_options
             (fun f ->
                Query.Pair
                  ("ConnectionLogOptions", (ConnectionLogOptions.to_query f)));
           Util.option_map v.server_certificate_arn
             (fun f ->
                Query.Pair ("ServerCertificateArn", (String.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Some
                    (Ezxmlm.make_tag "ClientVpnEndpointId"
                       ([], (String.to_xml v.client_vpn_endpoint_id)))])
                @
                [Util.option_map v.server_certificate_arn
                   (fun f ->
                      Ezxmlm.make_tag "ServerCertificateArn"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.connection_log_options
                  (fun f ->
                     Ezxmlm.make_tag "ConnectionLogOptions"
                       ([], (ConnectionLogOptions.to_xml f)))])
              @
              [Util.option_map v.dns_servers
                 (fun f ->
                    Ezxmlm.make_tag "DnsServers"
                      ([], (DnsServersOptionsModifyStructure.to_xml f)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
            @
            [Util.option_map v.split_tunnel
               (fun f ->
                  Ezxmlm.make_tag "SplitTunnel" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.split_tunnel
             (fun f -> ("split_tunnel", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.dns_servers
             (fun f ->
                ("dns_servers", (DnsServersOptionsModifyStructure.to_json f)));
           Util.option_map v.connection_log_options
             (fun f ->
                ("connection_log_options", (ConnectionLogOptions.to_json f)));
           Util.option_map v.server_certificate_arn
             (fun f -> ("server_certificate_arn", (String.to_json f)));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        server_certificate_arn =
          (Util.option_map (Json.lookup j "server_certificate_arn")
             String.of_json);
        connection_log_options =
          (Util.option_map (Json.lookup j "connection_log_options")
             ConnectionLogOptions.of_json);
        dns_servers =
          (Util.option_map (Json.lookup j "dns_servers")
             DnsServersOptionsModifyStructure.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        split_tunnel =
          (Util.option_map (Json.lookup j "split_tunnel") Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module GetPasswordDataResult =
  struct
    type t =
      {
      instance_id: String.t ;
      password_data: String.t ;
      timestamp: DateTime.t }
    let make ~instance_id  ~password_data  ~timestamp  () =
      { instance_id; password_data; timestamp }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          password_data =
            (Xml.required "passwordData"
               (Util.option_bind (Xml.member "passwordData" xml) String.parse));
          timestamp =
            (Xml.required "timestamp"
               (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Timestamp", (DateTime.to_query v.timestamp)));
           Some
             (Query.Pair ("PasswordData", (String.to_query v.password_data)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "instanceId"
                   ([], (String.to_xml v.instance_id)))])
            @
            [Some
               (Ezxmlm.make_tag "passwordData"
                  ([], (String.to_xml v.password_data)))])
           @
           [Some
              (Ezxmlm.make_tag "timestamp"
                 ([], (DateTime.to_xml v.timestamp)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("timestamp", (DateTime.to_json v.timestamp));
           Some ("password_data", (String.to_json v.password_data));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        password_data =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "password_data")));
        timestamp =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "timestamp")))
      }
  end
module DescribeClientVpnTargetNetworksResult =
  struct
    type t =
      {
      client_vpn_target_networks: TargetNetworkSet.t ;
      next_token: String.t option }
    let make ?(client_vpn_target_networks= [])  ?next_token  () =
      { client_vpn_target_networks; next_token }
    let parse xml =
      Some
        {
          client_vpn_target_networks =
            (Util.of_option []
               (Util.option_bind (Xml.member "clientVpnTargetNetworks" xml)
                  TargetNetworkSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnTargetNetworks",
                  (TargetNetworkSet.to_query v.client_vpn_target_networks)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "clientVpnTargetNetworks"
                       ([], (TargetNetworkSet.to_xml [x]))))
               v.client_vpn_target_networks))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("client_vpn_target_networks",
               (TargetNetworkSet.to_json v.client_vpn_target_networks))])
    let of_json j =
      {
        client_vpn_target_networks =
          (TargetNetworkSet.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_target_networks")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeRegionsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      region_names: RegionNameStringList.t ;
      dry_run: Boolean.t option ;
      all_regions: Boolean.t option }
    let make ?(filters= [])  ?(region_names= [])  ?dry_run  ?all_regions  ()
      = { filters; region_names; dry_run; all_regions }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          region_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "RegionName" xml)
                  RegionNameStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          all_regions =
            (Util.option_bind (Xml.member "AllRegions" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.all_regions
              (fun f -> Query.Pair ("AllRegions", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("RegionName",
                  (RegionNameStringList.to_query v.region_names)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "RegionName"
                        ([], (RegionNameStringList.to_xml [x]))))
                v.region_names))
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.all_regions
              (fun f -> Ezxmlm.make_tag "AllRegions" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.all_regions
              (fun f -> ("all_regions", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("region_names", (RegionNameStringList.to_json v.region_names));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        region_names =
          (RegionNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "region_names")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        all_regions =
          (Util.option_map (Json.lookup j "all_regions") Boolean.of_json)
      }
  end
module DescribeVpcEndpointServicePermissionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ~service_id  ?(filters= [])  ?max_results  ?next_token
       () = { dry_run; service_id; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_id =
            (Xml.required "ServiceId"
               (Util.option_bind (Xml.member "ServiceId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some (Query.Pair ("ServiceId", (String.to_query v.service_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              [Some
                 (Ezxmlm.make_tag "ServiceId"
                    ([], (String.to_xml v.service_id)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("service_id", (String.to_json v.service_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "service_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyVpcEndpointServicePermissionsResult =
  struct
    type t = {
      return_value: Boolean.t option }
    let make ?return_value  () = { return_value }
    let parse xml =
      Some
        {
          return_value =
            (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return_value
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> ("return_value", (Boolean.to_json f)))])
    let of_json j =
      {
        return_value =
          (Util.option_map (Json.lookup j "return_value") Boolean.of_json)
      }
  end
module ModifySubnetAttributeRequest =
  struct
    type t =
      {
      assign_ipv6_address_on_creation: AttributeBooleanValue.t option ;
      map_public_ip_on_launch: AttributeBooleanValue.t option ;
      subnet_id: String.t }
    let make ?assign_ipv6_address_on_creation  ?map_public_ip_on_launch 
      ~subnet_id  () =
      { assign_ipv6_address_on_creation; map_public_ip_on_launch; subnet_id }
    let parse xml =
      Some
        {
          assign_ipv6_address_on_creation =
            (Util.option_bind (Xml.member "AssignIpv6AddressOnCreation" xml)
               AttributeBooleanValue.parse);
          map_public_ip_on_launch =
            (Util.option_bind (Xml.member "MapPublicIpOnLaunch" xml)
               AttributeBooleanValue.parse);
          subnet_id =
            (Xml.required "subnetId"
               (Util.option_bind (Xml.member "subnetId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)));
           Util.option_map v.map_public_ip_on_launch
             (fun f ->
                Query.Pair
                  ("MapPublicIpOnLaunch", (AttributeBooleanValue.to_query f)));
           Util.option_map v.assign_ipv6_address_on_creation
             (fun f ->
                Query.Pair
                  ("AssignIpv6AddressOnCreation",
                    (AttributeBooleanValue.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.assign_ipv6_address_on_creation
                (fun f ->
                   Ezxmlm.make_tag "AssignIpv6AddressOnCreation"
                     ([], (AttributeBooleanValue.to_xml f)))])
            @
            [Util.option_map v.map_public_ip_on_launch
               (fun f ->
                  Ezxmlm.make_tag "MapPublicIpOnLaunch"
                    ([], (AttributeBooleanValue.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "subnetId" ([], (String.to_xml v.subnet_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("subnet_id", (String.to_json v.subnet_id));
           Util.option_map v.map_public_ip_on_launch
             (fun f ->
                ("map_public_ip_on_launch",
                  (AttributeBooleanValue.to_json f)));
           Util.option_map v.assign_ipv6_address_on_creation
             (fun f ->
                ("assign_ipv6_address_on_creation",
                  (AttributeBooleanValue.to_json f)))])
    let of_json j =
      {
        assign_ipv6_address_on_creation =
          (Util.option_map (Json.lookup j "assign_ipv6_address_on_creation")
             AttributeBooleanValue.of_json);
        map_public_ip_on_launch =
          (Util.option_map (Json.lookup j "map_public_ip_on_launch")
             AttributeBooleanValue.of_json);
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")))
      }
  end
module DisableFastSnapshotRestoresRequest =
  struct
    type t =
      {
      availability_zones: AvailabilityZoneStringList.t ;
      source_snapshot_ids: SnapshotIdStringList.t ;
      dry_run: Boolean.t option }
    let make ~availability_zones  ~source_snapshot_ids  ?dry_run  () =
      { availability_zones; source_snapshot_ids; dry_run }
    let parse xml =
      Some
        {
          availability_zones =
            (Xml.required "AvailabilityZone"
               (Util.option_bind (Xml.member "AvailabilityZone" xml)
                  AvailabilityZoneStringList.parse));
          source_snapshot_ids =
            (Xml.required "SourceSnapshotId"
               (Util.option_bind (Xml.member "SourceSnapshotId" xml)
                  SnapshotIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SourceSnapshotId",
                  (SnapshotIdStringList.to_query v.source_snapshot_ids)));
           Some
             (Query.Pair
                ("AvailabilityZone",
                  (AvailabilityZoneStringList.to_query v.availability_zones)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "AvailabilityZone"
                        ([], (AvailabilityZoneStringList.to_xml [x]))))
                v.availability_zones))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "SourceSnapshotId"
                       ([], (SnapshotIdStringList.to_xml [x]))))
               v.source_snapshot_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("source_snapshot_ids",
               (SnapshotIdStringList.to_json v.source_snapshot_ids));
           Some
             ("availability_zones",
               (AvailabilityZoneStringList.to_json v.availability_zones))])
    let of_json j =
      {
        availability_zones =
          (AvailabilityZoneStringList.of_json
             (Util.of_option_exn (Json.lookup j "availability_zones")));
        source_snapshot_ids =
          (SnapshotIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "source_snapshot_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ImportInstanceResult =
  struct
    type t = {
      conversion_task: ConversionTask.t option }
    let make ?conversion_task  () = { conversion_task }
    let parse xml =
      Some
        {
          conversion_task =
            (Util.option_bind (Xml.member "conversionTask" xml)
               ConversionTask.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.conversion_task
              (fun f ->
                 Query.Pair ("ConversionTask", (ConversionTask.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.conversion_task
              (fun f ->
                 Ezxmlm.make_tag "conversionTask"
                   ([], (ConversionTask.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.conversion_task
              (fun f -> ("conversion_task", (ConversionTask.to_json f)))])
    let of_json j =
      {
        conversion_task =
          (Util.option_map (Json.lookup j "conversion_task")
             ConversionTask.of_json)
      }
  end
module RegisterImageRequest =
  struct
    type t =
      {
      image_location: String.t option ;
      architecture: ArchitectureValues.t option ;
      block_device_mappings: BlockDeviceMappingRequestList.t ;
      description: String.t option ;
      dry_run: Boolean.t option ;
      ena_support: Boolean.t option ;
      kernel_id: String.t option ;
      name: String.t ;
      billing_products: BillingProductList.t ;
      ramdisk_id: String.t option ;
      root_device_name: String.t option ;
      sriov_net_support: String.t option ;
      virtualization_type: String.t option }
    let make ?image_location  ?architecture  ?(block_device_mappings= []) 
      ?description  ?dry_run  ?ena_support  ?kernel_id  ~name 
      ?(billing_products= [])  ?ramdisk_id  ?root_device_name 
      ?sriov_net_support  ?virtualization_type  () =
      {
        image_location;
        architecture;
        block_device_mappings;
        description;
        dry_run;
        ena_support;
        kernel_id;
        name;
        billing_products;
        ramdisk_id;
        root_device_name;
        sriov_net_support;
        virtualization_type
      }
    let parse xml =
      Some
        {
          image_location =
            (Util.option_bind (Xml.member "ImageLocation" xml) String.parse);
          architecture =
            (Util.option_bind (Xml.member "architecture" xml)
               ArchitectureValues.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "BlockDeviceMapping" xml)
                  BlockDeviceMappingRequestList.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          ena_support =
            (Util.option_bind (Xml.member "enaSupport" xml) Boolean.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          name =
            (Xml.required "name"
               (Util.option_bind (Xml.member "name" xml) String.parse));
          billing_products =
            (Util.of_option []
               (Util.option_bind (Xml.member "BillingProduct" xml)
                  BillingProductList.parse));
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          root_device_name =
            (Util.option_bind (Xml.member "rootDeviceName" xml) String.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml) String.parse);
          virtualization_type =
            (Util.option_bind (Xml.member "virtualizationType" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.virtualization_type
              (fun f ->
                 Query.Pair ("VirtualizationType", (String.to_query f)));
           Util.option_map v.sriov_net_support
             (fun f -> Query.Pair ("SriovNetSupport", (String.to_query f)));
           Util.option_map v.root_device_name
             (fun f -> Query.Pair ("RootDeviceName", (String.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Some
             (Query.Pair
                ("BillingProduct",
                  (BillingProductList.to_query v.billing_products)));
           Some (Query.Pair ("Name", (String.to_query v.name)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.ena_support
             (fun f -> Query.Pair ("EnaSupport", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingRequestList.to_query
                     v.block_device_mappings)));
           Util.option_map v.architecture
             (fun f ->
                Query.Pair ("Architecture", (ArchitectureValues.to_query f)));
           Util.option_map v.image_location
             (fun f -> Query.Pair ("ImageLocation", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.image_location
                          (fun f ->
                             Ezxmlm.make_tag "ImageLocation"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.architecture
                         (fun f ->
                            Ezxmlm.make_tag "architecture"
                              ([], (ArchitectureValues.to_xml f)))])
                     @
                     (List.map
                        (fun x ->
                           Some
                             (Ezxmlm.make_tag "BlockDeviceMapping"
                                ([],
                                  (BlockDeviceMappingRequestList.to_xml [x]))))
                        v.block_device_mappings))
                    @
                    [Util.option_map v.description
                       (fun f ->
                          Ezxmlm.make_tag "description"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.dry_run
                      (fun f ->
                         Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
                  @
                  [Util.option_map v.ena_support
                     (fun f ->
                        Ezxmlm.make_tag "enaSupport" ([], (Boolean.to_xml f)))])
                 @
                 [Util.option_map v.kernel_id
                    (fun f ->
                       Ezxmlm.make_tag "kernelId" ([], (String.to_xml f)))])
                @
                [Some (Ezxmlm.make_tag "name" ([], (String.to_xml v.name)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "BillingProduct"
                          ([], (BillingProductList.to_xml [x]))))
                  v.billing_products))
              @
              [Util.option_map v.ramdisk_id
                 (fun f ->
                    Ezxmlm.make_tag "ramdiskId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.root_device_name
                (fun f ->
                   Ezxmlm.make_tag "rootDeviceName" ([], (String.to_xml f)))])
            @
            [Util.option_map v.sriov_net_support
               (fun f ->
                  Ezxmlm.make_tag "sriovNetSupport" ([], (String.to_xml f)))])
           @
           [Util.option_map v.virtualization_type
              (fun f ->
                 Ezxmlm.make_tag "virtualizationType" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.virtualization_type
              (fun f -> ("virtualization_type", (String.to_json f)));
           Util.option_map v.sriov_net_support
             (fun f -> ("sriov_net_support", (String.to_json f)));
           Util.option_map v.root_device_name
             (fun f -> ("root_device_name", (String.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Some
             ("billing_products",
               (BillingProductList.to_json v.billing_products));
           Some ("name", (String.to_json v.name));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.ena_support
             (fun f -> ("ena_support", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingRequestList.to_json v.block_device_mappings));
           Util.option_map v.architecture
             (fun f -> ("architecture", (ArchitectureValues.to_json f)));
           Util.option_map v.image_location
             (fun f -> ("image_location", (String.to_json f)))])
    let of_json j =
      {
        image_location =
          (Util.option_map (Json.lookup j "image_location") String.of_json);
        architecture =
          (Util.option_map (Json.lookup j "architecture")
             ArchitectureValues.of_json);
        block_device_mappings =
          (BlockDeviceMappingRequestList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        ena_support =
          (Util.option_map (Json.lookup j "ena_support") Boolean.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        billing_products =
          (BillingProductList.of_json
             (Util.of_option_exn (Json.lookup j "billing_products")));
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        root_device_name =
          (Util.option_map (Json.lookup j "root_device_name") String.of_json);
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support") String.of_json);
        virtualization_type =
          (Util.option_map (Json.lookup j "virtualization_type")
             String.of_json)
      }
  end
module CreateSecurityGroupRequest =
  struct
    type t =
      {
      description: String.t ;
      group_name: String.t ;
      vpc_id: String.t option ;
      dry_run: Boolean.t option }
    let make ~description  ~group_name  ?vpc_id  ?dry_run  () =
      { description; group_name; vpc_id; dry_run }
    let parse xml =
      Some
        {
          description =
            (Xml.required "GroupDescription"
               (Util.option_bind (Xml.member "GroupDescription" xml)
                  String.parse));
          group_name =
            (Xml.required "GroupName"
               (Util.option_bind (Xml.member "GroupName" xml) String.parse));
          vpc_id = (Util.option_bind (Xml.member "VpcId" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("GroupName", (String.to_query v.group_name)));
           Some
             (Query.Pair
                ("GroupDescription", (String.to_query v.description)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "GroupDescription"
                    ([], (String.to_xml v.description)))])
             @
             [Some
                (Ezxmlm.make_tag "GroupName"
                   ([], (String.to_xml v.group_name)))])
            @
            [Util.option_map v.vpc_id
               (fun f -> Ezxmlm.make_tag "VpcId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Some ("group_name", (String.to_json v.group_name));
           Some ("description", (String.to_json v.description))])
    let of_json j =
      {
        description =
          (String.of_json (Util.of_option_exn (Json.lookup j "description")));
        group_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_name")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisableVpcClassicLinkDnsSupportRequest =
  struct
    type t = {
      vpc_id: String.t option }
    let make ?vpc_id  () = { vpc_id }
    let parse xml =
      Some
        { vpc_id = (Util.option_bind (Xml.member "VpcId" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "VpcId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)))])
    let of_json j =
      { vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json) }
  end
module DescribeVpcPeeringConnectionsResult =
  struct
    type t =
      {
      vpc_peering_connections: VpcPeeringConnectionList.t ;
      next_token: String.t option }
    let make ?(vpc_peering_connections= [])  ?next_token  () =
      { vpc_peering_connections; next_token }
    let parse xml =
      Some
        {
          vpc_peering_connections =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcPeeringConnectionSet" xml)
                  VpcPeeringConnectionList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("VpcPeeringConnectionSet",
                  (VpcPeeringConnectionList.to_query
                     v.vpc_peering_connections)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "vpcPeeringConnectionSet"
                       ([], (VpcPeeringConnectionList.to_xml [x]))))
               v.vpc_peering_connections))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("vpc_peering_connections",
               (VpcPeeringConnectionList.to_json v.vpc_peering_connections))])
    let of_json j =
      {
        vpc_peering_connections =
          (VpcPeeringConnectionList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_peering_connections")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeNetworkAclsResult =
  struct
    type t = {
      network_acls: NetworkAclList.t ;
      next_token: String.t option }
    let make ?(network_acls= [])  ?next_token  () =
      { network_acls; next_token }
    let parse xml =
      Some
        {
          network_acls =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkAclSet" xml)
                  NetworkAclList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkAclSet", (NetworkAclList.to_query v.network_acls)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "networkAclSet"
                       ([], (NetworkAclList.to_xml [x])))) v.network_acls))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("network_acls", (NetworkAclList.to_json v.network_acls))])
    let of_json j =
      {
        network_acls =
          (NetworkAclList.of_json
             (Util.of_option_exn (Json.lookup j "network_acls")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteTrafficMirrorTargetResult =
  struct
    type t = {
      traffic_mirror_target_id: String.t option }
    let make ?traffic_mirror_target_id  () = { traffic_mirror_target_id }
    let parse xml =
      Some
        {
          traffic_mirror_target_id =
            (Util.option_bind (Xml.member "trafficMirrorTargetId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_target_id
              (fun f ->
                 Query.Pair ("TrafficMirrorTargetId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.traffic_mirror_target_id
              (fun f ->
                 Ezxmlm.make_tag "trafficMirrorTargetId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_target_id
              (fun f -> ("traffic_mirror_target_id", (String.to_json f)))])
    let of_json j =
      {
        traffic_mirror_target_id =
          (Util.option_map (Json.lookup j "traffic_mirror_target_id")
             String.of_json)
      }
  end
module DeleteTrafficMirrorFilterRequest =
  struct
    type t = {
      traffic_mirror_filter_id: String.t ;
      dry_run: Boolean.t option }
    let make ~traffic_mirror_filter_id  ?dry_run  () =
      { traffic_mirror_filter_id; dry_run }
    let parse xml =
      Some
        {
          traffic_mirror_filter_id =
            (Xml.required "TrafficMirrorFilterId"
               (Util.option_bind (Xml.member "TrafficMirrorFilterId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterId",
                  (String.to_query v.traffic_mirror_filter_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "TrafficMirrorFilterId"
                  ([], (String.to_xml v.traffic_mirror_filter_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("traffic_mirror_filter_id",
               (String.to_json v.traffic_mirror_filter_id))])
    let of_json j =
      {
        traffic_mirror_filter_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_filter_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult =
  struct
    type t =
      {
      local_gateway_route_table_virtual_interface_group_associations:
        LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.t ;
      next_token: String.t option }
    let make
      ?(local_gateway_route_table_virtual_interface_group_associations= []) 
      ?next_token  () =
      {
        local_gateway_route_table_virtual_interface_group_associations;
        next_token
      }
    let parse xml =
      Some
        {
          local_gateway_route_table_virtual_interface_group_associations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member
                     "localGatewayRouteTableVirtualInterfaceGroupAssociationSet"
                     xml)
                  LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet",
                  (LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.to_query
                     v.local_gateway_route_table_virtual_interface_group_associations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag
                       "localGatewayRouteTableVirtualInterfaceGroupAssociationSet"
                       ([],
                         (LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.to_xml
                            [x]))))
               v.local_gateway_route_table_virtual_interface_group_associations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateway_route_table_virtual_interface_group_associations",
               (LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.to_json
                  v.local_gateway_route_table_virtual_interface_group_associations))])
    let of_json j =
      {
        local_gateway_route_table_virtual_interface_group_associations =
          (LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.of_json
             (Util.of_option_exn
                (Json.lookup j
                   "local_gateway_route_table_virtual_interface_group_associations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module EnableEbsEncryptionByDefaultResult =
  struct
    type t = {
      ebs_encryption_by_default: Boolean.t option }
    let make ?ebs_encryption_by_default  () = { ebs_encryption_by_default }
    let parse xml =
      Some
        {
          ebs_encryption_by_default =
            (Util.option_bind (Xml.member "ebsEncryptionByDefault" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f ->
                 Query.Pair ("EbsEncryptionByDefault", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ebs_encryption_by_default
              (fun f ->
                 Ezxmlm.make_tag "ebsEncryptionByDefault"
                   ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f -> ("ebs_encryption_by_default", (Boolean.to_json f)))])
    let of_json j =
      {
        ebs_encryption_by_default =
          (Util.option_map (Json.lookup j "ebs_encryption_by_default")
             Boolean.of_json)
      }
  end
module PurchaseHostReservationRequest =
  struct
    type t =
      {
      client_token: String.t option ;
      currency_code: CurrencyCodeValues.t option ;
      host_id_set: RequestHostIdSet.t ;
      limit_price: String.t option ;
      offering_id: String.t }
    let make ?client_token  ?currency_code  ~host_id_set  ?limit_price 
      ~offering_id  () =
      { client_token; currency_code; host_id_set; limit_price; offering_id }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          currency_code =
            (Util.option_bind (Xml.member "CurrencyCode" xml)
               CurrencyCodeValues.parse);
          host_id_set =
            (Xml.required "HostIdSet"
               (Util.option_bind (Xml.member "HostIdSet" xml)
                  RequestHostIdSet.parse));
          limit_price =
            (Util.option_bind (Xml.member "LimitPrice" xml) String.parse);
          offering_id =
            (Xml.required "OfferingId"
               (Util.option_bind (Xml.member "OfferingId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("OfferingId", (String.to_query v.offering_id)));
           Util.option_map v.limit_price
             (fun f -> Query.Pair ("LimitPrice", (String.to_query f)));
           Some
             (Query.Pair
                ("HostIdSet", (RequestHostIdSet.to_query v.host_id_set)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.client_token
                  (fun f ->
                     Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
              @
              [Util.option_map v.currency_code
                 (fun f ->
                    Ezxmlm.make_tag "CurrencyCode"
                      ([], (CurrencyCodeValues.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "HostIdSet"
                        ([], (RequestHostIdSet.to_xml [x])))) v.host_id_set))
            @
            [Util.option_map v.limit_price
               (fun f -> Ezxmlm.make_tag "LimitPrice" ([], (String.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "OfferingId"
                 ([], (String.to_xml v.offering_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("offering_id", (String.to_json v.offering_id));
           Util.option_map v.limit_price
             (fun f -> ("limit_price", (String.to_json f)));
           Some ("host_id_set", (RequestHostIdSet.to_json v.host_id_set));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        host_id_set =
          (RequestHostIdSet.of_json
             (Util.of_option_exn (Json.lookup j "host_id_set")));
        limit_price =
          (Util.option_map (Json.lookup j "limit_price") String.of_json);
        offering_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "offering_id")))
      }
  end
module CancelConversionRequest =
  struct
    type t =
      {
      conversion_task_id: String.t ;
      dry_run: Boolean.t option ;
      reason_message: String.t option }
    let make ~conversion_task_id  ?dry_run  ?reason_message  () =
      { conversion_task_id; dry_run; reason_message }
    let parse xml =
      Some
        {
          conversion_task_id =
            (Xml.required "conversionTaskId"
               (Util.option_bind (Xml.member "conversionTaskId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          reason_message =
            (Util.option_bind (Xml.member "reasonMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reason_message
              (fun f -> Query.Pair ("ReasonMessage", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ConversionTaskId", (String.to_query v.conversion_task_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "conversionTaskId"
                   ([], (String.to_xml v.conversion_task_id)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.reason_message
              (fun f ->
                 Ezxmlm.make_tag "reasonMessage" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reason_message
              (fun f -> ("reason_message", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("conversion_task_id", (String.to_json v.conversion_task_id))])
    let of_json j =
      {
        conversion_task_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "conversion_task_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        reason_message =
          (Util.option_map (Json.lookup j "reason_message") String.of_json)
      }
  end
module AssociateClientVpnTargetNetworkRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      subnet_id: String.t ;
      client_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ~subnet_id  ?client_token  ?dry_run  ()
      = { client_vpn_endpoint_id; subnet_id; client_token; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          subnet_id =
            (Xml.required "SubnetId"
               (Util.option_bind (Xml.member "SubnetId" xml) String.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "ClientVpnEndpointId"
                    ([], (String.to_xml v.client_vpn_endpoint_id)))])
             @
             [Some
                (Ezxmlm.make_tag "SubnetId" ([], (String.to_xml v.subnet_id)))])
            @
            [Util.option_map v.client_token
               (fun f ->
                  Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some ("subnet_id", (String.to_json v.subnet_id));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AttachInternetGatewayRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      internet_gateway_id: String.t ;
      vpc_id: String.t }
    let make ?dry_run  ~internet_gateway_id  ~vpc_id  () =
      { dry_run; internet_gateway_id; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          internet_gateway_id =
            (Xml.required "internetGatewayId"
               (Util.option_bind (Xml.member "internetGatewayId" xml)
                  String.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("InternetGatewayId",
                  (String.to_query v.internet_gateway_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "internetGatewayId"
                  ([], (String.to_xml v.internet_gateway_id)))])
           @ [Some (Ezxmlm.make_tag "vpcId" ([], (String.to_xml v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some
             ("internet_gateway_id", (String.to_json v.internet_gateway_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        internet_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateway_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DescribeFleetHistoryRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      event_type: FleetEventType.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      fleet_id: String.t ;
      start_time: DateTime.t }
    let make ?dry_run  ?event_type  ?max_results  ?next_token  ~fleet_id 
      ~start_time  () =
      { dry_run; event_type; max_results; next_token; fleet_id; start_time }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          event_type =
            (Util.option_bind (Xml.member "EventType" xml)
               FleetEventType.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          fleet_id =
            (Xml.required "FleetId"
               (Util.option_bind (Xml.member "FleetId" xml) String.parse));
          start_time =
            (Xml.required "StartTime"
               (Util.option_bind (Xml.member "StartTime" xml) DateTime.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("StartTime", (DateTime.to_query v.start_time)));
           Some (Query.Pair ("FleetId", (String.to_query v.fleet_id)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.event_type
             (fun f -> Query.Pair ("EventType", (FleetEventType.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.dry_run
                   (fun f ->
                      Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.event_type
                  (fun f ->
                     Ezxmlm.make_tag "EventType"
                       ([], (FleetEventType.to_xml f)))])
              @
              [Util.option_map v.max_results
                 (fun f ->
                    Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "FleetId" ([], (String.to_xml v.fleet_id)))])
           @
           [Some
              (Ezxmlm.make_tag "StartTime"
                 ([], (DateTime.to_xml v.start_time)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("start_time", (DateTime.to_json v.start_time));
           Some ("fleet_id", (String.to_json v.fleet_id));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.event_type
             (fun f -> ("event_type", (FleetEventType.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        event_type =
          (Util.option_map (Json.lookup j "event_type")
             FleetEventType.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        fleet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "fleet_id")));
        start_time =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "start_time")))
      }
  end
module DescribeFleetsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      fleet_ids: FleetIdSet.t ;
      filters: FilterList.t }
    let make ?dry_run  ?max_results  ?next_token  ?(fleet_ids= []) 
      ?(filters= [])  () =
      { dry_run; max_results; next_token; fleet_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          fleet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "FleetId" xml) FleetIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some (Query.Pair ("FleetId", (FleetIdSet.to_query v.fleet_ids)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.max_results
                 (fun f ->
                    Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "FleetId" ([], (FleetIdSet.to_xml [x]))))
               v.fleet_ids))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
              v.filters))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some ("fleet_ids", (FleetIdSet.to_json v.fleet_ids));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        fleet_ids =
          (FleetIdSet.of_json
             (Util.of_option_exn (Json.lookup j "fleet_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DescribeLaunchTemplatesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      launch_template_ids: ValueStringList.t ;
      launch_template_names: LaunchTemplateNameStringList.t ;
      filters: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?dry_run  ?(launch_template_ids= [])  ?(launch_template_names=
      [])  ?(filters= [])  ?next_token  ?max_results  () =
      {
        dry_run;
        launch_template_ids;
        launch_template_names;
        filters;
        next_token;
        max_results
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          launch_template_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "LaunchTemplateId" xml)
                  ValueStringList.parse));
          launch_template_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "LaunchTemplateName" xml)
                  LaunchTemplateNameStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("LaunchTemplateName",
                  (LaunchTemplateNameStringList.to_query
                     v.launch_template_names)));
           Some
             (Query.Pair
                ("LaunchTemplateId",
                  (ValueStringList.to_query v.launch_template_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.dry_run
                   (fun f ->
                      Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "LaunchTemplateId"
                          ([], (ValueStringList.to_xml [x]))))
                  v.launch_template_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "LaunchTemplateName"
                         ([], (LaunchTemplateNameStringList.to_xml [x]))))
                 v.launch_template_names))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("launch_template_names",
               (LaunchTemplateNameStringList.to_json v.launch_template_names));
           Some
             ("launch_template_ids",
               (ValueStringList.to_json v.launch_template_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        launch_template_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_ids")));
        launch_template_names =
          (LaunchTemplateNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_names")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module CancelSpotFleetRequestsResponse =
  struct
    type t =
      {
      successful_fleet_requests: CancelSpotFleetRequestsSuccessSet.t ;
      unsuccessful_fleet_requests: CancelSpotFleetRequestsErrorSet.t }
    let make ?(successful_fleet_requests= [])  ?(unsuccessful_fleet_requests=
      [])  () = { successful_fleet_requests; unsuccessful_fleet_requests }
    let parse xml =
      Some
        {
          successful_fleet_requests =
            (Util.of_option []
               (Util.option_bind (Xml.member "successfulFleetRequestSet" xml)
                  CancelSpotFleetRequestsSuccessSet.parse));
          unsuccessful_fleet_requests =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "unsuccessfulFleetRequestSet" xml)
                  CancelSpotFleetRequestsErrorSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnsuccessfulFleetRequestSet",
                   (CancelSpotFleetRequestsErrorSet.to_query
                      v.unsuccessful_fleet_requests)));
           Some
             (Query.Pair
                ("SuccessfulFleetRequestSet",
                  (CancelSpotFleetRequestsSuccessSet.to_query
                     v.successful_fleet_requests)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "successfulFleetRequestSet"
                       ([], (CancelSpotFleetRequestsSuccessSet.to_xml [x]))))
               v.successful_fleet_requests))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessfulFleetRequestSet"
                      ([], (CancelSpotFleetRequestsErrorSet.to_xml [x]))))
              v.unsuccessful_fleet_requests))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful_fleet_requests",
                (CancelSpotFleetRequestsErrorSet.to_json
                   v.unsuccessful_fleet_requests));
           Some
             ("successful_fleet_requests",
               (CancelSpotFleetRequestsSuccessSet.to_json
                  v.successful_fleet_requests))])
    let of_json j =
      {
        successful_fleet_requests =
          (CancelSpotFleetRequestsSuccessSet.of_json
             (Util.of_option_exn (Json.lookup j "successful_fleet_requests")));
        unsuccessful_fleet_requests =
          (CancelSpotFleetRequestsErrorSet.of_json
             (Util.of_option_exn
                (Json.lookup j "unsuccessful_fleet_requests")))
      }
  end
module CreateSnapshotRequest =
  struct
    type t =
      {
      description: String.t option ;
      volume_id: String.t ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ?description  ~volume_id  ?(tag_specifications= [])  ?dry_run 
      () = { description; volume_id; tag_specifications; dry_run }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "VolumeId" ([], (String.to_xml v.volume_id)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "TagSpecification"
                       ([], (TagSpecificationList.to_xml [x]))))
               v.tag_specifications))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeAccountAttributesResult =
  struct
    type t = {
      account_attributes: AccountAttributeList.t }
    let make ?(account_attributes= [])  () = { account_attributes }
    let parse xml =
      Some
        {
          account_attributes =
            (Util.of_option []
               (Util.option_bind (Xml.member "accountAttributeSet" xml)
                  AccountAttributeList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AccountAttributeSet",
                   (AccountAttributeList.to_query v.account_attributes)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "accountAttributeSet"
                      ([], (AccountAttributeList.to_xml [x]))))
              v.account_attributes))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("account_attributes",
                (AccountAttributeList.to_json v.account_attributes))])
    let of_json j =
      {
        account_attributes =
          (AccountAttributeList.of_json
             (Util.of_option_exn (Json.lookup j "account_attributes")))
      }
  end
module CreateTransitGatewayPeeringAttachmentResult =
  struct
    type t =
      {
      transit_gateway_peering_attachment:
        TransitGatewayPeeringAttachment.t option }
    let make ?transit_gateway_peering_attachment  () =
      { transit_gateway_peering_attachment }
    let parse xml =
      Some
        {
          transit_gateway_peering_attachment =
            (Util.option_bind
               (Xml.member "transitGatewayPeeringAttachment" xml)
               TransitGatewayPeeringAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayPeeringAttachment",
                     (TransitGatewayPeeringAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayPeeringAttachment"
                   ([], (TransitGatewayPeeringAttachment.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 ("transit_gateway_peering_attachment",
                   (TransitGatewayPeeringAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_peering_attachment =
          (Util.option_map
             (Json.lookup j "transit_gateway_peering_attachment")
             TransitGatewayPeeringAttachment.of_json)
      }
  end
module ReplaceRouteTableAssociationResult =
  struct
    type t =
      {
      new_association_id: String.t option ;
      association_state: RouteTableAssociationState.t option }
    let make ?new_association_id  ?association_state  () =
      { new_association_id; association_state }
    let parse xml =
      Some
        {
          new_association_id =
            (Util.option_bind (Xml.member "newAssociationId" xml)
               String.parse);
          association_state =
            (Util.option_bind (Xml.member "associationState" xml)
               RouteTableAssociationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 Query.Pair
                   ("AssociationState",
                     (RouteTableAssociationState.to_query f)));
           Util.option_map v.new_association_id
             (fun f -> Query.Pair ("NewAssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.new_association_id
               (fun f ->
                  Ezxmlm.make_tag "newAssociationId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.association_state
              (fun f ->
                 Ezxmlm.make_tag "associationState"
                   ([], (RouteTableAssociationState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 ("association_state",
                   (RouteTableAssociationState.to_json f)));
           Util.option_map v.new_association_id
             (fun f -> ("new_association_id", (String.to_json f)))])
    let of_json j =
      {
        new_association_id =
          (Util.option_map (Json.lookup j "new_association_id")
             String.of_json);
        association_state =
          (Util.option_map (Json.lookup j "association_state")
             RouteTableAssociationState.of_json)
      }
  end
module GetCapacityReservationUsageRequest =
  struct
    type t =
      {
      capacity_reservation_id: String.t ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      dry_run: Boolean.t option }
    let make ~capacity_reservation_id  ?next_token  ?max_results  ?dry_run 
      () = { capacity_reservation_id; next_token; max_results; dry_run }
    let parse xml =
      Some
        {
          capacity_reservation_id =
            (Xml.required "CapacityReservationId"
               (Util.option_bind (Xml.member "CapacityReservationId" xml)
                  String.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("CapacityReservationId",
                  (String.to_query v.capacity_reservation_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "CapacityReservationId"
                    ([], (String.to_xml v.capacity_reservation_id)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("capacity_reservation_id",
               (String.to_json v.capacity_reservation_id))])
    let of_json j =
      {
        capacity_reservation_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "capacity_reservation_id")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeVolumeStatusRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      volume_ids: VolumeIdStringList.t ;
      dry_run: Boolean.t option }
    let make ?(filters= [])  ?max_results  ?next_token  ?(volume_ids= []) 
      ?dry_run  () =
      { filters; max_results; next_token; volume_ids; dry_run }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          volume_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VolumeId" xml)
                  VolumeIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("VolumeId", (VolumeIdStringList.to_query v.volume_ids)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filter"
                          ([], (FilterList.to_xml [x])))) v.filters))
              @
              [Util.option_map v.max_results
                 (fun f ->
                    Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "VolumeId"
                       ([], (VolumeIdStringList.to_xml [x])))) v.volume_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("volume_ids", (VolumeIdStringList.to_json v.volume_ids));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        volume_ids =
          (VolumeIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "volume_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeAggregateIdFormatRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module GetEbsDefaultKmsKeyIdRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateLocalGatewayRouteResult =
  struct
    type t = {
      route: LocalGatewayRoute.t option }
    let make ?route  () = { route }
    let parse xml =
      Some
        {
          route =
            (Util.option_bind (Xml.member "route" xml)
               LocalGatewayRoute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> Query.Pair ("Route", (LocalGatewayRoute.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.route
              (fun f ->
                 Ezxmlm.make_tag "route" ([], (LocalGatewayRoute.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> ("route", (LocalGatewayRoute.to_json f)))])
    let of_json j =
      {
        route =
          (Util.option_map (Json.lookup j "route") LocalGatewayRoute.of_json)
      }
  end
module DeleteTagsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      resources: ResourceIdList.t ;
      tags: TagList.t }
    let make ?dry_run  ~resources  ?(tags= [])  () =
      { dry_run; resources; tags }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          resources =
            (Xml.required "resourceId"
               (Util.option_bind (Xml.member "resourceId" xml)
                  ResourceIdList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tag" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Tag", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("ResourceId", (ResourceIdList.to_query v.resources)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "resourceId"
                       ([], (ResourceIdList.to_xml [x])))) v.resources))
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tag" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some ("resources", (ResourceIdList.to_json v.resources));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        resources =
          (ResourceIdList.of_json
             (Util.of_option_exn (Json.lookup j "resources")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ModifyVpcPeeringConnectionOptionsResult =
  struct
    type t =
      {
      accepter_peering_connection_options: PeeringConnectionOptions.t option ;
      requester_peering_connection_options: PeeringConnectionOptions.t option }
    let make ?accepter_peering_connection_options 
      ?requester_peering_connection_options  () =
      {
        accepter_peering_connection_options;
        requester_peering_connection_options
      }
    let parse xml =
      Some
        {
          accepter_peering_connection_options =
            (Util.option_bind
               (Xml.member "accepterPeeringConnectionOptions" xml)
               PeeringConnectionOptions.parse);
          requester_peering_connection_options =
            (Util.option_bind
               (Xml.member "requesterPeeringConnectionOptions" xml)
               PeeringConnectionOptions.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.requester_peering_connection_options
              (fun f ->
                 Query.Pair
                   ("RequesterPeeringConnectionOptions",
                     (PeeringConnectionOptions.to_query f)));
           Util.option_map v.accepter_peering_connection_options
             (fun f ->
                Query.Pair
                  ("AccepterPeeringConnectionOptions",
                    (PeeringConnectionOptions.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.accepter_peering_connection_options
               (fun f ->
                  Ezxmlm.make_tag "accepterPeeringConnectionOptions"
                    ([], (PeeringConnectionOptions.to_xml f)))])
           @
           [Util.option_map v.requester_peering_connection_options
              (fun f ->
                 Ezxmlm.make_tag "requesterPeeringConnectionOptions"
                   ([], (PeeringConnectionOptions.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.requester_peering_connection_options
              (fun f ->
                 ("requester_peering_connection_options",
                   (PeeringConnectionOptions.to_json f)));
           Util.option_map v.accepter_peering_connection_options
             (fun f ->
                ("accepter_peering_connection_options",
                  (PeeringConnectionOptions.to_json f)))])
    let of_json j =
      {
        accepter_peering_connection_options =
          (Util.option_map
             (Json.lookup j "accepter_peering_connection_options")
             PeeringConnectionOptions.of_json);
        requester_peering_connection_options =
          (Util.option_map
             (Json.lookup j "requester_peering_connection_options")
             PeeringConnectionOptions.of_json)
      }
  end
module ImportClientVpnClientCertificateRevocationListRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      certificate_revocation_list: String.t ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ~certificate_revocation_list  ?dry_run 
      () = { client_vpn_endpoint_id; certificate_revocation_list; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          certificate_revocation_list =
            (Xml.required "CertificateRevocationList"
               (Util.option_bind (Xml.member "CertificateRevocationList" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("CertificateRevocationList",
                  (String.to_query v.certificate_revocation_list)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "ClientVpnEndpointId"
                   ([], (String.to_xml v.client_vpn_endpoint_id)))])
            @
            [Some
               (Ezxmlm.make_tag "CertificateRevocationList"
                  ([], (String.to_xml v.certificate_revocation_list)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("certificate_revocation_list",
               (String.to_json v.certificate_revocation_list));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        certificate_revocation_list =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "certificate_revocation_list")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyTrafficMirrorFilterNetworkServicesRequest =
  struct
    type t =
      {
      traffic_mirror_filter_id: String.t ;
      add_network_services: TrafficMirrorNetworkServiceList.t ;
      remove_network_services: TrafficMirrorNetworkServiceList.t ;
      dry_run: Boolean.t option }
    let make ~traffic_mirror_filter_id  ?(add_network_services= []) 
      ?(remove_network_services= [])  ?dry_run  () =
      {
        traffic_mirror_filter_id;
        add_network_services;
        remove_network_services;
        dry_run
      }
    let parse xml =
      Some
        {
          traffic_mirror_filter_id =
            (Xml.required "TrafficMirrorFilterId"
               (Util.option_bind (Xml.member "TrafficMirrorFilterId" xml)
                  String.parse));
          add_network_services =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddNetworkService" xml)
                  TrafficMirrorNetworkServiceList.parse));
          remove_network_services =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveNetworkService" xml)
                  TrafficMirrorNetworkServiceList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("RemoveNetworkService",
                  (TrafficMirrorNetworkServiceList.to_query
                     v.remove_network_services)));
           Some
             (Query.Pair
                ("AddNetworkService",
                  (TrafficMirrorNetworkServiceList.to_query
                     v.add_network_services)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterId",
                  (String.to_query v.traffic_mirror_filter_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "TrafficMirrorFilterId"
                    ([], (String.to_xml v.traffic_mirror_filter_id)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "AddNetworkService"
                        ([], (TrafficMirrorNetworkServiceList.to_xml [x]))))
                v.add_network_services))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "RemoveNetworkService"
                       ([], (TrafficMirrorNetworkServiceList.to_xml [x]))))
               v.remove_network_services))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("remove_network_services",
               (TrafficMirrorNetworkServiceList.to_json
                  v.remove_network_services));
           Some
             ("add_network_services",
               (TrafficMirrorNetworkServiceList.to_json
                  v.add_network_services));
           Some
             ("traffic_mirror_filter_id",
               (String.to_json v.traffic_mirror_filter_id))])
    let of_json j =
      {
        traffic_mirror_filter_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_filter_id")));
        add_network_services =
          (TrafficMirrorNetworkServiceList.of_json
             (Util.of_option_exn (Json.lookup j "add_network_services")));
        remove_network_services =
          (TrafficMirrorNetworkServiceList.of_json
             (Util.of_option_exn (Json.lookup j "remove_network_services")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateVpcPeeringConnectionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      peer_owner_id: String.t option ;
      peer_vpc_id: String.t option ;
      vpc_id: String.t option ;
      peer_region: String.t option }
    let make ?dry_run  ?peer_owner_id  ?peer_vpc_id  ?vpc_id  ?peer_region 
      () = { dry_run; peer_owner_id; peer_vpc_id; vpc_id; peer_region }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          peer_owner_id =
            (Util.option_bind (Xml.member "peerOwnerId" xml) String.parse);
          peer_vpc_id =
            (Util.option_bind (Xml.member "peerVpcId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          peer_region =
            (Util.option_bind (Xml.member "PeerRegion" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.peer_region
              (fun f -> Query.Pair ("PeerRegion", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.peer_vpc_id
             (fun f -> Query.Pair ("PeerVpcId", (String.to_query f)));
           Util.option_map v.peer_owner_id
             (fun f -> Query.Pair ("PeerOwnerId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.peer_owner_id
                 (fun f ->
                    Ezxmlm.make_tag "peerOwnerId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.peer_vpc_id
                (fun f -> Ezxmlm.make_tag "peerVpcId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.vpc_id
               (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.peer_region
              (fun f -> Ezxmlm.make_tag "PeerRegion" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.peer_region
              (fun f -> ("peer_region", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.peer_vpc_id
             (fun f -> ("peer_vpc_id", (String.to_json f)));
           Util.option_map v.peer_owner_id
             (fun f -> ("peer_owner_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        peer_owner_id =
          (Util.option_map (Json.lookup j "peer_owner_id") String.of_json);
        peer_vpc_id =
          (Util.option_map (Json.lookup j "peer_vpc_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        peer_region =
          (Util.option_map (Json.lookup j "peer_region") String.of_json)
      }
  end
module DescribeVpcsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      vpc_ids: VpcIdStringList.t ;
      dry_run: Boolean.t option ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?(vpc_ids= [])  ?dry_run  ?next_token 
      ?max_results  () =
      { filters; vpc_ids; dry_run; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          vpc_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpcId" xml)
                  VpcIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VpcId", (VpcIdStringList.to_query v.vpc_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filter"
                          ([], (FilterList.to_xml [x])))) v.filters))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "VpcId"
                         ([], (VpcIdStringList.to_xml [x])))) v.vpc_ids))
             @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpc_ids", (VpcIdStringList.to_json v.vpc_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        vpc_ids =
          (VpcIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module SendDiagnosticInterruptRequest =
  struct
    type t = {
      instance_id: String.t ;
      dry_run: Boolean.t option }
    let make ~instance_id  ?dry_run  () = { instance_id; dry_run }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "InstanceId"
                  ([], (String.to_xml v.instance_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module RevokeClientVpnIngressResult =
  struct
    type t = {
      status: ClientVpnAuthorizationRuleStatus.t option }
    let make ?status  () = { status }
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnAuthorizationRuleStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair
                   ("Status", (ClientVpnAuthorizationRuleStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status"
                   ([], (ClientVpnAuthorizationRuleStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 ("status", (ClientVpnAuthorizationRuleStatus.to_json f)))])
    let of_json j =
      {
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnAuthorizationRuleStatus.of_json)
      }
  end
module DeleteTrafficMirrorFilterRuleResult =
  struct
    type t = {
      traffic_mirror_filter_rule_id: String.t option }
    let make ?traffic_mirror_filter_rule_id  () =
      { traffic_mirror_filter_rule_id }
    let parse xml =
      Some
        {
          traffic_mirror_filter_rule_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterRuleId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_rule_id
              (fun f ->
                 Query.Pair
                   ("TrafficMirrorFilterRuleId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.traffic_mirror_filter_rule_id
              (fun f ->
                 Ezxmlm.make_tag "trafficMirrorFilterRuleId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_rule_id
              (fun f -> ("traffic_mirror_filter_rule_id", (String.to_json f)))])
    let of_json j =
      {
        traffic_mirror_filter_rule_id =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_rule_id")
             String.of_json)
      }
  end
module DescribeVpcClassicLinkDnsSupportRequest =
  struct
    type t =
      {
      max_results: Integer.t option ;
      next_token: String.t option ;
      vpc_ids: VpcClassicLinkIdList.t }
    let make ?max_results  ?next_token  ?(vpc_ids= [])  () =
      { max_results; next_token; vpc_ids }
    let parse xml =
      Some
        {
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          vpc_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpcIds" xml)
                  VpcClassicLinkIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcIds", (VpcClassicLinkIdList.to_query v.vpc_ids)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "maxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "VpcIds"
                      ([], (VpcClassicLinkIdList.to_xml [x])))) v.vpc_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_ids", (VpcClassicLinkIdList.to_json v.vpc_ids));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)))])
    let of_json j =
      {
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        vpc_ids =
          (VpcClassicLinkIdList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_ids")))
      }
  end
module ModifyDefaultCreditSpecificationResult =
  struct
    type t =
      {
      instance_family_credit_specification:
        InstanceFamilyCreditSpecification.t option }
    let make ?instance_family_credit_specification  () =
      { instance_family_credit_specification }
    let parse xml =
      Some
        {
          instance_family_credit_specification =
            (Util.option_bind
               (Xml.member "instanceFamilyCreditSpecification" xml)
               InstanceFamilyCreditSpecification.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_family_credit_specification
              (fun f ->
                 Query.Pair
                   ("InstanceFamilyCreditSpecification",
                     (InstanceFamilyCreditSpecification.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.instance_family_credit_specification
              (fun f ->
                 Ezxmlm.make_tag "instanceFamilyCreditSpecification"
                   ([], (InstanceFamilyCreditSpecification.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_family_credit_specification
              (fun f ->
                 ("instance_family_credit_specification",
                   (InstanceFamilyCreditSpecification.to_json f)))])
    let of_json j =
      {
        instance_family_credit_specification =
          (Util.option_map
             (Json.lookup j "instance_family_credit_specification")
             InstanceFamilyCreditSpecification.of_json)
      }
  end
module BundleInstanceRequest =
  struct
    type t =
      {
      instance_id: String.t ;
      storage: Storage.t ;
      dry_run: Boolean.t option }
    let make ~instance_id  ~storage  ?dry_run  () =
      { instance_id; storage; dry_run }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          storage =
            (Xml.required "Storage"
               (Util.option_bind (Xml.member "Storage" xml) Storage.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Storage", (Storage.to_query v.storage)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "InstanceId"
                   ([], (String.to_xml v.instance_id)))])
            @
            [Some
               (Ezxmlm.make_tag "Storage" ([], (Storage.to_xml v.storage)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("storage", (Storage.to_json v.storage));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        storage =
          (Storage.of_json (Util.of_option_exn (Json.lookup j "storage")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteTransitGatewayRequest =
  struct
    type t = {
      transit_gateway_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_id  ?dry_run  () =
      { transit_gateway_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Xml.required "TransitGatewayId"
               (Util.option_bind (Xml.member "TransitGatewayId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayId", (String.to_query v.transit_gateway_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "TransitGatewayId"
                  ([], (String.to_xml v.transit_gateway_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("transit_gateway_id", (String.to_json v.transit_gateway_id))])
    let of_json j =
      {
        transit_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "transit_gateway_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ImportInstanceRequest =
  struct
    type t =
      {
      description: String.t option ;
      disk_images: DiskImageList.t ;
      dry_run: Boolean.t option ;
      launch_specification: ImportInstanceLaunchSpecification.t option ;
      platform: PlatformValues.t }
    let make ?description  ?(disk_images= [])  ?dry_run 
      ?launch_specification  ~platform  () =
      { description; disk_images; dry_run; launch_specification; platform }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          disk_images =
            (Util.of_option []
               (Util.option_bind (Xml.member "diskImage" xml)
                  DiskImageList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          launch_specification =
            (Util.option_bind (Xml.member "launchSpecification" xml)
               ImportInstanceLaunchSpecification.parse);
          platform =
            (Xml.required "platform"
               (Util.option_bind (Xml.member "platform" xml)
                  PlatformValues.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("Platform", (PlatformValues.to_query v.platform)));
           Util.option_map v.launch_specification
             (fun f ->
                Query.Pair
                  ("LaunchSpecification",
                    (ImportInstanceLaunchSpecification.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("DiskImage", (DiskImageList.to_query v.disk_images)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.description
                  (fun f ->
                     Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "diskImage"
                         ([], (DiskImageList.to_xml [x])))) v.disk_images))
             @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.launch_specification
               (fun f ->
                  Ezxmlm.make_tag "launchSpecification"
                    ([], (ImportInstanceLaunchSpecification.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "platform"
                 ([], (PlatformValues.to_xml v.platform)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("platform", (PlatformValues.to_json v.platform));
           Util.option_map v.launch_specification
             (fun f ->
                ("launch_specification",
                  (ImportInstanceLaunchSpecification.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("disk_images", (DiskImageList.to_json v.disk_images));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        disk_images =
          (DiskImageList.of_json
             (Util.of_option_exn (Json.lookup j "disk_images")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        launch_specification =
          (Util.option_map (Json.lookup j "launch_specification")
             ImportInstanceLaunchSpecification.of_json);
        platform =
          (PlatformValues.of_json
             (Util.of_option_exn (Json.lookup j "platform")))
      }
  end
module ImportVolumeRequest =
  struct
    type t =
      {
      availability_zone: String.t ;
      description: String.t option ;
      dry_run: Boolean.t option ;
      image: DiskImageDetail.t ;
      volume: VolumeDetail.t }
    let make ~availability_zone  ?description  ?dry_run  ~image  ~volume  ()
      = { availability_zone; description; dry_run; image; volume }
    let parse xml =
      Some
        {
          availability_zone =
            (Xml.required "availabilityZone"
               (Util.option_bind (Xml.member "availabilityZone" xml)
                  String.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          image =
            (Xml.required "image"
               (Util.option_bind (Xml.member "image" xml)
                  DiskImageDetail.parse));
          volume =
            (Xml.required "volume"
               (Util.option_bind (Xml.member "volume" xml) VolumeDetail.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Volume", (VolumeDetail.to_query v.volume)));
           Some (Query.Pair ("Image", (DiskImageDetail.to_query v.image)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "availabilityZone"
                     ([], (String.to_xml v.availability_zone)))])
              @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
             @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "image"
                  ([], (DiskImageDetail.to_xml v.image)))])
           @
           [Some
              (Ezxmlm.make_tag "volume" ([], (VolumeDetail.to_xml v.volume)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("volume", (VolumeDetail.to_json v.volume));
           Some ("image", (DiskImageDetail.to_json v.image));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some ("availability_zone", (String.to_json v.availability_zone))])
    let of_json j =
      {
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        image =
          (DiskImageDetail.of_json
             (Util.of_option_exn (Json.lookup j "image")));
        volume =
          (VolumeDetail.of_json (Util.of_option_exn (Json.lookup j "volume")))
      }
  end
module DescribeInstanceStatusRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      instance_ids: InstanceIdStringList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option ;
      include_all_instances: Boolean.t option }
    let make ?(filters= [])  ?(instance_ids= [])  ?max_results  ?next_token 
      ?dry_run  ?include_all_instances  () =
      {
        filters;
        instance_ids;
        max_results;
        next_token;
        dry_run;
        include_all_instances
      }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          include_all_instances =
            (Util.option_bind (Xml.member "includeAllInstances" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.include_all_instances
              (fun f ->
                 Query.Pair ("IncludeAllInstances", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "Filter"
                           ([], (FilterList.to_xml [x])))) v.filters))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "InstanceId"
                          ([], (InstanceIdStringList.to_xml [x]))))
                  v.instance_ids))
              @
              [Util.option_map v.max_results
                 (fun f ->
                    Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.include_all_instances
              (fun f ->
                 Ezxmlm.make_tag "includeAllInstances"
                   ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.include_all_instances
              (fun f -> ("include_all_instances", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        include_all_instances =
          (Util.option_map (Json.lookup j "include_all_instances")
             Boolean.of_json)
      }
  end
module ModifyClientVpnEndpointResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module CancelImportTaskRequest =
  struct
    type t =
      {
      cancel_reason: String.t option ;
      dry_run: Boolean.t option ;
      import_task_id: String.t option }
    let make ?cancel_reason  ?dry_run  ?import_task_id  () =
      { cancel_reason; dry_run; import_task_id }
    let parse xml =
      Some
        {
          cancel_reason =
            (Util.option_bind (Xml.member "CancelReason" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          import_task_id =
            (Util.option_bind (Xml.member "ImportTaskId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.import_task_id
              (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.cancel_reason
             (fun f -> Query.Pair ("CancelReason", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.cancel_reason
                (fun f ->
                   Ezxmlm.make_tag "CancelReason" ([], (String.to_xml f)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.import_task_id
              (fun f ->
                 Ezxmlm.make_tag "ImportTaskId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.import_task_id
              (fun f -> ("import_task_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.cancel_reason
             (fun f -> ("cancel_reason", (String.to_json f)))])
    let of_json j =
      {
        cancel_reason =
          (Util.option_map (Json.lookup j "cancel_reason") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json)
      }
  end
module DescribeVpcEndpointsResult =
  struct
    type t = {
      vpc_endpoints: VpcEndpointSet.t ;
      next_token: String.t option }
    let make ?(vpc_endpoints= [])  ?next_token  () =
      { vpc_endpoints; next_token }
    let parse xml =
      Some
        {
          vpc_endpoints =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcEndpointSet" xml)
                  VpcEndpointSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("VpcEndpointSet", (VpcEndpointSet.to_query v.vpc_endpoints)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "vpcEndpointSet"
                       ([], (VpcEndpointSet.to_xml [x])))) v.vpc_endpoints))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("vpc_endpoints", (VpcEndpointSet.to_json v.vpc_endpoints))])
    let of_json j =
      {
        vpc_endpoints =
          (VpcEndpointSet.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoints")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeClassicLinkInstancesResult =
  struct
    type t =
      {
      instances: ClassicLinkInstanceList.t ;
      next_token: String.t option }
    let make ?(instances= [])  ?next_token  () = { instances; next_token }
    let parse xml =
      Some
        {
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  ClassicLinkInstanceList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstancesSet",
                  (ClassicLinkInstanceList.to_query v.instances)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "instancesSet"
                       ([], (ClassicLinkInstanceList.to_xml [x]))))
               v.instances))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("instances", (ClassicLinkInstanceList.to_json v.instances))])
    let of_json j =
      {
        instances =
          (ClassicLinkInstanceList.of_json
             (Util.of_option_exn (Json.lookup j "instances")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetHostReservationPurchasePreviewResult =
  struct
    type t =
      {
      currency_code: CurrencyCodeValues.t option ;
      purchase: PurchaseSet.t ;
      total_hourly_price: String.t option ;
      total_upfront_price: String.t option }
    let make ?currency_code  ?(purchase= [])  ?total_hourly_price 
      ?total_upfront_price  () =
      { currency_code; purchase; total_hourly_price; total_upfront_price }
    let parse xml =
      Some
        {
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          purchase =
            (Util.of_option []
               (Util.option_bind (Xml.member "purchase" xml)
                  PurchaseSet.parse));
          total_hourly_price =
            (Util.option_bind (Xml.member "totalHourlyPrice" xml)
               String.parse);
          total_upfront_price =
            (Util.option_bind (Xml.member "totalUpfrontPrice" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_upfront_price
              (fun f -> Query.Pair ("TotalUpfrontPrice", (String.to_query f)));
           Util.option_map v.total_hourly_price
             (fun f -> Query.Pair ("TotalHourlyPrice", (String.to_query f)));
           Some (Query.Pair ("Purchase", (PurchaseSet.to_query v.purchase)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.currency_code
                 (fun f ->
                    Ezxmlm.make_tag "currencyCode"
                      ([], (CurrencyCodeValues.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "purchase"
                        ([], (PurchaseSet.to_xml [x])))) v.purchase))
            @
            [Util.option_map v.total_hourly_price
               (fun f ->
                  Ezxmlm.make_tag "totalHourlyPrice" ([], (String.to_xml f)))])
           @
           [Util.option_map v.total_upfront_price
              (fun f ->
                 Ezxmlm.make_tag "totalUpfrontPrice" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_upfront_price
              (fun f -> ("total_upfront_price", (String.to_json f)));
           Util.option_map v.total_hourly_price
             (fun f -> ("total_hourly_price", (String.to_json f)));
           Some ("purchase", (PurchaseSet.to_json v.purchase));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)))])
    let of_json j =
      {
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        purchase =
          (PurchaseSet.of_json
             (Util.of_option_exn (Json.lookup j "purchase")));
        total_hourly_price =
          (Util.option_map (Json.lookup j "total_hourly_price")
             String.of_json);
        total_upfront_price =
          (Util.option_map (Json.lookup j "total_upfront_price")
             String.of_json)
      }
  end
module DescribeTransitGatewayAttachmentsResult =
  struct
    type t =
      {
      transit_gateway_attachments: TransitGatewayAttachmentList.t ;
      next_token: String.t option }
    let make ?(transit_gateway_attachments= [])  ?next_token  () =
      { transit_gateway_attachments; next_token }
    let parse xml =
      Some
        {
          transit_gateway_attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "transitGatewayAttachments" xml)
                  TransitGatewayAttachmentList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachments",
                  (TransitGatewayAttachmentList.to_query
                     v.transit_gateway_attachments)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "transitGatewayAttachments"
                       ([], (TransitGatewayAttachmentList.to_xml [x]))))
               v.transit_gateway_attachments))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_attachments",
               (TransitGatewayAttachmentList.to_json
                  v.transit_gateway_attachments))])
    let of_json j =
      {
        transit_gateway_attachments =
          (TransitGatewayAttachmentList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachments")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateInternetGatewayRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeImageAttributeRequest =
  struct
    type t =
      {
      attribute: ImageAttributeName.t ;
      image_id: String.t ;
      dry_run: Boolean.t option }
    let make ~attribute  ~image_id  ?dry_run  () =
      { attribute; image_id; dry_run }
    let parse xml =
      Some
        {
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  ImageAttributeName.parse));
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Some
             (Query.Pair
                ("Attribute", (ImageAttributeName.to_query v.attribute)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "Attribute"
                   ([], (ImageAttributeName.to_xml v.attribute)))])
            @
            [Some
               (Ezxmlm.make_tag "ImageId" ([], (String.to_xml v.image_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("image_id", (String.to_json v.image_id));
           Some ("attribute", (ImageAttributeName.to_json v.attribute))])
    let of_json j =
      {
        attribute =
          (ImageAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")));
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyVpnConnectionRequest =
  struct
    type t =
      {
      vpn_connection_id: String.t ;
      transit_gateway_id: String.t option ;
      customer_gateway_id: String.t option ;
      vpn_gateway_id: String.t option ;
      dry_run: Boolean.t option }
    let make ~vpn_connection_id  ?transit_gateway_id  ?customer_gateway_id 
      ?vpn_gateway_id  ?dry_run  () =
      {
        vpn_connection_id;
        transit_gateway_id;
        customer_gateway_id;
        vpn_gateway_id;
        dry_run
      }
    let parse xml =
      Some
        {
          vpn_connection_id =
            (Xml.required "VpnConnectionId"
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  String.parse));
          transit_gateway_id =
            (Util.option_bind (Xml.member "TransitGatewayId" xml)
               String.parse);
          customer_gateway_id =
            (Util.option_bind (Xml.member "CustomerGatewayId" xml)
               String.parse);
          vpn_gateway_id =
            (Util.option_bind (Xml.member "VpnGatewayId" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> Query.Pair ("VpnGatewayId", (String.to_query f)));
           Util.option_map v.customer_gateway_id
             (fun f -> Query.Pair ("CustomerGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("VpnConnectionId", (String.to_query v.vpn_connection_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "VpnConnectionId"
                     ([], (String.to_xml v.vpn_connection_id)))])
              @
              [Util.option_map v.transit_gateway_id
                 (fun f ->
                    Ezxmlm.make_tag "TransitGatewayId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.customer_gateway_id
                (fun f ->
                   Ezxmlm.make_tag "CustomerGatewayId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.vpn_gateway_id
               (fun f ->
                  Ezxmlm.make_tag "VpnGatewayId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> ("vpn_gateway_id", (String.to_json f)));
           Util.option_map v.customer_gateway_id
             (fun f -> ("customer_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Some ("vpn_connection_id", (String.to_json v.vpn_connection_id))])
    let of_json j =
      {
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")));
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        customer_gateway_id =
          (Util.option_map (Json.lookup j "customer_gateway_id")
             String.of_json);
        vpn_gateway_id =
          (Util.option_map (Json.lookup j "vpn_gateway_id") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyVpnTunnelCertificateResult =
  struct
    type t = {
      vpn_connection: VpnConnection.t option }
    let make ?vpn_connection  () = { vpn_connection }
    let parse xml =
      Some
        {
          vpn_connection =
            (Util.option_bind (Xml.member "vpnConnection" xml)
               VpnConnection.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f ->
                 Query.Pair ("VpnConnection", (VpnConnection.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpn_connection
              (fun f ->
                 Ezxmlm.make_tag "vpnConnection"
                   ([], (VpnConnection.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f -> ("vpn_connection", (VpnConnection.to_json f)))])
    let of_json j =
      {
        vpn_connection =
          (Util.option_map (Json.lookup j "vpn_connection")
             VpnConnection.of_json)
      }
  end
module DescribeSnapshotsResult =
  struct
    type t = {
      snapshots: SnapshotList.t ;
      next_token: String.t option }
    let make ?(snapshots= [])  ?next_token  () = { snapshots; next_token }
    let parse xml =
      Some
        {
          snapshots =
            (Util.of_option []
               (Util.option_bind (Xml.member "snapshotSet" xml)
                  SnapshotList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair ("SnapshotSet", (SnapshotList.to_query v.snapshots)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "snapshotSet"
                       ([], (SnapshotList.to_xml [x])))) v.snapshots))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("snapshots", (SnapshotList.to_json v.snapshots))])
    let of_json j =
      {
        snapshots =
          (SnapshotList.of_json
             (Util.of_option_exn (Json.lookup j "snapshots")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetEbsEncryptionByDefaultResult =
  struct
    type t = {
      ebs_encryption_by_default: Boolean.t option }
    let make ?ebs_encryption_by_default  () = { ebs_encryption_by_default }
    let parse xml =
      Some
        {
          ebs_encryption_by_default =
            (Util.option_bind (Xml.member "ebsEncryptionByDefault" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f ->
                 Query.Pair ("EbsEncryptionByDefault", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ebs_encryption_by_default
              (fun f ->
                 Ezxmlm.make_tag "ebsEncryptionByDefault"
                   ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f -> ("ebs_encryption_by_default", (Boolean.to_json f)))])
    let of_json j =
      {
        ebs_encryption_by_default =
          (Util.option_map (Json.lookup j "ebs_encryption_by_default")
             Boolean.of_json)
      }
  end
module AssociateIamInstanceProfileResult =
  struct
    type t =
      {
      iam_instance_profile_association:
        IamInstanceProfileAssociation.t option }
    let make ?iam_instance_profile_association  () =
      { iam_instance_profile_association }
    let parse xml =
      Some
        {
          iam_instance_profile_association =
            (Util.option_bind
               (Xml.member "iamInstanceProfileAssociation" xml)
               IamInstanceProfileAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 Query.Pair
                   ("IamInstanceProfileAssociation",
                     (IamInstanceProfileAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 Ezxmlm.make_tag "iamInstanceProfileAssociation"
                   ([], (IamInstanceProfileAssociation.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 ("iam_instance_profile_association",
                   (IamInstanceProfileAssociation.to_json f)))])
    let of_json j =
      {
        iam_instance_profile_association =
          (Util.option_map (Json.lookup j "iam_instance_profile_association")
             IamInstanceProfileAssociation.of_json)
      }
  end
module EnableVolumeIORequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      volume_id: String.t }
    let make ?dry_run  ~volume_id  () = { dry_run; volume_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          volume_id =
            (Xml.required "volumeId"
               (Util.option_bind (Xml.member "volumeId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "volumeId" ([], (String.to_xml v.volume_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")))
      }
  end
module CreateTrafficMirrorFilterRequest =
  struct
    type t =
      {
      description: String.t option ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option ;
      client_token: String.t option }
    let make ?description  ?(tag_specifications= [])  ?dry_run  ?client_token
       () = { description; tag_specifications; dry_run; client_token }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "TagSpecification"
                        ([], (TagSpecificationList.to_xml [x]))))
                v.tag_specifications))
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeTransitGatewayMulticastDomainsRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_ids:
        TransitGatewayMulticastDomainIdStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(transit_gateway_multicast_domain_ids= [])  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        transit_gateway_multicast_domain_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "TransitGatewayMulticastDomainIds" xml)
                  TransitGatewayMulticastDomainIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayMulticastDomainIds",
                  (TransitGatewayMulticastDomainIdStringList.to_query
                     v.transit_gateway_multicast_domain_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "TransitGatewayMulticastDomainIds"
                          ([],
                            (TransitGatewayMulticastDomainIdStringList.to_xml
                               [x])))) v.transit_gateway_multicast_domain_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_multicast_domain_ids",
               (TransitGatewayMulticastDomainIdStringList.to_json
                  v.transit_gateway_multicast_domain_ids))])
    let of_json j =
      {
        transit_gateway_multicast_domain_ids =
          (TransitGatewayMulticastDomainIdStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_multicast_domain_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateTransitGatewayMulticastDomainResult =
  struct
    type t =
      {
      transit_gateway_multicast_domain:
        TransitGatewayMulticastDomain.t option }
    let make ?transit_gateway_multicast_domain  () =
      { transit_gateway_multicast_domain }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomain" xml)
               TransitGatewayMulticastDomain.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_multicast_domain
              (fun f ->
                 Query.Pair
                   ("TransitGatewayMulticastDomain",
                     (TransitGatewayMulticastDomain.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_multicast_domain
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayMulticastDomain"
                   ([], (TransitGatewayMulticastDomain.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_multicast_domain
              (fun f ->
                 ("transit_gateway_multicast_domain",
                   (TransitGatewayMulticastDomain.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain =
          (Util.option_map (Json.lookup j "transit_gateway_multicast_domain")
             TransitGatewayMulticastDomain.of_json)
      }
  end
module PurchaseScheduledInstancesResult =
  struct
    type t = {
      scheduled_instance_set: PurchasedScheduledInstanceSet.t }
    let make ?(scheduled_instance_set= [])  () = { scheduled_instance_set }
    let parse xml =
      Some
        {
          scheduled_instance_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "scheduledInstanceSet" xml)
                  PurchasedScheduledInstanceSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ScheduledInstanceSet",
                   (PurchasedScheduledInstanceSet.to_query
                      v.scheduled_instance_set)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "scheduledInstanceSet"
                      ([], (PurchasedScheduledInstanceSet.to_xml [x]))))
              v.scheduled_instance_set))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("scheduled_instance_set",
                (PurchasedScheduledInstanceSet.to_json
                   v.scheduled_instance_set))])
    let of_json j =
      {
        scheduled_instance_set =
          (PurchasedScheduledInstanceSet.of_json
             (Util.of_option_exn (Json.lookup j "scheduled_instance_set")))
      }
  end
module CreateFleetResult =
  struct
    type t =
      {
      fleet_id: String.t option ;
      errors: CreateFleetErrorsSet.t ;
      instances: CreateFleetInstancesSet.t }
    let make ?fleet_id  ?(errors= [])  ?(instances= [])  () =
      { fleet_id; errors; instances }
    let parse xml =
      Some
        {
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse);
          errors =
            (Util.of_option []
               (Util.option_bind (Xml.member "errorSet" xml)
                  CreateFleetErrorsSet.parse));
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "fleetInstanceSet" xml)
                  CreateFleetInstancesSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FleetInstanceSet",
                   (CreateFleetInstancesSet.to_query v.instances)));
           Some
             (Query.Pair
                ("ErrorSet", (CreateFleetErrorsSet.to_query v.errors)));
           Util.option_map v.fleet_id
             (fun f -> Query.Pair ("FleetId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.fleet_id
                (fun f -> Ezxmlm.make_tag "fleetId" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "errorSet"
                       ([], (CreateFleetErrorsSet.to_xml [x])))) v.errors))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "fleetInstanceSet"
                      ([], (CreateFleetInstancesSet.to_xml [x]))))
              v.instances))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instances", (CreateFleetInstancesSet.to_json v.instances));
           Some ("errors", (CreateFleetErrorsSet.to_json v.errors));
           Util.option_map v.fleet_id
             (fun f -> ("fleet_id", (String.to_json f)))])
    let of_json j =
      {
        fleet_id =
          (Util.option_map (Json.lookup j "fleet_id") String.of_json);
        errors =
          (CreateFleetErrorsSet.of_json
             (Util.of_option_exn (Json.lookup j "errors")));
        instances =
          (CreateFleetInstancesSet.of_json
             (Util.of_option_exn (Json.lookup j "instances")))
      }
  end
module CreateSnapshotsResult =
  struct
    type t = {
      snapshots: SnapshotSet.t }
    let make ?(snapshots= [])  () = { snapshots }
    let parse xml =
      Some
        {
          snapshots =
            (Util.of_option []
               (Util.option_bind (Xml.member "snapshotSet" xml)
                  SnapshotSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("SnapshotSet", (SnapshotSet.to_query v.snapshots)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "snapshotSet"
                      ([], (SnapshotSet.to_xml [x])))) v.snapshots))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("snapshots", (SnapshotSet.to_json v.snapshots))])
    let of_json j =
      {
        snapshots =
          (SnapshotSet.of_json
             (Util.of_option_exn (Json.lookup j "snapshots")))
      }
  end
module DescribeTrafficMirrorTargetsResult =
  struct
    type t =
      {
      traffic_mirror_targets: TrafficMirrorTargetSet.t ;
      next_token: String.t option }
    let make ?(traffic_mirror_targets= [])  ?next_token  () =
      { traffic_mirror_targets; next_token }
    let parse xml =
      Some
        {
          traffic_mirror_targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "trafficMirrorTargetSet" xml)
                  TrafficMirrorTargetSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorTargetSet",
                  (TrafficMirrorTargetSet.to_query v.traffic_mirror_targets)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "trafficMirrorTargetSet"
                       ([], (TrafficMirrorTargetSet.to_xml [x]))))
               v.traffic_mirror_targets))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("traffic_mirror_targets",
               (TrafficMirrorTargetSet.to_json v.traffic_mirror_targets))])
    let of_json j =
      {
        traffic_mirror_targets =
          (TrafficMirrorTargetSet.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_targets")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeNetworkInterfaceAttributeRequest =
  struct
    type t =
      {
      attribute: NetworkInterfaceAttribute.t option ;
      dry_run: Boolean.t option ;
      network_interface_id: String.t }
    let make ?attribute  ?dry_run  ~network_interface_id  () =
      { attribute; dry_run; network_interface_id }
    let parse xml =
      Some
        {
          attribute =
            (Util.option_bind (Xml.member "attribute" xml)
               NetworkInterfaceAttribute.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkInterfaceId",
                   (String.to_query v.network_interface_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.attribute
             (fun f ->
                Query.Pair
                  ("Attribute", (NetworkInterfaceAttribute.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.attribute
                (fun f ->
                   Ezxmlm.make_tag "attribute"
                     ([], (NetworkInterfaceAttribute.to_xml f)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "networkInterfaceId"
                 ([], (String.to_xml v.network_interface_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("network_interface_id",
                (String.to_json v.network_interface_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.attribute
             (fun f -> ("attribute", (NetworkInterfaceAttribute.to_json f)))])
    let of_json j =
      {
        attribute =
          (Util.option_map (Json.lookup j "attribute")
             NetworkInterfaceAttribute.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")))
      }
  end
module EnableVpcClassicLinkDnsSupportResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module ModifyTrafficMirrorFilterRuleRequest =
  struct
    type t =
      {
      traffic_mirror_filter_rule_id: String.t ;
      traffic_direction: TrafficDirection.t option ;
      rule_number: Integer.t option ;
      rule_action: TrafficMirrorRuleAction.t option ;
      destination_port_range: TrafficMirrorPortRangeRequest.t option ;
      source_port_range: TrafficMirrorPortRangeRequest.t option ;
      protocol: Integer.t option ;
      destination_cidr_block: String.t option ;
      source_cidr_block: String.t option ;
      description: String.t option ;
      remove_fields: TrafficMirrorFilterRuleFieldList.t ;
      dry_run: Boolean.t option }
    let make ~traffic_mirror_filter_rule_id  ?traffic_direction  ?rule_number
       ?rule_action  ?destination_port_range  ?source_port_range  ?protocol 
      ?destination_cidr_block  ?source_cidr_block  ?description 
      ?(remove_fields= [])  ?dry_run  () =
      {
        traffic_mirror_filter_rule_id;
        traffic_direction;
        rule_number;
        rule_action;
        destination_port_range;
        source_port_range;
        protocol;
        destination_cidr_block;
        source_cidr_block;
        description;
        remove_fields;
        dry_run
      }
    let parse xml =
      Some
        {
          traffic_mirror_filter_rule_id =
            (Xml.required "TrafficMirrorFilterRuleId"
               (Util.option_bind (Xml.member "TrafficMirrorFilterRuleId" xml)
                  String.parse));
          traffic_direction =
            (Util.option_bind (Xml.member "TrafficDirection" xml)
               TrafficDirection.parse);
          rule_number =
            (Util.option_bind (Xml.member "RuleNumber" xml) Integer.parse);
          rule_action =
            (Util.option_bind (Xml.member "RuleAction" xml)
               TrafficMirrorRuleAction.parse);
          destination_port_range =
            (Util.option_bind (Xml.member "DestinationPortRange" xml)
               TrafficMirrorPortRangeRequest.parse);
          source_port_range =
            (Util.option_bind (Xml.member "SourcePortRange" xml)
               TrafficMirrorPortRangeRequest.parse);
          protocol =
            (Util.option_bind (Xml.member "Protocol" xml) Integer.parse);
          destination_cidr_block =
            (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
               String.parse);
          source_cidr_block =
            (Util.option_bind (Xml.member "SourceCidrBlock" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          remove_fields =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveField" xml)
                  TrafficMirrorFilterRuleFieldList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("RemoveField",
                  (TrafficMirrorFilterRuleFieldList.to_query v.remove_fields)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.source_cidr_block
             (fun f -> Query.Pair ("SourceCidrBlock", (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)));
           Util.option_map v.protocol
             (fun f -> Query.Pair ("Protocol", (Integer.to_query f)));
           Util.option_map v.source_port_range
             (fun f ->
                Query.Pair
                  ("SourcePortRange",
                    (TrafficMirrorPortRangeRequest.to_query f)));
           Util.option_map v.destination_port_range
             (fun f ->
                Query.Pair
                  ("DestinationPortRange",
                    (TrafficMirrorPortRangeRequest.to_query f)));
           Util.option_map v.rule_action
             (fun f ->
                Query.Pair
                  ("RuleAction", (TrafficMirrorRuleAction.to_query f)));
           Util.option_map v.rule_number
             (fun f -> Query.Pair ("RuleNumber", (Integer.to_query f)));
           Util.option_map v.traffic_direction
             (fun f ->
                Query.Pair
                  ("TrafficDirection", (TrafficDirection.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterRuleId",
                  (String.to_query v.traffic_mirror_filter_rule_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Some
                         (Ezxmlm.make_tag "TrafficMirrorFilterRuleId"
                            ([],
                              (String.to_xml v.traffic_mirror_filter_rule_id)))])
                     @
                     [Util.option_map v.traffic_direction
                        (fun f ->
                           Ezxmlm.make_tag "TrafficDirection"
                             ([], (TrafficDirection.to_xml f)))])
                    @
                    [Util.option_map v.rule_number
                       (fun f ->
                          Ezxmlm.make_tag "RuleNumber"
                            ([], (Integer.to_xml f)))])
                   @
                   [Util.option_map v.rule_action
                      (fun f ->
                         Ezxmlm.make_tag "RuleAction"
                           ([], (TrafficMirrorRuleAction.to_xml f)))])
                  @
                  [Util.option_map v.destination_port_range
                     (fun f ->
                        Ezxmlm.make_tag "DestinationPortRange"
                          ([], (TrafficMirrorPortRangeRequest.to_xml f)))])
                 @
                 [Util.option_map v.source_port_range
                    (fun f ->
                       Ezxmlm.make_tag "SourcePortRange"
                         ([], (TrafficMirrorPortRangeRequest.to_xml f)))])
                @
                [Util.option_map v.protocol
                   (fun f ->
                      Ezxmlm.make_tag "Protocol" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.destination_cidr_block
                  (fun f ->
                     Ezxmlm.make_tag "DestinationCidrBlock"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.source_cidr_block
                 (fun f ->
                    Ezxmlm.make_tag "SourceCidrBlock" ([], (String.to_xml f)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "RemoveField"
                       ([], (TrafficMirrorFilterRuleFieldList.to_xml [x]))))
               v.remove_fields))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("remove_fields",
               (TrafficMirrorFilterRuleFieldList.to_json v.remove_fields));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.source_cidr_block
             (fun f -> ("source_cidr_block", (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)));
           Util.option_map v.protocol
             (fun f -> ("protocol", (Integer.to_json f)));
           Util.option_map v.source_port_range
             (fun f ->
                ("source_port_range",
                  (TrafficMirrorPortRangeRequest.to_json f)));
           Util.option_map v.destination_port_range
             (fun f ->
                ("destination_port_range",
                  (TrafficMirrorPortRangeRequest.to_json f)));
           Util.option_map v.rule_action
             (fun f -> ("rule_action", (TrafficMirrorRuleAction.to_json f)));
           Util.option_map v.rule_number
             (fun f -> ("rule_number", (Integer.to_json f)));
           Util.option_map v.traffic_direction
             (fun f -> ("traffic_direction", (TrafficDirection.to_json f)));
           Some
             ("traffic_mirror_filter_rule_id",
               (String.to_json v.traffic_mirror_filter_rule_id))])
    let of_json j =
      {
        traffic_mirror_filter_rule_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "traffic_mirror_filter_rule_id")));
        traffic_direction =
          (Util.option_map (Json.lookup j "traffic_direction")
             TrafficDirection.of_json);
        rule_number =
          (Util.option_map (Json.lookup j "rule_number") Integer.of_json);
        rule_action =
          (Util.option_map (Json.lookup j "rule_action")
             TrafficMirrorRuleAction.of_json);
        destination_port_range =
          (Util.option_map (Json.lookup j "destination_port_range")
             TrafficMirrorPortRangeRequest.of_json);
        source_port_range =
          (Util.option_map (Json.lookup j "source_port_range")
             TrafficMirrorPortRangeRequest.of_json);
        protocol =
          (Util.option_map (Json.lookup j "protocol") Integer.of_json);
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        source_cidr_block =
          (Util.option_map (Json.lookup j "source_cidr_block") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        remove_fields =
          (TrafficMirrorFilterRuleFieldList.of_json
             (Util.of_option_exn (Json.lookup j "remove_fields")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateTransitGatewayRouteRequest =
  struct
    type t =
      {
      destination_cidr_block: String.t ;
      transit_gateway_route_table_id: String.t ;
      transit_gateway_attachment_id: String.t option ;
      blackhole: Boolean.t option ;
      dry_run: Boolean.t option }
    let make ~destination_cidr_block  ~transit_gateway_route_table_id 
      ?transit_gateway_attachment_id  ?blackhole  ?dry_run  () =
      {
        destination_cidr_block;
        transit_gateway_route_table_id;
        transit_gateway_attachment_id;
        blackhole;
        dry_run
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "TransitGatewayAttachmentId" xml)
               String.parse);
          blackhole =
            (Util.option_bind (Xml.member "Blackhole" xml) Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.blackhole
             (fun f -> Query.Pair ("Blackhole", (Boolean.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "DestinationCidrBlock"
                     ([], (String.to_xml v.destination_cidr_block)))])
              @
              [Some
                 (Ezxmlm.make_tag "TransitGatewayRouteTableId"
                    ([], (String.to_xml v.transit_gateway_route_table_id)))])
             @
             [Util.option_map v.transit_gateway_attachment_id
                (fun f ->
                   Ezxmlm.make_tag "TransitGatewayAttachmentId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.blackhole
               (fun f -> Ezxmlm.make_tag "Blackhole" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.blackhole
             (fun f -> ("blackhole", (Boolean.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block))])
    let of_json j =
      {
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        blackhole =
          (Util.option_map (Json.lookup j "blackhole") Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateClientVpnEndpointResult =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option ;
      status: ClientVpnEndpointStatus.t option ;
      dns_name: String.t option }
    let make ?client_vpn_endpoint_id  ?status  ?dns_name  () =
      { client_vpn_endpoint_id; status; dns_name }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnEndpointStatus.parse);
          dns_name =
            (Util.option_bind (Xml.member "dnsName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dns_name
              (fun f -> Query.Pair ("DnsName", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (ClientVpnEndpointStatus.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.client_vpn_endpoint_id
                (fun f ->
                   Ezxmlm.make_tag "clientVpnEndpointId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.status
               (fun f ->
                  Ezxmlm.make_tag "status"
                    ([], (ClientVpnEndpointStatus.to_xml f)))])
           @
           [Util.option_map v.dns_name
              (fun f -> Ezxmlm.make_tag "dnsName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dns_name
              (fun f -> ("dns_name", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ClientVpnEndpointStatus.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (Util.option_map (Json.lookup j "client_vpn_endpoint_id")
             String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnEndpointStatus.of_json);
        dns_name =
          (Util.option_map (Json.lookup j "dns_name") String.of_json)
      }
  end
module CreateVpcEndpointResult =
  struct
    type t =
      {
      vpc_endpoint: VpcEndpoint.t option ;
      client_token: String.t option }
    let make ?vpc_endpoint  ?client_token  () =
      { vpc_endpoint; client_token }
    let parse xml =
      Some
        {
          vpc_endpoint =
            (Util.option_bind (Xml.member "vpcEndpoint" xml)
               VpcEndpoint.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.vpc_endpoint
             (fun f -> Query.Pair ("VpcEndpoint", (VpcEndpoint.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.vpc_endpoint
               (fun f ->
                  Ezxmlm.make_tag "vpcEndpoint" ([], (VpcEndpoint.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.vpc_endpoint
             (fun f -> ("vpc_endpoint", (VpcEndpoint.to_json f)))])
    let of_json j =
      {
        vpc_endpoint =
          (Util.option_map (Json.lookup j "vpc_endpoint") VpcEndpoint.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeMovingAddressesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      public_ips: ValueStringList.t }
    let make ?(filters= [])  ?dry_run  ?max_results  ?next_token 
      ?(public_ips= [])  () =
      { filters; dry_run; max_results; next_token; public_ips }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          public_ips =
            (Util.of_option []
               (Util.option_bind (Xml.member "publicIp" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PublicIp", (ValueStringList.to_query v.public_ips)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "filter"
                          ([], (FilterList.to_xml [x])))) v.filters))
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "maxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "publicIp"
                      ([], (ValueStringList.to_xml [x])))) v.public_ips))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("public_ips", (ValueStringList.to_json v.public_ips));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        public_ips =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "public_ips")))
      }
  end
module MoveAddressToVpcRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      public_ip: String.t }
    let make ?dry_run  ~public_ip  () = { dry_run; public_ip }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          public_ip =
            (Xml.required "publicIp"
               (Util.option_bind (Xml.member "publicIp" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("PublicIp", (String.to_query v.public_ip)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "publicIp" ([], (String.to_xml v.public_ip)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("public_ip", (String.to_json v.public_ip));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        public_ip =
          (String.of_json (Util.of_option_exn (Json.lookup j "public_ip")))
      }
  end
module DescribeVolumesModificationsResult =
  struct
    type t =
      {
      volumes_modifications: VolumeModificationList.t ;
      next_token: String.t option }
    let make ?(volumes_modifications= [])  ?next_token  () =
      { volumes_modifications; next_token }
    let parse xml =
      Some
        {
          volumes_modifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "volumeModificationSet" xml)
                  VolumeModificationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("VolumeModificationSet",
                  (VolumeModificationList.to_query v.volumes_modifications)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "volumeModificationSet"
                       ([], (VolumeModificationList.to_xml [x]))))
               v.volumes_modifications))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("volumes_modifications",
               (VolumeModificationList.to_json v.volumes_modifications))])
    let of_json j =
      {
        volumes_modifications =
          (VolumeModificationList.of_json
             (Util.of_option_exn (Json.lookup j "volumes_modifications")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module RegisterTransitGatewayMulticastGroupSourcesRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      group_ip_address: String.t option ;
      network_interface_ids: ValueStringList.t ;
      dry_run: Boolean.t option }
    let make ?transit_gateway_multicast_domain_id  ?group_ip_address 
      ?(network_interface_ids= [])  ?dry_run  () =
      {
        transit_gateway_multicast_domain_id;
        group_ip_address;
        network_interface_ids;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse);
          group_ip_address =
            (Util.option_bind (Xml.member "GroupIpAddress" xml) String.parse);
          network_interface_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterfaceIds" xml)
                  ValueStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceIds",
                  (ValueStringList.to_query v.network_interface_ids)));
           Util.option_map v.group_ip_address
             (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.transit_gateway_multicast_domain_id
                 (fun f ->
                    Ezxmlm.make_tag "TransitGatewayMulticastDomainId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.group_ip_address
                (fun f ->
                   Ezxmlm.make_tag "GroupIpAddress" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "NetworkInterfaceIds"
                       ([], (ValueStringList.to_xml [x]))))
               v.network_interface_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("network_interface_ids",
               (ValueStringList.to_json v.network_interface_ids));
           Util.option_map v.group_ip_address
             (fun f -> ("group_ip_address", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json);
        network_interface_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ResetEbsDefaultKmsKeyIdResult =
  struct
    type t = {
      kms_key_id: String.t option }
    let make ?kms_key_id  () = { kms_key_id }
    let parse xml =
      Some
        {
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.kms_key_id
              (fun f -> Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> ("kms_key_id", (String.to_json f)))])
    let of_json j =
      {
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json)
      }
  end
module ResetImageAttributeRequest =
  struct
    type t =
      {
      attribute: ResetImageAttributeName.t ;
      image_id: String.t ;
      dry_run: Boolean.t option }
    let make ~attribute  ~image_id  ?dry_run  () =
      { attribute; image_id; dry_run }
    let parse xml =
      Some
        {
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  ResetImageAttributeName.parse));
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Some
             (Query.Pair
                ("Attribute", (ResetImageAttributeName.to_query v.attribute)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "Attribute"
                   ([], (ResetImageAttributeName.to_xml v.attribute)))])
            @
            [Some
               (Ezxmlm.make_tag "ImageId" ([], (String.to_xml v.image_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("image_id", (String.to_json v.image_id));
           Some ("attribute", (ResetImageAttributeName.to_json v.attribute))])
    let of_json j =
      {
        attribute =
          (ResetImageAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")));
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AcceptVpcEndpointConnectionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_id: String.t ;
      vpc_endpoint_ids: ValueStringList.t }
    let make ?dry_run  ~service_id  ~vpc_endpoint_ids  () =
      { dry_run; service_id; vpc_endpoint_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_id =
            (Xml.required "ServiceId"
               (Util.option_bind (Xml.member "ServiceId" xml) String.parse));
          vpc_endpoint_ids =
            (Xml.required "VpcEndpointId"
               (Util.option_bind (Xml.member "VpcEndpointId" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcEndpointId",
                   (ValueStringList.to_query v.vpc_endpoint_ids)));
           Some (Query.Pair ("ServiceId", (String.to_query v.service_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "ServiceId"
                  ([], (String.to_xml v.service_id)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "VpcEndpointId"
                      ([], (ValueStringList.to_xml [x])))) v.vpc_endpoint_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpc_endpoint_ids",
                (ValueStringList.to_json v.vpc_endpoint_ids));
           Some ("service_id", (String.to_json v.service_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "service_id")));
        vpc_endpoint_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoint_ids")))
      }
  end
module SearchTransitGatewayRoutesRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ~filters  ?max_results 
      ?dry_run  () =
      { transit_gateway_route_table_id; filters; max_results; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          filters =
            (Xml.required "Filter"
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "TransitGatewayRouteTableId"
                    ([], (String.to_xml v.transit_gateway_route_table_id)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CancelCapacityReservationResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module CopySnapshotRequest =
  struct
    type t =
      {
      description: String.t option ;
      destination_region: String.t option ;
      encrypted: Boolean.t option ;
      kms_key_id: String.t option ;
      presigned_url: String.t option ;
      source_region: String.t ;
      source_snapshot_id: String.t ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ?description  ?destination_region  ?encrypted  ?kms_key_id 
      ?presigned_url  ~source_region  ~source_snapshot_id 
      ?(tag_specifications= [])  ?dry_run  () =
      {
        description;
        destination_region;
        encrypted;
        kms_key_id;
        presigned_url;
        source_region;
        source_snapshot_id;
        tag_specifications;
        dry_run
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          destination_region =
            (Util.option_bind (Xml.member "destinationRegion" xml)
               String.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          presigned_url =
            (Util.option_bind (Xml.member "presignedUrl" xml) String.parse);
          source_region =
            (Xml.required "SourceRegion"
               (Util.option_bind (Xml.member "SourceRegion" xml) String.parse));
          source_snapshot_id =
            (Xml.required "SourceSnapshotId"
               (Util.option_bind (Xml.member "SourceSnapshotId" xml)
                  String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some
             (Query.Pair
                ("SourceSnapshotId", (String.to_query v.source_snapshot_id)));
           Some
             (Query.Pair ("SourceRegion", (String.to_query v.source_region)));
           Util.option_map v.presigned_url
             (fun f -> Query.Pair ("PresignedUrl", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.destination_region
             (fun f -> Query.Pair ("DestinationRegion", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.description
                      (fun f ->
                         Ezxmlm.make_tag "Description"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.destination_region
                     (fun f ->
                        Ezxmlm.make_tag "destinationRegion"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.encrypted
                    (fun f ->
                       Ezxmlm.make_tag "encrypted" ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.kms_key_id
                   (fun f ->
                      Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.presigned_url
                  (fun f ->
                     Ezxmlm.make_tag "presignedUrl" ([], (String.to_xml f)))])
              @
              [Some
                 (Ezxmlm.make_tag "SourceRegion"
                    ([], (String.to_xml v.source_region)))])
             @
             [Some
                (Ezxmlm.make_tag "SourceSnapshotId"
                   ([], (String.to_xml v.source_snapshot_id)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "TagSpecification"
                       ([], (TagSpecificationList.to_xml [x]))))
               v.tag_specifications))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("source_snapshot_id", (String.to_json v.source_snapshot_id));
           Some ("source_region", (String.to_json v.source_region));
           Util.option_map v.presigned_url
             (fun f -> ("presigned_url", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.destination_region
             (fun f -> ("destination_region", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        destination_region =
          (Util.option_map (Json.lookup j "destination_region")
             String.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        presigned_url =
          (Util.option_map (Json.lookup j "presigned_url") String.of_json);
        source_region =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_region")));
        source_snapshot_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_snapshot_id")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateDhcpOptionsRequest =
  struct
    type t =
      {
      dhcp_configurations: NewDhcpConfigurationList.t ;
      dry_run: Boolean.t option }
    let make ~dhcp_configurations  ?dry_run  () =
      { dhcp_configurations; dry_run }
    let parse xml =
      Some
        {
          dhcp_configurations =
            (Xml.required "dhcpConfiguration"
               (Util.option_bind (Xml.member "dhcpConfiguration" xml)
                  NewDhcpConfigurationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("DhcpConfiguration",
                  (NewDhcpConfigurationList.to_query v.dhcp_configurations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "dhcpConfiguration"
                       ([], (NewDhcpConfigurationList.to_xml [x]))))
               v.dhcp_configurations))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("dhcp_configurations",
               (NewDhcpConfigurationList.to_json v.dhcp_configurations))])
    let of_json j =
      {
        dhcp_configurations =
          (NewDhcpConfigurationList.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_configurations")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module UpdateSecurityGroupRuleDescriptionsIngressResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DescribeVpcAttributeRequest =
  struct
    type t =
      {
      attribute: VpcAttributeName.t ;
      vpc_id: String.t ;
      dry_run: Boolean.t option }
    let make ~attribute  ~vpc_id  ?dry_run  () =
      { attribute; vpc_id; dry_run }
    let parse xml =
      Some
        {
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  VpcAttributeName.parse));
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("Attribute", (VpcAttributeName.to_query v.attribute)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "Attribute"
                   ([], (VpcAttributeName.to_xml v.attribute)))])
            @ [Some (Ezxmlm.make_tag "VpcId" ([], (String.to_xml v.vpc_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("attribute", (VpcAttributeName.to_json v.attribute))])
    let of_json j =
      {
        attribute =
          (VpcAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module GetConsoleScreenshotResult =
  struct
    type t = {
      image_data: String.t option ;
      instance_id: String.t option }
    let make ?image_data  ?instance_id  () = { image_data; instance_id }
    let parse xml =
      Some
        {
          image_data =
            (Util.option_bind (Xml.member "imageData" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.image_data
             (fun f -> Query.Pair ("ImageData", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.image_data
               (fun f -> Ezxmlm.make_tag "imageData" ([], (String.to_xml f)))])
           @
           [Util.option_map v.instance_id
              (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.image_data
             (fun f -> ("image_data", (String.to_json f)))])
    let of_json j =
      {
        image_data =
          (Util.option_map (Json.lookup j "image_data") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json)
      }
  end
module DescribeNetworkInterfacesResult =
  struct
    type t =
      {
      network_interfaces: NetworkInterfaceList.t ;
      next_token: String.t option }
    let make ?(network_interfaces= [])  ?next_token  () =
      { network_interfaces; next_token }
    let parse xml =
      Some
        {
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  NetworkInterfaceList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (NetworkInterfaceList.to_query v.network_interfaces)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "networkInterfaceSet"
                       ([], (NetworkInterfaceList.to_xml [x]))))
               v.network_interfaces))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("network_interfaces",
               (NetworkInterfaceList.to_json v.network_interfaces))])
    let of_json j =
      {
        network_interfaces =
          (NetworkInterfaceList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateVpcRequest =
  struct
    type t =
      {
      cidr_block: String.t ;
      amazon_provided_ipv6_cidr_block: Boolean.t option ;
      dry_run: Boolean.t option ;
      instance_tenancy: Tenancy.t option ;
      ipv6_cidr_block_network_border_group: String.t option }
    let make ~cidr_block  ?amazon_provided_ipv6_cidr_block  ?dry_run 
      ?instance_tenancy  ?ipv6_cidr_block_network_border_group  () =
      {
        cidr_block;
        amazon_provided_ipv6_cidr_block;
        dry_run;
        instance_tenancy;
        ipv6_cidr_block_network_border_group
      }
    let parse xml =
      Some
        {
          cidr_block =
            (Xml.required "CidrBlock"
               (Util.option_bind (Xml.member "CidrBlock" xml) String.parse));
          amazon_provided_ipv6_cidr_block =
            (Util.option_bind (Xml.member "amazonProvidedIpv6CidrBlock" xml)
               Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_tenancy =
            (Util.option_bind (Xml.member "instanceTenancy" xml)
               Tenancy.parse);
          ipv6_cidr_block_network_border_group =
            (Util.option_bind
               (Xml.member "Ipv6CidrBlockNetworkBorderGroup" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block_network_border_group
              (fun f ->
                 Query.Pair
                   ("Ipv6CidrBlockNetworkBorderGroup", (String.to_query f)));
           Util.option_map v.instance_tenancy
             (fun f -> Query.Pair ("InstanceTenancy", (Tenancy.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.amazon_provided_ipv6_cidr_block
             (fun f ->
                Query.Pair
                  ("AmazonProvidedIpv6CidrBlock", (Boolean.to_query f)));
           Some (Query.Pair ("CidrBlock", (String.to_query v.cidr_block)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "CidrBlock"
                     ([], (String.to_xml v.cidr_block)))])
              @
              [Util.option_map v.amazon_provided_ipv6_cidr_block
                 (fun f ->
                    Ezxmlm.make_tag "amazonProvidedIpv6CidrBlock"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.instance_tenancy
               (fun f ->
                  Ezxmlm.make_tag "instanceTenancy" ([], (Tenancy.to_xml f)))])
           @
           [Util.option_map v.ipv6_cidr_block_network_border_group
              (fun f ->
                 Ezxmlm.make_tag "Ipv6CidrBlockNetworkBorderGroup"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block_network_border_group
              (fun f ->
                 ("ipv6_cidr_block_network_border_group", (String.to_json f)));
           Util.option_map v.instance_tenancy
             (fun f -> ("instance_tenancy", (Tenancy.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.amazon_provided_ipv6_cidr_block
             (fun f ->
                ("amazon_provided_ipv6_cidr_block", (Boolean.to_json f)));
           Some ("cidr_block", (String.to_json v.cidr_block))])
    let of_json j =
      {
        cidr_block =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_block")));
        amazon_provided_ipv6_cidr_block =
          (Util.option_map (Json.lookup j "amazon_provided_ipv6_cidr_block")
             Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_tenancy =
          (Util.option_map (Json.lookup j "instance_tenancy") Tenancy.of_json);
        ipv6_cidr_block_network_border_group =
          (Util.option_map
             (Json.lookup j "ipv6_cidr_block_network_border_group")
             String.of_json)
      }
  end
module DescribeVpcEndpointConnectionNotificationsResult =
  struct
    type t =
      {
      connection_notification_set: ConnectionNotificationSet.t ;
      next_token: String.t option }
    let make ?(connection_notification_set= [])  ?next_token  () =
      { connection_notification_set; next_token }
    let parse xml =
      Some
        {
          connection_notification_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "connectionNotificationSet" xml)
                  ConnectionNotificationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ConnectionNotificationSet",
                  (ConnectionNotificationSet.to_query
                     v.connection_notification_set)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "connectionNotificationSet"
                       ([], (ConnectionNotificationSet.to_xml [x]))))
               v.connection_notification_set))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("connection_notification_set",
               (ConnectionNotificationSet.to_json
                  v.connection_notification_set))])
    let of_json j =
      {
        connection_notification_set =
          (ConnectionNotificationSet.of_json
             (Util.of_option_exn
                (Json.lookup j "connection_notification_set")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ResetFpgaImageAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      fpga_image_id: String.t ;
      attribute: ResetFpgaImageAttributeName.t option }
    let make ?dry_run  ~fpga_image_id  ?attribute  () =
      { dry_run; fpga_image_id; attribute }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          fpga_image_id =
            (Xml.required "FpgaImageId"
               (Util.option_bind (Xml.member "FpgaImageId" xml) String.parse));
          attribute =
            (Util.option_bind (Xml.member "Attribute" xml)
               ResetFpgaImageAttributeName.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.attribute
              (fun f ->
                 Query.Pair
                   ("Attribute", (ResetFpgaImageAttributeName.to_query f)));
           Some
             (Query.Pair ("FpgaImageId", (String.to_query v.fpga_image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "FpgaImageId"
                  ([], (String.to_xml v.fpga_image_id)))])
           @
           [Util.option_map v.attribute
              (fun f ->
                 Ezxmlm.make_tag "Attribute"
                   ([], (ResetFpgaImageAttributeName.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.attribute
              (fun f ->
                 ("attribute", (ResetFpgaImageAttributeName.to_json f)));
           Some ("fpga_image_id", (String.to_json v.fpga_image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        fpga_image_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "fpga_image_id")));
        attribute =
          (Util.option_map (Json.lookup j "attribute")
             ResetFpgaImageAttributeName.of_json)
      }
  end
module DescribeClientVpnConnectionsRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      filters: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?(filters= [])  ?next_token 
      ?max_results  ?dry_run  () =
      { client_vpn_endpoint_id; filters; next_token; max_results; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "ClientVpnEndpointId"
                     ([], (String.to_xml v.client_vpn_endpoint_id)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateImageResult =
  struct
    type t = {
      image_id: String.t option }
    let make ?image_id  () = { image_id }
    let parse xml =
      Some
        {
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> Query.Pair ("ImageId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.image_id
              (fun f -> Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> ("image_id", (String.to_json f)))])
    let of_json j =
      {
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json)
      }
  end
module CreateNetworkAclRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      vpc_id: String.t }
    let make ?dry_run  ~vpc_id  () = { dry_run; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @ [Some (Ezxmlm.make_tag "vpcId" ([], (String.to_xml v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module CopyImageRequest =
  struct
    type t =
      {
      client_token: String.t option ;
      description: String.t option ;
      encrypted: Boolean.t option ;
      kms_key_id: String.t option ;
      name: String.t ;
      source_image_id: String.t ;
      source_region: String.t ;
      dry_run: Boolean.t option }
    let make ?client_token  ?description  ?encrypted  ?kms_key_id  ~name 
      ~source_image_id  ~source_region  ?dry_run  () =
      {
        client_token;
        description;
        encrypted;
        kms_key_id;
        name;
        source_image_id;
        source_region;
        dry_run
      }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          source_image_id =
            (Xml.required "SourceImageId"
               (Util.option_bind (Xml.member "SourceImageId" xml)
                  String.parse));
          source_region =
            (Xml.required "SourceRegion"
               (Util.option_bind (Xml.member "SourceRegion" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("SourceRegion", (String.to_query v.source_region)));
           Some
             (Query.Pair
                ("SourceImageId", (String.to_query v.source_image_id)));
           Some (Query.Pair ("Name", (String.to_query v.name)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.client_token
                     (fun f ->
                        Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.description
                    (fun f ->
                       Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
                @
                [Util.option_map v.encrypted
                   (fun f ->
                      Ezxmlm.make_tag "encrypted" ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.kms_key_id
                  (fun f ->
                     Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
              @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
             @
             [Some
                (Ezxmlm.make_tag "SourceImageId"
                   ([], (String.to_xml v.source_image_id)))])
            @
            [Some
               (Ezxmlm.make_tag "SourceRegion"
                  ([], (String.to_xml v.source_region)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("source_region", (String.to_json v.source_region));
           Some ("source_image_id", (String.to_json v.source_image_id));
           Some ("name", (String.to_json v.name));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        source_image_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_image_id")));
        source_region =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_region")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module RejectTransitGatewayVpcAttachmentResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.t option }
    let make ?transit_gateway_vpc_attachment  () =
      { transit_gateway_vpc_attachment }
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachment =
            (Util.option_bind (Xml.member "transitGatewayVpcAttachment" xml)
               TransitGatewayVpcAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayVpcAttachment",
                     (TransitGatewayVpcAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayVpcAttachment"
                   ([], (TransitGatewayVpcAttachment.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 ("transit_gateway_vpc_attachment",
                   (TransitGatewayVpcAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_vpc_attachment =
          (Util.option_map (Json.lookup j "transit_gateway_vpc_attachment")
             TransitGatewayVpcAttachment.of_json)
      }
  end
module DescribeNetworkInterfaceAttributeResult =
  struct
    type t =
      {
      attachment: NetworkInterfaceAttachment.t option ;
      description: AttributeValue.t option ;
      groups: GroupIdentifierList.t ;
      network_interface_id: String.t option ;
      source_dest_check: AttributeBooleanValue.t option }
    let make ?attachment  ?description  ?(groups= [])  ?network_interface_id 
      ?source_dest_check  () =
      {
        attachment;
        description;
        groups;
        network_interface_id;
        source_dest_check
      }
    let parse xml =
      Some
        {
          attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               NetworkInterfaceAttachment.parse);
          description =
            (Util.option_bind (Xml.member "description" xml)
               AttributeValue.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               AttributeBooleanValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.source_dest_check
              (fun f ->
                 Query.Pair
                   ("SourceDestCheck", (AttributeBooleanValue.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)));
           Util.option_map v.description
             (fun f ->
                Query.Pair ("Description", (AttributeValue.to_query f)));
           Util.option_map v.attachment
             (fun f ->
                Query.Pair
                  ("Attachment", (NetworkInterfaceAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.attachment
                  (fun f ->
                     Ezxmlm.make_tag "attachment"
                       ([], (NetworkInterfaceAttachment.to_xml f)))])
              @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "description"
                      ([], (AttributeValue.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "groupSet"
                        ([], (GroupIdentifierList.to_xml [x])))) v.groups))
            @
            [Util.option_map v.network_interface_id
               (fun f ->
                  Ezxmlm.make_tag "networkInterfaceId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.source_dest_check
              (fun f ->
                 Ezxmlm.make_tag "sourceDestCheck"
                   ([], (AttributeBooleanValue.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.source_dest_check
              (fun f ->
                 ("source_dest_check", (AttributeBooleanValue.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Some ("groups", (GroupIdentifierList.to_json v.groups));
           Util.option_map v.description
             (fun f -> ("description", (AttributeValue.to_json f)));
           Util.option_map v.attachment
             (fun f -> ("attachment", (NetworkInterfaceAttachment.to_json f)))])
    let of_json j =
      {
        attachment =
          (Util.option_map (Json.lookup j "attachment")
             NetworkInterfaceAttachment.of_json);
        description =
          (Util.option_map (Json.lookup j "description")
             AttributeValue.of_json);
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             AttributeBooleanValue.of_json)
      }
  end
module DescribeReservedInstancesResult =
  struct
    type t = {
      reserved_instances: ReservedInstancesList.t }
    let make ?(reserved_instances= [])  () = { reserved_instances }
    let parse xml =
      Some
        {
          reserved_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "reservedInstancesSet" xml)
                  ReservedInstancesList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesSet",
                   (ReservedInstancesList.to_query v.reserved_instances)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "reservedInstancesSet"
                      ([], (ReservedInstancesList.to_xml [x]))))
              v.reserved_instances))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances",
                (ReservedInstancesList.to_json v.reserved_instances))])
    let of_json j =
      {
        reserved_instances =
          (ReservedInstancesList.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances")))
      }
  end
module DescribeSecurityGroupReferencesRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      group_id: GroupIds.t }
    let make ?dry_run  ~group_id  () = { dry_run; group_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          group_id =
            (Xml.required "GroupId"
               (Util.option_bind (Xml.member "GroupId" xml) GroupIds.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("GroupId", (GroupIds.to_query v.group_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "GroupId" ([], (GroupIds.to_xml [x]))))
              v.group_id))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("group_id", (GroupIds.to_json v.group_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_id =
          (GroupIds.of_json (Util.of_option_exn (Json.lookup j "group_id")))
      }
  end
module CreateNatGatewayResult =
  struct
    type t =
      {
      client_token: String.t option ;
      nat_gateway: NatGateway.t option }
    let make ?client_token  ?nat_gateway  () = { client_token; nat_gateway }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          nat_gateway =
            (Util.option_bind (Xml.member "natGateway" xml) NatGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.nat_gateway
              (fun f -> Query.Pair ("NatGateway", (NatGateway.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.client_token
               (fun f ->
                  Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.nat_gateway
              (fun f ->
                 Ezxmlm.make_tag "natGateway" ([], (NatGateway.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.nat_gateway
              (fun f -> ("nat_gateway", (NatGateway.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        nat_gateway =
          (Util.option_map (Json.lookup j "nat_gateway") NatGateway.of_json)
      }
  end
module DescribePrincipalIdFormatRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      resources: ResourceList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(resources= [])  ?max_results  ?next_token  () =
      { dry_run; resources; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          resources =
            (Util.of_option []
               (Util.option_bind (Xml.member "Resource" xml)
                  ResourceList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair ("Resource", (ResourceList.to_query v.resources)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Resource"
                        ([], (ResourceList.to_xml [x])))) v.resources))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("resources", (ResourceList.to_json v.resources));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        resources =
          (ResourceList.of_json
             (Util.of_option_exn (Json.lookup j "resources")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeTransitGatewayPeeringAttachmentsResult =
  struct
    type t =
      {
      transit_gateway_peering_attachments:
        TransitGatewayPeeringAttachmentList.t ;
      next_token: String.t option }
    let make ?(transit_gateway_peering_attachments= [])  ?next_token  () =
      { transit_gateway_peering_attachments; next_token }
    let parse xml =
      Some
        {
          transit_gateway_peering_attachments =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "transitGatewayPeeringAttachments" xml)
                  TransitGatewayPeeringAttachmentList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayPeeringAttachments",
                  (TransitGatewayPeeringAttachmentList.to_query
                     v.transit_gateway_peering_attachments)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "transitGatewayPeeringAttachments"
                       ([], (TransitGatewayPeeringAttachmentList.to_xml [x]))))
               v.transit_gateway_peering_attachments))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_peering_attachments",
               (TransitGatewayPeeringAttachmentList.to_json
                  v.transit_gateway_peering_attachments))])
    let of_json j =
      {
        transit_gateway_peering_attachments =
          (TransitGatewayPeeringAttachmentList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_peering_attachments")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module AcceptTransitGatewayPeeringAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_attachment_id  ?dry_run  () =
      { transit_gateway_attachment_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "TransitGatewayAttachmentId"
                  ([], (String.to_xml v.transit_gateway_attachment_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CancelSpotInstanceRequestsResult =
  struct
    type t =
      {
      cancelled_spot_instance_requests: CancelledSpotInstanceRequestList.t }
    let make ?(cancelled_spot_instance_requests= [])  () =
      { cancelled_spot_instance_requests }
    let parse xml =
      Some
        {
          cancelled_spot_instance_requests =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotInstanceRequestSet" xml)
                  CancelledSpotInstanceRequestList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotInstanceRequestSet",
                   (CancelledSpotInstanceRequestList.to_query
                      v.cancelled_spot_instance_requests)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "spotInstanceRequestSet"
                      ([], (CancelledSpotInstanceRequestList.to_xml [x]))))
              v.cancelled_spot_instance_requests))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("cancelled_spot_instance_requests",
                (CancelledSpotInstanceRequestList.to_json
                   v.cancelled_spot_instance_requests))])
    let of_json j =
      {
        cancelled_spot_instance_requests =
          (CancelledSpotInstanceRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "cancelled_spot_instance_requests")))
      }
  end
module CreateSpotDatafeedSubscriptionResult =
  struct
    type t = {
      spot_datafeed_subscription: SpotDatafeedSubscription.t option }
    let make ?spot_datafeed_subscription  () = { spot_datafeed_subscription }
    let parse xml =
      Some
        {
          spot_datafeed_subscription =
            (Util.option_bind (Xml.member "spotDatafeedSubscription" xml)
               SpotDatafeedSubscription.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 Query.Pair
                   ("SpotDatafeedSubscription",
                     (SpotDatafeedSubscription.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 Ezxmlm.make_tag "spotDatafeedSubscription"
                   ([], (SpotDatafeedSubscription.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 ("spot_datafeed_subscription",
                   (SpotDatafeedSubscription.to_json f)))])
    let of_json j =
      {
        spot_datafeed_subscription =
          (Util.option_map (Json.lookup j "spot_datafeed_subscription")
             SpotDatafeedSubscription.of_json)
      }
  end
module DeleteTransitGatewayRouteRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      destination_cidr_block: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ~destination_cidr_block 
      ?dry_run  () =
      { transit_gateway_route_table_id; destination_cidr_block; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "TransitGatewayRouteTableId"
                   ([], (String.to_xml v.transit_gateway_route_table_id)))])
            @
            [Some
               (Ezxmlm.make_tag "DestinationCidrBlock"
                  ([], (String.to_xml v.destination_cidr_block)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeVpcEndpointServiceConfigurationsResult =
  struct
    type t =
      {
      service_configurations: ServiceConfigurationSet.t ;
      next_token: String.t option }
    let make ?(service_configurations= [])  ?next_token  () =
      { service_configurations; next_token }
    let parse xml =
      Some
        {
          service_configurations =
            (Util.of_option []
               (Util.option_bind (Xml.member "serviceConfigurationSet" xml)
                  ServiceConfigurationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ServiceConfigurationSet",
                  (ServiceConfigurationSet.to_query v.service_configurations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "serviceConfigurationSet"
                       ([], (ServiceConfigurationSet.to_xml [x]))))
               v.service_configurations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("service_configurations",
               (ServiceConfigurationSet.to_json v.service_configurations))])
    let of_json j =
      {
        service_configurations =
          (ServiceConfigurationSet.of_json
             (Util.of_option_exn (Json.lookup j "service_configurations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateFpgaImageRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      input_storage_location: StorageLocation.t ;
      logs_storage_location: StorageLocation.t option ;
      description: String.t option ;
      name: String.t option ;
      client_token: String.t option ;
      tag_specifications: TagSpecificationList.t }
    let make ?dry_run  ~input_storage_location  ?logs_storage_location 
      ?description  ?name  ?client_token  ?(tag_specifications= [])  () =
      {
        dry_run;
        input_storage_location;
        logs_storage_location;
        description;
        name;
        client_token;
        tag_specifications
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          input_storage_location =
            (Xml.required "InputStorageLocation"
               (Util.option_bind (Xml.member "InputStorageLocation" xml)
                  StorageLocation.parse));
          logs_storage_location =
            (Util.option_bind (Xml.member "LogsStorageLocation" xml)
               StorageLocation.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.logs_storage_location
             (fun f ->
                Query.Pair
                  ("LogsStorageLocation", (StorageLocation.to_query f)));
           Some
             (Query.Pair
                ("InputStorageLocation",
                  (StorageLocation.to_query v.input_storage_location)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.dry_run
                    (fun f ->
                       Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
                @
                [Some
                   (Ezxmlm.make_tag "InputStorageLocation"
                      ([], (StorageLocation.to_xml v.input_storage_location)))])
               @
               [Util.option_map v.logs_storage_location
                  (fun f ->
                     Ezxmlm.make_tag "LogsStorageLocation"
                       ([], (StorageLocation.to_xml f)))])
              @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
             @
             [Util.option_map v.name
                (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
            @
            [Util.option_map v.client_token
               (fun f ->
                  Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "TagSpecification"
                      ([], (TagSpecificationList.to_xml [x]))))
              v.tag_specifications))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.logs_storage_location
             (fun f -> ("logs_storage_location", (StorageLocation.to_json f)));
           Some
             ("input_storage_location",
               (StorageLocation.to_json v.input_storage_location));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        input_storage_location =
          (StorageLocation.of_json
             (Util.of_option_exn (Json.lookup j "input_storage_location")));
        logs_storage_location =
          (Util.option_map (Json.lookup j "logs_storage_location")
             StorageLocation.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module DescribeBundleTasksRequest =
  struct
    type t =
      {
      bundle_ids: BundleIdStringList.t ;
      filters: FilterList.t ;
      dry_run: Boolean.t option }
    let make ?(bundle_ids= [])  ?(filters= [])  ?dry_run  () =
      { bundle_ids; filters; dry_run }
    let parse xml =
      Some
        {
          bundle_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "BundleId" xml)
                  BundleIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("BundleId", (BundleIdStringList.to_query v.bundle_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "BundleId"
                        ([], (BundleIdStringList.to_xml [x])))) v.bundle_ids))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
               v.filters))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("bundle_ids", (BundleIdStringList.to_json v.bundle_ids))])
    let of_json j =
      {
        bundle_ids =
          (BundleIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "bundle_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeConversionTasksResult =
  struct
    type t = {
      conversion_tasks: DescribeConversionTaskList.t }
    let make ?(conversion_tasks= [])  () = { conversion_tasks }
    let parse xml =
      Some
        {
          conversion_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "conversionTasks" xml)
                  DescribeConversionTaskList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ConversionTasks",
                   (DescribeConversionTaskList.to_query v.conversion_tasks)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "conversionTasks"
                      ([], (DescribeConversionTaskList.to_xml [x]))))
              v.conversion_tasks))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("conversion_tasks",
                (DescribeConversionTaskList.to_json v.conversion_tasks))])
    let of_json j =
      {
        conversion_tasks =
          (DescribeConversionTaskList.of_json
             (Util.of_option_exn (Json.lookup j "conversion_tasks")))
      }
  end
module DescribeLocalGatewayRouteTablesRequest =
  struct
    type t =
      {
      local_gateway_route_table_ids: LocalGatewayRouteTableIdSet.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(local_gateway_route_table_ids= [])  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        local_gateway_route_table_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          local_gateway_route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "LocalGatewayRouteTableId" xml)
                  LocalGatewayRouteTableIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableId",
                  (LocalGatewayRouteTableIdSet.to_query
                     v.local_gateway_route_table_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "LocalGatewayRouteTableId"
                          ([], (LocalGatewayRouteTableIdSet.to_xml [x]))))
                  v.local_gateway_route_table_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("local_gateway_route_table_ids",
               (LocalGatewayRouteTableIdSet.to_json
                  v.local_gateway_route_table_ids))])
    let of_json j =
      {
        local_gateway_route_table_ids =
          (LocalGatewayRouteTableIdSet.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_route_table_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateDefaultVpcRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeTransitGatewayVpcAttachmentsResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachments: TransitGatewayVpcAttachmentList.t ;
      next_token: String.t option }
    let make ?(transit_gateway_vpc_attachments= [])  ?next_token  () =
      { transit_gateway_vpc_attachments; next_token }
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachments =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "transitGatewayVpcAttachments" xml)
                  TransitGatewayVpcAttachmentList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayVpcAttachments",
                  (TransitGatewayVpcAttachmentList.to_query
                     v.transit_gateway_vpc_attachments)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "transitGatewayVpcAttachments"
                       ([], (TransitGatewayVpcAttachmentList.to_xml [x]))))
               v.transit_gateway_vpc_attachments))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_vpc_attachments",
               (TransitGatewayVpcAttachmentList.to_json
                  v.transit_gateway_vpc_attachments))])
    let of_json j =
      {
        transit_gateway_vpc_attachments =
          (TransitGatewayVpcAttachmentList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_vpc_attachments")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateInstanceExportTaskRequest =
  struct
    type t =
      {
      description: String.t option ;
      export_to_s3_task: ExportToS3TaskSpecification.t option ;
      instance_id: String.t ;
      target_environment: ExportEnvironment.t option }
    let make ?description  ?export_to_s3_task  ~instance_id 
      ?target_environment  () =
      { description; export_to_s3_task; instance_id; target_environment }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          export_to_s3_task =
            (Util.option_bind (Xml.member "exportToS3" xml)
               ExportToS3TaskSpecification.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          target_environment =
            (Util.option_bind (Xml.member "targetEnvironment" xml)
               ExportEnvironment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.target_environment
              (fun f ->
                 Query.Pair
                   ("TargetEnvironment", (ExportEnvironment.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.export_to_s3_task
             (fun f ->
                Query.Pair
                  ("ExportToS3", (ExportToS3TaskSpecification.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
             @
             [Util.option_map v.export_to_s3_task
                (fun f ->
                   Ezxmlm.make_tag "exportToS3"
                     ([], (ExportToS3TaskSpecification.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "instanceId"
                  ([], (String.to_xml v.instance_id)))])
           @
           [Util.option_map v.target_environment
              (fun f ->
                 Ezxmlm.make_tag "targetEnvironment"
                   ([], (ExportEnvironment.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_environment
              (fun f -> ("target_environment", (ExportEnvironment.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.export_to_s3_task
             (fun f ->
                ("export_to_s3_task",
                  (ExportToS3TaskSpecification.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        export_to_s3_task =
          (Util.option_map (Json.lookup j "export_to_s3_task")
             ExportToS3TaskSpecification.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        target_environment =
          (Util.option_map (Json.lookup j "target_environment")
             ExportEnvironment.of_json)
      }
  end
module GetReservedInstancesExchangeQuoteResult =
  struct
    type t =
      {
      currency_code: String.t option ;
      is_valid_exchange: Boolean.t option ;
      output_reserved_instances_will_expire_at: DateTime.t option ;
      payment_due: String.t option ;
      reserved_instance_value_rollup: ReservationValue.t option ;
      reserved_instance_value_set: ReservedInstanceReservationValueSet.t ;
      target_configuration_value_rollup: ReservationValue.t option ;
      target_configuration_value_set: TargetReservationValueSet.t ;
      validation_failure_reason: String.t option }
    let make ?currency_code  ?is_valid_exchange 
      ?output_reserved_instances_will_expire_at  ?payment_due 
      ?reserved_instance_value_rollup  ?(reserved_instance_value_set= []) 
      ?target_configuration_value_rollup  ?(target_configuration_value_set=
      [])  ?validation_failure_reason  () =
      {
        currency_code;
        is_valid_exchange;
        output_reserved_instances_will_expire_at;
        payment_due;
        reserved_instance_value_rollup;
        reserved_instance_value_set;
        target_configuration_value_rollup;
        target_configuration_value_set;
        validation_failure_reason
      }
    let parse xml =
      Some
        {
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml) String.parse);
          is_valid_exchange =
            (Util.option_bind (Xml.member "isValidExchange" xml)
               Boolean.parse);
          output_reserved_instances_will_expire_at =
            (Util.option_bind
               (Xml.member "outputReservedInstancesWillExpireAt" xml)
               DateTime.parse);
          payment_due =
            (Util.option_bind (Xml.member "paymentDue" xml) String.parse);
          reserved_instance_value_rollup =
            (Util.option_bind (Xml.member "reservedInstanceValueRollup" xml)
               ReservationValue.parse);
          reserved_instance_value_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "reservedInstanceValueSet" xml)
                  ReservedInstanceReservationValueSet.parse));
          target_configuration_value_rollup =
            (Util.option_bind
               (Xml.member "targetConfigurationValueRollup" xml)
               ReservationValue.parse);
          target_configuration_value_set =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "targetConfigurationValueSet" xml)
                  TargetReservationValueSet.parse));
          validation_failure_reason =
            (Util.option_bind (Xml.member "validationFailureReason" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.validation_failure_reason
              (fun f ->
                 Query.Pair ("ValidationFailureReason", (String.to_query f)));
           Some
             (Query.Pair
                ("TargetConfigurationValueSet",
                  (TargetReservationValueSet.to_query
                     v.target_configuration_value_set)));
           Util.option_map v.target_configuration_value_rollup
             (fun f ->
                Query.Pair
                  ("TargetConfigurationValueRollup",
                    (ReservationValue.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstanceValueSet",
                  (ReservedInstanceReservationValueSet.to_query
                     v.reserved_instance_value_set)));
           Util.option_map v.reserved_instance_value_rollup
             (fun f ->
                Query.Pair
                  ("ReservedInstanceValueRollup",
                    (ReservationValue.to_query f)));
           Util.option_map v.payment_due
             (fun f -> Query.Pair ("PaymentDue", (String.to_query f)));
           Util.option_map v.output_reserved_instances_will_expire_at
             (fun f ->
                Query.Pair
                  ("OutputReservedInstancesWillExpireAt",
                    (DateTime.to_query f)));
           Util.option_map v.is_valid_exchange
             (fun f -> Query.Pair ("IsValidExchange", (Boolean.to_query f)));
           Util.option_map v.currency_code
             (fun f -> Query.Pair ("CurrencyCode", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.currency_code
                      (fun f ->
                         Ezxmlm.make_tag "currencyCode"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.is_valid_exchange
                     (fun f ->
                        Ezxmlm.make_tag "isValidExchange"
                          ([], (Boolean.to_xml f)))])
                 @
                 [Util.option_map v.output_reserved_instances_will_expire_at
                    (fun f ->
                       Ezxmlm.make_tag "outputReservedInstancesWillExpireAt"
                         ([], (DateTime.to_xml f)))])
                @
                [Util.option_map v.payment_due
                   (fun f ->
                      Ezxmlm.make_tag "paymentDue" ([], (String.to_xml f)))])
               @
               [Util.option_map v.reserved_instance_value_rollup
                  (fun f ->
                     Ezxmlm.make_tag "reservedInstanceValueRollup"
                       ([], (ReservationValue.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "reservedInstanceValueSet"
                         ([],
                           (ReservedInstanceReservationValueSet.to_xml [x]))))
                 v.reserved_instance_value_set))
             @
             [Util.option_map v.target_configuration_value_rollup
                (fun f ->
                   Ezxmlm.make_tag "targetConfigurationValueRollup"
                     ([], (ReservationValue.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "targetConfigurationValueSet"
                       ([], (TargetReservationValueSet.to_xml [x]))))
               v.target_configuration_value_set))
           @
           [Util.option_map v.validation_failure_reason
              (fun f ->
                 Ezxmlm.make_tag "validationFailureReason"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.validation_failure_reason
              (fun f -> ("validation_failure_reason", (String.to_json f)));
           Some
             ("target_configuration_value_set",
               (TargetReservationValueSet.to_json
                  v.target_configuration_value_set));
           Util.option_map v.target_configuration_value_rollup
             (fun f ->
                ("target_configuration_value_rollup",
                  (ReservationValue.to_json f)));
           Some
             ("reserved_instance_value_set",
               (ReservedInstanceReservationValueSet.to_json
                  v.reserved_instance_value_set));
           Util.option_map v.reserved_instance_value_rollup
             (fun f ->
                ("reserved_instance_value_rollup",
                  (ReservationValue.to_json f)));
           Util.option_map v.payment_due
             (fun f -> ("payment_due", (String.to_json f)));
           Util.option_map v.output_reserved_instances_will_expire_at
             (fun f ->
                ("output_reserved_instances_will_expire_at",
                  (DateTime.to_json f)));
           Util.option_map v.is_valid_exchange
             (fun f -> ("is_valid_exchange", (Boolean.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (String.to_json f)))])
    let of_json j =
      {
        currency_code =
          (Util.option_map (Json.lookup j "currency_code") String.of_json);
        is_valid_exchange =
          (Util.option_map (Json.lookup j "is_valid_exchange")
             Boolean.of_json);
        output_reserved_instances_will_expire_at =
          (Util.option_map
             (Json.lookup j "output_reserved_instances_will_expire_at")
             DateTime.of_json);
        payment_due =
          (Util.option_map (Json.lookup j "payment_due") String.of_json);
        reserved_instance_value_rollup =
          (Util.option_map (Json.lookup j "reserved_instance_value_rollup")
             ReservationValue.of_json);
        reserved_instance_value_set =
          (ReservedInstanceReservationValueSet.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instance_value_set")));
        target_configuration_value_rollup =
          (Util.option_map
             (Json.lookup j "target_configuration_value_rollup")
             ReservationValue.of_json);
        target_configuration_value_set =
          (TargetReservationValueSet.of_json
             (Util.of_option_exn
                (Json.lookup j "target_configuration_value_set")));
        validation_failure_reason =
          (Util.option_map (Json.lookup j "validation_failure_reason")
             String.of_json)
      }
  end
module SearchTransitGatewayRoutesResult =
  struct
    type t =
      {
      routes: TransitGatewayRouteList.t ;
      additional_routes_available: Boolean.t option }
    let make ?(routes= [])  ?additional_routes_available  () =
      { routes; additional_routes_available }
    let parse xml =
      Some
        {
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeSet" xml)
                  TransitGatewayRouteList.parse));
          additional_routes_available =
            (Util.option_bind (Xml.member "additionalRoutesAvailable" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.additional_routes_available
              (fun f ->
                 Query.Pair
                   ("AdditionalRoutesAvailable", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("RouteSet", (TransitGatewayRouteList.to_query v.routes)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "routeSet"
                       ([], (TransitGatewayRouteList.to_xml [x])))) v.routes))
           @
           [Util.option_map v.additional_routes_available
              (fun f ->
                 Ezxmlm.make_tag "additionalRoutesAvailable"
                   ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.additional_routes_available
              (fun f -> ("additional_routes_available", (Boolean.to_json f)));
           Some ("routes", (TransitGatewayRouteList.to_json v.routes))])
    let of_json j =
      {
        routes =
          (TransitGatewayRouteList.of_json
             (Util.of_option_exn (Json.lookup j "routes")));
        additional_routes_available =
          (Util.option_map (Json.lookup j "additional_routes_available")
             Boolean.of_json)
      }
  end
module CreateSecurityGroupResult =
  struct
    type t = {
      group_id: String.t }
    let make ~group_id  () = { group_id }
    let parse xml =
      Some
        {
          group_id =
            (Xml.required "groupId"
               (Util.option_bind (Xml.member "groupId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("GroupId", (String.to_query v.group_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some (Ezxmlm.make_tag "groupId" ([], (String.to_xml v.group_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("group_id", (String.to_json v.group_id))])
    let of_json j =
      {
        group_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_id")))
      }
  end
module DescribeSpotFleetRequestHistoryResponse =
  struct
    type t =
      {
      history_records: HistoryRecords.t ;
      last_evaluated_time: DateTime.t option ;
      next_token: String.t option ;
      spot_fleet_request_id: String.t option ;
      start_time: DateTime.t option }
    let make ?(history_records= [])  ?last_evaluated_time  ?next_token 
      ?spot_fleet_request_id  ?start_time  () =
      {
        history_records;
        last_evaluated_time;
        next_token;
        spot_fleet_request_id;
        start_time
      }
    let parse xml =
      Some
        {
          history_records =
            (Util.of_option []
               (Util.option_bind (Xml.member "historyRecordSet" xml)
                  HistoryRecords.parse));
          last_evaluated_time =
            (Util.option_bind (Xml.member "lastEvaluatedTime" xml)
               DateTime.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse);
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.start_time
              (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Util.option_map v.spot_fleet_request_id
             (fun f -> Query.Pair ("SpotFleetRequestId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.last_evaluated_time
             (fun f ->
                Query.Pair ("LastEvaluatedTime", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("HistoryRecordSet",
                  (HistoryRecords.to_query v.history_records)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "historyRecordSet"
                          ([], (HistoryRecords.to_xml [x]))))
                  v.history_records))
              @
              [Util.option_map v.last_evaluated_time
                 (fun f ->
                    Ezxmlm.make_tag "lastEvaluatedTime"
                      ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
            @
            [Util.option_map v.spot_fleet_request_id
               (fun f ->
                  Ezxmlm.make_tag "spotFleetRequestId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.start_time
              (fun f -> Ezxmlm.make_tag "startTime" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.start_time
              (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.spot_fleet_request_id
             (fun f -> ("spot_fleet_request_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.last_evaluated_time
             (fun f -> ("last_evaluated_time", (DateTime.to_json f)));
           Some
             ("history_records", (HistoryRecords.to_json v.history_records))])
    let of_json j =
      {
        history_records =
          (HistoryRecords.of_json
             (Util.of_option_exn (Json.lookup j "history_records")));
        last_evaluated_time =
          (Util.option_map (Json.lookup j "last_evaluated_time")
             DateTime.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        spot_fleet_request_id =
          (Util.option_map (Json.lookup j "spot_fleet_request_id")
             String.of_json);
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json)
      }
  end
module CancelReservedInstancesListingRequest =
  struct
    type t = {
      reserved_instances_listing_id: String.t }
    let make ~reserved_instances_listing_id  () =
      { reserved_instances_listing_id }
    let parse xml =
      Some
        {
          reserved_instances_listing_id =
            (Xml.required "reservedInstancesListingId"
               (Util.option_bind
                  (Xml.member "reservedInstancesListingId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesListingId",
                   (String.to_query v.reserved_instances_listing_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "reservedInstancesListingId"
                 ([], (String.to_xml v.reserved_instances_listing_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_listing_id",
                (String.to_json v.reserved_instances_listing_id))])
    let of_json j =
      {
        reserved_instances_listing_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_listing_id")))
      }
  end
module DescribeFpgaImagesResult =
  struct
    type t = {
      fpga_images: FpgaImageList.t ;
      next_token: String.t option }
    let make ?(fpga_images= [])  ?next_token  () =
      { fpga_images; next_token }
    let parse xml =
      Some
        {
          fpga_images =
            (Util.of_option []
               (Util.option_bind (Xml.member "fpgaImageSet" xml)
                  FpgaImageList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("FpgaImageSet", (FpgaImageList.to_query v.fpga_images)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "fpgaImageSet"
                       ([], (FpgaImageList.to_xml [x])))) v.fpga_images))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("fpga_images", (FpgaImageList.to_json v.fpga_images))])
    let of_json j =
      {
        fpga_images =
          (FpgaImageList.of_json
             (Util.of_option_exn (Json.lookup j "fpga_images")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeSnapshotsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      owner_ids: OwnerStringList.t ;
      restorable_by_user_ids: RestorableByStringList.t ;
      snapshot_ids: SnapshotIdStringList.t ;
      dry_run: Boolean.t option }
    let make ?(filters= [])  ?max_results  ?next_token  ?(owner_ids= []) 
      ?(restorable_by_user_ids= [])  ?(snapshot_ids= [])  ?dry_run  () =
      {
        filters;
        max_results;
        next_token;
        owner_ids;
        restorable_by_user_ids;
        snapshot_ids;
        dry_run
      }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          owner_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "Owner" xml)
                  OwnerStringList.parse));
          restorable_by_user_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RestorableBy" xml)
                  RestorableByStringList.parse));
          snapshot_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SnapshotId" xml)
                  SnapshotIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SnapshotId",
                  (SnapshotIdStringList.to_query v.snapshot_ids)));
           Some
             (Query.Pair
                ("RestorableBy",
                  (RestorableByStringList.to_query v.restorable_by_user_ids)));
           Some
             (Query.Pair ("Owner", (OwnerStringList.to_query v.owner_ids)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "Filter"
                            ([], (FilterList.to_xml [x])))) v.filters))
                @
                [Util.option_map v.max_results
                   (fun f ->
                      Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.next_token
                  (fun f ->
                     Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Owner"
                         ([], (OwnerStringList.to_xml [x])))) v.owner_ids))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "RestorableBy"
                        ([], (RestorableByStringList.to_xml [x]))))
                v.restorable_by_user_ids))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "SnapshotId"
                       ([], (SnapshotIdStringList.to_xml [x]))))
               v.snapshot_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("snapshot_ids", (SnapshotIdStringList.to_json v.snapshot_ids));
           Some
             ("restorable_by_user_ids",
               (RestorableByStringList.to_json v.restorable_by_user_ids));
           Some ("owner_ids", (OwnerStringList.to_json v.owner_ids));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        owner_ids =
          (OwnerStringList.of_json
             (Util.of_option_exn (Json.lookup j "owner_ids")));
        restorable_by_user_ids =
          (RestorableByStringList.of_json
             (Util.of_option_exn (Json.lookup j "restorable_by_user_ids")));
        snapshot_ids =
          (SnapshotIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "snapshot_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyInstanceMetadataOptionsRequest =
  struct
    type t =
      {
      instance_id: String.t ;
      http_tokens: HttpTokensState.t option ;
      http_put_response_hop_limit: Integer.t option ;
      http_endpoint: InstanceMetadataEndpointState.t option ;
      dry_run: Boolean.t option }
    let make ~instance_id  ?http_tokens  ?http_put_response_hop_limit 
      ?http_endpoint  ?dry_run  () =
      {
        instance_id;
        http_tokens;
        http_put_response_hop_limit;
        http_endpoint;
        dry_run
      }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          http_tokens =
            (Util.option_bind (Xml.member "HttpTokens" xml)
               HttpTokensState.parse);
          http_put_response_hop_limit =
            (Util.option_bind (Xml.member "HttpPutResponseHopLimit" xml)
               Integer.parse);
          http_endpoint =
            (Util.option_bind (Xml.member "HttpEndpoint" xml)
               InstanceMetadataEndpointState.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.http_endpoint
             (fun f ->
                Query.Pair
                  ("HttpEndpoint",
                    (InstanceMetadataEndpointState.to_query f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f ->
                Query.Pair ("HttpPutResponseHopLimit", (Integer.to_query f)));
           Util.option_map v.http_tokens
             (fun f ->
                Query.Pair ("HttpTokens", (HttpTokensState.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "InstanceId"
                     ([], (String.to_xml v.instance_id)))])
              @
              [Util.option_map v.http_tokens
                 (fun f ->
                    Ezxmlm.make_tag "HttpTokens"
                      ([], (HttpTokensState.to_xml f)))])
             @
             [Util.option_map v.http_put_response_hop_limit
                (fun f ->
                   Ezxmlm.make_tag "HttpPutResponseHopLimit"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.http_endpoint
               (fun f ->
                  Ezxmlm.make_tag "HttpEndpoint"
                    ([], (InstanceMetadataEndpointState.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.http_endpoint
             (fun f ->
                ("http_endpoint", (InstanceMetadataEndpointState.to_json f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f -> ("http_put_response_hop_limit", (Integer.to_json f)));
           Util.option_map v.http_tokens
             (fun f -> ("http_tokens", (HttpTokensState.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        http_tokens =
          (Util.option_map (Json.lookup j "http_tokens")
             HttpTokensState.of_json);
        http_put_response_hop_limit =
          (Util.option_map (Json.lookup j "http_put_response_hop_limit")
             Integer.of_json);
        http_endpoint =
          (Util.option_map (Json.lookup j "http_endpoint")
             InstanceMetadataEndpointState.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ReplaceNetworkAclEntryRequest =
  struct
    type t =
      {
      cidr_block: String.t option ;
      dry_run: Boolean.t option ;
      egress: Boolean.t ;
      icmp_type_code: IcmpTypeCode.t option ;
      ipv6_cidr_block: String.t option ;
      network_acl_id: String.t ;
      port_range: PortRange.t option ;
      protocol: String.t ;
      rule_action: RuleAction.t ;
      rule_number: Integer.t }
    let make ?cidr_block  ?dry_run  ~egress  ?icmp_type_code 
      ?ipv6_cidr_block  ~network_acl_id  ?port_range  ~protocol  ~rule_action
       ~rule_number  () =
      {
        cidr_block;
        dry_run;
        egress;
        icmp_type_code;
        ipv6_cidr_block;
        network_acl_id;
        port_range;
        protocol;
        rule_action;
        rule_number
      }
    let parse xml =
      Some
        {
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          egress =
            (Xml.required "egress"
               (Util.option_bind (Xml.member "egress" xml) Boolean.parse));
          icmp_type_code =
            (Util.option_bind (Xml.member "Icmp" xml) IcmpTypeCode.parse);
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "ipv6CidrBlock" xml) String.parse);
          network_acl_id =
            (Xml.required "networkAclId"
               (Util.option_bind (Xml.member "networkAclId" xml) String.parse));
          port_range =
            (Util.option_bind (Xml.member "portRange" xml) PortRange.parse);
          protocol =
            (Xml.required "protocol"
               (Util.option_bind (Xml.member "protocol" xml) String.parse));
          rule_action =
            (Xml.required "ruleAction"
               (Util.option_bind (Xml.member "ruleAction" xml)
                  RuleAction.parse));
          rule_number =
            (Xml.required "ruleNumber"
               (Util.option_bind (Xml.member "ruleNumber" xml) Integer.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("RuleNumber", (Integer.to_query v.rule_number)));
           Some
             (Query.Pair ("RuleAction", (RuleAction.to_query v.rule_action)));
           Some (Query.Pair ("Protocol", (String.to_query v.protocol)));
           Util.option_map v.port_range
             (fun f -> Query.Pair ("PortRange", (PortRange.to_query f)));
           Some
             (Query.Pair ("NetworkAclId", (String.to_query v.network_acl_id)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Util.option_map v.icmp_type_code
             (fun f -> Query.Pair ("Icmp", (IcmpTypeCode.to_query f)));
           Some (Query.Pair ("Egress", (Boolean.to_query v.egress)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.cidr_block
                       (fun f ->
                          Ezxmlm.make_tag "cidrBlock" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.dry_run
                      (fun f ->
                         Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "egress"
                        ([], (Boolean.to_xml v.egress)))])
                 @
                 [Util.option_map v.icmp_type_code
                    (fun f ->
                       Ezxmlm.make_tag "Icmp" ([], (IcmpTypeCode.to_xml f)))])
                @
                [Util.option_map v.ipv6_cidr_block
                   (fun f ->
                      Ezxmlm.make_tag "ipv6CidrBlock" ([], (String.to_xml f)))])
               @
               [Some
                  (Ezxmlm.make_tag "networkAclId"
                     ([], (String.to_xml v.network_acl_id)))])
              @
              [Util.option_map v.port_range
                 (fun f ->
                    Ezxmlm.make_tag "portRange" ([], (PortRange.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "protocol" ([], (String.to_xml v.protocol)))])
            @
            [Some
               (Ezxmlm.make_tag "ruleAction"
                  ([], (RuleAction.to_xml v.rule_action)))])
           @
           [Some
              (Ezxmlm.make_tag "ruleNumber"
                 ([], (Integer.to_xml v.rule_number)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("rule_number", (Integer.to_json v.rule_number));
           Some ("rule_action", (RuleAction.to_json v.rule_action));
           Some ("protocol", (String.to_json v.protocol));
           Util.option_map v.port_range
             (fun f -> ("port_range", (PortRange.to_json f)));
           Some ("network_acl_id", (String.to_json v.network_acl_id));
           Util.option_map v.ipv6_cidr_block
             (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.icmp_type_code
             (fun f -> ("icmp_type_code", (IcmpTypeCode.to_json f)));
           Some ("egress", (Boolean.to_json v.egress));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)))])
    let of_json j =
      {
        cidr_block =
          (Util.option_map (Json.lookup j "cidr_block") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        egress =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "egress")));
        icmp_type_code =
          (Util.option_map (Json.lookup j "icmp_type_code")
             IcmpTypeCode.of_json);
        ipv6_cidr_block =
          (Util.option_map (Json.lookup j "ipv6_cidr_block") String.of_json);
        network_acl_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_id")));
        port_range =
          (Util.option_map (Json.lookup j "port_range") PortRange.of_json);
        protocol =
          (String.of_json (Util.of_option_exn (Json.lookup j "protocol")));
        rule_action =
          (RuleAction.of_json
             (Util.of_option_exn (Json.lookup j "rule_action")));
        rule_number =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "rule_number")))
      }
  end
module UnassignIpv6AddressesResult =
  struct
    type t =
      {
      network_interface_id: String.t option ;
      unassigned_ipv6_addresses: Ipv6AddressList.t }
    let make ?network_interface_id  ?(unassigned_ipv6_addresses= [])  () =
      { network_interface_id; unassigned_ipv6_addresses }
    let parse xml =
      Some
        {
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          unassigned_ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "unassignedIpv6Addresses" xml)
                  Ipv6AddressList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnassignedIpv6Addresses",
                   (Ipv6AddressList.to_query v.unassigned_ipv6_addresses)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.network_interface_id
               (fun f ->
                  Ezxmlm.make_tag "networkInterfaceId"
                    ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unassignedIpv6Addresses"
                      ([], (Ipv6AddressList.to_xml [x]))))
              v.unassigned_ipv6_addresses))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unassigned_ipv6_addresses",
                (Ipv6AddressList.to_json v.unassigned_ipv6_addresses));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)))])
    let of_json j =
      {
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        unassigned_ipv6_addresses =
          (Ipv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "unassigned_ipv6_addresses")))
      }
  end
module DescribeFlowLogsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filter: FilterList.t ;
      flow_log_ids: ValueStringList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(filter= [])  ?(flow_log_ids= [])  ?max_results 
      ?next_token  () =
      { dry_run; filter; flow_log_ids; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filter =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          flow_log_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "FlowLogId" xml)
                  ValueStringList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("FlowLogId", (ValueStringList.to_query v.flow_log_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filter)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filter))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "FlowLogId"
                        ([], (ValueStringList.to_xml [x])))) v.flow_log_ids))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("flow_log_ids", (ValueStringList.to_json v.flow_log_ids));
           Some ("filter", (FilterList.to_json v.filter));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filter =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filter")));
        flow_log_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "flow_log_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module EnableFastSnapshotRestoresResult =
  struct
    type t =
      {
      successful: EnableFastSnapshotRestoreSuccessSet.t ;
      unsuccessful: EnableFastSnapshotRestoreErrorSet.t }
    let make ?(successful= [])  ?(unsuccessful= [])  () =
      { successful; unsuccessful }
    let parse xml =
      Some
        {
          successful =
            (Util.of_option []
               (Util.option_bind (Xml.member "successful" xml)
                  EnableFastSnapshotRestoreSuccessSet.parse));
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  EnableFastSnapshotRestoreErrorSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (EnableFastSnapshotRestoreErrorSet.to_query v.unsuccessful)));
           Some
             (Query.Pair
                ("Successful",
                  (EnableFastSnapshotRestoreSuccessSet.to_query v.successful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "successful"
                       ([], (EnableFastSnapshotRestoreSuccessSet.to_xml [x]))))
               v.successful))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (EnableFastSnapshotRestoreErrorSet.to_xml [x]))))
              v.unsuccessful))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful",
                (EnableFastSnapshotRestoreErrorSet.to_json v.unsuccessful));
           Some
             ("successful",
               (EnableFastSnapshotRestoreSuccessSet.to_json v.successful))])
    let of_json j =
      {
        successful =
          (EnableFastSnapshotRestoreSuccessSet.of_json
             (Util.of_option_exn (Json.lookup j "successful")));
        unsuccessful =
          (EnableFastSnapshotRestoreErrorSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module AssignPrivateIpAddressesRequest =
  struct
    type t =
      {
      allow_reassignment: Boolean.t option ;
      network_interface_id: String.t ;
      private_ip_addresses: PrivateIpAddressStringList.t ;
      secondary_private_ip_address_count: Integer.t option }
    let make ?allow_reassignment  ~network_interface_id 
      ?(private_ip_addresses= [])  ?secondary_private_ip_address_count  () =
      {
        allow_reassignment;
        network_interface_id;
        private_ip_addresses;
        secondary_private_ip_address_count
      }
    let parse xml =
      Some
        {
          allow_reassignment =
            (Util.option_bind (Xml.member "allowReassignment" xml)
               Boolean.parse);
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse));
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddress" xml)
                  PrivateIpAddressStringList.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "secondaryPrivateIpAddressCount" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.secondary_private_ip_address_count
              (fun f ->
                 Query.Pair
                   ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddress",
                  (PrivateIpAddressStringList.to_query v.private_ip_addresses)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)));
           Util.option_map v.allow_reassignment
             (fun f -> Query.Pair ("AllowReassignment", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.allow_reassignment
                 (fun f ->
                    Ezxmlm.make_tag "allowReassignment"
                      ([], (Boolean.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "networkInterfaceId"
                   ([], (String.to_xml v.network_interface_id)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "privateIpAddress"
                       ([], (PrivateIpAddressStringList.to_xml [x]))))
               v.private_ip_addresses))
           @
           [Util.option_map v.secondary_private_ip_address_count
              (fun f ->
                 Ezxmlm.make_tag "secondaryPrivateIpAddressCount"
                   ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.secondary_private_ip_address_count
              (fun f ->
                 ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_addresses",
               (PrivateIpAddressStringList.to_json v.private_ip_addresses));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id));
           Util.option_map v.allow_reassignment
             (fun f -> ("allow_reassignment", (Boolean.to_json f)))])
    let of_json j =
      {
        allow_reassignment =
          (Util.option_map (Json.lookup j "allow_reassignment")
             Boolean.of_json);
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        private_ip_addresses =
          (PrivateIpAddressStringList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        secondary_private_ip_address_count =
          (Util.option_map
             (Json.lookup j "secondary_private_ip_address_count")
             Integer.of_json)
      }
  end
module EnableTransitGatewayRouteTablePropagationRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ~transit_gateway_attachment_id 
      ?dry_run  () =
      {
        transit_gateway_route_table_id;
        transit_gateway_attachment_id;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "TransitGatewayRouteTableId"
                   ([], (String.to_xml v.transit_gateway_route_table_id)))])
            @
            [Some
               (Ezxmlm.make_tag "TransitGatewayAttachmentId"
                  ([], (String.to_xml v.transit_gateway_attachment_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module RunScheduledInstancesResult =
  struct
    type t = {
      instance_id_set: InstanceIdSet.t }
    let make ?(instance_id_set= [])  () = { instance_id_set }
    let parse xml =
      Some
        {
          instance_id_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceIdSet" xml)
                  InstanceIdSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstanceIdSet",
                   (InstanceIdSet.to_query v.instance_id_set)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "instanceIdSet"
                      ([], (InstanceIdSet.to_xml [x])))) v.instance_id_set))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_id_set", (InstanceIdSet.to_json v.instance_id_set))])
    let of_json j =
      {
        instance_id_set =
          (InstanceIdSet.of_json
             (Util.of_option_exn (Json.lookup j "instance_id_set")))
      }
  end
module DescribeStaleSecurityGroupsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      vpc_id: String.t }
    let make ?dry_run  ?max_results  ?next_token  ~vpc_id  () =
      { dry_run; max_results; next_token; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @ [Some (Ezxmlm.make_tag "VpcId" ([], (String.to_xml v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DescribeRouteTablesResult =
  struct
    type t = {
      route_tables: RouteTableList.t ;
      next_token: String.t option }
    let make ?(route_tables= [])  ?next_token  () =
      { route_tables; next_token }
    let parse xml =
      Some
        {
          route_tables =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeTableSet" xml)
                  RouteTableList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("RouteTableSet", (RouteTableList.to_query v.route_tables)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "routeTableSet"
                       ([], (RouteTableList.to_xml [x])))) v.route_tables))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("route_tables", (RouteTableList.to_json v.route_tables))])
    let of_json j =
      {
        route_tables =
          (RouteTableList.of_json
             (Util.of_option_exn (Json.lookup j "route_tables")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeSpotDatafeedSubscriptionRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeSnapshotAttributeResult =
  struct
    type t =
      {
      create_volume_permissions: CreateVolumePermissionList.t ;
      product_codes: ProductCodeList.t ;
      snapshot_id: String.t option }
    let make ?(create_volume_permissions= [])  ?(product_codes= []) 
      ?snapshot_id  () =
      { create_volume_permissions; product_codes; snapshot_id }
    let parse xml =
      Some
        {
          create_volume_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "createVolumePermission" xml)
                  CreateVolumePermissionList.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.snapshot_id
              (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Some
             (Query.Pair
                ("CreateVolumePermission",
                  (CreateVolumePermissionList.to_query
                     v.create_volume_permissions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "createVolumePermission"
                        ([], (CreateVolumePermissionList.to_xml [x]))))
                v.create_volume_permissions))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "productCodes"
                       ([], (ProductCodeList.to_xml [x])))) v.product_codes))
           @
           [Util.option_map v.snapshot_id
              (fun f -> Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.snapshot_id
              (fun f -> ("snapshot_id", (String.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Some
             ("create_volume_permissions",
               (CreateVolumePermissionList.to_json
                  v.create_volume_permissions))])
    let of_json j =
      {
        create_volume_permissions =
          (CreateVolumePermissionList.of_json
             (Util.of_option_exn (Json.lookup j "create_volume_permissions")));
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json)
      }
  end
module WithdrawByoipCidrResult =
  struct
    type t = {
      byoip_cidr: ByoipCidr.t option }
    let make ?byoip_cidr  () = { byoip_cidr }
    let parse xml =
      Some
        {
          byoip_cidr =
            (Util.option_bind (Xml.member "byoipCidr" xml) ByoipCidr.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> Query.Pair ("ByoipCidr", (ByoipCidr.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.byoip_cidr
              (fun f ->
                 Ezxmlm.make_tag "byoipCidr" ([], (ByoipCidr.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> ("byoip_cidr", (ByoipCidr.to_json f)))])
    let of_json j =
      {
        byoip_cidr =
          (Util.option_map (Json.lookup j "byoip_cidr") ByoipCidr.of_json)
      }
  end
module DeleteTransitGatewayResult =
  struct
    type t = {
      transit_gateway: TransitGateway.t option }
    let make ?transit_gateway  () = { transit_gateway }
    let parse xml =
      Some
        {
          transit_gateway =
            (Util.option_bind (Xml.member "transitGateway" xml)
               TransitGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway
              (fun f ->
                 Query.Pair ("TransitGateway", (TransitGateway.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway
              (fun f ->
                 Ezxmlm.make_tag "transitGateway"
                   ([], (TransitGateway.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway
              (fun f -> ("transit_gateway", (TransitGateway.to_json f)))])
    let of_json j =
      {
        transit_gateway =
          (Util.option_map (Json.lookup j "transit_gateway")
             TransitGateway.of_json)
      }
  end
module DisassociateSubnetCidrBlockResult =
  struct
    type t =
      {
      ipv6_cidr_block_association: SubnetIpv6CidrBlockAssociation.t option ;
      subnet_id: String.t option }
    let make ?ipv6_cidr_block_association  ?subnet_id  () =
      { ipv6_cidr_block_association; subnet_id }
    let parse xml =
      Some
        {
          ipv6_cidr_block_association =
            (Util.option_bind (Xml.member "ipv6CidrBlockAssociation" xml)
               SubnetIpv6CidrBlockAssociation.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockAssociation",
                    (SubnetIpv6CidrBlockAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.ipv6_cidr_block_association
               (fun f ->
                  Ezxmlm.make_tag "ipv6CidrBlockAssociation"
                    ([], (SubnetIpv6CidrBlockAssociation.to_xml f)))])
           @
           [Util.option_map v.subnet_id
              (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                ("ipv6_cidr_block_association",
                  (SubnetIpv6CidrBlockAssociation.to_json f)))])
    let of_json j =
      {
        ipv6_cidr_block_association =
          (Util.option_map (Json.lookup j "ipv6_cidr_block_association")
             SubnetIpv6CidrBlockAssociation.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json)
      }
  end
module ModifyVpcEndpointConnectionNotificationResult =
  struct
    type t = {
      return_value: Boolean.t option }
    let make ?return_value  () = { return_value }
    let parse xml =
      Some
        {
          return_value =
            (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return_value
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> ("return_value", (Boolean.to_json f)))])
    let of_json j =
      {
        return_value =
          (Util.option_map (Json.lookup j "return_value") Boolean.of_json)
      }
  end
module DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest =
  struct
    type t =
      {
      local_gateway_route_table_virtual_interface_group_association_ids:
        LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make
      ?(local_gateway_route_table_virtual_interface_group_association_ids=
      [])  ?(filters= [])  ?max_results  ?next_token  ?dry_run  () =
      {
        local_gateway_route_table_virtual_interface_group_association_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          local_gateway_route_table_virtual_interface_group_association_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member
                     "LocalGatewayRouteTableVirtualInterfaceGroupAssociationId"
                     xml)
                  LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableVirtualInterfaceGroupAssociationId",
                  (LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet.to_query
                     v.local_gateway_route_table_virtual_interface_group_association_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag
                          "LocalGatewayRouteTableVirtualInterfaceGroupAssociationId"
                          ([],
                            (LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet.to_xml
                               [x]))))
                  v.local_gateway_route_table_virtual_interface_group_association_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("local_gateway_route_table_virtual_interface_group_association_ids",
               (LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet.to_json
                  v.local_gateway_route_table_virtual_interface_group_association_ids))])
    let of_json j =
      {
        local_gateway_route_table_virtual_interface_group_association_ids =
          (LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet.of_json
             (Util.of_option_exn
                (Json.lookup j
                   "local_gateway_route_table_virtual_interface_group_association_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ReleaseHostsResult =
  struct
    type t =
      {
      successful: ResponseHostIdList.t ;
      unsuccessful: UnsuccessfulItemList.t }
    let make ?(successful= [])  ?(unsuccessful= [])  () =
      { successful; unsuccessful }
    let parse xml =
      Some
        {
          successful =
            (Util.of_option []
               (Util.option_bind (Xml.member "successful" xml)
                  ResponseHostIdList.parse));
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemList.to_query v.unsuccessful)));
           Some
             (Query.Pair
                ("Successful", (ResponseHostIdList.to_query v.successful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "successful"
                       ([], (ResponseHostIdList.to_xml [x])))) v.successful))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemList.to_xml [x]))))
              v.unsuccessful))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemList.to_json v.unsuccessful));
           Some ("successful", (ResponseHostIdList.to_json v.successful))])
    let of_json j =
      {
        successful =
          (ResponseHostIdList.of_json
             (Util.of_option_exn (Json.lookup j "successful")));
        unsuccessful =
          (UnsuccessfulItemList.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module EnableVpcClassicLinkResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module CreateDefaultSubnetRequest =
  struct
    type t = {
      availability_zone: String.t ;
      dry_run: Boolean.t option }
    let make ~availability_zone  ?dry_run  () =
      { availability_zone; dry_run }
    let parse xml =
      Some
        {
          availability_zone =
            (Xml.required "AvailabilityZone"
               (Util.option_bind (Xml.member "AvailabilityZone" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "AvailabilityZone"
                  ([], (String.to_xml v.availability_zone)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("availability_zone", (String.to_json v.availability_zone))])
    let of_json j =
      {
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateNetworkInterfacePermissionRequest =
  struct
    type t =
      {
      network_interface_id: String.t ;
      aws_account_id: String.t option ;
      aws_service: String.t option ;
      permission: InterfacePermissionType.t ;
      dry_run: Boolean.t option }
    let make ~network_interface_id  ?aws_account_id  ?aws_service 
      ~permission  ?dry_run  () =
      {
        network_interface_id;
        aws_account_id;
        aws_service;
        permission;
        dry_run
      }
    let parse xml =
      Some
        {
          network_interface_id =
            (Xml.required "NetworkInterfaceId"
               (Util.option_bind (Xml.member "NetworkInterfaceId" xml)
                  String.parse));
          aws_account_id =
            (Util.option_bind (Xml.member "AwsAccountId" xml) String.parse);
          aws_service =
            (Util.option_bind (Xml.member "AwsService" xml) String.parse);
          permission =
            (Xml.required "Permission"
               (Util.option_bind (Xml.member "Permission" xml)
                  InterfacePermissionType.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("Permission",
                  (InterfacePermissionType.to_query v.permission)));
           Util.option_map v.aws_service
             (fun f -> Query.Pair ("AwsService", (String.to_query f)));
           Util.option_map v.aws_account_id
             (fun f -> Query.Pair ("AwsAccountId", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "NetworkInterfaceId"
                     ([], (String.to_xml v.network_interface_id)))])
              @
              [Util.option_map v.aws_account_id
                 (fun f ->
                    Ezxmlm.make_tag "AwsAccountId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.aws_service
                (fun f ->
                   Ezxmlm.make_tag "AwsService" ([], (String.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "Permission"
                  ([], (InterfacePermissionType.to_xml v.permission)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("permission", (InterfacePermissionType.to_json v.permission));
           Util.option_map v.aws_service
             (fun f -> ("aws_service", (String.to_json f)));
           Util.option_map v.aws_account_id
             (fun f -> ("aws_account_id", (String.to_json f)));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id))])
    let of_json j =
      {
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        aws_account_id =
          (Util.option_map (Json.lookup j "aws_account_id") String.of_json);
        aws_service =
          (Util.option_map (Json.lookup j "aws_service") String.of_json);
        permission =
          (InterfacePermissionType.of_json
             (Util.of_option_exn (Json.lookup j "permission")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module PurchaseReservedInstancesOfferingResult =
  struct
    type t = {
      reserved_instances_id: String.t option }
    let make ?reserved_instances_id  () = { reserved_instances_id }
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Ezxmlm.make_tag "reservedInstancesId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json)
      }
  end
module ModifyVpcAttributeRequest =
  struct
    type t =
      {
      enable_dns_hostnames: AttributeBooleanValue.t option ;
      enable_dns_support: AttributeBooleanValue.t option ;
      vpc_id: String.t }
    let make ?enable_dns_hostnames  ?enable_dns_support  ~vpc_id  () =
      { enable_dns_hostnames; enable_dns_support; vpc_id }
    let parse xml =
      Some
        {
          enable_dns_hostnames =
            (Util.option_bind (Xml.member "EnableDnsHostnames" xml)
               AttributeBooleanValue.parse);
          enable_dns_support =
            (Util.option_bind (Xml.member "EnableDnsSupport" xml)
               AttributeBooleanValue.parse);
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.enable_dns_support
             (fun f ->
                Query.Pair
                  ("EnableDnsSupport", (AttributeBooleanValue.to_query f)));
           Util.option_map v.enable_dns_hostnames
             (fun f ->
                Query.Pair
                  ("EnableDnsHostnames", (AttributeBooleanValue.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.enable_dns_hostnames
                (fun f ->
                   Ezxmlm.make_tag "EnableDnsHostnames"
                     ([], (AttributeBooleanValue.to_xml f)))])
            @
            [Util.option_map v.enable_dns_support
               (fun f ->
                  Ezxmlm.make_tag "EnableDnsSupport"
                    ([], (AttributeBooleanValue.to_xml f)))])
           @ [Some (Ezxmlm.make_tag "vpcId" ([], (String.to_xml v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.enable_dns_support
             (fun f ->
                ("enable_dns_support", (AttributeBooleanValue.to_json f)));
           Util.option_map v.enable_dns_hostnames
             (fun f ->
                ("enable_dns_hostnames", (AttributeBooleanValue.to_json f)))])
    let of_json j =
      {
        enable_dns_hostnames =
          (Util.option_map (Json.lookup j "enable_dns_hostnames")
             AttributeBooleanValue.of_json);
        enable_dns_support =
          (Util.option_map (Json.lookup j "enable_dns_support")
             AttributeBooleanValue.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module RejectVpcPeeringConnectionResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DescribeIamInstanceProfileAssociationsResult =
  struct
    type t =
      {
      iam_instance_profile_associations: IamInstanceProfileAssociationSet.t ;
      next_token: String.t option }
    let make ?(iam_instance_profile_associations= [])  ?next_token  () =
      { iam_instance_profile_associations; next_token }
    let parse xml =
      Some
        {
          iam_instance_profile_associations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "iamInstanceProfileAssociationSet" xml)
                  IamInstanceProfileAssociationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("IamInstanceProfileAssociationSet",
                  (IamInstanceProfileAssociationSet.to_query
                     v.iam_instance_profile_associations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "iamInstanceProfileAssociationSet"
                       ([], (IamInstanceProfileAssociationSet.to_xml [x]))))
               v.iam_instance_profile_associations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("iam_instance_profile_associations",
               (IamInstanceProfileAssociationSet.to_json
                  v.iam_instance_profile_associations))])
    let of_json j =
      {
        iam_instance_profile_associations =
          (IamInstanceProfileAssociationSet.of_json
             (Util.of_option_exn
                (Json.lookup j "iam_instance_profile_associations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyVpcEndpointResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module TerminateInstancesRequest =
  struct
    type t =
      {
      instance_ids: InstanceIdStringList.t ;
      dry_run: Boolean.t option }
    let make ~instance_ids  ?dry_run  () = { instance_ids; dry_run }
    let parse xml =
      Some
        {
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "InstanceId"
                       ([], (InstanceIdStringList.to_xml [x]))))
               v.instance_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids))])
    let of_json j =
      {
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateRouteResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DeleteVpcEndpointsResult =
  struct
    type t = {
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemSet.to_xml [x])))) v.unsuccessful))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let of_json j =
      {
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module DescribeLaunchTemplateVersionsResult =
  struct
    type t =
      {
      launch_template_versions: LaunchTemplateVersionSet.t ;
      next_token: String.t option }
    let make ?(launch_template_versions= [])  ?next_token  () =
      { launch_template_versions; next_token }
    let parse xml =
      Some
        {
          launch_template_versions =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchTemplateVersionSet" xml)
                  LaunchTemplateVersionSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LaunchTemplateVersionSet",
                  (LaunchTemplateVersionSet.to_query
                     v.launch_template_versions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "launchTemplateVersionSet"
                       ([], (LaunchTemplateVersionSet.to_xml [x]))))
               v.launch_template_versions))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("launch_template_versions",
               (LaunchTemplateVersionSet.to_json v.launch_template_versions))])
    let of_json j =
      {
        launch_template_versions =
          (LaunchTemplateVersionSet.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_versions")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateVpcEndpointRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_endpoint_type: VpcEndpointType.t option ;
      vpc_id: String.t ;
      service_name: String.t ;
      policy_document: String.t option ;
      route_table_ids: ValueStringList.t ;
      subnet_ids: ValueStringList.t ;
      security_group_ids: ValueStringList.t ;
      client_token: String.t option ;
      private_dns_enabled: Boolean.t option }
    let make ?dry_run  ?vpc_endpoint_type  ~vpc_id  ~service_name 
      ?policy_document  ?(route_table_ids= [])  ?(subnet_ids= []) 
      ?(security_group_ids= [])  ?client_token  ?private_dns_enabled  () =
      {
        dry_run;
        vpc_endpoint_type;
        vpc_id;
        service_name;
        policy_document;
        route_table_ids;
        subnet_ids;
        security_group_ids;
        client_token;
        private_dns_enabled
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          vpc_endpoint_type =
            (Util.option_bind (Xml.member "VpcEndpointType" xml)
               VpcEndpointType.parse);
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          service_name =
            (Xml.required "ServiceName"
               (Util.option_bind (Xml.member "ServiceName" xml) String.parse));
          policy_document =
            (Util.option_bind (Xml.member "PolicyDocument" xml) String.parse);
          route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RouteTableId" xml)
                  ValueStringList.parse));
          subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SubnetId" xml)
                  ValueStringList.parse));
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  ValueStringList.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          private_dns_enabled =
            (Util.option_bind (Xml.member "PrivateDnsEnabled" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_dns_enabled
              (fun f ->
                 Query.Pair ("PrivateDnsEnabled", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (ValueStringList.to_query v.security_group_ids)));
           Some
             (Query.Pair
                ("SubnetId", (ValueStringList.to_query v.subnet_ids)));
           Some
             (Query.Pair
                ("RouteTableId",
                  (ValueStringList.to_query v.route_table_ids)));
           Util.option_map v.policy_document
             (fun f -> Query.Pair ("PolicyDocument", (String.to_query f)));
           Some
             (Query.Pair ("ServiceName", (String.to_query v.service_name)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.vpc_endpoint_type
             (fun f ->
                Query.Pair ("VpcEndpointType", (VpcEndpointType.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.dry_run
                       (fun f ->
                          Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
                   @
                   [Util.option_map v.vpc_endpoint_type
                      (fun f ->
                         Ezxmlm.make_tag "VpcEndpointType"
                           ([], (VpcEndpointType.to_xml f)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "VpcId" ([], (String.to_xml v.vpc_id)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "ServiceName"
                       ([], (String.to_xml v.service_name)))])
                @
                [Util.option_map v.policy_document
                   (fun f ->
                      Ezxmlm.make_tag "PolicyDocument"
                        ([], (String.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "RouteTableId"
                          ([], (ValueStringList.to_xml [x]))))
                  v.route_table_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "SubnetId"
                         ([], (ValueStringList.to_xml [x])))) v.subnet_ids))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "SecurityGroupId"
                        ([], (ValueStringList.to_xml [x]))))
                v.security_group_ids))
            @
            [Util.option_map v.client_token
               (fun f ->
                  Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.private_dns_enabled
              (fun f ->
                 Ezxmlm.make_tag "PrivateDnsEnabled" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_dns_enabled
              (fun f -> ("private_dns_enabled", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some
             ("security_group_ids",
               (ValueStringList.to_json v.security_group_ids));
           Some ("subnet_ids", (ValueStringList.to_json v.subnet_ids));
           Some
             ("route_table_ids", (ValueStringList.to_json v.route_table_ids));
           Util.option_map v.policy_document
             (fun f -> ("policy_document", (String.to_json f)));
           Some ("service_name", (String.to_json v.service_name));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.vpc_endpoint_type
             (fun f -> ("vpc_endpoint_type", (VpcEndpointType.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_endpoint_type =
          (Util.option_map (Json.lookup j "vpc_endpoint_type")
             VpcEndpointType.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        service_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "service_name")));
        policy_document =
          (Util.option_map (Json.lookup j "policy_document") String.of_json);
        route_table_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "route_table_ids")));
        subnet_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "subnet_ids")));
        security_group_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        private_dns_enabled =
          (Util.option_map (Json.lookup j "private_dns_enabled")
             Boolean.of_json)
      }
  end
module DeleteDhcpOptionsRequest =
  struct
    type t = {
      dhcp_options_id: String.t ;
      dry_run: Boolean.t option }
    let make ~dhcp_options_id  ?dry_run  () = { dhcp_options_id; dry_run }
    let parse xml =
      Some
        {
          dhcp_options_id =
            (Xml.required "DhcpOptionsId"
               (Util.option_bind (Xml.member "DhcpOptionsId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("DhcpOptionsId", (String.to_query v.dhcp_options_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "DhcpOptionsId"
                  ([], (String.to_xml v.dhcp_options_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("dhcp_options_id", (String.to_json v.dhcp_options_id))])
    let of_json j =
      {
        dhcp_options_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_options_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AcceptTransitGatewayPeeringAttachmentResult =
  struct
    type t =
      {
      transit_gateway_peering_attachment:
        TransitGatewayPeeringAttachment.t option }
    let make ?transit_gateway_peering_attachment  () =
      { transit_gateway_peering_attachment }
    let parse xml =
      Some
        {
          transit_gateway_peering_attachment =
            (Util.option_bind
               (Xml.member "transitGatewayPeeringAttachment" xml)
               TransitGatewayPeeringAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayPeeringAttachment",
                     (TransitGatewayPeeringAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayPeeringAttachment"
                   ([], (TransitGatewayPeeringAttachment.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 ("transit_gateway_peering_attachment",
                   (TransitGatewayPeeringAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_peering_attachment =
          (Util.option_map
             (Json.lookup j "transit_gateway_peering_attachment")
             TransitGatewayPeeringAttachment.of_json)
      }
  end
module DescribeVpcEndpointConnectionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(filters= [])  ?max_results  ?next_token  () =
      { dry_run; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeTransitGatewayPeeringAttachmentsRequest =
  struct
    type t =
      {
      transit_gateway_attachment_ids: TransitGatewayAttachmentIdStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(transit_gateway_attachment_ids= [])  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        transit_gateway_attachment_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentIds" xml)
                  TransitGatewayAttachmentIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentIds",
                  (TransitGatewayAttachmentIdStringList.to_query
                     v.transit_gateway_attachment_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "TransitGatewayAttachmentIds"
                          ([],
                            (TransitGatewayAttachmentIdStringList.to_xml [x]))))
                  v.transit_gateway_attachment_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_attachment_ids",
               (TransitGatewayAttachmentIdStringList.to_json
                  v.transit_gateway_attachment_ids))])
    let of_json j =
      {
        transit_gateway_attachment_ids =
          (TransitGatewayAttachmentIdStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module SearchTransitGatewayMulticastGroupsResult =
  struct
    type t =
      {
      multicast_groups: TransitGatewayMulticastGroupList.t ;
      next_token: String.t option }
    let make ?(multicast_groups= [])  ?next_token  () =
      { multicast_groups; next_token }
    let parse xml =
      Some
        {
          multicast_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "multicastGroups" xml)
                  TransitGatewayMulticastGroupList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("MulticastGroups",
                  (TransitGatewayMulticastGroupList.to_query
                     v.multicast_groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "multicastGroups"
                       ([], (TransitGatewayMulticastGroupList.to_xml [x]))))
               v.multicast_groups))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("multicast_groups",
               (TransitGatewayMulticastGroupList.to_json v.multicast_groups))])
    let of_json j =
      {
        multicast_groups =
          (TransitGatewayMulticastGroupList.of_json
             (Util.of_option_exn (Json.lookup j "multicast_groups")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeScheduledInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      scheduled_instance_ids: ScheduledInstanceIdRequestSet.t ;
      slot_start_time_range: SlotStartTimeRangeRequest.t option }
    let make ?dry_run  ?(filters= [])  ?max_results  ?next_token 
      ?(scheduled_instance_ids= [])  ?slot_start_time_range  () =
      {
        dry_run;
        filters;
        max_results;
        next_token;
        scheduled_instance_ids;
        slot_start_time_range
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          scheduled_instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ScheduledInstanceId" xml)
                  ScheduledInstanceIdRequestSet.parse));
          slot_start_time_range =
            (Util.option_bind (Xml.member "SlotStartTimeRange" xml)
               SlotStartTimeRangeRequest.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.slot_start_time_range
              (fun f ->
                 Query.Pair
                   ("SlotStartTimeRange",
                     (SlotStartTimeRangeRequest.to_query f)));
           Some
             (Query.Pair
                ("ScheduledInstanceId",
                  (ScheduledInstanceIdRequestSet.to_query
                     v.scheduled_instance_ids)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.dry_run
                   (fun f ->
                      Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filter"
                          ([], (FilterList.to_xml [x])))) v.filters))
              @
              [Util.option_map v.max_results
                 (fun f ->
                    Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ScheduledInstanceId"
                       ([], (ScheduledInstanceIdRequestSet.to_xml [x]))))
               v.scheduled_instance_ids))
           @
           [Util.option_map v.slot_start_time_range
              (fun f ->
                 Ezxmlm.make_tag "SlotStartTimeRange"
                   ([], (SlotStartTimeRangeRequest.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.slot_start_time_range
              (fun f ->
                 ("slot_start_time_range",
                   (SlotStartTimeRangeRequest.to_json f)));
           Some
             ("scheduled_instance_ids",
               (ScheduledInstanceIdRequestSet.to_json
                  v.scheduled_instance_ids));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        scheduled_instance_ids =
          (ScheduledInstanceIdRequestSet.of_json
             (Util.of_option_exn (Json.lookup j "scheduled_instance_ids")));
        slot_start_time_range =
          (Util.option_map (Json.lookup j "slot_start_time_range")
             SlotStartTimeRangeRequest.of_json)
      }
  end
module DeleteSecurityGroupRequest =
  struct
    type t =
      {
      group_id: String.t option ;
      group_name: String.t option ;
      dry_run: Boolean.t option }
    let make ?group_id  ?group_name  ?dry_run  () =
      { group_id; group_name; dry_run }
    let parse xml =
      Some
        {
          group_id =
            (Util.option_bind (Xml.member "GroupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.group_id
                (fun f -> Ezxmlm.make_tag "GroupId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.group_name
               (fun f -> Ezxmlm.make_tag "GroupName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)))])
    let of_json j =
      {
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeLocalGatewayVirtualInterfacesResult =
  struct
    type t =
      {
      local_gateway_virtual_interfaces: LocalGatewayVirtualInterfaceSet.t ;
      next_token: String.t option }
    let make ?(local_gateway_virtual_interfaces= [])  ?next_token  () =
      { local_gateway_virtual_interfaces; next_token }
    let parse xml =
      Some
        {
          local_gateway_virtual_interfaces =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "localGatewayVirtualInterfaceSet" xml)
                  LocalGatewayVirtualInterfaceSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayVirtualInterfaceSet",
                  (LocalGatewayVirtualInterfaceSet.to_query
                     v.local_gateway_virtual_interfaces)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "localGatewayVirtualInterfaceSet"
                       ([], (LocalGatewayVirtualInterfaceSet.to_xml [x]))))
               v.local_gateway_virtual_interfaces))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateway_virtual_interfaces",
               (LocalGatewayVirtualInterfaceSet.to_json
                  v.local_gateway_virtual_interfaces))])
    let of_json j =
      {
        local_gateway_virtual_interfaces =
          (LocalGatewayVirtualInterfaceSet.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_virtual_interfaces")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteEgressOnlyInternetGatewayRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      egress_only_internet_gateway_id: String.t }
    let make ?dry_run  ~egress_only_internet_gateway_id  () =
      { dry_run; egress_only_internet_gateway_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          egress_only_internet_gateway_id =
            (Xml.required "EgressOnlyInternetGatewayId"
               (Util.option_bind
                  (Xml.member "EgressOnlyInternetGatewayId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("EgressOnlyInternetGatewayId",
                   (String.to_query v.egress_only_internet_gateway_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "EgressOnlyInternetGatewayId"
                 ([], (String.to_xml v.egress_only_internet_gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("egress_only_internet_gateway_id",
                (String.to_json v.egress_only_internet_gateway_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        egress_only_internet_gateway_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "egress_only_internet_gateway_id")))
      }
  end
module RunInstancesRequest =
  struct
    type t =
      {
      block_device_mappings: BlockDeviceMappingRequestList.t ;
      image_id: String.t option ;
      instance_type: InstanceType.t option ;
      ipv6_address_count: Integer.t option ;
      ipv6_addresses: InstanceIpv6AddressList.t ;
      kernel_id: String.t option ;
      key_name: String.t option ;
      max_count: Integer.t ;
      min_count: Integer.t ;
      monitoring: RunInstancesMonitoringEnabled.t option ;
      placement: Placement.t option ;
      ramdisk_id: String.t option ;
      security_group_ids: SecurityGroupIdStringList.t ;
      security_groups: SecurityGroupStringList.t ;
      subnet_id: String.t option ;
      user_data: String.t option ;
      additional_info: String.t option ;
      client_token: String.t option ;
      disable_api_termination: Boolean.t option ;
      dry_run: Boolean.t option ;
      ebs_optimized: Boolean.t option ;
      iam_instance_profile: IamInstanceProfileSpecification.t option ;
      instance_initiated_shutdown_behavior: ShutdownBehavior.t option ;
      network_interfaces: InstanceNetworkInterfaceSpecificationList.t ;
      private_ip_address: String.t option ;
      elastic_gpu_specification: ElasticGpuSpecifications.t ;
      elastic_inference_accelerators: ElasticInferenceAccelerators.t ;
      tag_specifications: TagSpecificationList.t ;
      launch_template: LaunchTemplateSpecification.t option ;
      instance_market_options: InstanceMarketOptionsRequest.t option ;
      credit_specification: CreditSpecificationRequest.t option ;
      cpu_options: CpuOptionsRequest.t option ;
      capacity_reservation_specification:
        CapacityReservationSpecification.t option ;
      hibernation_options: HibernationOptionsRequest.t option ;
      license_specifications: LicenseSpecificationListRequest.t ;
      metadata_options: InstanceMetadataOptionsRequest.t option }
    let make ?(block_device_mappings= [])  ?image_id  ?instance_type 
      ?ipv6_address_count  ?(ipv6_addresses= [])  ?kernel_id  ?key_name 
      ~max_count  ~min_count  ?monitoring  ?placement  ?ramdisk_id 
      ?(security_group_ids= [])  ?(security_groups= [])  ?subnet_id 
      ?user_data  ?additional_info  ?client_token  ?disable_api_termination 
      ?dry_run  ?ebs_optimized  ?iam_instance_profile 
      ?instance_initiated_shutdown_behavior  ?(network_interfaces= []) 
      ?private_ip_address  ?(elastic_gpu_specification= []) 
      ?(elastic_inference_accelerators= [])  ?(tag_specifications= []) 
      ?launch_template  ?instance_market_options  ?credit_specification 
      ?cpu_options  ?capacity_reservation_specification  ?hibernation_options
       ?(license_specifications= [])  ?metadata_options  () =
      {
        block_device_mappings;
        image_id;
        instance_type;
        ipv6_address_count;
        ipv6_addresses;
        kernel_id;
        key_name;
        max_count;
        min_count;
        monitoring;
        placement;
        ramdisk_id;
        security_group_ids;
        security_groups;
        subnet_id;
        user_data;
        additional_info;
        client_token;
        disable_api_termination;
        dry_run;
        ebs_optimized;
        iam_instance_profile;
        instance_initiated_shutdown_behavior;
        network_interfaces;
        private_ip_address;
        elastic_gpu_specification;
        elastic_inference_accelerators;
        tag_specifications;
        launch_template;
        instance_market_options;
        credit_specification;
        cpu_options;
        capacity_reservation_specification;
        hibernation_options;
        license_specifications;
        metadata_options
      }
    let parse xml =
      Some
        {
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "BlockDeviceMapping" xml)
                  BlockDeviceMappingRequestList.parse));
          image_id =
            (Util.option_bind (Xml.member "ImageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml)
               InstanceType.parse);
          ipv6_address_count =
            (Util.option_bind (Xml.member "Ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "Ipv6Address" xml)
                  InstanceIpv6AddressList.parse));
          kernel_id =
            (Util.option_bind (Xml.member "KernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "KeyName" xml) String.parse);
          max_count =
            (Xml.required "MaxCount"
               (Util.option_bind (Xml.member "MaxCount" xml) Integer.parse));
          min_count =
            (Xml.required "MinCount"
               (Util.option_bind (Xml.member "MinCount" xml) Integer.parse));
          monitoring =
            (Util.option_bind (Xml.member "Monitoring" xml)
               RunInstancesMonitoringEnabled.parse);
          placement =
            (Util.option_bind (Xml.member "Placement" xml) Placement.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "RamdiskId" xml) String.parse);
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroup" xml)
                  SecurityGroupStringList.parse));
          subnet_id =
            (Util.option_bind (Xml.member "SubnetId" xml) String.parse);
          user_data =
            (Util.option_bind (Xml.member "UserData" xml) String.parse);
          additional_info =
            (Util.option_bind (Xml.member "additionalInfo" xml) String.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          disable_api_termination =
            (Util.option_bind (Xml.member "disableApiTermination" xml)
               Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse);
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               ShutdownBehavior.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterface" xml)
                  InstanceNetworkInterfaceSpecificationList.parse));
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          elastic_gpu_specification =
            (Util.of_option []
               (Util.option_bind (Xml.member "ElasticGpuSpecification" xml)
                  ElasticGpuSpecifications.parse));
          elastic_inference_accelerators =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ElasticInferenceAccelerator" xml)
                  ElasticInferenceAccelerators.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          launch_template =
            (Util.option_bind (Xml.member "LaunchTemplate" xml)
               LaunchTemplateSpecification.parse);
          instance_market_options =
            (Util.option_bind (Xml.member "InstanceMarketOptions" xml)
               InstanceMarketOptionsRequest.parse);
          credit_specification =
            (Util.option_bind (Xml.member "CreditSpecification" xml)
               CreditSpecificationRequest.parse);
          cpu_options =
            (Util.option_bind (Xml.member "CpuOptions" xml)
               CpuOptionsRequest.parse);
          capacity_reservation_specification =
            (Util.option_bind
               (Xml.member "CapacityReservationSpecification" xml)
               CapacityReservationSpecification.parse);
          hibernation_options =
            (Util.option_bind (Xml.member "HibernationOptions" xml)
               HibernationOptionsRequest.parse);
          license_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "LicenseSpecification" xml)
                  LicenseSpecificationListRequest.parse));
          metadata_options =
            (Util.option_bind (Xml.member "MetadataOptions" xml)
               InstanceMetadataOptionsRequest.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.metadata_options
              (fun f ->
                 Query.Pair
                   ("MetadataOptions",
                     (InstanceMetadataOptionsRequest.to_query f)));
           Some
             (Query.Pair
                ("LicenseSpecification",
                  (LicenseSpecificationListRequest.to_query
                     v.license_specifications)));
           Util.option_map v.hibernation_options
             (fun f ->
                Query.Pair
                  ("HibernationOptions",
                    (HibernationOptionsRequest.to_query f)));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                Query.Pair
                  ("CapacityReservationSpecification",
                    (CapacityReservationSpecification.to_query f)));
           Util.option_map v.cpu_options
             (fun f ->
                Query.Pair ("CpuOptions", (CpuOptionsRequest.to_query f)));
           Util.option_map v.credit_specification
             (fun f ->
                Query.Pair
                  ("CreditSpecification",
                    (CreditSpecificationRequest.to_query f)));
           Util.option_map v.instance_market_options
             (fun f ->
                Query.Pair
                  ("InstanceMarketOptions",
                    (InstanceMarketOptionsRequest.to_query f)));
           Util.option_map v.launch_template
             (fun f ->
                Query.Pair
                  ("LaunchTemplate",
                    (LaunchTemplateSpecification.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some
             (Query.Pair
                ("ElasticInferenceAccelerator",
                  (ElasticInferenceAccelerators.to_query
                     v.elastic_inference_accelerators)));
           Some
             (Query.Pair
                ("ElasticGpuSpecification",
                  (ElasticGpuSpecifications.to_query
                     v.elastic_gpu_specification)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterface",
                  (InstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (ShutdownBehavior.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (IamInstanceProfileSpecification.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                Query.Pair ("DisableApiTermination", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.additional_info
             (fun f -> Query.Pair ("AdditionalInfo", (String.to_query f)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroup",
                  (SecurityGroupStringList.to_query v.security_groups)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.security_group_ids)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (Placement.to_query f)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair
                  ("Monitoring", (RunInstancesMonitoringEnabled.to_query f)));
           Some (Query.Pair ("MinCount", (Integer.to_query v.min_count)));
           Some (Query.Pair ("MaxCount", (Integer.to_query v.max_count)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6Address",
                  (InstanceIpv6AddressList.to_query v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingRequestList.to_query
                     v.block_device_mappings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((((((((((((((((((((([] @
                                              (List.map
                                                 (fun x ->
                                                    Some
                                                      (Ezxmlm.make_tag
                                                         "BlockDeviceMapping"
                                                         ([],
                                                           (BlockDeviceMappingRequestList.to_xml
                                                              [x]))))
                                                 v.block_device_mappings))
                                             @
                                             [Util.option_map v.image_id
                                                (fun f ->
                                                   Ezxmlm.make_tag "ImageId"
                                                     ([], (String.to_xml f)))])
                                            @
                                            [Util.option_map v.instance_type
                                               (fun f ->
                                                  Ezxmlm.make_tag
                                                    "InstanceType"
                                                    ([],
                                                      (InstanceType.to_xml f)))])
                                           @
                                           [Util.option_map
                                              v.ipv6_address_count
                                              (fun f ->
                                                 Ezxmlm.make_tag
                                                   "Ipv6AddressCount"
                                                   ([], (Integer.to_xml f)))])
                                          @
                                          (List.map
                                             (fun x ->
                                                Some
                                                  (Ezxmlm.make_tag
                                                     "Ipv6Address"
                                                     ([],
                                                       (InstanceIpv6AddressList.to_xml
                                                          [x]))))
                                             v.ipv6_addresses))
                                         @
                                         [Util.option_map v.kernel_id
                                            (fun f ->
                                               Ezxmlm.make_tag "KernelId"
                                                 ([], (String.to_xml f)))])
                                        @
                                        [Util.option_map v.key_name
                                           (fun f ->
                                              Ezxmlm.make_tag "KeyName"
                                                ([], (String.to_xml f)))])
                                       @
                                       [Some
                                          (Ezxmlm.make_tag "MaxCount"
                                             ([],
                                               (Integer.to_xml v.max_count)))])
                                      @
                                      [Some
                                         (Ezxmlm.make_tag "MinCount"
                                            ([],
                                              (Integer.to_xml v.min_count)))])
                                     @
                                     [Util.option_map v.monitoring
                                        (fun f ->
                                           Ezxmlm.make_tag "Monitoring"
                                             ([],
                                               (RunInstancesMonitoringEnabled.to_xml
                                                  f)))])
                                    @
                                    [Util.option_map v.placement
                                       (fun f ->
                                          Ezxmlm.make_tag "Placement"
                                            ([], (Placement.to_xml f)))])
                                   @
                                   [Util.option_map v.ramdisk_id
                                      (fun f ->
                                         Ezxmlm.make_tag "RamdiskId"
                                           ([], (String.to_xml f)))])
                                  @
                                  (List.map
                                     (fun x ->
                                        Some
                                          (Ezxmlm.make_tag "SecurityGroupId"
                                             ([],
                                               (SecurityGroupIdStringList.to_xml
                                                  [x]))))
                                     v.security_group_ids))
                                 @
                                 (List.map
                                    (fun x ->
                                       Some
                                         (Ezxmlm.make_tag "SecurityGroup"
                                            ([],
                                              (SecurityGroupStringList.to_xml
                                                 [x])))) v.security_groups))
                                @
                                [Util.option_map v.subnet_id
                                   (fun f ->
                                      Ezxmlm.make_tag "SubnetId"
                                        ([], (String.to_xml f)))])
                               @
                               [Util.option_map v.user_data
                                  (fun f ->
                                     Ezxmlm.make_tag "UserData"
                                       ([], (String.to_xml f)))])
                              @
                              [Util.option_map v.additional_info
                                 (fun f ->
                                    Ezxmlm.make_tag "additionalInfo"
                                      ([], (String.to_xml f)))])
                             @
                             [Util.option_map v.client_token
                                (fun f ->
                                   Ezxmlm.make_tag "clientToken"
                                     ([], (String.to_xml f)))])
                            @
                            [Util.option_map v.disable_api_termination
                               (fun f ->
                                  Ezxmlm.make_tag "disableApiTermination"
                                    ([], (Boolean.to_xml f)))])
                           @
                           [Util.option_map v.dry_run
                              (fun f ->
                                 Ezxmlm.make_tag "dryRun"
                                   ([], (Boolean.to_xml f)))])
                          @
                          [Util.option_map v.ebs_optimized
                             (fun f ->
                                Ezxmlm.make_tag "ebsOptimized"
                                  ([], (Boolean.to_xml f)))])
                         @
                         [Util.option_map v.iam_instance_profile
                            (fun f ->
                               Ezxmlm.make_tag "iamInstanceProfile"
                                 ([],
                                   (IamInstanceProfileSpecification.to_xml f)))])
                        @
                        [Util.option_map
                           v.instance_initiated_shutdown_behavior
                           (fun f ->
                              Ezxmlm.make_tag
                                "instanceInitiatedShutdownBehavior"
                                ([], (ShutdownBehavior.to_xml f)))])
                       @
                       (List.map
                          (fun x ->
                             Some
                               (Ezxmlm.make_tag "networkInterface"
                                  ([],
                                    (InstanceNetworkInterfaceSpecificationList.to_xml
                                       [x])))) v.network_interfaces))
                      @
                      [Util.option_map v.private_ip_address
                         (fun f ->
                            Ezxmlm.make_tag "privateIpAddress"
                              ([], (String.to_xml f)))])
                     @
                     (List.map
                        (fun x ->
                           Some
                             (Ezxmlm.make_tag "ElasticGpuSpecification"
                                ([], (ElasticGpuSpecifications.to_xml [x]))))
                        v.elastic_gpu_specification))
                    @
                    (List.map
                       (fun x ->
                          Some
                            (Ezxmlm.make_tag "ElasticInferenceAccelerator"
                               ([],
                                 (ElasticInferenceAccelerators.to_xml [x]))))
                       v.elastic_inference_accelerators))
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "TagSpecification"
                              ([], (TagSpecificationList.to_xml [x]))))
                      v.tag_specifications))
                  @
                  [Util.option_map v.launch_template
                     (fun f ->
                        Ezxmlm.make_tag "LaunchTemplate"
                          ([], (LaunchTemplateSpecification.to_xml f)))])
                 @
                 [Util.option_map v.instance_market_options
                    (fun f ->
                       Ezxmlm.make_tag "InstanceMarketOptions"
                         ([], (InstanceMarketOptionsRequest.to_xml f)))])
                @
                [Util.option_map v.credit_specification
                   (fun f ->
                      Ezxmlm.make_tag "CreditSpecification"
                        ([], (CreditSpecificationRequest.to_xml f)))])
               @
               [Util.option_map v.cpu_options
                  (fun f ->
                     Ezxmlm.make_tag "CpuOptions"
                       ([], (CpuOptionsRequest.to_xml f)))])
              @
              [Util.option_map v.capacity_reservation_specification
                 (fun f ->
                    Ezxmlm.make_tag "CapacityReservationSpecification"
                      ([], (CapacityReservationSpecification.to_xml f)))])
             @
             [Util.option_map v.hibernation_options
                (fun f ->
                   Ezxmlm.make_tag "HibernationOptions"
                     ([], (HibernationOptionsRequest.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "LicenseSpecification"
                       ([], (LicenseSpecificationListRequest.to_xml [x]))))
               v.license_specifications))
           @
           [Util.option_map v.metadata_options
              (fun f ->
                 Ezxmlm.make_tag "MetadataOptions"
                   ([], (InstanceMetadataOptionsRequest.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.metadata_options
              (fun f ->
                 ("metadata_options",
                   (InstanceMetadataOptionsRequest.to_json f)));
           Some
             ("license_specifications",
               (LicenseSpecificationListRequest.to_json
                  v.license_specifications));
           Util.option_map v.hibernation_options
             (fun f ->
                ("hibernation_options",
                  (HibernationOptionsRequest.to_json f)));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                ("capacity_reservation_specification",
                  (CapacityReservationSpecification.to_json f)));
           Util.option_map v.cpu_options
             (fun f -> ("cpu_options", (CpuOptionsRequest.to_json f)));
           Util.option_map v.credit_specification
             (fun f ->
                ("credit_specification",
                  (CreditSpecificationRequest.to_json f)));
           Util.option_map v.instance_market_options
             (fun f ->
                ("instance_market_options",
                  (InstanceMarketOptionsRequest.to_json f)));
           Util.option_map v.launch_template
             (fun f ->
                ("launch_template", (LaunchTemplateSpecification.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some
             ("elastic_inference_accelerators",
               (ElasticInferenceAccelerators.to_json
                  v.elastic_inference_accelerators));
           Some
             ("elastic_gpu_specification",
               (ElasticGpuSpecifications.to_json v.elastic_gpu_specification));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (ShutdownBehavior.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (IamInstanceProfileSpecification.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.disable_api_termination
             (fun f -> ("disable_api_termination", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.additional_info
             (fun f -> ("additional_info", (String.to_json f)));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Some
             ("security_groups",
               (SecurityGroupStringList.to_json v.security_groups));
           Some
             ("security_group_ids",
               (SecurityGroupIdStringList.to_json v.security_group_ids));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (Placement.to_json f)));
           Util.option_map v.monitoring
             (fun f ->
                ("monitoring", (RunInstancesMonitoringEnabled.to_json f)));
           Some ("min_count", (Integer.to_json v.min_count));
           Some ("max_count", (Integer.to_json v.max_count));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (InstanceIpv6AddressList.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingRequestList.to_json v.block_device_mappings))])
    let of_json j =
      {
        block_device_mappings =
          (BlockDeviceMappingRequestList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        ipv6_address_count =
          (Util.option_map (Json.lookup j "ipv6_address_count")
             Integer.of_json);
        ipv6_addresses =
          (InstanceIpv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        max_count =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "max_count")));
        min_count =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "min_count")));
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             RunInstancesMonitoringEnabled.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement") Placement.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        security_group_ids =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        security_groups =
          (SecurityGroupStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json);
        additional_info =
          (Util.option_map (Json.lookup j "additional_info") String.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        disable_api_termination =
          (Util.option_map (Json.lookup j "disable_api_termination")
             Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfileSpecification.of_json);
        instance_initiated_shutdown_behavior =
          (Util.option_map
             (Json.lookup j "instance_initiated_shutdown_behavior")
             ShutdownBehavior.of_json);
        network_interfaces =
          (InstanceNetworkInterfaceSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        elastic_gpu_specification =
          (ElasticGpuSpecifications.of_json
             (Util.of_option_exn (Json.lookup j "elastic_gpu_specification")));
        elastic_inference_accelerators =
          (ElasticInferenceAccelerators.of_json
             (Util.of_option_exn
                (Json.lookup j "elastic_inference_accelerators")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        launch_template =
          (Util.option_map (Json.lookup j "launch_template")
             LaunchTemplateSpecification.of_json);
        instance_market_options =
          (Util.option_map (Json.lookup j "instance_market_options")
             InstanceMarketOptionsRequest.of_json);
        credit_specification =
          (Util.option_map (Json.lookup j "credit_specification")
             CreditSpecificationRequest.of_json);
        cpu_options =
          (Util.option_map (Json.lookup j "cpu_options")
             CpuOptionsRequest.of_json);
        capacity_reservation_specification =
          (Util.option_map
             (Json.lookup j "capacity_reservation_specification")
             CapacityReservationSpecification.of_json);
        hibernation_options =
          (Util.option_map (Json.lookup j "hibernation_options")
             HibernationOptionsRequest.of_json);
        license_specifications =
          (LicenseSpecificationListRequest.of_json
             (Util.of_option_exn (Json.lookup j "license_specifications")));
        metadata_options =
          (Util.option_map (Json.lookup j "metadata_options")
             InstanceMetadataOptionsRequest.of_json)
      }
  end
module StartInstancesResult =
  struct
    type t = {
      starting_instances: InstanceStateChangeList.t }
    let make ?(starting_instances= [])  () = { starting_instances }
    let parse xml =
      Some
        {
          starting_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceStateChangeList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceStateChangeList.to_query v.starting_instances)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "instancesSet"
                      ([], (InstanceStateChangeList.to_xml [x]))))
              v.starting_instances))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("starting_instances",
                (InstanceStateChangeList.to_json v.starting_instances))])
    let of_json j =
      {
        starting_instances =
          (InstanceStateChangeList.of_json
             (Util.of_option_exn (Json.lookup j "starting_instances")))
      }
  end
module DescribeLocalGatewayVirtualInterfaceGroupsResult =
  struct
    type t =
      {
      local_gateway_virtual_interface_groups:
        LocalGatewayVirtualInterfaceGroupSet.t ;
      next_token: String.t option }
    let make ?(local_gateway_virtual_interface_groups= [])  ?next_token  () =
      { local_gateway_virtual_interface_groups; next_token }
    let parse xml =
      Some
        {
          local_gateway_virtual_interface_groups =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "localGatewayVirtualInterfaceGroupSet" xml)
                  LocalGatewayVirtualInterfaceGroupSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayVirtualInterfaceGroupSet",
                  (LocalGatewayVirtualInterfaceGroupSet.to_query
                     v.local_gateway_virtual_interface_groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "localGatewayVirtualInterfaceGroupSet"
                       ([],
                         (LocalGatewayVirtualInterfaceGroupSet.to_xml [x]))))
               v.local_gateway_virtual_interface_groups))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateway_virtual_interface_groups",
               (LocalGatewayVirtualInterfaceGroupSet.to_json
                  v.local_gateway_virtual_interface_groups))])
    let of_json j =
      {
        local_gateway_virtual_interface_groups =
          (LocalGatewayVirtualInterfaceGroupSet.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_virtual_interface_groups")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateTransitGatewayVpcAttachmentResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.t option }
    let make ?transit_gateway_vpc_attachment  () =
      { transit_gateway_vpc_attachment }
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachment =
            (Util.option_bind (Xml.member "transitGatewayVpcAttachment" xml)
               TransitGatewayVpcAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayVpcAttachment",
                     (TransitGatewayVpcAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayVpcAttachment"
                   ([], (TransitGatewayVpcAttachment.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 ("transit_gateway_vpc_attachment",
                   (TransitGatewayVpcAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_vpc_attachment =
          (Util.option_map (Json.lookup j "transit_gateway_vpc_attachment")
             TransitGatewayVpcAttachment.of_json)
      }
  end
module DescribeImagesRequest =
  struct
    type t =
      {
      executable_users: ExecutableByStringList.t ;
      filters: FilterList.t ;
      image_ids: ImageIdStringList.t ;
      owners: OwnerStringList.t ;
      dry_run: Boolean.t option }
    let make ?(executable_users= [])  ?(filters= [])  ?(image_ids= []) 
      ?(owners= [])  ?dry_run  () =
      { executable_users; filters; image_ids; owners; dry_run }
    let parse xml =
      Some
        {
          executable_users =
            (Util.of_option []
               (Util.option_bind (Xml.member "ExecutableBy" xml)
                  ExecutableByStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          image_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ImageId" xml)
                  ImageIdStringList.parse));
          owners =
            (Util.of_option []
               (Util.option_bind (Xml.member "Owner" xml)
                  OwnerStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Owner", (OwnerStringList.to_query v.owners)));
           Some
             (Query.Pair
                ("ImageId", (ImageIdStringList.to_query v.image_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("ExecutableBy",
                  (ExecutableByStringList.to_query v.executable_users)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "ExecutableBy"
                          ([], (ExecutableByStringList.to_xml [x]))))
                  v.executable_users))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "ImageId"
                        ([], (ImageIdStringList.to_xml [x])))) v.image_ids))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Owner"
                       ([], (OwnerStringList.to_xml [x])))) v.owners))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("owners", (OwnerStringList.to_json v.owners));
           Some ("image_ids", (ImageIdStringList.to_json v.image_ids));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("executable_users",
               (ExecutableByStringList.to_json v.executable_users))])
    let of_json j =
      {
        executable_users =
          (ExecutableByStringList.of_json
             (Util.of_option_exn (Json.lookup j "executable_users")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        image_ids =
          (ImageIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "image_ids")));
        owners =
          (OwnerStringList.of_json
             (Util.of_option_exn (Json.lookup j "owners")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ReplaceNetworkAclAssociationRequest =
  struct
    type t =
      {
      association_id: String.t ;
      dry_run: Boolean.t option ;
      network_acl_id: String.t }
    let make ~association_id  ?dry_run  ~network_acl_id  () =
      { association_id; dry_run; network_acl_id }
    let parse xml =
      Some
        {
          association_id =
            (Xml.required "associationId"
               (Util.option_bind (Xml.member "associationId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_acl_id =
            (Xml.required "networkAclId"
               (Util.option_bind (Xml.member "networkAclId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkAclId", (String.to_query v.network_acl_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AssociationId", (String.to_query v.association_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "associationId"
                   ([], (String.to_xml v.association_id)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "networkAclId"
                 ([], (String.to_xml v.network_acl_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("network_acl_id", (String.to_json v.network_acl_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("association_id", (String.to_json v.association_id))])
    let of_json j =
      {
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_acl_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_id")))
      }
  end
module DescribeVpcEndpointsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_endpoint_ids: ValueStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(vpc_endpoint_ids= [])  ?(filters= [])  ?max_results 
      ?next_token  () =
      { dry_run; vpc_endpoint_ids; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          vpc_endpoint_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpcEndpointId" xml)
                  ValueStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("VpcEndpointId",
                  (ValueStringList.to_query v.vpc_endpoint_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "VpcEndpointId"
                         ([], (ValueStringList.to_xml [x]))))
                 v.vpc_endpoint_ids))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("vpc_endpoint_ids",
               (ValueStringList.to_json v.vpc_endpoint_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_endpoint_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoint_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeVpcPeeringConnectionsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      vpc_peering_connection_ids: ValueStringList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?dry_run  ?(vpc_peering_connection_ids= []) 
      ?next_token  ?max_results  () =
      { filters; dry_run; vpc_peering_connection_ids; next_token; max_results
      }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_peering_connection_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpcPeeringConnectionId" xml)
                  ValueStringList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("VpcPeeringConnectionId",
                  (ValueStringList.to_query v.vpc_peering_connection_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filter"
                          ([], (FilterList.to_xml [x])))) v.filters))
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "VpcPeeringConnectionId"
                        ([], (ValueStringList.to_xml [x]))))
                v.vpc_peering_connection_ids))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("vpc_peering_connection_ids",
               (ValueStringList.to_json v.vpc_peering_connection_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_peering_connection_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_peering_connection_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DisassociateTransitGatewayRouteTableResult =
  struct
    type t = {
      association: TransitGatewayAssociation.t option }
    let make ?association  () = { association }
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               TransitGatewayAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association
              (fun f ->
                 Query.Pair
                   ("Association", (TransitGatewayAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.association
              (fun f ->
                 Ezxmlm.make_tag "association"
                   ([], (TransitGatewayAssociation.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association
              (fun f ->
                 ("association", (TransitGatewayAssociation.to_json f)))])
    let of_json j =
      {
        association =
          (Util.option_map (Json.lookup j "association")
             TransitGatewayAssociation.of_json)
      }
  end
module DescribeMovingAddressesResult =
  struct
    type t =
      {
      moving_address_statuses: MovingAddressStatusSet.t ;
      next_token: String.t option }
    let make ?(moving_address_statuses= [])  ?next_token  () =
      { moving_address_statuses; next_token }
    let parse xml =
      Some
        {
          moving_address_statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "movingAddressStatusSet" xml)
                  MovingAddressStatusSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("MovingAddressStatusSet",
                  (MovingAddressStatusSet.to_query v.moving_address_statuses)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "movingAddressStatusSet"
                       ([], (MovingAddressStatusSet.to_xml [x]))))
               v.moving_address_statuses))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("moving_address_statuses",
               (MovingAddressStatusSet.to_json v.moving_address_statuses))])
    let of_json j =
      {
        moving_address_statuses =
          (MovingAddressStatusSet.of_json
             (Util.of_option_exn (Json.lookup j "moving_address_statuses")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeExportTasksRequest =
  struct
    type t =
      {
      export_task_ids: ExportTaskIdStringList.t ;
      filters: FilterList.t }
    let make ?(export_task_ids= [])  ?(filters= [])  () =
      { export_task_ids; filters }
    let parse xml =
      Some
        {
          export_task_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "exportTaskId" xml)
                  ExportTaskIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("ExportTaskId",
                  (ExportTaskIdStringList.to_query v.export_task_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "exportTaskId"
                       ([], (ExportTaskIdStringList.to_xml [x]))))
               v.export_task_ids))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
              v.filters))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some
             ("export_task_ids",
               (ExportTaskIdStringList.to_json v.export_task_ids))])
    let of_json j =
      {
        export_task_ids =
          (ExportTaskIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "export_task_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DescribeReservedInstancesOfferingsRequest =
  struct
    type t =
      {
      availability_zone: String.t option ;
      filters: FilterList.t ;
      include_marketplace: Boolean.t option ;
      instance_type: InstanceType.t option ;
      max_duration: Long.t option ;
      max_instance_count: Integer.t option ;
      min_duration: Long.t option ;
      offering_class: OfferingClassType.t option ;
      product_description: RIProductDescription.t option ;
      reserved_instances_offering_ids:
        ReservedInstancesOfferingIdStringList.t ;
      dry_run: Boolean.t option ;
      instance_tenancy: Tenancy.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      offering_type: OfferingTypeValues.t option }
    let make ?availability_zone  ?(filters= [])  ?include_marketplace 
      ?instance_type  ?max_duration  ?max_instance_count  ?min_duration 
      ?offering_class  ?product_description 
      ?(reserved_instances_offering_ids= [])  ?dry_run  ?instance_tenancy 
      ?max_results  ?next_token  ?offering_type  () =
      {
        availability_zone;
        filters;
        include_marketplace;
        instance_type;
        max_duration;
        max_instance_count;
        min_duration;
        offering_class;
        product_description;
        reserved_instances_offering_ids;
        dry_run;
        instance_tenancy;
        max_results;
        next_token;
        offering_type
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          include_marketplace =
            (Util.option_bind (Xml.member "IncludeMarketplace" xml)
               Boolean.parse);
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml)
               InstanceType.parse);
          max_duration =
            (Util.option_bind (Xml.member "MaxDuration" xml) Long.parse);
          max_instance_count =
            (Util.option_bind (Xml.member "MaxInstanceCount" xml)
               Integer.parse);
          min_duration =
            (Util.option_bind (Xml.member "MinDuration" xml) Long.parse);
          offering_class =
            (Util.option_bind (Xml.member "OfferingClass" xml)
               OfferingClassType.parse);
          product_description =
            (Util.option_bind (Xml.member "ProductDescription" xml)
               RIProductDescription.parse);
          reserved_instances_offering_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ReservedInstancesOfferingId" xml)
                  ReservedInstancesOfferingIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_tenancy =
            (Util.option_bind (Xml.member "instanceTenancy" xml)
               Tenancy.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          offering_type =
            (Util.option_bind (Xml.member "offeringType" xml)
               OfferingTypeValues.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.offering_type
              (fun f ->
                 Query.Pair ("OfferingType", (OfferingTypeValues.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.instance_tenancy
             (fun f -> Query.Pair ("InstanceTenancy", (Tenancy.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesOfferingId",
                  (ReservedInstancesOfferingIdStringList.to_query
                     v.reserved_instances_offering_ids)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.offering_class
             (fun f ->
                Query.Pair ("OfferingClass", (OfferingClassType.to_query f)));
           Util.option_map v.min_duration
             (fun f -> Query.Pair ("MinDuration", (Long.to_query f)));
           Util.option_map v.max_instance_count
             (fun f -> Query.Pair ("MaxInstanceCount", (Integer.to_query f)));
           Util.option_map v.max_duration
             (fun f -> Query.Pair ("MaxDuration", (Long.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.include_marketplace
             (fun f ->
                Query.Pair ("IncludeMarketplace", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Util.option_map v.availability_zone
                            (fun f ->
                               Ezxmlm.make_tag "AvailabilityZone"
                                 ([], (String.to_xml f)))])
                        @
                        (List.map
                           (fun x ->
                              Some
                                (Ezxmlm.make_tag "Filter"
                                   ([], (FilterList.to_xml [x])))) v.filters))
                       @
                       [Util.option_map v.include_marketplace
                          (fun f ->
                             Ezxmlm.make_tag "IncludeMarketplace"
                               ([], (Boolean.to_xml f)))])
                      @
                      [Util.option_map v.instance_type
                         (fun f ->
                            Ezxmlm.make_tag "InstanceType"
                              ([], (InstanceType.to_xml f)))])
                     @
                     [Util.option_map v.max_duration
                        (fun f ->
                           Ezxmlm.make_tag "MaxDuration"
                             ([], (Long.to_xml f)))])
                    @
                    [Util.option_map v.max_instance_count
                       (fun f ->
                          Ezxmlm.make_tag "MaxInstanceCount"
                            ([], (Integer.to_xml f)))])
                   @
                   [Util.option_map v.min_duration
                      (fun f ->
                         Ezxmlm.make_tag "MinDuration" ([], (Long.to_xml f)))])
                  @
                  [Util.option_map v.offering_class
                     (fun f ->
                        Ezxmlm.make_tag "OfferingClass"
                          ([], (OfferingClassType.to_xml f)))])
                 @
                 [Util.option_map v.product_description
                    (fun f ->
                       Ezxmlm.make_tag "ProductDescription"
                         ([], (RIProductDescription.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "ReservedInstancesOfferingId"
                           ([],
                             (ReservedInstancesOfferingIdStringList.to_xml
                                [x])))) v.reserved_instances_offering_ids))
               @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.instance_tenancy
                 (fun f ->
                    Ezxmlm.make_tag "instanceTenancy"
                      ([], (Tenancy.to_xml f)))])
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "maxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.offering_type
              (fun f ->
                 Ezxmlm.make_tag "offeringType"
                   ([], (OfferingTypeValues.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.offering_type
              (fun f -> ("offering_type", (OfferingTypeValues.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.instance_tenancy
             (fun f -> ("instance_tenancy", (Tenancy.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("reserved_instances_offering_ids",
               (ReservedInstancesOfferingIdStringList.to_json
                  v.reserved_instances_offering_ids));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.offering_class
             (fun f -> ("offering_class", (OfferingClassType.to_json f)));
           Util.option_map v.min_duration
             (fun f -> ("min_duration", (Long.to_json f)));
           Util.option_map v.max_instance_count
             (fun f -> ("max_instance_count", (Integer.to_json f)));
           Util.option_map v.max_duration
             (fun f -> ("max_duration", (Long.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.include_marketplace
             (fun f -> ("include_marketplace", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        include_marketplace =
          (Util.option_map (Json.lookup j "include_marketplace")
             Boolean.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        max_duration =
          (Util.option_map (Json.lookup j "max_duration") Long.of_json);
        max_instance_count =
          (Util.option_map (Json.lookup j "max_instance_count")
             Integer.of_json);
        min_duration =
          (Util.option_map (Json.lookup j "min_duration") Long.of_json);
        offering_class =
          (Util.option_map (Json.lookup j "offering_class")
             OfferingClassType.of_json);
        product_description =
          (Util.option_map (Json.lookup j "product_description")
             RIProductDescription.of_json);
        reserved_instances_offering_ids =
          (ReservedInstancesOfferingIdStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_offering_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_tenancy =
          (Util.option_map (Json.lookup j "instance_tenancy") Tenancy.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        offering_type =
          (Util.option_map (Json.lookup j "offering_type")
             OfferingTypeValues.of_json)
      }
  end
module CreateVpcPeeringConnectionResult =
  struct
    type t = {
      vpc_peering_connection: VpcPeeringConnection.t option }
    let make ?vpc_peering_connection  () = { vpc_peering_connection }
    let parse xml =
      Some
        {
          vpc_peering_connection =
            (Util.option_bind (Xml.member "vpcPeeringConnection" xml)
               VpcPeeringConnection.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 Query.Pair
                   ("VpcPeeringConnection",
                     (VpcPeeringConnection.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 Ezxmlm.make_tag "vpcPeeringConnection"
                   ([], (VpcPeeringConnection.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 ("vpc_peering_connection", (VpcPeeringConnection.to_json f)))])
    let of_json j =
      {
        vpc_peering_connection =
          (Util.option_map (Json.lookup j "vpc_peering_connection")
             VpcPeeringConnection.of_json)
      }
  end
module CreateLaunchTemplateVersionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      client_token: String.t option ;
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      source_version: String.t option ;
      version_description: String.t option ;
      launch_template_data: RequestLaunchTemplateData.t }
    let make ?dry_run  ?client_token  ?launch_template_id 
      ?launch_template_name  ?source_version  ?version_description 
      ~launch_template_data  () =
      {
        dry_run;
        client_token;
        launch_template_id;
        launch_template_name;
        source_version;
        version_description;
        launch_template_data
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          launch_template_id =
            (Util.option_bind (Xml.member "LaunchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "LaunchTemplateName" xml)
               String.parse);
          source_version =
            (Util.option_bind (Xml.member "SourceVersion" xml) String.parse);
          version_description =
            (Util.option_bind (Xml.member "VersionDescription" xml)
               String.parse);
          launch_template_data =
            (Xml.required "LaunchTemplateData"
               (Util.option_bind (Xml.member "LaunchTemplateData" xml)
                  RequestLaunchTemplateData.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("LaunchTemplateData",
                   (RequestLaunchTemplateData.to_query v.launch_template_data)));
           Util.option_map v.version_description
             (fun f -> Query.Pair ("VersionDescription", (String.to_query f)));
           Util.option_map v.source_version
             (fun f -> Query.Pair ("SourceVersion", (String.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.dry_run
                    (fun f ->
                       Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.client_token
                   (fun f ->
                      Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
               @
               [Util.option_map v.launch_template_id
                  (fun f ->
                     Ezxmlm.make_tag "LaunchTemplateId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.launch_template_name
                 (fun f ->
                    Ezxmlm.make_tag "LaunchTemplateName"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.source_version
                (fun f ->
                   Ezxmlm.make_tag "SourceVersion" ([], (String.to_xml f)))])
            @
            [Util.option_map v.version_description
               (fun f ->
                  Ezxmlm.make_tag "VersionDescription"
                    ([], (String.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "LaunchTemplateData"
                 ([],
                   (RequestLaunchTemplateData.to_xml v.launch_template_data)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("launch_template_data",
                (RequestLaunchTemplateData.to_json v.launch_template_data));
           Util.option_map v.version_description
             (fun f -> ("version_description", (String.to_json f)));
           Util.option_map v.source_version
             (fun f -> ("source_version", (String.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        source_version =
          (Util.option_map (Json.lookup j "source_version") String.of_json);
        version_description =
          (Util.option_map (Json.lookup j "version_description")
             String.of_json);
        launch_template_data =
          (RequestLaunchTemplateData.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_data")))
      }
  end
module DescribeNetworkAclsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      network_acl_ids: ValueStringList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?dry_run  ?(network_acl_ids= [])  ?next_token 
      ?max_results  () =
      { filters; dry_run; network_acl_ids; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_acl_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkAclId" xml)
                  ValueStringList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkAclId",
                  (ValueStringList.to_query v.network_acl_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filter"
                          ([], (FilterList.to_xml [x])))) v.filters))
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "NetworkAclId"
                        ([], (ValueStringList.to_xml [x]))))
                v.network_acl_ids))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("network_acl_ids", (ValueStringList.to_json v.network_acl_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_acl_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DescribeTrafficMirrorSessionsResult =
  struct
    type t =
      {
      traffic_mirror_sessions: TrafficMirrorSessionSet.t ;
      next_token: String.t option }
    let make ?(traffic_mirror_sessions= [])  ?next_token  () =
      { traffic_mirror_sessions; next_token }
    let parse xml =
      Some
        {
          traffic_mirror_sessions =
            (Util.of_option []
               (Util.option_bind (Xml.member "trafficMirrorSessionSet" xml)
                  TrafficMirrorSessionSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorSessionSet",
                  (TrafficMirrorSessionSet.to_query v.traffic_mirror_sessions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "trafficMirrorSessionSet"
                       ([], (TrafficMirrorSessionSet.to_xml [x]))))
               v.traffic_mirror_sessions))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("traffic_mirror_sessions",
               (TrafficMirrorSessionSet.to_json v.traffic_mirror_sessions))])
    let of_json j =
      {
        traffic_mirror_sessions =
          (TrafficMirrorSessionSet.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_sessions")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyHostsRequest =
  struct
    type t =
      {
      auto_placement: AutoPlacement.t option ;
      host_ids: RequestHostIdList.t ;
      host_recovery: HostRecovery.t option ;
      instance_type: String.t option ;
      instance_family: String.t option }
    let make ?auto_placement  ~host_ids  ?host_recovery  ?instance_type 
      ?instance_family  () =
      {
        auto_placement;
        host_ids;
        host_recovery;
        instance_type;
        instance_family
      }
    let parse xml =
      Some
        {
          auto_placement =
            (Util.option_bind (Xml.member "autoPlacement" xml)
               AutoPlacement.parse);
          host_ids =
            (Xml.required "hostId"
               (Util.option_bind (Xml.member "hostId" xml)
                  RequestHostIdList.parse));
          host_recovery =
            (Util.option_bind (Xml.member "HostRecovery" xml)
               HostRecovery.parse);
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml) String.parse);
          instance_family =
            (Util.option_bind (Xml.member "InstanceFamily" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_family
              (fun f -> Query.Pair ("InstanceFamily", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.host_recovery
             (fun f -> Query.Pair ("HostRecovery", (HostRecovery.to_query f)));
           Some
             (Query.Pair ("HostId", (RequestHostIdList.to_query v.host_ids)));
           Util.option_map v.auto_placement
             (fun f ->
                Query.Pair ("AutoPlacement", (AutoPlacement.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.auto_placement
                  (fun f ->
                     Ezxmlm.make_tag "autoPlacement"
                       ([], (AutoPlacement.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "hostId"
                         ([], (RequestHostIdList.to_xml [x])))) v.host_ids))
             @
             [Util.option_map v.host_recovery
                (fun f ->
                   Ezxmlm.make_tag "HostRecovery"
                     ([], (HostRecovery.to_xml f)))])
            @
            [Util.option_map v.instance_type
               (fun f ->
                  Ezxmlm.make_tag "InstanceType" ([], (String.to_xml f)))])
           @
           [Util.option_map v.instance_family
              (fun f ->
                 Ezxmlm.make_tag "InstanceFamily" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_family
              (fun f -> ("instance_family", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.host_recovery
             (fun f -> ("host_recovery", (HostRecovery.to_json f)));
           Some ("host_ids", (RequestHostIdList.to_json v.host_ids));
           Util.option_map v.auto_placement
             (fun f -> ("auto_placement", (AutoPlacement.to_json f)))])
    let of_json j =
      {
        auto_placement =
          (Util.option_map (Json.lookup j "auto_placement")
             AutoPlacement.of_json);
        host_ids =
          (RequestHostIdList.of_json
             (Util.of_option_exn (Json.lookup j "host_ids")));
        host_recovery =
          (Util.option_map (Json.lookup j "host_recovery")
             HostRecovery.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        instance_family =
          (Util.option_map (Json.lookup j "instance_family") String.of_json)
      }
  end
module RevokeClientVpnIngressRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      target_network_cidr: String.t ;
      access_group_id: String.t option ;
      revoke_all_groups: Boolean.t option ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ~target_network_cidr  ?access_group_id 
      ?revoke_all_groups  ?dry_run  () =
      {
        client_vpn_endpoint_id;
        target_network_cidr;
        access_group_id;
        revoke_all_groups;
        dry_run
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          target_network_cidr =
            (Xml.required "TargetNetworkCidr"
               (Util.option_bind (Xml.member "TargetNetworkCidr" xml)
                  String.parse));
          access_group_id =
            (Util.option_bind (Xml.member "AccessGroupId" xml) String.parse);
          revoke_all_groups =
            (Util.option_bind (Xml.member "RevokeAllGroups" xml)
               Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.revoke_all_groups
             (fun f -> Query.Pair ("RevokeAllGroups", (Boolean.to_query f)));
           Util.option_map v.access_group_id
             (fun f -> Query.Pair ("AccessGroupId", (String.to_query f)));
           Some
             (Query.Pair
                ("TargetNetworkCidr",
                  (String.to_query v.target_network_cidr)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "ClientVpnEndpointId"
                     ([], (String.to_xml v.client_vpn_endpoint_id)))])
              @
              [Some
                 (Ezxmlm.make_tag "TargetNetworkCidr"
                    ([], (String.to_xml v.target_network_cidr)))])
             @
             [Util.option_map v.access_group_id
                (fun f ->
                   Ezxmlm.make_tag "AccessGroupId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.revoke_all_groups
               (fun f ->
                  Ezxmlm.make_tag "RevokeAllGroups" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.revoke_all_groups
             (fun f -> ("revoke_all_groups", (Boolean.to_json f)));
           Util.option_map v.access_group_id
             (fun f -> ("access_group_id", (String.to_json f)));
           Some
             ("target_network_cidr", (String.to_json v.target_network_cidr));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        target_network_cidr =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "target_network_cidr")));
        access_group_id =
          (Util.option_map (Json.lookup j "access_group_id") String.of_json);
        revoke_all_groups =
          (Util.option_map (Json.lookup j "revoke_all_groups")
             Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeClientVpnEndpointsRequest =
  struct
    type t =
      {
      client_vpn_endpoint_ids: ValueStringList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      filters: FilterList.t ;
      dry_run: Boolean.t option }
    let make ?(client_vpn_endpoint_ids= [])  ?max_results  ?next_token 
      ?(filters= [])  ?dry_run  () =
      { client_vpn_endpoint_ids; max_results; next_token; filters; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  ValueStringList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (ValueStringList.to_query v.client_vpn_endpoint_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "ClientVpnEndpointId"
                          ([], (ValueStringList.to_xml [x]))))
                  v.client_vpn_endpoint_ids))
              @
              [Util.option_map v.max_results
                 (fun f ->
                    Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
               v.filters))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("client_vpn_endpoint_ids",
               (ValueStringList.to_json v.client_vpn_endpoint_ids))])
    let of_json j =
      {
        client_vpn_endpoint_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteTrafficMirrorSessionRequest =
  struct
    type t =
      {
      traffic_mirror_session_id: String.t ;
      dry_run: Boolean.t option }
    let make ~traffic_mirror_session_id  ?dry_run  () =
      { traffic_mirror_session_id; dry_run }
    let parse xml =
      Some
        {
          traffic_mirror_session_id =
            (Xml.required "TrafficMirrorSessionId"
               (Util.option_bind (Xml.member "TrafficMirrorSessionId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorSessionId",
                  (String.to_query v.traffic_mirror_session_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "TrafficMirrorSessionId"
                  ([], (String.to_xml v.traffic_mirror_session_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("traffic_mirror_session_id",
               (String.to_json v.traffic_mirror_session_id))])
    let of_json j =
      {
        traffic_mirror_session_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_session_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeTransitGatewayVpcAttachmentsRequest =
  struct
    type t =
      {
      transit_gateway_attachment_ids: TransitGatewayAttachmentIdStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(transit_gateway_attachment_ids= [])  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        transit_gateway_attachment_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentIds" xml)
                  TransitGatewayAttachmentIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentIds",
                  (TransitGatewayAttachmentIdStringList.to_query
                     v.transit_gateway_attachment_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "TransitGatewayAttachmentIds"
                          ([],
                            (TransitGatewayAttachmentIdStringList.to_xml [x]))))
                  v.transit_gateway_attachment_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_attachment_ids",
               (TransitGatewayAttachmentIdStringList.to_json
                  v.transit_gateway_attachment_ids))])
    let of_json j =
      {
        transit_gateway_attachment_ids =
          (TransitGatewayAttachmentIdStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyCapacityReservationResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module ModifyNetworkInterfaceAttributeRequest =
  struct
    type t =
      {
      attachment: NetworkInterfaceAttachmentChanges.t option ;
      description: AttributeValue.t option ;
      dry_run: Boolean.t option ;
      groups: SecurityGroupIdStringList.t ;
      network_interface_id: String.t ;
      source_dest_check: AttributeBooleanValue.t option }
    let make ?attachment  ?description  ?dry_run  ?(groups= []) 
      ~network_interface_id  ?source_dest_check  () =
      {
        attachment;
        description;
        dry_run;
        groups;
        network_interface_id;
        source_dest_check
      }
    let parse xml =
      Some
        {
          attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               NetworkInterfaceAttachmentChanges.parse);
          description =
            (Util.option_bind (Xml.member "description" xml)
               AttributeValue.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse));
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               AttributeBooleanValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.source_dest_check
              (fun f ->
                 Query.Pair
                   ("SourceDestCheck", (AttributeBooleanValue.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.groups)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f ->
                Query.Pair ("Description", (AttributeValue.to_query f)));
           Util.option_map v.attachment
             (fun f ->
                Query.Pair
                  ("Attachment",
                    (NetworkInterfaceAttachmentChanges.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.attachment
                   (fun f ->
                      Ezxmlm.make_tag "attachment"
                        ([], (NetworkInterfaceAttachmentChanges.to_xml f)))])
               @
               [Util.option_map v.description
                  (fun f ->
                     Ezxmlm.make_tag "description"
                       ([], (AttributeValue.to_xml f)))])
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "SecurityGroupId"
                        ([], (SecurityGroupIdStringList.to_xml [x]))))
                v.groups))
            @
            [Some
               (Ezxmlm.make_tag "networkInterfaceId"
                  ([], (String.to_xml v.network_interface_id)))])
           @
           [Util.option_map v.source_dest_check
              (fun f ->
                 Ezxmlm.make_tag "sourceDestCheck"
                   ([], (AttributeBooleanValue.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.source_dest_check
              (fun f ->
                 ("source_dest_check", (AttributeBooleanValue.to_json f)));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id));
           Some ("groups", (SecurityGroupIdStringList.to_json v.groups));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (AttributeValue.to_json f)));
           Util.option_map v.attachment
             (fun f ->
                ("attachment", (NetworkInterfaceAttachmentChanges.to_json f)))])
    let of_json j =
      {
        attachment =
          (Util.option_map (Json.lookup j "attachment")
             NetworkInterfaceAttachmentChanges.of_json);
        description =
          (Util.option_map (Json.lookup j "description")
             AttributeValue.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        groups =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             AttributeBooleanValue.of_json)
      }
  end
module CreateVolumeRequest =
  struct
    type t =
      {
      availability_zone: String.t ;
      encrypted: Boolean.t option ;
      iops: Integer.t option ;
      kms_key_id: String.t option ;
      outpost_arn: String.t option ;
      size: Integer.t option ;
      snapshot_id: String.t option ;
      volume_type: VolumeType.t option ;
      dry_run: Boolean.t option ;
      tag_specifications: TagSpecificationList.t }
    let make ~availability_zone  ?encrypted  ?iops  ?kms_key_id  ?outpost_arn
       ?size  ?snapshot_id  ?volume_type  ?dry_run  ?(tag_specifications= [])
       () =
      {
        availability_zone;
        encrypted;
        iops;
        kms_key_id;
        outpost_arn;
        size;
        snapshot_id;
        volume_type;
        dry_run;
        tag_specifications
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Xml.required "AvailabilityZone"
               (Util.option_bind (Xml.member "AvailabilityZone" xml)
                  String.parse));
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          iops = (Util.option_bind (Xml.member "Iops" xml) Integer.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "KmsKeyId" xml) String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "OutpostArn" xml) String.parse);
          size = (Util.option_bind (Xml.member "Size" xml) Integer.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "SnapshotId" xml) String.parse);
          volume_type =
            (Util.option_bind (Xml.member "VolumeType" xml) VolumeType.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.volume_type
             (fun f -> Query.Pair ("VolumeType", (VolumeType.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.size
             (fun f -> Query.Pair ("Size", (Integer.to_query f)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Some
                       (Ezxmlm.make_tag "AvailabilityZone"
                          ([], (String.to_xml v.availability_zone)))])
                   @
                   [Util.option_map v.encrypted
                      (fun f ->
                         Ezxmlm.make_tag "encrypted" ([], (Boolean.to_xml f)))])
                  @
                  [Util.option_map v.iops
                     (fun f ->
                        Ezxmlm.make_tag "Iops" ([], (Integer.to_xml f)))])
                 @
                 [Util.option_map v.kms_key_id
                    (fun f ->
                       Ezxmlm.make_tag "KmsKeyId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.outpost_arn
                   (fun f ->
                      Ezxmlm.make_tag "OutpostArn" ([], (String.to_xml f)))])
               @
               [Util.option_map v.size
                  (fun f -> Ezxmlm.make_tag "Size" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.snapshot_id
                 (fun f ->
                    Ezxmlm.make_tag "SnapshotId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.volume_type
                (fun f ->
                   Ezxmlm.make_tag "VolumeType" ([], (VolumeType.to_xml f)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "TagSpecification"
                      ([], (TagSpecificationList.to_xml [x]))))
              v.tag_specifications))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.volume_type
             (fun f -> ("volume_type", (VolumeType.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.size (fun f -> ("size", (Integer.to_json f)));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Some ("availability_zone", (String.to_json v.availability_zone))])
    let of_json j =
      {
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        size = (Util.option_map (Json.lookup j "size") Integer.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        volume_type =
          (Util.option_map (Json.lookup j "volume_type") VolumeType.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module DescribePublicIpv4PoolsRequest =
  struct
    type t =
      {
      pool_ids: ValueStringList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(pool_ids= [])  ?next_token  ?max_results  () =
      { pool_ids; next_token; max_results }
    let parse xml =
      Some
        {
          pool_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "PoolId" xml)
                  ValueStringList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair ("PoolId", (ValueStringList.to_query v.pool_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "PoolId"
                        ([], (ValueStringList.to_xml [x])))) v.pool_ids))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("pool_ids", (ValueStringList.to_json v.pool_ids))])
    let of_json j =
      {
        pool_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "pool_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module EnableVpcClassicLinkRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      vpc_id: String.t }
    let make ?dry_run  ~vpc_id  () = { dry_run; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @ [Some (Ezxmlm.make_tag "vpcId" ([], (String.to_xml v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DeleteClientVpnEndpointResult =
  struct
    type t = {
      status: ClientVpnEndpointStatus.t option }
    let make ?status  () = { status }
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnEndpointStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair ("Status", (ClientVpnEndpointStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status"
                   ([], (ClientVpnEndpointStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (ClientVpnEndpointStatus.to_json f)))])
    let of_json j =
      {
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnEndpointStatus.of_json)
      }
  end
module DisassociateRouteTableRequest =
  struct
    type t = {
      association_id: String.t ;
      dry_run: Boolean.t option }
    let make ~association_id  ?dry_run  () = { association_id; dry_run }
    let parse xml =
      Some
        {
          association_id =
            (Xml.required "associationId"
               (Util.option_bind (Xml.member "associationId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AssociationId", (String.to_query v.association_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "associationId"
                  ([], (String.to_xml v.association_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("association_id", (String.to_json v.association_id))])
    let of_json j =
      {
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AdvertiseByoipCidrResult =
  struct
    type t = {
      byoip_cidr: ByoipCidr.t option }
    let make ?byoip_cidr  () = { byoip_cidr }
    let parse xml =
      Some
        {
          byoip_cidr =
            (Util.option_bind (Xml.member "byoipCidr" xml) ByoipCidr.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> Query.Pair ("ByoipCidr", (ByoipCidr.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.byoip_cidr
              (fun f ->
                 Ezxmlm.make_tag "byoipCidr" ([], (ByoipCidr.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> ("byoip_cidr", (ByoipCidr.to_json f)))])
    let of_json j =
      {
        byoip_cidr =
          (Util.option_map (Json.lookup j "byoip_cidr") ByoipCidr.of_json)
      }
  end
module CreateTransitGatewayRouteTableResult =
  struct
    type t =
      {
      transit_gateway_route_table: TransitGatewayRouteTable.t option }
    let make ?transit_gateway_route_table  () =
      { transit_gateway_route_table }
    let parse xml =
      Some
        {
          transit_gateway_route_table =
            (Util.option_bind (Xml.member "transitGatewayRouteTable" xml)
               TransitGatewayRouteTable.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_route_table
              (fun f ->
                 Query.Pair
                   ("TransitGatewayRouteTable",
                     (TransitGatewayRouteTable.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_route_table
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayRouteTable"
                   ([], (TransitGatewayRouteTable.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_route_table
              (fun f ->
                 ("transit_gateway_route_table",
                   (TransitGatewayRouteTable.to_json f)))])
    let of_json j =
      {
        transit_gateway_route_table =
          (Util.option_map (Json.lookup j "transit_gateway_route_table")
             TransitGatewayRouteTable.of_json)
      }
  end
module DeleteFpgaImageResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module ResetFpgaImageAttributeResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DeleteLaunchTemplateRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      launch_template_id: String.t option ;
      launch_template_name: String.t option }
    let make ?dry_run  ?launch_template_id  ?launch_template_name  () =
      { dry_run; launch_template_id; launch_template_name }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          launch_template_id =
            (Util.option_bind (Xml.member "LaunchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "LaunchTemplateName" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template_name
              (fun f ->
                 Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.launch_template_id
               (fun f ->
                  Ezxmlm.make_tag "LaunchTemplateId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.launch_template_name
              (fun f ->
                 Ezxmlm.make_tag "LaunchTemplateName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template_name
              (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json)
      }
  end
module UnassignIpv6AddressesRequest =
  struct
    type t =
      {
      ipv6_addresses: Ipv6AddressList.t ;
      network_interface_id: String.t }
    let make ~ipv6_addresses  ~network_interface_id  () =
      { ipv6_addresses; network_interface_id }
    let parse xml =
      Some
        {
          ipv6_addresses =
            (Xml.required "ipv6Addresses"
               (Util.option_bind (Xml.member "ipv6Addresses" xml)
                  Ipv6AddressList.parse));
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkInterfaceId",
                   (String.to_query v.network_interface_id)));
           Some
             (Query.Pair
                ("Ipv6Addresses",
                  (Ipv6AddressList.to_query v.ipv6_addresses)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ipv6Addresses"
                       ([], (Ipv6AddressList.to_xml [x])))) v.ipv6_addresses))
           @
           [Some
              (Ezxmlm.make_tag "networkInterfaceId"
                 ([], (String.to_xml v.network_interface_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("network_interface_id",
                (String.to_json v.network_interface_id));
           Some
             ("ipv6_addresses", (Ipv6AddressList.to_json v.ipv6_addresses))])
    let of_json j =
      {
        ipv6_addresses =
          (Ipv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")))
      }
  end
module GetTransitGatewayMulticastDomainAssociationsRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?transit_gateway_multicast_domain_id  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        transit_gateway_multicast_domain_id;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.transit_gateway_multicast_domain_id
                  (fun f ->
                     Ezxmlm.make_tag "TransitGatewayMulticastDomainId"
                       ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteLaunchTemplateVersionsResult =
  struct
    type t =
      {
      successfully_deleted_launch_template_versions:
        DeleteLaunchTemplateVersionsResponseSuccessSet.t ;
      unsuccessfully_deleted_launch_template_versions:
        DeleteLaunchTemplateVersionsResponseErrorSet.t }
    let make ?(successfully_deleted_launch_template_versions= []) 
      ?(unsuccessfully_deleted_launch_template_versions= [])  () =
      {
        successfully_deleted_launch_template_versions;
        unsuccessfully_deleted_launch_template_versions
      }
    let parse xml =
      Some
        {
          successfully_deleted_launch_template_versions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "successfullyDeletedLaunchTemplateVersionSet"
                     xml)
                  DeleteLaunchTemplateVersionsResponseSuccessSet.parse));
          unsuccessfully_deleted_launch_template_versions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "unsuccessfullyDeletedLaunchTemplateVersionSet"
                     xml) DeleteLaunchTemplateVersionsResponseErrorSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnsuccessfullyDeletedLaunchTemplateVersionSet",
                   (DeleteLaunchTemplateVersionsResponseErrorSet.to_query
                      v.unsuccessfully_deleted_launch_template_versions)));
           Some
             (Query.Pair
                ("SuccessfullyDeletedLaunchTemplateVersionSet",
                  (DeleteLaunchTemplateVersionsResponseSuccessSet.to_query
                     v.successfully_deleted_launch_template_versions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag
                       "successfullyDeletedLaunchTemplateVersionSet"
                       ([],
                         (DeleteLaunchTemplateVersionsResponseSuccessSet.to_xml
                            [x]))))
               v.successfully_deleted_launch_template_versions))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag
                      "unsuccessfullyDeletedLaunchTemplateVersionSet"
                      ([],
                        (DeleteLaunchTemplateVersionsResponseErrorSet.to_xml
                           [x]))))
              v.unsuccessfully_deleted_launch_template_versions))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessfully_deleted_launch_template_versions",
                (DeleteLaunchTemplateVersionsResponseErrorSet.to_json
                   v.unsuccessfully_deleted_launch_template_versions));
           Some
             ("successfully_deleted_launch_template_versions",
               (DeleteLaunchTemplateVersionsResponseSuccessSet.to_json
                  v.successfully_deleted_launch_template_versions))])
    let of_json j =
      {
        successfully_deleted_launch_template_versions =
          (DeleteLaunchTemplateVersionsResponseSuccessSet.of_json
             (Util.of_option_exn
                (Json.lookup j
                   "successfully_deleted_launch_template_versions")));
        unsuccessfully_deleted_launch_template_versions =
          (DeleteLaunchTemplateVersionsResponseErrorSet.of_json
             (Util.of_option_exn
                (Json.lookup j
                   "unsuccessfully_deleted_launch_template_versions")))
      }
  end
module DescribeKeyPairsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      key_names: KeyNameStringList.t ;
      key_pair_ids: KeyPairIdStringList.t ;
      dry_run: Boolean.t option }
    let make ?(filters= [])  ?(key_names= [])  ?(key_pair_ids= [])  ?dry_run 
      () = { filters; key_names; key_pair_ids; dry_run }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          key_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "KeyName" xml)
                  KeyNameStringList.parse));
          key_pair_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "KeyPairId" xml)
                  KeyPairIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("KeyPairId", (KeyPairIdStringList.to_query v.key_pair_ids)));
           Some
             (Query.Pair
                ("KeyName", (KeyNameStringList.to_query v.key_names)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "KeyName"
                        ([], (KeyNameStringList.to_xml [x])))) v.key_names))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "KeyPairId"
                       ([], (KeyPairIdStringList.to_xml [x]))))
               v.key_pair_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("key_pair_ids", (KeyPairIdStringList.to_json v.key_pair_ids));
           Some ("key_names", (KeyNameStringList.to_json v.key_names));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        key_names =
          (KeyNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "key_names")));
        key_pair_ids =
          (KeyPairIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "key_pair_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module RegisterTransitGatewayMulticastGroupSourcesResult =
  struct
    type t =
      {
      registered_multicast_group_sources:
        TransitGatewayMulticastRegisteredGroupSources.t option }
    let make ?registered_multicast_group_sources  () =
      { registered_multicast_group_sources }
    let parse xml =
      Some
        {
          registered_multicast_group_sources =
            (Util.option_bind
               (Xml.member "registeredMulticastGroupSources" xml)
               TransitGatewayMulticastRegisteredGroupSources.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.registered_multicast_group_sources
              (fun f ->
                 Query.Pair
                   ("RegisteredMulticastGroupSources",
                     (TransitGatewayMulticastRegisteredGroupSources.to_query
                        f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.registered_multicast_group_sources
              (fun f ->
                 Ezxmlm.make_tag "registeredMulticastGroupSources"
                   ([],
                     (TransitGatewayMulticastRegisteredGroupSources.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.registered_multicast_group_sources
              (fun f ->
                 ("registered_multicast_group_sources",
                   (TransitGatewayMulticastRegisteredGroupSources.to_json f)))])
    let of_json j =
      {
        registered_multicast_group_sources =
          (Util.option_map
             (Json.lookup j "registered_multicast_group_sources")
             TransitGatewayMulticastRegisteredGroupSources.of_json)
      }
  end
module UpdateSecurityGroupRuleDescriptionsEgressRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_id: String.t option ;
      group_name: String.t option ;
      ip_permissions: IpPermissionList.t }
    let make ?dry_run  ?group_id  ?group_name  ~ip_permissions  () =
      { dry_run; group_id; group_name; ip_permissions }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          group_id =
            (Util.option_bind (Xml.member "GroupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          ip_permissions =
            (Xml.required "IpPermissions"
               (Util.option_bind (Xml.member "IpPermissions" xml)
                  IpPermissionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("IpPermissions",
                   (IpPermissionList.to_query v.ip_permissions)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.group_id
                (fun f -> Ezxmlm.make_tag "GroupId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.group_name
               (fun f -> Ezxmlm.make_tag "GroupName" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "IpPermissions"
                      ([], (IpPermissionList.to_xml [x])))) v.ip_permissions))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")))
      }
  end
module RequestSpotInstancesResult =
  struct
    type t = {
      spot_instance_requests: SpotInstanceRequestList.t }
    let make ?(spot_instance_requests= [])  () = { spot_instance_requests }
    let parse xml =
      Some
        {
          spot_instance_requests =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotInstanceRequestSet" xml)
                  SpotInstanceRequestList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotInstanceRequestSet",
                   (SpotInstanceRequestList.to_query v.spot_instance_requests)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "spotInstanceRequestSet"
                      ([], (SpotInstanceRequestList.to_xml [x]))))
              v.spot_instance_requests))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_instance_requests",
                (SpotInstanceRequestList.to_json v.spot_instance_requests))])
    let of_json j =
      {
        spot_instance_requests =
          (SpotInstanceRequestList.of_json
             (Util.of_option_exn (Json.lookup j "spot_instance_requests")))
      }
  end
module ExportTransitGatewayRoutesRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      filters: FilterList.t ;
      s3_bucket: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ?(filters= [])  ~s3_bucket 
      ?dry_run  () =
      { transit_gateway_route_table_id; filters; s3_bucket; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          s3_bucket =
            (Xml.required "S3Bucket"
               (Util.option_bind (Xml.member "S3Bucket" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("S3Bucket", (String.to_query v.s3_bucket)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "TransitGatewayRouteTableId"
                    ([], (String.to_xml v.transit_gateway_route_table_id)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Some
               (Ezxmlm.make_tag "S3Bucket" ([], (String.to_xml v.s3_bucket)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("s3_bucket", (String.to_json v.s3_bucket));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        s3_bucket =
          (String.of_json (Util.of_option_exn (Json.lookup j "s3_bucket")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeReservedInstancesListingsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      reserved_instances_id: String.t option ;
      reserved_instances_listing_id: String.t option }
    let make ?(filters= [])  ?reserved_instances_id 
      ?reserved_instances_listing_id  () =
      { filters; reserved_instances_id; reserved_instances_listing_id }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse);
          reserved_instances_listing_id =
            (Util.option_bind (Xml.member "reservedInstancesListingId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_listing_id
              (fun f ->
                 Query.Pair
                   ("ReservedInstancesListingId", (String.to_query f)));
           Util.option_map v.reserved_instances_id
             (fun f ->
                Query.Pair ("ReservedInstancesId", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.reserved_instances_id
               (fun f ->
                  Ezxmlm.make_tag "reservedInstancesId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.reserved_instances_listing_id
              (fun f ->
                 Ezxmlm.make_tag "reservedInstancesListingId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_listing_id
              (fun f -> ("reserved_instances_listing_id", (String.to_json f)));
           Util.option_map v.reserved_instances_id
             (fun f -> ("reserved_instances_id", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json);
        reserved_instances_listing_id =
          (Util.option_map (Json.lookup j "reserved_instances_listing_id")
             String.of_json)
      }
  end
module MoveAddressToVpcResult =
  struct
    type t = {
      allocation_id: String.t option ;
      status: Status.t option }
    let make ?allocation_id  ?status  () = { allocation_id; status }
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) Status.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (Status.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.allocation_id
               (fun f ->
                  Ezxmlm.make_tag "allocationId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f -> Ezxmlm.make_tag "status" ([], (Status.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (Status.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let of_json j =
      {
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        status = (Util.option_map (Json.lookup j "status") Status.of_json)
      }
  end
module DeleteRouteRequest =
  struct
    type t =
      {
      destination_cidr_block: String.t option ;
      destination_ipv6_cidr_block: String.t option ;
      dry_run: Boolean.t option ;
      route_table_id: String.t }
    let make ?destination_cidr_block  ?destination_ipv6_cidr_block  ?dry_run 
      ~route_table_id  () =
      {
        destination_cidr_block;
        destination_ipv6_cidr_block;
        dry_run;
        route_table_id
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          destination_ipv6_cidr_block =
            (Util.option_bind (Xml.member "destinationIpv6CidrBlock" xml)
               String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RouteTableId", (String.to_query v.route_table_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f ->
                Query.Pair ("DestinationIpv6CidrBlock", (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.destination_cidr_block
                 (fun f ->
                    Ezxmlm.make_tag "destinationCidrBlock"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.destination_ipv6_cidr_block
                (fun f ->
                   Ezxmlm.make_tag "destinationIpv6CidrBlock"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "routeTableId"
                 ([], (String.to_xml v.route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("route_table_id", (String.to_json v.route_table_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f -> ("destination_ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        destination_ipv6_cidr_block =
          (Util.option_map (Json.lookup j "destination_ipv6_cidr_block")
             String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")))
      }
  end
module DeleteQueuedReservedInstancesResult =
  struct
    type t =
      {
      successful_queued_purchase_deletions:
        SuccessfulQueuedPurchaseDeletionSet.t ;
      failed_queued_purchase_deletions: FailedQueuedPurchaseDeletionSet.t }
    let make ?(successful_queued_purchase_deletions= []) 
      ?(failed_queued_purchase_deletions= [])  () =
      {
        successful_queued_purchase_deletions;
        failed_queued_purchase_deletions
      }
    let parse xml =
      Some
        {
          successful_queued_purchase_deletions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "successfulQueuedPurchaseDeletionSet" xml)
                  SuccessfulQueuedPurchaseDeletionSet.parse));
          failed_queued_purchase_deletions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "failedQueuedPurchaseDeletionSet" xml)
                  FailedQueuedPurchaseDeletionSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FailedQueuedPurchaseDeletionSet",
                   (FailedQueuedPurchaseDeletionSet.to_query
                      v.failed_queued_purchase_deletions)));
           Some
             (Query.Pair
                ("SuccessfulQueuedPurchaseDeletionSet",
                  (SuccessfulQueuedPurchaseDeletionSet.to_query
                     v.successful_queued_purchase_deletions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "successfulQueuedPurchaseDeletionSet"
                       ([], (SuccessfulQueuedPurchaseDeletionSet.to_xml [x]))))
               v.successful_queued_purchase_deletions))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "failedQueuedPurchaseDeletionSet"
                      ([], (FailedQueuedPurchaseDeletionSet.to_xml [x]))))
              v.failed_queued_purchase_deletions))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("failed_queued_purchase_deletions",
                (FailedQueuedPurchaseDeletionSet.to_json
                   v.failed_queued_purchase_deletions));
           Some
             ("successful_queued_purchase_deletions",
               (SuccessfulQueuedPurchaseDeletionSet.to_json
                  v.successful_queued_purchase_deletions))])
    let of_json j =
      {
        successful_queued_purchase_deletions =
          (SuccessfulQueuedPurchaseDeletionSet.of_json
             (Util.of_option_exn
                (Json.lookup j "successful_queued_purchase_deletions")));
        failed_queued_purchase_deletions =
          (FailedQueuedPurchaseDeletionSet.of_json
             (Util.of_option_exn
                (Json.lookup j "failed_queued_purchase_deletions")))
      }
  end
module GetLaunchTemplateDataResult =
  struct
    type t = {
      launch_template_data: ResponseLaunchTemplateData.t option }
    let make ?launch_template_data  () = { launch_template_data }
    let parse xml =
      Some
        {
          launch_template_data =
            (Util.option_bind (Xml.member "launchTemplateData" xml)
               ResponseLaunchTemplateData.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template_data
              (fun f ->
                 Query.Pair
                   ("LaunchTemplateData",
                     (ResponseLaunchTemplateData.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.launch_template_data
              (fun f ->
                 Ezxmlm.make_tag "launchTemplateData"
                   ([], (ResponseLaunchTemplateData.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template_data
              (fun f ->
                 ("launch_template_data",
                   (ResponseLaunchTemplateData.to_json f)))])
    let of_json j =
      {
        launch_template_data =
          (Util.option_map (Json.lookup j "launch_template_data")
             ResponseLaunchTemplateData.of_json)
      }
  end
module DeleteVpcRequest =
  struct
    type t = {
      vpc_id: String.t ;
      dry_run: Boolean.t option }
    let make ~vpc_id  ?dry_run  () = { vpc_id; dry_run }
    let parse xml =
      Some
        {
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some (Ezxmlm.make_tag "VpcId" ([], (String.to_xml v.vpc_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id))])
    let of_json j =
      {
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AssociateTransitGatewayMulticastDomainResult =
  struct
    type t =
      {
      associations: TransitGatewayMulticastDomainAssociations.t option }
    let make ?associations  () = { associations }
    let parse xml =
      Some
        {
          associations =
            (Util.option_bind (Xml.member "associations" xml)
               TransitGatewayMulticastDomainAssociations.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.associations
              (fun f ->
                 Query.Pair
                   ("Associations",
                     (TransitGatewayMulticastDomainAssociations.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.associations
              (fun f ->
                 Ezxmlm.make_tag "associations"
                   ([], (TransitGatewayMulticastDomainAssociations.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.associations
              (fun f ->
                 ("associations",
                   (TransitGatewayMulticastDomainAssociations.to_json f)))])
    let of_json j =
      {
        associations =
          (Util.option_map (Json.lookup j "associations")
             TransitGatewayMulticastDomainAssociations.of_json)
      }
  end
module DeleteNetworkInterfacePermissionResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module CancelExportTaskRequest =
  struct
    type t = {
      export_task_id: String.t }
    let make ~export_task_id  () = { export_task_id }
    let parse xml =
      Some
        {
          export_task_id =
            (Xml.required "exportTaskId"
               (Util.option_bind (Xml.member "exportTaskId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ExportTaskId", (String.to_query v.export_task_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "exportTaskId"
                 ([], (String.to_xml v.export_task_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("export_task_id", (String.to_json v.export_task_id))])
    let of_json j =
      {
        export_task_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "export_task_id")))
      }
  end
module DeleteTransitGatewayMulticastDomainRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_multicast_domain_id  ?dry_run  () =
      { transit_gateway_multicast_domain_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Xml.required "TransitGatewayMulticastDomainId"
               (Util.option_bind
                  (Xml.member "TransitGatewayMulticastDomainId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayMulticastDomainId",
                  (String.to_query v.transit_gateway_multicast_domain_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "TransitGatewayMulticastDomainId"
                  ([], (String.to_xml v.transit_gateway_multicast_domain_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_multicast_domain_id",
               (String.to_json v.transit_gateway_multicast_domain_id))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_multicast_domain_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeExportTasksResult =
  struct
    type t = {
      export_tasks: ExportTaskList.t }
    let make ?(export_tasks= [])  () = { export_tasks }
    let parse xml =
      Some
        {
          export_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "exportTaskSet" xml)
                  ExportTaskList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ExportTaskSet", (ExportTaskList.to_query v.export_tasks)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "exportTaskSet"
                      ([], (ExportTaskList.to_xml [x])))) v.export_tasks))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("export_tasks", (ExportTaskList.to_json v.export_tasks))])
    let of_json j =
      {
        export_tasks =
          (ExportTaskList.of_json
             (Util.of_option_exn (Json.lookup j "export_tasks")))
      }
  end
module UnmonitorInstancesResult =
  struct
    type t = {
      instance_monitorings: InstanceMonitoringList.t }
    let make ?(instance_monitorings= [])  () = { instance_monitorings }
    let parse xml =
      Some
        {
          instance_monitorings =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceMonitoringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceMonitoringList.to_query v.instance_monitorings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "instancesSet"
                      ([], (InstanceMonitoringList.to_xml [x]))))
              v.instance_monitorings))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_monitorings",
                (InstanceMonitoringList.to_json v.instance_monitorings))])
    let of_json j =
      {
        instance_monitorings =
          (InstanceMonitoringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_monitorings")))
      }
  end
module CreateTransitGatewayRouteResult =
  struct
    type t = {
      route: TransitGatewayRoute.t option }
    let make ?route  () = { route }
    let parse xml =
      Some
        {
          route =
            (Util.option_bind (Xml.member "route" xml)
               TransitGatewayRoute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f ->
                 Query.Pair ("Route", (TransitGatewayRoute.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.route
              (fun f ->
                 Ezxmlm.make_tag "route" ([], (TransitGatewayRoute.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> ("route", (TransitGatewayRoute.to_json f)))])
    let of_json j =
      {
        route =
          (Util.option_map (Json.lookup j "route")
             TransitGatewayRoute.of_json)
      }
  end
module DescribeClientVpnAuthorizationRulesRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      dry_run: Boolean.t option ;
      next_token: String.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option }
    let make ~client_vpn_endpoint_id  ?dry_run  ?next_token  ?(filters= []) 
      ?max_results  () =
      { client_vpn_endpoint_id; dry_run; next_token; filters; max_results }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "ClientVpnEndpointId"
                     ([], (String.to_xml v.client_vpn_endpoint_id)))])
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
               v.filters))
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DescribeSecurityGroupsResult =
  struct
    type t =
      {
      security_groups: SecurityGroupList.t ;
      next_token: String.t option }
    let make ?(security_groups= [])  ?next_token  () =
      { security_groups; next_token }
    let parse xml =
      Some
        {
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupInfo" xml)
                  SecurityGroupList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupInfo",
                  (SecurityGroupList.to_query v.security_groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "securityGroupInfo"
                       ([], (SecurityGroupList.to_xml [x]))))
               v.security_groups))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("security_groups",
               (SecurityGroupList.to_json v.security_groups))])
    let of_json j =
      {
        security_groups =
          (SecurityGroupList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteLocalGatewayRouteTableVpcAssociationResult =
  struct
    type t =
      {
      local_gateway_route_table_vpc_association:
        LocalGatewayRouteTableVpcAssociation.t option }
    let make ?local_gateway_route_table_vpc_association  () =
      { local_gateway_route_table_vpc_association }
    let parse xml =
      Some
        {
          local_gateway_route_table_vpc_association =
            (Util.option_bind
               (Xml.member "localGatewayRouteTableVpcAssociation" xml)
               LocalGatewayRouteTableVpcAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_vpc_association
              (fun f ->
                 Query.Pair
                   ("LocalGatewayRouteTableVpcAssociation",
                     (LocalGatewayRouteTableVpcAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.local_gateway_route_table_vpc_association
              (fun f ->
                 Ezxmlm.make_tag "localGatewayRouteTableVpcAssociation"
                   ([], (LocalGatewayRouteTableVpcAssociation.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_vpc_association
              (fun f ->
                 ("local_gateway_route_table_vpc_association",
                   (LocalGatewayRouteTableVpcAssociation.to_json f)))])
    let of_json j =
      {
        local_gateway_route_table_vpc_association =
          (Util.option_map
             (Json.lookup j "local_gateway_route_table_vpc_association")
             LocalGatewayRouteTableVpcAssociation.of_json)
      }
  end
module DeleteSubnetRequest =
  struct
    type t = {
      subnet_id: String.t ;
      dry_run: Boolean.t option }
    let make ~subnet_id  ?dry_run  () = { subnet_id; dry_run }
    let parse xml =
      Some
        {
          subnet_id =
            (Xml.required "SubnetId"
               (Util.option_bind (Xml.member "SubnetId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "SubnetId" ([], (String.to_xml v.subnet_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("subnet_id", (String.to_json v.subnet_id))])
    let of_json j =
      {
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateTrafficMirrorTargetResult =
  struct
    type t =
      {
      traffic_mirror_target: TrafficMirrorTarget.t option ;
      client_token: String.t option }
    let make ?traffic_mirror_target  ?client_token  () =
      { traffic_mirror_target; client_token }
    let parse xml =
      Some
        {
          traffic_mirror_target =
            (Util.option_bind (Xml.member "trafficMirrorTarget" xml)
               TrafficMirrorTarget.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.traffic_mirror_target
             (fun f ->
                Query.Pair
                  ("TrafficMirrorTarget", (TrafficMirrorTarget.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.traffic_mirror_target
               (fun f ->
                  Ezxmlm.make_tag "trafficMirrorTarget"
                    ([], (TrafficMirrorTarget.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.traffic_mirror_target
             (fun f ->
                ("traffic_mirror_target", (TrafficMirrorTarget.to_json f)))])
    let of_json j =
      {
        traffic_mirror_target =
          (Util.option_map (Json.lookup j "traffic_mirror_target")
             TrafficMirrorTarget.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeVpcEndpointServicesResult =
  struct
    type t =
      {
      service_names: ValueStringList.t ;
      service_details: ServiceDetailSet.t ;
      next_token: String.t option }
    let make ?(service_names= [])  ?(service_details= [])  ?next_token  () =
      { service_names; service_details; next_token }
    let parse xml =
      Some
        {
          service_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "serviceNameSet" xml)
                  ValueStringList.parse));
          service_details =
            (Util.of_option []
               (Util.option_bind (Xml.member "serviceDetailSet" xml)
                  ServiceDetailSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ServiceDetailSet",
                  (ServiceDetailSet.to_query v.service_details)));
           Some
             (Query.Pair
                ("ServiceNameSet",
                  (ValueStringList.to_query v.service_names)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "serviceNameSet"
                        ([], (ValueStringList.to_xml [x])))) v.service_names))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "serviceDetailSet"
                       ([], (ServiceDetailSet.to_xml [x]))))
               v.service_details))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("service_details",
               (ServiceDetailSet.to_json v.service_details));
           Some ("service_names", (ValueStringList.to_json v.service_names))])
    let of_json j =
      {
        service_names =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "service_names")));
        service_details =
          (ServiceDetailSet.of_json
             (Util.of_option_exn (Json.lookup j "service_details")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteTransitGatewayVpcAttachmentResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.t option }
    let make ?transit_gateway_vpc_attachment  () =
      { transit_gateway_vpc_attachment }
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachment =
            (Util.option_bind (Xml.member "transitGatewayVpcAttachment" xml)
               TransitGatewayVpcAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayVpcAttachment",
                     (TransitGatewayVpcAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayVpcAttachment"
                   ([], (TransitGatewayVpcAttachment.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 ("transit_gateway_vpc_attachment",
                   (TransitGatewayVpcAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_vpc_attachment =
          (Util.option_map (Json.lookup j "transit_gateway_vpc_attachment")
             TransitGatewayVpcAttachment.of_json)
      }
  end
module CancelCapacityReservationRequest =
  struct
    type t = {
      capacity_reservation_id: String.t ;
      dry_run: Boolean.t option }
    let make ~capacity_reservation_id  ?dry_run  () =
      { capacity_reservation_id; dry_run }
    let parse xml =
      Some
        {
          capacity_reservation_id =
            (Xml.required "CapacityReservationId"
               (Util.option_bind (Xml.member "CapacityReservationId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("CapacityReservationId",
                  (String.to_query v.capacity_reservation_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "CapacityReservationId"
                  ([], (String.to_xml v.capacity_reservation_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("capacity_reservation_id",
               (String.to_json v.capacity_reservation_id))])
    let of_json j =
      {
        capacity_reservation_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "capacity_reservation_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module GetConsoleOutputResult =
  struct
    type t =
      {
      instance_id: String.t option ;
      output: String.t option ;
      timestamp: DateTime.t option }
    let make ?instance_id  ?output  ?timestamp  () =
      { instance_id; output; timestamp }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          output = (Util.option_bind (Xml.member "output" xml) String.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.output
             (fun f -> Query.Pair ("Output", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.instance_id
                (fun f ->
                   Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.output
               (fun f -> Ezxmlm.make_tag "output" ([], (String.to_xml f)))])
           @
           [Util.option_map v.timestamp
              (fun f -> Ezxmlm.make_tag "timestamp" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.output (fun f -> ("output", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        output = (Util.option_map (Json.lookup j "output") String.of_json);
        timestamp =
          (Util.option_map (Json.lookup j "timestamp") DateTime.of_json)
      }
  end
module DescribeClientVpnEndpointsResult =
  struct
    type t =
      {
      client_vpn_endpoints: EndpointSet.t ;
      next_token: String.t option }
    let make ?(client_vpn_endpoints= [])  ?next_token  () =
      { client_vpn_endpoints; next_token }
    let parse xml =
      Some
        {
          client_vpn_endpoints =
            (Util.of_option []
               (Util.option_bind (Xml.member "clientVpnEndpoint" xml)
                  EndpointSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpoint",
                  (EndpointSet.to_query v.client_vpn_endpoints)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "clientVpnEndpoint"
                       ([], (EndpointSet.to_xml [x]))))
               v.client_vpn_endpoints))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("client_vpn_endpoints",
               (EndpointSet.to_json v.client_vpn_endpoints))])
    let of_json j =
      {
        client_vpn_endpoints =
          (EndpointSet.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoints")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyInstanceCapacityReservationAttributesResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DeleteVpnConnectionRouteRequest =
  struct
    type t = {
      destination_cidr_block: String.t ;
      vpn_connection_id: String.t }
    let make ~destination_cidr_block  ~vpn_connection_id  () =
      { destination_cidr_block; vpn_connection_id }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          vpn_connection_id =
            (Xml.required "VpnConnectionId"
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpnConnectionId", (String.to_query v.vpn_connection_id)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "DestinationCidrBlock"
                  ([], (String.to_xml v.destination_cidr_block)))])
           @
           [Some
              (Ezxmlm.make_tag "VpnConnectionId"
                 ([], (String.to_xml v.vpn_connection_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpn_connection_id", (String.to_json v.vpn_connection_id));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block))])
    let of_json j =
      {
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")))
      }
  end
module CreateSpotDatafeedSubscriptionRequest =
  struct
    type t =
      {
      bucket: String.t ;
      dry_run: Boolean.t option ;
      prefix: String.t option }
    let make ~bucket  ?dry_run  ?prefix  () = { bucket; dry_run; prefix }
    let parse xml =
      Some
        {
          bucket =
            (Xml.required "bucket"
               (Util.option_bind (Xml.member "bucket" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          prefix = (Util.option_bind (Xml.member "prefix" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.prefix
              (fun f -> Query.Pair ("Prefix", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Bucket", (String.to_query v.bucket)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some (Ezxmlm.make_tag "bucket" ([], (String.to_xml v.bucket)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.prefix
              (fun f -> Ezxmlm.make_tag "prefix" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.prefix
              (fun f -> ("prefix", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("bucket", (String.to_json v.bucket))])
    let of_json j =
      {
        bucket =
          (String.of_json (Util.of_option_exn (Json.lookup j "bucket")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        prefix = (Util.option_map (Json.lookup j "prefix") String.of_json)
      }
  end
module DescribeTransitGatewayAttachmentsRequest =
  struct
    type t =
      {
      transit_gateway_attachment_ids: TransitGatewayAttachmentIdStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(transit_gateway_attachment_ids= [])  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        transit_gateway_attachment_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentIds" xml)
                  TransitGatewayAttachmentIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentIds",
                  (TransitGatewayAttachmentIdStringList.to_query
                     v.transit_gateway_attachment_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "TransitGatewayAttachmentIds"
                          ([],
                            (TransitGatewayAttachmentIdStringList.to_xml [x]))))
                  v.transit_gateway_attachment_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_attachment_ids",
               (TransitGatewayAttachmentIdStringList.to_json
                  v.transit_gateway_attachment_ids))])
    let of_json j =
      {
        transit_gateway_attachment_ids =
          (TransitGatewayAttachmentIdStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateFleetRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      client_token: String.t option ;
      spot_options: SpotOptionsRequest.t option ;
      on_demand_options: OnDemandOptionsRequest.t option ;
      excess_capacity_termination_policy:
        FleetExcessCapacityTerminationPolicy.t option ;
      launch_template_configs: FleetLaunchTemplateConfigListRequest.t ;
      target_capacity_specification: TargetCapacitySpecificationRequest.t ;
      terminate_instances_with_expiration: Boolean.t option ;
      type_: FleetType.t option ;
      valid_from: DateTime.t option ;
      valid_until: DateTime.t option ;
      replace_unhealthy_instances: Boolean.t option ;
      tag_specifications: TagSpecificationList.t }
    let make ?dry_run  ?client_token  ?spot_options  ?on_demand_options 
      ?excess_capacity_termination_policy  ~launch_template_configs 
      ~target_capacity_specification  ?terminate_instances_with_expiration 
      ?type_  ?valid_from  ?valid_until  ?replace_unhealthy_instances 
      ?(tag_specifications= [])  () =
      {
        dry_run;
        client_token;
        spot_options;
        on_demand_options;
        excess_capacity_termination_policy;
        launch_template_configs;
        target_capacity_specification;
        terminate_instances_with_expiration;
        type_;
        valid_from;
        valid_until;
        replace_unhealthy_instances;
        tag_specifications
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          spot_options =
            (Util.option_bind (Xml.member "SpotOptions" xml)
               SpotOptionsRequest.parse);
          on_demand_options =
            (Util.option_bind (Xml.member "OnDemandOptions" xml)
               OnDemandOptionsRequest.parse);
          excess_capacity_termination_policy =
            (Util.option_bind
               (Xml.member "ExcessCapacityTerminationPolicy" xml)
               FleetExcessCapacityTerminationPolicy.parse);
          launch_template_configs =
            (Xml.required "LaunchTemplateConfigs"
               (Util.option_bind (Xml.member "LaunchTemplateConfigs" xml)
                  FleetLaunchTemplateConfigListRequest.parse));
          target_capacity_specification =
            (Xml.required "TargetCapacitySpecification"
               (Util.option_bind
                  (Xml.member "TargetCapacitySpecification" xml)
                  TargetCapacitySpecificationRequest.parse));
          terminate_instances_with_expiration =
            (Util.option_bind
               (Xml.member "TerminateInstancesWithExpiration" xml)
               Boolean.parse);
          type_ = (Util.option_bind (Xml.member "Type" xml) FleetType.parse);
          valid_from =
            (Util.option_bind (Xml.member "ValidFrom" xml) DateTime.parse);
          valid_until =
            (Util.option_bind (Xml.member "ValidUntil" xml) DateTime.parse);
          replace_unhealthy_instances =
            (Util.option_bind (Xml.member "ReplaceUnhealthyInstances" xml)
               Boolean.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.replace_unhealthy_instances
             (fun f ->
                Query.Pair
                  ("ReplaceUnhealthyInstances", (Boolean.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.valid_from
             (fun f -> Query.Pair ("ValidFrom", (DateTime.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (FleetType.to_query f)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                Query.Pair
                  ("TerminateInstancesWithExpiration", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TargetCapacitySpecification",
                  (TargetCapacitySpecificationRequest.to_query
                     v.target_capacity_specification)));
           Some
             (Query.Pair
                ("LaunchTemplateConfigs",
                  (FleetLaunchTemplateConfigListRequest.to_query
                     v.launch_template_configs)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                Query.Pair
                  ("ExcessCapacityTerminationPolicy",
                    (FleetExcessCapacityTerminationPolicy.to_query f)));
           Util.option_map v.on_demand_options
             (fun f ->
                Query.Pair
                  ("OnDemandOptions", (OnDemandOptionsRequest.to_query f)));
           Util.option_map v.spot_options
             (fun f ->
                Query.Pair ("SpotOptions", (SpotOptionsRequest.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.dry_run
                          (fun f ->
                             Ezxmlm.make_tag "DryRun"
                               ([], (Boolean.to_xml f)))])
                      @
                      [Util.option_map v.client_token
                         (fun f ->
                            Ezxmlm.make_tag "ClientToken"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.spot_options
                        (fun f ->
                           Ezxmlm.make_tag "SpotOptions"
                             ([], (SpotOptionsRequest.to_xml f)))])
                    @
                    [Util.option_map v.on_demand_options
                       (fun f ->
                          Ezxmlm.make_tag "OnDemandOptions"
                            ([], (OnDemandOptionsRequest.to_xml f)))])
                   @
                   [Util.option_map v.excess_capacity_termination_policy
                      (fun f ->
                         Ezxmlm.make_tag "ExcessCapacityTerminationPolicy"
                           ([],
                             (FleetExcessCapacityTerminationPolicy.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "LaunchTemplateConfigs"
                             ([],
                               (FleetLaunchTemplateConfigListRequest.to_xml
                                  [x])))) v.launch_template_configs))
                 @
                 [Some
                    (Ezxmlm.make_tag "TargetCapacitySpecification"
                       ([],
                         (TargetCapacitySpecificationRequest.to_xml
                            v.target_capacity_specification)))])
                @
                [Util.option_map v.terminate_instances_with_expiration
                   (fun f ->
                      Ezxmlm.make_tag "TerminateInstancesWithExpiration"
                        ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.type_
                  (fun f -> Ezxmlm.make_tag "Type" ([], (FleetType.to_xml f)))])
              @
              [Util.option_map v.valid_from
                 (fun f ->
                    Ezxmlm.make_tag "ValidFrom" ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.valid_until
                (fun f ->
                   Ezxmlm.make_tag "ValidUntil" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.replace_unhealthy_instances
               (fun f ->
                  Ezxmlm.make_tag "ReplaceUnhealthyInstances"
                    ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "TagSpecification"
                      ([], (TagSpecificationList.to_xml [x]))))
              v.tag_specifications))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.replace_unhealthy_instances
             (fun f -> ("replace_unhealthy_instances", (Boolean.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.valid_from
             (fun f -> ("valid_from", (DateTime.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (FleetType.to_json f)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                ("terminate_instances_with_expiration", (Boolean.to_json f)));
           Some
             ("target_capacity_specification",
               (TargetCapacitySpecificationRequest.to_json
                  v.target_capacity_specification));
           Some
             ("launch_template_configs",
               (FleetLaunchTemplateConfigListRequest.to_json
                  v.launch_template_configs));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                ("excess_capacity_termination_policy",
                  (FleetExcessCapacityTerminationPolicy.to_json f)));
           Util.option_map v.on_demand_options
             (fun f ->
                ("on_demand_options", (OnDemandOptionsRequest.to_json f)));
           Util.option_map v.spot_options
             (fun f -> ("spot_options", (SpotOptionsRequest.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        spot_options =
          (Util.option_map (Json.lookup j "spot_options")
             SpotOptionsRequest.of_json);
        on_demand_options =
          (Util.option_map (Json.lookup j "on_demand_options")
             OnDemandOptionsRequest.of_json);
        excess_capacity_termination_policy =
          (Util.option_map
             (Json.lookup j "excess_capacity_termination_policy")
             FleetExcessCapacityTerminationPolicy.of_json);
        launch_template_configs =
          (FleetLaunchTemplateConfigListRequest.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_configs")));
        target_capacity_specification =
          (TargetCapacitySpecificationRequest.of_json
             (Util.of_option_exn
                (Json.lookup j "target_capacity_specification")));
        terminate_instances_with_expiration =
          (Util.option_map
             (Json.lookup j "terminate_instances_with_expiration")
             Boolean.of_json);
        type_ = (Util.option_map (Json.lookup j "type_") FleetType.of_json);
        valid_from =
          (Util.option_map (Json.lookup j "valid_from") DateTime.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        replace_unhealthy_instances =
          (Util.option_map (Json.lookup j "replace_unhealthy_instances")
             Boolean.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module RejectVpcEndpointConnectionsResult =
  struct
    type t = {
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemSet.to_xml [x])))) v.unsuccessful))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let of_json j =
      {
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module ResetEbsDefaultKmsKeyIdRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteFlowLogsRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      flow_log_ids: ValueStringList.t }
    let make ?dry_run  ~flow_log_ids  () = { dry_run; flow_log_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          flow_log_ids =
            (Xml.required "FlowLogId"
               (Util.option_bind (Xml.member "FlowLogId" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FlowLogId", (ValueStringList.to_query v.flow_log_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "FlowLogId"
                      ([], (ValueStringList.to_xml [x])))) v.flow_log_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("flow_log_ids", (ValueStringList.to_json v.flow_log_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        flow_log_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "flow_log_ids")))
      }
  end
module EnableVgwRoutePropagationRequest =
  struct
    type t = {
      gateway_id: String.t ;
      route_table_id: String.t }
    let make ~gateway_id  ~route_table_id  () =
      { gateway_id; route_table_id }
    let parse xml =
      Some
        {
          gateway_id =
            (Xml.required "GatewayId"
               (Util.option_bind (Xml.member "GatewayId" xml) String.parse));
          route_table_id =
            (Xml.required "RouteTableId"
               (Util.option_bind (Xml.member "RouteTableId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RouteTableId", (String.to_query v.route_table_id)));
           Some (Query.Pair ("GatewayId", (String.to_query v.gateway_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "GatewayId"
                  ([], (String.to_xml v.gateway_id)))])
           @
           [Some
              (Ezxmlm.make_tag "RouteTableId"
                 ([], (String.to_xml v.route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("route_table_id", (String.to_json v.route_table_id));
           Some ("gateway_id", (String.to_json v.gateway_id))])
    let of_json j =
      {
        gateway_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "gateway_id")));
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")))
      }
  end
module DeregisterTransitGatewayMulticastGroupSourcesResult =
  struct
    type t =
      {
      deregistered_multicast_group_sources:
        TransitGatewayMulticastDeregisteredGroupSources.t option }
    let make ?deregistered_multicast_group_sources  () =
      { deregistered_multicast_group_sources }
    let parse xml =
      Some
        {
          deregistered_multicast_group_sources =
            (Util.option_bind
               (Xml.member "deregisteredMulticastGroupSources" xml)
               TransitGatewayMulticastDeregisteredGroupSources.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.deregistered_multicast_group_sources
              (fun f ->
                 Query.Pair
                   ("DeregisteredMulticastGroupSources",
                     (TransitGatewayMulticastDeregisteredGroupSources.to_query
                        f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.deregistered_multicast_group_sources
              (fun f ->
                 Ezxmlm.make_tag "deregisteredMulticastGroupSources"
                   ([],
                     (TransitGatewayMulticastDeregisteredGroupSources.to_xml
                        f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.deregistered_multicast_group_sources
              (fun f ->
                 ("deregistered_multicast_group_sources",
                   (TransitGatewayMulticastDeregisteredGroupSources.to_json f)))])
    let of_json j =
      {
        deregistered_multicast_group_sources =
          (Util.option_map
             (Json.lookup j "deregistered_multicast_group_sources")
             TransitGatewayMulticastDeregisteredGroupSources.of_json)
      }
  end
module DescribeInternetGatewaysResult =
  struct
    type t =
      {
      internet_gateways: InternetGatewayList.t ;
      next_token: String.t option }
    let make ?(internet_gateways= [])  ?next_token  () =
      { internet_gateways; next_token }
    let parse xml =
      Some
        {
          internet_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "internetGatewaySet" xml)
                  InternetGatewayList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InternetGatewaySet",
                  (InternetGatewayList.to_query v.internet_gateways)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "internetGatewaySet"
                       ([], (InternetGatewayList.to_xml [x]))))
               v.internet_gateways))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("internet_gateways",
               (InternetGatewayList.to_json v.internet_gateways))])
    let of_json j =
      {
        internet_gateways =
          (InternetGatewayList.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateways")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeNetworkInterfacesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      network_interface_ids: NetworkInterfaceIdList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?dry_run  ?(network_interface_ids= []) 
      ?next_token  ?max_results  () =
      { filters; dry_run; network_interface_ids; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_interface_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterfaceId" xml)
                  NetworkInterfaceIdList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (NetworkInterfaceIdList.to_query v.network_interface_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "filter"
                          ([], (FilterList.to_xml [x])))) v.filters))
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "NetworkInterfaceId"
                        ([], (NetworkInterfaceIdList.to_xml [x]))))
                v.network_interface_ids))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("network_interface_ids",
               (NetworkInterfaceIdList.to_json v.network_interface_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_interface_ids =
          (NetworkInterfaceIdList.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module CreateLaunchTemplateRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      client_token: String.t option ;
      launch_template_name: String.t ;
      version_description: String.t option ;
      launch_template_data: RequestLaunchTemplateData.t ;
      tag_specifications: TagSpecificationList.t }
    let make ?dry_run  ?client_token  ~launch_template_name 
      ?version_description  ~launch_template_data  ?(tag_specifications= []) 
      () =
      {
        dry_run;
        client_token;
        launch_template_name;
        version_description;
        launch_template_data;
        tag_specifications
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          launch_template_name =
            (Xml.required "LaunchTemplateName"
               (Util.option_bind (Xml.member "LaunchTemplateName" xml)
                  String.parse));
          version_description =
            (Util.option_bind (Xml.member "VersionDescription" xml)
               String.parse);
          launch_template_data =
            (Xml.required "LaunchTemplateData"
               (Util.option_bind (Xml.member "LaunchTemplateData" xml)
                  RequestLaunchTemplateData.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Some
             (Query.Pair
                ("LaunchTemplateData",
                  (RequestLaunchTemplateData.to_query v.launch_template_data)));
           Util.option_map v.version_description
             (fun f -> Query.Pair ("VersionDescription", (String.to_query f)));
           Some
             (Query.Pair
                ("LaunchTemplateName",
                  (String.to_query v.launch_template_name)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.dry_run
                   (fun f ->
                      Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.client_token
                  (fun f ->
                     Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
              @
              [Some
                 (Ezxmlm.make_tag "LaunchTemplateName"
                    ([], (String.to_xml v.launch_template_name)))])
             @
             [Util.option_map v.version_description
                (fun f ->
                   Ezxmlm.make_tag "VersionDescription"
                     ([], (String.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "LaunchTemplateData"
                  ([],
                    (RequestLaunchTemplateData.to_xml v.launch_template_data)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "TagSpecification"
                      ([], (TagSpecificationList.to_xml [x]))))
              v.tag_specifications))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Some
             ("launch_template_data",
               (RequestLaunchTemplateData.to_json v.launch_template_data));
           Util.option_map v.version_description
             (fun f -> ("version_description", (String.to_json f)));
           Some
             ("launch_template_name",
               (String.to_json v.launch_template_name));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        launch_template_name =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_name")));
        version_description =
          (Util.option_map (Json.lookup j "version_description")
             String.of_json);
        launch_template_data =
          (RequestLaunchTemplateData.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_data")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module DescribeAccountAttributesRequest =
  struct
    type t =
      {
      attribute_names: AccountAttributeNameStringList.t ;
      dry_run: Boolean.t option }
    let make ?(attribute_names= [])  ?dry_run  () =
      { attribute_names; dry_run }
    let parse xml =
      Some
        {
          attribute_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "attributeName" xml)
                  AccountAttributeNameStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AttributeName",
                  (AccountAttributeNameStringList.to_query v.attribute_names)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "attributeName"
                       ([], (AccountAttributeNameStringList.to_xml [x]))))
               v.attribute_names))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("attribute_names",
               (AccountAttributeNameStringList.to_json v.attribute_names))])
    let of_json j =
      {
        attribute_names =
          (AccountAttributeNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "attribute_names")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeConversionTasksRequest =
  struct
    type t =
      {
      conversion_task_ids: ConversionIdStringList.t ;
      dry_run: Boolean.t option }
    let make ?(conversion_task_ids= [])  ?dry_run  () =
      { conversion_task_ids; dry_run }
    let parse xml =
      Some
        {
          conversion_task_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "conversionTaskId" xml)
                  ConversionIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ConversionTaskId",
                  (ConversionIdStringList.to_query v.conversion_task_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "conversionTaskId"
                       ([], (ConversionIdStringList.to_xml [x]))))
               v.conversion_task_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("conversion_task_ids",
               (ConversionIdStringList.to_json v.conversion_task_ids))])
    let of_json j =
      {
        conversion_task_ids =
          (ConversionIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "conversion_task_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisassociateTransitGatewayMulticastDomainRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      transit_gateway_attachment_id: String.t option ;
      subnet_ids: ValueStringList.t ;
      dry_run: Boolean.t option }
    let make ?transit_gateway_multicast_domain_id 
      ?transit_gateway_attachment_id  ?(subnet_ids= [])  ?dry_run  () =
      {
        transit_gateway_multicast_domain_id;
        transit_gateway_attachment_id;
        subnet_ids;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse);
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "TransitGatewayAttachmentId" xml)
               String.parse);
          subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SubnetIds" xml)
                  ValueStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SubnetIds", (ValueStringList.to_query v.subnet_ids)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.transit_gateway_multicast_domain_id
                 (fun f ->
                    Ezxmlm.make_tag "TransitGatewayMulticastDomainId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.transit_gateway_attachment_id
                (fun f ->
                   Ezxmlm.make_tag "TransitGatewayAttachmentId"
                     ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "SubnetIds"
                       ([], (ValueStringList.to_xml [x])))) v.subnet_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("subnet_ids", (ValueStringList.to_json v.subnet_ids));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        subnet_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "subnet_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyVpcEndpointRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_endpoint_id: String.t ;
      reset_policy: Boolean.t option ;
      policy_document: String.t option ;
      add_route_table_ids: ValueStringList.t ;
      remove_route_table_ids: ValueStringList.t ;
      add_subnet_ids: ValueStringList.t ;
      remove_subnet_ids: ValueStringList.t ;
      add_security_group_ids: ValueStringList.t ;
      remove_security_group_ids: ValueStringList.t ;
      private_dns_enabled: Boolean.t option }
    let make ?dry_run  ~vpc_endpoint_id  ?reset_policy  ?policy_document 
      ?(add_route_table_ids= [])  ?(remove_route_table_ids= []) 
      ?(add_subnet_ids= [])  ?(remove_subnet_ids= []) 
      ?(add_security_group_ids= [])  ?(remove_security_group_ids= []) 
      ?private_dns_enabled  () =
      {
        dry_run;
        vpc_endpoint_id;
        reset_policy;
        policy_document;
        add_route_table_ids;
        remove_route_table_ids;
        add_subnet_ids;
        remove_subnet_ids;
        add_security_group_ids;
        remove_security_group_ids;
        private_dns_enabled
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          vpc_endpoint_id =
            (Xml.required "VpcEndpointId"
               (Util.option_bind (Xml.member "VpcEndpointId" xml)
                  String.parse));
          reset_policy =
            (Util.option_bind (Xml.member "ResetPolicy" xml) Boolean.parse);
          policy_document =
            (Util.option_bind (Xml.member "PolicyDocument" xml) String.parse);
          add_route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddRouteTableId" xml)
                  ValueStringList.parse));
          remove_route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveRouteTableId" xml)
                  ValueStringList.parse));
          add_subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddSubnetId" xml)
                  ValueStringList.parse));
          remove_subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveSubnetId" xml)
                  ValueStringList.parse));
          add_security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddSecurityGroupId" xml)
                  ValueStringList.parse));
          remove_security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveSecurityGroupId" xml)
                  ValueStringList.parse));
          private_dns_enabled =
            (Util.option_bind (Xml.member "PrivateDnsEnabled" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_dns_enabled
              (fun f ->
                 Query.Pair ("PrivateDnsEnabled", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("RemoveSecurityGroupId",
                  (ValueStringList.to_query v.remove_security_group_ids)));
           Some
             (Query.Pair
                ("AddSecurityGroupId",
                  (ValueStringList.to_query v.add_security_group_ids)));
           Some
             (Query.Pair
                ("RemoveSubnetId",
                  (ValueStringList.to_query v.remove_subnet_ids)));
           Some
             (Query.Pair
                ("AddSubnetId", (ValueStringList.to_query v.add_subnet_ids)));
           Some
             (Query.Pair
                ("RemoveRouteTableId",
                  (ValueStringList.to_query v.remove_route_table_ids)));
           Some
             (Query.Pair
                ("AddRouteTableId",
                  (ValueStringList.to_query v.add_route_table_ids)));
           Util.option_map v.policy_document
             (fun f -> Query.Pair ("PolicyDocument", (String.to_query f)));
           Util.option_map v.reset_policy
             (fun f -> Query.Pair ("ResetPolicy", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("VpcEndpointId", (String.to_query v.vpc_endpoint_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.dry_run
                        (fun f ->
                           Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
                    @
                    [Some
                       (Ezxmlm.make_tag "VpcEndpointId"
                          ([], (String.to_xml v.vpc_endpoint_id)))])
                   @
                   [Util.option_map v.reset_policy
                      (fun f ->
                         Ezxmlm.make_tag "ResetPolicy"
                           ([], (Boolean.to_xml f)))])
                  @
                  [Util.option_map v.policy_document
                     (fun f ->
                        Ezxmlm.make_tag "PolicyDocument"
                          ([], (String.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "AddRouteTableId"
                            ([], (ValueStringList.to_xml [x]))))
                    v.add_route_table_ids))
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "RemoveRouteTableId"
                           ([], (ValueStringList.to_xml [x]))))
                   v.remove_route_table_ids))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "AddSubnetId"
                          ([], (ValueStringList.to_xml [x]))))
                  v.add_subnet_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "RemoveSubnetId"
                         ([], (ValueStringList.to_xml [x]))))
                 v.remove_subnet_ids))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "AddSecurityGroupId"
                        ([], (ValueStringList.to_xml [x]))))
                v.add_security_group_ids))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "RemoveSecurityGroupId"
                       ([], (ValueStringList.to_xml [x]))))
               v.remove_security_group_ids))
           @
           [Util.option_map v.private_dns_enabled
              (fun f ->
                 Ezxmlm.make_tag "PrivateDnsEnabled" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_dns_enabled
              (fun f -> ("private_dns_enabled", (Boolean.to_json f)));
           Some
             ("remove_security_group_ids",
               (ValueStringList.to_json v.remove_security_group_ids));
           Some
             ("add_security_group_ids",
               (ValueStringList.to_json v.add_security_group_ids));
           Some
             ("remove_subnet_ids",
               (ValueStringList.to_json v.remove_subnet_ids));
           Some
             ("add_subnet_ids", (ValueStringList.to_json v.add_subnet_ids));
           Some
             ("remove_route_table_ids",
               (ValueStringList.to_json v.remove_route_table_ids));
           Some
             ("add_route_table_ids",
               (ValueStringList.to_json v.add_route_table_ids));
           Util.option_map v.policy_document
             (fun f -> ("policy_document", (String.to_json f)));
           Util.option_map v.reset_policy
             (fun f -> ("reset_policy", (Boolean.to_json f)));
           Some ("vpc_endpoint_id", (String.to_json v.vpc_endpoint_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoint_id")));
        reset_policy =
          (Util.option_map (Json.lookup j "reset_policy") Boolean.of_json);
        policy_document =
          (Util.option_map (Json.lookup j "policy_document") String.of_json);
        add_route_table_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "add_route_table_ids")));
        remove_route_table_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "remove_route_table_ids")));
        add_subnet_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "add_subnet_ids")));
        remove_subnet_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "remove_subnet_ids")));
        add_security_group_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "add_security_group_ids")));
        remove_security_group_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "remove_security_group_ids")));
        private_dns_enabled =
          (Util.option_map (Json.lookup j "private_dns_enabled")
             Boolean.of_json)
      }
  end
module ModifyVolumeAttributeRequest =
  struct
    type t =
      {
      auto_enable_i_o: AttributeBooleanValue.t option ;
      volume_id: String.t ;
      dry_run: Boolean.t option }
    let make ?auto_enable_i_o  ~volume_id  ?dry_run  () =
      { auto_enable_i_o; volume_id; dry_run }
    let parse xml =
      Some
        {
          auto_enable_i_o =
            (Util.option_bind (Xml.member "AutoEnableIO" xml)
               AttributeBooleanValue.parse);
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.auto_enable_i_o
             (fun f ->
                Query.Pair
                  ("AutoEnableIO", (AttributeBooleanValue.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.auto_enable_i_o
                (fun f ->
                   Ezxmlm.make_tag "AutoEnableIO"
                     ([], (AttributeBooleanValue.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "VolumeId" ([], (String.to_xml v.volume_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.auto_enable_i_o
             (fun f -> ("auto_enable_i_o", (AttributeBooleanValue.to_json f)))])
    let of_json j =
      {
        auto_enable_i_o =
          (Util.option_map (Json.lookup j "auto_enable_i_o")
             AttributeBooleanValue.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisableTransitGatewayRouteTablePropagationRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ~transit_gateway_attachment_id 
      ?dry_run  () =
      {
        transit_gateway_route_table_id;
        transit_gateway_attachment_id;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "TransitGatewayRouteTableId"
                   ([], (String.to_xml v.transit_gateway_route_table_id)))])
            @
            [Some
               (Ezxmlm.make_tag "TransitGatewayAttachmentId"
                  ([], (String.to_xml v.transit_gateway_attachment_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AcceptVpcPeeringConnectionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_peering_connection_id: String.t option }
    let make ?dry_run  ?vpc_peering_connection_id  () =
      { dry_run; vpc_peering_connection_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Ezxmlm.make_tag "vpcPeeringConnectionId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module CreateTrafficMirrorSessionResult =
  struct
    type t =
      {
      traffic_mirror_session: TrafficMirrorSession.t option ;
      client_token: String.t option }
    let make ?traffic_mirror_session  ?client_token  () =
      { traffic_mirror_session; client_token }
    let parse xml =
      Some
        {
          traffic_mirror_session =
            (Util.option_bind (Xml.member "trafficMirrorSession" xml)
               TrafficMirrorSession.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.traffic_mirror_session
             (fun f ->
                Query.Pair
                  ("TrafficMirrorSession", (TrafficMirrorSession.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.traffic_mirror_session
               (fun f ->
                  Ezxmlm.make_tag "trafficMirrorSession"
                    ([], (TrafficMirrorSession.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.traffic_mirror_session
             (fun f ->
                ("traffic_mirror_session", (TrafficMirrorSession.to_json f)))])
    let of_json j =
      {
        traffic_mirror_session =
          (Util.option_map (Json.lookup j "traffic_mirror_session")
             TrafficMirrorSession.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeFleetsResult =
  struct
    type t = {
      next_token: String.t option ;
      fleets: FleetSet.t }
    let make ?next_token  ?(fleets= [])  () = { next_token; fleets }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          fleets =
            (Util.of_option []
               (Util.option_bind (Xml.member "fleetSet" xml) FleetSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("FleetSet", (FleetSet.to_query v.fleets)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "fleetSet" ([], (FleetSet.to_xml [x]))))
              v.fleets))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("fleets", (FleetSet.to_json v.fleets));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        fleets =
          (FleetSet.of_json (Util.of_option_exn (Json.lookup j "fleets")))
      }
  end
module DescribeImportImageTasksRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      import_task_ids: ImportTaskIdList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(filters= [])  ?(import_task_ids= [])  ?max_results 
      ?next_token  () =
      { dry_run; filters; import_task_ids; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml) FilterList.parse));
          import_task_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ImportTaskId" xml)
                  ImportTaskIdList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("ImportTaskId",
                  (ImportTaskIdList.to_query v.import_task_ids)));
           Some (Query.Pair ("Filters", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filters"
                         ([], (FilterList.to_xml [x])))) v.filters))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "ImportTaskId"
                        ([], (ImportTaskIdList.to_xml [x]))))
                v.import_task_ids))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("import_task_ids",
               (ImportTaskIdList.to_json v.import_task_ids));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        import_task_ids =
          (ImportTaskIdList.of_json
             (Util.of_option_exn (Json.lookup j "import_task_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module UnmonitorInstancesRequest =
  struct
    type t =
      {
      instance_ids: InstanceIdStringList.t ;
      dry_run: Boolean.t option }
    let make ~instance_ids  ?dry_run  () = { instance_ids; dry_run }
    let parse xml =
      Some
        {
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "InstanceId"
                       ([], (InstanceIdStringList.to_xml [x]))))
               v.instance_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids))])
    let of_json j =
      {
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ImportKeyPairRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      key_name: String.t ;
      public_key_material: Blob.t }
    let make ?dry_run  ~key_name  ~public_key_material  () =
      { dry_run; key_name; public_key_material }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          key_name =
            (Xml.required "keyName"
               (Util.option_bind (Xml.member "keyName" xml) String.parse));
          public_key_material =
            (Xml.required "publicKeyMaterial"
               (Util.option_bind (Xml.member "publicKeyMaterial" xml)
                  Blob.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PublicKeyMaterial", (Blob.to_query v.public_key_material)));
           Some (Query.Pair ("KeyName", (String.to_query v.key_name)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "keyName" ([], (String.to_xml v.key_name)))])
           @
           [Some
              (Ezxmlm.make_tag "publicKeyMaterial"
                 ([], (Blob.to_xml v.public_key_material)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("public_key_material", (Blob.to_json v.public_key_material));
           Some ("key_name", (String.to_json v.key_name));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        key_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "key_name")));
        public_key_material =
          (Blob.of_json
             (Util.of_option_exn (Json.lookup j "public_key_material")))
      }
  end
module DeleteTrafficMirrorSessionResult =
  struct
    type t = {
      traffic_mirror_session_id: String.t option }
    let make ?traffic_mirror_session_id  () = { traffic_mirror_session_id }
    let parse xml =
      Some
        {
          traffic_mirror_session_id =
            (Util.option_bind (Xml.member "trafficMirrorSessionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_session_id
              (fun f ->
                 Query.Pair ("TrafficMirrorSessionId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.traffic_mirror_session_id
              (fun f ->
                 Ezxmlm.make_tag "trafficMirrorSessionId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_session_id
              (fun f -> ("traffic_mirror_session_id", (String.to_json f)))])
    let of_json j =
      {
        traffic_mirror_session_id =
          (Util.option_map (Json.lookup j "traffic_mirror_session_id")
             String.of_json)
      }
  end
module GetEbsEncryptionByDefaultRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeInternetGatewaysRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      internet_gateway_ids: ValueStringList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?dry_run  ?(internet_gateway_ids= []) 
      ?next_token  ?max_results  () =
      { filters; dry_run; internet_gateway_ids; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          internet_gateway_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "internetGatewayId" xml)
                  ValueStringList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InternetGatewayId",
                  (ValueStringList.to_query v.internet_gateway_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filter"
                          ([], (FilterList.to_xml [x])))) v.filters))
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "internetGatewayId"
                        ([], (ValueStringList.to_xml [x]))))
                v.internet_gateway_ids))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("internet_gateway_ids",
               (ValueStringList.to_json v.internet_gateway_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        internet_gateway_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateway_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DeleteVpcPeeringConnectionResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DeleteQueuedReservedInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      reserved_instances_ids: DeleteQueuedReservedInstancesIdList.t }
    let make ?dry_run  ~reserved_instances_ids  () =
      { dry_run; reserved_instances_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          reserved_instances_ids =
            (Xml.required "ReservedInstancesId"
               (Util.option_bind (Xml.member "ReservedInstancesId" xml)
                  DeleteQueuedReservedInstancesIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesId",
                   (DeleteQueuedReservedInstancesIdList.to_query
                      v.reserved_instances_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "ReservedInstancesId"
                      ([], (DeleteQueuedReservedInstancesIdList.to_xml [x]))))
              v.reserved_instances_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_ids",
                (DeleteQueuedReservedInstancesIdList.to_json
                   v.reserved_instances_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        reserved_instances_ids =
          (DeleteQueuedReservedInstancesIdList.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances_ids")))
      }
  end
module WithdrawByoipCidrRequest =
  struct
    type t = {
      cidr: String.t ;
      dry_run: Boolean.t option }
    let make ~cidr  ?dry_run  () = { cidr; dry_run }
    let parse xml =
      Some
        {
          cidr =
            (Xml.required "Cidr"
               (Util.option_bind (Xml.member "Cidr" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Cidr", (String.to_query v.cidr)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Cidr" ([], (String.to_xml v.cidr)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("cidr", (String.to_json v.cidr))])
    let of_json j =
      {
        cidr = (String.of_json (Util.of_option_exn (Json.lookup j "cidr")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeSpotFleetRequestsResponse =
  struct
    type t =
      {
      next_token: String.t option ;
      spot_fleet_request_configs: SpotFleetRequestConfigSet.t }
    let make ?next_token  ?(spot_fleet_request_configs= [])  () =
      { next_token; spot_fleet_request_configs }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_fleet_request_configs =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotFleetRequestConfigSet" xml)
                  SpotFleetRequestConfigSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotFleetRequestConfigSet",
                   (SpotFleetRequestConfigSet.to_query
                      v.spot_fleet_request_configs)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "spotFleetRequestConfigSet"
                      ([], (SpotFleetRequestConfigSet.to_xml [x]))))
              v.spot_fleet_request_configs))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_fleet_request_configs",
                (SpotFleetRequestConfigSet.to_json
                   v.spot_fleet_request_configs));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        spot_fleet_request_configs =
          (SpotFleetRequestConfigSet.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_configs")))
      }
  end
module ImportVolumeResult =
  struct
    type t = {
      conversion_task: ConversionTask.t option }
    let make ?conversion_task  () = { conversion_task }
    let parse xml =
      Some
        {
          conversion_task =
            (Util.option_bind (Xml.member "conversionTask" xml)
               ConversionTask.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.conversion_task
              (fun f ->
                 Query.Pair ("ConversionTask", (ConversionTask.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.conversion_task
              (fun f ->
                 Ezxmlm.make_tag "conversionTask"
                   ([], (ConversionTask.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.conversion_task
              (fun f -> ("conversion_task", (ConversionTask.to_json f)))])
    let of_json j =
      {
        conversion_task =
          (Util.option_map (Json.lookup j "conversion_task")
             ConversionTask.of_json)
      }
  end
module DescribeFpgaImageAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      fpga_image_id: String.t ;
      attribute: FpgaImageAttributeName.t }
    let make ?dry_run  ~fpga_image_id  ~attribute  () =
      { dry_run; fpga_image_id; attribute }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          fpga_image_id =
            (Xml.required "FpgaImageId"
               (Util.option_bind (Xml.member "FpgaImageId" xml) String.parse));
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  FpgaImageAttributeName.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Attribute", (FpgaImageAttributeName.to_query v.attribute)));
           Some
             (Query.Pair ("FpgaImageId", (String.to_query v.fpga_image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "FpgaImageId"
                  ([], (String.to_xml v.fpga_image_id)))])
           @
           [Some
              (Ezxmlm.make_tag "Attribute"
                 ([], (FpgaImageAttributeName.to_xml v.attribute)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("attribute", (FpgaImageAttributeName.to_json v.attribute));
           Some ("fpga_image_id", (String.to_json v.fpga_image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        fpga_image_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "fpga_image_id")));
        attribute =
          (FpgaImageAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")))
      }
  end
module DescribeVolumeAttributeRequest =
  struct
    type t =
      {
      attribute: VolumeAttributeName.t ;
      volume_id: String.t ;
      dry_run: Boolean.t option }
    let make ~attribute  ~volume_id  ?dry_run  () =
      { attribute; volume_id; dry_run }
    let parse xml =
      Some
        {
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  VolumeAttributeName.parse));
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Some
             (Query.Pair
                ("Attribute", (VolumeAttributeName.to_query v.attribute)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "Attribute"
                   ([], (VolumeAttributeName.to_xml v.attribute)))])
            @
            [Some
               (Ezxmlm.make_tag "VolumeId" ([], (String.to_xml v.volume_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Some ("attribute", (VolumeAttributeName.to_json v.attribute))])
    let of_json j =
      {
        attribute =
          (VolumeAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")));
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module PurchaseScheduledInstancesRequest =
  struct
    type t =
      {
      client_token: String.t option ;
      dry_run: Boolean.t option ;
      purchase_requests: PurchaseRequestSet.t }
    let make ?client_token  ?dry_run  ~purchase_requests  () =
      { client_token; dry_run; purchase_requests }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          purchase_requests =
            (Xml.required "PurchaseRequest"
               (Util.option_bind (Xml.member "PurchaseRequest" xml)
                  PurchaseRequestSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PurchaseRequest",
                   (PurchaseRequestSet.to_query v.purchase_requests)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.client_token
                (fun f ->
                   Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "PurchaseRequest"
                      ([], (PurchaseRequestSet.to_xml [x]))))
              v.purchase_requests))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("purchase_requests",
                (PurchaseRequestSet.to_json v.purchase_requests));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        purchase_requests =
          (PurchaseRequestSet.of_json
             (Util.of_option_exn (Json.lookup j "purchase_requests")))
      }
  end
module CreateNetworkAclResult =
  struct
    type t = {
      network_acl: NetworkAcl.t option }
    let make ?network_acl  () = { network_acl }
    let parse xml =
      Some
        {
          network_acl =
            (Util.option_bind (Xml.member "networkAcl" xml) NetworkAcl.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_acl
              (fun f -> Query.Pair ("NetworkAcl", (NetworkAcl.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.network_acl
              (fun f ->
                 Ezxmlm.make_tag "networkAcl" ([], (NetworkAcl.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_acl
              (fun f -> ("network_acl", (NetworkAcl.to_json f)))])
    let of_json j =
      {
        network_acl =
          (Util.option_map (Json.lookup j "network_acl") NetworkAcl.of_json)
      }
  end
module DisassociateIamInstanceProfileResult =
  struct
    type t =
      {
      iam_instance_profile_association:
        IamInstanceProfileAssociation.t option }
    let make ?iam_instance_profile_association  () =
      { iam_instance_profile_association }
    let parse xml =
      Some
        {
          iam_instance_profile_association =
            (Util.option_bind
               (Xml.member "iamInstanceProfileAssociation" xml)
               IamInstanceProfileAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 Query.Pair
                   ("IamInstanceProfileAssociation",
                     (IamInstanceProfileAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 Ezxmlm.make_tag "iamInstanceProfileAssociation"
                   ([], (IamInstanceProfileAssociation.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 ("iam_instance_profile_association",
                   (IamInstanceProfileAssociation.to_json f)))])
    let of_json j =
      {
        iam_instance_profile_association =
          (Util.option_map (Json.lookup j "iam_instance_profile_association")
             IamInstanceProfileAssociation.of_json)
      }
  end
module CreateRouteTableResult =
  struct
    type t = {
      route_table: RouteTable.t option }
    let make ?route_table  () = { route_table }
    let parse xml =
      Some
        {
          route_table =
            (Util.option_bind (Xml.member "routeTable" xml) RouteTable.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route_table
              (fun f -> Query.Pair ("RouteTable", (RouteTable.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.route_table
              (fun f ->
                 Ezxmlm.make_tag "routeTable" ([], (RouteTable.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route_table
              (fun f -> ("route_table", (RouteTable.to_json f)))])
    let of_json j =
      {
        route_table =
          (Util.option_map (Json.lookup j "route_table") RouteTable.of_json)
      }
  end
module DeleteNetworkInterfaceRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      network_interface_id: String.t }
    let make ?dry_run  ~network_interface_id  () =
      { dry_run; network_interface_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkInterfaceId",
                   (String.to_query v.network_interface_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "networkInterfaceId"
                 ([], (String.to_xml v.network_interface_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("network_interface_id",
                (String.to_json v.network_interface_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")))
      }
  end
module EnableEbsEncryptionByDefaultRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeAvailabilityZonesResult =
  struct
    type t = {
      availability_zones: AvailabilityZoneList.t }
    let make ?(availability_zones= [])  () = { availability_zones }
    let parse xml =
      Some
        {
          availability_zones =
            (Util.of_option []
               (Util.option_bind (Xml.member "availabilityZoneInfo" xml)
                  AvailabilityZoneList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AvailabilityZoneInfo",
                   (AvailabilityZoneList.to_query v.availability_zones)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "availabilityZoneInfo"
                      ([], (AvailabilityZoneList.to_xml [x]))))
              v.availability_zones))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("availability_zones",
                (AvailabilityZoneList.to_json v.availability_zones))])
    let of_json j =
      {
        availability_zones =
          (AvailabilityZoneList.of_json
             (Util.of_option_exn (Json.lookup j "availability_zones")))
      }
  end
module DescribeCoipPoolsRequest =
  struct
    type t =
      {
      pool_ids: CoipPoolIdSet.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(pool_ids= [])  ?(filters= [])  ?max_results  ?next_token 
      ?dry_run  () = { pool_ids; filters; max_results; next_token; dry_run }
    let parse xml =
      Some
        {
          pool_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "PoolId" xml)
                  CoipPoolIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some (Query.Pair ("PoolId", (CoipPoolIdSet.to_query v.pool_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "PoolId"
                          ([], (CoipPoolIdSet.to_xml [x])))) v.pool_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("pool_ids", (CoipPoolIdSet.to_json v.pool_ids))])
    let of_json j =
      {
        pool_ids =
          (CoipPoolIdSet.of_json
             (Util.of_option_exn (Json.lookup j "pool_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module StartInstancesRequest =
  struct
    type t =
      {
      instance_ids: InstanceIdStringList.t ;
      additional_info: String.t option ;
      dry_run: Boolean.t option }
    let make ~instance_ids  ?additional_info  ?dry_run  () =
      { instance_ids; additional_info; dry_run }
    let parse xml =
      Some
        {
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          additional_info =
            (Util.option_bind (Xml.member "additionalInfo" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.additional_info
             (fun f -> Query.Pair ("AdditionalInfo", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "InstanceId"
                        ([], (InstanceIdStringList.to_xml [x]))))
                v.instance_ids))
            @
            [Util.option_map v.additional_info
               (fun f ->
                  Ezxmlm.make_tag "additionalInfo" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.additional_info
             (fun f -> ("additional_info", (String.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids))])
    let of_json j =
      {
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        additional_info =
          (Util.option_map (Json.lookup j "additional_info") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ImportImageResult =
  struct
    type t =
      {
      architecture: String.t option ;
      description: String.t option ;
      encrypted: Boolean.t option ;
      hypervisor: String.t option ;
      image_id: String.t option ;
      import_task_id: String.t option ;
      kms_key_id: String.t option ;
      license_type: String.t option ;
      platform: String.t option ;
      progress: String.t option ;
      snapshot_details: SnapshotDetailList.t ;
      status: String.t option ;
      status_message: String.t option ;
      license_specifications: ImportImageLicenseSpecificationListResponse.t }
    let make ?architecture  ?description  ?encrypted  ?hypervisor  ?image_id 
      ?import_task_id  ?kms_key_id  ?license_type  ?platform  ?progress 
      ?(snapshot_details= [])  ?status  ?status_message 
      ?(license_specifications= [])  () =
      {
        architecture;
        description;
        encrypted;
        hypervisor;
        image_id;
        import_task_id;
        kms_key_id;
        license_type;
        platform;
        progress;
        snapshot_details;
        status;
        status_message;
        license_specifications
      }
    let parse xml =
      Some
        {
          architecture =
            (Util.option_bind (Xml.member "architecture" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          hypervisor =
            (Util.option_bind (Xml.member "hypervisor" xml) String.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          license_type =
            (Util.option_bind (Xml.member "licenseType" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          snapshot_details =
            (Util.of_option []
               (Util.option_bind (Xml.member "snapshotDetailSet" xml)
                  SnapshotDetailList.parse));
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          license_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "licenseSpecifications" xml)
                  ImportImageLicenseSpecificationListResponse.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("LicenseSpecifications",
                   (ImportImageLicenseSpecificationListResponse.to_query
                      v.license_specifications)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Some
             (Query.Pair
                ("SnapshotDetailSet",
                  (SnapshotDetailList.to_query v.snapshot_details)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.license_type
             (fun f -> Query.Pair ("LicenseType", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.hypervisor
             (fun f -> Query.Pair ("Hypervisor", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.architecture
             (fun f -> Query.Pair ("Architecture", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        [Util.option_map v.architecture
                           (fun f ->
                              Ezxmlm.make_tag "architecture"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.description
                          (fun f ->
                             Ezxmlm.make_tag "description"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.encrypted
                         (fun f ->
                            Ezxmlm.make_tag "encrypted"
                              ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.hypervisor
                        (fun f ->
                           Ezxmlm.make_tag "hypervisor"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.image_id
                       (fun f ->
                          Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.import_task_id
                      (fun f ->
                         Ezxmlm.make_tag "importTaskId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.kms_key_id
                     (fun f ->
                        Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.license_type
                    (fun f ->
                       Ezxmlm.make_tag "licenseType" ([], (String.to_xml f)))])
                @
                [Util.option_map v.platform
                   (fun f ->
                      Ezxmlm.make_tag "platform" ([], (String.to_xml f)))])
               @
               [Util.option_map v.progress
                  (fun f ->
                     Ezxmlm.make_tag "progress" ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "snapshotDetailSet"
                         ([], (SnapshotDetailList.to_xml [x]))))
                 v.snapshot_details))
             @
             [Util.option_map v.status
                (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
            @
            [Util.option_map v.status_message
               (fun f ->
                  Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "licenseSpecifications"
                      ([],
                        (ImportImageLicenseSpecificationListResponse.to_xml
                           [x])))) v.license_specifications))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("license_specifications",
                (ImportImageLicenseSpecificationListResponse.to_json
                   v.license_specifications));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Some
             ("snapshot_details",
               (SnapshotDetailList.to_json v.snapshot_details));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.license_type
             (fun f -> ("license_type", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.hypervisor
             (fun f -> ("hypervisor", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.architecture
             (fun f -> ("architecture", (String.to_json f)))])
    let of_json j =
      {
        architecture =
          (Util.option_map (Json.lookup j "architecture") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        hypervisor =
          (Util.option_map (Json.lookup j "hypervisor") String.of_json);
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        license_type =
          (Util.option_map (Json.lookup j "license_type") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") String.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        snapshot_details =
          (SnapshotDetailList.of_json
             (Util.of_option_exn (Json.lookup j "snapshot_details")));
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        license_specifications =
          (ImportImageLicenseSpecificationListResponse.of_json
             (Util.of_option_exn (Json.lookup j "license_specifications")))
      }
  end
module DescribeCustomerGatewaysResult =
  struct
    type t = {
      customer_gateways: CustomerGatewayList.t }
    let make ?(customer_gateways= [])  () = { customer_gateways }
    let parse xml =
      Some
        {
          customer_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "customerGatewaySet" xml)
                  CustomerGatewayList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("CustomerGatewaySet",
                   (CustomerGatewayList.to_query v.customer_gateways)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "customerGatewaySet"
                      ([], (CustomerGatewayList.to_xml [x]))))
              v.customer_gateways))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("customer_gateways",
                (CustomerGatewayList.to_json v.customer_gateways))])
    let of_json j =
      {
        customer_gateways =
          (CustomerGatewayList.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateways")))
      }
  end
module DescribeSpotFleetRequestHistoryRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      event_type: EventType.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      spot_fleet_request_id: String.t ;
      start_time: DateTime.t }
    let make ?dry_run  ?event_type  ?max_results  ?next_token 
      ~spot_fleet_request_id  ~start_time  () =
      {
        dry_run;
        event_type;
        max_results;
        next_token;
        spot_fleet_request_id;
        start_time
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          event_type =
            (Util.option_bind (Xml.member "eventType" xml) EventType.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_fleet_request_id =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  String.parse));
          start_time =
            (Xml.required "startTime"
               (Util.option_bind (Xml.member "startTime" xml) DateTime.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("StartTime", (DateTime.to_query v.start_time)));
           Some
             (Query.Pair
                ("SpotFleetRequestId",
                  (String.to_query v.spot_fleet_request_id)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.event_type
             (fun f -> Query.Pair ("EventType", (EventType.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.dry_run
                   (fun f ->
                      Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.event_type
                  (fun f ->
                     Ezxmlm.make_tag "eventType" ([], (EventType.to_xml f)))])
              @
              [Util.option_map v.max_results
                 (fun f ->
                    Ezxmlm.make_tag "maxResults" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "spotFleetRequestId"
                  ([], (String.to_xml v.spot_fleet_request_id)))])
           @
           [Some
              (Ezxmlm.make_tag "startTime"
                 ([], (DateTime.to_xml v.start_time)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("start_time", (DateTime.to_json v.start_time));
           Some
             ("spot_fleet_request_id",
               (String.to_json v.spot_fleet_request_id));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.event_type
             (fun f -> ("event_type", (EventType.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        event_type =
          (Util.option_map (Json.lookup j "event_type") EventType.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        spot_fleet_request_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_id")));
        start_time =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "start_time")))
      }
  end
module ModifyVpnConnectionResult =
  struct
    type t = {
      vpn_connection: VpnConnection.t option }
    let make ?vpn_connection  () = { vpn_connection }
    let parse xml =
      Some
        {
          vpn_connection =
            (Util.option_bind (Xml.member "vpnConnection" xml)
               VpnConnection.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f ->
                 Query.Pair ("VpnConnection", (VpnConnection.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpn_connection
              (fun f ->
                 Ezxmlm.make_tag "vpnConnection"
                   ([], (VpnConnection.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f -> ("vpn_connection", (VpnConnection.to_json f)))])
    let of_json j =
      {
        vpn_connection =
          (Util.option_map (Json.lookup j "vpn_connection")
             VpnConnection.of_json)
      }
  end
module DeleteVolumeRequest =
  struct
    type t = {
      volume_id: String.t ;
      dry_run: Boolean.t option }
    let make ~volume_id  ?dry_run  () = { volume_id; dry_run }
    let parse xml =
      Some
        {
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "VolumeId" ([], (String.to_xml v.volume_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id))])
    let of_json j =
      {
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ReplaceIamInstanceProfileAssociationResult =
  struct
    type t =
      {
      iam_instance_profile_association:
        IamInstanceProfileAssociation.t option }
    let make ?iam_instance_profile_association  () =
      { iam_instance_profile_association }
    let parse xml =
      Some
        {
          iam_instance_profile_association =
            (Util.option_bind
               (Xml.member "iamInstanceProfileAssociation" xml)
               IamInstanceProfileAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 Query.Pair
                   ("IamInstanceProfileAssociation",
                     (IamInstanceProfileAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 Ezxmlm.make_tag "iamInstanceProfileAssociation"
                   ([], (IamInstanceProfileAssociation.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 ("iam_instance_profile_association",
                   (IamInstanceProfileAssociation.to_json f)))])
    let of_json j =
      {
        iam_instance_profile_association =
          (Util.option_map (Json.lookup j "iam_instance_profile_association")
             IamInstanceProfileAssociation.of_json)
      }
  end
module DescribeByoipCidrsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      max_results: Integer.t ;
      next_token: String.t option }
    let make ?dry_run  ~max_results  ?next_token  () =
      { dry_run; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          max_results =
            (Xml.required "MaxResults"
               (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("MaxResults", (Integer.to_query v.max_results)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "MaxResults"
                  ([], (Integer.to_xml v.max_results)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("max_results", (Integer.to_json v.max_results));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "max_results")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeVolumeStatusResult =
  struct
    type t =
      {
      next_token: String.t option ;
      volume_statuses: VolumeStatusList.t }
    let make ?next_token  ?(volume_statuses= [])  () =
      { next_token; volume_statuses }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          volume_statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "volumeStatusSet" xml)
                  VolumeStatusList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VolumeStatusSet",
                   (VolumeStatusList.to_query v.volume_statuses)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "volumeStatusSet"
                      ([], (VolumeStatusList.to_xml [x])))) v.volume_statuses))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("volume_statuses",
                (VolumeStatusList.to_json v.volume_statuses));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        volume_statuses =
          (VolumeStatusList.of_json
             (Util.of_option_exn (Json.lookup j "volume_statuses")))
      }
  end
module AssociateClientVpnTargetNetworkResult =
  struct
    type t =
      {
      association_id: String.t option ;
      status: AssociationStatus.t option }
    let make ?association_id  ?status  () = { association_id; status }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AssociationStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (AssociationStatus.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.association_id
               (fun f ->
                  Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status" ([], (AssociationStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (AssociationStatus.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") AssociationStatus.of_json)
      }
  end
module ReplaceTransitGatewayRouteResult =
  struct
    type t = {
      route: TransitGatewayRoute.t option }
    let make ?route  () = { route }
    let parse xml =
      Some
        {
          route =
            (Util.option_bind (Xml.member "route" xml)
               TransitGatewayRoute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f ->
                 Query.Pair ("Route", (TransitGatewayRoute.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.route
              (fun f ->
                 Ezxmlm.make_tag "route" ([], (TransitGatewayRoute.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> ("route", (TransitGatewayRoute.to_json f)))])
    let of_json j =
      {
        route =
          (Util.option_map (Json.lookup j "route")
             TransitGatewayRoute.of_json)
      }
  end
module DeleteVpcEndpointServiceConfigurationsResult =
  struct
    type t = {
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemSet.to_xml [x])))) v.unsuccessful))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let of_json j =
      {
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module ModifyEbsDefaultKmsKeyIdResult =
  struct
    type t = {
      kms_key_id: String.t option }
    let make ?kms_key_id  () = { kms_key_id }
    let parse xml =
      Some
        {
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.kms_key_id
              (fun f -> Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> ("kms_key_id", (String.to_json f)))])
    let of_json j =
      {
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json)
      }
  end
module DisableVpcClassicLinkResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DeleteFlowLogsResult =
  struct
    type t = {
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemSet.to_xml [x])))) v.unsuccessful))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let of_json j =
      {
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module AttachVpnGatewayResult =
  struct
    type t = {
      vpc_attachment: VpcAttachment.t option }
    let make ?vpc_attachment  () = { vpc_attachment }
    let parse xml =
      Some
        {
          vpc_attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               VpcAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_attachment
              (fun f -> Query.Pair ("Attachment", (VpcAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpc_attachment
              (fun f ->
                 Ezxmlm.make_tag "attachment" ([], (VpcAttachment.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_attachment
              (fun f -> ("vpc_attachment", (VpcAttachment.to_json f)))])
    let of_json j =
      {
        vpc_attachment =
          (Util.option_map (Json.lookup j "vpc_attachment")
             VpcAttachment.of_json)
      }
  end
module CreateTransitGatewayRequest =
  struct
    type t =
      {
      description: String.t option ;
      options: TransitGatewayRequestOptions.t option ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ?description  ?options  ?(tag_specifications= [])  ?dry_run  ()
      = { description; options; tag_specifications; dry_run }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          options =
            (Util.option_bind (Xml.member "Options" xml)
               TransitGatewayRequestOptions.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.options
             (fun f ->
                Query.Pair
                  ("Options", (TransitGatewayRequestOptions.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
             @
             [Util.option_map v.options
                (fun f ->
                   Ezxmlm.make_tag "Options"
                     ([], (TransitGatewayRequestOptions.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "TagSpecification"
                       ([], (TagSpecificationList.to_xml [x]))))
               v.tag_specifications))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.options
             (fun f -> ("options", (TransitGatewayRequestOptions.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        options =
          (Util.option_map (Json.lookup j "options")
             TransitGatewayRequestOptions.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ImageAttribute =
  struct
    type t =
      {
      block_device_mappings: BlockDeviceMappingList.t ;
      image_id: String.t option ;
      launch_permissions: LaunchPermissionList.t ;
      product_codes: ProductCodeList.t ;
      description: AttributeValue.t option ;
      kernel_id: AttributeValue.t option ;
      ramdisk_id: AttributeValue.t option ;
      sriov_net_support: AttributeValue.t option }
    let make ?(block_device_mappings= [])  ?image_id  ?(launch_permissions=
      [])  ?(product_codes= [])  ?description  ?kernel_id  ?ramdisk_id 
      ?sriov_net_support  () =
      {
        block_device_mappings;
        image_id;
        launch_permissions;
        product_codes;
        description;
        kernel_id;
        ramdisk_id;
        sriov_net_support
      }
    let parse xml =
      Some
        {
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          launch_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchPermission" xml)
                  LaunchPermissionList.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          description =
            (Util.option_bind (Xml.member "description" xml)
               AttributeValue.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernel" xml) AttributeValue.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdisk" xml) AttributeValue.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml)
               AttributeValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.sriov_net_support
              (fun f ->
                 Query.Pair ("SriovNetSupport", (AttributeValue.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("Ramdisk", (AttributeValue.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("Kernel", (AttributeValue.to_query f)));
           Util.option_map v.description
             (fun f ->
                Query.Pair ("Description", (AttributeValue.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Some
             (Query.Pair
                ("LaunchPermission",
                  (LaunchPermissionList.to_query v.launch_permissions)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "blockDeviceMapping"
                             ([], (BlockDeviceMappingList.to_xml [x]))))
                     v.block_device_mappings))
                 @
                 [Util.option_map v.image_id
                    (fun f ->
                       Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "launchPermission"
                           ([], (LaunchPermissionList.to_xml [x]))))
                   v.launch_permissions))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "productCodes"
                          ([], (ProductCodeList.to_xml [x]))))
                  v.product_codes))
              @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "description"
                      ([], (AttributeValue.to_xml f)))])
             @
             [Util.option_map v.kernel_id
                (fun f ->
                   Ezxmlm.make_tag "kernel" ([], (AttributeValue.to_xml f)))])
            @
            [Util.option_map v.ramdisk_id
               (fun f ->
                  Ezxmlm.make_tag "ramdisk" ([], (AttributeValue.to_xml f)))])
           @
           [Util.option_map v.sriov_net_support
              (fun f ->
                 Ezxmlm.make_tag "sriovNetSupport"
                   ([], (AttributeValue.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.sriov_net_support
              (fun f -> ("sriov_net_support", (AttributeValue.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (AttributeValue.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (AttributeValue.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (AttributeValue.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Some
             ("launch_permissions",
               (LaunchPermissionList.to_json v.launch_permissions));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings))])
    let of_json j =
      {
        block_device_mappings =
          (BlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        launch_permissions =
          (LaunchPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "launch_permissions")));
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        description =
          (Util.option_map (Json.lookup j "description")
             AttributeValue.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") AttributeValue.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id")
             AttributeValue.of_json);
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support")
             AttributeValue.of_json)
      }
  end
module DetachClassicLinkVpcResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module GetTransitGatewayRouteTableAssociationsResult =
  struct
    type t =
      {
      associations: TransitGatewayRouteTableAssociationList.t ;
      next_token: String.t option }
    let make ?(associations= [])  ?next_token  () =
      { associations; next_token }
    let parse xml =
      Some
        {
          associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "associations" xml)
                  TransitGatewayRouteTableAssociationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("Associations",
                  (TransitGatewayRouteTableAssociationList.to_query
                     v.associations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "associations"
                       ([],
                         (TransitGatewayRouteTableAssociationList.to_xml [x]))))
               v.associations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("associations",
               (TransitGatewayRouteTableAssociationList.to_json
                  v.associations))])
    let of_json j =
      {
        associations =
          (TransitGatewayRouteTableAssociationList.of_json
             (Util.of_option_exn (Json.lookup j "associations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyInstanceEventStartTimeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      instance_event_id: String.t ;
      not_before: DateTime.t }
    let make ?dry_run  ~instance_id  ~instance_event_id  ~not_before  () =
      { dry_run; instance_id; instance_event_id; not_before }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          instance_event_id =
            (Xml.required "InstanceEventId"
               (Util.option_bind (Xml.member "InstanceEventId" xml)
                  String.parse));
          not_before =
            (Xml.required "NotBefore"
               (Util.option_bind (Xml.member "NotBefore" xml) DateTime.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("NotBefore", (DateTime.to_query v.not_before)));
           Some
             (Query.Pair
                ("InstanceEventId", (String.to_query v.instance_event_id)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "InstanceId"
                   ([], (String.to_xml v.instance_id)))])
            @
            [Some
               (Ezxmlm.make_tag "InstanceEventId"
                  ([], (String.to_xml v.instance_event_id)))])
           @
           [Some
              (Ezxmlm.make_tag "NotBefore"
                 ([], (DateTime.to_xml v.not_before)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("not_before", (DateTime.to_json v.not_before));
           Some ("instance_event_id", (String.to_json v.instance_event_id));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        instance_event_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "instance_event_id")));
        not_before =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "not_before")))
      }
  end
module DeleteSnapshotRequest =
  struct
    type t = {
      snapshot_id: String.t ;
      dry_run: Boolean.t option }
    let make ~snapshot_id  ?dry_run  () = { snapshot_id; dry_run }
    let parse xml =
      Some
        {
          snapshot_id =
            (Xml.required "SnapshotId"
               (Util.option_bind (Xml.member "SnapshotId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "SnapshotId"
                  ([], (String.to_xml v.snapshot_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("snapshot_id", (String.to_json v.snapshot_id))])
    let of_json j =
      {
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ReplaceIamInstanceProfileAssociationRequest =
  struct
    type t =
      {
      iam_instance_profile: IamInstanceProfileSpecification.t ;
      association_id: String.t }
    let make ~iam_instance_profile  ~association_id  () =
      { iam_instance_profile; association_id }
    let parse xml =
      Some
        {
          iam_instance_profile =
            (Xml.required "IamInstanceProfile"
               (Util.option_bind (Xml.member "IamInstanceProfile" xml)
                  IamInstanceProfileSpecification.parse));
          association_id =
            (Xml.required "AssociationId"
               (Util.option_bind (Xml.member "AssociationId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AssociationId", (String.to_query v.association_id)));
           Some
             (Query.Pair
                ("IamInstanceProfile",
                  (IamInstanceProfileSpecification.to_query
                     v.iam_instance_profile)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "IamInstanceProfile"
                  ([],
                    (IamInstanceProfileSpecification.to_xml
                       v.iam_instance_profile)))])
           @
           [Some
              (Ezxmlm.make_tag "AssociationId"
                 ([], (String.to_xml v.association_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("association_id", (String.to_json v.association_id));
           Some
             ("iam_instance_profile",
               (IamInstanceProfileSpecification.to_json
                  v.iam_instance_profile))])
    let of_json j =
      {
        iam_instance_profile =
          (IamInstanceProfileSpecification.of_json
             (Util.of_option_exn (Json.lookup j "iam_instance_profile")));
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")))
      }
  end
module DescribeHostReservationOfferingsResult =
  struct
    type t = {
      next_token: String.t option ;
      offering_set: HostOfferingSet.t }
    let make ?next_token  ?(offering_set= [])  () =
      { next_token; offering_set }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          offering_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "offeringSet" xml)
                  HostOfferingSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("OfferingSet", (HostOfferingSet.to_query v.offering_set)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "offeringSet"
                      ([], (HostOfferingSet.to_xml [x])))) v.offering_set))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("offering_set", (HostOfferingSet.to_json v.offering_set));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        offering_set =
          (HostOfferingSet.of_json
             (Util.of_option_exn (Json.lookup j "offering_set")))
      }
  end
module DescribeTransitGatewaysRequest =
  struct
    type t =
      {
      transit_gateway_ids: TransitGatewayIdStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(transit_gateway_ids= [])  ?(filters= [])  ?max_results 
      ?next_token  ?dry_run  () =
      { transit_gateway_ids; filters; max_results; next_token; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "TransitGatewayIds" xml)
                  TransitGatewayIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayIds",
                  (TransitGatewayIdStringList.to_query v.transit_gateway_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "TransitGatewayIds"
                          ([], (TransitGatewayIdStringList.to_xml [x]))))
                  v.transit_gateway_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_ids",
               (TransitGatewayIdStringList.to_json v.transit_gateway_ids))])
    let of_json j =
      {
        transit_gateway_ids =
          (TransitGatewayIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "transit_gateway_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyInstancePlacementRequest =
  struct
    type t =
      {
      affinity: Affinity.t option ;
      group_name: String.t option ;
      host_id: String.t option ;
      instance_id: String.t ;
      tenancy: HostTenancy.t option ;
      partition_number: Integer.t option ;
      host_resource_group_arn: String.t option }
    let make ?affinity  ?group_name  ?host_id  ~instance_id  ?tenancy 
      ?partition_number  ?host_resource_group_arn  () =
      {
        affinity;
        group_name;
        host_id;
        instance_id;
        tenancy;
        partition_number;
        host_resource_group_arn
      }
    let parse xml =
      Some
        {
          affinity =
            (Util.option_bind (Xml.member "affinity" xml) Affinity.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          host_id = (Util.option_bind (Xml.member "hostId" xml) String.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          tenancy =
            (Util.option_bind (Xml.member "tenancy" xml) HostTenancy.parse);
          partition_number =
            (Util.option_bind (Xml.member "PartitionNumber" xml)
               Integer.parse);
          host_resource_group_arn =
            (Util.option_bind (Xml.member "HostResourceGroupArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f ->
                 Query.Pair ("HostResourceGroupArn", (String.to_query f)));
           Util.option_map v.partition_number
             (fun f -> Query.Pair ("PartitionNumber", (Integer.to_query f)));
           Util.option_map v.tenancy
             (fun f -> Query.Pair ("Tenancy", (HostTenancy.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.host_id
             (fun f -> Query.Pair ("HostId", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.affinity
             (fun f -> Query.Pair ("Affinity", (Affinity.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.affinity
                    (fun f ->
                       Ezxmlm.make_tag "affinity" ([], (Affinity.to_xml f)))])
                @
                [Util.option_map v.group_name
                   (fun f ->
                      Ezxmlm.make_tag "GroupName" ([], (String.to_xml f)))])
               @
               [Util.option_map v.host_id
                  (fun f -> Ezxmlm.make_tag "hostId" ([], (String.to_xml f)))])
              @
              [Some
                 (Ezxmlm.make_tag "instanceId"
                    ([], (String.to_xml v.instance_id)))])
             @
             [Util.option_map v.tenancy
                (fun f ->
                   Ezxmlm.make_tag "tenancy" ([], (HostTenancy.to_xml f)))])
            @
            [Util.option_map v.partition_number
               (fun f ->
                  Ezxmlm.make_tag "PartitionNumber" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.host_resource_group_arn
              (fun f ->
                 Ezxmlm.make_tag "HostResourceGroupArn"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f -> ("host_resource_group_arn", (String.to_json f)));
           Util.option_map v.partition_number
             (fun f -> ("partition_number", (Integer.to_json f)));
           Util.option_map v.tenancy
             (fun f -> ("tenancy", (HostTenancy.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.host_id
             (fun f -> ("host_id", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.affinity
             (fun f -> ("affinity", (Affinity.to_json f)))])
    let of_json j =
      {
        affinity =
          (Util.option_map (Json.lookup j "affinity") Affinity.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        host_id = (Util.option_map (Json.lookup j "host_id") String.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        tenancy =
          (Util.option_map (Json.lookup j "tenancy") HostTenancy.of_json);
        partition_number =
          (Util.option_map (Json.lookup j "partition_number") Integer.of_json);
        host_resource_group_arn =
          (Util.option_map (Json.lookup j "host_resource_group_arn")
             String.of_json)
      }
  end
module DescribeNatGatewaysRequest =
  struct
    type t =
      {
      filter: FilterList.t ;
      max_results: Integer.t option ;
      nat_gateway_ids: ValueStringList.t ;
      next_token: String.t option }
    let make ?(filter= [])  ?max_results  ?(nat_gateway_ids= [])  ?next_token
       () = { filter; max_results; nat_gateway_ids; next_token }
    let parse xml =
      Some
        {
          filter =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          nat_gateway_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "NatGatewayId" xml)
                  ValueStringList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NatGatewayId",
                  (ValueStringList.to_query v.nat_gateway_ids)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filter)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filter))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "NatGatewayId"
                       ([], (ValueStringList.to_xml [x])))) v.nat_gateway_ids))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("nat_gateway_ids", (ValueStringList.to_json v.nat_gateway_ids));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filter", (FilterList.to_json v.filter))])
    let of_json j =
      {
        filter =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filter")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        nat_gateway_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "nat_gateway_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeEgressOnlyInternetGatewaysRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      egress_only_internet_gateway_ids: EgressOnlyInternetGatewayIdList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(egress_only_internet_gateway_ids= [])  ?max_results 
      ?next_token  () =
      { dry_run; egress_only_internet_gateway_ids; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          egress_only_internet_gateway_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "EgressOnlyInternetGatewayId" xml)
                  EgressOnlyInternetGatewayIdList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("EgressOnlyInternetGatewayId",
                  (EgressOnlyInternetGatewayIdList.to_query
                     v.egress_only_internet_gateway_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "EgressOnlyInternetGatewayId"
                        ([], (EgressOnlyInternetGatewayIdList.to_xml [x]))))
                v.egress_only_internet_gateway_ids))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("egress_only_internet_gateway_ids",
               (EgressOnlyInternetGatewayIdList.to_json
                  v.egress_only_internet_gateway_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        egress_only_internet_gateway_ids =
          (EgressOnlyInternetGatewayIdList.of_json
             (Util.of_option_exn
                (Json.lookup j "egress_only_internet_gateway_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeSpotInstanceRequestsResult =
  struct
    type t =
      {
      spot_instance_requests: SpotInstanceRequestList.t ;
      next_token: String.t option }
    let make ?(spot_instance_requests= [])  ?next_token  () =
      { spot_instance_requests; next_token }
    let parse xml =
      Some
        {
          spot_instance_requests =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotInstanceRequestSet" xml)
                  SpotInstanceRequestList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("SpotInstanceRequestSet",
                  (SpotInstanceRequestList.to_query v.spot_instance_requests)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "spotInstanceRequestSet"
                       ([], (SpotInstanceRequestList.to_xml [x]))))
               v.spot_instance_requests))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("spot_instance_requests",
               (SpotInstanceRequestList.to_json v.spot_instance_requests))])
    let of_json j =
      {
        spot_instance_requests =
          (SpotInstanceRequestList.of_json
             (Util.of_option_exn (Json.lookup j "spot_instance_requests")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyTransitGatewayVpcAttachmentResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.t option }
    let make ?transit_gateway_vpc_attachment  () =
      { transit_gateway_vpc_attachment }
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachment =
            (Util.option_bind (Xml.member "transitGatewayVpcAttachment" xml)
               TransitGatewayVpcAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayVpcAttachment",
                     (TransitGatewayVpcAttachment.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayVpcAttachment"
                   ([], (TransitGatewayVpcAttachment.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 ("transit_gateway_vpc_attachment",
                   (TransitGatewayVpcAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_vpc_attachment =
          (Util.option_map (Json.lookup j "transit_gateway_vpc_attachment")
             TransitGatewayVpcAttachment.of_json)
      }
  end
module ModifyFpgaImageAttributeResult =
  struct
    type t = {
      fpga_image_attribute: FpgaImageAttribute.t option }
    let make ?fpga_image_attribute  () = { fpga_image_attribute }
    let parse xml =
      Some
        {
          fpga_image_attribute =
            (Util.option_bind (Xml.member "fpgaImageAttribute" xml)
               FpgaImageAttribute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_attribute
              (fun f ->
                 Query.Pair
                   ("FpgaImageAttribute", (FpgaImageAttribute.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.fpga_image_attribute
              (fun f ->
                 Ezxmlm.make_tag "fpgaImageAttribute"
                   ([], (FpgaImageAttribute.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_attribute
              (fun f ->
                 ("fpga_image_attribute", (FpgaImageAttribute.to_json f)))])
    let of_json j =
      {
        fpga_image_attribute =
          (Util.option_map (Json.lookup j "fpga_image_attribute")
             FpgaImageAttribute.of_json)
      }
  end
module DeleteFpgaImageRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      fpga_image_id: String.t }
    let make ?dry_run  ~fpga_image_id  () = { dry_run; fpga_image_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          fpga_image_id =
            (Xml.required "FpgaImageId"
               (Util.option_bind (Xml.member "FpgaImageId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("FpgaImageId", (String.to_query v.fpga_image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "FpgaImageId"
                 ([], (String.to_xml v.fpga_image_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("fpga_image_id", (String.to_json v.fpga_image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        fpga_image_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "fpga_image_id")))
      }
  end
module DescribeFastSnapshotRestoresRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(filters= [])  ?max_results  ?next_token  ?dry_run  () =
      { filters; max_results; next_token; dry_run }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AcceptVpcPeeringConnectionResult =
  struct
    type t = {
      vpc_peering_connection: VpcPeeringConnection.t option }
    let make ?vpc_peering_connection  () = { vpc_peering_connection }
    let parse xml =
      Some
        {
          vpc_peering_connection =
            (Util.option_bind (Xml.member "vpcPeeringConnection" xml)
               VpcPeeringConnection.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 Query.Pair
                   ("VpcPeeringConnection",
                     (VpcPeeringConnection.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 Ezxmlm.make_tag "vpcPeeringConnection"
                   ([], (VpcPeeringConnection.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 ("vpc_peering_connection", (VpcPeeringConnection.to_json f)))])
    let of_json j =
      {
        vpc_peering_connection =
          (Util.option_map (Json.lookup j "vpc_peering_connection")
             VpcPeeringConnection.of_json)
      }
  end
module GetTransitGatewayRouteTablePropagationsRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ?(filters= [])  ?max_results 
      ?next_token  ?dry_run  () =
      {
        transit_gateway_route_table_id;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "TransitGatewayRouteTableId"
                     ([], (String.to_xml v.transit_gateway_route_table_id)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateNetworkInterfacePermissionResult =
  struct
    type t = {
      interface_permission: NetworkInterfacePermission.t option }
    let make ?interface_permission  () = { interface_permission }
    let parse xml =
      Some
        {
          interface_permission =
            (Util.option_bind (Xml.member "interfacePermission" xml)
               NetworkInterfacePermission.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.interface_permission
              (fun f ->
                 Query.Pair
                   ("InterfacePermission",
                     (NetworkInterfacePermission.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.interface_permission
              (fun f ->
                 Ezxmlm.make_tag "interfacePermission"
                   ([], (NetworkInterfacePermission.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.interface_permission
              (fun f ->
                 ("interface_permission",
                   (NetworkInterfacePermission.to_json f)))])
    let of_json j =
      {
        interface_permission =
          (Util.option_map (Json.lookup j "interface_permission")
             NetworkInterfacePermission.of_json)
      }
  end
module AuthorizeClientVpnIngressRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      target_network_cidr: String.t ;
      access_group_id: String.t option ;
      authorize_all_groups: Boolean.t option ;
      description: String.t option ;
      client_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ~target_network_cidr  ?access_group_id 
      ?authorize_all_groups  ?description  ?client_token  ?dry_run  () =
      {
        client_vpn_endpoint_id;
        target_network_cidr;
        access_group_id;
        authorize_all_groups;
        description;
        client_token;
        dry_run
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          target_network_cidr =
            (Xml.required "TargetNetworkCidr"
               (Util.option_bind (Xml.member "TargetNetworkCidr" xml)
                  String.parse));
          access_group_id =
            (Util.option_bind (Xml.member "AccessGroupId" xml) String.parse);
          authorize_all_groups =
            (Util.option_bind (Xml.member "AuthorizeAllGroups" xml)
               Boolean.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.authorize_all_groups
             (fun f ->
                Query.Pair ("AuthorizeAllGroups", (Boolean.to_query f)));
           Util.option_map v.access_group_id
             (fun f -> Query.Pair ("AccessGroupId", (String.to_query f)));
           Some
             (Query.Pair
                ("TargetNetworkCidr",
                  (String.to_query v.target_network_cidr)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Some
                    (Ezxmlm.make_tag "ClientVpnEndpointId"
                       ([], (String.to_xml v.client_vpn_endpoint_id)))])
                @
                [Some
                   (Ezxmlm.make_tag "TargetNetworkCidr"
                      ([], (String.to_xml v.target_network_cidr)))])
               @
               [Util.option_map v.access_group_id
                  (fun f ->
                     Ezxmlm.make_tag "AccessGroupId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.authorize_all_groups
                 (fun f ->
                    Ezxmlm.make_tag "AuthorizeAllGroups"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
            @
            [Util.option_map v.client_token
               (fun f ->
                  Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.authorize_all_groups
             (fun f -> ("authorize_all_groups", (Boolean.to_json f)));
           Util.option_map v.access_group_id
             (fun f -> ("access_group_id", (String.to_json f)));
           Some
             ("target_network_cidr", (String.to_json v.target_network_cidr));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        target_network_cidr =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "target_network_cidr")));
        access_group_id =
          (Util.option_map (Json.lookup j "access_group_id") String.of_json);
        authorize_all_groups =
          (Util.option_map (Json.lookup j "authorize_all_groups")
             Boolean.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeNetworkInterfacePermissionsRequest =
  struct
    type t =
      {
      network_interface_permission_ids: NetworkInterfacePermissionIdList.t ;
      filters: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(network_interface_permission_ids= [])  ?(filters= []) 
      ?next_token  ?max_results  () =
      { network_interface_permission_ids; filters; next_token; max_results }
    let parse xml =
      Some
        {
          network_interface_permission_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "NetworkInterfacePermissionId" xml)
                  NetworkInterfacePermissionIdList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("NetworkInterfacePermissionId",
                  (NetworkInterfacePermissionIdList.to_query
                     v.network_interface_permission_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "NetworkInterfacePermissionId"
                         ([], (NetworkInterfacePermissionIdList.to_xml [x]))))
                 v.network_interface_permission_ids))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("network_interface_permission_ids",
               (NetworkInterfacePermissionIdList.to_json
                  v.network_interface_permission_ids))])
    let of_json j =
      {
        network_interface_permission_ids =
          (NetworkInterfacePermissionIdList.of_json
             (Util.of_option_exn
                (Json.lookup j "network_interface_permission_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DescribeTrafficMirrorFiltersRequest =
  struct
    type t =
      {
      traffic_mirror_filter_ids: ValueStringList.t ;
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(traffic_mirror_filter_ids= [])  ?dry_run  ?(filters= []) 
      ?max_results  ?next_token  () =
      { traffic_mirror_filter_ids; dry_run; filters; max_results; next_token
      }
    let parse xml =
      Some
        {
          traffic_mirror_filter_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "TrafficMirrorFilterId" xml)
                  ValueStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterId",
                  (ValueStringList.to_query v.traffic_mirror_filter_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "TrafficMirrorFilterId"
                          ([], (ValueStringList.to_xml [x]))))
                  v.traffic_mirror_filter_ids))
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("traffic_mirror_filter_ids",
               (ValueStringList.to_json v.traffic_mirror_filter_ids))])
    let of_json j =
      {
        traffic_mirror_filter_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_filter_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ReplaceTransitGatewayRouteRequest =
  struct
    type t =
      {
      destination_cidr_block: String.t ;
      transit_gateway_route_table_id: String.t ;
      transit_gateway_attachment_id: String.t option ;
      blackhole: Boolean.t option ;
      dry_run: Boolean.t option }
    let make ~destination_cidr_block  ~transit_gateway_route_table_id 
      ?transit_gateway_attachment_id  ?blackhole  ?dry_run  () =
      {
        destination_cidr_block;
        transit_gateway_route_table_id;
        transit_gateway_attachment_id;
        blackhole;
        dry_run
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "TransitGatewayAttachmentId" xml)
               String.parse);
          blackhole =
            (Util.option_bind (Xml.member "Blackhole" xml) Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.blackhole
             (fun f -> Query.Pair ("Blackhole", (Boolean.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "DestinationCidrBlock"
                     ([], (String.to_xml v.destination_cidr_block)))])
              @
              [Some
                 (Ezxmlm.make_tag "TransitGatewayRouteTableId"
                    ([], (String.to_xml v.transit_gateway_route_table_id)))])
             @
             [Util.option_map v.transit_gateway_attachment_id
                (fun f ->
                   Ezxmlm.make_tag "TransitGatewayAttachmentId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.blackhole
               (fun f -> Ezxmlm.make_tag "Blackhole" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.blackhole
             (fun f -> ("blackhole", (Boolean.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block))])
    let of_json j =
      {
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        blackhole =
          (Util.option_map (Json.lookup j "blackhole") Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateVpnGatewayRequest =
  struct
    type t =
      {
      availability_zone: String.t option ;
      type_: GatewayType.t ;
      amazon_side_asn: Long.t option ;
      dry_run: Boolean.t option }
    let make ?availability_zone  ~type_  ?amazon_side_asn  ?dry_run  () =
      { availability_zone; type_; amazon_side_asn; dry_run }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) GatewayType.parse));
          amazon_side_asn =
            (Util.option_bind (Xml.member "AmazonSideAsn" xml) Long.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.amazon_side_asn
             (fun f -> Query.Pair ("AmazonSideAsn", (Long.to_query f)));
           Some (Query.Pair ("Type", (GatewayType.to_query v.type_)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.availability_zone
                 (fun f ->
                    Ezxmlm.make_tag "AvailabilityZone"
                      ([], (String.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "Type" ([], (GatewayType.to_xml v.type_)))])
            @
            [Util.option_map v.amazon_side_asn
               (fun f ->
                  Ezxmlm.make_tag "AmazonSideAsn" ([], (Long.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.amazon_side_asn
             (fun f -> ("amazon_side_asn", (Long.to_json f)));
           Some ("type_", (GatewayType.to_json v.type_));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        type_ =
          (GatewayType.of_json (Util.of_option_exn (Json.lookup j "type_")));
        amazon_side_asn =
          (Util.option_map (Json.lookup j "amazon_side_asn") Long.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyTrafficMirrorSessionResult =
  struct
    type t = {
      traffic_mirror_session: TrafficMirrorSession.t option }
    let make ?traffic_mirror_session  () = { traffic_mirror_session }
    let parse xml =
      Some
        {
          traffic_mirror_session =
            (Util.option_bind (Xml.member "trafficMirrorSession" xml)
               TrafficMirrorSession.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_session
              (fun f ->
                 Query.Pair
                   ("TrafficMirrorSession",
                     (TrafficMirrorSession.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.traffic_mirror_session
              (fun f ->
                 Ezxmlm.make_tag "trafficMirrorSession"
                   ([], (TrafficMirrorSession.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_session
              (fun f ->
                 ("traffic_mirror_session", (TrafficMirrorSession.to_json f)))])
    let of_json j =
      {
        traffic_mirror_session =
          (Util.option_map (Json.lookup j "traffic_mirror_session")
             TrafficMirrorSession.of_json)
      }
  end
module DisableVpcClassicLinkDnsSupportResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module RegisterImageResult =
  struct
    type t = {
      image_id: String.t option }
    let make ?image_id  () = { image_id }
    let parse xml =
      Some
        {
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> Query.Pair ("ImageId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.image_id
              (fun f -> Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> ("image_id", (String.to_json f)))])
    let of_json j =
      {
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json)
      }
  end
module AttachVolumeRequest =
  struct
    type t =
      {
      device: String.t ;
      instance_id: String.t ;
      volume_id: String.t ;
      dry_run: Boolean.t option }
    let make ~device  ~instance_id  ~volume_id  ?dry_run  () =
      { device; instance_id; volume_id; dry_run }
    let parse xml =
      Some
        {
          device =
            (Xml.required "Device"
               (Util.option_bind (Xml.member "Device" xml) String.parse));
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Some (Query.Pair ("Device", (String.to_query v.device)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some (Ezxmlm.make_tag "Device" ([], (String.to_xml v.device)))])
             @
             [Some
                (Ezxmlm.make_tag "InstanceId"
                   ([], (String.to_xml v.instance_id)))])
            @
            [Some
               (Ezxmlm.make_tag "VolumeId" ([], (String.to_xml v.volume_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Some ("instance_id", (String.to_json v.instance_id));
           Some ("device", (String.to_json v.device))])
    let of_json j =
      {
        device =
          (String.of_json (Util.of_option_exn (Json.lookup j "device")));
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteLocalGatewayRouteResult =
  struct
    type t = {
      route: LocalGatewayRoute.t option }
    let make ?route  () = { route }
    let parse xml =
      Some
        {
          route =
            (Util.option_bind (Xml.member "route" xml)
               LocalGatewayRoute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> Query.Pair ("Route", (LocalGatewayRoute.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.route
              (fun f ->
                 Ezxmlm.make_tag "route" ([], (LocalGatewayRoute.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> ("route", (LocalGatewayRoute.to_json f)))])
    let of_json j =
      {
        route =
          (Util.option_map (Json.lookup j "route") LocalGatewayRoute.of_json)
      }
  end
module CancelReservedInstancesListingResult =
  struct
    type t = {
      reserved_instances_listings: ReservedInstancesListingList.t }
    let make ?(reserved_instances_listings= [])  () =
      { reserved_instances_listings }
    let parse xml =
      Some
        {
          reserved_instances_listings =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesListingsSet" xml)
                  ReservedInstancesListingList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesListingsSet",
                   (ReservedInstancesListingList.to_query
                      v.reserved_instances_listings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "reservedInstancesListingsSet"
                      ([], (ReservedInstancesListingList.to_xml [x]))))
              v.reserved_instances_listings))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_listings",
                (ReservedInstancesListingList.to_json
                   v.reserved_instances_listings))])
    let of_json j =
      {
        reserved_instances_listings =
          (ReservedInstancesListingList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_listings")))
      }
  end
module CreateTagsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      resources: ResourceIdList.t ;
      tags: TagList.t }
    let make ?dry_run  ~resources  ~tags  () = { dry_run; resources; tags }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          resources =
            (Xml.required "ResourceId"
               (Util.option_bind (Xml.member "ResourceId" xml)
                  ResourceIdList.parse));
          tags =
            (Xml.required "Tag"
               (Util.option_bind (Xml.member "Tag" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Tag", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("ResourceId", (ResourceIdList.to_query v.resources)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ResourceId"
                       ([], (ResourceIdList.to_xml [x])))) v.resources))
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "Tag" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some ("resources", (ResourceIdList.to_json v.resources));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        resources =
          (ResourceIdList.of_json
             (Util.of_option_exn (Json.lookup j "resources")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module RegisterTransitGatewayMulticastGroupMembersRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      group_ip_address: String.t option ;
      network_interface_ids: ValueStringList.t ;
      dry_run: Boolean.t option }
    let make ?transit_gateway_multicast_domain_id  ?group_ip_address 
      ?(network_interface_ids= [])  ?dry_run  () =
      {
        transit_gateway_multicast_domain_id;
        group_ip_address;
        network_interface_ids;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse);
          group_ip_address =
            (Util.option_bind (Xml.member "GroupIpAddress" xml) String.parse);
          network_interface_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterfaceIds" xml)
                  ValueStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceIds",
                  (ValueStringList.to_query v.network_interface_ids)));
           Util.option_map v.group_ip_address
             (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.transit_gateway_multicast_domain_id
                 (fun f ->
                    Ezxmlm.make_tag "TransitGatewayMulticastDomainId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.group_ip_address
                (fun f ->
                   Ezxmlm.make_tag "GroupIpAddress" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "NetworkInterfaceIds"
                       ([], (ValueStringList.to_xml [x]))))
               v.network_interface_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("network_interface_ids",
               (ValueStringList.to_json v.network_interface_ids));
           Util.option_map v.group_ip_address
             (fun f -> ("group_ip_address", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json);
        network_interface_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreatePlacementGroupRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_name: String.t option ;
      strategy: PlacementStrategy.t option ;
      partition_count: Integer.t option }
    let make ?dry_run  ?group_name  ?strategy  ?partition_count  () =
      { dry_run; group_name; strategy; partition_count }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          strategy =
            (Util.option_bind (Xml.member "strategy" xml)
               PlacementStrategy.parse);
          partition_count =
            (Util.option_bind (Xml.member "PartitionCount" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.partition_count
              (fun f -> Query.Pair ("PartitionCount", (Integer.to_query f)));
           Util.option_map v.strategy
             (fun f ->
                Query.Pair ("Strategy", (PlacementStrategy.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.group_name
                (fun f -> Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
            @
            [Util.option_map v.strategy
               (fun f ->
                  Ezxmlm.make_tag "strategy"
                    ([], (PlacementStrategy.to_xml f)))])
           @
           [Util.option_map v.partition_count
              (fun f ->
                 Ezxmlm.make_tag "PartitionCount" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.partition_count
              (fun f -> ("partition_count", (Integer.to_json f)));
           Util.option_map v.strategy
             (fun f -> ("strategy", (PlacementStrategy.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        strategy =
          (Util.option_map (Json.lookup j "strategy")
             PlacementStrategy.of_json);
        partition_count =
          (Util.option_map (Json.lookup j "partition_count") Integer.of_json)
      }
  end
module RejectTransitGatewayVpcAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_attachment_id  ?dry_run  () =
      { transit_gateway_attachment_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "TransitGatewayAttachmentId"
                  ([], (String.to_xml v.transit_gateway_attachment_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AssociateAddressRequest =
  struct
    type t =
      {
      allocation_id: String.t option ;
      instance_id: String.t option ;
      public_ip: String.t option ;
      allow_reassociation: Boolean.t option ;
      dry_run: Boolean.t option ;
      network_interface_id: String.t option ;
      private_ip_address: String.t option }
    let make ?allocation_id  ?instance_id  ?public_ip  ?allow_reassociation 
      ?dry_run  ?network_interface_id  ?private_ip_address  () =
      {
        allocation_id;
        instance_id;
        public_ip;
        allow_reassociation;
        dry_run;
        network_interface_id;
        private_ip_address
      }
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "AllocationId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "PublicIp" xml) String.parse);
          allow_reassociation =
            (Util.option_bind (Xml.member "allowReassociation" xml)
               Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.allow_reassociation
             (fun f ->
                Query.Pair ("AllowReassociation", (Boolean.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.allocation_id
                    (fun f ->
                       Ezxmlm.make_tag "AllocationId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.instance_id
                   (fun f ->
                      Ezxmlm.make_tag "InstanceId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.public_ip
                  (fun f ->
                     Ezxmlm.make_tag "PublicIp" ([], (String.to_xml f)))])
              @
              [Util.option_map v.allow_reassociation
                 (fun f ->
                    Ezxmlm.make_tag "allowReassociation"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.network_interface_id
               (fun f ->
                  Ezxmlm.make_tag "networkInterfaceId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.private_ip_address
              (fun f ->
                 Ezxmlm.make_tag "privateIpAddress" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.allow_reassociation
             (fun f -> ("allow_reassociation", (Boolean.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let of_json j =
      {
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        allow_reassociation =
          (Util.option_map (Json.lookup j "allow_reassociation")
             Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json)
      }
  end
module DeleteTrafficMirrorFilterRuleRequest =
  struct
    type t =
      {
      traffic_mirror_filter_rule_id: String.t ;
      dry_run: Boolean.t option }
    let make ~traffic_mirror_filter_rule_id  ?dry_run  () =
      { traffic_mirror_filter_rule_id; dry_run }
    let parse xml =
      Some
        {
          traffic_mirror_filter_rule_id =
            (Xml.required "TrafficMirrorFilterRuleId"
               (Util.option_bind (Xml.member "TrafficMirrorFilterRuleId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterRuleId",
                  (String.to_query v.traffic_mirror_filter_rule_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "TrafficMirrorFilterRuleId"
                  ([], (String.to_xml v.traffic_mirror_filter_rule_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("traffic_mirror_filter_rule_id",
               (String.to_json v.traffic_mirror_filter_rule_id))])
    let of_json j =
      {
        traffic_mirror_filter_rule_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "traffic_mirror_filter_rule_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyVpnTunnelOptionsRequest =
  struct
    type t =
      {
      vpn_connection_id: String.t ;
      vpn_tunnel_outside_ip_address: String.t ;
      tunnel_options: ModifyVpnTunnelOptionsSpecification.t ;
      dry_run: Boolean.t option }
    let make ~vpn_connection_id  ~vpn_tunnel_outside_ip_address 
      ~tunnel_options  ?dry_run  () =
      {
        vpn_connection_id;
        vpn_tunnel_outside_ip_address;
        tunnel_options;
        dry_run
      }
    let parse xml =
      Some
        {
          vpn_connection_id =
            (Xml.required "VpnConnectionId"
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  String.parse));
          vpn_tunnel_outside_ip_address =
            (Xml.required "VpnTunnelOutsideIpAddress"
               (Util.option_bind (Xml.member "VpnTunnelOutsideIpAddress" xml)
                  String.parse));
          tunnel_options =
            (Xml.required "TunnelOptions"
               (Util.option_bind (Xml.member "TunnelOptions" xml)
                  ModifyVpnTunnelOptionsSpecification.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TunnelOptions",
                  (ModifyVpnTunnelOptionsSpecification.to_query
                     v.tunnel_options)));
           Some
             (Query.Pair
                ("VpnTunnelOutsideIpAddress",
                  (String.to_query v.vpn_tunnel_outside_ip_address)));
           Some
             (Query.Pair
                ("VpnConnectionId", (String.to_query v.vpn_connection_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "VpnConnectionId"
                    ([], (String.to_xml v.vpn_connection_id)))])
             @
             [Some
                (Ezxmlm.make_tag "VpnTunnelOutsideIpAddress"
                   ([], (String.to_xml v.vpn_tunnel_outside_ip_address)))])
            @
            [Some
               (Ezxmlm.make_tag "TunnelOptions"
                  ([],
                    (ModifyVpnTunnelOptionsSpecification.to_xml
                       v.tunnel_options)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tunnel_options",
               (ModifyVpnTunnelOptionsSpecification.to_json v.tunnel_options));
           Some
             ("vpn_tunnel_outside_ip_address",
               (String.to_json v.vpn_tunnel_outside_ip_address));
           Some ("vpn_connection_id", (String.to_json v.vpn_connection_id))])
    let of_json j =
      {
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")));
        vpn_tunnel_outside_ip_address =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "vpn_tunnel_outside_ip_address")));
        tunnel_options =
          (ModifyVpnTunnelOptionsSpecification.of_json
             (Util.of_option_exn (Json.lookup j "tunnel_options")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module RejectVpcPeeringConnectionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_peering_connection_id: String.t }
    let make ?dry_run  ~vpc_peering_connection_id  () =
      { dry_run; vpc_peering_connection_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_peering_connection_id =
            (Xml.required "vpcPeeringConnectionId"
               (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcPeeringConnectionId",
                   (String.to_query v.vpc_peering_connection_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "vpcPeeringConnectionId"
                 ([], (String.to_xml v.vpc_peering_connection_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpc_peering_connection_id",
                (String.to_json v.vpc_peering_connection_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_peering_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpc_peering_connection_id")))
      }
  end
module AllocateAddressRequest =
  struct
    type t =
      {
      domain: DomainType.t option ;
      address: String.t option ;
      public_ipv4_pool: String.t option ;
      network_border_group: String.t option ;
      customer_owned_ipv4_pool: String.t option ;
      dry_run: Boolean.t option }
    let make ?domain  ?address  ?public_ipv4_pool  ?network_border_group 
      ?customer_owned_ipv4_pool  ?dry_run  () =
      {
        domain;
        address;
        public_ipv4_pool;
        network_border_group;
        customer_owned_ipv4_pool;
        dry_run
      }
    let parse xml =
      Some
        {
          domain =
            (Util.option_bind (Xml.member "Domain" xml) DomainType.parse);
          address =
            (Util.option_bind (Xml.member "Address" xml) String.parse);
          public_ipv4_pool =
            (Util.option_bind (Xml.member "PublicIpv4Pool" xml) String.parse);
          network_border_group =
            (Util.option_bind (Xml.member "NetworkBorderGroup" xml)
               String.parse);
          customer_owned_ipv4_pool =
            (Util.option_bind (Xml.member "CustomerOwnedIpv4Pool" xml)
               String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.customer_owned_ipv4_pool
             (fun f ->
                Query.Pair ("CustomerOwnedIpv4Pool", (String.to_query f)));
           Util.option_map v.network_border_group
             (fun f -> Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.public_ipv4_pool
             (fun f -> Query.Pair ("PublicIpv4Pool", (String.to_query f)));
           Util.option_map v.address
             (fun f -> Query.Pair ("Address", (String.to_query f)));
           Util.option_map v.domain
             (fun f -> Query.Pair ("Domain", (DomainType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.domain
                   (fun f ->
                      Ezxmlm.make_tag "Domain" ([], (DomainType.to_xml f)))])
               @
               [Util.option_map v.address
                  (fun f -> Ezxmlm.make_tag "Address" ([], (String.to_xml f)))])
              @
              [Util.option_map v.public_ipv4_pool
                 (fun f ->
                    Ezxmlm.make_tag "PublicIpv4Pool" ([], (String.to_xml f)))])
             @
             [Util.option_map v.network_border_group
                (fun f ->
                   Ezxmlm.make_tag "NetworkBorderGroup"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.customer_owned_ipv4_pool
               (fun f ->
                  Ezxmlm.make_tag "CustomerOwnedIpv4Pool"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.customer_owned_ipv4_pool
             (fun f -> ("customer_owned_ipv4_pool", (String.to_json f)));
           Util.option_map v.network_border_group
             (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.public_ipv4_pool
             (fun f -> ("public_ipv4_pool", (String.to_json f)));
           Util.option_map v.address
             (fun f -> ("address", (String.to_json f)));
           Util.option_map v.domain
             (fun f -> ("domain", (DomainType.to_json f)))])
    let of_json j =
      {
        domain =
          (Util.option_map (Json.lookup j "domain") DomainType.of_json);
        address = (Util.option_map (Json.lookup j "address") String.of_json);
        public_ipv4_pool =
          (Util.option_map (Json.lookup j "public_ipv4_pool") String.of_json);
        network_border_group =
          (Util.option_map (Json.lookup j "network_border_group")
             String.of_json);
        customer_owned_ipv4_pool =
          (Util.option_map (Json.lookup j "customer_owned_ipv4_pool")
             String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateTrafficMirrorSessionRequest =
  struct
    type t =
      {
      network_interface_id: String.t ;
      traffic_mirror_target_id: String.t ;
      traffic_mirror_filter_id: String.t ;
      packet_length: Integer.t option ;
      session_number: Integer.t ;
      virtual_network_id: Integer.t option ;
      description: String.t option ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option ;
      client_token: String.t option }
    let make ~network_interface_id  ~traffic_mirror_target_id 
      ~traffic_mirror_filter_id  ?packet_length  ~session_number 
      ?virtual_network_id  ?description  ?(tag_specifications= [])  ?dry_run 
      ?client_token  () =
      {
        network_interface_id;
        traffic_mirror_target_id;
        traffic_mirror_filter_id;
        packet_length;
        session_number;
        virtual_network_id;
        description;
        tag_specifications;
        dry_run;
        client_token
      }
    let parse xml =
      Some
        {
          network_interface_id =
            (Xml.required "NetworkInterfaceId"
               (Util.option_bind (Xml.member "NetworkInterfaceId" xml)
                  String.parse));
          traffic_mirror_target_id =
            (Xml.required "TrafficMirrorTargetId"
               (Util.option_bind (Xml.member "TrafficMirrorTargetId" xml)
                  String.parse));
          traffic_mirror_filter_id =
            (Xml.required "TrafficMirrorFilterId"
               (Util.option_bind (Xml.member "TrafficMirrorFilterId" xml)
                  String.parse));
          packet_length =
            (Util.option_bind (Xml.member "PacketLength" xml) Integer.parse);
          session_number =
            (Xml.required "SessionNumber"
               (Util.option_bind (Xml.member "SessionNumber" xml)
                  Integer.parse));
          virtual_network_id =
            (Util.option_bind (Xml.member "VirtualNetworkId" xml)
               Integer.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.virtual_network_id
             (fun f -> Query.Pair ("VirtualNetworkId", (Integer.to_query f)));
           Some
             (Query.Pair
                ("SessionNumber", (Integer.to_query v.session_number)));
           Util.option_map v.packet_length
             (fun f -> Query.Pair ("PacketLength", (Integer.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterId",
                  (String.to_query v.traffic_mirror_filter_id)));
           Some
             (Query.Pair
                ("TrafficMirrorTargetId",
                  (String.to_query v.traffic_mirror_target_id)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Some
                       (Ezxmlm.make_tag "NetworkInterfaceId"
                          ([], (String.to_xml v.network_interface_id)))])
                   @
                   [Some
                      (Ezxmlm.make_tag "TrafficMirrorTargetId"
                         ([], (String.to_xml v.traffic_mirror_target_id)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "TrafficMirrorFilterId"
                        ([], (String.to_xml v.traffic_mirror_filter_id)))])
                 @
                 [Util.option_map v.packet_length
                    (fun f ->
                       Ezxmlm.make_tag "PacketLength"
                         ([], (Integer.to_xml f)))])
                @
                [Some
                   (Ezxmlm.make_tag "SessionNumber"
                      ([], (Integer.to_xml v.session_number)))])
               @
               [Util.option_map v.virtual_network_id
                  (fun f ->
                     Ezxmlm.make_tag "VirtualNetworkId"
                       ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "TagSpecification"
                        ([], (TagSpecificationList.to_xml [x]))))
                v.tag_specifications))
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.virtual_network_id
             (fun f -> ("virtual_network_id", (Integer.to_json f)));
           Some ("session_number", (Integer.to_json v.session_number));
           Util.option_map v.packet_length
             (fun f -> ("packet_length", (Integer.to_json f)));
           Some
             ("traffic_mirror_filter_id",
               (String.to_json v.traffic_mirror_filter_id));
           Some
             ("traffic_mirror_target_id",
               (String.to_json v.traffic_mirror_target_id));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id))])
    let of_json j =
      {
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        traffic_mirror_target_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_target_id")));
        traffic_mirror_filter_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_filter_id")));
        packet_length =
          (Util.option_map (Json.lookup j "packet_length") Integer.of_json);
        session_number =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "session_number")));
        virtual_network_id =
          (Util.option_map (Json.lookup j "virtual_network_id")
             Integer.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module BundleInstanceResult =
  struct
    type t = {
      bundle_task: BundleTask.t option }
    let make ?bundle_task  () = { bundle_task }
    let parse xml =
      Some
        {
          bundle_task =
            (Util.option_bind (Xml.member "bundleInstanceTask" xml)
               BundleTask.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.bundle_task
              (fun f ->
                 Query.Pair ("BundleInstanceTask", (BundleTask.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.bundle_task
              (fun f ->
                 Ezxmlm.make_tag "bundleInstanceTask"
                   ([], (BundleTask.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.bundle_task
              (fun f -> ("bundle_task", (BundleTask.to_json f)))])
    let of_json j =
      {
        bundle_task =
          (Util.option_map (Json.lookup j "bundle_task") BundleTask.of_json)
      }
  end
module DescribeTransitGatewayRouteTablesResult =
  struct
    type t =
      {
      transit_gateway_route_tables: TransitGatewayRouteTableList.t ;
      next_token: String.t option }
    let make ?(transit_gateway_route_tables= [])  ?next_token  () =
      { transit_gateway_route_tables; next_token }
    let parse xml =
      Some
        {
          transit_gateway_route_tables =
            (Util.of_option []
               (Util.option_bind (Xml.member "transitGatewayRouteTables" xml)
                  TransitGatewayRouteTableList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTables",
                  (TransitGatewayRouteTableList.to_query
                     v.transit_gateway_route_tables)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "transitGatewayRouteTables"
                       ([], (TransitGatewayRouteTableList.to_xml [x]))))
               v.transit_gateway_route_tables))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_route_tables",
               (TransitGatewayRouteTableList.to_json
                  v.transit_gateway_route_tables))])
    let of_json j =
      {
        transit_gateway_route_tables =
          (TransitGatewayRouteTableList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_tables")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module AssociateSubnetCidrBlockResult =
  struct
    type t =
      {
      ipv6_cidr_block_association: SubnetIpv6CidrBlockAssociation.t option ;
      subnet_id: String.t option }
    let make ?ipv6_cidr_block_association  ?subnet_id  () =
      { ipv6_cidr_block_association; subnet_id }
    let parse xml =
      Some
        {
          ipv6_cidr_block_association =
            (Util.option_bind (Xml.member "ipv6CidrBlockAssociation" xml)
               SubnetIpv6CidrBlockAssociation.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockAssociation",
                    (SubnetIpv6CidrBlockAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.ipv6_cidr_block_association
               (fun f ->
                  Ezxmlm.make_tag "ipv6CidrBlockAssociation"
                    ([], (SubnetIpv6CidrBlockAssociation.to_xml f)))])
           @
           [Util.option_map v.subnet_id
              (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                ("ipv6_cidr_block_association",
                  (SubnetIpv6CidrBlockAssociation.to_json f)))])
    let of_json j =
      {
        ipv6_cidr_block_association =
          (Util.option_map (Json.lookup j "ipv6_cidr_block_association")
             SubnetIpv6CidrBlockAssociation.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json)
      }
  end
module CreateRouteTableRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      vpc_id: String.t }
    let make ?dry_run  ~vpc_id  () = { dry_run; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @ [Some (Ezxmlm.make_tag "vpcId" ([], (String.to_xml v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module InstanceAttribute =
  struct
    type t =
      {
      groups: GroupIdentifierList.t ;
      block_device_mappings: InstanceBlockDeviceMappingList.t ;
      disable_api_termination: AttributeBooleanValue.t option ;
      ena_support: AttributeBooleanValue.t option ;
      ebs_optimized: AttributeBooleanValue.t option ;
      instance_id: String.t option ;
      instance_initiated_shutdown_behavior: AttributeValue.t option ;
      instance_type: AttributeValue.t option ;
      kernel_id: AttributeValue.t option ;
      product_codes: ProductCodeList.t ;
      ramdisk_id: AttributeValue.t option ;
      root_device_name: AttributeValue.t option ;
      source_dest_check: AttributeBooleanValue.t option ;
      sriov_net_support: AttributeValue.t option ;
      user_data: AttributeValue.t option }
    let make ?(groups= [])  ?(block_device_mappings= []) 
      ?disable_api_termination  ?ena_support  ?ebs_optimized  ?instance_id 
      ?instance_initiated_shutdown_behavior  ?instance_type  ?kernel_id 
      ?(product_codes= [])  ?ramdisk_id  ?root_device_name 
      ?source_dest_check  ?sriov_net_support  ?user_data  () =
      {
        groups;
        block_device_mappings;
        disable_api_termination;
        ena_support;
        ebs_optimized;
        instance_id;
        instance_initiated_shutdown_behavior;
        instance_type;
        kernel_id;
        product_codes;
        ramdisk_id;
        root_device_name;
        source_dest_check;
        sriov_net_support;
        user_data
      }
    let parse xml =
      Some
        {
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  InstanceBlockDeviceMappingList.parse));
          disable_api_termination =
            (Util.option_bind (Xml.member "disableApiTermination" xml)
               AttributeBooleanValue.parse);
          ena_support =
            (Util.option_bind (Xml.member "enaSupport" xml)
               AttributeBooleanValue.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml)
               AttributeBooleanValue.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               AttributeValue.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               AttributeValue.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernel" xml) AttributeValue.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdisk" xml) AttributeValue.parse);
          root_device_name =
            (Util.option_bind (Xml.member "rootDeviceName" xml)
               AttributeValue.parse);
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               AttributeBooleanValue.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml)
               AttributeValue.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml)
               AttributeValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> Query.Pair ("UserData", (AttributeValue.to_query f)));
           Util.option_map v.sriov_net_support
             (fun f ->
                Query.Pair ("SriovNetSupport", (AttributeValue.to_query f)));
           Util.option_map v.source_dest_check
             (fun f ->
                Query.Pair
                  ("SourceDestCheck", (AttributeBooleanValue.to_query f)));
           Util.option_map v.root_device_name
             (fun f ->
                Query.Pair ("RootDeviceName", (AttributeValue.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("Ramdisk", (AttributeValue.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("Kernel", (AttributeValue.to_query f)));
           Util.option_map v.instance_type
             (fun f ->
                Query.Pair ("InstanceType", (AttributeValue.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (AttributeValue.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f ->
                Query.Pair
                  ("EbsOptimized", (AttributeBooleanValue.to_query f)));
           Util.option_map v.ena_support
             (fun f ->
                Query.Pair ("EnaSupport", (AttributeBooleanValue.to_query f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                Query.Pair
                  ("DisableApiTermination",
                    (AttributeBooleanValue.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (InstanceBlockDeviceMappingList.to_query
                     v.block_device_mappings)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         (List.map
                            (fun x ->
                               Some
                                 (Ezxmlm.make_tag "groupSet"
                                    ([], (GroupIdentifierList.to_xml [x]))))
                            v.groups))
                        @
                        (List.map
                           (fun x ->
                              Some
                                (Ezxmlm.make_tag "blockDeviceMapping"
                                   ([],
                                     (InstanceBlockDeviceMappingList.to_xml
                                        [x])))) v.block_device_mappings))
                       @
                       [Util.option_map v.disable_api_termination
                          (fun f ->
                             Ezxmlm.make_tag "disableApiTermination"
                               ([], (AttributeBooleanValue.to_xml f)))])
                      @
                      [Util.option_map v.ena_support
                         (fun f ->
                            Ezxmlm.make_tag "enaSupport"
                              ([], (AttributeBooleanValue.to_xml f)))])
                     @
                     [Util.option_map v.ebs_optimized
                        (fun f ->
                           Ezxmlm.make_tag "ebsOptimized"
                             ([], (AttributeBooleanValue.to_xml f)))])
                    @
                    [Util.option_map v.instance_id
                       (fun f ->
                          Ezxmlm.make_tag "instanceId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.instance_initiated_shutdown_behavior
                      (fun f ->
                         Ezxmlm.make_tag "instanceInitiatedShutdownBehavior"
                           ([], (AttributeValue.to_xml f)))])
                  @
                  [Util.option_map v.instance_type
                     (fun f ->
                        Ezxmlm.make_tag "instanceType"
                          ([], (AttributeValue.to_xml f)))])
                 @
                 [Util.option_map v.kernel_id
                    (fun f ->
                       Ezxmlm.make_tag "kernel"
                         ([], (AttributeValue.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "productCodes"
                           ([], (ProductCodeList.to_xml [x]))))
                   v.product_codes))
               @
               [Util.option_map v.ramdisk_id
                  (fun f ->
                     Ezxmlm.make_tag "ramdisk"
                       ([], (AttributeValue.to_xml f)))])
              @
              [Util.option_map v.root_device_name
                 (fun f ->
                    Ezxmlm.make_tag "rootDeviceName"
                      ([], (AttributeValue.to_xml f)))])
             @
             [Util.option_map v.source_dest_check
                (fun f ->
                   Ezxmlm.make_tag "sourceDestCheck"
                     ([], (AttributeBooleanValue.to_xml f)))])
            @
            [Util.option_map v.sriov_net_support
               (fun f ->
                  Ezxmlm.make_tag "sriovNetSupport"
                    ([], (AttributeValue.to_xml f)))])
           @
           [Util.option_map v.user_data
              (fun f ->
                 Ezxmlm.make_tag "userData" ([], (AttributeValue.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> ("user_data", (AttributeValue.to_json f)));
           Util.option_map v.sriov_net_support
             (fun f -> ("sriov_net_support", (AttributeValue.to_json f)));
           Util.option_map v.source_dest_check
             (fun f ->
                ("source_dest_check", (AttributeBooleanValue.to_json f)));
           Util.option_map v.root_device_name
             (fun f -> ("root_device_name", (AttributeValue.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (AttributeValue.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (AttributeValue.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (AttributeValue.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (AttributeValue.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (AttributeBooleanValue.to_json f)));
           Util.option_map v.ena_support
             (fun f -> ("ena_support", (AttributeBooleanValue.to_json f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                ("disable_api_termination",
                  (AttributeBooleanValue.to_json f)));
           Some
             ("block_device_mappings",
               (InstanceBlockDeviceMappingList.to_json
                  v.block_device_mappings));
           Some ("groups", (GroupIdentifierList.to_json v.groups))])
    let of_json j =
      {
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        block_device_mappings =
          (InstanceBlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        disable_api_termination =
          (Util.option_map (Json.lookup j "disable_api_termination")
             AttributeBooleanValue.of_json);
        ena_support =
          (Util.option_map (Json.lookup j "ena_support")
             AttributeBooleanValue.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized")
             AttributeBooleanValue.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_initiated_shutdown_behavior =
          (Util.option_map
             (Json.lookup j "instance_initiated_shutdown_behavior")
             AttributeValue.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             AttributeValue.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") AttributeValue.of_json);
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id")
             AttributeValue.of_json);
        root_device_name =
          (Util.option_map (Json.lookup j "root_device_name")
             AttributeValue.of_json);
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             AttributeBooleanValue.of_json);
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support")
             AttributeValue.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") AttributeValue.of_json)
      }
  end
module CreateEgressOnlyInternetGatewayRequest =
  struct
    type t =
      {
      client_token: String.t option ;
      dry_run: Boolean.t option ;
      vpc_id: String.t }
    let make ?client_token  ?dry_run  ~vpc_id  () =
      { client_token; dry_run; vpc_id }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.client_token
                (fun f ->
                   Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @ [Some (Ezxmlm.make_tag "VpcId" ([], (String.to_xml v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DescribeRouteTablesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      route_table_ids: ValueStringList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?dry_run  ?(route_table_ids= [])  ?next_token 
      ?max_results  () =
      { filters; dry_run; route_table_ids; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RouteTableId" xml)
                  ValueStringList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("RouteTableId",
                  (ValueStringList.to_query v.route_table_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filter"
                          ([], (FilterList.to_xml [x])))) v.filters))
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "RouteTableId"
                        ([], (ValueStringList.to_xml [x]))))
                v.route_table_ids))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("route_table_ids", (ValueStringList.to_json v.route_table_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        route_table_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "route_table_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module ImportSnapshotRequest =
  struct
    type t =
      {
      client_data: ClientData.t option ;
      client_token: String.t option ;
      description: String.t option ;
      disk_container: SnapshotDiskContainer.t option ;
      dry_run: Boolean.t option ;
      encrypted: Boolean.t option ;
      kms_key_id: String.t option ;
      role_name: String.t option }
    let make ?client_data  ?client_token  ?description  ?disk_container 
      ?dry_run  ?encrypted  ?kms_key_id  ?role_name  () =
      {
        client_data;
        client_token;
        description;
        disk_container;
        dry_run;
        encrypted;
        kms_key_id;
        role_name
      }
    let parse xml =
      Some
        {
          client_data =
            (Util.option_bind (Xml.member "ClientData" xml) ClientData.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          disk_container =
            (Util.option_bind (Xml.member "DiskContainer" xml)
               SnapshotDiskContainer.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          encrypted =
            (Util.option_bind (Xml.member "Encrypted" xml) Boolean.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "KmsKeyId" xml) String.parse);
          role_name =
            (Util.option_bind (Xml.member "RoleName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.role_name
              (fun f -> Query.Pair ("RoleName", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.disk_container
             (fun f ->
                Query.Pair
                  ("DiskContainer", (SnapshotDiskContainer.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.client_data
             (fun f -> Query.Pair ("ClientData", (ClientData.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.client_data
                     (fun f ->
                        Ezxmlm.make_tag "ClientData"
                          ([], (ClientData.to_xml f)))])
                 @
                 [Util.option_map v.client_token
                    (fun f ->
                       Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
                @
                [Util.option_map v.description
                   (fun f ->
                      Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
               @
               [Util.option_map v.disk_container
                  (fun f ->
                     Ezxmlm.make_tag "DiskContainer"
                       ([], (SnapshotDiskContainer.to_xml f)))])
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.encrypted
                (fun f ->
                   Ezxmlm.make_tag "Encrypted" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.kms_key_id
               (fun f -> Ezxmlm.make_tag "KmsKeyId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.role_name
              (fun f -> Ezxmlm.make_tag "RoleName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.role_name
              (fun f -> ("role_name", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.disk_container
             (fun f -> ("disk_container", (SnapshotDiskContainer.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.client_data
             (fun f -> ("client_data", (ClientData.to_json f)))])
    let of_json j =
      {
        client_data =
          (Util.option_map (Json.lookup j "client_data") ClientData.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        disk_container =
          (Util.option_map (Json.lookup j "disk_container")
             SnapshotDiskContainer.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        role_name =
          (Util.option_map (Json.lookup j "role_name") String.of_json)
      }
  end
module ModifyHostsResult =
  struct
    type t =
      {
      successful: ResponseHostIdList.t ;
      unsuccessful: UnsuccessfulItemList.t }
    let make ?(successful= [])  ?(unsuccessful= [])  () =
      { successful; unsuccessful }
    let parse xml =
      Some
        {
          successful =
            (Util.of_option []
               (Util.option_bind (Xml.member "successful" xml)
                  ResponseHostIdList.parse));
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemList.to_query v.unsuccessful)));
           Some
             (Query.Pair
                ("Successful", (ResponseHostIdList.to_query v.successful)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "successful"
                       ([], (ResponseHostIdList.to_xml [x])))) v.successful))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "unsuccessful"
                      ([], (UnsuccessfulItemList.to_xml [x]))))
              v.unsuccessful))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemList.to_json v.unsuccessful));
           Some ("successful", (ResponseHostIdList.to_json v.successful))])
    let of_json j =
      {
        successful =
          (ResponseHostIdList.of_json
             (Util.of_option_exn (Json.lookup j "successful")));
        unsuccessful =
          (UnsuccessfulItemList.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module DeregisterTransitGatewayMulticastGroupMembersResult =
  struct
    type t =
      {
      deregistered_multicast_group_members:
        TransitGatewayMulticastDeregisteredGroupMembers.t option }
    let make ?deregistered_multicast_group_members  () =
      { deregistered_multicast_group_members }
    let parse xml =
      Some
        {
          deregistered_multicast_group_members =
            (Util.option_bind
               (Xml.member "deregisteredMulticastGroupMembers" xml)
               TransitGatewayMulticastDeregisteredGroupMembers.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.deregistered_multicast_group_members
              (fun f ->
                 Query.Pair
                   ("DeregisteredMulticastGroupMembers",
                     (TransitGatewayMulticastDeregisteredGroupMembers.to_query
                        f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.deregistered_multicast_group_members
              (fun f ->
                 Ezxmlm.make_tag "deregisteredMulticastGroupMembers"
                   ([],
                     (TransitGatewayMulticastDeregisteredGroupMembers.to_xml
                        f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.deregistered_multicast_group_members
              (fun f ->
                 ("deregistered_multicast_group_members",
                   (TransitGatewayMulticastDeregisteredGroupMembers.to_json f)))])
    let of_json j =
      {
        deregistered_multicast_group_members =
          (Util.option_map
             (Json.lookup j "deregistered_multicast_group_members")
             TransitGatewayMulticastDeregisteredGroupMembers.of_json)
      }
  end
module DescribeClientVpnAuthorizationRulesResult =
  struct
    type t =
      {
      authorization_rules: AuthorizationRuleSet.t ;
      next_token: String.t option }
    let make ?(authorization_rules= [])  ?next_token  () =
      { authorization_rules; next_token }
    let parse xml =
      Some
        {
          authorization_rules =
            (Util.of_option []
               (Util.option_bind (Xml.member "authorizationRule" xml)
                  AuthorizationRuleSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("AuthorizationRule",
                  (AuthorizationRuleSet.to_query v.authorization_rules)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "authorizationRule"
                       ([], (AuthorizationRuleSet.to_xml [x]))))
               v.authorization_rules))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("authorization_rules",
               (AuthorizationRuleSet.to_json v.authorization_rules))])
    let of_json j =
      {
        authorization_rules =
          (AuthorizationRuleSet.of_json
             (Util.of_option_exn (Json.lookup j "authorization_rules")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeFleetInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      fleet_id: String.t ;
      filters: FilterList.t }
    let make ?dry_run  ?max_results  ?next_token  ~fleet_id  ?(filters= []) 
      () = { dry_run; max_results; next_token; fleet_id; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          fleet_id =
            (Xml.required "FleetId"
               (Util.option_bind (Xml.member "FleetId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some (Query.Pair ("FleetId", (String.to_query v.fleet_id)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.max_results
                 (fun f ->
                    Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "FleetId" ([], (String.to_xml v.fleet_id)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
              v.filters))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some ("fleet_id", (String.to_json v.fleet_id));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        fleet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "fleet_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module StopInstancesResult =
  struct
    type t = {
      stopping_instances: InstanceStateChangeList.t }
    let make ?(stopping_instances= [])  () = { stopping_instances }
    let parse xml =
      Some
        {
          stopping_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceStateChangeList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceStateChangeList.to_query v.stopping_instances)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "instancesSet"
                      ([], (InstanceStateChangeList.to_xml [x]))))
              v.stopping_instances))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("stopping_instances",
                (InstanceStateChangeList.to_json v.stopping_instances))])
    let of_json j =
      {
        stopping_instances =
          (InstanceStateChangeList.of_json
             (Util.of_option_exn (Json.lookup j "stopping_instances")))
      }
  end
module RequestSpotFleetResponse =
  struct
    type t = {
      spot_fleet_request_id: String.t option }
    let make ?spot_fleet_request_id  () = { spot_fleet_request_id }
    let parse xml =
      Some
        {
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Query.Pair ("SpotFleetRequestId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Ezxmlm.make_tag "spotFleetRequestId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f -> ("spot_fleet_request_id", (String.to_json f)))])
    let of_json j =
      {
        spot_fleet_request_id =
          (Util.option_map (Json.lookup j "spot_fleet_request_id")
             String.of_json)
      }
  end
module GetTransitGatewayMulticastDomainAssociationsResult =
  struct
    type t =
      {
      multicast_domain_associations:
        TransitGatewayMulticastDomainAssociationList.t ;
      next_token: String.t option }
    let make ?(multicast_domain_associations= [])  ?next_token  () =
      { multicast_domain_associations; next_token }
    let parse xml =
      Some
        {
          multicast_domain_associations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "multicastDomainAssociations" xml)
                  TransitGatewayMulticastDomainAssociationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("MulticastDomainAssociations",
                  (TransitGatewayMulticastDomainAssociationList.to_query
                     v.multicast_domain_associations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "multicastDomainAssociations"
                       ([],
                         (TransitGatewayMulticastDomainAssociationList.to_xml
                            [x])))) v.multicast_domain_associations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("multicast_domain_associations",
               (TransitGatewayMulticastDomainAssociationList.to_json
                  v.multicast_domain_associations))])
    let of_json j =
      {
        multicast_domain_associations =
          (TransitGatewayMulticastDomainAssociationList.of_json
             (Util.of_option_exn
                (Json.lookup j "multicast_domain_associations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyTrafficMirrorSessionRequest =
  struct
    type t =
      {
      traffic_mirror_session_id: String.t ;
      traffic_mirror_target_id: String.t option ;
      traffic_mirror_filter_id: String.t option ;
      packet_length: Integer.t option ;
      session_number: Integer.t option ;
      virtual_network_id: Integer.t option ;
      description: String.t option ;
      remove_fields: TrafficMirrorSessionFieldList.t ;
      dry_run: Boolean.t option }
    let make ~traffic_mirror_session_id  ?traffic_mirror_target_id 
      ?traffic_mirror_filter_id  ?packet_length  ?session_number 
      ?virtual_network_id  ?description  ?(remove_fields= [])  ?dry_run  () =
      {
        traffic_mirror_session_id;
        traffic_mirror_target_id;
        traffic_mirror_filter_id;
        packet_length;
        session_number;
        virtual_network_id;
        description;
        remove_fields;
        dry_run
      }
    let parse xml =
      Some
        {
          traffic_mirror_session_id =
            (Xml.required "TrafficMirrorSessionId"
               (Util.option_bind (Xml.member "TrafficMirrorSessionId" xml)
                  String.parse));
          traffic_mirror_target_id =
            (Util.option_bind (Xml.member "TrafficMirrorTargetId" xml)
               String.parse);
          traffic_mirror_filter_id =
            (Util.option_bind (Xml.member "TrafficMirrorFilterId" xml)
               String.parse);
          packet_length =
            (Util.option_bind (Xml.member "PacketLength" xml) Integer.parse);
          session_number =
            (Util.option_bind (Xml.member "SessionNumber" xml) Integer.parse);
          virtual_network_id =
            (Util.option_bind (Xml.member "VirtualNetworkId" xml)
               Integer.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          remove_fields =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveField" xml)
                  TrafficMirrorSessionFieldList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("RemoveField",
                  (TrafficMirrorSessionFieldList.to_query v.remove_fields)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.virtual_network_id
             (fun f -> Query.Pair ("VirtualNetworkId", (Integer.to_query f)));
           Util.option_map v.session_number
             (fun f -> Query.Pair ("SessionNumber", (Integer.to_query f)));
           Util.option_map v.packet_length
             (fun f -> Query.Pair ("PacketLength", (Integer.to_query f)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f ->
                Query.Pair ("TrafficMirrorFilterId", (String.to_query f)));
           Util.option_map v.traffic_mirror_target_id
             (fun f ->
                Query.Pair ("TrafficMirrorTargetId", (String.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorSessionId",
                  (String.to_query v.traffic_mirror_session_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Some
                      (Ezxmlm.make_tag "TrafficMirrorSessionId"
                         ([], (String.to_xml v.traffic_mirror_session_id)))])
                  @
                  [Util.option_map v.traffic_mirror_target_id
                     (fun f ->
                        Ezxmlm.make_tag "TrafficMirrorTargetId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.traffic_mirror_filter_id
                    (fun f ->
                       Ezxmlm.make_tag "TrafficMirrorFilterId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.packet_length
                   (fun f ->
                      Ezxmlm.make_tag "PacketLength" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.session_number
                  (fun f ->
                     Ezxmlm.make_tag "SessionNumber" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.virtual_network_id
                 (fun f ->
                    Ezxmlm.make_tag "VirtualNetworkId"
                      ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "RemoveField"
                       ([], (TrafficMirrorSessionFieldList.to_xml [x]))))
               v.remove_fields))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("remove_fields",
               (TrafficMirrorSessionFieldList.to_json v.remove_fields));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.virtual_network_id
             (fun f -> ("virtual_network_id", (Integer.to_json f)));
           Util.option_map v.session_number
             (fun f -> ("session_number", (Integer.to_json f)));
           Util.option_map v.packet_length
             (fun f -> ("packet_length", (Integer.to_json f)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f -> ("traffic_mirror_filter_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_target_id
             (fun f -> ("traffic_mirror_target_id", (String.to_json f)));
           Some
             ("traffic_mirror_session_id",
               (String.to_json v.traffic_mirror_session_id))])
    let of_json j =
      {
        traffic_mirror_session_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_session_id")));
        traffic_mirror_target_id =
          (Util.option_map (Json.lookup j "traffic_mirror_target_id")
             String.of_json);
        traffic_mirror_filter_id =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_id")
             String.of_json);
        packet_length =
          (Util.option_map (Json.lookup j "packet_length") Integer.of_json);
        session_number =
          (Util.option_map (Json.lookup j "session_number") Integer.of_json);
        virtual_network_id =
          (Util.option_map (Json.lookup j "virtual_network_id")
             Integer.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        remove_fields =
          (TrafficMirrorSessionFieldList.of_json
             (Util.of_option_exn (Json.lookup j "remove_fields")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateTransitGatewayPeeringAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_id: String.t ;
      peer_transit_gateway_id: String.t ;
      peer_account_id: String.t ;
      peer_region: String.t ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_id  ~peer_transit_gateway_id  ~peer_account_id 
      ~peer_region  ?(tag_specifications= [])  ?dry_run  () =
      {
        transit_gateway_id;
        peer_transit_gateway_id;
        peer_account_id;
        peer_region;
        tag_specifications;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Xml.required "TransitGatewayId"
               (Util.option_bind (Xml.member "TransitGatewayId" xml)
                  String.parse));
          peer_transit_gateway_id =
            (Xml.required "PeerTransitGatewayId"
               (Util.option_bind (Xml.member "PeerTransitGatewayId" xml)
                  String.parse));
          peer_account_id =
            (Xml.required "PeerAccountId"
               (Util.option_bind (Xml.member "PeerAccountId" xml)
                  String.parse));
          peer_region =
            (Xml.required "PeerRegion"
               (Util.option_bind (Xml.member "PeerRegion" xml) String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("PeerRegion", (String.to_query v.peer_region)));
           Some
             (Query.Pair
                ("PeerAccountId", (String.to_query v.peer_account_id)));
           Some
             (Query.Pair
                ("PeerTransitGatewayId",
                  (String.to_query v.peer_transit_gateway_id)));
           Some
             (Query.Pair
                ("TransitGatewayId", (String.to_query v.transit_gateway_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Some
                   (Ezxmlm.make_tag "TransitGatewayId"
                      ([], (String.to_xml v.transit_gateway_id)))])
               @
               [Some
                  (Ezxmlm.make_tag "PeerTransitGatewayId"
                     ([], (String.to_xml v.peer_transit_gateway_id)))])
              @
              [Some
                 (Ezxmlm.make_tag "PeerAccountId"
                    ([], (String.to_xml v.peer_account_id)))])
             @
             [Some
                (Ezxmlm.make_tag "PeerRegion"
                   ([], (String.to_xml v.peer_region)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "TagSpecification"
                       ([], (TagSpecificationList.to_xml [x]))))
               v.tag_specifications))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("peer_region", (String.to_json v.peer_region));
           Some ("peer_account_id", (String.to_json v.peer_account_id));
           Some
             ("peer_transit_gateway_id",
               (String.to_json v.peer_transit_gateway_id));
           Some ("transit_gateway_id", (String.to_json v.transit_gateway_id))])
    let of_json j =
      {
        transit_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "transit_gateway_id")));
        peer_transit_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "peer_transit_gateway_id")));
        peer_account_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "peer_account_id")));
        peer_region =
          (String.of_json (Util.of_option_exn (Json.lookup j "peer_region")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyInstanceCreditSpecificationResult =
  struct
    type t =
      {
      successful_instance_credit_specifications:
        SuccessfulInstanceCreditSpecificationSet.t ;
      unsuccessful_instance_credit_specifications:
        UnsuccessfulInstanceCreditSpecificationSet.t }
    let make ?(successful_instance_credit_specifications= []) 
      ?(unsuccessful_instance_credit_specifications= [])  () =
      {
        successful_instance_credit_specifications;
        unsuccessful_instance_credit_specifications
      }
    let parse xml =
      Some
        {
          successful_instance_credit_specifications =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "successfulInstanceCreditSpecificationSet" xml)
                  SuccessfulInstanceCreditSpecificationSet.parse));
          unsuccessful_instance_credit_specifications =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "unsuccessfulInstanceCreditSpecificationSet"
                     xml) UnsuccessfulInstanceCreditSpecificationSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnsuccessfulInstanceCreditSpecificationSet",
                   (UnsuccessfulInstanceCreditSpecificationSet.to_query
                      v.unsuccessful_instance_credit_specifications)));
           Some
             (Query.Pair
                ("SuccessfulInstanceCreditSpecificationSet",
                  (SuccessfulInstanceCreditSpecificationSet.to_query
                     v.successful_instance_credit_specifications)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag
                       "successfulInstanceCreditSpecificationSet"
                       ([],
                         (SuccessfulInstanceCreditSpecificationSet.to_xml [x]))))
               v.successful_instance_credit_specifications))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag
                      "unsuccessfulInstanceCreditSpecificationSet"
                      ([],
                        (UnsuccessfulInstanceCreditSpecificationSet.to_xml
                           [x]))))
              v.unsuccessful_instance_credit_specifications))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful_instance_credit_specifications",
                (UnsuccessfulInstanceCreditSpecificationSet.to_json
                   v.unsuccessful_instance_credit_specifications));
           Some
             ("successful_instance_credit_specifications",
               (SuccessfulInstanceCreditSpecificationSet.to_json
                  v.successful_instance_credit_specifications))])
    let of_json j =
      {
        successful_instance_credit_specifications =
          (SuccessfulInstanceCreditSpecificationSet.of_json
             (Util.of_option_exn
                (Json.lookup j "successful_instance_credit_specifications")));
        unsuccessful_instance_credit_specifications =
          (UnsuccessfulInstanceCreditSpecificationSet.of_json
             (Util.of_option_exn
                (Json.lookup j "unsuccessful_instance_credit_specifications")))
      }
  end
module DescribeReservedInstancesOfferingsResult =
  struct
    type t =
      {
      reserved_instances_offerings: ReservedInstancesOfferingList.t ;
      next_token: String.t option }
    let make ?(reserved_instances_offerings= [])  ?next_token  () =
      { reserved_instances_offerings; next_token }
    let parse xml =
      Some
        {
          reserved_instances_offerings =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesOfferingsSet" xml)
                  ReservedInstancesOfferingList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesOfferingsSet",
                  (ReservedInstancesOfferingList.to_query
                     v.reserved_instances_offerings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "reservedInstancesOfferingsSet"
                       ([], (ReservedInstancesOfferingList.to_xml [x]))))
               v.reserved_instances_offerings))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("reserved_instances_offerings",
               (ReservedInstancesOfferingList.to_json
                  v.reserved_instances_offerings))])
    let of_json j =
      {
        reserved_instances_offerings =
          (ReservedInstancesOfferingList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_offerings")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module AssociateDhcpOptionsRequest =
  struct
    type t =
      {
      dhcp_options_id: String.t ;
      vpc_id: String.t ;
      dry_run: Boolean.t option }
    let make ~dhcp_options_id  ~vpc_id  ?dry_run  () =
      { dhcp_options_id; vpc_id; dry_run }
    let parse xml =
      Some
        {
          dhcp_options_id =
            (Xml.required "DhcpOptionsId"
               (Util.option_bind (Xml.member "DhcpOptionsId" xml)
                  String.parse));
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("DhcpOptionsId", (String.to_query v.dhcp_options_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "DhcpOptionsId"
                   ([], (String.to_xml v.dhcp_options_id)))])
            @ [Some (Ezxmlm.make_tag "VpcId" ([], (String.to_xml v.vpc_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("dhcp_options_id", (String.to_json v.dhcp_options_id))])
    let of_json j =
      {
        dhcp_options_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_options_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AuthorizeClientVpnIngressResult =
  struct
    type t = {
      status: ClientVpnAuthorizationRuleStatus.t option }
    let make ?status  () = { status }
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnAuthorizationRuleStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair
                   ("Status", (ClientVpnAuthorizationRuleStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status"
                   ([], (ClientVpnAuthorizationRuleStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 ("status", (ClientVpnAuthorizationRuleStatus.to_json f)))])
    let of_json j =
      {
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnAuthorizationRuleStatus.of_json)
      }
  end
module DeleteKeyPairRequest =
  struct
    type t = {
      key_name: String.t ;
      dry_run: Boolean.t option }
    let make ~key_name  ?dry_run  () = { key_name; dry_run }
    let parse xml =
      Some
        {
          key_name =
            (Xml.required "KeyName"
               (Util.option_bind (Xml.member "KeyName" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("KeyName", (String.to_query v.key_name)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "KeyName" ([], (String.to_xml v.key_name)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("key_name", (String.to_json v.key_name))])
    let of_json j =
      {
        key_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "key_name")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeScheduledInstanceAvailabilityResult =
  struct
    type t =
      {
      next_token: String.t option ;
      scheduled_instance_availability_set: ScheduledInstanceAvailabilitySet.t }
    let make ?next_token  ?(scheduled_instance_availability_set= [])  () =
      { next_token; scheduled_instance_availability_set }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          scheduled_instance_availability_set =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "scheduledInstanceAvailabilitySet" xml)
                  ScheduledInstanceAvailabilitySet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ScheduledInstanceAvailabilitySet",
                   (ScheduledInstanceAvailabilitySet.to_query
                      v.scheduled_instance_availability_set)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "scheduledInstanceAvailabilitySet"
                      ([], (ScheduledInstanceAvailabilitySet.to_xml [x]))))
              v.scheduled_instance_availability_set))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("scheduled_instance_availability_set",
                (ScheduledInstanceAvailabilitySet.to_json
                   v.scheduled_instance_availability_set));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        scheduled_instance_availability_set =
          (ScheduledInstanceAvailabilitySet.of_json
             (Util.of_option_exn
                (Json.lookup j "scheduled_instance_availability_set")))
      }
  end
module DescribeInstancesResult =
  struct
    type t = {
      reservations: ReservationList.t ;
      next_token: String.t option }
    let make ?(reservations= [])  ?next_token  () =
      { reservations; next_token }
    let parse xml =
      Some
        {
          reservations =
            (Util.of_option []
               (Util.option_bind (Xml.member "reservationSet" xml)
                  ReservationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservationSet", (ReservationList.to_query v.reservations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "reservationSet"
                       ([], (ReservationList.to_xml [x])))) v.reservations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("reservations", (ReservationList.to_json v.reservations))])
    let of_json j =
      {
        reservations =
          (ReservationList.of_json
             (Util.of_option_exn (Json.lookup j "reservations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteClientVpnRouteResult =
  struct
    type t = {
      status: ClientVpnRouteStatus.t option }
    let make ?status  () = { status }
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnRouteStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair ("Status", (ClientVpnRouteStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status"
                   ([], (ClientVpnRouteStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (ClientVpnRouteStatus.to_json f)))])
    let of_json j =
      {
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnRouteStatus.of_json)
      }
  end
module DeleteFleetsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      fleet_ids: FleetIdSet.t ;
      terminate_instances: Boolean.t }
    let make ?dry_run  ~fleet_ids  ~terminate_instances  () =
      { dry_run; fleet_ids; terminate_instances }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          fleet_ids =
            (Xml.required "FleetId"
               (Util.option_bind (Xml.member "FleetId" xml) FleetIdSet.parse));
          terminate_instances =
            (Xml.required "TerminateInstances"
               (Util.option_bind (Xml.member "TerminateInstances" xml)
                  Boolean.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TerminateInstances",
                   (Boolean.to_query v.terminate_instances)));
           Some (Query.Pair ("FleetId", (FleetIdSet.to_query v.fleet_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "FleetId" ([], (FleetIdSet.to_xml [x]))))
               v.fleet_ids))
           @
           [Some
              (Ezxmlm.make_tag "TerminateInstances"
                 ([], (Boolean.to_xml v.terminate_instances)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("terminate_instances",
                (Boolean.to_json v.terminate_instances));
           Some ("fleet_ids", (FleetIdSet.to_json v.fleet_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        fleet_ids =
          (FleetIdSet.of_json
             (Util.of_option_exn (Json.lookup j "fleet_ids")));
        terminate_instances =
          (Boolean.of_json
             (Util.of_option_exn (Json.lookup j "terminate_instances")))
      }
  end
module DescribeLocalGatewayVirtualInterfaceGroupsRequest =
  struct
    type t =
      {
      local_gateway_virtual_interface_group_ids:
        LocalGatewayVirtualInterfaceGroupIdSet.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(local_gateway_virtual_interface_group_ids= [])  ?(filters= [])
       ?max_results  ?next_token  ?dry_run  () =
      {
        local_gateway_virtual_interface_group_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          local_gateway_virtual_interface_group_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "LocalGatewayVirtualInterfaceGroupId" xml)
                  LocalGatewayVirtualInterfaceGroupIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("LocalGatewayVirtualInterfaceGroupId",
                  (LocalGatewayVirtualInterfaceGroupIdSet.to_query
                     v.local_gateway_virtual_interface_group_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "LocalGatewayVirtualInterfaceGroupId"
                          ([],
                            (LocalGatewayVirtualInterfaceGroupIdSet.to_xml
                               [x]))))
                  v.local_gateway_virtual_interface_group_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("local_gateway_virtual_interface_group_ids",
               (LocalGatewayVirtualInterfaceGroupIdSet.to_json
                  v.local_gateway_virtual_interface_group_ids))])
    let of_json j =
      {
        local_gateway_virtual_interface_group_ids =
          (LocalGatewayVirtualInterfaceGroupIdSet.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_virtual_interface_group_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeIdentityIdFormatResult =
  struct
    type t = {
      statuses: IdFormatList.t }
    let make ?(statuses= [])  () = { statuses }
    let parse xml =
      Some
        {
          statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "statusSet" xml)
                  IdFormatList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("StatusSet", (IdFormatList.to_query v.statuses)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "statusSet"
                      ([], (IdFormatList.to_xml [x])))) v.statuses))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("statuses", (IdFormatList.to_json v.statuses))])
    let of_json j =
      {
        statuses =
          (IdFormatList.of_json
             (Util.of_option_exn (Json.lookup j "statuses")))
      }
  end
module CreateVpcResult =
  struct
    type t = {
      vpc: Vpc.t option }
    let make ?vpc  () = { vpc }
    let parse xml =
      Some { vpc = (Util.option_bind (Xml.member "vpc" xml) Vpc.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc
              (fun f -> Query.Pair ("Vpc", (Vpc.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.vpc
              (fun f -> Ezxmlm.make_tag "vpc" ([], (Vpc.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc (fun f -> ("vpc", (Vpc.to_json f)))])
    let of_json j =
      { vpc = (Util.option_map (Json.lookup j "vpc") Vpc.of_json) }
  end
module DescribeVolumesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      volume_ids: VolumeIdStringList.t ;
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(filters= [])  ?(volume_ids= [])  ?dry_run  ?max_results 
      ?next_token  () =
      { filters; volume_ids; dry_run; max_results; next_token }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          volume_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VolumeId" xml)
                  VolumeIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("VolumeId", (VolumeIdStringList.to_query v.volume_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filter"
                          ([], (FilterList.to_xml [x])))) v.filters))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "VolumeId"
                         ([], (VolumeIdStringList.to_xml [x])))) v.volume_ids))
             @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "maxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("volume_ids", (VolumeIdStringList.to_json v.volume_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        volume_ids =
          (VolumeIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "volume_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module MonitorInstancesRequest =
  struct
    type t =
      {
      instance_ids: InstanceIdStringList.t ;
      dry_run: Boolean.t option }
    let make ~instance_ids  ?dry_run  () = { instance_ids; dry_run }
    let parse xml =
      Some
        {
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "InstanceId"
                       ([], (InstanceIdStringList.to_xml [x]))))
               v.instance_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids))])
    let of_json j =
      {
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module PurchaseHostReservationResult =
  struct
    type t =
      {
      client_token: String.t option ;
      currency_code: CurrencyCodeValues.t option ;
      purchase: PurchaseSet.t ;
      total_hourly_price: String.t option ;
      total_upfront_price: String.t option }
    let make ?client_token  ?currency_code  ?(purchase= []) 
      ?total_hourly_price  ?total_upfront_price  () =
      {
        client_token;
        currency_code;
        purchase;
        total_hourly_price;
        total_upfront_price
      }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          purchase =
            (Util.of_option []
               (Util.option_bind (Xml.member "purchase" xml)
                  PurchaseSet.parse));
          total_hourly_price =
            (Util.option_bind (Xml.member "totalHourlyPrice" xml)
               String.parse);
          total_upfront_price =
            (Util.option_bind (Xml.member "totalUpfrontPrice" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_upfront_price
              (fun f -> Query.Pair ("TotalUpfrontPrice", (String.to_query f)));
           Util.option_map v.total_hourly_price
             (fun f -> Query.Pair ("TotalHourlyPrice", (String.to_query f)));
           Some (Query.Pair ("Purchase", (PurchaseSet.to_query v.purchase)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.client_token
                  (fun f ->
                     Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
              @
              [Util.option_map v.currency_code
                 (fun f ->
                    Ezxmlm.make_tag "currencyCode"
                      ([], (CurrencyCodeValues.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "purchase"
                        ([], (PurchaseSet.to_xml [x])))) v.purchase))
            @
            [Util.option_map v.total_hourly_price
               (fun f ->
                  Ezxmlm.make_tag "totalHourlyPrice" ([], (String.to_xml f)))])
           @
           [Util.option_map v.total_upfront_price
              (fun f ->
                 Ezxmlm.make_tag "totalUpfrontPrice" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_upfront_price
              (fun f -> ("total_upfront_price", (String.to_json f)));
           Util.option_map v.total_hourly_price
             (fun f -> ("total_hourly_price", (String.to_json f)));
           Some ("purchase", (PurchaseSet.to_json v.purchase));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        purchase =
          (PurchaseSet.of_json
             (Util.of_option_exn (Json.lookup j "purchase")));
        total_hourly_price =
          (Util.option_map (Json.lookup j "total_hourly_price")
             String.of_json);
        total_upfront_price =
          (Util.option_map (Json.lookup j "total_upfront_price")
             String.of_json)
      }
  end
module CreateClientVpnRouteResult =
  struct
    type t = {
      status: ClientVpnRouteStatus.t option }
    let make ?status  () = { status }
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnRouteStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair ("Status", (ClientVpnRouteStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status"
                   ([], (ClientVpnRouteStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (ClientVpnRouteStatus.to_json f)))])
    let of_json j =
      {
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnRouteStatus.of_json)
      }
  end
module ModifyEbsDefaultKmsKeyIdRequest =
  struct
    type t = {
      kms_key_id: String.t ;
      dry_run: Boolean.t option }
    let make ~kms_key_id  ?dry_run  () = { kms_key_id; dry_run }
    let parse xml =
      Some
        {
          kms_key_id =
            (Xml.required "KmsKeyId"
               (Util.option_bind (Xml.member "KmsKeyId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("KmsKeyId", (String.to_query v.kms_key_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "KmsKeyId" ([], (String.to_xml v.kms_key_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("kms_key_id", (String.to_json v.kms_key_id))])
    let of_json j =
      {
        kms_key_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "kms_key_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeIdFormatRequest =
  struct
    type t = {
      resource: String.t option }
    let make ?resource  () = { resource }
    let parse xml =
      Some
        {
          resource =
            (Util.option_bind (Xml.member "Resource" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.resource
              (fun f -> Query.Pair ("Resource", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.resource
              (fun f -> Ezxmlm.make_tag "Resource" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.resource
              (fun f -> ("resource", (String.to_json f)))])
    let of_json j =
      {
        resource =
          (Util.option_map (Json.lookup j "resource") String.of_json)
      }
  end
module DescribePublicIpv4PoolsResult =
  struct
    type t =
      {
      public_ipv4_pools: PublicIpv4PoolSet.t ;
      next_token: String.t option }
    let make ?(public_ipv4_pools= [])  ?next_token  () =
      { public_ipv4_pools; next_token }
    let parse xml =
      Some
        {
          public_ipv4_pools =
            (Util.of_option []
               (Util.option_bind (Xml.member "publicIpv4PoolSet" xml)
                  PublicIpv4PoolSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("PublicIpv4PoolSet",
                  (PublicIpv4PoolSet.to_query v.public_ipv4_pools)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "publicIpv4PoolSet"
                       ([], (PublicIpv4PoolSet.to_xml [x]))))
               v.public_ipv4_pools))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("public_ipv4_pools",
               (PublicIpv4PoolSet.to_json v.public_ipv4_pools))])
    let of_json j =
      {
        public_ipv4_pools =
          (PublicIpv4PoolSet.of_json
             (Util.of_option_exn (Json.lookup j "public_ipv4_pools")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetLaunchTemplateDataRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      instance_id: String.t }
    let make ?dry_run  ~instance_id  () = { dry_run; instance_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "InstanceId"
                 ([], (String.to_xml v.instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")))
      }
  end
module DescribeLocalGatewayVirtualInterfacesRequest =
  struct
    type t =
      {
      local_gateway_virtual_interface_ids:
        LocalGatewayVirtualInterfaceIdSet.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(local_gateway_virtual_interface_ids= [])  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        local_gateway_virtual_interface_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          local_gateway_virtual_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "LocalGatewayVirtualInterfaceId" xml)
                  LocalGatewayVirtualInterfaceIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("LocalGatewayVirtualInterfaceId",
                  (LocalGatewayVirtualInterfaceIdSet.to_query
                     v.local_gateway_virtual_interface_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "LocalGatewayVirtualInterfaceId"
                          ([],
                            (LocalGatewayVirtualInterfaceIdSet.to_xml [x]))))
                  v.local_gateway_virtual_interface_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("local_gateway_virtual_interface_ids",
               (LocalGatewayVirtualInterfaceIdSet.to_json
                  v.local_gateway_virtual_interface_ids))])
    let of_json j =
      {
        local_gateway_virtual_interface_ids =
          (LocalGatewayVirtualInterfaceIdSet.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_virtual_interface_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeVolumeAttributeResult =
  struct
    type t =
      {
      auto_enable_i_o: AttributeBooleanValue.t option ;
      product_codes: ProductCodeList.t ;
      volume_id: String.t option }
    let make ?auto_enable_i_o  ?(product_codes= [])  ?volume_id  () =
      { auto_enable_i_o; product_codes; volume_id }
    let parse xml =
      Some
        {
          auto_enable_i_o =
            (Util.option_bind (Xml.member "autoEnableIO" xml)
               AttributeBooleanValue.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Util.option_map v.auto_enable_i_o
             (fun f ->
                Query.Pair
                  ("AutoEnableIO", (AttributeBooleanValue.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.auto_enable_i_o
                (fun f ->
                   Ezxmlm.make_tag "autoEnableIO"
                     ([], (AttributeBooleanValue.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "productCodes"
                       ([], (ProductCodeList.to_xml [x])))) v.product_codes))
           @
           [Util.option_map v.volume_id
              (fun f -> Ezxmlm.make_tag "volumeId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> ("volume_id", (String.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Util.option_map v.auto_enable_i_o
             (fun f -> ("auto_enable_i_o", (AttributeBooleanValue.to_json f)))])
    let of_json j =
      {
        auto_enable_i_o =
          (Util.option_map (Json.lookup j "auto_enable_i_o")
             AttributeBooleanValue.of_json);
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json)
      }
  end
module DescribeVpcsResult =
  struct
    type t = {
      vpcs: VpcList.t ;
      next_token: String.t option }
    let make ?(vpcs= [])  ?next_token  () = { vpcs; next_token }
    let parse xml =
      Some
        {
          vpcs =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcSet" xml) VpcList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("VpcSet", (VpcList.to_query v.vpcs)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "vpcSet" ([], (VpcList.to_xml [x]))))
               v.vpcs))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("vpcs", (VpcList.to_json v.vpcs))])
    let of_json j =
      {
        vpcs = (VpcList.of_json (Util.of_option_exn (Json.lookup j "vpcs")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeLocalGatewaysResult =
  struct
    type t =
      {
      local_gateways: LocalGatewaySet.t ;
      next_token: String.t option }
    let make ?(local_gateways= [])  ?next_token  () =
      { local_gateways; next_token }
    let parse xml =
      Some
        {
          local_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "localGatewaySet" xml)
                  LocalGatewaySet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewaySet",
                  (LocalGatewaySet.to_query v.local_gateways)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "localGatewaySet"
                       ([], (LocalGatewaySet.to_xml [x])))) v.local_gateways))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateways", (LocalGatewaySet.to_json v.local_gateways))])
    let of_json j =
      {
        local_gateways =
          (LocalGatewaySet.of_json
             (Util.of_option_exn (Json.lookup j "local_gateways")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribePrefixListsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      prefix_list_ids: ValueStringList.t }
    let make ?dry_run  ?(filters= [])  ?max_results  ?next_token 
      ?(prefix_list_ids= [])  () =
      { dry_run; filters; max_results; next_token; prefix_list_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          prefix_list_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "PrefixListId" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PrefixListId",
                   (ValueStringList.to_query v.prefix_list_ids)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "PrefixListId"
                      ([], (ValueStringList.to_xml [x])))) v.prefix_list_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("prefix_list_ids",
                (ValueStringList.to_json v.prefix_list_ids));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        prefix_list_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_ids")))
      }
  end
module ModifyLaunchTemplateResult =
  struct
    type t = {
      launch_template: LaunchTemplate.t option }
    let make ?launch_template  () = { launch_template }
    let parse xml =
      Some
        {
          launch_template =
            (Util.option_bind (Xml.member "launchTemplate" xml)
               LaunchTemplate.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template
              (fun f ->
                 Query.Pair ("LaunchTemplate", (LaunchTemplate.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.launch_template
              (fun f ->
                 Ezxmlm.make_tag "launchTemplate"
                   ([], (LaunchTemplate.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template
              (fun f -> ("launch_template", (LaunchTemplate.to_json f)))])
    let of_json j =
      {
        launch_template =
          (Util.option_map (Json.lookup j "launch_template")
             LaunchTemplate.of_json)
      }
  end
module DescribeSubnetsResult =
  struct
    type t = {
      subnets: SubnetList.t ;
      next_token: String.t option }
    let make ?(subnets= [])  ?next_token  () = { subnets; next_token }
    let parse xml =
      Some
        {
          subnets =
            (Util.of_option []
               (Util.option_bind (Xml.member "subnetSet" xml)
                  SubnetList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("SubnetSet", (SubnetList.to_query v.subnets)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "subnetSet"
                       ([], (SubnetList.to_xml [x])))) v.subnets))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("subnets", (SubnetList.to_json v.subnets))])
    let of_json j =
      {
        subnets =
          (SubnetList.of_json (Util.of_option_exn (Json.lookup j "subnets")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetTransitGatewayRouteTableAssociationsRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ?(filters= [])  ?max_results 
      ?next_token  ?dry_run  () =
      {
        transit_gateway_route_table_id;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "TransitGatewayRouteTableId"
                     ([], (String.to_xml v.transit_gateway_route_table_id)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CancelBundleTaskResult =
  struct
    type t = {
      bundle_task: BundleTask.t option }
    let make ?bundle_task  () = { bundle_task }
    let parse xml =
      Some
        {
          bundle_task =
            (Util.option_bind (Xml.member "bundleInstanceTask" xml)
               BundleTask.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.bundle_task
              (fun f ->
                 Query.Pair ("BundleInstanceTask", (BundleTask.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.bundle_task
              (fun f ->
                 Ezxmlm.make_tag "bundleInstanceTask"
                   ([], (BundleTask.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.bundle_task
              (fun f -> ("bundle_task", (BundleTask.to_json f)))])
    let of_json j =
      {
        bundle_task =
          (Util.option_map (Json.lookup j "bundle_task") BundleTask.of_json)
      }
  end
module ModifySpotFleetRequestRequest =
  struct
    type t =
      {
      excess_capacity_termination_policy:
        ExcessCapacityTerminationPolicy.t option ;
      spot_fleet_request_id: String.t ;
      target_capacity: Integer.t option ;
      on_demand_target_capacity: Integer.t option }
    let make ?excess_capacity_termination_policy  ~spot_fleet_request_id 
      ?target_capacity  ?on_demand_target_capacity  () =
      {
        excess_capacity_termination_policy;
        spot_fleet_request_id;
        target_capacity;
        on_demand_target_capacity
      }
    let parse xml =
      Some
        {
          excess_capacity_termination_policy =
            (Util.option_bind
               (Xml.member "excessCapacityTerminationPolicy" xml)
               ExcessCapacityTerminationPolicy.parse);
          spot_fleet_request_id =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  String.parse));
          target_capacity =
            (Util.option_bind (Xml.member "targetCapacity" xml) Integer.parse);
          on_demand_target_capacity =
            (Util.option_bind (Xml.member "OnDemandTargetCapacity" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.on_demand_target_capacity
              (fun f ->
                 Query.Pair ("OnDemandTargetCapacity", (Integer.to_query f)));
           Util.option_map v.target_capacity
             (fun f -> Query.Pair ("TargetCapacity", (Integer.to_query f)));
           Some
             (Query.Pair
                ("SpotFleetRequestId",
                  (String.to_query v.spot_fleet_request_id)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                Query.Pair
                  ("ExcessCapacityTerminationPolicy",
                    (ExcessCapacityTerminationPolicy.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.excess_capacity_termination_policy
                 (fun f ->
                    Ezxmlm.make_tag "excessCapacityTerminationPolicy"
                      ([], (ExcessCapacityTerminationPolicy.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "spotFleetRequestId"
                   ([], (String.to_xml v.spot_fleet_request_id)))])
            @
            [Util.option_map v.target_capacity
               (fun f ->
                  Ezxmlm.make_tag "targetCapacity" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.on_demand_target_capacity
              (fun f ->
                 Ezxmlm.make_tag "OnDemandTargetCapacity"
                   ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.on_demand_target_capacity
              (fun f -> ("on_demand_target_capacity", (Integer.to_json f)));
           Util.option_map v.target_capacity
             (fun f -> ("target_capacity", (Integer.to_json f)));
           Some
             ("spot_fleet_request_id",
               (String.to_json v.spot_fleet_request_id));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                ("excess_capacity_termination_policy",
                  (ExcessCapacityTerminationPolicy.to_json f)))])
    let of_json j =
      {
        excess_capacity_termination_policy =
          (Util.option_map
             (Json.lookup j "excess_capacity_termination_policy")
             ExcessCapacityTerminationPolicy.of_json);
        spot_fleet_request_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_id")));
        target_capacity =
          (Util.option_map (Json.lookup j "target_capacity") Integer.of_json);
        on_demand_target_capacity =
          (Util.option_map (Json.lookup j "on_demand_target_capacity")
             Integer.of_json)
      }
  end
module AssignIpv6AddressesResult =
  struct
    type t =
      {
      assigned_ipv6_addresses: Ipv6AddressList.t ;
      network_interface_id: String.t option }
    let make ?(assigned_ipv6_addresses= [])  ?network_interface_id  () =
      { assigned_ipv6_addresses; network_interface_id }
    let parse xml =
      Some
        {
          assigned_ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "assignedIpv6Addresses" xml)
                  Ipv6AddressList.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_interface_id
              (fun f ->
                 Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("AssignedIpv6Addresses",
                  (Ipv6AddressList.to_query v.assigned_ipv6_addresses)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "assignedIpv6Addresses"
                       ([], (Ipv6AddressList.to_xml [x]))))
               v.assigned_ipv6_addresses))
           @
           [Util.option_map v.network_interface_id
              (fun f ->
                 Ezxmlm.make_tag "networkInterfaceId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_interface_id
              (fun f -> ("network_interface_id", (String.to_json f)));
           Some
             ("assigned_ipv6_addresses",
               (Ipv6AddressList.to_json v.assigned_ipv6_addresses))])
    let of_json j =
      {
        assigned_ipv6_addresses =
          (Ipv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "assigned_ipv6_addresses")));
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json)
      }
  end
module DetachInternetGatewayRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      internet_gateway_id: String.t ;
      vpc_id: String.t }
    let make ?dry_run  ~internet_gateway_id  ~vpc_id  () =
      { dry_run; internet_gateway_id; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          internet_gateway_id =
            (Xml.required "internetGatewayId"
               (Util.option_bind (Xml.member "internetGatewayId" xml)
                  String.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("InternetGatewayId",
                  (String.to_query v.internet_gateway_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "internetGatewayId"
                  ([], (String.to_xml v.internet_gateway_id)))])
           @ [Some (Ezxmlm.make_tag "vpcId" ([], (String.to_xml v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some
             ("internet_gateway_id", (String.to_json v.internet_gateway_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        internet_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateway_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DescribeElasticGpusResult =
  struct
    type t =
      {
      elastic_gpu_set: ElasticGpuSet.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(elastic_gpu_set= [])  ?max_results  ?next_token  () =
      { elastic_gpu_set; max_results; next_token }
    let parse xml =
      Some
        {
          elastic_gpu_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "elasticGpuSet" xml)
                  ElasticGpuSet.parse));
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("ElasticGpuSet", (ElasticGpuSet.to_query v.elastic_gpu_set)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "elasticGpuSet"
                        ([], (ElasticGpuSet.to_xml [x])))) v.elastic_gpu_set))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "maxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("elastic_gpu_set", (ElasticGpuSet.to_json v.elastic_gpu_set))])
    let of_json j =
      {
        elastic_gpu_set =
          (ElasticGpuSet.of_json
             (Util.of_option_exn (Json.lookup j "elastic_gpu_set")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DisassociateClientVpnTargetNetworkResult =
  struct
    type t =
      {
      association_id: String.t option ;
      status: AssociationStatus.t option }
    let make ?association_id  ?status  () = { association_id; status }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AssociationStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (AssociationStatus.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.association_id
               (fun f ->
                  Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status" ([], (AssociationStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (AssociationStatus.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") AssociationStatus.of_json)
      }
  end
module DescribeVpcClassicLinkResult =
  struct
    type t = {
      vpcs: VpcClassicLinkList.t }
    let make ?(vpcs= [])  () = { vpcs }
    let parse xml =
      Some
        {
          vpcs =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcSet" xml)
                  VpcClassicLinkList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("VpcSet", (VpcClassicLinkList.to_query v.vpcs)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "vpcSet"
                      ([], (VpcClassicLinkList.to_xml [x])))) v.vpcs))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpcs", (VpcClassicLinkList.to_json v.vpcs))])
    let of_json j =
      {
        vpcs =
          (VpcClassicLinkList.of_json
             (Util.of_option_exn (Json.lookup j "vpcs")))
      }
  end
module DescribeImportImageTasksResult =
  struct
    type t =
      {
      import_image_tasks: ImportImageTaskList.t ;
      next_token: String.t option }
    let make ?(import_image_tasks= [])  ?next_token  () =
      { import_image_tasks; next_token }
    let parse xml =
      Some
        {
          import_image_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "importImageTaskSet" xml)
                  ImportImageTaskList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ImportImageTaskSet",
                  (ImportImageTaskList.to_query v.import_image_tasks)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "importImageTaskSet"
                       ([], (ImportImageTaskList.to_xml [x]))))
               v.import_image_tasks))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("import_image_tasks",
               (ImportImageTaskList.to_json v.import_image_tasks))])
    let of_json j =
      {
        import_image_tasks =
          (ImportImageTaskList.of_json
             (Util.of_option_exn (Json.lookup j "import_image_tasks")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DisableEbsEncryptionByDefaultResult =
  struct
    type t = {
      ebs_encryption_by_default: Boolean.t option }
    let make ?ebs_encryption_by_default  () = { ebs_encryption_by_default }
    let parse xml =
      Some
        {
          ebs_encryption_by_default =
            (Util.option_bind (Xml.member "ebsEncryptionByDefault" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f ->
                 Query.Pair ("EbsEncryptionByDefault", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ebs_encryption_by_default
              (fun f ->
                 Ezxmlm.make_tag "ebsEncryptionByDefault"
                   ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f -> ("ebs_encryption_by_default", (Boolean.to_json f)))])
    let of_json j =
      {
        ebs_encryption_by_default =
          (Util.option_map (Json.lookup j "ebs_encryption_by_default")
             Boolean.of_json)
      }
  end
module ModifyIdFormatRequest =
  struct
    type t = {
      resource: String.t ;
      use_long_ids: Boolean.t }
    let make ~resource  ~use_long_ids  () = { resource; use_long_ids }
    let parse xml =
      Some
        {
          resource =
            (Xml.required "Resource"
               (Util.option_bind (Xml.member "Resource" xml) String.parse));
          use_long_ids =
            (Xml.required "UseLongIds"
               (Util.option_bind (Xml.member "UseLongIds" xml) Boolean.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("UseLongIds", (Boolean.to_query v.use_long_ids)));
           Some (Query.Pair ("Resource", (String.to_query v.resource)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "Resource" ([], (String.to_xml v.resource)))])
           @
           [Some
              (Ezxmlm.make_tag "UseLongIds"
                 ([], (Boolean.to_xml v.use_long_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("use_long_ids", (Boolean.to_json v.use_long_ids));
           Some ("resource", (String.to_json v.resource))])
    let of_json j =
      {
        resource =
          (String.of_json (Util.of_option_exn (Json.lookup j "resource")));
        use_long_ids =
          (Boolean.of_json
             (Util.of_option_exn (Json.lookup j "use_long_ids")))
      }
  end
module ProvisionByoipCidrResult =
  struct
    type t = {
      byoip_cidr: ByoipCidr.t option }
    let make ?byoip_cidr  () = { byoip_cidr }
    let parse xml =
      Some
        {
          byoip_cidr =
            (Util.option_bind (Xml.member "byoipCidr" xml) ByoipCidr.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> Query.Pair ("ByoipCidr", (ByoipCidr.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.byoip_cidr
              (fun f ->
                 Ezxmlm.make_tag "byoipCidr" ([], (ByoipCidr.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> ("byoip_cidr", (ByoipCidr.to_json f)))])
    let of_json j =
      {
        byoip_cidr =
          (Util.option_map (Json.lookup j "byoip_cidr") ByoipCidr.of_json)
      }
  end
module CreateFlowLogsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      client_token: String.t option ;
      deliver_logs_permission_arn: String.t option ;
      log_group_name: String.t option ;
      resource_ids: ValueStringList.t ;
      resource_type: FlowLogsResourceType.t ;
      traffic_type: TrafficType.t ;
      log_destination_type: LogDestinationType.t option ;
      log_destination: String.t option ;
      log_format: String.t option }
    let make ?dry_run  ?client_token  ?deliver_logs_permission_arn 
      ?log_group_name  ~resource_ids  ~resource_type  ~traffic_type 
      ?log_destination_type  ?log_destination  ?log_format  () =
      {
        dry_run;
        client_token;
        deliver_logs_permission_arn;
        log_group_name;
        resource_ids;
        resource_type;
        traffic_type;
        log_destination_type;
        log_destination;
        log_format
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          deliver_logs_permission_arn =
            (Util.option_bind (Xml.member "DeliverLogsPermissionArn" xml)
               String.parse);
          log_group_name =
            (Util.option_bind (Xml.member "LogGroupName" xml) String.parse);
          resource_ids =
            (Xml.required "ResourceId"
               (Util.option_bind (Xml.member "ResourceId" xml)
                  ValueStringList.parse));
          resource_type =
            (Xml.required "ResourceType"
               (Util.option_bind (Xml.member "ResourceType" xml)
                  FlowLogsResourceType.parse));
          traffic_type =
            (Xml.required "TrafficType"
               (Util.option_bind (Xml.member "TrafficType" xml)
                  TrafficType.parse));
          log_destination_type =
            (Util.option_bind (Xml.member "LogDestinationType" xml)
               LogDestinationType.parse);
          log_destination =
            (Util.option_bind (Xml.member "LogDestination" xml) String.parse);
          log_format =
            (Util.option_bind (Xml.member "LogFormat" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.log_format
              (fun f -> Query.Pair ("LogFormat", (String.to_query f)));
           Util.option_map v.log_destination
             (fun f -> Query.Pair ("LogDestination", (String.to_query f)));
           Util.option_map v.log_destination_type
             (fun f ->
                Query.Pair
                  ("LogDestinationType", (LogDestinationType.to_query f)));
           Some
             (Query.Pair
                ("TrafficType", (TrafficType.to_query v.traffic_type)));
           Some
             (Query.Pair
                ("ResourceType",
                  (FlowLogsResourceType.to_query v.resource_type)));
           Some
             (Query.Pair
                ("ResourceId", (ValueStringList.to_query v.resource_ids)));
           Util.option_map v.log_group_name
             (fun f -> Query.Pair ("LogGroupName", (String.to_query f)));
           Util.option_map v.deliver_logs_permission_arn
             (fun f ->
                Query.Pair ("DeliverLogsPermissionArn", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.dry_run
                       (fun f ->
                          Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
                   @
                   [Util.option_map v.client_token
                      (fun f ->
                         Ezxmlm.make_tag "ClientToken"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.deliver_logs_permission_arn
                     (fun f ->
                        Ezxmlm.make_tag "DeliverLogsPermissionArn"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.log_group_name
                    (fun f ->
                       Ezxmlm.make_tag "LogGroupName" ([], (String.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "ResourceId"
                           ([], (ValueStringList.to_xml [x]))))
                   v.resource_ids))
               @
               [Some
                  (Ezxmlm.make_tag "ResourceType"
                     ([], (FlowLogsResourceType.to_xml v.resource_type)))])
              @
              [Some
                 (Ezxmlm.make_tag "TrafficType"
                    ([], (TrafficType.to_xml v.traffic_type)))])
             @
             [Util.option_map v.log_destination_type
                (fun f ->
                   Ezxmlm.make_tag "LogDestinationType"
                     ([], (LogDestinationType.to_xml f)))])
            @
            [Util.option_map v.log_destination
               (fun f ->
                  Ezxmlm.make_tag "LogDestination" ([], (String.to_xml f)))])
           @
           [Util.option_map v.log_format
              (fun f -> Ezxmlm.make_tag "LogFormat" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.log_format
              (fun f -> ("log_format", (String.to_json f)));
           Util.option_map v.log_destination
             (fun f -> ("log_destination", (String.to_json f)));
           Util.option_map v.log_destination_type
             (fun f ->
                ("log_destination_type", (LogDestinationType.to_json f)));
           Some ("traffic_type", (TrafficType.to_json v.traffic_type));
           Some
             ("resource_type",
               (FlowLogsResourceType.to_json v.resource_type));
           Some ("resource_ids", (ValueStringList.to_json v.resource_ids));
           Util.option_map v.log_group_name
             (fun f -> ("log_group_name", (String.to_json f)));
           Util.option_map v.deliver_logs_permission_arn
             (fun f -> ("deliver_logs_permission_arn", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        deliver_logs_permission_arn =
          (Util.option_map (Json.lookup j "deliver_logs_permission_arn")
             String.of_json);
        log_group_name =
          (Util.option_map (Json.lookup j "log_group_name") String.of_json);
        resource_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "resource_ids")));
        resource_type =
          (FlowLogsResourceType.of_json
             (Util.of_option_exn (Json.lookup j "resource_type")));
        traffic_type =
          (TrafficType.of_json
             (Util.of_option_exn (Json.lookup j "traffic_type")));
        log_destination_type =
          (Util.option_map (Json.lookup j "log_destination_type")
             LogDestinationType.of_json);
        log_destination =
          (Util.option_map (Json.lookup j "log_destination") String.of_json);
        log_format =
          (Util.option_map (Json.lookup j "log_format") String.of_json)
      }
  end
module CreateEgressOnlyInternetGatewayResult =
  struct
    type t =
      {
      client_token: String.t option ;
      egress_only_internet_gateway: EgressOnlyInternetGateway.t option }
    let make ?client_token  ?egress_only_internet_gateway  () =
      { client_token; egress_only_internet_gateway }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          egress_only_internet_gateway =
            (Util.option_bind (Xml.member "egressOnlyInternetGateway" xml)
               EgressOnlyInternetGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.egress_only_internet_gateway
              (fun f ->
                 Query.Pair
                   ("EgressOnlyInternetGateway",
                     (EgressOnlyInternetGateway.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.client_token
               (fun f ->
                  Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.egress_only_internet_gateway
              (fun f ->
                 Ezxmlm.make_tag "egressOnlyInternetGateway"
                   ([], (EgressOnlyInternetGateway.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.egress_only_internet_gateway
              (fun f ->
                 ("egress_only_internet_gateway",
                   (EgressOnlyInternetGateway.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        egress_only_internet_gateway =
          (Util.option_map (Json.lookup j "egress_only_internet_gateway")
             EgressOnlyInternetGateway.of_json)
      }
  end
module ModifySpotFleetRequestResponse =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module AssociateIamInstanceProfileRequest =
  struct
    type t =
      {
      iam_instance_profile: IamInstanceProfileSpecification.t ;
      instance_id: String.t }
    let make ~iam_instance_profile  ~instance_id  () =
      { iam_instance_profile; instance_id }
    let parse xml =
      Some
        {
          iam_instance_profile =
            (Xml.required "IamInstanceProfile"
               (Util.option_bind (Xml.member "IamInstanceProfile" xml)
                  IamInstanceProfileSpecification.parse));
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Some
             (Query.Pair
                ("IamInstanceProfile",
                  (IamInstanceProfileSpecification.to_query
                     v.iam_instance_profile)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "IamInstanceProfile"
                  ([],
                    (IamInstanceProfileSpecification.to_xml
                       v.iam_instance_profile)))])
           @
           [Some
              (Ezxmlm.make_tag "InstanceId"
                 ([], (String.to_xml v.instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instance_id", (String.to_json v.instance_id));
           Some
             ("iam_instance_profile",
               (IamInstanceProfileSpecification.to_json
                  v.iam_instance_profile))])
    let of_json j =
      {
        iam_instance_profile =
          (IamInstanceProfileSpecification.of_json
             (Util.of_option_exn (Json.lookup j "iam_instance_profile")));
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")))
      }
  end
module DescribeVpcEndpointServiceConfigurationsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_ids: ValueStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(service_ids= [])  ?(filters= [])  ?max_results 
      ?next_token  () =
      { dry_run; service_ids; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ServiceId" xml)
                  ValueStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("ServiceId", (ValueStringList.to_query v.service_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "ServiceId"
                         ([], (ValueStringList.to_xml [x])))) v.service_ids))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("service_ids", (ValueStringList.to_json v.service_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "service_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyVpcEndpointConnectionNotificationRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      connection_notification_id: String.t ;
      connection_notification_arn: String.t option ;
      connection_events: ValueStringList.t }
    let make ?dry_run  ~connection_notification_id 
      ?connection_notification_arn  ?(connection_events= [])  () =
      {
        dry_run;
        connection_notification_id;
        connection_notification_arn;
        connection_events
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          connection_notification_id =
            (Xml.required "ConnectionNotificationId"
               (Util.option_bind (Xml.member "ConnectionNotificationId" xml)
                  String.parse));
          connection_notification_arn =
            (Util.option_bind (Xml.member "ConnectionNotificationArn" xml)
               String.parse);
          connection_events =
            (Util.of_option []
               (Util.option_bind (Xml.member "ConnectionEvents" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ConnectionEvents",
                   (ValueStringList.to_query v.connection_events)));
           Util.option_map v.connection_notification_arn
             (fun f ->
                Query.Pair ("ConnectionNotificationArn", (String.to_query f)));
           Some
             (Query.Pair
                ("ConnectionNotificationId",
                  (String.to_query v.connection_notification_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "ConnectionNotificationId"
                   ([], (String.to_xml v.connection_notification_id)))])
            @
            [Util.option_map v.connection_notification_arn
               (fun f ->
                  Ezxmlm.make_tag "ConnectionNotificationArn"
                    ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "ConnectionEvents"
                      ([], (ValueStringList.to_xml [x]))))
              v.connection_events))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("connection_events",
                (ValueStringList.to_json v.connection_events));
           Util.option_map v.connection_notification_arn
             (fun f -> ("connection_notification_arn", (String.to_json f)));
           Some
             ("connection_notification_id",
               (String.to_json v.connection_notification_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        connection_notification_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "connection_notification_id")));
        connection_notification_arn =
          (Util.option_map (Json.lookup j "connection_notification_arn")
             String.of_json);
        connection_events =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "connection_events")))
      }
  end
module ModifyVpcTenancyRequest =
  struct
    type t =
      {
      vpc_id: String.t ;
      instance_tenancy: VpcTenancy.t ;
      dry_run: Boolean.t option }
    let make ~vpc_id  ~instance_tenancy  ?dry_run  () =
      { vpc_id; instance_tenancy; dry_run }
    let parse xml =
      Some
        {
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          instance_tenancy =
            (Xml.required "InstanceTenancy"
               (Util.option_bind (Xml.member "InstanceTenancy" xml)
                  VpcTenancy.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceTenancy", (VpcTenancy.to_query v.instance_tenancy)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some (Ezxmlm.make_tag "VpcId" ([], (String.to_xml v.vpc_id)))])
            @
            [Some
               (Ezxmlm.make_tag "InstanceTenancy"
                  ([], (VpcTenancy.to_xml v.instance_tenancy)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("instance_tenancy", (VpcTenancy.to_json v.instance_tenancy));
           Some ("vpc_id", (String.to_json v.vpc_id))])
    let of_json j =
      {
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        instance_tenancy =
          (VpcTenancy.of_json
             (Util.of_option_exn (Json.lookup j "instance_tenancy")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeFpgaImagesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      fpga_image_ids: FpgaImageIdList.t ;
      owners: OwnerStringList.t ;
      filters: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?dry_run  ?(fpga_image_ids= [])  ?(owners= [])  ?(filters= []) 
      ?next_token  ?max_results  () =
      { dry_run; fpga_image_ids; owners; filters; next_token; max_results }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          fpga_image_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "FpgaImageId" xml)
                  FpgaImageIdList.parse));
          owners =
            (Util.of_option []
               (Util.option_bind (Xml.member "Owner" xml)
                  OwnerStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some (Query.Pair ("Owner", (OwnerStringList.to_query v.owners)));
           Some
             (Query.Pair
                ("FpgaImageId", (FpgaImageIdList.to_query v.fpga_image_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.dry_run
                   (fun f ->
                      Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "FpgaImageId"
                          ([], (FpgaImageIdList.to_xml [x]))))
                  v.fpga_image_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Owner"
                         ([], (OwnerStringList.to_xml [x])))) v.owners))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("owners", (OwnerStringList.to_json v.owners));
           Some
             ("fpga_image_ids", (FpgaImageIdList.to_json v.fpga_image_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        fpga_image_ids =
          (FpgaImageIdList.of_json
             (Util.of_option_exn (Json.lookup j "fpga_image_ids")));
        owners =
          (OwnerStringList.of_json
             (Util.of_option_exn (Json.lookup j "owners")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module ApplySecurityGroupsToClientVpnTargetNetworkRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      vpc_id: String.t ;
      security_group_ids: ClientVpnSecurityGroupIdSet.t ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ~vpc_id  ~security_group_ids  ?dry_run 
      () = { client_vpn_endpoint_id; vpc_id; security_group_ids; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          security_group_ids =
            (Xml.required "SecurityGroupId"
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  ClientVpnSecurityGroupIdSet.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (ClientVpnSecurityGroupIdSet.to_query v.security_group_ids)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "ClientVpnEndpointId"
                    ([], (String.to_xml v.client_vpn_endpoint_id)))])
             @
             [Some (Ezxmlm.make_tag "VpcId" ([], (String.to_xml v.vpc_id)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "SecurityGroupId"
                       ([], (ClientVpnSecurityGroupIdSet.to_xml [x]))))
               v.security_group_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("security_group_ids",
               (ClientVpnSecurityGroupIdSet.to_json v.security_group_ids));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        security_group_ids =
          (ClientVpnSecurityGroupIdSet.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CopyFpgaImageResult =
  struct
    type t = {
      fpga_image_id: String.t option }
    let make ?fpga_image_id  () = { fpga_image_id }
    let parse xml =
      Some
        {
          fpga_image_id =
            (Util.option_bind (Xml.member "fpgaImageId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_id
              (fun f -> Query.Pair ("FpgaImageId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.fpga_image_id
              (fun f -> Ezxmlm.make_tag "fpgaImageId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_id
              (fun f -> ("fpga_image_id", (String.to_json f)))])
    let of_json j =
      {
        fpga_image_id =
          (Util.option_map (Json.lookup j "fpga_image_id") String.of_json)
      }
  end
module AcceptReservedInstancesExchangeQuoteResult =
  struct
    type t = {
      exchange_id: String.t option }
    let make ?exchange_id  () = { exchange_id }
    let parse xml =
      Some
        {
          exchange_id =
            (Util.option_bind (Xml.member "exchangeId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.exchange_id
              (fun f -> Query.Pair ("ExchangeId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.exchange_id
              (fun f -> Ezxmlm.make_tag "exchangeId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.exchange_id
              (fun f -> ("exchange_id", (String.to_json f)))])
    let of_json j =
      {
        exchange_id =
          (Util.option_map (Json.lookup j "exchange_id") String.of_json)
      }
  end
module DescribeDhcpOptionsRequest =
  struct
    type t =
      {
      dhcp_options_ids: DhcpOptionsIdStringList.t ;
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(dhcp_options_ids= [])  ?(filters= [])  ?dry_run  ?next_token 
      ?max_results  () =
      { dhcp_options_ids; filters; dry_run; next_token; max_results }
    let parse xml =
      Some
        {
          dhcp_options_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "DhcpOptionsId" xml)
                  DhcpOptionsIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("DhcpOptionsId",
                  (DhcpOptionsIdStringList.to_query v.dhcp_options_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "DhcpOptionsId"
                          ([], (DhcpOptionsIdStringList.to_xml [x]))))
                  v.dhcp_options_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("dhcp_options_ids",
               (DhcpOptionsIdStringList.to_json v.dhcp_options_ids))])
    let of_json j =
      {
        dhcp_options_ids =
          (DhcpOptionsIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_options_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module ModifyDefaultCreditSpecificationRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_family: UnlimitedSupportedInstanceFamily.t ;
      cpu_credits: String.t }
    let make ?dry_run  ~instance_family  ~cpu_credits  () =
      { dry_run; instance_family; cpu_credits }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          instance_family =
            (Xml.required "InstanceFamily"
               (Util.option_bind (Xml.member "InstanceFamily" xml)
                  UnlimitedSupportedInstanceFamily.parse));
          cpu_credits =
            (Xml.required "CpuCredits"
               (Util.option_bind (Xml.member "CpuCredits" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("CpuCredits", (String.to_query v.cpu_credits)));
           Some
             (Query.Pair
                ("InstanceFamily",
                  (UnlimitedSupportedInstanceFamily.to_query
                     v.instance_family)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "InstanceFamily"
                  ([],
                    (UnlimitedSupportedInstanceFamily.to_xml
                       v.instance_family)))])
           @
           [Some
              (Ezxmlm.make_tag "CpuCredits"
                 ([], (String.to_xml v.cpu_credits)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("cpu_credits", (String.to_json v.cpu_credits));
           Some
             ("instance_family",
               (UnlimitedSupportedInstanceFamily.to_json v.instance_family));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_family =
          (UnlimitedSupportedInstanceFamily.of_json
             (Util.of_option_exn (Json.lookup j "instance_family")));
        cpu_credits =
          (String.of_json (Util.of_option_exn (Json.lookup j "cpu_credits")))
      }
  end
module AssociateVpcCidrBlockRequest =
  struct
    type t =
      {
      amazon_provided_ipv6_cidr_block: Boolean.t option ;
      cidr_block: String.t option ;
      vpc_id: String.t ;
      ipv6_cidr_block_network_border_group: String.t option }
    let make ?amazon_provided_ipv6_cidr_block  ?cidr_block  ~vpc_id 
      ?ipv6_cidr_block_network_border_group  () =
      {
        amazon_provided_ipv6_cidr_block;
        cidr_block;
        vpc_id;
        ipv6_cidr_block_network_border_group
      }
    let parse xml =
      Some
        {
          amazon_provided_ipv6_cidr_block =
            (Util.option_bind (Xml.member "amazonProvidedIpv6CidrBlock" xml)
               Boolean.parse);
          cidr_block =
            (Util.option_bind (Xml.member "CidrBlock" xml) String.parse);
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse));
          ipv6_cidr_block_network_border_group =
            (Util.option_bind
               (Xml.member "Ipv6CidrBlockNetworkBorderGroup" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block_network_border_group
              (fun f ->
                 Query.Pair
                   ("Ipv6CidrBlockNetworkBorderGroup", (String.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)));
           Util.option_map v.amazon_provided_ipv6_cidr_block
             (fun f ->
                Query.Pair
                  ("AmazonProvidedIpv6CidrBlock", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.amazon_provided_ipv6_cidr_block
                 (fun f ->
                    Ezxmlm.make_tag "amazonProvidedIpv6CidrBlock"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.cidr_block
                (fun f -> Ezxmlm.make_tag "CidrBlock" ([], (String.to_xml f)))])
            @ [Some (Ezxmlm.make_tag "vpcId" ([], (String.to_xml v.vpc_id)))])
           @
           [Util.option_map v.ipv6_cidr_block_network_border_group
              (fun f ->
                 Ezxmlm.make_tag "Ipv6CidrBlockNetworkBorderGroup"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block_network_border_group
              (fun f ->
                 ("ipv6_cidr_block_network_border_group", (String.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)));
           Util.option_map v.amazon_provided_ipv6_cidr_block
             (fun f ->
                ("amazon_provided_ipv6_cidr_block", (Boolean.to_json f)))])
    let of_json j =
      {
        amazon_provided_ipv6_cidr_block =
          (Util.option_map (Json.lookup j "amazon_provided_ipv6_cidr_block")
             Boolean.of_json);
        cidr_block =
          (Util.option_map (Json.lookup j "cidr_block") String.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        ipv6_cidr_block_network_border_group =
          (Util.option_map
             (Json.lookup j "ipv6_cidr_block_network_border_group")
             String.of_json)
      }
  end
module DescribeAggregateIdFormatResult =
  struct
    type t =
      {
      use_long_ids_aggregated: Boolean.t option ;
      statuses: IdFormatList.t }
    let make ?use_long_ids_aggregated  ?(statuses= [])  () =
      { use_long_ids_aggregated; statuses }
    let parse xml =
      Some
        {
          use_long_ids_aggregated =
            (Util.option_bind (Xml.member "useLongIdsAggregated" xml)
               Boolean.parse);
          statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "statusSet" xml)
                  IdFormatList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("StatusSet", (IdFormatList.to_query v.statuses)));
           Util.option_map v.use_long_ids_aggregated
             (fun f ->
                Query.Pair ("UseLongIdsAggregated", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.use_long_ids_aggregated
               (fun f ->
                  Ezxmlm.make_tag "useLongIdsAggregated"
                    ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "statusSet"
                      ([], (IdFormatList.to_xml [x])))) v.statuses))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("statuses", (IdFormatList.to_json v.statuses));
           Util.option_map v.use_long_ids_aggregated
             (fun f -> ("use_long_ids_aggregated", (Boolean.to_json f)))])
    let of_json j =
      {
        use_long_ids_aggregated =
          (Util.option_map (Json.lookup j "use_long_ids_aggregated")
             Boolean.of_json);
        statuses =
          (IdFormatList.of_json
             (Util.of_option_exn (Json.lookup j "statuses")))
      }
  end
module DescribeHostsRequest =
  struct
    type t =
      {
      filter: FilterList.t ;
      host_ids: RequestHostIdList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(filter= [])  ?(host_ids= [])  ?max_results  ?next_token  () =
      { filter; host_ids; max_results; next_token }
    let parse xml =
      Some
        {
          filter =
            (Util.of_option []
               (Util.option_bind (Xml.member "filter" xml) FilterList.parse));
          host_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostId" xml)
                  RequestHostIdList.parse));
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair ("HostId", (RequestHostIdList.to_query v.host_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filter)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "filter" ([], (FilterList.to_xml [x]))))
                 v.filter))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "hostId"
                        ([], (RequestHostIdList.to_xml [x])))) v.host_ids))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "maxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("host_ids", (RequestHostIdList.to_json v.host_ids));
           Some ("filter", (FilterList.to_json v.filter))])
    let of_json j =
      {
        filter =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filter")));
        host_ids =
          (RequestHostIdList.of_json
             (Util.of_option_exn (Json.lookup j "host_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeSpotPriceHistoryResult =
  struct
    type t =
      {
      next_token: String.t option ;
      spot_price_history: SpotPriceHistoryList.t }
    let make ?next_token  ?(spot_price_history= [])  () =
      { next_token; spot_price_history }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_price_history =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotPriceHistorySet" xml)
                  SpotPriceHistoryList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotPriceHistorySet",
                   (SpotPriceHistoryList.to_query v.spot_price_history)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "spotPriceHistorySet"
                      ([], (SpotPriceHistoryList.to_xml [x]))))
              v.spot_price_history))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_price_history",
                (SpotPriceHistoryList.to_json v.spot_price_history));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        spot_price_history =
          (SpotPriceHistoryList.of_json
             (Util.of_option_exn (Json.lookup j "spot_price_history")))
      }
  end
module ReportInstanceStatusRequest =
  struct
    type t =
      {
      description: String.t option ;
      dry_run: Boolean.t option ;
      end_time: DateTime.t option ;
      instances: InstanceIdStringList.t ;
      reason_codes: ReasonCodesList.t ;
      start_time: DateTime.t option ;
      status: ReportStatusType.t }
    let make ?description  ?dry_run  ?end_time  ~instances  ~reason_codes 
      ?start_time  ~status  () =
      {
        description;
        dry_run;
        end_time;
        instances;
        reason_codes;
        start_time;
        status
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          end_time =
            (Util.option_bind (Xml.member "endTime" xml) DateTime.parse);
          instances =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml)
                  InstanceIdStringList.parse));
          reason_codes =
            (Xml.required "reasonCode"
               (Util.option_bind (Xml.member "reasonCode" xml)
                  ReasonCodesList.parse));
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse);
          status =
            (Xml.required "status"
               (Util.option_bind (Xml.member "status" xml)
                  ReportStatusType.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("Status", (ReportStatusType.to_query v.status)));
           Util.option_map v.start_time
             (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("ReasonCode", (ReasonCodesList.to_query v.reason_codes)));
           Some
             (Query.Pair
                ("InstanceId", (InstanceIdStringList.to_query v.instances)));
           Util.option_map v.end_time
             (fun f -> Query.Pair ("EndTime", (DateTime.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.description
                    (fun f ->
                       Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
                @
                [Util.option_map v.dry_run
                   (fun f ->
                      Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.end_time
                  (fun f ->
                     Ezxmlm.make_tag "endTime" ([], (DateTime.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "instanceId"
                         ([], (InstanceIdStringList.to_xml [x]))))
                 v.instances))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "reasonCode"
                        ([], (ReasonCodesList.to_xml [x])))) v.reason_codes))
            @
            [Util.option_map v.start_time
               (fun f ->
                  Ezxmlm.make_tag "startTime" ([], (DateTime.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "status"
                 ([], (ReportStatusType.to_xml v.status)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("status", (ReportStatusType.to_json v.status));
           Util.option_map v.start_time
             (fun f -> ("start_time", (DateTime.to_json f)));
           Some ("reason_codes", (ReasonCodesList.to_json v.reason_codes));
           Some ("instances", (InstanceIdStringList.to_json v.instances));
           Util.option_map v.end_time
             (fun f -> ("end_time", (DateTime.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        end_time =
          (Util.option_map (Json.lookup j "end_time") DateTime.of_json);
        instances =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instances")));
        reason_codes =
          (ReasonCodesList.of_json
             (Util.of_option_exn (Json.lookup j "reason_codes")));
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json);
        status =
          (ReportStatusType.of_json
             (Util.of_option_exn (Json.lookup j "status")))
      }
  end
module ImportClientVpnClientCertificateRevocationListResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module ModifyInstanceCreditSpecificationRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      client_token: String.t option ;
      instance_credit_specifications:
        InstanceCreditSpecificationListRequest.t }
    let make ?dry_run  ?client_token  ~instance_credit_specifications  () =
      { dry_run; client_token; instance_credit_specifications }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          instance_credit_specifications =
            (Xml.required "InstanceCreditSpecification"
               (Util.option_bind
                  (Xml.member "InstanceCreditSpecification" xml)
                  InstanceCreditSpecificationListRequest.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstanceCreditSpecification",
                   (InstanceCreditSpecificationListRequest.to_query
                      v.instance_credit_specifications)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.client_token
               (fun f ->
                  Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "InstanceCreditSpecification"
                      ([],
                        (InstanceCreditSpecificationListRequest.to_xml [x]))))
              v.instance_credit_specifications))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_credit_specifications",
                (InstanceCreditSpecificationListRequest.to_json
                   v.instance_credit_specifications));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        instance_credit_specifications =
          (InstanceCreditSpecificationListRequest.of_json
             (Util.of_option_exn
                (Json.lookup j "instance_credit_specifications")))
      }
  end
module AssociateRouteTableResult =
  struct
    type t =
      {
      association_id: String.t option ;
      association_state: RouteTableAssociationState.t option }
    let make ?association_id  ?association_state  () =
      { association_id; association_state }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          association_state =
            (Util.option_bind (Xml.member "associationState" xml)
               RouteTableAssociationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 Query.Pair
                   ("AssociationState",
                     (RouteTableAssociationState.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.association_id
               (fun f ->
                  Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.association_state
              (fun f ->
                 Ezxmlm.make_tag "associationState"
                   ([], (RouteTableAssociationState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 ("association_state",
                   (RouteTableAssociationState.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        association_state =
          (Util.option_map (Json.lookup j "association_state")
             RouteTableAssociationState.of_json)
      }
  end
module CreateVpcEndpointConnectionNotificationResult =
  struct
    type t =
      {
      connection_notification: ConnectionNotification.t option ;
      client_token: String.t option }
    let make ?connection_notification  ?client_token  () =
      { connection_notification; client_token }
    let parse xml =
      Some
        {
          connection_notification =
            (Util.option_bind (Xml.member "connectionNotification" xml)
               ConnectionNotification.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.connection_notification
             (fun f ->
                Query.Pair
                  ("ConnectionNotification",
                    (ConnectionNotification.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.connection_notification
               (fun f ->
                  Ezxmlm.make_tag "connectionNotification"
                    ([], (ConnectionNotification.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "clientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.connection_notification
             (fun f ->
                ("connection_notification",
                  (ConnectionNotification.to_json f)))])
    let of_json j =
      {
        connection_notification =
          (Util.option_map (Json.lookup j "connection_notification")
             ConnectionNotification.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DeleteClientVpnRouteRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      target_vpc_subnet_id: String.t option ;
      destination_cidr_block: String.t ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?target_vpc_subnet_id 
      ~destination_cidr_block  ?dry_run  () =
      {
        client_vpn_endpoint_id;
        target_vpc_subnet_id;
        destination_cidr_block;
        dry_run
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          target_vpc_subnet_id =
            (Util.option_bind (Xml.member "TargetVpcSubnetId" xml)
               String.parse);
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)));
           Util.option_map v.target_vpc_subnet_id
             (fun f -> Query.Pair ("TargetVpcSubnetId", (String.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "ClientVpnEndpointId"
                    ([], (String.to_xml v.client_vpn_endpoint_id)))])
             @
             [Util.option_map v.target_vpc_subnet_id
                (fun f ->
                   Ezxmlm.make_tag "TargetVpcSubnetId"
                     ([], (String.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "DestinationCidrBlock"
                  ([], (String.to_xml v.destination_cidr_block)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block));
           Util.option_map v.target_vpc_subnet_id
             (fun f -> ("target_vpc_subnet_id", (String.to_json f)));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        target_vpc_subnet_id =
          (Util.option_map (Json.lookup j "target_vpc_subnet_id")
             String.of_json);
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyFleetRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      excess_capacity_termination_policy:
        FleetExcessCapacityTerminationPolicy.t option ;
      fleet_id: String.t ;
      target_capacity_specification: TargetCapacitySpecificationRequest.t }
    let make ?dry_run  ?excess_capacity_termination_policy  ~fleet_id 
      ~target_capacity_specification  () =
      {
        dry_run;
        excess_capacity_termination_policy;
        fleet_id;
        target_capacity_specification
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          excess_capacity_termination_policy =
            (Util.option_bind
               (Xml.member "ExcessCapacityTerminationPolicy" xml)
               FleetExcessCapacityTerminationPolicy.parse);
          fleet_id =
            (Xml.required "FleetId"
               (Util.option_bind (Xml.member "FleetId" xml) String.parse));
          target_capacity_specification =
            (Xml.required "TargetCapacitySpecification"
               (Util.option_bind
                  (Xml.member "TargetCapacitySpecification" xml)
                  TargetCapacitySpecificationRequest.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TargetCapacitySpecification",
                   (TargetCapacitySpecificationRequest.to_query
                      v.target_capacity_specification)));
           Some (Query.Pair ("FleetId", (String.to_query v.fleet_id)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                Query.Pair
                  ("ExcessCapacityTerminationPolicy",
                    (FleetExcessCapacityTerminationPolicy.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.excess_capacity_termination_policy
                (fun f ->
                   Ezxmlm.make_tag "ExcessCapacityTerminationPolicy"
                     ([], (FleetExcessCapacityTerminationPolicy.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "FleetId" ([], (String.to_xml v.fleet_id)))])
           @
           [Some
              (Ezxmlm.make_tag "TargetCapacitySpecification"
                 ([],
                   (TargetCapacitySpecificationRequest.to_xml
                      v.target_capacity_specification)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("target_capacity_specification",
                (TargetCapacitySpecificationRequest.to_json
                   v.target_capacity_specification));
           Some ("fleet_id", (String.to_json v.fleet_id));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                ("excess_capacity_termination_policy",
                  (FleetExcessCapacityTerminationPolicy.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        excess_capacity_termination_policy =
          (Util.option_map
             (Json.lookup j "excess_capacity_termination_policy")
             FleetExcessCapacityTerminationPolicy.of_json);
        fleet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "fleet_id")));
        target_capacity_specification =
          (TargetCapacitySpecificationRequest.of_json
             (Util.of_option_exn
                (Json.lookup j "target_capacity_specification")))
      }
  end
module DetachNetworkInterfaceRequest =
  struct
    type t =
      {
      attachment_id: String.t ;
      dry_run: Boolean.t option ;
      force: Boolean.t option }
    let make ~attachment_id  ?dry_run  ?force  () =
      { attachment_id; dry_run; force }
    let parse xml =
      Some
        {
          attachment_id =
            (Xml.required "attachmentId"
               (Util.option_bind (Xml.member "attachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          force = (Util.option_bind (Xml.member "force" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.force
              (fun f -> Query.Pair ("Force", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("AttachmentId", (String.to_query v.attachment_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "attachmentId"
                   ([], (String.to_xml v.attachment_id)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.force
              (fun f -> Ezxmlm.make_tag "force" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.force (fun f -> ("force", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("attachment_id", (String.to_json v.attachment_id))])
    let of_json j =
      {
        attachment_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        force = (Util.option_map (Json.lookup j "force") Boolean.of_json)
      }
  end
module DescribeLaunchTemplateVersionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      versions: VersionStringList.t ;
      min_version: String.t option ;
      max_version: String.t option ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      filters: FilterList.t }
    let make ?dry_run  ?launch_template_id  ?launch_template_name 
      ?(versions= [])  ?min_version  ?max_version  ?next_token  ?max_results 
      ?(filters= [])  () =
      {
        dry_run;
        launch_template_id;
        launch_template_name;
        versions;
        min_version;
        max_version;
        next_token;
        max_results;
        filters
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          launch_template_id =
            (Util.option_bind (Xml.member "LaunchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "LaunchTemplateName" xml)
               String.parse);
          versions =
            (Util.of_option []
               (Util.option_bind (Xml.member "LaunchTemplateVersion" xml)
                  VersionStringList.parse));
          min_version =
            (Util.option_bind (Xml.member "MinVersion" xml) String.parse);
          max_version =
            (Util.option_bind (Xml.member "MaxVersion" xml) String.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_version
             (fun f -> Query.Pair ("MaxVersion", (String.to_query f)));
           Util.option_map v.min_version
             (fun f -> Query.Pair ("MinVersion", (String.to_query f)));
           Some
             (Query.Pair
                ("LaunchTemplateVersion",
                  (VersionStringList.to_query v.versions)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.dry_run
                      (fun f ->
                         Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
                  @
                  [Util.option_map v.launch_template_id
                     (fun f ->
                        Ezxmlm.make_tag "LaunchTemplateId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.launch_template_name
                    (fun f ->
                       Ezxmlm.make_tag "LaunchTemplateName"
                         ([], (String.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "LaunchTemplateVersion"
                           ([], (VersionStringList.to_xml [x])))) v.versions))
               @
               [Util.option_map v.min_version
                  (fun f ->
                     Ezxmlm.make_tag "MinVersion" ([], (String.to_xml f)))])
              @
              [Util.option_map v.max_version
                 (fun f ->
                    Ezxmlm.make_tag "MaxVersion" ([], (String.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
              v.filters))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_version
             (fun f -> ("max_version", (String.to_json f)));
           Util.option_map v.min_version
             (fun f -> ("min_version", (String.to_json f)));
           Some ("versions", (VersionStringList.to_json v.versions));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        versions =
          (VersionStringList.of_json
             (Util.of_option_exn (Json.lookup j "versions")));
        min_version =
          (Util.option_map (Json.lookup j "min_version") String.of_json);
        max_version =
          (Util.option_map (Json.lookup j "max_version") String.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module CreateNetworkInterfaceRequest =
  struct
    type t =
      {
      description: String.t option ;
      dry_run: Boolean.t option ;
      groups: SecurityGroupIdStringList.t ;
      ipv6_address_count: Integer.t option ;
      ipv6_addresses: InstanceIpv6AddressList.t ;
      private_ip_address: String.t option ;
      private_ip_addresses: PrivateIpAddressSpecificationList.t ;
      secondary_private_ip_address_count: Integer.t option ;
      interface_type: NetworkInterfaceCreationType.t option ;
      subnet_id: String.t }
    let make ?description  ?dry_run  ?(groups= [])  ?ipv6_address_count 
      ?(ipv6_addresses= [])  ?private_ip_address  ?(private_ip_addresses= [])
       ?secondary_private_ip_address_count  ?interface_type  ~subnet_id  () =
      {
        description;
        dry_run;
        groups;
        ipv6_address_count;
        ipv6_addresses;
        private_ip_address;
        private_ip_addresses;
        secondary_private_ip_address_count;
        interface_type;
        subnet_id
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          ipv6_address_count =
            (Util.option_bind (Xml.member "ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6Addresses" xml)
                  InstanceIpv6AddressList.parse));
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddresses" xml)
                  PrivateIpAddressSpecificationList.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "secondaryPrivateIpAddressCount" xml)
               Integer.parse);
          interface_type =
            (Util.option_bind (Xml.member "InterfaceType" xml)
               NetworkInterfaceCreationType.parse);
          subnet_id =
            (Xml.required "subnetId"
               (Util.option_bind (Xml.member "subnetId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)));
           Util.option_map v.interface_type
             (fun f ->
                Query.Pair
                  ("InterfaceType",
                    (NetworkInterfaceCreationType.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddresses",
                  (PrivateIpAddressSpecificationList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6Addresses",
                  (InstanceIpv6AddressList.to_query v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.groups)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.description
                       (fun f ->
                          Ezxmlm.make_tag "description"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.dry_run
                      (fun f ->
                         Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "SecurityGroupId"
                             ([], (SecurityGroupIdStringList.to_xml [x]))))
                     v.groups))
                 @
                 [Util.option_map v.ipv6_address_count
                    (fun f ->
                       Ezxmlm.make_tag "ipv6AddressCount"
                         ([], (Integer.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "ipv6Addresses"
                           ([], (InstanceIpv6AddressList.to_xml [x]))))
                   v.ipv6_addresses))
               @
               [Util.option_map v.private_ip_address
                  (fun f ->
                     Ezxmlm.make_tag "privateIpAddress"
                       ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "privateIpAddresses"
                         ([], (PrivateIpAddressSpecificationList.to_xml [x]))))
                 v.private_ip_addresses))
             @
             [Util.option_map v.secondary_private_ip_address_count
                (fun f ->
                   Ezxmlm.make_tag "secondaryPrivateIpAddressCount"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.interface_type
               (fun f ->
                  Ezxmlm.make_tag "InterfaceType"
                    ([], (NetworkInterfaceCreationType.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "subnetId" ([], (String.to_xml v.subnet_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("subnet_id", (String.to_json v.subnet_id));
           Util.option_map v.interface_type
             (fun f ->
                ("interface_type", (NetworkInterfaceCreationType.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_addresses",
               (PrivateIpAddressSpecificationList.to_json
                  v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (InstanceIpv6AddressList.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)));
           Some ("groups", (SecurityGroupIdStringList.to_json v.groups));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        groups =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        ipv6_address_count =
          (Util.option_map (Json.lookup j "ipv6_address_count")
             Integer.of_json);
        ipv6_addresses =
          (InstanceIpv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_ip_addresses =
          (PrivateIpAddressSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        secondary_private_ip_address_count =
          (Util.option_map
             (Json.lookup j "secondary_private_ip_address_count")
             Integer.of_json);
        interface_type =
          (Util.option_map (Json.lookup j "interface_type")
             NetworkInterfaceCreationType.of_json);
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")))
      }
  end
module GetReservedInstancesExchangeQuoteRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      reserved_instance_ids: ReservedInstanceIdSet.t ;
      target_configurations: TargetConfigurationRequestSet.t }
    let make ?dry_run  ~reserved_instance_ids  ?(target_configurations= []) 
      () = { dry_run; reserved_instance_ids; target_configurations }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          reserved_instance_ids =
            (Xml.required "ReservedInstanceId"
               (Util.option_bind (Xml.member "ReservedInstanceId" xml)
                  ReservedInstanceIdSet.parse));
          target_configurations =
            (Util.of_option []
               (Util.option_bind (Xml.member "TargetConfiguration" xml)
                  TargetConfigurationRequestSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TargetConfiguration",
                   (TargetConfigurationRequestSet.to_query
                      v.target_configurations)));
           Some
             (Query.Pair
                ("ReservedInstanceId",
                  (ReservedInstanceIdSet.to_query v.reserved_instance_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ReservedInstanceId"
                       ([], (ReservedInstanceIdSet.to_xml [x]))))
               v.reserved_instance_ids))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "TargetConfiguration"
                      ([], (TargetConfigurationRequestSet.to_xml [x]))))
              v.target_configurations))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("target_configurations",
                (TargetConfigurationRequestSet.to_json
                   v.target_configurations));
           Some
             ("reserved_instance_ids",
               (ReservedInstanceIdSet.to_json v.reserved_instance_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        reserved_instance_ids =
          (ReservedInstanceIdSet.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instance_ids")));
        target_configurations =
          (TargetConfigurationRequestSet.of_json
             (Util.of_option_exn (Json.lookup j "target_configurations")))
      }
  end
module GetPasswordDataRequest =
  struct
    type t = {
      instance_id: String.t ;
      dry_run: Boolean.t option }
    let make ~instance_id  ?dry_run  () = { instance_id; dry_run }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "InstanceId"
                  ([], (String.to_xml v.instance_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeregisterImageRequest =
  struct
    type t = {
      image_id: String.t ;
      dry_run: Boolean.t option }
    let make ~image_id  ?dry_run  () = { image_id; dry_run }
    let parse xml =
      Some
        {
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "ImageId" ([], (String.to_xml v.image_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("image_id", (String.to_json v.image_id))])
    let of_json j =
      {
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeHostReservationsRequest =
  struct
    type t =
      {
      filter: FilterList.t ;
      host_reservation_id_set: HostReservationIdSet.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(filter= [])  ?(host_reservation_id_set= [])  ?max_results 
      ?next_token  () =
      { filter; host_reservation_id_set; max_results; next_token }
    let parse xml =
      Some
        {
          filter =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          host_reservation_id_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "HostReservationIdSet" xml)
                  HostReservationIdSet.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("HostReservationIdSet",
                  (HostReservationIdSet.to_query v.host_reservation_id_set)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filter)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filter))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "HostReservationIdSet"
                        ([], (HostReservationIdSet.to_xml [x]))))
                v.host_reservation_id_set))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("host_reservation_id_set",
               (HostReservationIdSet.to_json v.host_reservation_id_set));
           Some ("filter", (FilterList.to_json v.filter))])
    let of_json j =
      {
        filter =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filter")));
        host_reservation_id_set =
          (HostReservationIdSet.of_json
             (Util.of_option_exn (Json.lookup j "host_reservation_id_set")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteTransitGatewayRouteResult =
  struct
    type t = {
      route: TransitGatewayRoute.t option }
    let make ?route  () = { route }
    let parse xml =
      Some
        {
          route =
            (Util.option_bind (Xml.member "route" xml)
               TransitGatewayRoute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f ->
                 Query.Pair ("Route", (TransitGatewayRoute.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.route
              (fun f ->
                 Ezxmlm.make_tag "route" ([], (TransitGatewayRoute.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> ("route", (TransitGatewayRoute.to_json f)))])
    let of_json j =
      {
        route =
          (Util.option_map (Json.lookup j "route")
             TransitGatewayRoute.of_json)
      }
  end
module RebootInstancesRequest =
  struct
    type t =
      {
      instance_ids: InstanceIdStringList.t ;
      dry_run: Boolean.t option }
    let make ~instance_ids  ?dry_run  () = { instance_ids; dry_run }
    let parse xml =
      Some
        {
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "InstanceId"
                       ([], (InstanceIdStringList.to_xml [x]))))
               v.instance_ids))
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids))])
    let of_json j =
      {
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ReplaceRouteTableAssociationRequest =
  struct
    type t =
      {
      association_id: String.t ;
      dry_run: Boolean.t option ;
      route_table_id: String.t }
    let make ~association_id  ?dry_run  ~route_table_id  () =
      { association_id; dry_run; route_table_id }
    let parse xml =
      Some
        {
          association_id =
            (Xml.required "associationId"
               (Util.option_bind (Xml.member "associationId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RouteTableId", (String.to_query v.route_table_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AssociationId", (String.to_query v.association_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "associationId"
                   ([], (String.to_xml v.association_id)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "routeTableId"
                 ([], (String.to_xml v.route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("route_table_id", (String.to_json v.route_table_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("association_id", (String.to_json v.association_id))])
    let of_json j =
      {
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")))
      }
  end
module DescribeClassicLinkInstancesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      instance_ids: InstanceIdStringList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(filters= [])  ?dry_run  ?(instance_ids= [])  ?max_results 
      ?next_token  () =
      { filters; dry_run; instance_ids; max_results; next_token }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filter"
                          ([], (FilterList.to_xml [x])))) v.filters))
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "InstanceId"
                        ([], (InstanceIdStringList.to_xml [x]))))
                v.instance_ids))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "maxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetCoipPoolUsageRequest =
  struct
    type t =
      {
      pool_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~pool_id  ?(filters= [])  ?max_results  ?next_token  ?dry_run 
      () = { pool_id; filters; max_results; next_token; dry_run }
    let parse xml =
      Some
        {
          pool_id =
            (Xml.required "PoolId"
               (Util.option_bind (Xml.member "PoolId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some (Query.Pair ("PoolId", (String.to_query v.pool_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "PoolId" ([], (String.to_xml v.pool_id)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("pool_id", (String.to_json v.pool_id))])
    let of_json j =
      {
        pool_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "pool_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateInternetGatewayResult =
  struct
    type t = {
      internet_gateway: InternetGateway.t option }
    let make ?internet_gateway  () = { internet_gateway }
    let parse xml =
      Some
        {
          internet_gateway =
            (Util.option_bind (Xml.member "internetGateway" xml)
               InternetGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.internet_gateway
              (fun f ->
                 Query.Pair ("InternetGateway", (InternetGateway.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.internet_gateway
              (fun f ->
                 Ezxmlm.make_tag "internetGateway"
                   ([], (InternetGateway.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.internet_gateway
              (fun f -> ("internet_gateway", (InternetGateway.to_json f)))])
    let of_json j =
      {
        internet_gateway =
          (Util.option_map (Json.lookup j "internet_gateway")
             InternetGateway.of_json)
      }
  end
module DescribeIdFormatResult =
  struct
    type t = {
      statuses: IdFormatList.t }
    let make ?(statuses= [])  () = { statuses }
    let parse xml =
      Some
        {
          statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "statusSet" xml)
                  IdFormatList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("StatusSet", (IdFormatList.to_query v.statuses)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "statusSet"
                      ([], (IdFormatList.to_xml [x])))) v.statuses))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("statuses", (IdFormatList.to_json v.statuses))])
    let of_json j =
      {
        statuses =
          (IdFormatList.of_json
             (Util.of_option_exn (Json.lookup j "statuses")))
      }
  end
module DescribeScheduledInstanceAvailabilityRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      first_slot_start_time_range: SlotDateTimeRangeRequest.t ;
      max_results: Integer.t option ;
      max_slot_duration_in_hours: Integer.t option ;
      min_slot_duration_in_hours: Integer.t option ;
      next_token: String.t option ;
      recurrence: ScheduledInstanceRecurrenceRequest.t }
    let make ?dry_run  ?(filters= [])  ~first_slot_start_time_range 
      ?max_results  ?max_slot_duration_in_hours  ?min_slot_duration_in_hours 
      ?next_token  ~recurrence  () =
      {
        dry_run;
        filters;
        first_slot_start_time_range;
        max_results;
        max_slot_duration_in_hours;
        min_slot_duration_in_hours;
        next_token;
        recurrence
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          first_slot_start_time_range =
            (Xml.required "FirstSlotStartTimeRange"
               (Util.option_bind (Xml.member "FirstSlotStartTimeRange" xml)
                  SlotDateTimeRangeRequest.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          max_slot_duration_in_hours =
            (Util.option_bind (Xml.member "MaxSlotDurationInHours" xml)
               Integer.parse);
          min_slot_duration_in_hours =
            (Util.option_bind (Xml.member "MinSlotDurationInHours" xml)
               Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          recurrence =
            (Xml.required "Recurrence"
               (Util.option_bind (Xml.member "Recurrence" xml)
                  ScheduledInstanceRecurrenceRequest.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Recurrence",
                   (ScheduledInstanceRecurrenceRequest.to_query v.recurrence)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.min_slot_duration_in_hours
             (fun f ->
                Query.Pair ("MinSlotDurationInHours", (Integer.to_query f)));
           Util.option_map v.max_slot_duration_in_hours
             (fun f ->
                Query.Pair ("MaxSlotDurationInHours", (Integer.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("FirstSlotStartTimeRange",
                  (SlotDateTimeRangeRequest.to_query
                     v.first_slot_start_time_range)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.dry_run
                     (fun f ->
                        Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "Filter"
                            ([], (FilterList.to_xml [x])))) v.filters))
                @
                [Some
                   (Ezxmlm.make_tag "FirstSlotStartTimeRange"
                      ([],
                        (SlotDateTimeRangeRequest.to_xml
                           v.first_slot_start_time_range)))])
               @
               [Util.option_map v.max_results
                  (fun f ->
                     Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.max_slot_duration_in_hours
                 (fun f ->
                    Ezxmlm.make_tag "MaxSlotDurationInHours"
                      ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.min_slot_duration_in_hours
                (fun f ->
                   Ezxmlm.make_tag "MinSlotDurationInHours"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "Recurrence"
                 ([],
                   (ScheduledInstanceRecurrenceRequest.to_xml v.recurrence)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("recurrence",
                (ScheduledInstanceRecurrenceRequest.to_json v.recurrence));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.min_slot_duration_in_hours
             (fun f -> ("min_slot_duration_in_hours", (Integer.to_json f)));
           Util.option_map v.max_slot_duration_in_hours
             (fun f -> ("max_slot_duration_in_hours", (Integer.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("first_slot_start_time_range",
               (SlotDateTimeRangeRequest.to_json
                  v.first_slot_start_time_range));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        first_slot_start_time_range =
          (SlotDateTimeRangeRequest.of_json
             (Util.of_option_exn
                (Json.lookup j "first_slot_start_time_range")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        max_slot_duration_in_hours =
          (Util.option_map (Json.lookup j "max_slot_duration_in_hours")
             Integer.of_json);
        min_slot_duration_in_hours =
          (Util.option_map (Json.lookup j "min_slot_duration_in_hours")
             Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        recurrence =
          (ScheduledInstanceRecurrenceRequest.of_json
             (Util.of_option_exn (Json.lookup j "recurrence")))
      }
  end
module ImportImageRequest =
  struct
    type t =
      {
      architecture: String.t option ;
      client_data: ClientData.t option ;
      client_token: String.t option ;
      description: String.t option ;
      disk_containers: ImageDiskContainerList.t ;
      dry_run: Boolean.t option ;
      encrypted: Boolean.t option ;
      hypervisor: String.t option ;
      kms_key_id: String.t option ;
      license_type: String.t option ;
      platform: String.t option ;
      role_name: String.t option ;
      license_specifications: ImportImageLicenseSpecificationListRequest.t }
    let make ?architecture  ?client_data  ?client_token  ?description 
      ?(disk_containers= [])  ?dry_run  ?encrypted  ?hypervisor  ?kms_key_id 
      ?license_type  ?platform  ?role_name  ?(license_specifications= [])  ()
      =
      {
        architecture;
        client_data;
        client_token;
        description;
        disk_containers;
        dry_run;
        encrypted;
        hypervisor;
        kms_key_id;
        license_type;
        platform;
        role_name;
        license_specifications
      }
    let parse xml =
      Some
        {
          architecture =
            (Util.option_bind (Xml.member "Architecture" xml) String.parse);
          client_data =
            (Util.option_bind (Xml.member "ClientData" xml) ClientData.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          disk_containers =
            (Util.of_option []
               (Util.option_bind (Xml.member "DiskContainer" xml)
                  ImageDiskContainerList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          encrypted =
            (Util.option_bind (Xml.member "Encrypted" xml) Boolean.parse);
          hypervisor =
            (Util.option_bind (Xml.member "Hypervisor" xml) String.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "KmsKeyId" xml) String.parse);
          license_type =
            (Util.option_bind (Xml.member "LicenseType" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "Platform" xml) String.parse);
          role_name =
            (Util.option_bind (Xml.member "RoleName" xml) String.parse);
          license_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "LicenseSpecifications" xml)
                  ImportImageLicenseSpecificationListRequest.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("LicenseSpecifications",
                   (ImportImageLicenseSpecificationListRequest.to_query
                      v.license_specifications)));
           Util.option_map v.role_name
             (fun f -> Query.Pair ("RoleName", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.license_type
             (fun f -> Query.Pair ("LicenseType", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.hypervisor
             (fun f -> Query.Pair ("Hypervisor", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("DiskContainer",
                  (ImageDiskContainerList.to_query v.disk_containers)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.client_data
             (fun f -> Query.Pair ("ClientData", (ClientData.to_query f)));
           Util.option_map v.architecture
             (fun f -> Query.Pair ("Architecture", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.architecture
                          (fun f ->
                             Ezxmlm.make_tag "Architecture"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.client_data
                         (fun f ->
                            Ezxmlm.make_tag "ClientData"
                              ([], (ClientData.to_xml f)))])
                     @
                     [Util.option_map v.client_token
                        (fun f ->
                           Ezxmlm.make_tag "ClientToken"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.description
                       (fun f ->
                          Ezxmlm.make_tag "Description"
                            ([], (String.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "DiskContainer"
                              ([], (ImageDiskContainerList.to_xml [x]))))
                      v.disk_containers))
                  @
                  [Util.option_map v.dry_run
                     (fun f ->
                        Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
                 @
                 [Util.option_map v.encrypted
                    (fun f ->
                       Ezxmlm.make_tag "Encrypted" ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.hypervisor
                   (fun f ->
                      Ezxmlm.make_tag "Hypervisor" ([], (String.to_xml f)))])
               @
               [Util.option_map v.kms_key_id
                  (fun f ->
                     Ezxmlm.make_tag "KmsKeyId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.license_type
                 (fun f ->
                    Ezxmlm.make_tag "LicenseType" ([], (String.to_xml f)))])
             @
             [Util.option_map v.platform
                (fun f -> Ezxmlm.make_tag "Platform" ([], (String.to_xml f)))])
            @
            [Util.option_map v.role_name
               (fun f -> Ezxmlm.make_tag "RoleName" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "LicenseSpecifications"
                      ([],
                        (ImportImageLicenseSpecificationListRequest.to_xml
                           [x])))) v.license_specifications))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("license_specifications",
                (ImportImageLicenseSpecificationListRequest.to_json
                   v.license_specifications));
           Util.option_map v.role_name
             (fun f -> ("role_name", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.license_type
             (fun f -> ("license_type", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.hypervisor
             (fun f -> ("hypervisor", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("disk_containers",
               (ImageDiskContainerList.to_json v.disk_containers));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.client_data
             (fun f -> ("client_data", (ClientData.to_json f)));
           Util.option_map v.architecture
             (fun f -> ("architecture", (String.to_json f)))])
    let of_json j =
      {
        architecture =
          (Util.option_map (Json.lookup j "architecture") String.of_json);
        client_data =
          (Util.option_map (Json.lookup j "client_data") ClientData.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        disk_containers =
          (ImageDiskContainerList.of_json
             (Util.of_option_exn (Json.lookup j "disk_containers")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        hypervisor =
          (Util.option_map (Json.lookup j "hypervisor") String.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        license_type =
          (Util.option_map (Json.lookup j "license_type") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") String.of_json);
        role_name =
          (Util.option_map (Json.lookup j "role_name") String.of_json);
        license_specifications =
          (ImportImageLicenseSpecificationListRequest.of_json
             (Util.of_option_exn (Json.lookup j "license_specifications")))
      }
  end
module ModifyVpcEndpointServiceConfigurationRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_id: String.t ;
      acceptance_required: Boolean.t option ;
      add_network_load_balancer_arns: ValueStringList.t ;
      remove_network_load_balancer_arns: ValueStringList.t }
    let make ?dry_run  ~service_id  ?acceptance_required 
      ?(add_network_load_balancer_arns= []) 
      ?(remove_network_load_balancer_arns= [])  () =
      {
        dry_run;
        service_id;
        acceptance_required;
        add_network_load_balancer_arns;
        remove_network_load_balancer_arns
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_id =
            (Xml.required "ServiceId"
               (Util.option_bind (Xml.member "ServiceId" xml) String.parse));
          acceptance_required =
            (Util.option_bind (Xml.member "AcceptanceRequired" xml)
               Boolean.parse);
          add_network_load_balancer_arns =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddNetworkLoadBalancerArn" xml)
                  ValueStringList.parse));
          remove_network_load_balancer_arns =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "RemoveNetworkLoadBalancerArn" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RemoveNetworkLoadBalancerArn",
                   (ValueStringList.to_query
                      v.remove_network_load_balancer_arns)));
           Some
             (Query.Pair
                ("AddNetworkLoadBalancerArn",
                  (ValueStringList.to_query v.add_network_load_balancer_arns)));
           Util.option_map v.acceptance_required
             (fun f ->
                Query.Pair ("AcceptanceRequired", (Boolean.to_query f)));
           Some (Query.Pair ("ServiceId", (String.to_query v.service_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              [Some
                 (Ezxmlm.make_tag "ServiceId"
                    ([], (String.to_xml v.service_id)))])
             @
             [Util.option_map v.acceptance_required
                (fun f ->
                   Ezxmlm.make_tag "AcceptanceRequired"
                     ([], (Boolean.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "AddNetworkLoadBalancerArn"
                       ([], (ValueStringList.to_xml [x]))))
               v.add_network_load_balancer_arns))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "RemoveNetworkLoadBalancerArn"
                      ([], (ValueStringList.to_xml [x]))))
              v.remove_network_load_balancer_arns))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("remove_network_load_balancer_arns",
                (ValueStringList.to_json v.remove_network_load_balancer_arns));
           Some
             ("add_network_load_balancer_arns",
               (ValueStringList.to_json v.add_network_load_balancer_arns));
           Util.option_map v.acceptance_required
             (fun f -> ("acceptance_required", (Boolean.to_json f)));
           Some ("service_id", (String.to_json v.service_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "service_id")));
        acceptance_required =
          (Util.option_map (Json.lookup j "acceptance_required")
             Boolean.of_json);
        add_network_load_balancer_arns =
          (ValueStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "add_network_load_balancer_arns")));
        remove_network_load_balancer_arns =
          (ValueStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "remove_network_load_balancer_arns")))
      }
  end
module AcceptTransitGatewayVpcAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_attachment_id  ?dry_run  () =
      { transit_gateway_attachment_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "TransitGatewayAttachmentId"
                  ([], (String.to_xml v.transit_gateway_attachment_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeInstanceCreditSpecificationsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      instance_ids: InstanceIdStringList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(filters= [])  ?(instance_ids= [])  ?max_results 
      ?next_token  () =
      { dry_run; filters; instance_ids; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "InstanceId"
                        ([], (InstanceIdStringList.to_xml [x]))))
                v.instance_ids))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module EnableTransitGatewayRouteTablePropagationResult =
  struct
    type t = {
      propagation: TransitGatewayPropagation.t option }
    let make ?propagation  () = { propagation }
    let parse xml =
      Some
        {
          propagation =
            (Util.option_bind (Xml.member "propagation" xml)
               TransitGatewayPropagation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.propagation
              (fun f ->
                 Query.Pair
                   ("Propagation", (TransitGatewayPropagation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.propagation
              (fun f ->
                 Ezxmlm.make_tag "propagation"
                   ([], (TransitGatewayPropagation.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.propagation
              (fun f ->
                 ("propagation", (TransitGatewayPropagation.to_json f)))])
    let of_json j =
      {
        propagation =
          (Util.option_map (Json.lookup j "propagation")
             TransitGatewayPropagation.of_json)
      }
  end
module GetConsoleScreenshotRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      wake_up: Boolean.t option }
    let make ?dry_run  ~instance_id  ?wake_up  () =
      { dry_run; instance_id; wake_up }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          wake_up =
            (Util.option_bind (Xml.member "WakeUp" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.wake_up
              (fun f -> Query.Pair ("WakeUp", (Boolean.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "InstanceId"
                  ([], (String.to_xml v.instance_id)))])
           @
           [Util.option_map v.wake_up
              (fun f -> Ezxmlm.make_tag "WakeUp" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.wake_up
              (fun f -> ("wake_up", (Boolean.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        wake_up = (Util.option_map (Json.lookup j "wake_up") Boolean.of_json)
      }
  end
module RejectVpcEndpointConnectionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_id: String.t ;
      vpc_endpoint_ids: ValueStringList.t }
    let make ?dry_run  ~service_id  ~vpc_endpoint_ids  () =
      { dry_run; service_id; vpc_endpoint_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_id =
            (Xml.required "ServiceId"
               (Util.option_bind (Xml.member "ServiceId" xml) String.parse));
          vpc_endpoint_ids =
            (Xml.required "VpcEndpointId"
               (Util.option_bind (Xml.member "VpcEndpointId" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcEndpointId",
                   (ValueStringList.to_query v.vpc_endpoint_ids)));
           Some (Query.Pair ("ServiceId", (String.to_query v.service_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "ServiceId"
                  ([], (String.to_xml v.service_id)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "VpcEndpointId"
                      ([], (ValueStringList.to_xml [x])))) v.vpc_endpoint_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpc_endpoint_ids",
                (ValueStringList.to_json v.vpc_endpoint_ids));
           Some ("service_id", (String.to_json v.service_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "service_id")));
        vpc_endpoint_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoint_ids")))
      }
  end
module DescribeSpotFleetInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      spot_fleet_request_id: String.t }
    let make ?dry_run  ?max_results  ?next_token  ~spot_fleet_request_id  ()
      = { dry_run; max_results; next_token; spot_fleet_request_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_fleet_request_id =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotFleetRequestId",
                   (String.to_query v.spot_fleet_request_id)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "maxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "spotFleetRequestId"
                 ([], (String.to_xml v.spot_fleet_request_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_fleet_request_id",
                (String.to_json v.spot_fleet_request_id));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        spot_fleet_request_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_id")))
      }
  end
module DetachVpnGatewayRequest =
  struct
    type t =
      {
      vpc_id: String.t ;
      vpn_gateway_id: String.t ;
      dry_run: Boolean.t option }
    let make ~vpc_id  ~vpn_gateway_id  ?dry_run  () =
      { vpc_id; vpn_gateway_id; dry_run }
    let parse xml =
      Some
        {
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          vpn_gateway_id =
            (Xml.required "VpnGatewayId"
               (Util.option_bind (Xml.member "VpnGatewayId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("VpnGatewayId", (String.to_query v.vpn_gateway_id)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some (Ezxmlm.make_tag "VpcId" ([], (String.to_xml v.vpc_id)))])
            @
            [Some
               (Ezxmlm.make_tag "VpnGatewayId"
                  ([], (String.to_xml v.vpn_gateway_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpn_gateway_id", (String.to_json v.vpn_gateway_id));
           Some ("vpc_id", (String.to_json v.vpc_id))])
    let of_json j =
      {
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        vpn_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_gateway_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module MonitorInstancesResult =
  struct
    type t = {
      instance_monitorings: InstanceMonitoringList.t }
    let make ?(instance_monitorings= [])  () = { instance_monitorings }
    let parse xml =
      Some
        {
          instance_monitorings =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceMonitoringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceMonitoringList.to_query v.instance_monitorings)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "instancesSet"
                      ([], (InstanceMonitoringList.to_xml [x]))))
              v.instance_monitorings))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_monitorings",
                (InstanceMonitoringList.to_json v.instance_monitorings))])
    let of_json j =
      {
        instance_monitorings =
          (InstanceMonitoringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_monitorings")))
      }
  end
module AuthorizeSecurityGroupIngressRequest =
  struct
    type t =
      {
      cidr_ip: String.t option ;
      from_port: Integer.t option ;
      group_id: String.t option ;
      group_name: String.t option ;
      ip_permissions: IpPermissionList.t ;
      ip_protocol: String.t option ;
      source_security_group_name: String.t option ;
      source_security_group_owner_id: String.t option ;
      to_port: Integer.t option ;
      dry_run: Boolean.t option }
    let make ?cidr_ip  ?from_port  ?group_id  ?group_name  ?(ip_permissions=
      [])  ?ip_protocol  ?source_security_group_name 
      ?source_security_group_owner_id  ?to_port  ?dry_run  () =
      {
        cidr_ip;
        from_port;
        group_id;
        group_name;
        ip_permissions;
        ip_protocol;
        source_security_group_name;
        source_security_group_owner_id;
        to_port;
        dry_run
      }
    let parse xml =
      Some
        {
          cidr_ip = (Util.option_bind (Xml.member "CidrIp" xml) String.parse);
          from_port =
            (Util.option_bind (Xml.member "FromPort" xml) Integer.parse);
          group_id =
            (Util.option_bind (Xml.member "GroupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "IpPermissions" xml)
                  IpPermissionList.parse));
          ip_protocol =
            (Util.option_bind (Xml.member "IpProtocol" xml) String.parse);
          source_security_group_name =
            (Util.option_bind (Xml.member "SourceSecurityGroupName" xml)
               String.parse);
          source_security_group_owner_id =
            (Util.option_bind (Xml.member "SourceSecurityGroupOwnerId" xml)
               String.parse);
          to_port =
            (Util.option_bind (Xml.member "ToPort" xml) Integer.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.source_security_group_owner_id
             (fun f ->
                Query.Pair
                  ("SourceSecurityGroupOwnerId", (String.to_query f)));
           Util.option_map v.source_security_group_name
             (fun f ->
                Query.Pair ("SourceSecurityGroupName", (String.to_query f)));
           Util.option_map v.ip_protocol
             (fun f -> Query.Pair ("IpProtocol", (String.to_query f)));
           Some
             (Query.Pair
                ("IpPermissions",
                  (IpPermissionList.to_query v.ip_permissions)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)));
           Util.option_map v.cidr_ip
             (fun f -> Query.Pair ("CidrIp", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.cidr_ip
                       (fun f ->
                          Ezxmlm.make_tag "CidrIp" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.from_port
                      (fun f ->
                         Ezxmlm.make_tag "FromPort" ([], (Integer.to_xml f)))])
                  @
                  [Util.option_map v.group_id
                     (fun f ->
                        Ezxmlm.make_tag "GroupId" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.group_name
                    (fun f ->
                       Ezxmlm.make_tag "GroupName" ([], (String.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "IpPermissions"
                           ([], (IpPermissionList.to_xml [x]))))
                   v.ip_permissions))
               @
               [Util.option_map v.ip_protocol
                  (fun f ->
                     Ezxmlm.make_tag "IpProtocol" ([], (String.to_xml f)))])
              @
              [Util.option_map v.source_security_group_name
                 (fun f ->
                    Ezxmlm.make_tag "SourceSecurityGroupName"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.source_security_group_owner_id
                (fun f ->
                   Ezxmlm.make_tag "SourceSecurityGroupOwnerId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.to_port
               (fun f -> Ezxmlm.make_tag "ToPort" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.source_security_group_owner_id
             (fun f -> ("source_security_group_owner_id", (String.to_json f)));
           Util.option_map v.source_security_group_name
             (fun f -> ("source_security_group_name", (String.to_json f)));
           Util.option_map v.ip_protocol
             (fun f -> ("ip_protocol", (String.to_json f)));
           Some
             ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)));
           Util.option_map v.cidr_ip
             (fun f -> ("cidr_ip", (String.to_json f)))])
    let of_json j =
      {
        cidr_ip = (Util.option_map (Json.lookup j "cidr_ip") String.of_json);
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")));
        ip_protocol =
          (Util.option_map (Json.lookup j "ip_protocol") String.of_json);
        source_security_group_name =
          (Util.option_map (Json.lookup j "source_security_group_name")
             String.of_json);
        source_security_group_owner_id =
          (Util.option_map (Json.lookup j "source_security_group_owner_id")
             String.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteTransitGatewayMulticastDomainResult =
  struct
    type t =
      {
      transit_gateway_multicast_domain:
        TransitGatewayMulticastDomain.t option }
    let make ?transit_gateway_multicast_domain  () =
      { transit_gateway_multicast_domain }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomain" xml)
               TransitGatewayMulticastDomain.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_multicast_domain
              (fun f ->
                 Query.Pair
                   ("TransitGatewayMulticastDomain",
                     (TransitGatewayMulticastDomain.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.transit_gateway_multicast_domain
              (fun f ->
                 Ezxmlm.make_tag "transitGatewayMulticastDomain"
                   ([], (TransitGatewayMulticastDomain.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_multicast_domain
              (fun f ->
                 ("transit_gateway_multicast_domain",
                   (TransitGatewayMulticastDomain.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain =
          (Util.option_map (Json.lookup j "transit_gateway_multicast_domain")
             TransitGatewayMulticastDomain.of_json)
      }
  end
module SearchLocalGatewayRoutesResult =
  struct
    type t = {
      routes: LocalGatewayRouteList.t ;
      next_token: String.t option }
    let make ?(routes= [])  ?next_token  () = { routes; next_token }
    let parse xml =
      Some
        {
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeSet" xml)
                  LocalGatewayRouteList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("RouteSet", (LocalGatewayRouteList.to_query v.routes)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "routeSet"
                       ([], (LocalGatewayRouteList.to_xml [x])))) v.routes))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("routes", (LocalGatewayRouteList.to_json v.routes))])
    let of_json j =
      {
        routes =
          (LocalGatewayRouteList.of_json
             (Util.of_option_exn (Json.lookup j "routes")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module RunScheduledInstancesRequest =
  struct
    type t =
      {
      client_token: String.t option ;
      dry_run: Boolean.t option ;
      instance_count: Integer.t option ;
      launch_specification: ScheduledInstancesLaunchSpecification.t ;
      scheduled_instance_id: String.t }
    let make ?client_token  ?dry_run  ?instance_count  ~launch_specification 
      ~scheduled_instance_id  () =
      {
        client_token;
        dry_run;
        instance_count;
        launch_specification;
        scheduled_instance_id
      }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          instance_count =
            (Util.option_bind (Xml.member "InstanceCount" xml) Integer.parse);
          launch_specification =
            (Xml.required "LaunchSpecification"
               (Util.option_bind (Xml.member "LaunchSpecification" xml)
                  ScheduledInstancesLaunchSpecification.parse));
          scheduled_instance_id =
            (Xml.required "ScheduledInstanceId"
               (Util.option_bind (Xml.member "ScheduledInstanceId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ScheduledInstanceId",
                   (String.to_query v.scheduled_instance_id)));
           Some
             (Query.Pair
                ("LaunchSpecification",
                  (ScheduledInstancesLaunchSpecification.to_query
                     v.launch_specification)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.client_token
                  (fun f ->
                     Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
              @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.instance_count
                (fun f ->
                   Ezxmlm.make_tag "InstanceCount" ([], (Integer.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "LaunchSpecification"
                  ([],
                    (ScheduledInstancesLaunchSpecification.to_xml
                       v.launch_specification)))])
           @
           [Some
              (Ezxmlm.make_tag "ScheduledInstanceId"
                 ([], (String.to_xml v.scheduled_instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("scheduled_instance_id",
                (String.to_json v.scheduled_instance_id));
           Some
             ("launch_specification",
               (ScheduledInstancesLaunchSpecification.to_json
                  v.launch_specification));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        launch_specification =
          (ScheduledInstancesLaunchSpecification.of_json
             (Util.of_option_exn (Json.lookup j "launch_specification")));
        scheduled_instance_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "scheduled_instance_id")))
      }
  end
module DescribeExportImageTasksRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      export_image_task_ids: ExportImageTaskIdList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(filters= [])  ?(export_image_task_ids= []) 
      ?max_results  ?next_token  () =
      { dry_run; filters; export_image_task_ids; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          export_image_task_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ExportImageTaskId" xml)
                  ExportImageTaskIdList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("ExportImageTaskId",
                  (ExportImageTaskIdList.to_query v.export_image_task_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.dry_run
                  (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filter" ([], (FilterList.to_xml [x]))))
                 v.filters))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "ExportImageTaskId"
                        ([], (ExportImageTaskIdList.to_xml [x]))))
                v.export_image_task_ids))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("export_image_task_ids",
               (ExportImageTaskIdList.to_json v.export_image_task_ids));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        export_image_task_ids =
          (ExportImageTaskIdList.of_json
             (Util.of_option_exn (Json.lookup j "export_image_task_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteCustomerGatewayRequest =
  struct
    type t = {
      customer_gateway_id: String.t ;
      dry_run: Boolean.t option }
    let make ~customer_gateway_id  ?dry_run  () =
      { customer_gateway_id; dry_run }
    let parse xml =
      Some
        {
          customer_gateway_id =
            (Xml.required "CustomerGatewayId"
               (Util.option_bind (Xml.member "CustomerGatewayId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("CustomerGatewayId",
                  (String.to_query v.customer_gateway_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "CustomerGatewayId"
                  ([], (String.to_xml v.customer_gateway_id)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("customer_gateway_id", (String.to_json v.customer_gateway_id))])
    let of_json j =
      {
        customer_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateway_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module RevokeSecurityGroupIngressRequest =
  struct
    type t =
      {
      cidr_ip: String.t option ;
      from_port: Integer.t option ;
      group_id: String.t option ;
      group_name: String.t option ;
      ip_permissions: IpPermissionList.t ;
      ip_protocol: String.t option ;
      source_security_group_name: String.t option ;
      source_security_group_owner_id: String.t option ;
      to_port: Integer.t option ;
      dry_run: Boolean.t option }
    let make ?cidr_ip  ?from_port  ?group_id  ?group_name  ?(ip_permissions=
      [])  ?ip_protocol  ?source_security_group_name 
      ?source_security_group_owner_id  ?to_port  ?dry_run  () =
      {
        cidr_ip;
        from_port;
        group_id;
        group_name;
        ip_permissions;
        ip_protocol;
        source_security_group_name;
        source_security_group_owner_id;
        to_port;
        dry_run
      }
    let parse xml =
      Some
        {
          cidr_ip = (Util.option_bind (Xml.member "CidrIp" xml) String.parse);
          from_port =
            (Util.option_bind (Xml.member "FromPort" xml) Integer.parse);
          group_id =
            (Util.option_bind (Xml.member "GroupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "IpPermissions" xml)
                  IpPermissionList.parse));
          ip_protocol =
            (Util.option_bind (Xml.member "IpProtocol" xml) String.parse);
          source_security_group_name =
            (Util.option_bind (Xml.member "SourceSecurityGroupName" xml)
               String.parse);
          source_security_group_owner_id =
            (Util.option_bind (Xml.member "SourceSecurityGroupOwnerId" xml)
               String.parse);
          to_port =
            (Util.option_bind (Xml.member "ToPort" xml) Integer.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.source_security_group_owner_id
             (fun f ->
                Query.Pair
                  ("SourceSecurityGroupOwnerId", (String.to_query f)));
           Util.option_map v.source_security_group_name
             (fun f ->
                Query.Pair ("SourceSecurityGroupName", (String.to_query f)));
           Util.option_map v.ip_protocol
             (fun f -> Query.Pair ("IpProtocol", (String.to_query f)));
           Some
             (Query.Pair
                ("IpPermissions",
                  (IpPermissionList.to_query v.ip_permissions)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)));
           Util.option_map v.cidr_ip
             (fun f -> Query.Pair ("CidrIp", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.cidr_ip
                       (fun f ->
                          Ezxmlm.make_tag "CidrIp" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.from_port
                      (fun f ->
                         Ezxmlm.make_tag "FromPort" ([], (Integer.to_xml f)))])
                  @
                  [Util.option_map v.group_id
                     (fun f ->
                        Ezxmlm.make_tag "GroupId" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.group_name
                    (fun f ->
                       Ezxmlm.make_tag "GroupName" ([], (String.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "IpPermissions"
                           ([], (IpPermissionList.to_xml [x]))))
                   v.ip_permissions))
               @
               [Util.option_map v.ip_protocol
                  (fun f ->
                     Ezxmlm.make_tag "IpProtocol" ([], (String.to_xml f)))])
              @
              [Util.option_map v.source_security_group_name
                 (fun f ->
                    Ezxmlm.make_tag "SourceSecurityGroupName"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.source_security_group_owner_id
                (fun f ->
                   Ezxmlm.make_tag "SourceSecurityGroupOwnerId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.to_port
               (fun f -> Ezxmlm.make_tag "ToPort" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.source_security_group_owner_id
             (fun f -> ("source_security_group_owner_id", (String.to_json f)));
           Util.option_map v.source_security_group_name
             (fun f -> ("source_security_group_name", (String.to_json f)));
           Util.option_map v.ip_protocol
             (fun f -> ("ip_protocol", (String.to_json f)));
           Some
             ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)));
           Util.option_map v.cidr_ip
             (fun f -> ("cidr_ip", (String.to_json f)))])
    let of_json j =
      {
        cidr_ip = (Util.option_map (Json.lookup j "cidr_ip") String.of_json);
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")));
        ip_protocol =
          (Util.option_map (Json.lookup j "ip_protocol") String.of_json);
        source_security_group_name =
          (Util.option_map (Json.lookup j "source_security_group_name")
             String.of_json);
        source_security_group_owner_id =
          (Util.option_map (Json.lookup j "source_security_group_owner_id")
             String.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module UpdateSecurityGroupRuleDescriptionsEgressResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DisableVgwRoutePropagationRequest =
  struct
    type t = {
      gateway_id: String.t ;
      route_table_id: String.t }
    let make ~gateway_id  ~route_table_id  () =
      { gateway_id; route_table_id }
    let parse xml =
      Some
        {
          gateway_id =
            (Xml.required "GatewayId"
               (Util.option_bind (Xml.member "GatewayId" xml) String.parse));
          route_table_id =
            (Xml.required "RouteTableId"
               (Util.option_bind (Xml.member "RouteTableId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RouteTableId", (String.to_query v.route_table_id)));
           Some (Query.Pair ("GatewayId", (String.to_query v.gateway_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "GatewayId"
                  ([], (String.to_xml v.gateway_id)))])
           @
           [Some
              (Ezxmlm.make_tag "RouteTableId"
                 ([], (String.to_xml v.route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("route_table_id", (String.to_json v.route_table_id));
           Some ("gateway_id", (String.to_json v.gateway_id))])
    let of_json j =
      {
        gateway_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "gateway_id")));
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")))
      }
  end
module DescribeVpcAttributeResult =
  struct
    type t =
      {
      vpc_id: String.t option ;
      enable_dns_hostnames: AttributeBooleanValue.t option ;
      enable_dns_support: AttributeBooleanValue.t option }
    let make ?vpc_id  ?enable_dns_hostnames  ?enable_dns_support  () =
      { vpc_id; enable_dns_hostnames; enable_dns_support }
    let parse xml =
      Some
        {
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          enable_dns_hostnames =
            (Util.option_bind (Xml.member "enableDnsHostnames" xml)
               AttributeBooleanValue.parse);
          enable_dns_support =
            (Util.option_bind (Xml.member "enableDnsSupport" xml)
               AttributeBooleanValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enable_dns_support
              (fun f ->
                 Query.Pair
                   ("EnableDnsSupport", (AttributeBooleanValue.to_query f)));
           Util.option_map v.enable_dns_hostnames
             (fun f ->
                Query.Pair
                  ("EnableDnsHostnames", (AttributeBooleanValue.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.vpc_id
                (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.enable_dns_hostnames
               (fun f ->
                  Ezxmlm.make_tag "enableDnsHostnames"
                    ([], (AttributeBooleanValue.to_xml f)))])
           @
           [Util.option_map v.enable_dns_support
              (fun f ->
                 Ezxmlm.make_tag "enableDnsSupport"
                   ([], (AttributeBooleanValue.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enable_dns_support
              (fun f ->
                 ("enable_dns_support", (AttributeBooleanValue.to_json f)));
           Util.option_map v.enable_dns_hostnames
             (fun f ->
                ("enable_dns_hostnames", (AttributeBooleanValue.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)))])
    let of_json j =
      {
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        enable_dns_hostnames =
          (Util.option_map (Json.lookup j "enable_dns_hostnames")
             AttributeBooleanValue.of_json);
        enable_dns_support =
          (Util.option_map (Json.lookup j "enable_dns_support")
             AttributeBooleanValue.of_json)
      }
  end
module DeleteLaunchTemplateVersionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      versions: VersionStringList.t }
    let make ?dry_run  ?launch_template_id  ?launch_template_name  ~versions 
      () = { dry_run; launch_template_id; launch_template_name; versions }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          launch_template_id =
            (Util.option_bind (Xml.member "LaunchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "LaunchTemplateName" xml)
               String.parse);
          versions =
            (Xml.required "LaunchTemplateVersion"
               (Util.option_bind (Xml.member "LaunchTemplateVersion" xml)
                  VersionStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("LaunchTemplateVersion",
                   (VersionStringList.to_query v.versions)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.launch_template_id
                (fun f ->
                   Ezxmlm.make_tag "LaunchTemplateId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.launch_template_name
               (fun f ->
                  Ezxmlm.make_tag "LaunchTemplateName"
                    ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "LaunchTemplateVersion"
                      ([], (VersionStringList.to_xml [x])))) v.versions))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("versions", (VersionStringList.to_json v.versions));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        versions =
          (VersionStringList.of_json
             (Util.of_option_exn (Json.lookup j "versions")))
      }
  end
module DescribeNatGatewaysResult =
  struct
    type t = {
      nat_gateways: NatGatewayList.t ;
      next_token: String.t option }
    let make ?(nat_gateways= [])  ?next_token  () =
      { nat_gateways; next_token }
    let parse xml =
      Some
        {
          nat_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "natGatewaySet" xml)
                  NatGatewayList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NatGatewaySet", (NatGatewayList.to_query v.nat_gateways)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "natGatewaySet"
                       ([], (NatGatewayList.to_xml [x])))) v.nat_gateways))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("nat_gateways", (NatGatewayList.to_json v.nat_gateways))])
    let of_json j =
      {
        nat_gateways =
          (NatGatewayList.of_json
             (Util.of_option_exn (Json.lookup j "nat_gateways")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module TerminateClientVpnConnectionsRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      connection_id: String.t option ;
      username: String.t option ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?connection_id  ?username  ?dry_run  ()
      = { client_vpn_endpoint_id; connection_id; username; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          connection_id =
            (Util.option_bind (Xml.member "ConnectionId" xml) String.parse);
          username =
            (Util.option_bind (Xml.member "Username" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.username
             (fun f -> Query.Pair ("Username", (String.to_query f)));
           Util.option_map v.connection_id
             (fun f -> Query.Pair ("ConnectionId", (String.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "ClientVpnEndpointId"
                    ([], (String.to_xml v.client_vpn_endpoint_id)))])
             @
             [Util.option_map v.connection_id
                (fun f ->
                   Ezxmlm.make_tag "ConnectionId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.username
               (fun f -> Ezxmlm.make_tag "Username" ([], (String.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.username
             (fun f -> ("username", (String.to_json f)));
           Util.option_map v.connection_id
             (fun f -> ("connection_id", (String.to_json f)));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        connection_id =
          (Util.option_map (Json.lookup j "connection_id") String.of_json);
        username =
          (Util.option_map (Json.lookup j "username") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module GetCapacityReservationUsageResult =
  struct
    type t =
      {
      next_token: String.t option ;
      capacity_reservation_id: String.t option ;
      instance_type: String.t option ;
      total_instance_count: Integer.t option ;
      available_instance_count: Integer.t option ;
      state: CapacityReservationState.t option ;
      instance_usages: InstanceUsageSet.t }
    let make ?next_token  ?capacity_reservation_id  ?instance_type 
      ?total_instance_count  ?available_instance_count  ?state 
      ?(instance_usages= [])  () =
      {
        next_token;
        capacity_reservation_id;
        instance_type;
        total_instance_count;
        available_instance_count;
        state;
        instance_usages
      }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          capacity_reservation_id =
            (Util.option_bind (Xml.member "capacityReservationId" xml)
               String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          total_instance_count =
            (Util.option_bind (Xml.member "totalInstanceCount" xml)
               Integer.parse);
          available_instance_count =
            (Util.option_bind (Xml.member "availableInstanceCount" xml)
               Integer.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               CapacityReservationState.parse);
          instance_usages =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceUsageSet" xml)
                  InstanceUsageSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstanceUsageSet",
                   (InstanceUsageSet.to_query v.instance_usages)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (CapacityReservationState.to_query f)));
           Util.option_map v.available_instance_count
             (fun f ->
                Query.Pair ("AvailableInstanceCount", (Integer.to_query f)));
           Util.option_map v.total_instance_count
             (fun f ->
                Query.Pair ("TotalInstanceCount", (Integer.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.capacity_reservation_id
             (fun f ->
                Query.Pair ("CapacityReservationId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.next_token
                    (fun f ->
                       Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
                @
                [Util.option_map v.capacity_reservation_id
                   (fun f ->
                      Ezxmlm.make_tag "capacityReservationId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.instance_type
                  (fun f ->
                     Ezxmlm.make_tag "instanceType" ([], (String.to_xml f)))])
              @
              [Util.option_map v.total_instance_count
                 (fun f ->
                    Ezxmlm.make_tag "totalInstanceCount"
                      ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.available_instance_count
                (fun f ->
                   Ezxmlm.make_tag "availableInstanceCount"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.state
               (fun f ->
                  Ezxmlm.make_tag "state"
                    ([], (CapacityReservationState.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "instanceUsageSet"
                      ([], (InstanceUsageSet.to_xml [x])))) v.instance_usages))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_usages",
                (InstanceUsageSet.to_json v.instance_usages));
           Util.option_map v.state
             (fun f -> ("state", (CapacityReservationState.to_json f)));
           Util.option_map v.available_instance_count
             (fun f -> ("available_instance_count", (Integer.to_json f)));
           Util.option_map v.total_instance_count
             (fun f -> ("total_instance_count", (Integer.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.capacity_reservation_id
             (fun f -> ("capacity_reservation_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        capacity_reservation_id =
          (Util.option_map (Json.lookup j "capacity_reservation_id")
             String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        total_instance_count =
          (Util.option_map (Json.lookup j "total_instance_count")
             Integer.of_json);
        available_instance_count =
          (Util.option_map (Json.lookup j "available_instance_count")
             Integer.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             CapacityReservationState.of_json);
        instance_usages =
          (InstanceUsageSet.of_json
             (Util.of_option_exn (Json.lookup j "instance_usages")))
      }
  end
module DescribeFastSnapshotRestoresResult =
  struct
    type t =
      {
      fast_snapshot_restores: DescribeFastSnapshotRestoreSuccessSet.t ;
      next_token: String.t option }
    let make ?(fast_snapshot_restores= [])  ?next_token  () =
      { fast_snapshot_restores; next_token }
    let parse xml =
      Some
        {
          fast_snapshot_restores =
            (Util.of_option []
               (Util.option_bind (Xml.member "fastSnapshotRestoreSet" xml)
                  DescribeFastSnapshotRestoreSuccessSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("FastSnapshotRestoreSet",
                  (DescribeFastSnapshotRestoreSuccessSet.to_query
                     v.fast_snapshot_restores)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "fastSnapshotRestoreSet"
                       ([],
                         (DescribeFastSnapshotRestoreSuccessSet.to_xml [x]))))
               v.fast_snapshot_restores))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("fast_snapshot_restores",
               (DescribeFastSnapshotRestoreSuccessSet.to_json
                  v.fast_snapshot_restores))])
    let of_json j =
      {
        fast_snapshot_restores =
          (DescribeFastSnapshotRestoreSuccessSet.of_json
             (Util.of_option_exn (Json.lookup j "fast_snapshot_restores")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeHostReservationOfferingsRequest =
  struct
    type t =
      {
      filter: FilterList.t ;
      max_duration: Integer.t option ;
      max_results: Integer.t option ;
      min_duration: Integer.t option ;
      next_token: String.t option ;
      offering_id: String.t option }
    let make ?(filter= [])  ?max_duration  ?max_results  ?min_duration 
      ?next_token  ?offering_id  () =
      {
        filter;
        max_duration;
        max_results;
        min_duration;
        next_token;
        offering_id
      }
    let parse xml =
      Some
        {
          filter =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_duration =
            (Util.option_bind (Xml.member "MaxDuration" xml) Integer.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          min_duration =
            (Util.option_bind (Xml.member "MinDuration" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          offering_id =
            (Util.option_bind (Xml.member "OfferingId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.offering_id
              (fun f -> Query.Pair ("OfferingId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.min_duration
             (fun f -> Query.Pair ("MinDuration", (Integer.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.max_duration
             (fun f -> Query.Pair ("MaxDuration", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filter)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "Filter"
                           ([], (FilterList.to_xml [x])))) v.filter))
               @
               [Util.option_map v.max_duration
                  (fun f ->
                     Ezxmlm.make_tag "MaxDuration" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.max_results
                 (fun f ->
                    Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.min_duration
                (fun f ->
                   Ezxmlm.make_tag "MinDuration" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.offering_id
              (fun f -> Ezxmlm.make_tag "OfferingId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.offering_id
              (fun f -> ("offering_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.min_duration
             (fun f -> ("min_duration", (Integer.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.max_duration
             (fun f -> ("max_duration", (Integer.to_json f)));
           Some ("filter", (FilterList.to_json v.filter))])
    let of_json j =
      {
        filter =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filter")));
        max_duration =
          (Util.option_map (Json.lookup j "max_duration") Integer.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        min_duration =
          (Util.option_map (Json.lookup j "min_duration") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        offering_id =
          (Util.option_map (Json.lookup j "offering_id") String.of_json)
      }
  end
module PurchaseReservedInstancesOfferingRequest =
  struct
    type t =
      {
      instance_count: Integer.t ;
      reserved_instances_offering_id: String.t ;
      dry_run: Boolean.t option ;
      limit_price: ReservedInstanceLimitPrice.t option ;
      purchase_time: DateTime.t option }
    let make ~instance_count  ~reserved_instances_offering_id  ?dry_run 
      ?limit_price  ?purchase_time  () =
      {
        instance_count;
        reserved_instances_offering_id;
        dry_run;
        limit_price;
        purchase_time
      }
    let parse xml =
      Some
        {
          instance_count =
            (Xml.required "InstanceCount"
               (Util.option_bind (Xml.member "InstanceCount" xml)
                  Integer.parse));
          reserved_instances_offering_id =
            (Xml.required "ReservedInstancesOfferingId"
               (Util.option_bind
                  (Xml.member "ReservedInstancesOfferingId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          limit_price =
            (Util.option_bind (Xml.member "limitPrice" xml)
               ReservedInstanceLimitPrice.parse);
          purchase_time =
            (Util.option_bind (Xml.member "PurchaseTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.purchase_time
              (fun f -> Query.Pair ("PurchaseTime", (DateTime.to_query f)));
           Util.option_map v.limit_price
             (fun f ->
                Query.Pair
                  ("LimitPrice", (ReservedInstanceLimitPrice.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesOfferingId",
                  (String.to_query v.reserved_instances_offering_id)));
           Some
             (Query.Pair
                ("InstanceCount", (Integer.to_query v.instance_count)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "InstanceCount"
                     ([], (Integer.to_xml v.instance_count)))])
              @
              [Some
                 (Ezxmlm.make_tag "ReservedInstancesOfferingId"
                    ([], (String.to_xml v.reserved_instances_offering_id)))])
             @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.limit_price
               (fun f ->
                  Ezxmlm.make_tag "limitPrice"
                    ([], (ReservedInstanceLimitPrice.to_xml f)))])
           @
           [Util.option_map v.purchase_time
              (fun f ->
                 Ezxmlm.make_tag "PurchaseTime" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.purchase_time
              (fun f -> ("purchase_time", (DateTime.to_json f)));
           Util.option_map v.limit_price
             (fun f ->
                ("limit_price", (ReservedInstanceLimitPrice.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("reserved_instances_offering_id",
               (String.to_json v.reserved_instances_offering_id));
           Some ("instance_count", (Integer.to_json v.instance_count))])
    let of_json j =
      {
        instance_count =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "instance_count")));
        reserved_instances_offering_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_offering_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        limit_price =
          (Util.option_map (Json.lookup j "limit_price")
             ReservedInstanceLimitPrice.of_json);
        purchase_time =
          (Util.option_map (Json.lookup j "purchase_time") DateTime.of_json)
      }
  end
module DeleteNatGatewayResult =
  struct
    type t = {
      nat_gateway_id: String.t option }
    let make ?nat_gateway_id  () = { nat_gateway_id }
    let parse xml =
      Some
        {
          nat_gateway_id =
            (Util.option_bind (Xml.member "natGatewayId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.nat_gateway_id
              (fun f -> Query.Pair ("NatGatewayId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.nat_gateway_id
              (fun f ->
                 Ezxmlm.make_tag "natGatewayId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.nat_gateway_id
              (fun f -> ("nat_gateway_id", (String.to_json f)))])
    let of_json j =
      {
        nat_gateway_id =
          (Util.option_map (Json.lookup j "nat_gateway_id") String.of_json)
      }
  end
module ExportClientVpnClientConfigurationResult =
  struct
    type t = {
      client_configuration: String.t option }
    let make ?client_configuration  () = { client_configuration }
    let parse xml =
      Some
        {
          client_configuration =
            (Util.option_bind (Xml.member "clientConfiguration" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_configuration
              (fun f ->
                 Query.Pair ("ClientConfiguration", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.client_configuration
              (fun f ->
                 Ezxmlm.make_tag "clientConfiguration"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_configuration
              (fun f -> ("client_configuration", (String.to_json f)))])
    let of_json j =
      {
        client_configuration =
          (Util.option_map (Json.lookup j "client_configuration")
             String.of_json)
      }
  end
module DeleteVpcEndpointConnectionNotificationsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      connection_notification_ids: ValueStringList.t }
    let make ?dry_run  ~connection_notification_ids  () =
      { dry_run; connection_notification_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          connection_notification_ids =
            (Xml.required "ConnectionNotificationId"
               (Util.option_bind (Xml.member "ConnectionNotificationId" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ConnectionNotificationId",
                   (ValueStringList.to_query v.connection_notification_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "ConnectionNotificationId"
                      ([], (ValueStringList.to_xml [x]))))
              v.connection_notification_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("connection_notification_ids",
                (ValueStringList.to_json v.connection_notification_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        connection_notification_ids =
          (ValueStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "connection_notification_ids")))
      }
  end
module DescribeEgressOnlyInternetGatewaysResult =
  struct
    type t =
      {
      egress_only_internet_gateways: EgressOnlyInternetGatewayList.t ;
      next_token: String.t option }
    let make ?(egress_only_internet_gateways= [])  ?next_token  () =
      { egress_only_internet_gateways; next_token }
    let parse xml =
      Some
        {
          egress_only_internet_gateways =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "egressOnlyInternetGatewaySet" xml)
                  EgressOnlyInternetGatewayList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("EgressOnlyInternetGatewaySet",
                  (EgressOnlyInternetGatewayList.to_query
                     v.egress_only_internet_gateways)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "egressOnlyInternetGatewaySet"
                       ([], (EgressOnlyInternetGatewayList.to_xml [x]))))
               v.egress_only_internet_gateways))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "nextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("egress_only_internet_gateways",
               (EgressOnlyInternetGatewayList.to_json
                  v.egress_only_internet_gateways))])
    let of_json j =
      {
        egress_only_internet_gateways =
          (EgressOnlyInternetGatewayList.of_json
             (Util.of_option_exn
                (Json.lookup j "egress_only_internet_gateways")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyFpgaImageAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      fpga_image_id: String.t ;
      attribute: FpgaImageAttributeName.t option ;
      operation_type: OperationType.t option ;
      user_ids: UserIdStringList.t ;
      user_groups: UserGroupStringList.t ;
      product_codes: ProductCodeStringList.t ;
      load_permission: LoadPermissionModifications.t option ;
      description: String.t option ;
      name: String.t option }
    let make ?dry_run  ~fpga_image_id  ?attribute  ?operation_type 
      ?(user_ids= [])  ?(user_groups= [])  ?(product_codes= []) 
      ?load_permission  ?description  ?name  () =
      {
        dry_run;
        fpga_image_id;
        attribute;
        operation_type;
        user_ids;
        user_groups;
        product_codes;
        load_permission;
        description;
        name
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          fpga_image_id =
            (Xml.required "FpgaImageId"
               (Util.option_bind (Xml.member "FpgaImageId" xml) String.parse));
          attribute =
            (Util.option_bind (Xml.member "Attribute" xml)
               FpgaImageAttributeName.parse);
          operation_type =
            (Util.option_bind (Xml.member "OperationType" xml)
               OperationType.parse);
          user_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "UserId" xml)
                  UserIdStringList.parse));
          user_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "UserGroup" xml)
                  UserGroupStringList.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "ProductCode" xml)
                  ProductCodeStringList.parse));
          load_permission =
            (Util.option_bind (Xml.member "LoadPermission" xml)
               LoadPermissionModifications.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.load_permission
             (fun f ->
                Query.Pair
                  ("LoadPermission",
                    (LoadPermissionModifications.to_query f)));
           Some
             (Query.Pair
                ("ProductCode",
                  (ProductCodeStringList.to_query v.product_codes)));
           Some
             (Query.Pair
                ("UserGroup", (UserGroupStringList.to_query v.user_groups)));
           Some
             (Query.Pair ("UserId", (UserIdStringList.to_query v.user_ids)));
           Util.option_map v.operation_type
             (fun f ->
                Query.Pair ("OperationType", (OperationType.to_query f)));
           Util.option_map v.attribute
             (fun f ->
                Query.Pair ("Attribute", (FpgaImageAttributeName.to_query f)));
           Some
             (Query.Pair ("FpgaImageId", (String.to_query v.fpga_image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.dry_run
                       (fun f ->
                          Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
                   @
                   [Some
                      (Ezxmlm.make_tag "FpgaImageId"
                         ([], (String.to_xml v.fpga_image_id)))])
                  @
                  [Util.option_map v.attribute
                     (fun f ->
                        Ezxmlm.make_tag "Attribute"
                          ([], (FpgaImageAttributeName.to_xml f)))])
                 @
                 [Util.option_map v.operation_type
                    (fun f ->
                       Ezxmlm.make_tag "OperationType"
                         ([], (OperationType.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "UserId"
                           ([], (UserIdStringList.to_xml [x])))) v.user_ids))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "UserGroup"
                          ([], (UserGroupStringList.to_xml [x]))))
                  v.user_groups))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "ProductCode"
                         ([], (ProductCodeStringList.to_xml [x]))))
                 v.product_codes))
             @
             [Util.option_map v.load_permission
                (fun f ->
                   Ezxmlm.make_tag "LoadPermission"
                     ([], (LoadPermissionModifications.to_xml f)))])
            @
            [Util.option_map v.description
               (fun f ->
                  Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
           @
           [Util.option_map v.name
              (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.load_permission
             (fun f ->
                ("load_permission", (LoadPermissionModifications.to_json f)));
           Some
             ("product_codes",
               (ProductCodeStringList.to_json v.product_codes));
           Some ("user_groups", (UserGroupStringList.to_json v.user_groups));
           Some ("user_ids", (UserIdStringList.to_json v.user_ids));
           Util.option_map v.operation_type
             (fun f -> ("operation_type", (OperationType.to_json f)));
           Util.option_map v.attribute
             (fun f -> ("attribute", (FpgaImageAttributeName.to_json f)));
           Some ("fpga_image_id", (String.to_json v.fpga_image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        fpga_image_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "fpga_image_id")));
        attribute =
          (Util.option_map (Json.lookup j "attribute")
             FpgaImageAttributeName.of_json);
        operation_type =
          (Util.option_map (Json.lookup j "operation_type")
             OperationType.of_json);
        user_ids =
          (UserIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "user_ids")));
        user_groups =
          (UserGroupStringList.of_json
             (Util.of_option_exn (Json.lookup j "user_groups")));
        product_codes =
          (ProductCodeStringList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        load_permission =
          (Util.option_map (Json.lookup j "load_permission")
             LoadPermissionModifications.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json)
      }
  end
module ModifyVpcTenancyResult =
  struct
    type t = {
      return_value: Boolean.t option }
    let make ?return_value  () = { return_value }
    let parse xml =
      Some
        {
          return_value =
            (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.return_value
              (fun f -> Ezxmlm.make_tag "return" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> ("return_value", (Boolean.to_json f)))])
    let of_json j =
      {
        return_value =
          (Util.option_map (Json.lookup j "return_value") Boolean.of_json)
      }
  end
module ExportTransitGatewayRoutesResult =
  struct
    type t = {
      s3_location: String.t option }
    let make ?s3_location  () = { s3_location }
    let parse xml =
      Some
        {
          s3_location =
            (Util.option_bind (Xml.member "s3Location" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_location
              (fun f -> Query.Pair ("S3Location", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.s3_location
              (fun f -> Ezxmlm.make_tag "s3Location" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_location
              (fun f -> ("s3_location", (String.to_json f)))])
    let of_json j =
      {
        s3_location =
          (Util.option_map (Json.lookup j "s3_location") String.of_json)
      }
  end
module AttachNetworkInterfaceRequest =
  struct
    type t =
      {
      device_index: Integer.t ;
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      network_interface_id: String.t }
    let make ~device_index  ?dry_run  ~instance_id  ~network_interface_id  ()
      = { device_index; dry_run; instance_id; network_interface_id }
    let parse xml =
      Some
        {
          device_index =
            (Xml.required "deviceIndex"
               (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkInterfaceId",
                   (String.to_query v.network_interface_id)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("DeviceIndex", (Integer.to_query v.device_index)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "deviceIndex"
                    ([], (Integer.to_xml v.device_index)))])
             @
             [Util.option_map v.dry_run
                (fun f -> Ezxmlm.make_tag "dryRun" ([], (Boolean.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "instanceId"
                  ([], (String.to_xml v.instance_id)))])
           @
           [Some
              (Ezxmlm.make_tag "networkInterfaceId"
                 ([], (String.to_xml v.network_interface_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("network_interface_id",
                (String.to_json v.network_interface_id));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("device_index", (Integer.to_json v.device_index))])
    let of_json j =
      {
        device_index =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "device_index")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")))
      }
  end
module DeleteNetworkInterfacePermissionRequest =
  struct
    type t =
      {
      network_interface_permission_id: String.t ;
      force: Boolean.t option ;
      dry_run: Boolean.t option }
    let make ~network_interface_permission_id  ?force  ?dry_run  () =
      { network_interface_permission_id; force; dry_run }
    let parse xml =
      Some
        {
          network_interface_permission_id =
            (Xml.required "NetworkInterfacePermissionId"
               (Util.option_bind
                  (Xml.member "NetworkInterfacePermissionId" xml)
                  String.parse));
          force = (Util.option_bind (Xml.member "Force" xml) Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.force
             (fun f -> Query.Pair ("Force", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfacePermissionId",
                  (String.to_query v.network_interface_permission_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "NetworkInterfacePermissionId"
                   ([], (String.to_xml v.network_interface_permission_id)))])
            @
            [Util.option_map v.force
               (fun f -> Ezxmlm.make_tag "Force" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.dry_run
              (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.force (fun f -> ("force", (Boolean.to_json f)));
           Some
             ("network_interface_permission_id",
               (String.to_json v.network_interface_permission_id))])
    let of_json j =
      {
        network_interface_permission_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "network_interface_permission_id")));
        force = (Util.option_map (Json.lookup j "force") Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module UpdateSecurityGroupRuleDescriptionsIngressRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_id: String.t option ;
      group_name: String.t option ;
      ip_permissions: IpPermissionList.t }
    let make ?dry_run  ?group_id  ?group_name  ~ip_permissions  () =
      { dry_run; group_id; group_name; ip_permissions }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          group_id =
            (Util.option_bind (Xml.member "GroupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          ip_permissions =
            (Xml.required "IpPermissions"
               (Util.option_bind (Xml.member "IpPermissions" xml)
                  IpPermissionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("IpPermissions",
                   (IpPermissionList.to_query v.ip_permissions)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.dry_run
                 (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.group_id
                (fun f -> Ezxmlm.make_tag "GroupId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.group_name
               (fun f -> Ezxmlm.make_tag "GroupName" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "IpPermissions"
                      ([], (IpPermissionList.to_xml [x])))) v.ip_permissions))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")))
      }
  end