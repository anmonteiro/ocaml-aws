open Aws
open Aws.BaseTypes
open CalendarLib
type calendar = Calendar.t
module VolumeType =
  struct
    type t =
      | Standard 
      | Io1 
      | Gp2 
      | Sc1 
      | St1 
    let str_to_t =
      [("st1", St1);
      ("sc1", Sc1);
      ("gp2", Gp2);
      ("io1", Io1);
      ("standard", Standard)]
    let t_to_str =
      [(St1, "st1");
      (Sc1, "sc1");
      (Gp2, "gp2");
      (Io1, "io1");
      (Standard, "standard")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceIpv6Address =
  struct
    type t = {
      ipv6_address: String.t option }
    let make ?ipv6_address  () = { ipv6_address }
    let parse xml =
      Some
        {
          ipv6_address =
            (Util.option_bind (Xml.member "ipv6Address" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> Query.Pair ("Ipv6Address", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ipv6_address
              (fun f -> Ezxmlm.make_tag "ipv6Address" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> ("ipv6_address", (String.to_json f)))])
    let of_json j =
      {
        ipv6_address =
          (Util.option_map (Json.lookup j "ipv6_address") String.of_json)
      }
  end
module PrivateIpAddressSpecification =
  struct
    type t =
      {
      primary: Boolean.t option ;
      private_ip_address: String.t option }
    let make ?primary  ?private_ip_address  () =
      { primary; private_ip_address }
    let parse xml =
      Some
        {
          primary =
            (Util.option_bind (Xml.member "primary" xml) Boolean.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.primary
             (fun f -> Query.Pair ("Primary", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.primary
               (fun f -> Ezxmlm.make_tag "primary" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.private_ip_address
              (fun f ->
                 Ezxmlm.make_tag "privateIpAddress" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.primary
             (fun f -> ("primary", (Boolean.to_json f)))])
    let of_json j =
      {
        primary = (Util.option_map (Json.lookup j "primary") Boolean.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json)
      }
  end
module Tag =
  struct
    type t = {
      key: String.t ;
      value: String.t }
    let make ~key  ~value  () = { key; value }
    let parse xml =
      Some
        {
          key =
            (Xml.required "key"
               (Util.option_bind (Xml.member "key" xml) String.parse));
          value =
            (Xml.required "value"
               (Util.option_bind (Xml.member "value" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Value", (String.to_query v.value)));
           Some (Query.Pair ("Key", (String.to_query v.key)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "key" ([], (String.to_xml v.key)))]) @
           [Some (Ezxmlm.make_tag "value" ([], (String.to_xml v.value)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("value", (String.to_json v.value));
           Some ("key", (String.to_json v.key))])
    let of_json j =
      {
        key = (String.of_json (Util.of_option_exn (Json.lookup j "key")));
        value = (String.of_json (Util.of_option_exn (Json.lookup j "value")))
      }
  end
module InstanceNetworkInterfaceAssociation =
  struct
    type t =
      {
      ip_owner_id: String.t option ;
      public_dns_name: String.t option ;
      public_ip: String.t option }
    let make ?ip_owner_id  ?public_dns_name  ?public_ip  () =
      { ip_owner_id; public_dns_name; public_ip }
    let parse xml =
      Some
        {
          ip_owner_id =
            (Util.option_bind (Xml.member "ipOwnerId" xml) String.parse);
          public_dns_name =
            (Util.option_bind (Xml.member "publicDnsName" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.public_dns_name
             (fun f -> Query.Pair ("PublicDnsName", (String.to_query f)));
           Util.option_map v.ip_owner_id
             (fun f -> Query.Pair ("IpOwnerId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.ip_owner_id
                (fun f -> Ezxmlm.make_tag "ipOwnerId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.public_dns_name
               (fun f ->
                  Ezxmlm.make_tag "publicDnsName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.public_ip
              (fun f -> Ezxmlm.make_tag "publicIp" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.public_dns_name
             (fun f -> ("public_dns_name", (String.to_json f)));
           Util.option_map v.ip_owner_id
             (fun f -> ("ip_owner_id", (String.to_json f)))])
    let of_json j =
      {
        ip_owner_id =
          (Util.option_map (Json.lookup j "ip_owner_id") String.of_json);
        public_dns_name =
          (Util.option_map (Json.lookup j "public_dns_name") String.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json)
      }
  end
module EbsBlockDevice =
  struct
    type t =
      {
      delete_on_termination: Boolean.t option ;
      iops: Integer.t option ;
      snapshot_id: String.t option ;
      volume_size: Integer.t option ;
      volume_type: VolumeType.t option ;
      encrypted: Boolean.t option ;
      kms_key_id: String.t option }
    let make ?delete_on_termination  ?iops  ?snapshot_id  ?volume_size 
      ?volume_type  ?encrypted  ?kms_key_id  () =
      {
        delete_on_termination;
        iops;
        snapshot_id;
        volume_size;
        volume_type;
        encrypted;
        kms_key_id
      }
    let parse xml =
      Some
        {
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          iops = (Util.option_bind (Xml.member "iops" xml) Integer.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          volume_size =
            (Util.option_bind (Xml.member "volumeSize" xml) Integer.parse);
          volume_type =
            (Util.option_bind (Xml.member "volumeType" xml) VolumeType.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "KmsKeyId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.volume_type
             (fun f -> Query.Pair ("VolumeType", (VolumeType.to_query f)));
           Util.option_map v.volume_size
             (fun f -> Query.Pair ("VolumeSize", (Integer.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.delete_on_termination
                    (fun f ->
                       Ezxmlm.make_tag "deleteOnTermination"
                         ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.iops
                   (fun f -> Ezxmlm.make_tag "iops" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.snapshot_id
                  (fun f ->
                     Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.volume_size
                 (fun f ->
                    Ezxmlm.make_tag "volumeSize" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.volume_type
                (fun f ->
                   Ezxmlm.make_tag "volumeType" ([], (VolumeType.to_xml f)))])
            @
            [Util.option_map v.encrypted
               (fun f -> Ezxmlm.make_tag "encrypted" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.kms_key_id
              (fun f -> Ezxmlm.make_tag "KmsKeyId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.volume_type
             (fun f -> ("volume_type", (VolumeType.to_json f)));
           Util.option_map v.volume_size
             (fun f -> ("volume_size", (Integer.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)))])
    let of_json j =
      {
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        volume_size =
          (Util.option_map (Json.lookup j "volume_size") Integer.of_json);
        volume_type =
          (Util.option_map (Json.lookup j "volume_type") VolumeType.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json)
      }
  end
module InstanceIpv6AddressList =
  struct
    type t = InstanceIpv6Address.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceIpv6Address.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceIpv6Address.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceIpv6Address.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstanceIpv6Address.to_xml x))) v
    let to_json v = `List (List.map InstanceIpv6Address.to_json v)
    let of_json j = Json.to_list InstanceIpv6Address.of_json j
  end
module PrivateIpAddressSpecificationList =
  struct
    type t = PrivateIpAddressSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PrivateIpAddressSpecification.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list PrivateIpAddressSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list PrivateIpAddressSpecification.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (PrivateIpAddressSpecification.to_xml x))) v
    let to_json v = `List (List.map PrivateIpAddressSpecification.to_json v)
    let of_json j = Json.to_list PrivateIpAddressSpecification.of_json j
  end
module SecurityGroupIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "SecurityGroupId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ResourceType =
  struct
    type t =
      | Client_vpn_endpoint 
      | Customer_gateway 
      | Dedicated_host 
      | Dhcp_options 
      | Elastic_ip 
      | Fleet 
      | Fpga_image 
      | Host_reservation 
      | Image 
      | Instance 
      | Internet_gateway 
      | Key_pair 
      | Launch_template 
      | Natgateway 
      | Network_acl 
      | Network_interface 
      | Placement_group 
      | Reserved_instances 
      | Route_table 
      | Security_group 
      | Snapshot 
      | Spot_fleet_request 
      | Spot_instances_request 
      | Subnet 
      | Traffic_mirror_filter 
      | Traffic_mirror_session 
      | Traffic_mirror_target 
      | Transit_gateway 
      | Transit_gateway_attachment 
      | Transit_gateway_multicast_domain 
      | Transit_gateway_route_table 
      | Volume 
      | Vpc 
      | Vpc_peering_connection 
      | Vpn_connection 
      | Vpn_gateway 
    let str_to_t =
      [("vpn-gateway", Vpn_gateway);
      ("vpn-connection", Vpn_connection);
      ("vpc-peering-connection", Vpc_peering_connection);
      ("vpc", Vpc);
      ("volume", Volume);
      ("transit-gateway-route-table", Transit_gateway_route_table);
      ("transit-gateway-multicast-domain", Transit_gateway_multicast_domain);
      ("transit-gateway-attachment", Transit_gateway_attachment);
      ("transit-gateway", Transit_gateway);
      ("traffic-mirror-target", Traffic_mirror_target);
      ("traffic-mirror-session", Traffic_mirror_session);
      ("traffic-mirror-filter", Traffic_mirror_filter);
      ("subnet", Subnet);
      ("spot-instances-request", Spot_instances_request);
      ("spot-fleet-request", Spot_fleet_request);
      ("snapshot", Snapshot);
      ("security-group", Security_group);
      ("route-table", Route_table);
      ("reserved-instances", Reserved_instances);
      ("placement-group", Placement_group);
      ("network-interface", Network_interface);
      ("network-acl", Network_acl);
      ("natgateway", Natgateway);
      ("launch-template", Launch_template);
      ("key-pair", Key_pair);
      ("internet-gateway", Internet_gateway);
      ("instance", Instance);
      ("image", Image);
      ("host-reservation", Host_reservation);
      ("fpga-image", Fpga_image);
      ("fleet", Fleet);
      ("elastic-ip", Elastic_ip);
      ("dhcp-options", Dhcp_options);
      ("dedicated-host", Dedicated_host);
      ("customer-gateway", Customer_gateway);
      ("client-vpn-endpoint", Client_vpn_endpoint)]
    let t_to_str =
      [(Vpn_gateway, "vpn-gateway");
      (Vpn_connection, "vpn-connection");
      (Vpc_peering_connection, "vpc-peering-connection");
      (Vpc, "vpc");
      (Volume, "volume");
      (Transit_gateway_route_table, "transit-gateway-route-table");
      (Transit_gateway_multicast_domain, "transit-gateway-multicast-domain");
      (Transit_gateway_attachment, "transit-gateway-attachment");
      (Transit_gateway, "transit-gateway");
      (Traffic_mirror_target, "traffic-mirror-target");
      (Traffic_mirror_session, "traffic-mirror-session");
      (Traffic_mirror_filter, "traffic-mirror-filter");
      (Subnet, "subnet");
      (Spot_instances_request, "spot-instances-request");
      (Spot_fleet_request, "spot-fleet-request");
      (Snapshot, "snapshot");
      (Security_group, "security-group");
      (Route_table, "route-table");
      (Reserved_instances, "reserved-instances");
      (Placement_group, "placement-group");
      (Network_interface, "network-interface");
      (Network_acl, "network-acl");
      (Natgateway, "natgateway");
      (Launch_template, "launch-template");
      (Key_pair, "key-pair");
      (Internet_gateway, "internet-gateway");
      (Instance, "instance");
      (Image, "image");
      (Host_reservation, "host-reservation");
      (Fpga_image, "fpga-image");
      (Fleet, "fleet");
      (Elastic_ip, "elastic-ip");
      (Dhcp_options, "dhcp-options");
      (Dedicated_host, "dedicated-host");
      (Customer_gateway, "customer-gateway");
      (Client_vpn_endpoint, "client-vpn-endpoint")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TagList =
  struct
    type t = Tag.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Tag.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Tag.to_query v
    let to_headers v = Headers.to_headers_list Tag.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Tag.to_xml x))) v
    let to_json v = `List (List.map Tag.to_json v)
    let of_json j = Json.to_list Tag.of_json j
  end
module InstanceType =
  struct
    type t =
      | T1_micro 
      | T2_nano 
      | T2_micro 
      | T2_small 
      | T2_medium 
      | T2_large 
      | T2_xlarge 
      | T2_2xlarge 
      | T3_nano 
      | T3_micro 
      | T3_small 
      | T3_medium 
      | T3_large 
      | T3_xlarge 
      | T3_2xlarge 
      | T3a_nano 
      | T3a_micro 
      | T3a_small 
      | T3a_medium 
      | T3a_large 
      | T3a_xlarge 
      | T3a_2xlarge 
      | M1_small 
      | M1_medium 
      | M1_large 
      | M1_xlarge 
      | M3_medium 
      | M3_large 
      | M3_xlarge 
      | M3_2xlarge 
      | M4_large 
      | M4_xlarge 
      | M4_2xlarge 
      | M4_4xlarge 
      | M4_10xlarge 
      | M4_16xlarge 
      | M2_xlarge 
      | M2_2xlarge 
      | M2_4xlarge 
      | Cr1_8xlarge 
      | R3_large 
      | R3_xlarge 
      | R3_2xlarge 
      | R3_4xlarge 
      | R3_8xlarge 
      | R4_large 
      | R4_xlarge 
      | R4_2xlarge 
      | R4_4xlarge 
      | R4_8xlarge 
      | R4_16xlarge 
      | R5_large 
      | R5_xlarge 
      | R5_2xlarge 
      | R5_4xlarge 
      | R5_8xlarge 
      | R5_12xlarge 
      | R5_16xlarge 
      | R5_24xlarge 
      | R5_metal 
      | R5a_large 
      | R5a_xlarge 
      | R5a_2xlarge 
      | R5a_4xlarge 
      | R5a_8xlarge 
      | R5a_12xlarge 
      | R5a_16xlarge 
      | R5a_24xlarge 
      | R5d_large 
      | R5d_xlarge 
      | R5d_2xlarge 
      | R5d_4xlarge 
      | R5d_8xlarge 
      | R5d_12xlarge 
      | R5d_16xlarge 
      | R5d_24xlarge 
      | R5d_metal 
      | R5ad_large 
      | R5ad_xlarge 
      | R5ad_2xlarge 
      | R5ad_4xlarge 
      | R5ad_8xlarge 
      | R5ad_12xlarge 
      | R5ad_16xlarge 
      | R5ad_24xlarge 
      | X1_16xlarge 
      | X1_32xlarge 
      | X1e_xlarge 
      | X1e_2xlarge 
      | X1e_4xlarge 
      | X1e_8xlarge 
      | X1e_16xlarge 
      | X1e_32xlarge 
      | I2_xlarge 
      | I2_2xlarge 
      | I2_4xlarge 
      | I2_8xlarge 
      | I3_large 
      | I3_xlarge 
      | I3_2xlarge 
      | I3_4xlarge 
      | I3_8xlarge 
      | I3_16xlarge 
      | I3_metal 
      | I3en_large 
      | I3en_xlarge 
      | I3en_2xlarge 
      | I3en_3xlarge 
      | I3en_6xlarge 
      | I3en_12xlarge 
      | I3en_24xlarge 
      | I3en_metal 
      | Hi1_4xlarge 
      | Hs1_8xlarge 
      | C1_medium 
      | C1_xlarge 
      | C3_large 
      | C3_xlarge 
      | C3_2xlarge 
      | C3_4xlarge 
      | C3_8xlarge 
      | C4_large 
      | C4_xlarge 
      | C4_2xlarge 
      | C4_4xlarge 
      | C4_8xlarge 
      | C5_large 
      | C5_xlarge 
      | C5_2xlarge 
      | C5_4xlarge 
      | C5_9xlarge 
      | C5_12xlarge 
      | C5_18xlarge 
      | C5_24xlarge 
      | C5_metal 
      | C5d_large 
      | C5d_xlarge 
      | C5d_2xlarge 
      | C5d_4xlarge 
      | C5d_9xlarge 
      | C5d_12xlarge 
      | C5d_18xlarge 
      | C5d_24xlarge 
      | C5d_metal 
      | C5n_large 
      | C5n_xlarge 
      | C5n_2xlarge 
      | C5n_4xlarge 
      | C5n_9xlarge 
      | C5n_18xlarge 
      | Cc1_4xlarge 
      | Cc2_8xlarge 
      | G2_2xlarge 
      | G2_8xlarge 
      | G3_4xlarge 
      | G3_8xlarge 
      | G3_16xlarge 
      | G3s_xlarge 
      | G4dn_xlarge 
      | G4dn_2xlarge 
      | G4dn_4xlarge 
      | G4dn_8xlarge 
      | G4dn_12xlarge 
      | G4dn_16xlarge 
      | Cg1_4xlarge 
      | P2_xlarge 
      | P2_8xlarge 
      | P2_16xlarge 
      | P3_2xlarge 
      | P3_8xlarge 
      | P3_16xlarge 
      | P3dn_24xlarge 
      | D2_xlarge 
      | D2_2xlarge 
      | D2_4xlarge 
      | D2_8xlarge 
      | F1_2xlarge 
      | F1_4xlarge 
      | F1_16xlarge 
      | M5_large 
      | M5_xlarge 
      | M5_2xlarge 
      | M5_4xlarge 
      | M5_8xlarge 
      | M5_12xlarge 
      | M5_16xlarge 
      | M5_24xlarge 
      | M5_metal 
      | M5a_large 
      | M5a_xlarge 
      | M5a_2xlarge 
      | M5a_4xlarge 
      | M5a_8xlarge 
      | M5a_12xlarge 
      | M5a_16xlarge 
      | M5a_24xlarge 
      | M5d_large 
      | M5d_xlarge 
      | M5d_2xlarge 
      | M5d_4xlarge 
      | M5d_8xlarge 
      | M5d_12xlarge 
      | M5d_16xlarge 
      | M5d_24xlarge 
      | M5d_metal 
      | M5ad_large 
      | M5ad_xlarge 
      | M5ad_2xlarge 
      | M5ad_4xlarge 
      | M5ad_8xlarge 
      | M5ad_12xlarge 
      | M5ad_16xlarge 
      | M5ad_24xlarge 
      | H1_2xlarge 
      | H1_4xlarge 
      | H1_8xlarge 
      | H1_16xlarge 
      | Z1d_large 
      | Z1d_xlarge 
      | Z1d_2xlarge 
      | Z1d_3xlarge 
      | Z1d_6xlarge 
      | Z1d_12xlarge 
      | Z1d_metal 
      | U_6tb1_metal 
      | U_9tb1_metal 
      | U_12tb1_metal 
      | U_18tb1_metal 
      | U_24tb1_metal 
      | A1_medium 
      | A1_large 
      | A1_xlarge 
      | A1_2xlarge 
      | A1_4xlarge 
      | A1_metal 
      | M5dn_large 
      | M5dn_xlarge 
      | M5dn_2xlarge 
      | M5dn_4xlarge 
      | M5dn_8xlarge 
      | M5dn_12xlarge 
      | M5dn_16xlarge 
      | M5dn_24xlarge 
      | M5n_large 
      | M5n_xlarge 
      | M5n_2xlarge 
      | M5n_4xlarge 
      | M5n_8xlarge 
      | M5n_12xlarge 
      | M5n_16xlarge 
      | M5n_24xlarge 
      | R5dn_large 
      | R5dn_xlarge 
      | R5dn_2xlarge 
      | R5dn_4xlarge 
      | R5dn_8xlarge 
      | R5dn_12xlarge 
      | R5dn_16xlarge 
      | R5dn_24xlarge 
      | R5n_large 
      | R5n_xlarge 
      | R5n_2xlarge 
      | R5n_4xlarge 
      | R5n_8xlarge 
      | R5n_12xlarge 
      | R5n_16xlarge 
      | R5n_24xlarge 
      | Inf1_xlarge 
      | Inf1_2xlarge 
      | Inf1_6xlarge 
      | Inf1_24xlarge 
    let str_to_t =
      [("inf1.24xlarge", Inf1_24xlarge);
      ("inf1.6xlarge", Inf1_6xlarge);
      ("inf1.2xlarge", Inf1_2xlarge);
      ("inf1.xlarge", Inf1_xlarge);
      ("r5n.24xlarge", R5n_24xlarge);
      ("r5n.16xlarge", R5n_16xlarge);
      ("r5n.12xlarge", R5n_12xlarge);
      ("r5n.8xlarge", R5n_8xlarge);
      ("r5n.4xlarge", R5n_4xlarge);
      ("r5n.2xlarge", R5n_2xlarge);
      ("r5n.xlarge", R5n_xlarge);
      ("r5n.large", R5n_large);
      ("r5dn.24xlarge", R5dn_24xlarge);
      ("r5dn.16xlarge", R5dn_16xlarge);
      ("r5dn.12xlarge", R5dn_12xlarge);
      ("r5dn.8xlarge", R5dn_8xlarge);
      ("r5dn.4xlarge", R5dn_4xlarge);
      ("r5dn.2xlarge", R5dn_2xlarge);
      ("r5dn.xlarge", R5dn_xlarge);
      ("r5dn.large", R5dn_large);
      ("m5n.24xlarge", M5n_24xlarge);
      ("m5n.16xlarge", M5n_16xlarge);
      ("m5n.12xlarge", M5n_12xlarge);
      ("m5n.8xlarge", M5n_8xlarge);
      ("m5n.4xlarge", M5n_4xlarge);
      ("m5n.2xlarge", M5n_2xlarge);
      ("m5n.xlarge", M5n_xlarge);
      ("m5n.large", M5n_large);
      ("m5dn.24xlarge", M5dn_24xlarge);
      ("m5dn.16xlarge", M5dn_16xlarge);
      ("m5dn.12xlarge", M5dn_12xlarge);
      ("m5dn.8xlarge", M5dn_8xlarge);
      ("m5dn.4xlarge", M5dn_4xlarge);
      ("m5dn.2xlarge", M5dn_2xlarge);
      ("m5dn.xlarge", M5dn_xlarge);
      ("m5dn.large", M5dn_large);
      ("a1.metal", A1_metal);
      ("a1.4xlarge", A1_4xlarge);
      ("a1.2xlarge", A1_2xlarge);
      ("a1.xlarge", A1_xlarge);
      ("a1.large", A1_large);
      ("a1.medium", A1_medium);
      ("u-24tb1.metal", U_24tb1_metal);
      ("u-18tb1.metal", U_18tb1_metal);
      ("u-12tb1.metal", U_12tb1_metal);
      ("u-9tb1.metal", U_9tb1_metal);
      ("u-6tb1.metal", U_6tb1_metal);
      ("z1d.metal", Z1d_metal);
      ("z1d.12xlarge", Z1d_12xlarge);
      ("z1d.6xlarge", Z1d_6xlarge);
      ("z1d.3xlarge", Z1d_3xlarge);
      ("z1d.2xlarge", Z1d_2xlarge);
      ("z1d.xlarge", Z1d_xlarge);
      ("z1d.large", Z1d_large);
      ("h1.16xlarge", H1_16xlarge);
      ("h1.8xlarge", H1_8xlarge);
      ("h1.4xlarge", H1_4xlarge);
      ("h1.2xlarge", H1_2xlarge);
      ("m5ad.24xlarge", M5ad_24xlarge);
      ("m5ad.16xlarge", M5ad_16xlarge);
      ("m5ad.12xlarge", M5ad_12xlarge);
      ("m5ad.8xlarge", M5ad_8xlarge);
      ("m5ad.4xlarge", M5ad_4xlarge);
      ("m5ad.2xlarge", M5ad_2xlarge);
      ("m5ad.xlarge", M5ad_xlarge);
      ("m5ad.large", M5ad_large);
      ("m5d.metal", M5d_metal);
      ("m5d.24xlarge", M5d_24xlarge);
      ("m5d.16xlarge", M5d_16xlarge);
      ("m5d.12xlarge", M5d_12xlarge);
      ("m5d.8xlarge", M5d_8xlarge);
      ("m5d.4xlarge", M5d_4xlarge);
      ("m5d.2xlarge", M5d_2xlarge);
      ("m5d.xlarge", M5d_xlarge);
      ("m5d.large", M5d_large);
      ("m5a.24xlarge", M5a_24xlarge);
      ("m5a.16xlarge", M5a_16xlarge);
      ("m5a.12xlarge", M5a_12xlarge);
      ("m5a.8xlarge", M5a_8xlarge);
      ("m5a.4xlarge", M5a_4xlarge);
      ("m5a.2xlarge", M5a_2xlarge);
      ("m5a.xlarge", M5a_xlarge);
      ("m5a.large", M5a_large);
      ("m5.metal", M5_metal);
      ("m5.24xlarge", M5_24xlarge);
      ("m5.16xlarge", M5_16xlarge);
      ("m5.12xlarge", M5_12xlarge);
      ("m5.8xlarge", M5_8xlarge);
      ("m5.4xlarge", M5_4xlarge);
      ("m5.2xlarge", M5_2xlarge);
      ("m5.xlarge", M5_xlarge);
      ("m5.large", M5_large);
      ("f1.16xlarge", F1_16xlarge);
      ("f1.4xlarge", F1_4xlarge);
      ("f1.2xlarge", F1_2xlarge);
      ("d2.8xlarge", D2_8xlarge);
      ("d2.4xlarge", D2_4xlarge);
      ("d2.2xlarge", D2_2xlarge);
      ("d2.xlarge", D2_xlarge);
      ("p3dn.24xlarge", P3dn_24xlarge);
      ("p3.16xlarge", P3_16xlarge);
      ("p3.8xlarge", P3_8xlarge);
      ("p3.2xlarge", P3_2xlarge);
      ("p2.16xlarge", P2_16xlarge);
      ("p2.8xlarge", P2_8xlarge);
      ("p2.xlarge", P2_xlarge);
      ("cg1.4xlarge", Cg1_4xlarge);
      ("g4dn.16xlarge", G4dn_16xlarge);
      ("g4dn.12xlarge", G4dn_12xlarge);
      ("g4dn.8xlarge", G4dn_8xlarge);
      ("g4dn.4xlarge", G4dn_4xlarge);
      ("g4dn.2xlarge", G4dn_2xlarge);
      ("g4dn.xlarge", G4dn_xlarge);
      ("g3s.xlarge", G3s_xlarge);
      ("g3.16xlarge", G3_16xlarge);
      ("g3.8xlarge", G3_8xlarge);
      ("g3.4xlarge", G3_4xlarge);
      ("g2.8xlarge", G2_8xlarge);
      ("g2.2xlarge", G2_2xlarge);
      ("cc2.8xlarge", Cc2_8xlarge);
      ("cc1.4xlarge", Cc1_4xlarge);
      ("c5n.18xlarge", C5n_18xlarge);
      ("c5n.9xlarge", C5n_9xlarge);
      ("c5n.4xlarge", C5n_4xlarge);
      ("c5n.2xlarge", C5n_2xlarge);
      ("c5n.xlarge", C5n_xlarge);
      ("c5n.large", C5n_large);
      ("c5d.metal", C5d_metal);
      ("c5d.24xlarge", C5d_24xlarge);
      ("c5d.18xlarge", C5d_18xlarge);
      ("c5d.12xlarge", C5d_12xlarge);
      ("c5d.9xlarge", C5d_9xlarge);
      ("c5d.4xlarge", C5d_4xlarge);
      ("c5d.2xlarge", C5d_2xlarge);
      ("c5d.xlarge", C5d_xlarge);
      ("c5d.large", C5d_large);
      ("c5.metal", C5_metal);
      ("c5.24xlarge", C5_24xlarge);
      ("c5.18xlarge", C5_18xlarge);
      ("c5.12xlarge", C5_12xlarge);
      ("c5.9xlarge", C5_9xlarge);
      ("c5.4xlarge", C5_4xlarge);
      ("c5.2xlarge", C5_2xlarge);
      ("c5.xlarge", C5_xlarge);
      ("c5.large", C5_large);
      ("c4.8xlarge", C4_8xlarge);
      ("c4.4xlarge", C4_4xlarge);
      ("c4.2xlarge", C4_2xlarge);
      ("c4.xlarge", C4_xlarge);
      ("c4.large", C4_large);
      ("c3.8xlarge", C3_8xlarge);
      ("c3.4xlarge", C3_4xlarge);
      ("c3.2xlarge", C3_2xlarge);
      ("c3.xlarge", C3_xlarge);
      ("c3.large", C3_large);
      ("c1.xlarge", C1_xlarge);
      ("c1.medium", C1_medium);
      ("hs1.8xlarge", Hs1_8xlarge);
      ("hi1.4xlarge", Hi1_4xlarge);
      ("i3en.metal", I3en_metal);
      ("i3en.24xlarge", I3en_24xlarge);
      ("i3en.12xlarge", I3en_12xlarge);
      ("i3en.6xlarge", I3en_6xlarge);
      ("i3en.3xlarge", I3en_3xlarge);
      ("i3en.2xlarge", I3en_2xlarge);
      ("i3en.xlarge", I3en_xlarge);
      ("i3en.large", I3en_large);
      ("i3.metal", I3_metal);
      ("i3.16xlarge", I3_16xlarge);
      ("i3.8xlarge", I3_8xlarge);
      ("i3.4xlarge", I3_4xlarge);
      ("i3.2xlarge", I3_2xlarge);
      ("i3.xlarge", I3_xlarge);
      ("i3.large", I3_large);
      ("i2.8xlarge", I2_8xlarge);
      ("i2.4xlarge", I2_4xlarge);
      ("i2.2xlarge", I2_2xlarge);
      ("i2.xlarge", I2_xlarge);
      ("x1e.32xlarge", X1e_32xlarge);
      ("x1e.16xlarge", X1e_16xlarge);
      ("x1e.8xlarge", X1e_8xlarge);
      ("x1e.4xlarge", X1e_4xlarge);
      ("x1e.2xlarge", X1e_2xlarge);
      ("x1e.xlarge", X1e_xlarge);
      ("x1.32xlarge", X1_32xlarge);
      ("x1.16xlarge", X1_16xlarge);
      ("r5ad.24xlarge", R5ad_24xlarge);
      ("r5ad.16xlarge", R5ad_16xlarge);
      ("r5ad.12xlarge", R5ad_12xlarge);
      ("r5ad.8xlarge", R5ad_8xlarge);
      ("r5ad.4xlarge", R5ad_4xlarge);
      ("r5ad.2xlarge", R5ad_2xlarge);
      ("r5ad.xlarge", R5ad_xlarge);
      ("r5ad.large", R5ad_large);
      ("r5d.metal", R5d_metal);
      ("r5d.24xlarge", R5d_24xlarge);
      ("r5d.16xlarge", R5d_16xlarge);
      ("r5d.12xlarge", R5d_12xlarge);
      ("r5d.8xlarge", R5d_8xlarge);
      ("r5d.4xlarge", R5d_4xlarge);
      ("r5d.2xlarge", R5d_2xlarge);
      ("r5d.xlarge", R5d_xlarge);
      ("r5d.large", R5d_large);
      ("r5a.24xlarge", R5a_24xlarge);
      ("r5a.16xlarge", R5a_16xlarge);
      ("r5a.12xlarge", R5a_12xlarge);
      ("r5a.8xlarge", R5a_8xlarge);
      ("r5a.4xlarge", R5a_4xlarge);
      ("r5a.2xlarge", R5a_2xlarge);
      ("r5a.xlarge", R5a_xlarge);
      ("r5a.large", R5a_large);
      ("r5.metal", R5_metal);
      ("r5.24xlarge", R5_24xlarge);
      ("r5.16xlarge", R5_16xlarge);
      ("r5.12xlarge", R5_12xlarge);
      ("r5.8xlarge", R5_8xlarge);
      ("r5.4xlarge", R5_4xlarge);
      ("r5.2xlarge", R5_2xlarge);
      ("r5.xlarge", R5_xlarge);
      ("r5.large", R5_large);
      ("r4.16xlarge", R4_16xlarge);
      ("r4.8xlarge", R4_8xlarge);
      ("r4.4xlarge", R4_4xlarge);
      ("r4.2xlarge", R4_2xlarge);
      ("r4.xlarge", R4_xlarge);
      ("r4.large", R4_large);
      ("r3.8xlarge", R3_8xlarge);
      ("r3.4xlarge", R3_4xlarge);
      ("r3.2xlarge", R3_2xlarge);
      ("r3.xlarge", R3_xlarge);
      ("r3.large", R3_large);
      ("cr1.8xlarge", Cr1_8xlarge);
      ("m2.4xlarge", M2_4xlarge);
      ("m2.2xlarge", M2_2xlarge);
      ("m2.xlarge", M2_xlarge);
      ("m4.16xlarge", M4_16xlarge);
      ("m4.10xlarge", M4_10xlarge);
      ("m4.4xlarge", M4_4xlarge);
      ("m4.2xlarge", M4_2xlarge);
      ("m4.xlarge", M4_xlarge);
      ("m4.large", M4_large);
      ("m3.2xlarge", M3_2xlarge);
      ("m3.xlarge", M3_xlarge);
      ("m3.large", M3_large);
      ("m3.medium", M3_medium);
      ("m1.xlarge", M1_xlarge);
      ("m1.large", M1_large);
      ("m1.medium", M1_medium);
      ("m1.small", M1_small);
      ("t3a.2xlarge", T3a_2xlarge);
      ("t3a.xlarge", T3a_xlarge);
      ("t3a.large", T3a_large);
      ("t3a.medium", T3a_medium);
      ("t3a.small", T3a_small);
      ("t3a.micro", T3a_micro);
      ("t3a.nano", T3a_nano);
      ("t3.2xlarge", T3_2xlarge);
      ("t3.xlarge", T3_xlarge);
      ("t3.large", T3_large);
      ("t3.medium", T3_medium);
      ("t3.small", T3_small);
      ("t3.micro", T3_micro);
      ("t3.nano", T3_nano);
      ("t2.2xlarge", T2_2xlarge);
      ("t2.xlarge", T2_xlarge);
      ("t2.large", T2_large);
      ("t2.medium", T2_medium);
      ("t2.small", T2_small);
      ("t2.micro", T2_micro);
      ("t2.nano", T2_nano);
      ("t1.micro", T1_micro)]
    let t_to_str =
      [(Inf1_24xlarge, "inf1.24xlarge");
      (Inf1_6xlarge, "inf1.6xlarge");
      (Inf1_2xlarge, "inf1.2xlarge");
      (Inf1_xlarge, "inf1.xlarge");
      (R5n_24xlarge, "r5n.24xlarge");
      (R5n_16xlarge, "r5n.16xlarge");
      (R5n_12xlarge, "r5n.12xlarge");
      (R5n_8xlarge, "r5n.8xlarge");
      (R5n_4xlarge, "r5n.4xlarge");
      (R5n_2xlarge, "r5n.2xlarge");
      (R5n_xlarge, "r5n.xlarge");
      (R5n_large, "r5n.large");
      (R5dn_24xlarge, "r5dn.24xlarge");
      (R5dn_16xlarge, "r5dn.16xlarge");
      (R5dn_12xlarge, "r5dn.12xlarge");
      (R5dn_8xlarge, "r5dn.8xlarge");
      (R5dn_4xlarge, "r5dn.4xlarge");
      (R5dn_2xlarge, "r5dn.2xlarge");
      (R5dn_xlarge, "r5dn.xlarge");
      (R5dn_large, "r5dn.large");
      (M5n_24xlarge, "m5n.24xlarge");
      (M5n_16xlarge, "m5n.16xlarge");
      (M5n_12xlarge, "m5n.12xlarge");
      (M5n_8xlarge, "m5n.8xlarge");
      (M5n_4xlarge, "m5n.4xlarge");
      (M5n_2xlarge, "m5n.2xlarge");
      (M5n_xlarge, "m5n.xlarge");
      (M5n_large, "m5n.large");
      (M5dn_24xlarge, "m5dn.24xlarge");
      (M5dn_16xlarge, "m5dn.16xlarge");
      (M5dn_12xlarge, "m5dn.12xlarge");
      (M5dn_8xlarge, "m5dn.8xlarge");
      (M5dn_4xlarge, "m5dn.4xlarge");
      (M5dn_2xlarge, "m5dn.2xlarge");
      (M5dn_xlarge, "m5dn.xlarge");
      (M5dn_large, "m5dn.large");
      (A1_metal, "a1.metal");
      (A1_4xlarge, "a1.4xlarge");
      (A1_2xlarge, "a1.2xlarge");
      (A1_xlarge, "a1.xlarge");
      (A1_large, "a1.large");
      (A1_medium, "a1.medium");
      (U_24tb1_metal, "u-24tb1.metal");
      (U_18tb1_metal, "u-18tb1.metal");
      (U_12tb1_metal, "u-12tb1.metal");
      (U_9tb1_metal, "u-9tb1.metal");
      (U_6tb1_metal, "u-6tb1.metal");
      (Z1d_metal, "z1d.metal");
      (Z1d_12xlarge, "z1d.12xlarge");
      (Z1d_6xlarge, "z1d.6xlarge");
      (Z1d_3xlarge, "z1d.3xlarge");
      (Z1d_2xlarge, "z1d.2xlarge");
      (Z1d_xlarge, "z1d.xlarge");
      (Z1d_large, "z1d.large");
      (H1_16xlarge, "h1.16xlarge");
      (H1_8xlarge, "h1.8xlarge");
      (H1_4xlarge, "h1.4xlarge");
      (H1_2xlarge, "h1.2xlarge");
      (M5ad_24xlarge, "m5ad.24xlarge");
      (M5ad_16xlarge, "m5ad.16xlarge");
      (M5ad_12xlarge, "m5ad.12xlarge");
      (M5ad_8xlarge, "m5ad.8xlarge");
      (M5ad_4xlarge, "m5ad.4xlarge");
      (M5ad_2xlarge, "m5ad.2xlarge");
      (M5ad_xlarge, "m5ad.xlarge");
      (M5ad_large, "m5ad.large");
      (M5d_metal, "m5d.metal");
      (M5d_24xlarge, "m5d.24xlarge");
      (M5d_16xlarge, "m5d.16xlarge");
      (M5d_12xlarge, "m5d.12xlarge");
      (M5d_8xlarge, "m5d.8xlarge");
      (M5d_4xlarge, "m5d.4xlarge");
      (M5d_2xlarge, "m5d.2xlarge");
      (M5d_xlarge, "m5d.xlarge");
      (M5d_large, "m5d.large");
      (M5a_24xlarge, "m5a.24xlarge");
      (M5a_16xlarge, "m5a.16xlarge");
      (M5a_12xlarge, "m5a.12xlarge");
      (M5a_8xlarge, "m5a.8xlarge");
      (M5a_4xlarge, "m5a.4xlarge");
      (M5a_2xlarge, "m5a.2xlarge");
      (M5a_xlarge, "m5a.xlarge");
      (M5a_large, "m5a.large");
      (M5_metal, "m5.metal");
      (M5_24xlarge, "m5.24xlarge");
      (M5_16xlarge, "m5.16xlarge");
      (M5_12xlarge, "m5.12xlarge");
      (M5_8xlarge, "m5.8xlarge");
      (M5_4xlarge, "m5.4xlarge");
      (M5_2xlarge, "m5.2xlarge");
      (M5_xlarge, "m5.xlarge");
      (M5_large, "m5.large");
      (F1_16xlarge, "f1.16xlarge");
      (F1_4xlarge, "f1.4xlarge");
      (F1_2xlarge, "f1.2xlarge");
      (D2_8xlarge, "d2.8xlarge");
      (D2_4xlarge, "d2.4xlarge");
      (D2_2xlarge, "d2.2xlarge");
      (D2_xlarge, "d2.xlarge");
      (P3dn_24xlarge, "p3dn.24xlarge");
      (P3_16xlarge, "p3.16xlarge");
      (P3_8xlarge, "p3.8xlarge");
      (P3_2xlarge, "p3.2xlarge");
      (P2_16xlarge, "p2.16xlarge");
      (P2_8xlarge, "p2.8xlarge");
      (P2_xlarge, "p2.xlarge");
      (Cg1_4xlarge, "cg1.4xlarge");
      (G4dn_16xlarge, "g4dn.16xlarge");
      (G4dn_12xlarge, "g4dn.12xlarge");
      (G4dn_8xlarge, "g4dn.8xlarge");
      (G4dn_4xlarge, "g4dn.4xlarge");
      (G4dn_2xlarge, "g4dn.2xlarge");
      (G4dn_xlarge, "g4dn.xlarge");
      (G3s_xlarge, "g3s.xlarge");
      (G3_16xlarge, "g3.16xlarge");
      (G3_8xlarge, "g3.8xlarge");
      (G3_4xlarge, "g3.4xlarge");
      (G2_8xlarge, "g2.8xlarge");
      (G2_2xlarge, "g2.2xlarge");
      (Cc2_8xlarge, "cc2.8xlarge");
      (Cc1_4xlarge, "cc1.4xlarge");
      (C5n_18xlarge, "c5n.18xlarge");
      (C5n_9xlarge, "c5n.9xlarge");
      (C5n_4xlarge, "c5n.4xlarge");
      (C5n_2xlarge, "c5n.2xlarge");
      (C5n_xlarge, "c5n.xlarge");
      (C5n_large, "c5n.large");
      (C5d_metal, "c5d.metal");
      (C5d_24xlarge, "c5d.24xlarge");
      (C5d_18xlarge, "c5d.18xlarge");
      (C5d_12xlarge, "c5d.12xlarge");
      (C5d_9xlarge, "c5d.9xlarge");
      (C5d_4xlarge, "c5d.4xlarge");
      (C5d_2xlarge, "c5d.2xlarge");
      (C5d_xlarge, "c5d.xlarge");
      (C5d_large, "c5d.large");
      (C5_metal, "c5.metal");
      (C5_24xlarge, "c5.24xlarge");
      (C5_18xlarge, "c5.18xlarge");
      (C5_12xlarge, "c5.12xlarge");
      (C5_9xlarge, "c5.9xlarge");
      (C5_4xlarge, "c5.4xlarge");
      (C5_2xlarge, "c5.2xlarge");
      (C5_xlarge, "c5.xlarge");
      (C5_large, "c5.large");
      (C4_8xlarge, "c4.8xlarge");
      (C4_4xlarge, "c4.4xlarge");
      (C4_2xlarge, "c4.2xlarge");
      (C4_xlarge, "c4.xlarge");
      (C4_large, "c4.large");
      (C3_8xlarge, "c3.8xlarge");
      (C3_4xlarge, "c3.4xlarge");
      (C3_2xlarge, "c3.2xlarge");
      (C3_xlarge, "c3.xlarge");
      (C3_large, "c3.large");
      (C1_xlarge, "c1.xlarge");
      (C1_medium, "c1.medium");
      (Hs1_8xlarge, "hs1.8xlarge");
      (Hi1_4xlarge, "hi1.4xlarge");
      (I3en_metal, "i3en.metal");
      (I3en_24xlarge, "i3en.24xlarge");
      (I3en_12xlarge, "i3en.12xlarge");
      (I3en_6xlarge, "i3en.6xlarge");
      (I3en_3xlarge, "i3en.3xlarge");
      (I3en_2xlarge, "i3en.2xlarge");
      (I3en_xlarge, "i3en.xlarge");
      (I3en_large, "i3en.large");
      (I3_metal, "i3.metal");
      (I3_16xlarge, "i3.16xlarge");
      (I3_8xlarge, "i3.8xlarge");
      (I3_4xlarge, "i3.4xlarge");
      (I3_2xlarge, "i3.2xlarge");
      (I3_xlarge, "i3.xlarge");
      (I3_large, "i3.large");
      (I2_8xlarge, "i2.8xlarge");
      (I2_4xlarge, "i2.4xlarge");
      (I2_2xlarge, "i2.2xlarge");
      (I2_xlarge, "i2.xlarge");
      (X1e_32xlarge, "x1e.32xlarge");
      (X1e_16xlarge, "x1e.16xlarge");
      (X1e_8xlarge, "x1e.8xlarge");
      (X1e_4xlarge, "x1e.4xlarge");
      (X1e_2xlarge, "x1e.2xlarge");
      (X1e_xlarge, "x1e.xlarge");
      (X1_32xlarge, "x1.32xlarge");
      (X1_16xlarge, "x1.16xlarge");
      (R5ad_24xlarge, "r5ad.24xlarge");
      (R5ad_16xlarge, "r5ad.16xlarge");
      (R5ad_12xlarge, "r5ad.12xlarge");
      (R5ad_8xlarge, "r5ad.8xlarge");
      (R5ad_4xlarge, "r5ad.4xlarge");
      (R5ad_2xlarge, "r5ad.2xlarge");
      (R5ad_xlarge, "r5ad.xlarge");
      (R5ad_large, "r5ad.large");
      (R5d_metal, "r5d.metal");
      (R5d_24xlarge, "r5d.24xlarge");
      (R5d_16xlarge, "r5d.16xlarge");
      (R5d_12xlarge, "r5d.12xlarge");
      (R5d_8xlarge, "r5d.8xlarge");
      (R5d_4xlarge, "r5d.4xlarge");
      (R5d_2xlarge, "r5d.2xlarge");
      (R5d_xlarge, "r5d.xlarge");
      (R5d_large, "r5d.large");
      (R5a_24xlarge, "r5a.24xlarge");
      (R5a_16xlarge, "r5a.16xlarge");
      (R5a_12xlarge, "r5a.12xlarge");
      (R5a_8xlarge, "r5a.8xlarge");
      (R5a_4xlarge, "r5a.4xlarge");
      (R5a_2xlarge, "r5a.2xlarge");
      (R5a_xlarge, "r5a.xlarge");
      (R5a_large, "r5a.large");
      (R5_metal, "r5.metal");
      (R5_24xlarge, "r5.24xlarge");
      (R5_16xlarge, "r5.16xlarge");
      (R5_12xlarge, "r5.12xlarge");
      (R5_8xlarge, "r5.8xlarge");
      (R5_4xlarge, "r5.4xlarge");
      (R5_2xlarge, "r5.2xlarge");
      (R5_xlarge, "r5.xlarge");
      (R5_large, "r5.large");
      (R4_16xlarge, "r4.16xlarge");
      (R4_8xlarge, "r4.8xlarge");
      (R4_4xlarge, "r4.4xlarge");
      (R4_2xlarge, "r4.2xlarge");
      (R4_xlarge, "r4.xlarge");
      (R4_large, "r4.large");
      (R3_8xlarge, "r3.8xlarge");
      (R3_4xlarge, "r3.4xlarge");
      (R3_2xlarge, "r3.2xlarge");
      (R3_xlarge, "r3.xlarge");
      (R3_large, "r3.large");
      (Cr1_8xlarge, "cr1.8xlarge");
      (M2_4xlarge, "m2.4xlarge");
      (M2_2xlarge, "m2.2xlarge");
      (M2_xlarge, "m2.xlarge");
      (M4_16xlarge, "m4.16xlarge");
      (M4_10xlarge, "m4.10xlarge");
      (M4_4xlarge, "m4.4xlarge");
      (M4_2xlarge, "m4.2xlarge");
      (M4_xlarge, "m4.xlarge");
      (M4_large, "m4.large");
      (M3_2xlarge, "m3.2xlarge");
      (M3_xlarge, "m3.xlarge");
      (M3_large, "m3.large");
      (M3_medium, "m3.medium");
      (M1_xlarge, "m1.xlarge");
      (M1_large, "m1.large");
      (M1_medium, "m1.medium");
      (M1_small, "m1.small");
      (T3a_2xlarge, "t3a.2xlarge");
      (T3a_xlarge, "t3a.xlarge");
      (T3a_large, "t3a.large");
      (T3a_medium, "t3a.medium");
      (T3a_small, "t3a.small");
      (T3a_micro, "t3a.micro");
      (T3a_nano, "t3a.nano");
      (T3_2xlarge, "t3.2xlarge");
      (T3_xlarge, "t3.xlarge");
      (T3_large, "t3.large");
      (T3_medium, "t3.medium");
      (T3_small, "t3.small");
      (T3_micro, "t3.micro");
      (T3_nano, "t3.nano");
      (T2_2xlarge, "t2.2xlarge");
      (T2_xlarge, "t2.xlarge");
      (T2_large, "t2.large");
      (T2_medium, "t2.medium");
      (T2_small, "t2.small");
      (T2_micro, "t2.micro");
      (T2_nano, "t2.nano");
      (T1_micro, "t1.micro")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AttachmentStatus =
  struct
    type t =
      | Attaching 
      | Attached 
      | Detaching 
      | Detached 
    let str_to_t =
      [("detached", Detached);
      ("detaching", Detaching);
      ("attached", Attached);
      ("attaching", Attaching)]
    let t_to_str =
      [(Detached, "detached");
      (Detaching, "detaching");
      (Attached, "attached");
      (Attaching, "attaching")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module GroupIdentifier =
  struct
    type t = {
      group_name: String.t option ;
      group_id: String.t option }
    let make ?group_name  ?group_id  () = { group_name; group_id }
    let parse xml =
      Some
        {
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_id
              (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.group_name
               (fun f -> Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.group_id
              (fun f -> Ezxmlm.make_tag "groupId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_id
              (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)))])
    let of_json j =
      {
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json)
      }
  end
module InstancePrivateIpAddress =
  struct
    type t =
      {
      association: InstanceNetworkInterfaceAssociation.t option ;
      primary: Boolean.t option ;
      private_dns_name: String.t option ;
      private_ip_address: String.t option }
    let make ?association  ?primary  ?private_dns_name  ?private_ip_address 
      () = { association; primary; private_dns_name; private_ip_address }
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               InstanceNetworkInterfaceAssociation.parse);
          primary =
            (Util.option_bind (Xml.member "primary" xml) Boolean.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.primary
             (fun f -> Query.Pair ("Primary", (Boolean.to_query f)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association",
                    (InstanceNetworkInterfaceAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.association
                 (fun f ->
                    Ezxmlm.make_tag "association"
                      ([], (InstanceNetworkInterfaceAssociation.to_xml f)))])
             @
             [Util.option_map v.primary
                (fun f -> Ezxmlm.make_tag "primary" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.private_dns_name
               (fun f ->
                  Ezxmlm.make_tag "privateDnsName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.private_ip_address
              (fun f ->
                 Ezxmlm.make_tag "privateIpAddress" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.primary
             (fun f -> ("primary", (Boolean.to_json f)));
           Util.option_map v.association
             (fun f ->
                ("association",
                  (InstanceNetworkInterfaceAssociation.to_json f)))])
    let of_json j =
      {
        association =
          (Util.option_map (Json.lookup j "association")
             InstanceNetworkInterfaceAssociation.of_json);
        primary = (Util.option_map (Json.lookup j "primary") Boolean.of_json);
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json)
      }
  end
module IKEVersionsListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Phase1DHGroupNumbersListValue =
  struct
    type t = {
      value: Integer.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) Integer.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Integer.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") Integer.of_json) }
  end
module Phase1EncryptionAlgorithmsListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Phase1IntegrityAlgorithmsListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Phase2DHGroupNumbersListValue =
  struct
    type t = {
      value: Integer.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) Integer.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Integer.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") Integer.of_json) }
  end
module Phase2EncryptionAlgorithmsListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Phase2IntegrityAlgorithmsListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module DiskImageFormat =
  struct
    type t =
      | VMDK 
      | RAW 
      | VHD 
    let str_to_t = [("VHD", VHD); ("RAW", RAW); ("VMDK", VMDK)]
    let t_to_str = [(VHD, "VHD"); (RAW, "RAW"); (VMDK, "VMDK")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PlacementResponse =
  struct
    type t = {
      group_name: String.t option }
    let make ?group_name  () = { group_name }
    let parse xml =
      Some
        {
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> Query.Pair ("GroupName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.group_name
              (fun f -> Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> ("group_name", (String.to_json f)))])
    let of_json j =
      {
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json)
      }
  end
module BlockDeviceMapping =
  struct
    type t =
      {
      device_name: String.t ;
      virtual_name: String.t option ;
      ebs: EbsBlockDevice.t option ;
      no_device: String.t option }
    let make ~device_name  ?virtual_name  ?ebs  ?no_device  () =
      { device_name; virtual_name; ebs; no_device }
    let parse xml =
      Some
        {
          device_name =
            (Xml.required "deviceName"
               (Util.option_bind (Xml.member "deviceName" xml) String.parse));
          virtual_name =
            (Util.option_bind (Xml.member "virtualName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "ebs" xml) EbsBlockDevice.parse);
          no_device =
            (Util.option_bind (Xml.member "noDevice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.ebs
             (fun f -> Query.Pair ("Ebs", (EbsBlockDevice.to_query f)));
           Util.option_map v.virtual_name
             (fun f -> Query.Pair ("VirtualName", (String.to_query f)));
           Some (Query.Pair ("DeviceName", (String.to_query v.device_name)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "deviceName"
                    ([], (String.to_xml v.device_name)))])
             @
             [Util.option_map v.virtual_name
                (fun f ->
                   Ezxmlm.make_tag "virtualName" ([], (String.to_xml f)))])
            @
            [Util.option_map v.ebs
               (fun f ->
                  Ezxmlm.make_tag "ebs" ([], (EbsBlockDevice.to_xml f)))])
           @
           [Util.option_map v.no_device
              (fun f -> Ezxmlm.make_tag "noDevice" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.ebs
             (fun f -> ("ebs", (EbsBlockDevice.to_json f)));
           Util.option_map v.virtual_name
             (fun f -> ("virtual_name", (String.to_json f)));
           Some ("device_name", (String.to_json v.device_name))])
    let of_json j =
      {
        device_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "device_name")));
        virtual_name =
          (Util.option_map (Json.lookup j "virtual_name") String.of_json);
        ebs = (Util.option_map (Json.lookup j "ebs") EbsBlockDevice.of_json);
        no_device =
          (Util.option_map (Json.lookup j "no_device") String.of_json)
      }
  end
module InstanceNetworkInterfaceSpecification =
  struct
    type t =
      {
      associate_public_ip_address: Boolean.t option ;
      delete_on_termination: Boolean.t option ;
      description: String.t option ;
      device_index: Integer.t option ;
      groups: SecurityGroupIdStringList.t ;
      ipv6_address_count: Integer.t option ;
      ipv6_addresses: InstanceIpv6AddressList.t ;
      network_interface_id: String.t option ;
      private_ip_address: String.t option ;
      private_ip_addresses: PrivateIpAddressSpecificationList.t ;
      secondary_private_ip_address_count: Integer.t option ;
      subnet_id: String.t option ;
      interface_type: String.t option }
    let make ?associate_public_ip_address  ?delete_on_termination 
      ?description  ?device_index  ?(groups= [])  ?ipv6_address_count 
      ?(ipv6_addresses= [])  ?network_interface_id  ?private_ip_address 
      ?(private_ip_addresses= [])  ?secondary_private_ip_address_count 
      ?subnet_id  ?interface_type  () =
      {
        associate_public_ip_address;
        delete_on_termination;
        description;
        device_index;
        groups;
        ipv6_address_count;
        ipv6_addresses;
        network_interface_id;
        private_ip_address;
        private_ip_addresses;
        secondary_private_ip_address_count;
        subnet_id;
        interface_type
      }
    let parse xml =
      Some
        {
          associate_public_ip_address =
            (Util.option_bind (Xml.member "associatePublicIpAddress" xml)
               Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          device_index =
            (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          ipv6_address_count =
            (Util.option_bind (Xml.member "ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6AddressesSet" xml)
                  InstanceIpv6AddressList.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddressesSet" xml)
                  PrivateIpAddressSpecificationList.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "secondaryPrivateIpAddressCount" xml)
               Integer.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          interface_type =
            (Util.option_bind (Xml.member "InterfaceType" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.interface_type
              (fun f -> Query.Pair ("InterfaceType", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddressesSet",
                  (PrivateIpAddressSpecificationList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6AddressesSet",
                  (InstanceIpv6AddressList.to_query v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.groups)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.associate_public_ip_address
             (fun f ->
                Query.Pair ("AssociatePublicIpAddress", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.associate_public_ip_address
                          (fun f ->
                             Ezxmlm.make_tag "associatePublicIpAddress"
                               ([], (Boolean.to_xml f)))])
                      @
                      [Util.option_map v.delete_on_termination
                         (fun f ->
                            Ezxmlm.make_tag "deleteOnTermination"
                              ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.description
                        (fun f ->
                           Ezxmlm.make_tag "description"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.device_index
                       (fun f ->
                          Ezxmlm.make_tag "deviceIndex"
                            ([], (Integer.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "SecurityGroupId"
                              ([], (SecurityGroupIdStringList.to_xml [x]))))
                      v.groups))
                  @
                  [Util.option_map v.ipv6_address_count
                     (fun f ->
                        Ezxmlm.make_tag "ipv6AddressCount"
                          ([], (Integer.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "ipv6AddressesSet"
                            ([], (InstanceIpv6AddressList.to_xml [x]))))
                    v.ipv6_addresses))
                @
                [Util.option_map v.network_interface_id
                   (fun f ->
                      Ezxmlm.make_tag "networkInterfaceId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.private_ip_address
                  (fun f ->
                     Ezxmlm.make_tag "privateIpAddress"
                       ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "privateIpAddressesSet"
                         ([], (PrivateIpAddressSpecificationList.to_xml [x]))))
                 v.private_ip_addresses))
             @
             [Util.option_map v.secondary_private_ip_address_count
                (fun f ->
                   Ezxmlm.make_tag "secondaryPrivateIpAddressCount"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.subnet_id
               (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.interface_type
              (fun f ->
                 Ezxmlm.make_tag "InterfaceType" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.interface_type
              (fun f -> ("interface_type", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_addresses",
               (PrivateIpAddressSpecificationList.to_json
                  v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (InstanceIpv6AddressList.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)));
           Some ("groups", (SecurityGroupIdStringList.to_json v.groups));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.associate_public_ip_address
             (fun f -> ("associate_public_ip_address", (Boolean.to_json f)))])
    let of_json j =
      {
        associate_public_ip_address =
          (Util.option_map (Json.lookup j "associate_public_ip_address")
             Boolean.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        device_index =
          (Util.option_map (Json.lookup j "device_index") Integer.of_json);
        groups =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        ipv6_address_count =
          (Util.option_map (Json.lookup j "ipv6_address_count")
             Integer.of_json);
        ipv6_addresses =
          (InstanceIpv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_ip_addresses =
          (PrivateIpAddressSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        secondary_private_ip_address_count =
          (Util.option_map
             (Json.lookup j "secondary_private_ip_address_count")
             Integer.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        interface_type =
          (Util.option_map (Json.lookup j "interface_type") String.of_json)
      }
  end
module SpotFleetTagSpecification =
  struct
    type t = {
      resource_type: ResourceType.t option ;
      tags: TagList.t }
    let make ?resource_type  ?(tags= [])  () = { resource_type; tags }
    let parse xml =
      Some
        {
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               ResourceType.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tag" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Tag", (TagList.to_query v.tags)));
           Util.option_map v.resource_type
             (fun f -> Query.Pair ("ResourceType", (ResourceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "resourceType"
                    ([], (ResourceType.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tag" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.resource_type
             (fun f -> ("resource_type", (ResourceType.to_json f)))])
    let of_json j =
      {
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             ResourceType.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module Tenancy =
  struct
    type t =
      | Default 
      | Dedicated 
      | Host 
    let str_to_t =
      [("host", Host); ("dedicated", Dedicated); ("default", Default)]
    let t_to_str =
      [(Host, "host"); (Dedicated, "dedicated"); (Default, "default")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LaunchTemplateOverrides =
  struct
    type t =
      {
      instance_type: InstanceType.t option ;
      spot_price: String.t option ;
      subnet_id: String.t option ;
      availability_zone: String.t option ;
      weighted_capacity: Double.t option ;
      priority: Double.t option }
    let make ?instance_type  ?spot_price  ?subnet_id  ?availability_zone 
      ?weighted_capacity  ?priority  () =
      {
        instance_type;
        spot_price;
        subnet_id;
        availability_zone;
        weighted_capacity;
        priority
      }
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          weighted_capacity =
            (Util.option_bind (Xml.member "weightedCapacity" xml)
               Double.parse);
          priority =
            (Util.option_bind (Xml.member "priority" xml) Double.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.priority
              (fun f -> Query.Pair ("Priority", (Double.to_query f)));
           Util.option_map v.weighted_capacity
             (fun f -> Query.Pair ("WeightedCapacity", (Double.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.instance_type
                   (fun f ->
                      Ezxmlm.make_tag "instanceType"
                        ([], (InstanceType.to_xml f)))])
               @
               [Util.option_map v.spot_price
                  (fun f ->
                     Ezxmlm.make_tag "spotPrice" ([], (String.to_xml f)))])
              @
              [Util.option_map v.subnet_id
                 (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.availability_zone
                (fun f ->
                   Ezxmlm.make_tag "availabilityZone" ([], (String.to_xml f)))])
            @
            [Util.option_map v.weighted_capacity
               (fun f ->
                  Ezxmlm.make_tag "weightedCapacity" ([], (Double.to_xml f)))])
           @
           [Util.option_map v.priority
              (fun f -> Ezxmlm.make_tag "priority" ([], (Double.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.priority
              (fun f -> ("priority", (Double.to_json f)));
           Util.option_map v.weighted_capacity
             (fun f -> ("weighted_capacity", (Double.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)))])
    let of_json j =
      {
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        spot_price =
          (Util.option_map (Json.lookup j "spot_price") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        weighted_capacity =
          (Util.option_map (Json.lookup j "weighted_capacity") Double.of_json);
        priority =
          (Util.option_map (Json.lookup j "priority") Double.of_json)
      }
  end
module ClassicLoadBalancer =
  struct
    type t = {
      name: String.t option }
    let make ?name  () = { name }
    let parse xml =
      Some { name = (Util.option_bind (Xml.member "name" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.name
              (fun f -> Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      { name = (Util.option_map (Json.lookup j "name") String.of_json) }
  end
module TargetGroup =
  struct
    type t = {
      arn: String.t option }
    let make ?arn  () = { arn }
    let parse xml =
      Some { arn = (Util.option_bind (Xml.member "arn" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.arn
              (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.arn
              (fun f -> Ezxmlm.make_tag "arn" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      { arn = (Util.option_map (Json.lookup j "arn") String.of_json) }
  end
module EbsInstanceBlockDevice =
  struct
    type t =
      {
      attach_time: DateTime.t option ;
      delete_on_termination: Boolean.t option ;
      status: AttachmentStatus.t option ;
      volume_id: String.t option }
    let make ?attach_time  ?delete_on_termination  ?status  ?volume_id  () =
      { attach_time; delete_on_termination; status; volume_id }
    let parse xml =
      Some
        {
          attach_time =
            (Util.option_bind (Xml.member "attachTime" xml) DateTime.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AttachmentStatus.parse);
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (AttachmentStatus.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attach_time
             (fun f -> Query.Pair ("AttachTime", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.attach_time
                 (fun f ->
                    Ezxmlm.make_tag "attachTime" ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.delete_on_termination
                (fun f ->
                   Ezxmlm.make_tag "deleteOnTermination"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.status
               (fun f ->
                  Ezxmlm.make_tag "status" ([], (AttachmentStatus.to_xml f)))])
           @
           [Util.option_map v.volume_id
              (fun f -> Ezxmlm.make_tag "volumeId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> ("volume_id", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (AttachmentStatus.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attach_time
             (fun f -> ("attach_time", (DateTime.to_json f)))])
    let of_json j =
      {
        attach_time =
          (Util.option_map (Json.lookup j "attach_time") DateTime.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        status =
          (Util.option_map (Json.lookup j "status") AttachmentStatus.of_json);
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json)
      }
  end
module GroupIdentifierList =
  struct
    type t = GroupIdentifier.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map GroupIdentifier.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list GroupIdentifier.to_query v
    let to_headers v = Headers.to_headers_list GroupIdentifier.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (GroupIdentifier.to_xml x)))
        v
    let to_json v = `List (List.map GroupIdentifier.to_json v)
    let of_json j = Json.to_list GroupIdentifier.of_json j
  end
module InstanceNetworkInterfaceAttachment =
  struct
    type t =
      {
      attach_time: DateTime.t option ;
      attachment_id: String.t option ;
      delete_on_termination: Boolean.t option ;
      device_index: Integer.t option ;
      status: AttachmentStatus.t option }
    let make ?attach_time  ?attachment_id  ?delete_on_termination 
      ?device_index  ?status  () =
      {
        attach_time;
        attachment_id;
        delete_on_termination;
        device_index;
        status
      }
    let parse xml =
      Some
        {
          attach_time =
            (Util.option_bind (Xml.member "attachTime" xml) DateTime.parse);
          attachment_id =
            (Util.option_bind (Xml.member "attachmentId" xml) String.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          device_index =
            (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AttachmentStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (AttachmentStatus.to_query f)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attachment_id
             (fun f -> Query.Pair ("AttachmentId", (String.to_query f)));
           Util.option_map v.attach_time
             (fun f -> Query.Pair ("AttachTime", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.attach_time
                  (fun f ->
                     Ezxmlm.make_tag "attachTime" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.attachment_id
                 (fun f ->
                    Ezxmlm.make_tag "attachmentId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.delete_on_termination
                (fun f ->
                   Ezxmlm.make_tag "deleteOnTermination"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.device_index
               (fun f ->
                  Ezxmlm.make_tag "deviceIndex" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status" ([], (AttachmentStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (AttachmentStatus.to_json f)));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attachment_id
             (fun f -> ("attachment_id", (String.to_json f)));
           Util.option_map v.attach_time
             (fun f -> ("attach_time", (DateTime.to_json f)))])
    let of_json j =
      {
        attach_time =
          (Util.option_map (Json.lookup j "attach_time") DateTime.of_json);
        attachment_id =
          (Util.option_map (Json.lookup j "attachment_id") String.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        device_index =
          (Util.option_map (Json.lookup j "device_index") Integer.of_json);
        status =
          (Util.option_map (Json.lookup j "status") AttachmentStatus.of_json)
      }
  end
module InstancePrivateIpAddressList =
  struct
    type t = InstancePrivateIpAddress.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstancePrivateIpAddress.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstancePrivateIpAddress.to_query v
    let to_headers v =
      Headers.to_headers_list InstancePrivateIpAddress.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstancePrivateIpAddress.to_xml x)))
        v
    let to_json v = `List (List.map InstancePrivateIpAddress.to_json v)
    let of_json j = Json.to_list InstancePrivateIpAddress.of_json j
  end
module NetworkInterfaceStatus =
  struct
    type t =
      | Available 
      | Associated 
      | Attaching 
      | In_use 
      | Detaching 
    let str_to_t =
      [("detaching", Detaching);
      ("in-use", In_use);
      ("attaching", Attaching);
      ("associated", Associated);
      ("available", Available)]
    let t_to_str =
      [(Detaching, "detaching");
      (In_use, "in-use");
      (Attaching, "attaching");
      (Associated, "associated");
      (Available, "available")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ProductCodeValues =
  struct
    type t =
      | Devpay 
      | Marketplace 
    let str_to_t = [("marketplace", Marketplace); ("devpay", Devpay)]
    let t_to_str = [(Marketplace, "marketplace"); (Devpay, "devpay")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AttributeValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Scope =
  struct
    type t =
      | Availability_Zone 
      | Region 
    let str_to_t =
      [("Region", Region); ("Availability Zone", Availability_Zone)]
    let t_to_str =
      [(Region, "Region"); (Availability_Zone, "Availability Zone")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module StatusName =
  struct
    type t =
      | Reachability 
    let str_to_t = [("reachability", Reachability)]
    let t_to_str = [(Reachability, "reachability")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module StatusType =
  struct
    type t =
      | Passed 
      | Failed 
      | Insufficient_data 
      | Initializing 
    let str_to_t =
      [("initializing", Initializing);
      ("insufficient-data", Insufficient_data);
      ("failed", Failed);
      ("passed", Passed)]
    let t_to_str =
      [(Initializing, "initializing");
      (Insufficient_data, "insufficient-data");
      (Failed, "failed");
      (Passed, "passed")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module UserIdGroupPair =
  struct
    type t =
      {
      description: String.t option ;
      group_id: String.t option ;
      group_name: String.t option ;
      peering_status: String.t option ;
      user_id: String.t option ;
      vpc_id: String.t option ;
      vpc_peering_connection_id: String.t option }
    let make ?description  ?group_id  ?group_name  ?peering_status  ?user_id 
      ?vpc_id  ?vpc_peering_connection_id  () =
      {
        description;
        group_id;
        group_name;
        peering_status;
        user_id;
        vpc_id;
        vpc_peering_connection_id
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          peering_status =
            (Util.option_bind (Xml.member "peeringStatus" xml) String.parse);
          user_id = (Util.option_bind (Xml.member "userId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.user_id
             (fun f -> Query.Pair ("UserId", (String.to_query f)));
           Util.option_map v.peering_status
             (fun f -> Query.Pair ("PeeringStatus", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.description
                    (fun f ->
                       Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
                @
                [Util.option_map v.group_id
                   (fun f ->
                      Ezxmlm.make_tag "groupId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.group_name
                  (fun f ->
                     Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.peering_status
                 (fun f ->
                    Ezxmlm.make_tag "peeringStatus" ([], (String.to_xml f)))])
             @
             [Util.option_map v.user_id
                (fun f -> Ezxmlm.make_tag "userId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.vpc_id
               (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Ezxmlm.make_tag "vpcPeeringConnectionId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.user_id
             (fun f -> ("user_id", (String.to_json f)));
           Util.option_map v.peering_status
             (fun f -> ("peering_status", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        peering_status =
          (Util.option_map (Json.lookup j "peering_status") String.of_json);
        user_id = (Util.option_map (Json.lookup j "user_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module FpgaDeviceMemoryInfo =
  struct
    type t = {
      size_in_mi_b: Integer.t option }
    let make ?size_in_mi_b  () = { size_in_mi_b }
    let parse xml =
      Some
        {
          size_in_mi_b =
            (Util.option_bind (Xml.member "sizeInMiB" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> Query.Pair ("SizeInMiB", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.size_in_mi_b
              (fun f -> Ezxmlm.make_tag "sizeInMiB" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> ("size_in_mi_b", (Integer.to_json f)))])
    let of_json j =
      {
        size_in_mi_b =
          (Util.option_map (Json.lookup j "size_in_mi_b") Integer.of_json)
      }
  end
module GpuDeviceMemoryInfo =
  struct
    type t = {
      size_in_mi_b: Integer.t option }
    let make ?size_in_mi_b  () = { size_in_mi_b }
    let parse xml =
      Some
        {
          size_in_mi_b =
            (Util.option_bind (Xml.member "sizeInMiB" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> Query.Pair ("SizeInMiB", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.size_in_mi_b
              (fun f -> Ezxmlm.make_tag "sizeInMiB" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> ("size_in_mi_b", (Integer.to_json f)))])
    let of_json j =
      {
        size_in_mi_b =
          (Util.option_map (Json.lookup j "size_in_mi_b") Integer.of_json)
      }
  end
module DiskType =
  struct
    type t =
      | Hdd 
      | Ssd 
    let str_to_t = [("ssd", Ssd); ("hdd", Hdd)]
    let t_to_str = [(Ssd, "ssd"); (Hdd, "hdd")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module IKEVersionsList =
  struct
    type t = IKEVersionsListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map IKEVersionsListValue.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list IKEVersionsListValue.to_query v
    let to_headers v =
      Headers.to_headers_list IKEVersionsListValue.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (IKEVersionsListValue.to_xml x))) v
    let to_json v = `List (List.map IKEVersionsListValue.to_json v)
    let of_json j = Json.to_list IKEVersionsListValue.of_json j
  end
module Phase1DHGroupNumbersList =
  struct
    type t = Phase1DHGroupNumbersListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase1DHGroupNumbersListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase1DHGroupNumbersListValue.to_query v
    let to_headers v =
      Headers.to_headers_list Phase1DHGroupNumbersListValue.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase1DHGroupNumbersListValue.to_xml x))) v
    let to_json v = `List (List.map Phase1DHGroupNumbersListValue.to_json v)
    let of_json j = Json.to_list Phase1DHGroupNumbersListValue.of_json j
  end
module Phase1EncryptionAlgorithmsList =
  struct
    type t = Phase1EncryptionAlgorithmsListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase1EncryptionAlgorithmsListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase1EncryptionAlgorithmsListValue.to_query v
    let to_headers v =
      Headers.to_headers_list Phase1EncryptionAlgorithmsListValue.to_headers
        v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase1EncryptionAlgorithmsListValue.to_xml x))) v
    let to_json v =
      `List (List.map Phase1EncryptionAlgorithmsListValue.to_json v)
    let of_json j =
      Json.to_list Phase1EncryptionAlgorithmsListValue.of_json j
  end
module Phase1IntegrityAlgorithmsList =
  struct
    type t = Phase1IntegrityAlgorithmsListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase1IntegrityAlgorithmsListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase1IntegrityAlgorithmsListValue.to_query v
    let to_headers v =
      Headers.to_headers_list Phase1IntegrityAlgorithmsListValue.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase1IntegrityAlgorithmsListValue.to_xml x))) v
    let to_json v =
      `List (List.map Phase1IntegrityAlgorithmsListValue.to_json v)
    let of_json j = Json.to_list Phase1IntegrityAlgorithmsListValue.of_json j
  end
module Phase2DHGroupNumbersList =
  struct
    type t = Phase2DHGroupNumbersListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase2DHGroupNumbersListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase2DHGroupNumbersListValue.to_query v
    let to_headers v =
      Headers.to_headers_list Phase2DHGroupNumbersListValue.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase2DHGroupNumbersListValue.to_xml x))) v
    let to_json v = `List (List.map Phase2DHGroupNumbersListValue.to_json v)
    let of_json j = Json.to_list Phase2DHGroupNumbersListValue.of_json j
  end
module Phase2EncryptionAlgorithmsList =
  struct
    type t = Phase2EncryptionAlgorithmsListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase2EncryptionAlgorithmsListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase2EncryptionAlgorithmsListValue.to_query v
    let to_headers v =
      Headers.to_headers_list Phase2EncryptionAlgorithmsListValue.to_headers
        v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase2EncryptionAlgorithmsListValue.to_xml x))) v
    let to_json v =
      `List (List.map Phase2EncryptionAlgorithmsListValue.to_json v)
    let of_json j =
      Json.to_list Phase2EncryptionAlgorithmsListValue.of_json j
  end
module Phase2IntegrityAlgorithmsList =
  struct
    type t = Phase2IntegrityAlgorithmsListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase2IntegrityAlgorithmsListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase2IntegrityAlgorithmsListValue.to_query v
    let to_headers v =
      Headers.to_headers_list Phase2IntegrityAlgorithmsListValue.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase2IntegrityAlgorithmsListValue.to_xml x))) v
    let to_json v =
      `List (List.map Phase2IntegrityAlgorithmsListValue.to_json v)
    let of_json j = Json.to_list Phase2IntegrityAlgorithmsListValue.of_json j
  end
module DiskImageDescription =
  struct
    type t =
      {
      checksum: String.t option ;
      format: DiskImageFormat.t option ;
      import_manifest_url: String.t option ;
      size: Long.t option }
    let make ?checksum  ?format  ?import_manifest_url  ?size  () =
      { checksum; format; import_manifest_url; size }
    let parse xml =
      Some
        {
          checksum =
            (Util.option_bind (Xml.member "checksum" xml) String.parse);
          format =
            (Util.option_bind (Xml.member "format" xml) DiskImageFormat.parse);
          import_manifest_url =
            (Util.option_bind (Xml.member "importManifestUrl" xml)
               String.parse);
          size = (Util.option_bind (Xml.member "size" xml) Long.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.size
              (fun f -> Query.Pair ("Size", (Long.to_query f)));
           Util.option_map v.import_manifest_url
             (fun f -> Query.Pair ("ImportManifestUrl", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (DiskImageFormat.to_query f)));
           Util.option_map v.checksum
             (fun f -> Query.Pair ("Checksum", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.checksum
                 (fun f -> Ezxmlm.make_tag "checksum" ([], (String.to_xml f)))])
             @
             [Util.option_map v.format
                (fun f ->
                   Ezxmlm.make_tag "format" ([], (DiskImageFormat.to_xml f)))])
            @
            [Util.option_map v.import_manifest_url
               (fun f ->
                  Ezxmlm.make_tag "importManifestUrl" ([], (String.to_xml f)))])
           @
           [Util.option_map v.size
              (fun f -> Ezxmlm.make_tag "size" ([], (Long.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.size (fun f -> ("size", (Long.to_json f)));
           Util.option_map v.import_manifest_url
             (fun f -> ("import_manifest_url", (String.to_json f)));
           Util.option_map v.format
             (fun f -> ("format", (DiskImageFormat.to_json f)));
           Util.option_map v.checksum
             (fun f -> ("checksum", (String.to_json f)))])
    let of_json j =
      {
        checksum =
          (Util.option_map (Json.lookup j "checksum") String.of_json);
        format =
          (Util.option_map (Json.lookup j "format") DiskImageFormat.of_json);
        import_manifest_url =
          (Util.option_map (Json.lookup j "import_manifest_url")
             String.of_json);
        size = (Util.option_map (Json.lookup j "size") Long.of_json)
      }
  end
module DiskImageVolumeDescription =
  struct
    type t = {
      id: String.t option ;
      size: Long.t option }
    let make ?id  ?size  () = { id; size }
    let parse xml =
      Some
        {
          id = (Util.option_bind (Xml.member "id" xml) String.parse);
          size = (Util.option_bind (Xml.member "size" xml) Long.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.size
              (fun f -> Query.Pair ("Size", (Long.to_query f)));
           Util.option_map v.id
             (fun f -> Query.Pair ("Id", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.id
               (fun f -> Ezxmlm.make_tag "id" ([], (String.to_xml f)))])
           @
           [Util.option_map v.size
              (fun f -> Ezxmlm.make_tag "size" ([], (Long.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.size (fun f -> ("size", (Long.to_json f)));
           Util.option_map v.id (fun f -> ("id", (String.to_json f)))])
    let of_json j =
      {
        id = (Util.option_map (Json.lookup j "id") String.of_json);
        size = (Util.option_map (Json.lookup j "size") Long.of_json)
      }
  end
module RouteTableAssociationStateCode =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Failed, "failed");
      (Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LaunchTemplateEbsBlockDevice =
  struct
    type t =
      {
      encrypted: Boolean.t option ;
      delete_on_termination: Boolean.t option ;
      iops: Integer.t option ;
      kms_key_id: String.t option ;
      snapshot_id: String.t option ;
      volume_size: Integer.t option ;
      volume_type: VolumeType.t option }
    let make ?encrypted  ?delete_on_termination  ?iops  ?kms_key_id 
      ?snapshot_id  ?volume_size  ?volume_type  () =
      {
        encrypted;
        delete_on_termination;
        iops;
        kms_key_id;
        snapshot_id;
        volume_size;
        volume_type
      }
    let parse xml =
      Some
        {
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          iops = (Util.option_bind (Xml.member "iops" xml) Integer.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          volume_size =
            (Util.option_bind (Xml.member "volumeSize" xml) Integer.parse);
          volume_type =
            (Util.option_bind (Xml.member "volumeType" xml) VolumeType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> Query.Pair ("VolumeType", (VolumeType.to_query f)));
           Util.option_map v.volume_size
             (fun f -> Query.Pair ("VolumeSize", (Integer.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.encrypted
                    (fun f ->
                       Ezxmlm.make_tag "encrypted" ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.delete_on_termination
                   (fun f ->
                      Ezxmlm.make_tag "deleteOnTermination"
                        ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.iops
                  (fun f -> Ezxmlm.make_tag "iops" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.kms_key_id
                 (fun f -> Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.snapshot_id
                (fun f ->
                   Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.volume_size
               (fun f ->
                  Ezxmlm.make_tag "volumeSize" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.volume_type
              (fun f ->
                 Ezxmlm.make_tag "volumeType" ([], (VolumeType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> ("volume_type", (VolumeType.to_json f)));
           Util.option_map v.volume_size
             (fun f -> ("volume_size", (Integer.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)))])
    let of_json j =
      {
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        volume_size =
          (Util.option_map (Json.lookup j "volume_size") Integer.of_json);
        volume_type =
          (Util.option_map (Json.lookup j "volume_type") VolumeType.of_json)
      }
  end
module InstanceInterruptionBehavior =
  struct
    type t =
      | Hibernate 
      | Stop 
      | Terminate 
    let str_to_t =
      [("terminate", Terminate); ("stop", Stop); ("hibernate", Hibernate)]
    let t_to_str =
      [(Terminate, "terminate"); (Stop, "stop"); (Hibernate, "hibernate")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SpotInstanceType =
  struct
    type t =
      | One_time 
      | Persistent 
    let str_to_t = [("persistent", Persistent); ("one-time", One_time)]
    let t_to_str = [(Persistent, "persistent"); (One_time, "one-time")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module GroupIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "groupId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module IpRange =
  struct
    type t = {
      cidr_ip: String.t ;
      description: String.t option }
    let make ~cidr_ip  ?description  () = { cidr_ip; description }
    let parse xml =
      Some
        {
          cidr_ip =
            (Xml.required "cidrIp"
               (Util.option_bind (Xml.member "cidrIp" xml) String.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some (Query.Pair ("CidrIp", (String.to_query v.cidr_ip)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some (Ezxmlm.make_tag "cidrIp" ([], (String.to_xml v.cidr_ip)))])
           @
           [Util.option_map v.description
              (fun f -> Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Some ("cidr_ip", (String.to_json v.cidr_ip))])
    let of_json j =
      {
        cidr_ip =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_ip")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module Ipv6Range =
  struct
    type t = {
      cidr_ipv6: String.t option ;
      description: String.t option }
    let make ?cidr_ipv6  ?description  () = { cidr_ipv6; description }
    let parse xml =
      Some
        {
          cidr_ipv6 =
            (Util.option_bind (Xml.member "cidrIpv6" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.cidr_ipv6
             (fun f -> Query.Pair ("CidrIpv6", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.cidr_ipv6
               (fun f -> Ezxmlm.make_tag "cidrIpv6" ([], (String.to_xml f)))])
           @
           [Util.option_map v.description
              (fun f -> Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.cidr_ipv6
             (fun f -> ("cidr_ipv6", (String.to_json f)))])
    let of_json j =
      {
        cidr_ipv6 =
          (Util.option_map (Json.lookup j "cidr_ipv6") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module PrefixListId =
  struct
    type t = {
      description: String.t option ;
      prefix_list_id: String.t option }
    let make ?description  ?prefix_list_id  () =
      { description; prefix_list_id }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          prefix_list_id =
            (Util.option_bind (Xml.member "prefixListId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.prefix_list_id
              (fun f -> Query.Pair ("PrefixListId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.description
               (fun f ->
                  Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
           @
           [Util.option_map v.prefix_list_id
              (fun f ->
                 Ezxmlm.make_tag "prefixListId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.prefix_list_id
              (fun f -> ("prefix_list_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        prefix_list_id =
          (Util.option_map (Json.lookup j "prefix_list_id") String.of_json)
      }
  end
module FleetLaunchTemplateOverrides =
  struct
    type t =
      {
      instance_type: InstanceType.t option ;
      max_price: String.t option ;
      subnet_id: String.t option ;
      availability_zone: String.t option ;
      weighted_capacity: Double.t option ;
      priority: Double.t option ;
      placement: PlacementResponse.t option }
    let make ?instance_type  ?max_price  ?subnet_id  ?availability_zone 
      ?weighted_capacity  ?priority  ?placement  () =
      {
        instance_type;
        max_price;
        subnet_id;
        availability_zone;
        weighted_capacity;
        priority;
        placement
      }
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          max_price =
            (Util.option_bind (Xml.member "maxPrice" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          weighted_capacity =
            (Util.option_bind (Xml.member "weightedCapacity" xml)
               Double.parse);
          priority =
            (Util.option_bind (Xml.member "priority" xml) Double.parse);
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               PlacementResponse.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.placement
              (fun f ->
                 Query.Pair ("Placement", (PlacementResponse.to_query f)));
           Util.option_map v.priority
             (fun f -> Query.Pair ("Priority", (Double.to_query f)));
           Util.option_map v.weighted_capacity
             (fun f -> Query.Pair ("WeightedCapacity", (Double.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.max_price
             (fun f -> Query.Pair ("MaxPrice", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.instance_type
                    (fun f ->
                       Ezxmlm.make_tag "instanceType"
                         ([], (InstanceType.to_xml f)))])
                @
                [Util.option_map v.max_price
                   (fun f ->
                      Ezxmlm.make_tag "maxPrice" ([], (String.to_xml f)))])
               @
               [Util.option_map v.subnet_id
                  (fun f ->
                     Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.availability_zone
                 (fun f ->
                    Ezxmlm.make_tag "availabilityZone"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.weighted_capacity
                (fun f ->
                   Ezxmlm.make_tag "weightedCapacity" ([], (Double.to_xml f)))])
            @
            [Util.option_map v.priority
               (fun f -> Ezxmlm.make_tag "priority" ([], (Double.to_xml f)))])
           @
           [Util.option_map v.placement
              (fun f ->
                 Ezxmlm.make_tag "placement"
                   ([], (PlacementResponse.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.placement
              (fun f -> ("placement", (PlacementResponse.to_json f)));
           Util.option_map v.priority
             (fun f -> ("priority", (Double.to_json f)));
           Util.option_map v.weighted_capacity
             (fun f -> ("weighted_capacity", (Double.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.max_price
             (fun f -> ("max_price", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)))])
    let of_json j =
      {
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        max_price =
          (Util.option_map (Json.lookup j "max_price") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        weighted_capacity =
          (Util.option_map (Json.lookup j "weighted_capacity") Double.of_json);
        priority =
          (Util.option_map (Json.lookup j "priority") Double.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement")
             PlacementResponse.of_json)
      }
  end
module FleetLaunchTemplateSpecification =
  struct
    type t =
      {
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      version: String.t option }
    let make ?launch_template_id  ?launch_template_name  ?version  () =
      { launch_template_id; launch_template_name; version }
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "launchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "launchTemplateName" xml)
               String.parse);
          version =
            (Util.option_bind (Xml.member "version" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> Query.Pair ("Version", (String.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.launch_template_id
                (fun f ->
                   Ezxmlm.make_tag "launchTemplateId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.launch_template_name
               (fun f ->
                  Ezxmlm.make_tag "launchTemplateName"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.version
              (fun f -> Ezxmlm.make_tag "version" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> ("version", (String.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let of_json j =
      {
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        version = (Util.option_map (Json.lookup j "version") String.of_json)
      }
  end
module BlockDeviceMappingList =
  struct
    type t = BlockDeviceMapping.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map BlockDeviceMapping.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list BlockDeviceMapping.to_query v
    let to_headers v =
      Headers.to_headers_list BlockDeviceMapping.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (BlockDeviceMapping.to_xml x))) v
    let to_json v = `List (List.map BlockDeviceMapping.to_json v)
    let of_json j = Json.to_list BlockDeviceMapping.of_json j
  end
module IamInstanceProfileSpecification =
  struct
    type t = {
      arn: String.t option ;
      name: String.t option }
    let make ?arn  ?name  () = { arn; name }
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "arn" xml) String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.arn
               (fun f -> Ezxmlm.make_tag "arn" ([], (String.to_xml f)))])
           @
           [Util.option_map v.name
              (fun f -> Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      {
        arn = (Util.option_map (Json.lookup j "arn") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json)
      }
  end
module InstanceNetworkInterfaceSpecificationList =
  struct
    type t = InstanceNetworkInterfaceSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceNetworkInterfaceSpecification.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list InstanceNetworkInterfaceSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list
        InstanceNetworkInterfaceSpecification.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InstanceNetworkInterfaceSpecification.to_xml x))) v
    let to_json v =
      `List (List.map InstanceNetworkInterfaceSpecification.to_json v)
    let of_json j =
      Json.to_list InstanceNetworkInterfaceSpecification.of_json j
  end
module SpotFleetMonitoring =
  struct
    type t = {
      enabled: Boolean.t option }
    let make ?enabled  () = { enabled }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "enabled" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.enabled
              (fun f -> Ezxmlm.make_tag "enabled" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      { enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json)
      }
  end
module SpotFleetTagSpecificationList =
  struct
    type t = SpotFleetTagSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SpotFleetTagSpecification.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SpotFleetTagSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list SpotFleetTagSpecification.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (SpotFleetTagSpecification.to_xml x))) v
    let to_json v = `List (List.map SpotFleetTagSpecification.to_json v)
    let of_json j = Json.to_list SpotFleetTagSpecification.of_json j
  end
module SpotPlacement =
  struct
    type t =
      {
      availability_zone: String.t option ;
      group_name: String.t option ;
      tenancy: Tenancy.t option }
    let make ?availability_zone  ?group_name  ?tenancy  () =
      { availability_zone; group_name; tenancy }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          tenancy =
            (Util.option_bind (Xml.member "tenancy" xml) Tenancy.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.tenancy
              (fun f -> Query.Pair ("Tenancy", (Tenancy.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.availability_zone
                (fun f ->
                   Ezxmlm.make_tag "availabilityZone" ([], (String.to_xml f)))])
            @
            [Util.option_map v.group_name
               (fun f -> Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.tenancy
              (fun f -> Ezxmlm.make_tag "tenancy" ([], (Tenancy.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.tenancy
              (fun f -> ("tenancy", (Tenancy.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        tenancy = (Util.option_map (Json.lookup j "tenancy") Tenancy.of_json)
      }
  end
module LaunchTemplateOverridesList =
  struct
    type t = LaunchTemplateOverrides.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateOverrides.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LaunchTemplateOverrides.to_query v
    let to_headers v =
      Headers.to_headers_list LaunchTemplateOverrides.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (LaunchTemplateOverrides.to_xml x)))
        v
    let to_json v = `List (List.map LaunchTemplateOverrides.to_json v)
    let of_json j = Json.to_list LaunchTemplateOverrides.of_json j
  end
module ClassicLoadBalancers =
  struct
    type t = ClassicLoadBalancer.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClassicLoadBalancer.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ClassicLoadBalancer.to_query v
    let to_headers v =
      Headers.to_headers_list ClassicLoadBalancer.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ClassicLoadBalancer.to_xml x))) v
    let to_json v = `List (List.map ClassicLoadBalancer.to_json v)
    let of_json j = Json.to_list ClassicLoadBalancer.of_json j
  end
module TargetGroups =
  struct
    type t = TargetGroup.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map TargetGroup.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TargetGroup.to_query v
    let to_headers v = Headers.to_headers_list TargetGroup.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (TargetGroup.to_xml x))) v
    let to_json v = `List (List.map TargetGroup.to_json v)
    let of_json j = Json.to_list TargetGroup.of_json j
  end
module VolumeStatusName =
  struct
    type t =
      | Io_enabled 
      | Io_performance 
    let str_to_t =
      [("io-performance", Io_performance); ("io-enabled", Io_enabled)]
    let t_to_str =
      [(Io_performance, "io-performance"); (Io_enabled, "io-enabled")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CapacityReservationPreference =
  struct
    type t =
      | Open 
      | None 
    let str_to_t = [("none", None); ("open", Open)]
    let t_to_str = [(None, "none"); (Open, "open")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CapacityReservationTargetResponse =
  struct
    type t = {
      capacity_reservation_id: String.t option }
    let make ?capacity_reservation_id  () = { capacity_reservation_id }
    let parse xml =
      Some
        {
          capacity_reservation_id =
            (Util.option_bind (Xml.member "capacityReservationId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_id
              (fun f ->
                 Query.Pair ("CapacityReservationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.capacity_reservation_id
              (fun f ->
                 Ezxmlm.make_tag "capacityReservationId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_id
              (fun f -> ("capacity_reservation_id", (String.to_json f)))])
    let of_json j =
      {
        capacity_reservation_id =
          (Util.option_map (Json.lookup j "capacity_reservation_id")
             String.of_json)
      }
  end
module ElasticGpuAssociation =
  struct
    type t =
      {
      elastic_gpu_id: String.t option ;
      elastic_gpu_association_id: String.t option ;
      elastic_gpu_association_state: String.t option ;
      elastic_gpu_association_time: String.t option }
    let make ?elastic_gpu_id  ?elastic_gpu_association_id 
      ?elastic_gpu_association_state  ?elastic_gpu_association_time  () =
      {
        elastic_gpu_id;
        elastic_gpu_association_id;
        elastic_gpu_association_state;
        elastic_gpu_association_time
      }
    let parse xml =
      Some
        {
          elastic_gpu_id =
            (Util.option_bind (Xml.member "elasticGpuId" xml) String.parse);
          elastic_gpu_association_id =
            (Util.option_bind (Xml.member "elasticGpuAssociationId" xml)
               String.parse);
          elastic_gpu_association_state =
            (Util.option_bind (Xml.member "elasticGpuAssociationState" xml)
               String.parse);
          elastic_gpu_association_time =
            (Util.option_bind (Xml.member "elasticGpuAssociationTime" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.elastic_gpu_association_time
              (fun f ->
                 Query.Pair
                   ("ElasticGpuAssociationTime", (String.to_query f)));
           Util.option_map v.elastic_gpu_association_state
             (fun f ->
                Query.Pair
                  ("ElasticGpuAssociationState", (String.to_query f)));
           Util.option_map v.elastic_gpu_association_id
             (fun f ->
                Query.Pair ("ElasticGpuAssociationId", (String.to_query f)));
           Util.option_map v.elastic_gpu_id
             (fun f -> Query.Pair ("ElasticGpuId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.elastic_gpu_id
                 (fun f ->
                    Ezxmlm.make_tag "elasticGpuId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.elastic_gpu_association_id
                (fun f ->
                   Ezxmlm.make_tag "elasticGpuAssociationId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.elastic_gpu_association_state
               (fun f ->
                  Ezxmlm.make_tag "elasticGpuAssociationState"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.elastic_gpu_association_time
              (fun f ->
                 Ezxmlm.make_tag "elasticGpuAssociationTime"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.elastic_gpu_association_time
              (fun f -> ("elastic_gpu_association_time", (String.to_json f)));
           Util.option_map v.elastic_gpu_association_state
             (fun f -> ("elastic_gpu_association_state", (String.to_json f)));
           Util.option_map v.elastic_gpu_association_id
             (fun f -> ("elastic_gpu_association_id", (String.to_json f)));
           Util.option_map v.elastic_gpu_id
             (fun f -> ("elastic_gpu_id", (String.to_json f)))])
    let of_json j =
      {
        elastic_gpu_id =
          (Util.option_map (Json.lookup j "elastic_gpu_id") String.of_json);
        elastic_gpu_association_id =
          (Util.option_map (Json.lookup j "elastic_gpu_association_id")
             String.of_json);
        elastic_gpu_association_state =
          (Util.option_map (Json.lookup j "elastic_gpu_association_state")
             String.of_json);
        elastic_gpu_association_time =
          (Util.option_map (Json.lookup j "elastic_gpu_association_time")
             String.of_json)
      }
  end
module ElasticInferenceAcceleratorAssociation =
  struct
    type t =
      {
      elastic_inference_accelerator_arn: String.t option ;
      elastic_inference_accelerator_association_id: String.t option ;
      elastic_inference_accelerator_association_state: String.t option ;
      elastic_inference_accelerator_association_time: DateTime.t option }
    let make ?elastic_inference_accelerator_arn 
      ?elastic_inference_accelerator_association_id 
      ?elastic_inference_accelerator_association_state 
      ?elastic_inference_accelerator_association_time  () =
      {
        elastic_inference_accelerator_arn;
        elastic_inference_accelerator_association_id;
        elastic_inference_accelerator_association_state;
        elastic_inference_accelerator_association_time
      }
    let parse xml =
      Some
        {
          elastic_inference_accelerator_arn =
            (Util.option_bind
               (Xml.member "elasticInferenceAcceleratorArn" xml) String.parse);
          elastic_inference_accelerator_association_id =
            (Util.option_bind
               (Xml.member "elasticInferenceAcceleratorAssociationId" xml)
               String.parse);
          elastic_inference_accelerator_association_state =
            (Util.option_bind
               (Xml.member "elasticInferenceAcceleratorAssociationState" xml)
               String.parse);
          elastic_inference_accelerator_association_time =
            (Util.option_bind
               (Xml.member "elasticInferenceAcceleratorAssociationTime" xml)
               DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.elastic_inference_accelerator_association_time
              (fun f ->
                 Query.Pair
                   ("ElasticInferenceAcceleratorAssociationTime",
                     (DateTime.to_query f)));
           Util.option_map v.elastic_inference_accelerator_association_state
             (fun f ->
                Query.Pair
                  ("ElasticInferenceAcceleratorAssociationState",
                    (String.to_query f)));
           Util.option_map v.elastic_inference_accelerator_association_id
             (fun f ->
                Query.Pair
                  ("ElasticInferenceAcceleratorAssociationId",
                    (String.to_query f)));
           Util.option_map v.elastic_inference_accelerator_arn
             (fun f ->
                Query.Pair
                  ("ElasticInferenceAcceleratorArn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.elastic_inference_accelerator_arn
                 (fun f ->
                    Ezxmlm.make_tag "elasticInferenceAcceleratorArn"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.elastic_inference_accelerator_association_id
                (fun f ->
                   Ezxmlm.make_tag "elasticInferenceAcceleratorAssociationId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map
               v.elastic_inference_accelerator_association_state
               (fun f ->
                  Ezxmlm.make_tag
                    "elasticInferenceAcceleratorAssociationState"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.elastic_inference_accelerator_association_time
              (fun f ->
                 Ezxmlm.make_tag "elasticInferenceAcceleratorAssociationTime"
                   ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.elastic_inference_accelerator_association_time
              (fun f ->
                 ("elastic_inference_accelerator_association_time",
                   (DateTime.to_json f)));
           Util.option_map v.elastic_inference_accelerator_association_state
             (fun f ->
                ("elastic_inference_accelerator_association_state",
                  (String.to_json f)));
           Util.option_map v.elastic_inference_accelerator_association_id
             (fun f ->
                ("elastic_inference_accelerator_association_id",
                  (String.to_json f)));
           Util.option_map v.elastic_inference_accelerator_arn
             (fun f ->
                ("elastic_inference_accelerator_arn", (String.to_json f)))])
    let of_json j =
      {
        elastic_inference_accelerator_arn =
          (Util.option_map
             (Json.lookup j "elastic_inference_accelerator_arn")
             String.of_json);
        elastic_inference_accelerator_association_id =
          (Util.option_map
             (Json.lookup j "elastic_inference_accelerator_association_id")
             String.of_json);
        elastic_inference_accelerator_association_state =
          (Util.option_map
             (Json.lookup j "elastic_inference_accelerator_association_state")
             String.of_json);
        elastic_inference_accelerator_association_time =
          (Util.option_map
             (Json.lookup j "elastic_inference_accelerator_association_time")
             DateTime.of_json)
      }
  end
module InstanceBlockDeviceMapping =
  struct
    type t =
      {
      device_name: String.t option ;
      ebs: EbsInstanceBlockDevice.t option }
    let make ?device_name  ?ebs  () = { device_name; ebs }
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "ebs" xml)
               EbsInstanceBlockDevice.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ebs
              (fun f ->
                 Query.Pair ("Ebs", (EbsInstanceBlockDevice.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.device_name
               (fun f -> Ezxmlm.make_tag "deviceName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.ebs
              (fun f ->
                 Ezxmlm.make_tag "ebs"
                   ([], (EbsInstanceBlockDevice.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ebs
              (fun f -> ("ebs", (EbsInstanceBlockDevice.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let of_json j =
      {
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        ebs =
          (Util.option_map (Json.lookup j "ebs")
             EbsInstanceBlockDevice.of_json)
      }
  end
module HttpTokensState =
  struct
    type t =
      | Optional 
      | Required 
    let str_to_t = [("required", Required); ("optional", Optional)]
    let t_to_str = [(Required, "required"); (Optional, "optional")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceMetadataEndpointState =
  struct
    type t =
      | Disabled 
      | Enabled 
    let str_to_t = [("enabled", Enabled); ("disabled", Disabled)]
    let t_to_str = [(Enabled, "enabled"); (Disabled, "disabled")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceMetadataOptionsState =
  struct
    type t =
      | Pending 
      | Applied 
    let str_to_t = [("applied", Applied); ("pending", Pending)]
    let t_to_str = [(Applied, "applied"); (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceNetworkInterface =
  struct
    type t =
      {
      association: InstanceNetworkInterfaceAssociation.t option ;
      attachment: InstanceNetworkInterfaceAttachment.t option ;
      description: String.t option ;
      groups: GroupIdentifierList.t ;
      ipv6_addresses: InstanceIpv6AddressList.t ;
      mac_address: String.t option ;
      network_interface_id: String.t option ;
      owner_id: String.t option ;
      private_dns_name: String.t option ;
      private_ip_address: String.t option ;
      private_ip_addresses: InstancePrivateIpAddressList.t ;
      source_dest_check: Boolean.t option ;
      status: NetworkInterfaceStatus.t option ;
      subnet_id: String.t option ;
      vpc_id: String.t option ;
      interface_type: String.t option }
    let make ?association  ?attachment  ?description  ?(groups= []) 
      ?(ipv6_addresses= [])  ?mac_address  ?network_interface_id  ?owner_id 
      ?private_dns_name  ?private_ip_address  ?(private_ip_addresses= []) 
      ?source_dest_check  ?status  ?subnet_id  ?vpc_id  ?interface_type  () =
      {
        association;
        attachment;
        description;
        groups;
        ipv6_addresses;
        mac_address;
        network_interface_id;
        owner_id;
        private_dns_name;
        private_ip_address;
        private_ip_addresses;
        source_dest_check;
        status;
        subnet_id;
        vpc_id;
        interface_type
      }
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               InstanceNetworkInterfaceAssociation.parse);
          attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               InstanceNetworkInterfaceAttachment.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6AddressesSet" xml)
                  InstanceIpv6AddressList.parse));
          mac_address =
            (Util.option_bind (Xml.member "macAddress" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddressesSet" xml)
                  InstancePrivateIpAddressList.parse));
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               Boolean.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               NetworkInterfaceStatus.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          interface_type =
            (Util.option_bind (Xml.member "interfaceType" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.interface_type
              (fun f -> Query.Pair ("InterfaceType", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (NetworkInterfaceStatus.to_query f)));
           Util.option_map v.source_dest_check
             (fun f -> Query.Pair ("SourceDestCheck", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddressesSet",
                  (InstancePrivateIpAddressList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.mac_address
             (fun f -> Query.Pair ("MacAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6AddressesSet",
                  (InstanceIpv6AddressList.to_query v.ipv6_addresses)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.attachment
             (fun f ->
                Query.Pair
                  ("Attachment",
                    (InstanceNetworkInterfaceAttachment.to_query f)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association",
                    (InstanceNetworkInterfaceAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((([] @
                          [Util.option_map v.association
                             (fun f ->
                                Ezxmlm.make_tag "association"
                                  ([],
                                    (InstanceNetworkInterfaceAssociation.to_xml
                                       f)))])
                         @
                         [Util.option_map v.attachment
                            (fun f ->
                               Ezxmlm.make_tag "attachment"
                                 ([],
                                   (InstanceNetworkInterfaceAttachment.to_xml
                                      f)))])
                        @
                        [Util.option_map v.description
                           (fun f ->
                              Ezxmlm.make_tag "description"
                                ([], (String.to_xml f)))])
                       @
                       (List.map
                          (fun x ->
                             Some
                               (Ezxmlm.make_tag "groupSet"
                                  ([], (GroupIdentifierList.to_xml [x]))))
                          v.groups))
                      @
                      (List.map
                         (fun x ->
                            Some
                              (Ezxmlm.make_tag "ipv6AddressesSet"
                                 ([], (InstanceIpv6AddressList.to_xml [x]))))
                         v.ipv6_addresses))
                     @
                     [Util.option_map v.mac_address
                        (fun f ->
                           Ezxmlm.make_tag "macAddress"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.network_interface_id
                       (fun f ->
                          Ezxmlm.make_tag "networkInterfaceId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.owner_id
                      (fun f ->
                         Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.private_dns_name
                     (fun f ->
                        Ezxmlm.make_tag "privateDnsName"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.private_ip_address
                    (fun f ->
                       Ezxmlm.make_tag "privateIpAddress"
                         ([], (String.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "privateIpAddressesSet"
                           ([], (InstancePrivateIpAddressList.to_xml [x]))))
                   v.private_ip_addresses))
               @
               [Util.option_map v.source_dest_check
                  (fun f ->
                     Ezxmlm.make_tag "sourceDestCheck"
                       ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.status
                 (fun f ->
                    Ezxmlm.make_tag "status"
                      ([], (NetworkInterfaceStatus.to_xml f)))])
             @
             [Util.option_map v.subnet_id
                (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.vpc_id
               (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.interface_type
              (fun f ->
                 Ezxmlm.make_tag "interfaceType" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.interface_type
              (fun f -> ("interface_type", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (NetworkInterfaceStatus.to_json f)));
           Util.option_map v.source_dest_check
             (fun f -> ("source_dest_check", (Boolean.to_json f)));
           Some
             ("private_ip_addresses",
               (InstancePrivateIpAddressList.to_json v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.mac_address
             (fun f -> ("mac_address", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (InstanceIpv6AddressList.to_json v.ipv6_addresses));
           Some ("groups", (GroupIdentifierList.to_json v.groups));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.attachment
             (fun f ->
                ("attachment",
                  (InstanceNetworkInterfaceAttachment.to_json f)));
           Util.option_map v.association
             (fun f ->
                ("association",
                  (InstanceNetworkInterfaceAssociation.to_json f)))])
    let of_json j =
      {
        association =
          (Util.option_map (Json.lookup j "association")
             InstanceNetworkInterfaceAssociation.of_json);
        attachment =
          (Util.option_map (Json.lookup j "attachment")
             InstanceNetworkInterfaceAttachment.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        ipv6_addresses =
          (InstanceIpv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        mac_address =
          (Util.option_map (Json.lookup j "mac_address") String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_ip_addresses =
          (InstancePrivateIpAddressList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             Boolean.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             NetworkInterfaceStatus.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        interface_type =
          (Util.option_map (Json.lookup j "interface_type") String.of_json)
      }
  end
module InstanceStateName =
  struct
    type t =
      | Pending 
      | Running 
      | Shutting_down 
      | Terminated 
      | Stopping 
      | Stopped 
    let str_to_t =
      [("stopped", Stopped);
      ("stopping", Stopping);
      ("terminated", Terminated);
      ("shutting-down", Shutting_down);
      ("running", Running);
      ("pending", Pending)]
    let t_to_str =
      [(Stopped, "stopped");
      (Stopping, "stopping");
      (Terminated, "terminated");
      (Shutting_down, "shutting-down");
      (Running, "running");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LicenseConfiguration =
  struct
    type t = {
      license_configuration_arn: String.t option }
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "licenseConfigurationArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Ezxmlm.make_tag "licenseConfigurationArn"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let of_json j =
      {
        license_configuration_arn =
          (Util.option_map (Json.lookup j "license_configuration_arn")
             String.of_json)
      }
  end
module MonitoringState =
  struct
    type t =
      | Disabled 
      | Disabling 
      | Enabled 
      | Pending 
    let str_to_t =
      [("pending", Pending);
      ("enabled", Enabled);
      ("disabling", Disabling);
      ("disabled", Disabled)]
    let t_to_str =
      [(Pending, "pending");
      (Enabled, "enabled");
      (Disabling, "disabling");
      (Disabled, "disabled")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ProductCode =
  struct
    type t =
      {
      product_code_id: String.t option ;
      product_code_type: ProductCodeValues.t option }
    let make ?product_code_id  ?product_code_type  () =
      { product_code_id; product_code_type }
    let parse xml =
      Some
        {
          product_code_id =
            (Util.option_bind (Xml.member "productCode" xml) String.parse);
          product_code_type =
            (Util.option_bind (Xml.member "type" xml) ProductCodeValues.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.product_code_type
              (fun f -> Query.Pair ("Type", (ProductCodeValues.to_query f)));
           Util.option_map v.product_code_id
             (fun f -> Query.Pair ("ProductCode", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.product_code_id
               (fun f ->
                  Ezxmlm.make_tag "productCode" ([], (String.to_xml f)))])
           @
           [Util.option_map v.product_code_type
              (fun f ->
                 Ezxmlm.make_tag "type" ([], (ProductCodeValues.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.product_code_type
              (fun f -> ("product_code_type", (ProductCodeValues.to_json f)));
           Util.option_map v.product_code_id
             (fun f -> ("product_code_id", (String.to_json f)))])
    let of_json j =
      {
        product_code_id =
          (Util.option_map (Json.lookup j "product_code_id") String.of_json);
        product_code_type =
          (Util.option_map (Json.lookup j "product_code_type")
             ProductCodeValues.of_json)
      }
  end
module VpcCidrBlockStateCode =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
      | Failing 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("failing", Failing);
      ("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Failed, "failed");
      (Failing, "failing");
      (Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SubnetCidrBlockStateCode =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
      | Failing 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("failing", Failing);
      ("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Failed, "failed");
      (Failing, "failing");
      (Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DhcpConfigurationValueList =
  struct
    type t = AttributeValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AttributeValue.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AttributeValue.to_query v
    let to_headers v = Headers.to_headers_list AttributeValue.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (AttributeValue.to_xml x))) v
    let to_json v = `List (List.map AttributeValue.to_json v)
    let of_json j = Json.to_list AttributeValue.of_json j
  end
module ReservedInstancesConfiguration =
  struct
    type t =
      {
      availability_zone: String.t option ;
      instance_count: Integer.t option ;
      instance_type: InstanceType.t option ;
      platform: String.t option ;
      scope: Scope.t option }
    let make ?availability_zone  ?instance_count  ?instance_type  ?platform 
      ?scope  () =
      { availability_zone; instance_count; instance_type; platform; scope }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          scope = (Util.option_bind (Xml.member "scope" xml) Scope.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.scope
              (fun f -> Query.Pair ("Scope", (Scope.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.availability_zone
                  (fun f ->
                     Ezxmlm.make_tag "availabilityZone"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.instance_count
                 (fun f ->
                    Ezxmlm.make_tag "instanceCount" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.instance_type
                (fun f ->
                   Ezxmlm.make_tag "instanceType"
                     ([], (InstanceType.to_xml f)))])
            @
            [Util.option_map v.platform
               (fun f -> Ezxmlm.make_tag "platform" ([], (String.to_xml f)))])
           @
           [Util.option_map v.scope
              (fun f -> Ezxmlm.make_tag "scope" ([], (Scope.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.scope (fun f -> ("scope", (Scope.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") String.of_json);
        scope = (Util.option_map (Json.lookup j "scope") Scope.of_json)
      }
  end
module TrafficDirection =
  struct
    type t =
      | Ingress 
      | Egress 
    let str_to_t = [("egress", Egress); ("ingress", Ingress)]
    let t_to_str = [(Egress, "egress"); (Ingress, "ingress")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TrafficMirrorPortRange =
  struct
    type t = {
      from_port: Integer.t option ;
      to_port: Integer.t option }
    let make ?from_port  ?to_port  () = { from_port; to_port }
    let parse xml =
      Some
        {
          from_port =
            (Util.option_bind (Xml.member "fromPort" xml) Integer.parse);
          to_port =
            (Util.option_bind (Xml.member "toPort" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.to_port
              (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.from_port
               (fun f -> Ezxmlm.make_tag "fromPort" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.to_port
              (fun f -> Ezxmlm.make_tag "toPort" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.to_port
              (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)))])
    let of_json j =
      {
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json)
      }
  end
module TrafficMirrorRuleAction =
  struct
    type t =
      | Accept 
      | Reject 
    let str_to_t = [("reject", Reject); ("accept", Accept)]
    let t_to_str = [(Reject, "reject"); (Accept, "accept")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ListingState =
  struct
    type t =
      | Available 
      | Sold 
      | Cancelled 
      | Pending 
    let str_to_t =
      [("pending", Pending);
      ("cancelled", Cancelled);
      ("sold", Sold);
      ("available", Available)]
    let t_to_str =
      [(Pending, "pending");
      (Cancelled, "cancelled");
      (Sold, "sold");
      (Available, "available")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CurrencyCodeValues =
  struct
    type t =
      | USD 
    let str_to_t = [("USD", USD)]
    let t_to_str = [(USD, "USD")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EventCode =
  struct
    type t =
      | Instance_reboot 
      | System_reboot 
      | System_maintenance 
      | Instance_retirement 
      | Instance_stop 
    let str_to_t =
      [("instance-stop", Instance_stop);
      ("instance-retirement", Instance_retirement);
      ("system-maintenance", System_maintenance);
      ("system-reboot", System_reboot);
      ("instance-reboot", Instance_reboot)]
    let t_to_str =
      [(Instance_stop, "instance-stop");
      (Instance_retirement, "instance-retirement");
      (System_maintenance, "system-maintenance");
      (System_reboot, "system-reboot");
      (Instance_reboot, "instance-reboot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceStatusDetails =
  struct
    type t =
      {
      impaired_since: DateTime.t option ;
      name: StatusName.t option ;
      status: StatusType.t option }
    let make ?impaired_since  ?name  ?status  () =
      { impaired_since; name; status }
    let parse xml =
      Some
        {
          impaired_since =
            (Util.option_bind (Xml.member "impairedSince" xml) DateTime.parse);
          name = (Util.option_bind (Xml.member "name" xml) StatusName.parse);
          status =
            (Util.option_bind (Xml.member "status" xml) StatusType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (StatusType.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (StatusName.to_query f)));
           Util.option_map v.impaired_since
             (fun f -> Query.Pair ("ImpairedSince", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.impaired_since
                (fun f ->
                   Ezxmlm.make_tag "impairedSince" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.name
               (fun f -> Ezxmlm.make_tag "name" ([], (StatusName.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f -> Ezxmlm.make_tag "status" ([], (StatusType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (StatusType.to_json f)));
           Util.option_map v.name (fun f -> ("name", (StatusName.to_json f)));
           Util.option_map v.impaired_since
             (fun f -> ("impaired_since", (DateTime.to_json f)))])
    let of_json j =
      {
        impaired_since =
          (Util.option_map (Json.lookup j "impaired_since") DateTime.of_json);
        name = (Util.option_map (Json.lookup j "name") StatusName.of_json);
        status =
          (Util.option_map (Json.lookup j "status") StatusType.of_json)
      }
  end
module InstanceCapacity =
  struct
    type t =
      {
      available_capacity: Integer.t option ;
      instance_type: String.t option ;
      total_capacity: Integer.t option }
    let make ?available_capacity  ?instance_type  ?total_capacity  () =
      { available_capacity; instance_type; total_capacity }
    let parse xml =
      Some
        {
          available_capacity =
            (Util.option_bind (Xml.member "availableCapacity" xml)
               Integer.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          total_capacity =
            (Util.option_bind (Xml.member "totalCapacity" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_capacity
              (fun f -> Query.Pair ("TotalCapacity", (Integer.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.available_capacity
             (fun f -> Query.Pair ("AvailableCapacity", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.available_capacity
                (fun f ->
                   Ezxmlm.make_tag "availableCapacity"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.instance_type
               (fun f ->
                  Ezxmlm.make_tag "instanceType" ([], (String.to_xml f)))])
           @
           [Util.option_map v.total_capacity
              (fun f ->
                 Ezxmlm.make_tag "totalCapacity" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_capacity
              (fun f -> ("total_capacity", (Integer.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.available_capacity
             (fun f -> ("available_capacity", (Integer.to_json f)))])
    let of_json j =
      {
        available_capacity =
          (Util.option_map (Json.lookup j "available_capacity")
             Integer.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        total_capacity =
          (Util.option_map (Json.lookup j "total_capacity") Integer.of_json)
      }
  end
module DisableFastSnapshotRestoreStateError =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module IpRanges =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PrefixListIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module UserIdGroupPairSet =
  struct
    type t = UserIdGroupPair.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map UserIdGroupPair.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list UserIdGroupPair.to_query v
    let to_headers v = Headers.to_headers_list UserIdGroupPair.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (UserIdGroupPair.to_xml x)))
        v
    let to_json v = `List (List.map UserIdGroupPair.to_json v)
    let of_json j = Json.to_list UserIdGroupPair.of_json j
  end
module VolumeAttachmentState =
  struct
    type t =
      | Attaching 
      | Attached 
      | Detaching 
      | Detached 
      | Busy 
    let str_to_t =
      [("busy", Busy);
      ("detached", Detached);
      ("detaching", Detaching);
      ("attached", Attached);
      ("attaching", Attaching)]
    let t_to_str =
      [(Busy, "busy");
      (Detached, "detached");
      (Detaching, "detaching");
      (Attached, "attached");
      (Attaching, "attaching")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module IKEVersionsRequestListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "Value" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Phase1DHGroupNumbersRequestListValue =
  struct
    type t = {
      value: Integer.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) Integer.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "Value" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Integer.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") Integer.of_json) }
  end
module Phase1EncryptionAlgorithmsRequestListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "Value" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Phase1IntegrityAlgorithmsRequestListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "Value" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Phase2DHGroupNumbersRequestListValue =
  struct
    type t = {
      value: Integer.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) Integer.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "Value" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Integer.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") Integer.of_json) }
  end
module Phase2EncryptionAlgorithmsRequestListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "Value" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Phase2IntegrityAlgorithmsRequestListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "Value" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module FpgaDeviceInfo =
  struct
    type t =
      {
      name: String.t option ;
      manufacturer: String.t option ;
      count: Integer.t option ;
      memory_info: FpgaDeviceMemoryInfo.t option }
    let make ?name  ?manufacturer  ?count  ?memory_info  () =
      { name; manufacturer; count; memory_info }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          manufacturer =
            (Util.option_bind (Xml.member "manufacturer" xml) String.parse);
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          memory_info =
            (Util.option_bind (Xml.member "memoryInfo" xml)
               FpgaDeviceMemoryInfo.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.memory_info
              (fun f ->
                 Query.Pair ("MemoryInfo", (FpgaDeviceMemoryInfo.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Util.option_map v.manufacturer
             (fun f -> Query.Pair ("Manufacturer", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.name
                 (fun f -> Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
             @
             [Util.option_map v.manufacturer
                (fun f ->
                   Ezxmlm.make_tag "manufacturer" ([], (String.to_xml f)))])
            @
            [Util.option_map v.count
               (fun f -> Ezxmlm.make_tag "count" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.memory_info
              (fun f ->
                 Ezxmlm.make_tag "memoryInfo"
                   ([], (FpgaDeviceMemoryInfo.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.memory_info
              (fun f -> ("memory_info", (FpgaDeviceMemoryInfo.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Util.option_map v.manufacturer
             (fun f -> ("manufacturer", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        manufacturer =
          (Util.option_map (Json.lookup j "manufacturer") String.of_json);
        count = (Util.option_map (Json.lookup j "count") Integer.of_json);
        memory_info =
          (Util.option_map (Json.lookup j "memory_info")
             FpgaDeviceMemoryInfo.of_json)
      }
  end
module GpuDeviceInfo =
  struct
    type t =
      {
      name: String.t option ;
      manufacturer: String.t option ;
      count: Integer.t option ;
      memory_info: GpuDeviceMemoryInfo.t option }
    let make ?name  ?manufacturer  ?count  ?memory_info  () =
      { name; manufacturer; count; memory_info }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          manufacturer =
            (Util.option_bind (Xml.member "manufacturer" xml) String.parse);
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          memory_info =
            (Util.option_bind (Xml.member "memoryInfo" xml)
               GpuDeviceMemoryInfo.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.memory_info
              (fun f ->
                 Query.Pair ("MemoryInfo", (GpuDeviceMemoryInfo.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Util.option_map v.manufacturer
             (fun f -> Query.Pair ("Manufacturer", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.name
                 (fun f -> Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
             @
             [Util.option_map v.manufacturer
                (fun f ->
                   Ezxmlm.make_tag "manufacturer" ([], (String.to_xml f)))])
            @
            [Util.option_map v.count
               (fun f -> Ezxmlm.make_tag "count" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.memory_info
              (fun f ->
                 Ezxmlm.make_tag "memoryInfo"
                   ([], (GpuDeviceMemoryInfo.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.memory_info
              (fun f -> ("memory_info", (GpuDeviceMemoryInfo.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Util.option_map v.manufacturer
             (fun f -> ("manufacturer", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        manufacturer =
          (Util.option_map (Json.lookup j "manufacturer") String.of_json);
        count = (Util.option_map (Json.lookup j "count") Integer.of_json);
        memory_info =
          (Util.option_map (Json.lookup j "memory_info")
             GpuDeviceMemoryInfo.of_json)
      }
  end
module InferenceDeviceInfo =
  struct
    type t =
      {
      count: Integer.t option ;
      name: String.t option ;
      manufacturer: String.t option }
    let make ?count  ?name  ?manufacturer  () = { count; name; manufacturer }
    let parse xml =
      Some
        {
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          manufacturer =
            (Util.option_bind (Xml.member "manufacturer" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.manufacturer
              (fun f -> Query.Pair ("Manufacturer", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.count
                (fun f -> Ezxmlm.make_tag "count" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.name
               (fun f -> Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
           @
           [Util.option_map v.manufacturer
              (fun f ->
                 Ezxmlm.make_tag "manufacturer" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.manufacturer
              (fun f -> ("manufacturer", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)))])
    let of_json j =
      {
        count = (Util.option_map (Json.lookup j "count") Integer.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        manufacturer =
          (Util.option_map (Json.lookup j "manufacturer") String.of_json)
      }
  end
module DiskInfo =
  struct
    type t =
      {
      size_in_g_b: Long.t option ;
      count: Integer.t option ;
      type_: DiskType.t option }
    let make ?size_in_g_b  ?count  ?type_  () = { size_in_g_b; count; type_ }
    let parse xml =
      Some
        {
          size_in_g_b =
            (Util.option_bind (Xml.member "sizeInGB" xml) Long.parse);
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          type_ = (Util.option_bind (Xml.member "type" xml) DiskType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> Query.Pair ("Type", (DiskType.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Util.option_map v.size_in_g_b
             (fun f -> Query.Pair ("SizeInGB", (Long.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.size_in_g_b
                (fun f -> Ezxmlm.make_tag "sizeInGB" ([], (Long.to_xml f)))])
            @
            [Util.option_map v.count
               (fun f -> Ezxmlm.make_tag "count" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.type_
              (fun f -> Ezxmlm.make_tag "type" ([], (DiskType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> ("type_", (DiskType.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Util.option_map v.size_in_g_b
             (fun f -> ("size_in_g_b", (Long.to_json f)))])
    let of_json j =
      {
        size_in_g_b =
          (Util.option_map (Json.lookup j "size_in_g_b") Long.of_json);
        count = (Util.option_map (Json.lookup j "count") Integer.of_json);
        type_ = (Util.option_map (Json.lookup j "type_") DiskType.of_json)
      }
  end
module PlacementGroupStrategy =
  struct
    type t =
      | Cluster 
      | Partition 
      | Spread 
    let str_to_t =
      [("spread", Spread); ("partition", Partition); ("cluster", Cluster)]
    let t_to_str =
      [(Spread, "spread"); (Partition, "partition"); (Cluster, "cluster")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ArchitectureType =
  struct
    type t =
      | I386 
      | X86_64 
      | Arm64 
    let str_to_t = [("arm64", Arm64); ("x86_64", X86_64); ("i386", I386)]
    let t_to_str = [(Arm64, "arm64"); (X86_64, "x86_64"); (I386, "i386")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TelemetryStatus =
  struct
    type t =
      | UP 
      | DOWN 
    let str_to_t = [("DOWN", DOWN); ("UP", UP)]
    let t_to_str = [(DOWN, "DOWN"); (UP, "UP")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TunnelOption =
  struct
    type t =
      {
      outside_ip_address: String.t option ;
      tunnel_inside_cidr: String.t option ;
      pre_shared_key: String.t option ;
      phase1_lifetime_seconds: Integer.t option ;
      phase2_lifetime_seconds: Integer.t option ;
      rekey_margin_time_seconds: Integer.t option ;
      rekey_fuzz_percentage: Integer.t option ;
      replay_window_size: Integer.t option ;
      dpd_timeout_seconds: Integer.t option ;
      phase1_encryption_algorithms: Phase1EncryptionAlgorithmsList.t ;
      phase2_encryption_algorithms: Phase2EncryptionAlgorithmsList.t ;
      phase1_integrity_algorithms: Phase1IntegrityAlgorithmsList.t ;
      phase2_integrity_algorithms: Phase2IntegrityAlgorithmsList.t ;
      phase1_d_h_group_numbers: Phase1DHGroupNumbersList.t ;
      phase2_d_h_group_numbers: Phase2DHGroupNumbersList.t ;
      ike_versions: IKEVersionsList.t }
    let make ?outside_ip_address  ?tunnel_inside_cidr  ?pre_shared_key 
      ?phase1_lifetime_seconds  ?phase2_lifetime_seconds 
      ?rekey_margin_time_seconds  ?rekey_fuzz_percentage  ?replay_window_size
       ?dpd_timeout_seconds  ?(phase1_encryption_algorithms= []) 
      ?(phase2_encryption_algorithms= [])  ?(phase1_integrity_algorithms= [])
       ?(phase2_integrity_algorithms= [])  ?(phase1_d_h_group_numbers= []) 
      ?(phase2_d_h_group_numbers= [])  ?(ike_versions= [])  () =
      {
        outside_ip_address;
        tunnel_inside_cidr;
        pre_shared_key;
        phase1_lifetime_seconds;
        phase2_lifetime_seconds;
        rekey_margin_time_seconds;
        rekey_fuzz_percentage;
        replay_window_size;
        dpd_timeout_seconds;
        phase1_encryption_algorithms;
        phase2_encryption_algorithms;
        phase1_integrity_algorithms;
        phase2_integrity_algorithms;
        phase1_d_h_group_numbers;
        phase2_d_h_group_numbers;
        ike_versions
      }
    let parse xml =
      Some
        {
          outside_ip_address =
            (Util.option_bind (Xml.member "outsideIpAddress" xml)
               String.parse);
          tunnel_inside_cidr =
            (Util.option_bind (Xml.member "tunnelInsideCidr" xml)
               String.parse);
          pre_shared_key =
            (Util.option_bind (Xml.member "preSharedKey" xml) String.parse);
          phase1_lifetime_seconds =
            (Util.option_bind (Xml.member "phase1LifetimeSeconds" xml)
               Integer.parse);
          phase2_lifetime_seconds =
            (Util.option_bind (Xml.member "phase2LifetimeSeconds" xml)
               Integer.parse);
          rekey_margin_time_seconds =
            (Util.option_bind (Xml.member "rekeyMarginTimeSeconds" xml)
               Integer.parse);
          rekey_fuzz_percentage =
            (Util.option_bind (Xml.member "rekeyFuzzPercentage" xml)
               Integer.parse);
          replay_window_size =
            (Util.option_bind (Xml.member "replayWindowSize" xml)
               Integer.parse);
          dpd_timeout_seconds =
            (Util.option_bind (Xml.member "dpdTimeoutSeconds" xml)
               Integer.parse);
          phase1_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "phase1EncryptionAlgorithmSet" xml)
                  Phase1EncryptionAlgorithmsList.parse));
          phase2_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "phase2EncryptionAlgorithmSet" xml)
                  Phase2EncryptionAlgorithmsList.parse));
          phase1_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "phase1IntegrityAlgorithmSet" xml)
                  Phase1IntegrityAlgorithmsList.parse));
          phase2_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "phase2IntegrityAlgorithmSet" xml)
                  Phase2IntegrityAlgorithmsList.parse));
          phase1_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "phase1DHGroupNumberSet" xml)
                  Phase1DHGroupNumbersList.parse));
          phase2_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "phase2DHGroupNumberSet" xml)
                  Phase2DHGroupNumbersList.parse));
          ike_versions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ikeVersionSet" xml)
                  IKEVersionsList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("IkeVersionSet", (IKEVersionsList.to_query v.ike_versions)));
           Some
             (Query.Pair
                ("Phase2DHGroupNumberSet",
                  (Phase2DHGroupNumbersList.to_query
                     v.phase2_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase1DHGroupNumberSet",
                  (Phase1DHGroupNumbersList.to_query
                     v.phase1_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase2IntegrityAlgorithmSet",
                  (Phase2IntegrityAlgorithmsList.to_query
                     v.phase2_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase1IntegrityAlgorithmSet",
                  (Phase1IntegrityAlgorithmsList.to_query
                     v.phase1_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase2EncryptionAlgorithmSet",
                  (Phase2EncryptionAlgorithmsList.to_query
                     v.phase2_encryption_algorithms)));
           Some
             (Query.Pair
                ("Phase1EncryptionAlgorithmSet",
                  (Phase1EncryptionAlgorithmsList.to_query
                     v.phase1_encryption_algorithms)));
           Util.option_map v.dpd_timeout_seconds
             (fun f -> Query.Pair ("DpdTimeoutSeconds", (Integer.to_query f)));
           Util.option_map v.replay_window_size
             (fun f -> Query.Pair ("ReplayWindowSize", (Integer.to_query f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f ->
                Query.Pair ("RekeyFuzzPercentage", (Integer.to_query f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f ->
                Query.Pair ("RekeyMarginTimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase2LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase1LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.pre_shared_key
             (fun f -> Query.Pair ("PreSharedKey", (String.to_query f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> Query.Pair ("TunnelInsideCidr", (String.to_query f)));
           Util.option_map v.outside_ip_address
             (fun f -> Query.Pair ("OutsideIpAddress", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((([] @
                          [Util.option_map v.outside_ip_address
                             (fun f ->
                                Ezxmlm.make_tag "outsideIpAddress"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.tunnel_inside_cidr
                            (fun f ->
                               Ezxmlm.make_tag "tunnelInsideCidr"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.pre_shared_key
                           (fun f ->
                              Ezxmlm.make_tag "preSharedKey"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.phase1_lifetime_seconds
                          (fun f ->
                             Ezxmlm.make_tag "phase1LifetimeSeconds"
                               ([], (Integer.to_xml f)))])
                      @
                      [Util.option_map v.phase2_lifetime_seconds
                         (fun f ->
                            Ezxmlm.make_tag "phase2LifetimeSeconds"
                              ([], (Integer.to_xml f)))])
                     @
                     [Util.option_map v.rekey_margin_time_seconds
                        (fun f ->
                           Ezxmlm.make_tag "rekeyMarginTimeSeconds"
                             ([], (Integer.to_xml f)))])
                    @
                    [Util.option_map v.rekey_fuzz_percentage
                       (fun f ->
                          Ezxmlm.make_tag "rekeyFuzzPercentage"
                            ([], (Integer.to_xml f)))])
                   @
                   [Util.option_map v.replay_window_size
                      (fun f ->
                         Ezxmlm.make_tag "replayWindowSize"
                           ([], (Integer.to_xml f)))])
                  @
                  [Util.option_map v.dpd_timeout_seconds
                     (fun f ->
                        Ezxmlm.make_tag "dpdTimeoutSeconds"
                          ([], (Integer.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "phase1EncryptionAlgorithmSet"
                            ([], (Phase1EncryptionAlgorithmsList.to_xml [x]))))
                    v.phase1_encryption_algorithms))
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "phase2EncryptionAlgorithmSet"
                           ([], (Phase2EncryptionAlgorithmsList.to_xml [x]))))
                   v.phase2_encryption_algorithms))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "phase1IntegrityAlgorithmSet"
                          ([], (Phase1IntegrityAlgorithmsList.to_xml [x]))))
                  v.phase1_integrity_algorithms))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "phase2IntegrityAlgorithmSet"
                         ([], (Phase2IntegrityAlgorithmsList.to_xml [x]))))
                 v.phase2_integrity_algorithms))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "phase1DHGroupNumberSet"
                        ([], (Phase1DHGroupNumbersList.to_xml [x]))))
                v.phase1_d_h_group_numbers))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "phase2DHGroupNumberSet"
                       ([], (Phase2DHGroupNumbersList.to_xml [x]))))
               v.phase2_d_h_group_numbers))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "ikeVersionSet"
                      ([], (IKEVersionsList.to_xml [x])))) v.ike_versions))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("ike_versions", (IKEVersionsList.to_json v.ike_versions));
           Some
             ("phase2_d_h_group_numbers",
               (Phase2DHGroupNumbersList.to_json v.phase2_d_h_group_numbers));
           Some
             ("phase1_d_h_group_numbers",
               (Phase1DHGroupNumbersList.to_json v.phase1_d_h_group_numbers));
           Some
             ("phase2_integrity_algorithms",
               (Phase2IntegrityAlgorithmsList.to_json
                  v.phase2_integrity_algorithms));
           Some
             ("phase1_integrity_algorithms",
               (Phase1IntegrityAlgorithmsList.to_json
                  v.phase1_integrity_algorithms));
           Some
             ("phase2_encryption_algorithms",
               (Phase2EncryptionAlgorithmsList.to_json
                  v.phase2_encryption_algorithms));
           Some
             ("phase1_encryption_algorithms",
               (Phase1EncryptionAlgorithmsList.to_json
                  v.phase1_encryption_algorithms));
           Util.option_map v.dpd_timeout_seconds
             (fun f -> ("dpd_timeout_seconds", (Integer.to_json f)));
           Util.option_map v.replay_window_size
             (fun f -> ("replay_window_size", (Integer.to_json f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f -> ("rekey_fuzz_percentage", (Integer.to_json f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f -> ("rekey_margin_time_seconds", (Integer.to_json f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f -> ("phase2_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f -> ("phase1_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.pre_shared_key
             (fun f -> ("pre_shared_key", (String.to_json f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> ("tunnel_inside_cidr", (String.to_json f)));
           Util.option_map v.outside_ip_address
             (fun f -> ("outside_ip_address", (String.to_json f)))])
    let of_json j =
      {
        outside_ip_address =
          (Util.option_map (Json.lookup j "outside_ip_address")
             String.of_json);
        tunnel_inside_cidr =
          (Util.option_map (Json.lookup j "tunnel_inside_cidr")
             String.of_json);
        pre_shared_key =
          (Util.option_map (Json.lookup j "pre_shared_key") String.of_json);
        phase1_lifetime_seconds =
          (Util.option_map (Json.lookup j "phase1_lifetime_seconds")
             Integer.of_json);
        phase2_lifetime_seconds =
          (Util.option_map (Json.lookup j "phase2_lifetime_seconds")
             Integer.of_json);
        rekey_margin_time_seconds =
          (Util.option_map (Json.lookup j "rekey_margin_time_seconds")
             Integer.of_json);
        rekey_fuzz_percentage =
          (Util.option_map (Json.lookup j "rekey_fuzz_percentage")
             Integer.of_json);
        replay_window_size =
          (Util.option_map (Json.lookup j "replay_window_size")
             Integer.of_json);
        dpd_timeout_seconds =
          (Util.option_map (Json.lookup j "dpd_timeout_seconds")
             Integer.of_json);
        phase1_encryption_algorithms =
          (Phase1EncryptionAlgorithmsList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase1_encryption_algorithms")));
        phase2_encryption_algorithms =
          (Phase2EncryptionAlgorithmsList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase2_encryption_algorithms")));
        phase1_integrity_algorithms =
          (Phase1IntegrityAlgorithmsList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase1_integrity_algorithms")));
        phase2_integrity_algorithms =
          (Phase2IntegrityAlgorithmsList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase2_integrity_algorithms")));
        phase1_d_h_group_numbers =
          (Phase1DHGroupNumbersList.of_json
             (Util.of_option_exn (Json.lookup j "phase1_d_h_group_numbers")));
        phase2_d_h_group_numbers =
          (Phase2DHGroupNumbersList.of_json
             (Util.of_option_exn (Json.lookup j "phase2_d_h_group_numbers")));
        ike_versions =
          (IKEVersionsList.of_json
             (Util.of_option_exn (Json.lookup j "ike_versions")))
      }
  end
module VpnState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpnStaticRouteSource =
  struct
    type t =
      | Static 
    let str_to_t = [("Static", Static)]
    let t_to_str = [(Static, "Static")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CidrBlock =
  struct
    type t = {
      cidr_block: String.t option }
    let make ?cidr_block  () = { cidr_block }
    let parse xml =
      Some
        {
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cidr_block
              (fun f -> Query.Pair ("CidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.cidr_block
              (fun f -> Ezxmlm.make_tag "cidrBlock" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cidr_block
              (fun f -> ("cidr_block", (String.to_json f)))])
    let of_json j =
      {
        cidr_block =
          (Util.option_map (Json.lookup j "cidr_block") String.of_json)
      }
  end
module Ipv6CidrBlock =
  struct
    type t = {
      ipv6_cidr_block: String.t option }
    let make ?ipv6_cidr_block  () = { ipv6_cidr_block }
    let parse xml =
      Some
        {
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "ipv6CidrBlock" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block
              (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ipv6_cidr_block
              (fun f ->
                 Ezxmlm.make_tag "ipv6CidrBlock" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block
              (fun f -> ("ipv6_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        ipv6_cidr_block =
          (Util.option_map (Json.lookup j "ipv6_cidr_block") String.of_json)
      }
  end
module IcmpTypeCode =
  struct
    type t = {
      code: Integer.t option ;
      type_: Integer.t option }
    let make ?code  ?type_  () = { code; type_ }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) Integer.parse);
          type_ = (Util.option_bind (Xml.member "type" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> Query.Pair ("Type", (Integer.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f -> Ezxmlm.make_tag "code" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.type_
              (fun f -> Ezxmlm.make_tag "type" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.type_ (fun f -> ("type_", (Integer.to_json f)));
           Util.option_map v.code (fun f -> ("code", (Integer.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") Integer.of_json);
        type_ = (Util.option_map (Json.lookup j "type_") Integer.of_json)
      }
  end
module PortRange =
  struct
    type t = {
      from: Integer.t option ;
      to_: Integer.t option }
    let make ?from  ?to_  () = { from; to_ }
    let parse xml =
      Some
        {
          from = (Util.option_bind (Xml.member "from" xml) Integer.parse);
          to_ = (Util.option_bind (Xml.member "to" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.to_
              (fun f -> Query.Pair ("To", (Integer.to_query f)));
           Util.option_map v.from
             (fun f -> Query.Pair ("From", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.from
               (fun f -> Ezxmlm.make_tag "from" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.to_
              (fun f -> Ezxmlm.make_tag "to" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.to_ (fun f -> ("to_", (Integer.to_json f)));
           Util.option_map v.from (fun f -> ("from", (Integer.to_json f)))])
    let of_json j =
      {
        from = (Util.option_map (Json.lookup j "from") Integer.of_json);
        to_ = (Util.option_map (Json.lookup j "to_") Integer.of_json)
      }
  end
module RuleAction =
  struct
    type t =
      | Allow 
      | Deny 
    let str_to_t = [("deny", Deny); ("allow", Allow)]
    let t_to_str = [(Deny, "deny"); (Allow, "allow")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NetworkInterfaceAssociation =
  struct
    type t =
      {
      allocation_id: String.t option ;
      association_id: String.t option ;
      ip_owner_id: String.t option ;
      public_dns_name: String.t option ;
      public_ip: String.t option }
    let make ?allocation_id  ?association_id  ?ip_owner_id  ?public_dns_name 
      ?public_ip  () =
      {
        allocation_id;
        association_id;
        ip_owner_id;
        public_dns_name;
        public_ip
      }
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          ip_owner_id =
            (Util.option_bind (Xml.member "ipOwnerId" xml) String.parse);
          public_dns_name =
            (Util.option_bind (Xml.member "publicDnsName" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.public_dns_name
             (fun f -> Query.Pair ("PublicDnsName", (String.to_query f)));
           Util.option_map v.ip_owner_id
             (fun f -> Query.Pair ("IpOwnerId", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.allocation_id
                  (fun f ->
                     Ezxmlm.make_tag "allocationId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.association_id
                 (fun f ->
                    Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.ip_owner_id
                (fun f -> Ezxmlm.make_tag "ipOwnerId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.public_dns_name
               (fun f ->
                  Ezxmlm.make_tag "publicDnsName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.public_ip
              (fun f -> Ezxmlm.make_tag "publicIp" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.public_dns_name
             (fun f -> ("public_dns_name", (String.to_json f)));
           Util.option_map v.ip_owner_id
             (fun f -> ("ip_owner_id", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let of_json j =
      {
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        ip_owner_id =
          (Util.option_map (Json.lookup j "ip_owner_id") String.of_json);
        public_dns_name =
          (Util.option_map (Json.lookup j "public_dns_name") String.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json)
      }
  end
module RecurringChargeFrequency =
  struct
    type t =
      | Hourly 
    let str_to_t = [("Hourly", Hourly)]
    let t_to_str = [(Hourly, "Hourly")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ServiceType =
  struct
    type t =
      | Interface 
      | Gateway 
    let str_to_t = [("Gateway", Gateway); ("Interface", Interface)]
    let t_to_str = [(Gateway, "Gateway"); (Interface, "Interface")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ImportInstanceVolumeDetailItem =
  struct
    type t =
      {
      availability_zone: String.t option ;
      bytes_converted: Long.t option ;
      description: String.t option ;
      image: DiskImageDescription.t option ;
      status: String.t option ;
      status_message: String.t option ;
      volume: DiskImageVolumeDescription.t option }
    let make ?availability_zone  ?bytes_converted  ?description  ?image 
      ?status  ?status_message  ?volume  () =
      {
        availability_zone;
        bytes_converted;
        description;
        image;
        status;
        status_message;
        volume
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          bytes_converted =
            (Util.option_bind (Xml.member "bytesConverted" xml) Long.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          image =
            (Util.option_bind (Xml.member "image" xml)
               DiskImageDescription.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          volume =
            (Util.option_bind (Xml.member "volume" xml)
               DiskImageVolumeDescription.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f ->
                 Query.Pair
                   ("Volume", (DiskImageVolumeDescription.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.image
             (fun f ->
                Query.Pair ("Image", (DiskImageDescription.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.bytes_converted
             (fun f -> Query.Pair ("BytesConverted", (Long.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.availability_zone
                    (fun f ->
                       Ezxmlm.make_tag "availabilityZone"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.bytes_converted
                   (fun f ->
                      Ezxmlm.make_tag "bytesConverted" ([], (Long.to_xml f)))])
               @
               [Util.option_map v.description
                  (fun f ->
                     Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
              @
              [Util.option_map v.image
                 (fun f ->
                    Ezxmlm.make_tag "image"
                      ([], (DiskImageDescription.to_xml f)))])
             @
             [Util.option_map v.status
                (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
            @
            [Util.option_map v.status_message
               (fun f ->
                  Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
           @
           [Util.option_map v.volume
              (fun f ->
                 Ezxmlm.make_tag "volume"
                   ([], (DiskImageVolumeDescription.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f -> ("volume", (DiskImageVolumeDescription.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.image
             (fun f -> ("image", (DiskImageDescription.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.bytes_converted
             (fun f -> ("bytes_converted", (Long.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        bytes_converted =
          (Util.option_map (Json.lookup j "bytes_converted") Long.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        image =
          (Util.option_map (Json.lookup j "image")
             DiskImageDescription.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        volume =
          (Util.option_map (Json.lookup j "volume")
             DiskImageVolumeDescription.of_json)
      }
  end
module TransitGatewayAttachmentResourceType =
  struct
    type t =
      | Vpc 
      | Vpn 
      | Direct_connect_gateway 
      | Tgw_peering 
    let str_to_t =
      [("tgw-peering", Tgw_peering);
      ("direct-connect-gateway", Direct_connect_gateway);
      ("vpn", Vpn);
      ("vpc", Vpc)]
    let t_to_str =
      [(Tgw_peering, "tgw-peering");
      (Direct_connect_gateway, "direct-connect-gateway");
      (Vpn, "vpn");
      (Vpc, "vpc")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EnableFastSnapshotRestoreStateError =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module RouteOrigin =
  struct
    type t =
      | CreateRouteTable 
      | CreateRoute 
      | EnableVgwRoutePropagation 
    let str_to_t =
      [("EnableVgwRoutePropagation", EnableVgwRoutePropagation);
      ("CreateRoute", CreateRoute);
      ("CreateRouteTable", CreateRouteTable)]
    let t_to_str =
      [(EnableVgwRoutePropagation, "EnableVgwRoutePropagation");
      (CreateRoute, "CreateRoute");
      (CreateRouteTable, "CreateRouteTable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RouteState =
  struct
    type t =
      | Active 
      | Blackhole 
    let str_to_t = [("blackhole", Blackhole); ("active", Active)]
    let t_to_str = [(Blackhole, "blackhole"); (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RouteTableAssociationState =
  struct
    type t =
      {
      state: RouteTableAssociationStateCode.t option ;
      status_message: String.t option }
    let make ?state  ?status_message  () = { state; status_message }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml)
               RouteTableAssociationStateCode.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (RouteTableAssociationStateCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.state
               (fun f ->
                  Ezxmlm.make_tag "state"
                    ([], (RouteTableAssociationStateCode.to_xml f)))])
           @
           [Util.option_map v.status_message
              (fun f ->
                 Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (RouteTableAssociationStateCode.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state")
             RouteTableAssociationStateCode.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json)
      }
  end
module ElasticGpuSpecificationResponse =
  struct
    type t = {
      type_: String.t option }
    let make ?type_  () = { type_ }
    let parse xml =
      Some
        { type_ = (Util.option_bind (Xml.member "type" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> Query.Pair ("Type", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.type_
              (fun f -> Ezxmlm.make_tag "type" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.type_ (fun f -> ("type_", (String.to_json f)))])
    let of_json j =
      { type_ = (Util.option_map (Json.lookup j "type_") String.of_json) }
  end
module LaunchTemplateBlockDeviceMapping =
  struct
    type t =
      {
      device_name: String.t option ;
      virtual_name: String.t option ;
      ebs: LaunchTemplateEbsBlockDevice.t option ;
      no_device: String.t option }
    let make ?device_name  ?virtual_name  ?ebs  ?no_device  () =
      { device_name; virtual_name; ebs; no_device }
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          virtual_name =
            (Util.option_bind (Xml.member "virtualName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "ebs" xml)
               LaunchTemplateEbsBlockDevice.parse);
          no_device =
            (Util.option_bind (Xml.member "noDevice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.ebs
             (fun f ->
                Query.Pair ("Ebs", (LaunchTemplateEbsBlockDevice.to_query f)));
           Util.option_map v.virtual_name
             (fun f -> Query.Pair ("VirtualName", (String.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.device_name
                 (fun f ->
                    Ezxmlm.make_tag "deviceName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.virtual_name
                (fun f ->
                   Ezxmlm.make_tag "virtualName" ([], (String.to_xml f)))])
            @
            [Util.option_map v.ebs
               (fun f ->
                  Ezxmlm.make_tag "ebs"
                    ([], (LaunchTemplateEbsBlockDevice.to_xml f)))])
           @
           [Util.option_map v.no_device
              (fun f -> Ezxmlm.make_tag "noDevice" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.ebs
             (fun f -> ("ebs", (LaunchTemplateEbsBlockDevice.to_json f)));
           Util.option_map v.virtual_name
             (fun f -> ("virtual_name", (String.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let of_json j =
      {
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        virtual_name =
          (Util.option_map (Json.lookup j "virtual_name") String.of_json);
        ebs =
          (Util.option_map (Json.lookup j "ebs")
             LaunchTemplateEbsBlockDevice.of_json);
        no_device =
          (Util.option_map (Json.lookup j "no_device") String.of_json)
      }
  end
module LaunchTemplateElasticInferenceAcceleratorResponse =
  struct
    type t = {
      type_: String.t option ;
      count: Integer.t option }
    let make ?type_  ?count  () = { type_; count }
    let parse xml =
      Some
        {
          type_ = (Util.option_bind (Xml.member "type" xml) String.parse);
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.count
              (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.type_
               (fun f -> Ezxmlm.make_tag "type" ([], (String.to_xml f)))])
           @
           [Util.option_map v.count
              (fun f -> Ezxmlm.make_tag "count" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Util.option_map v.type_ (fun f -> ("type_", (String.to_json f)))])
    let of_json j =
      {
        type_ = (Util.option_map (Json.lookup j "type_") String.of_json);
        count = (Util.option_map (Json.lookup j "count") Integer.of_json)
      }
  end
module LaunchTemplateSpotMarketOptions =
  struct
    type t =
      {
      max_price: String.t option ;
      spot_instance_type: SpotInstanceType.t option ;
      block_duration_minutes: Integer.t option ;
      valid_until: DateTime.t option ;
      instance_interruption_behavior: InstanceInterruptionBehavior.t option }
    let make ?max_price  ?spot_instance_type  ?block_duration_minutes 
      ?valid_until  ?instance_interruption_behavior  () =
      {
        max_price;
        spot_instance_type;
        block_duration_minutes;
        valid_until;
        instance_interruption_behavior
      }
    let parse xml =
      Some
        {
          max_price =
            (Util.option_bind (Xml.member "maxPrice" xml) String.parse);
          spot_instance_type =
            (Util.option_bind (Xml.member "spotInstanceType" xml)
               SpotInstanceType.parse);
          block_duration_minutes =
            (Util.option_bind (Xml.member "blockDurationMinutes" xml)
               Integer.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "instanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Query.Pair
                   ("InstanceInterruptionBehavior",
                     (InstanceInterruptionBehavior.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.block_duration_minutes
             (fun f ->
                Query.Pair ("BlockDurationMinutes", (Integer.to_query f)));
           Util.option_map v.spot_instance_type
             (fun f ->
                Query.Pair
                  ("SpotInstanceType", (SpotInstanceType.to_query f)));
           Util.option_map v.max_price
             (fun f -> Query.Pair ("MaxPrice", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.max_price
                  (fun f ->
                     Ezxmlm.make_tag "maxPrice" ([], (String.to_xml f)))])
              @
              [Util.option_map v.spot_instance_type
                 (fun f ->
                    Ezxmlm.make_tag "spotInstanceType"
                      ([], (SpotInstanceType.to_xml f)))])
             @
             [Util.option_map v.block_duration_minutes
                (fun f ->
                   Ezxmlm.make_tag "blockDurationMinutes"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.valid_until
               (fun f ->
                  Ezxmlm.make_tag "validUntil" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Ezxmlm.make_tag "instanceInterruptionBehavior"
                   ([], (InstanceInterruptionBehavior.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 ("instance_interruption_behavior",
                   (InstanceInterruptionBehavior.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.block_duration_minutes
             (fun f -> ("block_duration_minutes", (Integer.to_json f)));
           Util.option_map v.spot_instance_type
             (fun f -> ("spot_instance_type", (SpotInstanceType.to_json f)));
           Util.option_map v.max_price
             (fun f -> ("max_price", (String.to_json f)))])
    let of_json j =
      {
        max_price =
          (Util.option_map (Json.lookup j "max_price") String.of_json);
        spot_instance_type =
          (Util.option_map (Json.lookup j "spot_instance_type")
             SpotInstanceType.of_json);
        block_duration_minutes =
          (Util.option_map (Json.lookup j "block_duration_minutes")
             Integer.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        instance_interruption_behavior =
          (Util.option_map (Json.lookup j "instance_interruption_behavior")
             InstanceInterruptionBehavior.of_json)
      }
  end
module MarketType =
  struct
    type t =
      | Spot 
    let str_to_t = [("spot", Spot)]
    let t_to_str = [(Spot, "spot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LaunchTemplateInstanceNetworkInterfaceSpecification =
  struct
    type t =
      {
      associate_public_ip_address: Boolean.t option ;
      delete_on_termination: Boolean.t option ;
      description: String.t option ;
      device_index: Integer.t option ;
      groups: GroupIdStringList.t ;
      interface_type: String.t option ;
      ipv6_address_count: Integer.t option ;
      ipv6_addresses: InstanceIpv6AddressList.t ;
      network_interface_id: String.t option ;
      private_ip_address: String.t option ;
      private_ip_addresses: PrivateIpAddressSpecificationList.t ;
      secondary_private_ip_address_count: Integer.t option ;
      subnet_id: String.t option }
    let make ?associate_public_ip_address  ?delete_on_termination 
      ?description  ?device_index  ?(groups= [])  ?interface_type 
      ?ipv6_address_count  ?(ipv6_addresses= [])  ?network_interface_id 
      ?private_ip_address  ?(private_ip_addresses= []) 
      ?secondary_private_ip_address_count  ?subnet_id  () =
      {
        associate_public_ip_address;
        delete_on_termination;
        description;
        device_index;
        groups;
        interface_type;
        ipv6_address_count;
        ipv6_addresses;
        network_interface_id;
        private_ip_address;
        private_ip_addresses;
        secondary_private_ip_address_count;
        subnet_id
      }
    let parse xml =
      Some
        {
          associate_public_ip_address =
            (Util.option_bind (Xml.member "associatePublicIpAddress" xml)
               Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          device_index =
            (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdStringList.parse));
          interface_type =
            (Util.option_bind (Xml.member "interfaceType" xml) String.parse);
          ipv6_address_count =
            (Util.option_bind (Xml.member "ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6AddressesSet" xml)
                  InstanceIpv6AddressList.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddressesSet" xml)
                  PrivateIpAddressSpecificationList.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "secondaryPrivateIpAddressCount" xml)
               Integer.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddressesSet",
                  (PrivateIpAddressSpecificationList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6AddressesSet",
                  (InstanceIpv6AddressList.to_query v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)));
           Util.option_map v.interface_type
             (fun f -> Query.Pair ("InterfaceType", (String.to_query f)));
           Some
             (Query.Pair ("GroupSet", (GroupIdStringList.to_query v.groups)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.associate_public_ip_address
             (fun f ->
                Query.Pair ("AssociatePublicIpAddress", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.associate_public_ip_address
                          (fun f ->
                             Ezxmlm.make_tag "associatePublicIpAddress"
                               ([], (Boolean.to_xml f)))])
                      @
                      [Util.option_map v.delete_on_termination
                         (fun f ->
                            Ezxmlm.make_tag "deleteOnTermination"
                              ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.description
                        (fun f ->
                           Ezxmlm.make_tag "description"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.device_index
                       (fun f ->
                          Ezxmlm.make_tag "deviceIndex"
                            ([], (Integer.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "groupSet"
                              ([], (GroupIdStringList.to_xml [x])))) v.groups))
                  @
                  [Util.option_map v.interface_type
                     (fun f ->
                        Ezxmlm.make_tag "interfaceType"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.ipv6_address_count
                    (fun f ->
                       Ezxmlm.make_tag "ipv6AddressCount"
                         ([], (Integer.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "ipv6AddressesSet"
                           ([], (InstanceIpv6AddressList.to_xml [x]))))
                   v.ipv6_addresses))
               @
               [Util.option_map v.network_interface_id
                  (fun f ->
                     Ezxmlm.make_tag "networkInterfaceId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.private_ip_address
                 (fun f ->
                    Ezxmlm.make_tag "privateIpAddress"
                      ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "privateIpAddressesSet"
                        ([], (PrivateIpAddressSpecificationList.to_xml [x]))))
                v.private_ip_addresses))
            @
            [Util.option_map v.secondary_private_ip_address_count
               (fun f ->
                  Ezxmlm.make_tag "secondaryPrivateIpAddressCount"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.subnet_id
              (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_addresses",
               (PrivateIpAddressSpecificationList.to_json
                  v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (InstanceIpv6AddressList.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)));
           Util.option_map v.interface_type
             (fun f -> ("interface_type", (String.to_json f)));
           Some ("groups", (GroupIdStringList.to_json v.groups));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.associate_public_ip_address
             (fun f -> ("associate_public_ip_address", (Boolean.to_json f)))])
    let of_json j =
      {
        associate_public_ip_address =
          (Util.option_map (Json.lookup j "associate_public_ip_address")
             Boolean.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        device_index =
          (Util.option_map (Json.lookup j "device_index") Integer.of_json);
        groups =
          (GroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        interface_type =
          (Util.option_map (Json.lookup j "interface_type") String.of_json);
        ipv6_address_count =
          (Util.option_map (Json.lookup j "ipv6_address_count")
             Integer.of_json);
        ipv6_addresses =
          (InstanceIpv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_ip_addresses =
          (PrivateIpAddressSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        secondary_private_ip_address_count =
          (Util.option_map
             (Json.lookup j "secondary_private_ip_address_count")
             Integer.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json)
      }
  end
module LaunchTemplateLicenseConfiguration =
  struct
    type t = {
      license_configuration_arn: String.t option }
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "licenseConfigurationArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Ezxmlm.make_tag "licenseConfigurationArn"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let of_json j =
      {
        license_configuration_arn =
          (Util.option_map (Json.lookup j "license_configuration_arn")
             String.of_json)
      }
  end
module LaunchTemplateTagSpecification =
  struct
    type t = {
      resource_type: ResourceType.t option ;
      tags: TagList.t }
    let make ?resource_type  ?(tags= [])  () = { resource_type; tags }
    let parse xml =
      Some
        {
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               ResourceType.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.resource_type
             (fun f -> Query.Pair ("ResourceType", (ResourceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "resourceType"
                    ([], (ResourceType.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.resource_type
             (fun f -> ("resource_type", (ResourceType.to_json f)))])
    let of_json j =
      {
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             ResourceType.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module InstanceIpv6AddressRequest =
  struct
    type t = {
      ipv6_address: String.t option }
    let make ?ipv6_address  () = { ipv6_address }
    let parse xml =
      Some
        {
          ipv6_address =
            (Util.option_bind (Xml.member "Ipv6Address" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> Query.Pair ("Ipv6Address", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ipv6_address
              (fun f -> Ezxmlm.make_tag "Ipv6Address" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> ("ipv6_address", (String.to_json f)))])
    let of_json j =
      {
        ipv6_address =
          (Util.option_map (Json.lookup j "ipv6_address") String.of_json)
      }
  end
module IpRangeList =
  struct
    type t = IpRange.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map IpRange.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list IpRange.to_query v
    let to_headers v = Headers.to_headers_list IpRange.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (IpRange.to_xml x))) v
    let to_json v = `List (List.map IpRange.to_json v)
    let of_json j = Json.to_list IpRange.of_json j
  end
module Ipv6RangeList =
  struct
    type t = Ipv6Range.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Ipv6Range.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Ipv6Range.to_query v
    let to_headers v = Headers.to_headers_list Ipv6Range.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Ipv6Range.to_xml x)))
        v
    let to_json v = `List (List.map Ipv6Range.to_json v)
    let of_json j = Json.to_list Ipv6Range.of_json j
  end
module PrefixListIdList =
  struct
    type t = PrefixListId.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map PrefixListId.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PrefixListId.to_query v
    let to_headers v = Headers.to_headers_list PrefixListId.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PrefixListId.to_xml x))) v
    let to_json v = `List (List.map PrefixListId.to_json v)
    let of_json j = Json.to_list PrefixListId.of_json j
  end
module UserIdGroupPairList =
  struct
    type t = UserIdGroupPair.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map UserIdGroupPair.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list UserIdGroupPair.to_query v
    let to_headers v = Headers.to_headers_list UserIdGroupPair.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (UserIdGroupPair.to_xml x)))
        v
    let to_json v = `List (List.map UserIdGroupPair.to_json v)
    let of_json j = Json.to_list UserIdGroupPair.of_json j
  end
module AssociatedNetworkType =
  struct
    type t =
      | Vpc 
    let str_to_t = [("vpc", Vpc)]
    let t_to_str = [(Vpc, "vpc")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CertificateAuthentication =
  struct
    type t = {
      client_root_certificate_chain: String.t option }
    let make ?client_root_certificate_chain  () =
      { client_root_certificate_chain }
    let parse xml =
      Some
        {
          client_root_certificate_chain =
            (Util.option_bind (Xml.member "clientRootCertificateChain" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_root_certificate_chain
              (fun f ->
                 Query.Pair
                   ("ClientRootCertificateChain", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.client_root_certificate_chain
              (fun f ->
                 Ezxmlm.make_tag "clientRootCertificateChain"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_root_certificate_chain
              (fun f -> ("client_root_certificate_chain", (String.to_json f)))])
    let of_json j =
      {
        client_root_certificate_chain =
          (Util.option_map (Json.lookup j "client_root_certificate_chain")
             String.of_json)
      }
  end
module ClientVpnAuthenticationType =
  struct
    type t =
      | Certificate_authentication 
      | Directory_service_authentication 
    let str_to_t =
      [("directory-service-authentication", Directory_service_authentication);
      ("certificate-authentication", Certificate_authentication)]
    let t_to_str =
      [(Directory_service_authentication, "directory-service-authentication");
      (Certificate_authentication, "certificate-authentication")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DirectoryServiceAuthentication =
  struct
    type t = {
      directory_id: String.t option }
    let make ?directory_id  () = { directory_id }
    let parse xml =
      Some
        {
          directory_id =
            (Util.option_bind (Xml.member "directoryId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.directory_id
              (fun f -> Query.Pair ("DirectoryId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.directory_id
              (fun f -> Ezxmlm.make_tag "directoryId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.directory_id
              (fun f -> ("directory_id", (String.to_json f)))])
    let of_json j =
      {
        directory_id =
          (Util.option_map (Json.lookup j "directory_id") String.of_json)
      }
  end
module Placement =
  struct
    type t =
      {
      availability_zone: String.t option ;
      affinity: String.t option ;
      group_name: String.t option ;
      partition_number: Integer.t option ;
      host_id: String.t option ;
      tenancy: Tenancy.t option ;
      spread_domain: String.t option ;
      host_resource_group_arn: String.t option }
    let make ?availability_zone  ?affinity  ?group_name  ?partition_number 
      ?host_id  ?tenancy  ?spread_domain  ?host_resource_group_arn  () =
      {
        availability_zone;
        affinity;
        group_name;
        partition_number;
        host_id;
        tenancy;
        spread_domain;
        host_resource_group_arn
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          affinity =
            (Util.option_bind (Xml.member "affinity" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          partition_number =
            (Util.option_bind (Xml.member "partitionNumber" xml)
               Integer.parse);
          host_id = (Util.option_bind (Xml.member "hostId" xml) String.parse);
          tenancy =
            (Util.option_bind (Xml.member "tenancy" xml) Tenancy.parse);
          spread_domain =
            (Util.option_bind (Xml.member "spreadDomain" xml) String.parse);
          host_resource_group_arn =
            (Util.option_bind (Xml.member "hostResourceGroupArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f ->
                 Query.Pair ("HostResourceGroupArn", (String.to_query f)));
           Util.option_map v.spread_domain
             (fun f -> Query.Pair ("SpreadDomain", (String.to_query f)));
           Util.option_map v.tenancy
             (fun f -> Query.Pair ("Tenancy", (Tenancy.to_query f)));
           Util.option_map v.host_id
             (fun f -> Query.Pair ("HostId", (String.to_query f)));
           Util.option_map v.partition_number
             (fun f -> Query.Pair ("PartitionNumber", (Integer.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.affinity
             (fun f -> Query.Pair ("Affinity", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.availability_zone
                     (fun f ->
                        Ezxmlm.make_tag "availabilityZone"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.affinity
                    (fun f ->
                       Ezxmlm.make_tag "affinity" ([], (String.to_xml f)))])
                @
                [Util.option_map v.group_name
                   (fun f ->
                      Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
               @
               [Util.option_map v.partition_number
                  (fun f ->
                     Ezxmlm.make_tag "partitionNumber"
                       ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.host_id
                 (fun f -> Ezxmlm.make_tag "hostId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.tenancy
                (fun f -> Ezxmlm.make_tag "tenancy" ([], (Tenancy.to_xml f)))])
            @
            [Util.option_map v.spread_domain
               (fun f ->
                  Ezxmlm.make_tag "spreadDomain" ([], (String.to_xml f)))])
           @
           [Util.option_map v.host_resource_group_arn
              (fun f ->
                 Ezxmlm.make_tag "hostResourceGroupArn"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f -> ("host_resource_group_arn", (String.to_json f)));
           Util.option_map v.spread_domain
             (fun f -> ("spread_domain", (String.to_json f)));
           Util.option_map v.tenancy
             (fun f -> ("tenancy", (Tenancy.to_json f)));
           Util.option_map v.host_id
             (fun f -> ("host_id", (String.to_json f)));
           Util.option_map v.partition_number
             (fun f -> ("partition_number", (Integer.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.affinity
             (fun f -> ("affinity", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        affinity =
          (Util.option_map (Json.lookup j "affinity") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        partition_number =
          (Util.option_map (Json.lookup j "partition_number") Integer.of_json);
        host_id = (Util.option_map (Json.lookup j "host_id") String.of_json);
        tenancy = (Util.option_map (Json.lookup j "tenancy") Tenancy.of_json);
        spread_domain =
          (Util.option_map (Json.lookup j "spread_domain") String.of_json);
        host_resource_group_arn =
          (Util.option_map (Json.lookup j "host_resource_group_arn")
             String.of_json)
      }
  end
module InstanceLifecycle =
  struct
    type t =
      | Spot 
      | On_demand 
    let str_to_t = [("on-demand", On_demand); ("spot", Spot)]
    let t_to_str = [(On_demand, "on-demand"); (Spot, "spot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LaunchTemplateAndOverridesResponse =
  struct
    type t =
      {
      launch_template_specification:
        FleetLaunchTemplateSpecification.t option ;
      overrides: FleetLaunchTemplateOverrides.t option }
    let make ?launch_template_specification  ?overrides  () =
      { launch_template_specification; overrides }
    let parse xml =
      Some
        {
          launch_template_specification =
            (Util.option_bind (Xml.member "launchTemplateSpecification" xml)
               FleetLaunchTemplateSpecification.parse);
          overrides =
            (Util.option_bind (Xml.member "overrides" xml)
               FleetLaunchTemplateOverrides.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.overrides
              (fun f ->
                 Query.Pair
                   ("Overrides", (FleetLaunchTemplateOverrides.to_query f)));
           Util.option_map v.launch_template_specification
             (fun f ->
                Query.Pair
                  ("LaunchTemplateSpecification",
                    (FleetLaunchTemplateSpecification.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.launch_template_specification
               (fun f ->
                  Ezxmlm.make_tag "launchTemplateSpecification"
                    ([], (FleetLaunchTemplateSpecification.to_xml f)))])
           @
           [Util.option_map v.overrides
              (fun f ->
                 Ezxmlm.make_tag "overrides"
                   ([], (FleetLaunchTemplateOverrides.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.overrides
              (fun f ->
                 ("overrides", (FleetLaunchTemplateOverrides.to_json f)));
           Util.option_map v.launch_template_specification
             (fun f ->
                ("launch_template_specification",
                  (FleetLaunchTemplateSpecification.to_json f)))])
    let of_json j =
      {
        launch_template_specification =
          (Util.option_map (Json.lookup j "launch_template_specification")
             FleetLaunchTemplateSpecification.of_json);
        overrides =
          (Util.option_map (Json.lookup j "overrides")
             FleetLaunchTemplateOverrides.of_json)
      }
  end
module InstanceIdsSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PlatformValues =
  struct
    type t =
      | Windows 
    let str_to_t = [("Windows", Windows)]
    let t_to_str = [(Windows, "Windows")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FleetLaunchTemplateOverridesList =
  struct
    type t = FleetLaunchTemplateOverrides.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map FleetLaunchTemplateOverrides.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list FleetLaunchTemplateOverrides.to_query v
    let to_headers v =
      Headers.to_headers_list FleetLaunchTemplateOverrides.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (FleetLaunchTemplateOverrides.to_xml x))) v
    let to_json v = `List (List.map FleetLaunchTemplateOverrides.to_json v)
    let of_json j = Json.to_list FleetLaunchTemplateOverrides.of_json j
  end
module FleetCapacityReservationUsageStrategy =
  struct
    type t =
      | Use_capacity_reservations_first 
    let str_to_t =
      [("use-capacity-reservations-first", Use_capacity_reservations_first)]
    let t_to_str =
      [(Use_capacity_reservations_first, "use-capacity-reservations-first")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SpotFleetLaunchSpecification =
  struct
    type t =
      {
      security_groups: GroupIdentifierList.t ;
      addressing_type: String.t option ;
      block_device_mappings: BlockDeviceMappingList.t ;
      ebs_optimized: Boolean.t option ;
      iam_instance_profile: IamInstanceProfileSpecification.t option ;
      image_id: String.t option ;
      instance_type: InstanceType.t option ;
      kernel_id: String.t option ;
      key_name: String.t option ;
      monitoring: SpotFleetMonitoring.t option ;
      network_interfaces: InstanceNetworkInterfaceSpecificationList.t ;
      placement: SpotPlacement.t option ;
      ramdisk_id: String.t option ;
      spot_price: String.t option ;
      subnet_id: String.t option ;
      user_data: String.t option ;
      weighted_capacity: Double.t option ;
      tag_specifications: SpotFleetTagSpecificationList.t }
    let make ?(security_groups= [])  ?addressing_type 
      ?(block_device_mappings= [])  ?ebs_optimized  ?iam_instance_profile 
      ?image_id  ?instance_type  ?kernel_id  ?key_name  ?monitoring 
      ?(network_interfaces= [])  ?placement  ?ramdisk_id  ?spot_price 
      ?subnet_id  ?user_data  ?weighted_capacity  ?(tag_specifications= []) 
      () =
      {
        security_groups;
        addressing_type;
        block_device_mappings;
        ebs_optimized;
        iam_instance_profile;
        image_id;
        instance_type;
        kernel_id;
        key_name;
        monitoring;
        network_interfaces;
        placement;
        ramdisk_id;
        spot_price;
        subnet_id;
        user_data;
        weighted_capacity;
        tag_specifications
      }
    let parse xml =
      Some
        {
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          addressing_type =
            (Util.option_bind (Xml.member "addressingType" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml)
               SpotFleetMonitoring.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  InstanceNetworkInterfaceSpecificationList.parse));
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               SpotPlacement.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml) String.parse);
          weighted_capacity =
            (Util.option_bind (Xml.member "weightedCapacity" xml)
               Double.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSpecificationSet" xml)
                  SpotFleetTagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecificationSet",
                   (SpotFleetTagSpecificationList.to_query
                      v.tag_specifications)));
           Util.option_map v.weighted_capacity
             (fun f -> Query.Pair ("WeightedCapacity", (Double.to_query f)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (SpotPlacement.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (InstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair ("Monitoring", (SpotFleetMonitoring.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (IamInstanceProfileSpecification.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Util.option_map v.addressing_type
             (fun f -> Query.Pair ("AddressingType", (String.to_query f)));
           Some
             (Query.Pair
                ("GroupSet",
                  (GroupIdentifierList.to_query v.security_groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((([] @
                            (List.map
                               (fun x ->
                                  Some
                                    (Ezxmlm.make_tag "groupSet"
                                       ([], (GroupIdentifierList.to_xml [x]))))
                               v.security_groups))
                           @
                           [Util.option_map v.addressing_type
                              (fun f ->
                                 Ezxmlm.make_tag "addressingType"
                                   ([], (String.to_xml f)))])
                          @
                          (List.map
                             (fun x ->
                                Some
                                  (Ezxmlm.make_tag "blockDeviceMapping"
                                     ([],
                                       (BlockDeviceMappingList.to_xml [x]))))
                             v.block_device_mappings))
                         @
                         [Util.option_map v.ebs_optimized
                            (fun f ->
                               Ezxmlm.make_tag "ebsOptimized"
                                 ([], (Boolean.to_xml f)))])
                        @
                        [Util.option_map v.iam_instance_profile
                           (fun f ->
                              Ezxmlm.make_tag "iamInstanceProfile"
                                ([],
                                  (IamInstanceProfileSpecification.to_xml f)))])
                       @
                       [Util.option_map v.image_id
                          (fun f ->
                             Ezxmlm.make_tag "imageId"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.instance_type
                         (fun f ->
                            Ezxmlm.make_tag "instanceType"
                              ([], (InstanceType.to_xml f)))])
                     @
                     [Util.option_map v.kernel_id
                        (fun f ->
                           Ezxmlm.make_tag "kernelId" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.key_name
                       (fun f ->
                          Ezxmlm.make_tag "keyName" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.monitoring
                      (fun f ->
                         Ezxmlm.make_tag "monitoring"
                           ([], (SpotFleetMonitoring.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "networkInterfaceSet"
                             ([],
                               (InstanceNetworkInterfaceSpecificationList.to_xml
                                  [x])))) v.network_interfaces))
                 @
                 [Util.option_map v.placement
                    (fun f ->
                       Ezxmlm.make_tag "placement"
                         ([], (SpotPlacement.to_xml f)))])
                @
                [Util.option_map v.ramdisk_id
                   (fun f ->
                      Ezxmlm.make_tag "ramdiskId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.spot_price
                  (fun f ->
                     Ezxmlm.make_tag "spotPrice" ([], (String.to_xml f)))])
              @
              [Util.option_map v.subnet_id
                 (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.user_data
                (fun f -> Ezxmlm.make_tag "userData" ([], (String.to_xml f)))])
            @
            [Util.option_map v.weighted_capacity
               (fun f ->
                  Ezxmlm.make_tag "weightedCapacity" ([], (Double.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "tagSpecificationSet"
                      ([], (SpotFleetTagSpecificationList.to_xml [x]))))
              v.tag_specifications))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (SpotFleetTagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.weighted_capacity
             (fun f -> ("weighted_capacity", (Double.to_json f)));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (SpotPlacement.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Util.option_map v.monitoring
             (fun f -> ("monitoring", (SpotFleetMonitoring.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (IamInstanceProfileSpecification.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings));
           Util.option_map v.addressing_type
             (fun f -> ("addressing_type", (String.to_json f)));
           Some
             ("security_groups",
               (GroupIdentifierList.to_json v.security_groups))])
    let of_json j =
      {
        security_groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        addressing_type =
          (Util.option_map (Json.lookup j "addressing_type") String.of_json);
        block_device_mappings =
          (BlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfileSpecification.of_json);
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             SpotFleetMonitoring.of_json);
        network_interfaces =
          (InstanceNetworkInterfaceSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        placement =
          (Util.option_map (Json.lookup j "placement") SpotPlacement.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        spot_price =
          (Util.option_map (Json.lookup j "spot_price") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json);
        weighted_capacity =
          (Util.option_map (Json.lookup j "weighted_capacity") Double.of_json);
        tag_specifications =
          (SpotFleetTagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module LaunchTemplateConfig =
  struct
    type t =
      {
      launch_template_specification:
        FleetLaunchTemplateSpecification.t option ;
      overrides: LaunchTemplateOverridesList.t }
    let make ?launch_template_specification  ?(overrides= [])  () =
      { launch_template_specification; overrides }
    let parse xml =
      Some
        {
          launch_template_specification =
            (Util.option_bind (Xml.member "launchTemplateSpecification" xml)
               FleetLaunchTemplateSpecification.parse);
          overrides =
            (Util.of_option []
               (Util.option_bind (Xml.member "overrides" xml)
                  LaunchTemplateOverridesList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Overrides",
                   (LaunchTemplateOverridesList.to_query v.overrides)));
           Util.option_map v.launch_template_specification
             (fun f ->
                Query.Pair
                  ("LaunchTemplateSpecification",
                    (FleetLaunchTemplateSpecification.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.launch_template_specification
               (fun f ->
                  Ezxmlm.make_tag "launchTemplateSpecification"
                    ([], (FleetLaunchTemplateSpecification.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "overrides"
                      ([], (LaunchTemplateOverridesList.to_xml [x]))))
              v.overrides))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("overrides",
                (LaunchTemplateOverridesList.to_json v.overrides));
           Util.option_map v.launch_template_specification
             (fun f ->
                ("launch_template_specification",
                  (FleetLaunchTemplateSpecification.to_json f)))])
    let of_json j =
      {
        launch_template_specification =
          (Util.option_map (Json.lookup j "launch_template_specification")
             FleetLaunchTemplateSpecification.of_json);
        overrides =
          (LaunchTemplateOverridesList.of_json
             (Util.of_option_exn (Json.lookup j "overrides")))
      }
  end
module ClassicLoadBalancersConfig =
  struct
    type t = {
      classic_load_balancers: ClassicLoadBalancers.t }
    let make ?(classic_load_balancers= [])  () = { classic_load_balancers }
    let parse xml =
      Some
        {
          classic_load_balancers =
            (Util.of_option []
               (Util.option_bind (Xml.member "classicLoadBalancers" xml)
                  ClassicLoadBalancers.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ClassicLoadBalancers",
                   (ClassicLoadBalancers.to_query v.classic_load_balancers)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "classicLoadBalancers"
                      ([], (ClassicLoadBalancers.to_xml [x]))))
              v.classic_load_balancers))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("classic_load_balancers",
                (ClassicLoadBalancers.to_json v.classic_load_balancers))])
    let of_json j =
      {
        classic_load_balancers =
          (ClassicLoadBalancers.of_json
             (Util.of_option_exn (Json.lookup j "classic_load_balancers")))
      }
  end
module TargetGroupsConfig =
  struct
    type t = {
      target_groups: TargetGroups.t }
    let make ?(target_groups= [])  () = { target_groups }
    let parse xml =
      Some
        {
          target_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "targetGroups" xml)
                  TargetGroups.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TargetGroups", (TargetGroups.to_query v.target_groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "targetGroups"
                      ([], (TargetGroups.to_xml [x])))) v.target_groups))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("target_groups", (TargetGroups.to_json v.target_groups))])
    let of_json j =
      {
        target_groups =
          (TargetGroups.of_json
             (Util.of_option_exn (Json.lookup j "target_groups")))
      }
  end
module VolumeStatusDetails =
  struct
    type t = {
      name: VolumeStatusName.t option ;
      status: String.t option }
    let make ?name  ?status  () = { name; status }
    let parse xml =
      Some
        {
          name =
            (Util.option_bind (Xml.member "name" xml) VolumeStatusName.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (VolumeStatusName.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.name
               (fun f ->
                  Ezxmlm.make_tag "name" ([], (VolumeStatusName.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (String.to_json f)));
           Util.option_map v.name
             (fun f -> ("name", (VolumeStatusName.to_json f)))])
    let of_json j =
      {
        name =
          (Util.option_map (Json.lookup j "name") VolumeStatusName.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json)
      }
  end
module ArchitectureValues =
  struct
    type t =
      | I386 
      | X86_64 
      | Arm64 
    let str_to_t = [("arm64", Arm64); ("x86_64", X86_64); ("i386", I386)]
    let t_to_str = [(Arm64, "arm64"); (X86_64, "x86_64"); (I386, "i386")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CapacityReservationSpecificationResponse =
  struct
    type t =
      {
      capacity_reservation_preference: CapacityReservationPreference.t option ;
      capacity_reservation_target: CapacityReservationTargetResponse.t option }
    let make ?capacity_reservation_preference  ?capacity_reservation_target 
      () = { capacity_reservation_preference; capacity_reservation_target }
    let parse xml =
      Some
        {
          capacity_reservation_preference =
            (Util.option_bind
               (Xml.member "capacityReservationPreference" xml)
               CapacityReservationPreference.parse);
          capacity_reservation_target =
            (Util.option_bind (Xml.member "capacityReservationTarget" xml)
               CapacityReservationTargetResponse.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Query.Pair
                   ("CapacityReservationTarget",
                     (CapacityReservationTargetResponse.to_query f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                Query.Pair
                  ("CapacityReservationPreference",
                    (CapacityReservationPreference.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.capacity_reservation_preference
               (fun f ->
                  Ezxmlm.make_tag "capacityReservationPreference"
                    ([], (CapacityReservationPreference.to_xml f)))])
           @
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Ezxmlm.make_tag "capacityReservationTarget"
                   ([], (CapacityReservationTargetResponse.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 ("capacity_reservation_target",
                   (CapacityReservationTargetResponse.to_json f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                ("capacity_reservation_preference",
                  (CapacityReservationPreference.to_json f)))])
    let of_json j =
      {
        capacity_reservation_preference =
          (Util.option_map (Json.lookup j "capacity_reservation_preference")
             CapacityReservationPreference.of_json);
        capacity_reservation_target =
          (Util.option_map (Json.lookup j "capacity_reservation_target")
             CapacityReservationTargetResponse.of_json)
      }
  end
module CpuOptions =
  struct
    type t =
      {
      core_count: Integer.t option ;
      threads_per_core: Integer.t option }
    let make ?core_count  ?threads_per_core  () =
      { core_count; threads_per_core }
    let parse xml =
      Some
        {
          core_count =
            (Util.option_bind (Xml.member "coreCount" xml) Integer.parse);
          threads_per_core =
            (Util.option_bind (Xml.member "threadsPerCore" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> Query.Pair ("ThreadsPerCore", (Integer.to_query f)));
           Util.option_map v.core_count
             (fun f -> Query.Pair ("CoreCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.core_count
               (fun f -> Ezxmlm.make_tag "coreCount" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.threads_per_core
              (fun f ->
                 Ezxmlm.make_tag "threadsPerCore" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> ("threads_per_core", (Integer.to_json f)));
           Util.option_map v.core_count
             (fun f -> ("core_count", (Integer.to_json f)))])
    let of_json j =
      {
        core_count =
          (Util.option_map (Json.lookup j "core_count") Integer.of_json);
        threads_per_core =
          (Util.option_map (Json.lookup j "threads_per_core") Integer.of_json)
      }
  end
module DeviceType =
  struct
    type t =
      | Ebs 
      | Instance_store 
    let str_to_t = [("instance-store", Instance_store); ("ebs", Ebs)]
    let t_to_str = [(Instance_store, "instance-store"); (Ebs, "ebs")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ElasticGpuAssociationList =
  struct
    type t = ElasticGpuAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ElasticGpuAssociation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ElasticGpuAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list ElasticGpuAssociation.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ElasticGpuAssociation.to_xml x))) v
    let to_json v = `List (List.map ElasticGpuAssociation.to_json v)
    let of_json j = Json.to_list ElasticGpuAssociation.of_json j
  end
module ElasticInferenceAcceleratorAssociationList =
  struct
    type t = ElasticInferenceAcceleratorAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ElasticInferenceAcceleratorAssociation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ElasticInferenceAcceleratorAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list
        ElasticInferenceAcceleratorAssociation.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ElasticInferenceAcceleratorAssociation.to_xml x))) v
    let to_json v =
      `List (List.map ElasticInferenceAcceleratorAssociation.to_json v)
    let of_json j =
      Json.to_list ElasticInferenceAcceleratorAssociation.of_json j
  end
module HibernationOptions =
  struct
    type t = {
      configured: Boolean.t option }
    let make ?configured  () = { configured }
    let parse xml =
      Some
        {
          configured =
            (Util.option_bind (Xml.member "configured" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> Query.Pair ("Configured", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.configured
              (fun f -> Ezxmlm.make_tag "configured" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> ("configured", (Boolean.to_json f)))])
    let of_json j =
      {
        configured =
          (Util.option_map (Json.lookup j "configured") Boolean.of_json)
      }
  end
module HypervisorType =
  struct
    type t =
      | Ovm 
      | Xen 
    let str_to_t = [("xen", Xen); ("ovm", Ovm)]
    let t_to_str = [(Xen, "xen"); (Ovm, "ovm")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module IamInstanceProfile =
  struct
    type t = {
      arn: String.t option ;
      id: String.t option }
    let make ?arn  ?id  () = { arn; id }
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "arn" xml) String.parse);
          id = (Util.option_bind (Xml.member "id" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.id
              (fun f -> Query.Pair ("Id", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.arn
               (fun f -> Ezxmlm.make_tag "arn" ([], (String.to_xml f)))])
           @
           [Util.option_map v.id
              (fun f -> Ezxmlm.make_tag "id" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.id (fun f -> ("id", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      {
        arn = (Util.option_map (Json.lookup j "arn") String.of_json);
        id = (Util.option_map (Json.lookup j "id") String.of_json)
      }
  end
module InstanceBlockDeviceMappingList =
  struct
    type t = InstanceBlockDeviceMapping.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceBlockDeviceMapping.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list InstanceBlockDeviceMapping.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceBlockDeviceMapping.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InstanceBlockDeviceMapping.to_xml x))) v
    let to_json v = `List (List.map InstanceBlockDeviceMapping.to_json v)
    let of_json j = Json.to_list InstanceBlockDeviceMapping.of_json j
  end
module InstanceLifecycleType =
  struct
    type t =
      | Spot 
      | Scheduled 
    let str_to_t = [("scheduled", Scheduled); ("spot", Spot)]
    let t_to_str = [(Scheduled, "scheduled"); (Spot, "spot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceMetadataOptionsResponse =
  struct
    type t =
      {
      state: InstanceMetadataOptionsState.t option ;
      http_tokens: HttpTokensState.t option ;
      http_put_response_hop_limit: Integer.t option ;
      http_endpoint: InstanceMetadataEndpointState.t option }
    let make ?state  ?http_tokens  ?http_put_response_hop_limit 
      ?http_endpoint  () =
      { state; http_tokens; http_put_response_hop_limit; http_endpoint }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml)
               InstanceMetadataOptionsState.parse);
          http_tokens =
            (Util.option_bind (Xml.member "httpTokens" xml)
               HttpTokensState.parse);
          http_put_response_hop_limit =
            (Util.option_bind (Xml.member "httpPutResponseHopLimit" xml)
               Integer.parse);
          http_endpoint =
            (Util.option_bind (Xml.member "httpEndpoint" xml)
               InstanceMetadataEndpointState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.http_endpoint
              (fun f ->
                 Query.Pair
                   ("HttpEndpoint",
                     (InstanceMetadataEndpointState.to_query f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f ->
                Query.Pair ("HttpPutResponseHopLimit", (Integer.to_query f)));
           Util.option_map v.http_tokens
             (fun f ->
                Query.Pair ("HttpTokens", (HttpTokensState.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (InstanceMetadataOptionsState.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.state
                 (fun f ->
                    Ezxmlm.make_tag "state"
                      ([], (InstanceMetadataOptionsState.to_xml f)))])
             @
             [Util.option_map v.http_tokens
                (fun f ->
                   Ezxmlm.make_tag "httpTokens"
                     ([], (HttpTokensState.to_xml f)))])
            @
            [Util.option_map v.http_put_response_hop_limit
               (fun f ->
                  Ezxmlm.make_tag "httpPutResponseHopLimit"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.http_endpoint
              (fun f ->
                 Ezxmlm.make_tag "httpEndpoint"
                   ([], (InstanceMetadataEndpointState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.http_endpoint
              (fun f ->
                 ("http_endpoint", (InstanceMetadataEndpointState.to_json f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f -> ("http_put_response_hop_limit", (Integer.to_json f)));
           Util.option_map v.http_tokens
             (fun f -> ("http_tokens", (HttpTokensState.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (InstanceMetadataOptionsState.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state")
             InstanceMetadataOptionsState.of_json);
        http_tokens =
          (Util.option_map (Json.lookup j "http_tokens")
             HttpTokensState.of_json);
        http_put_response_hop_limit =
          (Util.option_map (Json.lookup j "http_put_response_hop_limit")
             Integer.of_json);
        http_endpoint =
          (Util.option_map (Json.lookup j "http_endpoint")
             InstanceMetadataEndpointState.of_json)
      }
  end
module InstanceNetworkInterfaceList =
  struct
    type t = InstanceNetworkInterface.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceNetworkInterface.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceNetworkInterface.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceNetworkInterface.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstanceNetworkInterface.to_xml x)))
        v
    let to_json v = `List (List.map InstanceNetworkInterface.to_json v)
    let of_json j = Json.to_list InstanceNetworkInterface.of_json j
  end
module InstanceState =
  struct
    type t = {
      code: Integer.t ;
      name: InstanceStateName.t }
    let make ~code  ~name  () = { code; name }
    let parse xml =
      Some
        {
          code =
            (Xml.required "code"
               (Util.option_bind (Xml.member "code" xml) Integer.parse));
          name =
            (Xml.required "name"
               (Util.option_bind (Xml.member "name" xml)
                  InstanceStateName.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Name", (InstanceStateName.to_query v.name)));
           Some (Query.Pair ("Code", (Integer.to_query v.code)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "code" ([], (Integer.to_xml v.code)))])
           @
           [Some
              (Ezxmlm.make_tag "name" ([], (InstanceStateName.to_xml v.name)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("name", (InstanceStateName.to_json v.name));
           Some ("code", (Integer.to_json v.code))])
    let of_json j =
      {
        code = (Integer.of_json (Util.of_option_exn (Json.lookup j "code")));
        name =
          (InstanceStateName.of_json
             (Util.of_option_exn (Json.lookup j "name")))
      }
  end
module LicenseList =
  struct
    type t = LicenseConfiguration.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LicenseConfiguration.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LicenseConfiguration.to_query v
    let to_headers v =
      Headers.to_headers_list LicenseConfiguration.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (LicenseConfiguration.to_xml x))) v
    let to_json v = `List (List.map LicenseConfiguration.to_json v)
    let of_json j = Json.to_list LicenseConfiguration.of_json j
  end
module Monitoring =
  struct
    type t = {
      state: MonitoringState.t option }
    let make ?state  () = { state }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml) MonitoringState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (MonitoringState.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state" ([], (MonitoringState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (MonitoringState.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state") MonitoringState.of_json)
      }
  end
module ProductCodeList =
  struct
    type t = ProductCode.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map ProductCode.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ProductCode.to_query v
    let to_headers v = Headers.to_headers_list ProductCode.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ProductCode.to_xml x))) v
    let to_json v = `List (List.map ProductCode.to_json v)
    let of_json j = Json.to_list ProductCode.of_json j
  end
module StateReason =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module VirtualizationType =
  struct
    type t =
      | Hvm 
      | Paravirtual 
    let str_to_t = [("paravirtual", Paravirtual); ("hvm", Hvm)]
    let t_to_str = [(Paravirtual, "paravirtual"); (Hvm, "hvm")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpcCidrBlockState =
  struct
    type t =
      {
      state: VpcCidrBlockStateCode.t option ;
      status_message: String.t option }
    let make ?state  ?status_message  () = { state; status_message }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml)
               VpcCidrBlockStateCode.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (VpcCidrBlockStateCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.state
               (fun f ->
                  Ezxmlm.make_tag "state"
                    ([], (VpcCidrBlockStateCode.to_xml f)))])
           @
           [Util.option_map v.status_message
              (fun f ->
                 Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (VpcCidrBlockStateCode.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state")
             VpcCidrBlockStateCode.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json)
      }
  end
module SubnetCidrBlockState =
  struct
    type t =
      {
      state: SubnetCidrBlockStateCode.t option ;
      status_message: String.t option }
    let make ?state  ?status_message  () = { state; status_message }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml)
               SubnetCidrBlockStateCode.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (SubnetCidrBlockStateCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.state
               (fun f ->
                  Ezxmlm.make_tag "state"
                    ([], (SubnetCidrBlockStateCode.to_xml f)))])
           @
           [Util.option_map v.status_message
              (fun f ->
                 Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (SubnetCidrBlockStateCode.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state")
             SubnetCidrBlockStateCode.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json)
      }
  end
module UserBucketDetails =
  struct
    type t = {
      s3_bucket: String.t option ;
      s3_key: String.t option }
    let make ?s3_bucket  ?s3_key  () = { s3_bucket; s3_key }
    let parse xml =
      Some
        {
          s3_bucket =
            (Util.option_bind (Xml.member "s3Bucket" xml) String.parse);
          s3_key = (Util.option_bind (Xml.member "s3Key" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> Query.Pair ("S3Key", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.s3_bucket
               (fun f -> Ezxmlm.make_tag "s3Bucket" ([], (String.to_xml f)))])
           @
           [Util.option_map v.s3_key
              (fun f -> Ezxmlm.make_tag "s3Key" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> ("s3_key", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)))])
    let of_json j =
      {
        s3_bucket =
          (Util.option_map (Json.lookup j "s3_bucket") String.of_json);
        s3_key = (Util.option_map (Json.lookup j "s3_key") String.of_json)
      }
  end
module ScheduledInstancesPrivateIpAddressConfig =
  struct
    type t =
      {
      primary: Boolean.t option ;
      private_ip_address: String.t option }
    let make ?primary  ?private_ip_address  () =
      { primary; private_ip_address }
    let parse xml =
      Some
        {
          primary =
            (Util.option_bind (Xml.member "Primary" xml) Boolean.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "PrivateIpAddress" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.primary
             (fun f -> Query.Pair ("Primary", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.primary
               (fun f -> Ezxmlm.make_tag "Primary" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.private_ip_address
              (fun f ->
                 Ezxmlm.make_tag "PrivateIpAddress" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.primary
             (fun f -> ("primary", (Boolean.to_json f)))])
    let of_json j =
      {
        primary = (Util.option_map (Json.lookup j "primary") Boolean.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json)
      }
  end
module ScheduledInstancesIpv6Address =
  struct
    type t = {
      ipv6_address: String.t option }
    let make ?ipv6_address  () = { ipv6_address }
    let parse xml =
      Some
        {
          ipv6_address =
            (Util.option_bind (Xml.member "Ipv6Address" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> Query.Pair ("Ipv6Address", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ipv6_address
              (fun f -> Ezxmlm.make_tag "Ipv6Address" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> ("ipv6_address", (String.to_json f)))])
    let of_json j =
      {
        ipv6_address =
          (Util.option_map (Json.lookup j "ipv6_address") String.of_json)
      }
  end
module DhcpConfiguration =
  struct
    type t = {
      key: String.t option ;
      values: DhcpConfigurationValueList.t }
    let make ?key  ?(values= [])  () = { key; values }
    let parse xml =
      Some
        {
          key = (Util.option_bind (Xml.member "key" xml) String.parse);
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "valueSet" xml)
                  DhcpConfigurationValueList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ValueSet", (DhcpConfigurationValueList.to_query v.values)));
           Util.option_map v.key
             (fun f -> Query.Pair ("Key", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.key
               (fun f -> Ezxmlm.make_tag "key" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "valueSet"
                      ([], (DhcpConfigurationValueList.to_xml [x]))))
              v.values))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (DhcpConfigurationValueList.to_json v.values));
           Util.option_map v.key (fun f -> ("key", (String.to_json f)))])
    let of_json j =
      {
        key = (Util.option_map (Json.lookup j "key") String.of_json);
        values =
          (DhcpConfigurationValueList.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module VpcAttachment =
  struct
    type t = {
      state: AttachmentStatus.t option ;
      vpc_id: String.t option }
    let make ?state  ?vpc_id  () = { state; vpc_id }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml) AttachmentStatus.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (AttachmentStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.state
               (fun f ->
                  Ezxmlm.make_tag "state" ([], (AttachmentStatus.to_xml f)))])
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (AttachmentStatus.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state") AttachmentStatus.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module ReservedInstancesModificationResult =
  struct
    type t =
      {
      reserved_instances_id: String.t option ;
      target_configuration: ReservedInstancesConfiguration.t option }
    let make ?reserved_instances_id  ?target_configuration  () =
      { reserved_instances_id; target_configuration }
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse);
          target_configuration =
            (Util.option_bind (Xml.member "targetConfiguration" xml)
               ReservedInstancesConfiguration.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.target_configuration
              (fun f ->
                 Query.Pair
                   ("TargetConfiguration",
                     (ReservedInstancesConfiguration.to_query f)));
           Util.option_map v.reserved_instances_id
             (fun f ->
                Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.reserved_instances_id
               (fun f ->
                  Ezxmlm.make_tag "reservedInstancesId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.target_configuration
              (fun f ->
                 Ezxmlm.make_tag "targetConfiguration"
                   ([], (ReservedInstancesConfiguration.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_configuration
              (fun f ->
                 ("target_configuration",
                   (ReservedInstancesConfiguration.to_json f)));
           Util.option_map v.reserved_instances_id
             (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json);
        target_configuration =
          (Util.option_map (Json.lookup j "target_configuration")
             ReservedInstancesConfiguration.of_json)
      }
  end
module ReservedInstancesId =
  struct
    type t = {
      reserved_instances_id: String.t option }
    let make ?reserved_instances_id  () = { reserved_instances_id }
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Ezxmlm.make_tag "reservedInstancesId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json)
      }
  end
module PermissionGroup =
  struct
    type t =
      | All 
    let str_to_t = [("all", All)]
    let t_to_str = [(All, "all")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DnsEntry =
  struct
    type t = {
      dns_name: String.t option ;
      hosted_zone_id: String.t option }
    let make ?dns_name  ?hosted_zone_id  () = { dns_name; hosted_zone_id }
    let parse xml =
      Some
        {
          dns_name =
            (Util.option_bind (Xml.member "dnsName" xml) String.parse);
          hosted_zone_id =
            (Util.option_bind (Xml.member "hostedZoneId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.hosted_zone_id
              (fun f -> Query.Pair ("HostedZoneId", (String.to_query f)));
           Util.option_map v.dns_name
             (fun f -> Query.Pair ("DnsName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dns_name
               (fun f -> Ezxmlm.make_tag "dnsName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.hosted_zone_id
              (fun f ->
                 Ezxmlm.make_tag "hostedZoneId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.hosted_zone_id
              (fun f -> ("hosted_zone_id", (String.to_json f)));
           Util.option_map v.dns_name
             (fun f -> ("dns_name", (String.to_json f)))])
    let of_json j =
      {
        dns_name =
          (Util.option_map (Json.lookup j "dns_name") String.of_json);
        hosted_zone_id =
          (Util.option_map (Json.lookup j "hosted_zone_id") String.of_json)
      }
  end
module TrafficMirrorFilterRule =
  struct
    type t =
      {
      traffic_mirror_filter_rule_id: String.t option ;
      traffic_mirror_filter_id: String.t option ;
      traffic_direction: TrafficDirection.t option ;
      rule_number: Integer.t option ;
      rule_action: TrafficMirrorRuleAction.t option ;
      protocol: Integer.t option ;
      destination_port_range: TrafficMirrorPortRange.t option ;
      source_port_range: TrafficMirrorPortRange.t option ;
      destination_cidr_block: String.t option ;
      source_cidr_block: String.t option ;
      description: String.t option }
    let make ?traffic_mirror_filter_rule_id  ?traffic_mirror_filter_id 
      ?traffic_direction  ?rule_number  ?rule_action  ?protocol 
      ?destination_port_range  ?source_port_range  ?destination_cidr_block 
      ?source_cidr_block  ?description  () =
      {
        traffic_mirror_filter_rule_id;
        traffic_mirror_filter_id;
        traffic_direction;
        rule_number;
        rule_action;
        protocol;
        destination_port_range;
        source_port_range;
        destination_cidr_block;
        source_cidr_block;
        description
      }
    let parse xml =
      Some
        {
          traffic_mirror_filter_rule_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterRuleId" xml)
               String.parse);
          traffic_mirror_filter_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterId" xml)
               String.parse);
          traffic_direction =
            (Util.option_bind (Xml.member "trafficDirection" xml)
               TrafficDirection.parse);
          rule_number =
            (Util.option_bind (Xml.member "ruleNumber" xml) Integer.parse);
          rule_action =
            (Util.option_bind (Xml.member "ruleAction" xml)
               TrafficMirrorRuleAction.parse);
          protocol =
            (Util.option_bind (Xml.member "protocol" xml) Integer.parse);
          destination_port_range =
            (Util.option_bind (Xml.member "destinationPortRange" xml)
               TrafficMirrorPortRange.parse);
          source_port_range =
            (Util.option_bind (Xml.member "sourcePortRange" xml)
               TrafficMirrorPortRange.parse);
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          source_cidr_block =
            (Util.option_bind (Xml.member "sourceCidrBlock" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.source_cidr_block
             (fun f -> Query.Pair ("SourceCidrBlock", (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)));
           Util.option_map v.source_port_range
             (fun f ->
                Query.Pair
                  ("SourcePortRange", (TrafficMirrorPortRange.to_query f)));
           Util.option_map v.destination_port_range
             (fun f ->
                Query.Pair
                  ("DestinationPortRange",
                    (TrafficMirrorPortRange.to_query f)));
           Util.option_map v.protocol
             (fun f -> Query.Pair ("Protocol", (Integer.to_query f)));
           Util.option_map v.rule_action
             (fun f ->
                Query.Pair
                  ("RuleAction", (TrafficMirrorRuleAction.to_query f)));
           Util.option_map v.rule_number
             (fun f -> Query.Pair ("RuleNumber", (Integer.to_query f)));
           Util.option_map v.traffic_direction
             (fun f ->
                Query.Pair
                  ("TrafficDirection", (TrafficDirection.to_query f)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f ->
                Query.Pair ("TrafficMirrorFilterId", (String.to_query f)));
           Util.option_map v.traffic_mirror_filter_rule_id
             (fun f ->
                Query.Pair ("TrafficMirrorFilterRuleId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.traffic_mirror_filter_rule_id
                        (fun f ->
                           Ezxmlm.make_tag "trafficMirrorFilterRuleId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.traffic_mirror_filter_id
                       (fun f ->
                          Ezxmlm.make_tag "trafficMirrorFilterId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.traffic_direction
                      (fun f ->
                         Ezxmlm.make_tag "trafficDirection"
                           ([], (TrafficDirection.to_xml f)))])
                  @
                  [Util.option_map v.rule_number
                     (fun f ->
                        Ezxmlm.make_tag "ruleNumber" ([], (Integer.to_xml f)))])
                 @
                 [Util.option_map v.rule_action
                    (fun f ->
                       Ezxmlm.make_tag "ruleAction"
                         ([], (TrafficMirrorRuleAction.to_xml f)))])
                @
                [Util.option_map v.protocol
                   (fun f ->
                      Ezxmlm.make_tag "protocol" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.destination_port_range
                  (fun f ->
                     Ezxmlm.make_tag "destinationPortRange"
                       ([], (TrafficMirrorPortRange.to_xml f)))])
              @
              [Util.option_map v.source_port_range
                 (fun f ->
                    Ezxmlm.make_tag "sourcePortRange"
                      ([], (TrafficMirrorPortRange.to_xml f)))])
             @
             [Util.option_map v.destination_cidr_block
                (fun f ->
                   Ezxmlm.make_tag "destinationCidrBlock"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.source_cidr_block
               (fun f ->
                  Ezxmlm.make_tag "sourceCidrBlock" ([], (String.to_xml f)))])
           @
           [Util.option_map v.description
              (fun f -> Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.source_cidr_block
             (fun f -> ("source_cidr_block", (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)));
           Util.option_map v.source_port_range
             (fun f ->
                ("source_port_range", (TrafficMirrorPortRange.to_json f)));
           Util.option_map v.destination_port_range
             (fun f ->
                ("destination_port_range",
                  (TrafficMirrorPortRange.to_json f)));
           Util.option_map v.protocol
             (fun f -> ("protocol", (Integer.to_json f)));
           Util.option_map v.rule_action
             (fun f -> ("rule_action", (TrafficMirrorRuleAction.to_json f)));
           Util.option_map v.rule_number
             (fun f -> ("rule_number", (Integer.to_json f)));
           Util.option_map v.traffic_direction
             (fun f -> ("traffic_direction", (TrafficDirection.to_json f)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f -> ("traffic_mirror_filter_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_filter_rule_id
             (fun f -> ("traffic_mirror_filter_rule_id", (String.to_json f)))])
    let of_json j =
      {
        traffic_mirror_filter_rule_id =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_rule_id")
             String.of_json);
        traffic_mirror_filter_id =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_id")
             String.of_json);
        traffic_direction =
          (Util.option_map (Json.lookup j "traffic_direction")
             TrafficDirection.of_json);
        rule_number =
          (Util.option_map (Json.lookup j "rule_number") Integer.of_json);
        rule_action =
          (Util.option_map (Json.lookup j "rule_action")
             TrafficMirrorRuleAction.of_json);
        protocol =
          (Util.option_map (Json.lookup j "protocol") Integer.of_json);
        destination_port_range =
          (Util.option_map (Json.lookup j "destination_port_range")
             TrafficMirrorPortRange.of_json);
        source_port_range =
          (Util.option_map (Json.lookup j "source_port_range")
             TrafficMirrorPortRange.of_json);
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        source_cidr_block =
          (Util.option_map (Json.lookup j "source_cidr_block") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module TrafficMirrorNetworkService =
  struct
    type t =
      | Amazon_dns 
    let str_to_t = [("amazon-dns", Amazon_dns)]
    let t_to_str = [(Amazon_dns, "amazon-dns")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AutoAcceptSharedAttachmentsValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DefaultRouteTableAssociationValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DefaultRouteTablePropagationValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DnsSupportValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module MulticastSupportValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpnEcmpSupportValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceCount =
  struct
    type t =
      {
      instance_count: Integer.t option ;
      state: ListingState.t option }
    let make ?instance_count  ?state  () = { instance_count; state }
    let parse xml =
      Some
        {
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) ListingState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (ListingState.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_count
               (fun f ->
                  Ezxmlm.make_tag "instanceCount" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f -> Ezxmlm.make_tag "state" ([], (ListingState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (ListingState.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)))])
    let of_json j =
      {
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        state =
          (Util.option_map (Json.lookup j "state") ListingState.of_json)
      }
  end
module PriceSchedule =
  struct
    type t =
      {
      active: Boolean.t option ;
      currency_code: CurrencyCodeValues.t option ;
      price: Double.t option ;
      term: Long.t option }
    let make ?active  ?currency_code  ?price  ?term  () =
      { active; currency_code; price; term }
    let parse xml =
      Some
        {
          active = (Util.option_bind (Xml.member "active" xml) Boolean.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          price = (Util.option_bind (Xml.member "price" xml) Double.parse);
          term = (Util.option_bind (Xml.member "term" xml) Long.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.term
              (fun f -> Query.Pair ("Term", (Long.to_query f)));
           Util.option_map v.price
             (fun f -> Query.Pair ("Price", (Double.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.active
             (fun f -> Query.Pair ("Active", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.active
                 (fun f -> Ezxmlm.make_tag "active" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.currency_code
                (fun f ->
                   Ezxmlm.make_tag "currencyCode"
                     ([], (CurrencyCodeValues.to_xml f)))])
            @
            [Util.option_map v.price
               (fun f -> Ezxmlm.make_tag "price" ([], (Double.to_xml f)))])
           @
           [Util.option_map v.term
              (fun f -> Ezxmlm.make_tag "term" ([], (Long.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.term (fun f -> ("term", (Long.to_json f)));
           Util.option_map v.price (fun f -> ("price", (Double.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.active
             (fun f -> ("active", (Boolean.to_json f)))])
    let of_json j =
      {
        active = (Util.option_map (Json.lookup j "active") Boolean.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        price = (Util.option_map (Json.lookup j "price") Double.of_json);
        term = (Util.option_map (Json.lookup j "term") Long.of_json)
      }
  end
module ClientVpnConnectionStatusCode =
  struct
    type t =
      | Active 
      | Failed_to_terminate 
      | Terminating 
      | Terminated 
    let str_to_t =
      [("terminated", Terminated);
      ("terminating", Terminating);
      ("failed-to-terminate", Failed_to_terminate);
      ("active", Active)]
    let t_to_str =
      [(Terminated, "terminated");
      (Terminating, "terminating");
      (Failed_to_terminate, "failed-to-terminate");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceStatusEvent =
  struct
    type t =
      {
      instance_event_id: String.t option ;
      code: EventCode.t option ;
      description: String.t option ;
      not_after: DateTime.t option ;
      not_before: DateTime.t option ;
      not_before_deadline: DateTime.t option }
    let make ?instance_event_id  ?code  ?description  ?not_after  ?not_before
       ?not_before_deadline  () =
      {
        instance_event_id;
        code;
        description;
        not_after;
        not_before;
        not_before_deadline
      }
    let parse xml =
      Some
        {
          instance_event_id =
            (Util.option_bind (Xml.member "instanceEventId" xml) String.parse);
          code = (Util.option_bind (Xml.member "code" xml) EventCode.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          not_after =
            (Util.option_bind (Xml.member "notAfter" xml) DateTime.parse);
          not_before =
            (Util.option_bind (Xml.member "notBefore" xml) DateTime.parse);
          not_before_deadline =
            (Util.option_bind (Xml.member "notBeforeDeadline" xml)
               DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.not_before_deadline
              (fun f ->
                 Query.Pair ("NotBeforeDeadline", (DateTime.to_query f)));
           Util.option_map v.not_before
             (fun f -> Query.Pair ("NotBefore", (DateTime.to_query f)));
           Util.option_map v.not_after
             (fun f -> Query.Pair ("NotAfter", (DateTime.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (EventCode.to_query f)));
           Util.option_map v.instance_event_id
             (fun f -> Query.Pair ("InstanceEventId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.instance_event_id
                   (fun f ->
                      Ezxmlm.make_tag "instanceEventId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.code
                  (fun f -> Ezxmlm.make_tag "code" ([], (EventCode.to_xml f)))])
              @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
             @
             [Util.option_map v.not_after
                (fun f ->
                   Ezxmlm.make_tag "notAfter" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.not_before
               (fun f ->
                  Ezxmlm.make_tag "notBefore" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.not_before_deadline
              (fun f ->
                 Ezxmlm.make_tag "notBeforeDeadline"
                   ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.not_before_deadline
              (fun f -> ("not_before_deadline", (DateTime.to_json f)));
           Util.option_map v.not_before
             (fun f -> ("not_before", (DateTime.to_json f)));
           Util.option_map v.not_after
             (fun f -> ("not_after", (DateTime.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (EventCode.to_json f)));
           Util.option_map v.instance_event_id
             (fun f -> ("instance_event_id", (String.to_json f)))])
    let of_json j =
      {
        instance_event_id =
          (Util.option_map (Json.lookup j "instance_event_id") String.of_json);
        code = (Util.option_map (Json.lookup j "code") EventCode.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        not_after =
          (Util.option_map (Json.lookup j "not_after") DateTime.of_json);
        not_before =
          (Util.option_map (Json.lookup j "not_before") DateTime.of_json);
        not_before_deadline =
          (Util.option_map (Json.lookup j "not_before_deadline")
             DateTime.of_json)
      }
  end
module InstanceStatusDetailsList =
  struct
    type t = InstanceStatusDetails.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceStatusDetails.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceStatusDetails.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceStatusDetails.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstanceStatusDetails.to_xml x))) v
    let to_json v = `List (List.map InstanceStatusDetails.to_json v)
    let of_json j = Json.to_list InstanceStatusDetails.of_json j
  end
module SummaryStatus =
  struct
    type t =
      | Ok 
      | Impaired 
      | Insufficient_data 
      | Not_applicable 
      | Initializing 
    let str_to_t =
      [("initializing", Initializing);
      ("not-applicable", Not_applicable);
      ("insufficient-data", Insufficient_data);
      ("impaired", Impaired);
      ("ok", Ok)]
    let t_to_str =
      [(Initializing, "initializing");
      (Not_applicable, "not-applicable");
      (Insufficient_data, "insufficient-data");
      (Impaired, "impaired");
      (Ok, "ok")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NetworkInterfacePermissionStateCode =
  struct
    type t =
      | Pending 
      | Granted 
      | Revoking 
      | Revoked 
    let str_to_t =
      [("revoked", Revoked);
      ("revoking", Revoking);
      ("granted", Granted);
      ("pending", Pending)]
    let t_to_str =
      [(Revoked, "revoked");
      (Revoking, "revoking");
      (Granted, "granted");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AvailableInstanceCapacityList =
  struct
    type t = InstanceCapacity.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceCapacity.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceCapacity.to_query v
    let to_headers v = Headers.to_headers_list InstanceCapacity.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InstanceCapacity.to_xml x)))
        v
    let to_json v = `List (List.map InstanceCapacity.to_json v)
    let of_json j = Json.to_list InstanceCapacity.of_json j
  end
module HostInstance =
  struct
    type t =
      {
      instance_id: String.t option ;
      instance_type: String.t option ;
      owner_id: String.t option }
    let make ?instance_id  ?instance_type  ?owner_id  () =
      { instance_id; instance_type; owner_id }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.instance_id
                (fun f ->
                   Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.instance_type
               (fun f ->
                  Ezxmlm.make_tag "instanceType" ([], (String.to_xml f)))])
           @
           [Util.option_map v.owner_id
              (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json)
      }
  end
module TransitGatewayMulitcastDomainAssociationState =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
    let str_to_t =
      [("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module IdFormat =
  struct
    type t =
      {
      deadline: DateTime.t option ;
      resource: String.t option ;
      use_long_ids: Boolean.t option }
    let make ?deadline  ?resource  ?use_long_ids  () =
      { deadline; resource; use_long_ids }
    let parse xml =
      Some
        {
          deadline =
            (Util.option_bind (Xml.member "deadline" xml) DateTime.parse);
          resource =
            (Util.option_bind (Xml.member "resource" xml) String.parse);
          use_long_ids =
            (Util.option_bind (Xml.member "useLongIds" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.use_long_ids
              (fun f -> Query.Pair ("UseLongIds", (Boolean.to_query f)));
           Util.option_map v.resource
             (fun f -> Query.Pair ("Resource", (String.to_query f)));
           Util.option_map v.deadline
             (fun f -> Query.Pair ("Deadline", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.deadline
                (fun f ->
                   Ezxmlm.make_tag "deadline" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.resource
               (fun f -> Ezxmlm.make_tag "resource" ([], (String.to_xml f)))])
           @
           [Util.option_map v.use_long_ids
              (fun f -> Ezxmlm.make_tag "useLongIds" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.use_long_ids
              (fun f -> ("use_long_ids", (Boolean.to_json f)));
           Util.option_map v.resource
             (fun f -> ("resource", (String.to_json f)));
           Util.option_map v.deadline
             (fun f -> ("deadline", (DateTime.to_json f)))])
    let of_json j =
      {
        deadline =
          (Util.option_map (Json.lookup j "deadline") DateTime.of_json);
        resource =
          (Util.option_map (Json.lookup j "resource") String.of_json);
        use_long_ids =
          (Util.option_map (Json.lookup j "use_long_ids") Boolean.of_json)
      }
  end
module DeleteFleetErrorCode =
  struct
    type t =
      | FleetIdDoesNotExist 
      | FleetIdMalformed 
      | FleetNotInDeletableState 
      | UnexpectedError 
    let str_to_t =
      [("unexpectedError", UnexpectedError);
      ("fleetNotInDeletableState", FleetNotInDeletableState);
      ("fleetIdMalformed", FleetIdMalformed);
      ("fleetIdDoesNotExist", FleetIdDoesNotExist)]
    let t_to_str =
      [(UnexpectedError, "unexpectedError");
      (FleetNotInDeletableState, "fleetNotInDeletableState");
      (FleetIdMalformed, "fleetIdMalformed");
      (FleetIdDoesNotExist, "fleetIdDoesNotExist")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DisableFastSnapshotRestoreStateErrorItem =
  struct
    type t =
      {
      availability_zone: String.t option ;
      error: DisableFastSnapshotRestoreStateError.t option }
    let make ?availability_zone  ?error  () = { availability_zone; error }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          error =
            (Util.option_bind (Xml.member "error" xml)
               DisableFastSnapshotRestoreStateError.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 Query.Pair
                   ("Error",
                     (DisableFastSnapshotRestoreStateError.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.availability_zone
               (fun f ->
                  Ezxmlm.make_tag "availabilityZone" ([], (String.to_xml f)))])
           @
           [Util.option_map v.error
              (fun f ->
                 Ezxmlm.make_tag "error"
                   ([], (DisableFastSnapshotRestoreStateError.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 ("error", (DisableFastSnapshotRestoreStateError.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        error =
          (Util.option_map (Json.lookup j "error")
             DisableFastSnapshotRestoreStateError.of_json)
      }
  end
module OccurrenceDaySet =
  struct
    type t = Integer.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Integer.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Integer.to_query v
    let to_headers v = Headers.to_headers_list Integer.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Integer.to_xml x))) v
    let to_json v = `List (List.map Integer.to_json v)
    let of_json j = Json.to_list Integer.of_json j
  end
module S3Storage =
  struct
    type t =
      {
      a_w_s_access_key_id: String.t option ;
      bucket: String.t option ;
      prefix: String.t option ;
      upload_policy: Blob.t option ;
      upload_policy_signature: String.t option }
    let make ?a_w_s_access_key_id  ?bucket  ?prefix  ?upload_policy 
      ?upload_policy_signature  () =
      {
        a_w_s_access_key_id;
        bucket;
        prefix;
        upload_policy;
        upload_policy_signature
      }
    let parse xml =
      Some
        {
          a_w_s_access_key_id =
            (Util.option_bind (Xml.member "AWSAccessKeyId" xml) String.parse);
          bucket = (Util.option_bind (Xml.member "bucket" xml) String.parse);
          prefix = (Util.option_bind (Xml.member "prefix" xml) String.parse);
          upload_policy =
            (Util.option_bind (Xml.member "uploadPolicy" xml) Blob.parse);
          upload_policy_signature =
            (Util.option_bind (Xml.member "uploadPolicySignature" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.upload_policy_signature
              (fun f ->
                 Query.Pair ("UploadPolicySignature", (String.to_query f)));
           Util.option_map v.upload_policy
             (fun f -> Query.Pair ("UploadPolicy", (Blob.to_query f)));
           Util.option_map v.prefix
             (fun f -> Query.Pair ("Prefix", (String.to_query f)));
           Util.option_map v.bucket
             (fun f -> Query.Pair ("Bucket", (String.to_query f)));
           Util.option_map v.a_w_s_access_key_id
             (fun f -> Query.Pair ("AWSAccessKeyId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.a_w_s_access_key_id
                  (fun f ->
                     Ezxmlm.make_tag "AWSAccessKeyId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.bucket
                 (fun f -> Ezxmlm.make_tag "bucket" ([], (String.to_xml f)))])
             @
             [Util.option_map v.prefix
                (fun f -> Ezxmlm.make_tag "prefix" ([], (String.to_xml f)))])
            @
            [Util.option_map v.upload_policy
               (fun f -> Ezxmlm.make_tag "uploadPolicy" ([], (Blob.to_xml f)))])
           @
           [Util.option_map v.upload_policy_signature
              (fun f ->
                 Ezxmlm.make_tag "uploadPolicySignature"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.upload_policy_signature
              (fun f -> ("upload_policy_signature", (String.to_json f)));
           Util.option_map v.upload_policy
             (fun f -> ("upload_policy", (Blob.to_json f)));
           Util.option_map v.prefix (fun f -> ("prefix", (String.to_json f)));
           Util.option_map v.bucket (fun f -> ("bucket", (String.to_json f)));
           Util.option_map v.a_w_s_access_key_id
             (fun f -> ("a_w_s_access_key_id", (String.to_json f)))])
    let of_json j =
      {
        a_w_s_access_key_id =
          (Util.option_map (Json.lookup j "a_w_s_access_key_id")
             String.of_json);
        bucket = (Util.option_map (Json.lookup j "bucket") String.of_json);
        prefix = (Util.option_map (Json.lookup j "prefix") String.of_json);
        upload_policy =
          (Util.option_map (Json.lookup j "upload_policy") Blob.of_json);
        upload_policy_signature =
          (Util.option_map (Json.lookup j "upload_policy_signature")
             String.of_json)
      }
  end
module StaleIpPermission =
  struct
    type t =
      {
      from_port: Integer.t option ;
      ip_protocol: String.t option ;
      ip_ranges: IpRanges.t ;
      prefix_list_ids: PrefixListIdSet.t ;
      to_port: Integer.t option ;
      user_id_group_pairs: UserIdGroupPairSet.t }
    let make ?from_port  ?ip_protocol  ?(ip_ranges= [])  ?(prefix_list_ids=
      [])  ?to_port  ?(user_id_group_pairs= [])  () =
      {
        from_port;
        ip_protocol;
        ip_ranges;
        prefix_list_ids;
        to_port;
        user_id_group_pairs
      }
    let parse xml =
      Some
        {
          from_port =
            (Util.option_bind (Xml.member "fromPort" xml) Integer.parse);
          ip_protocol =
            (Util.option_bind (Xml.member "ipProtocol" xml) String.parse);
          ip_ranges =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipRanges" xml) IpRanges.parse));
          prefix_list_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "prefixListIds" xml)
                  PrefixListIdSet.parse));
          to_port =
            (Util.option_bind (Xml.member "toPort" xml) Integer.parse);
          user_id_group_pairs =
            (Util.of_option []
               (Util.option_bind (Xml.member "groups" xml)
                  UserIdGroupPairSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Groups",
                   (UserIdGroupPairSet.to_query v.user_id_group_pairs)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrefixListIds",
                  (PrefixListIdSet.to_query v.prefix_list_ids)));
           Some (Query.Pair ("IpRanges", (IpRanges.to_query v.ip_ranges)));
           Util.option_map v.ip_protocol
             (fun f -> Query.Pair ("IpProtocol", (String.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.from_port
                   (fun f ->
                      Ezxmlm.make_tag "fromPort" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.ip_protocol
                  (fun f ->
                     Ezxmlm.make_tag "ipProtocol" ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "ipRanges" ([], (IpRanges.to_xml [x]))))
                 v.ip_ranges))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "prefixListIds"
                        ([], (PrefixListIdSet.to_xml [x]))))
                v.prefix_list_ids))
            @
            [Util.option_map v.to_port
               (fun f -> Ezxmlm.make_tag "toPort" ([], (Integer.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "groups"
                      ([], (UserIdGroupPairSet.to_xml [x]))))
              v.user_id_group_pairs))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("user_id_group_pairs",
                (UserIdGroupPairSet.to_json v.user_id_group_pairs));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Some
             ("prefix_list_ids", (PrefixListIdSet.to_json v.prefix_list_ids));
           Some ("ip_ranges", (IpRanges.to_json v.ip_ranges));
           Util.option_map v.ip_protocol
             (fun f -> ("ip_protocol", (String.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)))])
    let of_json j =
      {
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        ip_protocol =
          (Util.option_map (Json.lookup j "ip_protocol") String.of_json);
        ip_ranges =
          (IpRanges.of_json (Util.of_option_exn (Json.lookup j "ip_ranges")));
        prefix_list_ids =
          (PrefixListIdSet.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_ids")));
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        user_id_group_pairs =
          (UserIdGroupPairSet.of_json
             (Util.of_option_exn (Json.lookup j "user_id_group_pairs")))
      }
  end
module VolumeAttachment =
  struct
    type t =
      {
      attach_time: DateTime.t option ;
      device: String.t option ;
      instance_id: String.t option ;
      state: VolumeAttachmentState.t option ;
      volume_id: String.t option ;
      delete_on_termination: Boolean.t option }
    let make ?attach_time  ?device  ?instance_id  ?state  ?volume_id 
      ?delete_on_termination  () =
      {
        attach_time;
        device;
        instance_id;
        state;
        volume_id;
        delete_on_termination
      }
    let parse xml =
      Some
        {
          attach_time =
            (Util.option_bind (Xml.member "attachTime" xml) DateTime.parse);
          device = (Util.option_bind (Xml.member "device" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "status" xml)
               VolumeAttachmentState.parse);
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f ->
                 Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("Status", (VolumeAttachmentState.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.device
             (fun f -> Query.Pair ("Device", (String.to_query f)));
           Util.option_map v.attach_time
             (fun f -> Query.Pair ("AttachTime", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.attach_time
                   (fun f ->
                      Ezxmlm.make_tag "attachTime" ([], (DateTime.to_xml f)))])
               @
               [Util.option_map v.device
                  (fun f -> Ezxmlm.make_tag "device" ([], (String.to_xml f)))])
              @
              [Util.option_map v.instance_id
                 (fun f ->
                    Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.state
                (fun f ->
                   Ezxmlm.make_tag "status"
                     ([], (VolumeAttachmentState.to_xml f)))])
            @
            [Util.option_map v.volume_id
               (fun f -> Ezxmlm.make_tag "volumeId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.delete_on_termination
              (fun f ->
                 Ezxmlm.make_tag "deleteOnTermination"
                   ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (VolumeAttachmentState.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.device (fun f -> ("device", (String.to_json f)));
           Util.option_map v.attach_time
             (fun f -> ("attach_time", (DateTime.to_json f)))])
    let of_json j =
      {
        attach_time =
          (Util.option_map (Json.lookup j "attach_time") DateTime.of_json);
        device = (Util.option_map (Json.lookup j "device") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             VolumeAttachmentState.of_json);
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json)
      }
  end
module IKEVersionsRequestList =
  struct
    type t = IKEVersionsRequestListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map IKEVersionsRequestListValue.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list IKEVersionsRequestListValue.to_query v
    let to_headers v =
      Headers.to_headers_list IKEVersionsRequestListValue.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (IKEVersionsRequestListValue.to_xml x))) v
    let to_json v = `List (List.map IKEVersionsRequestListValue.to_json v)
    let of_json j = Json.to_list IKEVersionsRequestListValue.of_json j
  end
module Phase1DHGroupNumbersRequestList =
  struct
    type t = Phase1DHGroupNumbersRequestListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase1DHGroupNumbersRequestListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase1DHGroupNumbersRequestListValue.to_query v
    let to_headers v =
      Headers.to_headers_list Phase1DHGroupNumbersRequestListValue.to_headers
        v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase1DHGroupNumbersRequestListValue.to_xml x))) v
    let to_json v =
      `List (List.map Phase1DHGroupNumbersRequestListValue.to_json v)
    let of_json j =
      Json.to_list Phase1DHGroupNumbersRequestListValue.of_json j
  end
module Phase1EncryptionAlgorithmsRequestList =
  struct
    type t = Phase1EncryptionAlgorithmsRequestListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase1EncryptionAlgorithmsRequestListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase1EncryptionAlgorithmsRequestListValue.to_query
        v
    let to_headers v =
      Headers.to_headers_list
        Phase1EncryptionAlgorithmsRequestListValue.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase1EncryptionAlgorithmsRequestListValue.to_xml x))) v
    let to_json v =
      `List (List.map Phase1EncryptionAlgorithmsRequestListValue.to_json v)
    let of_json j =
      Json.to_list Phase1EncryptionAlgorithmsRequestListValue.of_json j
  end
module Phase1IntegrityAlgorithmsRequestList =
  struct
    type t = Phase1IntegrityAlgorithmsRequestListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase1IntegrityAlgorithmsRequestListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase1IntegrityAlgorithmsRequestListValue.to_query
        v
    let to_headers v =
      Headers.to_headers_list
        Phase1IntegrityAlgorithmsRequestListValue.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase1IntegrityAlgorithmsRequestListValue.to_xml x))) v
    let to_json v =
      `List (List.map Phase1IntegrityAlgorithmsRequestListValue.to_json v)
    let of_json j =
      Json.to_list Phase1IntegrityAlgorithmsRequestListValue.of_json j
  end
module Phase2DHGroupNumbersRequestList =
  struct
    type t = Phase2DHGroupNumbersRequestListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase2DHGroupNumbersRequestListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase2DHGroupNumbersRequestListValue.to_query v
    let to_headers v =
      Headers.to_headers_list Phase2DHGroupNumbersRequestListValue.to_headers
        v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase2DHGroupNumbersRequestListValue.to_xml x))) v
    let to_json v =
      `List (List.map Phase2DHGroupNumbersRequestListValue.to_json v)
    let of_json j =
      Json.to_list Phase2DHGroupNumbersRequestListValue.of_json j
  end
module Phase2EncryptionAlgorithmsRequestList =
  struct
    type t = Phase2EncryptionAlgorithmsRequestListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase2EncryptionAlgorithmsRequestListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase2EncryptionAlgorithmsRequestListValue.to_query
        v
    let to_headers v =
      Headers.to_headers_list
        Phase2EncryptionAlgorithmsRequestListValue.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase2EncryptionAlgorithmsRequestListValue.to_xml x))) v
    let to_json v =
      `List (List.map Phase2EncryptionAlgorithmsRequestListValue.to_json v)
    let of_json j =
      Json.to_list Phase2EncryptionAlgorithmsRequestListValue.of_json j
  end
module Phase2IntegrityAlgorithmsRequestList =
  struct
    type t = Phase2IntegrityAlgorithmsRequestListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase2IntegrityAlgorithmsRequestListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase2IntegrityAlgorithmsRequestListValue.to_query
        v
    let to_headers v =
      Headers.to_headers_list
        Phase2IntegrityAlgorithmsRequestListValue.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (Phase2IntegrityAlgorithmsRequestListValue.to_xml x))) v
    let to_json v =
      `List (List.map Phase2IntegrityAlgorithmsRequestListValue.to_json v)
    let of_json j =
      Json.to_list Phase2IntegrityAlgorithmsRequestListValue.of_json j
  end
module EbsEncryptionSupport =
  struct
    type t =
      | Unsupported 
      | Supported 
    let str_to_t = [("supported", Supported); ("unsupported", Unsupported)]
    let t_to_str = [(Supported, "supported"); (Unsupported, "unsupported")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EbsOptimizedSupport =
  struct
    type t =
      | Unsupported 
      | Supported 
      | Default 
    let str_to_t =
      [("default", Default);
      ("supported", Supported);
      ("unsupported", Unsupported)]
    let t_to_str =
      [(Default, "default");
      (Supported, "supported");
      (Unsupported, "unsupported")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FpgaDeviceInfoList =
  struct
    type t = FpgaDeviceInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map FpgaDeviceInfo.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list FpgaDeviceInfo.to_query v
    let to_headers v = Headers.to_headers_list FpgaDeviceInfo.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (FpgaDeviceInfo.to_xml x))) v
    let to_json v = `List (List.map FpgaDeviceInfo.to_json v)
    let of_json j = Json.to_list FpgaDeviceInfo.of_json j
  end
module GpuDeviceInfoList =
  struct
    type t = GpuDeviceInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map GpuDeviceInfo.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list GpuDeviceInfo.to_query v
    let to_headers v = Headers.to_headers_list GpuDeviceInfo.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (GpuDeviceInfo.to_xml x))) v
    let to_json v = `List (List.map GpuDeviceInfo.to_json v)
    let of_json j = Json.to_list GpuDeviceInfo.of_json j
  end
module InferenceDeviceInfoList =
  struct
    type t = InferenceDeviceInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InferenceDeviceInfo.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InferenceDeviceInfo.to_query v
    let to_headers v =
      Headers.to_headers_list InferenceDeviceInfo.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InferenceDeviceInfo.to_xml x))) v
    let to_json v = `List (List.map InferenceDeviceInfo.to_json v)
    let of_json j = Json.to_list InferenceDeviceInfo.of_json j
  end
module DiskInfoList =
  struct
    type t = DiskInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map DiskInfo.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DiskInfo.to_query v
    let to_headers v = Headers.to_headers_list DiskInfo.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (DiskInfo.to_xml x)))
        v
    let to_json v = `List (List.map DiskInfo.to_json v)
    let of_json j = Json.to_list DiskInfo.of_json j
  end
module EnaSupport =
  struct
    type t =
      | Unsupported 
      | Supported 
      | Required 
    let str_to_t =
      [("required", Required);
      ("supported", Supported);
      ("unsupported", Unsupported)]
    let t_to_str =
      [(Required, "required");
      (Supported, "supported");
      (Unsupported, "unsupported")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PlacementGroupStrategyList =
  struct
    type t = PlacementGroupStrategy.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PlacementGroupStrategy.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PlacementGroupStrategy.to_query v
    let to_headers v =
      Headers.to_headers_list PlacementGroupStrategy.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (PlacementGroupStrategy.to_xml x)))
        v
    let to_json v = `List (List.map PlacementGroupStrategy.to_json v)
    let of_json j = Json.to_list PlacementGroupStrategy.of_json j
  end
module ArchitectureTypeList =
  struct
    type t = ArchitectureType.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ArchitectureType.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ArchitectureType.to_query v
    let to_headers v = Headers.to_headers_list ArchitectureType.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ArchitectureType.to_xml x)))
        v
    let to_json v = `List (List.map ArchitectureType.to_json v)
    let of_json j = Json.to_list ArchitectureType.of_json j
  end
module RootDeviceType =
  struct
    type t =
      | Ebs 
      | Instance_store 
    let str_to_t = [("instance-store", Instance_store); ("ebs", Ebs)]
    let t_to_str = [(Instance_store, "instance-store"); (Ebs, "ebs")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module UsageClassType =
  struct
    type t =
      | Spot 
      | On_demand 
    let str_to_t = [("on-demand", On_demand); ("spot", Spot)]
    let t_to_str = [(On_demand, "on-demand"); (Spot, "spot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CoreCountList =
  struct
    type t = Integer.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Integer.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Integer.to_query v
    let to_headers v = Headers.to_headers_list Integer.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Integer.to_xml x))) v
    let to_json v = `List (List.map Integer.to_json v)
    let of_json j = Json.to_list Integer.of_json j
  end
module ThreadsPerCoreList =
  struct
    type t = Integer.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Integer.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Integer.to_query v
    let to_headers v = Headers.to_headers_list Integer.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Integer.to_xml x))) v
    let to_json v = `List (List.map Integer.to_json v)
    let of_json j = Json.to_list Integer.of_json j
  end
module ClientVpnRouteStatusCode =
  struct
    type t =
      | Creating 
      | Active 
      | Failed 
      | Deleting 
    let str_to_t =
      [("deleting", Deleting);
      ("failed", Failed);
      ("active", Active);
      ("creating", Creating)]
    let t_to_str =
      [(Deleting, "deleting");
      (Failed, "failed");
      (Active, "active");
      (Creating, "creating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VgwTelemetry =
  struct
    type t =
      {
      accepted_route_count: Integer.t option ;
      last_status_change: DateTime.t option ;
      outside_ip_address: String.t option ;
      status: TelemetryStatus.t option ;
      status_message: String.t option ;
      certificate_arn: String.t option }
    let make ?accepted_route_count  ?last_status_change  ?outside_ip_address 
      ?status  ?status_message  ?certificate_arn  () =
      {
        accepted_route_count;
        last_status_change;
        outside_ip_address;
        status;
        status_message;
        certificate_arn
      }
    let parse xml =
      Some
        {
          accepted_route_count =
            (Util.option_bind (Xml.member "acceptedRouteCount" xml)
               Integer.parse);
          last_status_change =
            (Util.option_bind (Xml.member "lastStatusChange" xml)
               DateTime.parse);
          outside_ip_address =
            (Util.option_bind (Xml.member "outsideIpAddress" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml) TelemetryStatus.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          certificate_arn =
            (Util.option_bind (Xml.member "certificateArn" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.certificate_arn
              (fun f -> Query.Pair ("CertificateArn", (String.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (TelemetryStatus.to_query f)));
           Util.option_map v.outside_ip_address
             (fun f -> Query.Pair ("OutsideIpAddress", (String.to_query f)));
           Util.option_map v.last_status_change
             (fun f -> Query.Pair ("LastStatusChange", (DateTime.to_query f)));
           Util.option_map v.accepted_route_count
             (fun f ->
                Query.Pair ("AcceptedRouteCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.accepted_route_count
                   (fun f ->
                      Ezxmlm.make_tag "acceptedRouteCount"
                        ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.last_status_change
                  (fun f ->
                     Ezxmlm.make_tag "lastStatusChange"
                       ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.outside_ip_address
                 (fun f ->
                    Ezxmlm.make_tag "outsideIpAddress"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.status
                (fun f ->
                   Ezxmlm.make_tag "status" ([], (TelemetryStatus.to_xml f)))])
            @
            [Util.option_map v.status_message
               (fun f ->
                  Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
           @
           [Util.option_map v.certificate_arn
              (fun f ->
                 Ezxmlm.make_tag "certificateArn" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.certificate_arn
              (fun f -> ("certificate_arn", (String.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (TelemetryStatus.to_json f)));
           Util.option_map v.outside_ip_address
             (fun f -> ("outside_ip_address", (String.to_json f)));
           Util.option_map v.last_status_change
             (fun f -> ("last_status_change", (DateTime.to_json f)));
           Util.option_map v.accepted_route_count
             (fun f -> ("accepted_route_count", (Integer.to_json f)))])
    let of_json j =
      {
        accepted_route_count =
          (Util.option_map (Json.lookup j "accepted_route_count")
             Integer.of_json);
        last_status_change =
          (Util.option_map (Json.lookup j "last_status_change")
             DateTime.of_json);
        outside_ip_address =
          (Util.option_map (Json.lookup j "outside_ip_address")
             String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") TelemetryStatus.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        certificate_arn =
          (Util.option_map (Json.lookup j "certificate_arn") String.of_json)
      }
  end
module TunnelOptionsList =
  struct
    type t = TunnelOption.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map TunnelOption.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TunnelOption.to_query v
    let to_headers v = Headers.to_headers_list TunnelOption.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (TunnelOption.to_xml x))) v
    let to_json v = `List (List.map TunnelOption.to_json v)
    let of_json j = Json.to_list TunnelOption.of_json j
  end
module VpnStaticRoute =
  struct
    type t =
      {
      destination_cidr_block: String.t option ;
      source: VpnStaticRouteSource.t option ;
      state: VpnState.t option }
    let make ?destination_cidr_block  ?source  ?state  () =
      { destination_cidr_block; source; state }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          source =
            (Util.option_bind (Xml.member "source" xml)
               VpnStaticRouteSource.parse);
          state = (Util.option_bind (Xml.member "state" xml) VpnState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (VpnState.to_query f)));
           Util.option_map v.source
             (fun f ->
                Query.Pair ("Source", (VpnStaticRouteSource.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.destination_cidr_block
                (fun f ->
                   Ezxmlm.make_tag "destinationCidrBlock"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.source
               (fun f ->
                  Ezxmlm.make_tag "source"
                    ([], (VpnStaticRouteSource.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f -> Ezxmlm.make_tag "state" ([], (VpnState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (VpnState.to_json f)));
           Util.option_map v.source
             (fun f -> ("source", (VpnStaticRouteSource.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        source =
          (Util.option_map (Json.lookup j "source")
             VpnStaticRouteSource.of_json);
        state = (Util.option_map (Json.lookup j "state") VpnState.of_json)
      }
  end
module AssociationStatusCode =
  struct
    type t =
      | Associating 
      | Associated 
      | Association_failed 
      | Disassociating 
      | Disassociated 
    let str_to_t =
      [("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("association-failed", Association_failed);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Association_failed, "association-failed");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpcPeeringConnectionStateReasonCode =
  struct
    type t =
      | Initiating_request 
      | Pending_acceptance 
      | Active 
      | Deleted 
      | Rejected 
      | Failed 
      | Expired 
      | Provisioning 
      | Deleting 
    let str_to_t =
      [("deleting", Deleting);
      ("provisioning", Provisioning);
      ("expired", Expired);
      ("failed", Failed);
      ("rejected", Rejected);
      ("deleted", Deleted);
      ("active", Active);
      ("pending-acceptance", Pending_acceptance);
      ("initiating-request", Initiating_request)]
    let t_to_str =
      [(Deleting, "deleting");
      (Provisioning, "provisioning");
      (Expired, "expired");
      (Failed, "failed");
      (Rejected, "rejected");
      (Deleted, "deleted");
      (Active, "active");
      (Pending_acceptance, "pending-acceptance");
      (Initiating_request, "initiating-request")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CidrBlockSet =
  struct
    type t = CidrBlock.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map CidrBlock.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CidrBlock.to_query v
    let to_headers v = Headers.to_headers_list CidrBlock.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (CidrBlock.to_xml x)))
        v
    let to_json v = `List (List.map CidrBlock.to_json v)
    let of_json j = Json.to_list CidrBlock.of_json j
  end
module Ipv6CidrBlockSet =
  struct
    type t = Ipv6CidrBlock.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Ipv6CidrBlock.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Ipv6CidrBlock.to_query v
    let to_headers v = Headers.to_headers_list Ipv6CidrBlock.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (Ipv6CidrBlock.to_xml x))) v
    let to_json v = `List (List.map Ipv6CidrBlock.to_json v)
    let of_json j = Json.to_list Ipv6CidrBlock.of_json j
  end
module VpcPeeringConnectionOptionsDescription =
  struct
    type t =
      {
      allow_dns_resolution_from_remote_vpc: Boolean.t option ;
      allow_egress_from_local_classic_link_to_remote_vpc: Boolean.t option ;
      allow_egress_from_local_vpc_to_remote_classic_link: Boolean.t option }
    let make ?allow_dns_resolution_from_remote_vpc 
      ?allow_egress_from_local_classic_link_to_remote_vpc 
      ?allow_egress_from_local_vpc_to_remote_classic_link  () =
      {
        allow_dns_resolution_from_remote_vpc;
        allow_egress_from_local_classic_link_to_remote_vpc;
        allow_egress_from_local_vpc_to_remote_classic_link
      }
    let parse xml =
      Some
        {
          allow_dns_resolution_from_remote_vpc =
            (Util.option_bind
               (Xml.member "allowDnsResolutionFromRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_classic_link_to_remote_vpc =
            (Util.option_bind
               (Xml.member "allowEgressFromLocalClassicLinkToRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_vpc_to_remote_classic_link =
            (Util.option_bind
               (Xml.member "allowEgressFromLocalVpcToRemoteClassicLink" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 Query.Pair
                   ("AllowEgressFromLocalVpcToRemoteClassicLink",
                     (Boolean.to_query f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowEgressFromLocalClassicLinkToRemoteVpc",
                    (Boolean.to_query f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowDnsResolutionFromRemoteVpc", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.allow_dns_resolution_from_remote_vpc
                (fun f ->
                   Ezxmlm.make_tag "allowDnsResolutionFromRemoteVpc"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map
               v.allow_egress_from_local_classic_link_to_remote_vpc
               (fun f ->
                  Ezxmlm.make_tag
                    "allowEgressFromLocalClassicLinkToRemoteVpc"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 Ezxmlm.make_tag "allowEgressFromLocalVpcToRemoteClassicLink"
                   ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 ("allow_egress_from_local_vpc_to_remote_classic_link",
                   (Boolean.to_json f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                ("allow_egress_from_local_classic_link_to_remote_vpc",
                  (Boolean.to_json f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                ("allow_dns_resolution_from_remote_vpc", (Boolean.to_json f)))])
    let of_json j =
      {
        allow_dns_resolution_from_remote_vpc =
          (Util.option_map
             (Json.lookup j "allow_dns_resolution_from_remote_vpc")
             Boolean.of_json);
        allow_egress_from_local_classic_link_to_remote_vpc =
          (Util.option_map
             (Json.lookup j
                "allow_egress_from_local_classic_link_to_remote_vpc")
             Boolean.of_json);
        allow_egress_from_local_vpc_to_remote_classic_link =
          (Util.option_map
             (Json.lookup j
                "allow_egress_from_local_vpc_to_remote_classic_link")
             Boolean.of_json)
      }
  end
module NetworkAclAssociation =
  struct
    type t =
      {
      network_acl_association_id: String.t option ;
      network_acl_id: String.t option ;
      subnet_id: String.t option }
    let make ?network_acl_association_id  ?network_acl_id  ?subnet_id  () =
      { network_acl_association_id; network_acl_id; subnet_id }
    let parse xml =
      Some
        {
          network_acl_association_id =
            (Util.option_bind (Xml.member "networkAclAssociationId" xml)
               String.parse);
          network_acl_id =
            (Util.option_bind (Xml.member "networkAclId" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.network_acl_id
             (fun f -> Query.Pair ("NetworkAclId", (String.to_query f)));
           Util.option_map v.network_acl_association_id
             (fun f ->
                Query.Pair ("NetworkAclAssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.network_acl_association_id
                (fun f ->
                   Ezxmlm.make_tag "networkAclAssociationId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.network_acl_id
               (fun f ->
                  Ezxmlm.make_tag "networkAclId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.subnet_id
              (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.network_acl_id
             (fun f -> ("network_acl_id", (String.to_json f)));
           Util.option_map v.network_acl_association_id
             (fun f -> ("network_acl_association_id", (String.to_json f)))])
    let of_json j =
      {
        network_acl_association_id =
          (Util.option_map (Json.lookup j "network_acl_association_id")
             String.of_json);
        network_acl_id =
          (Util.option_map (Json.lookup j "network_acl_id") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json)
      }
  end
module NetworkAclEntry =
  struct
    type t =
      {
      cidr_block: String.t option ;
      egress: Boolean.t option ;
      icmp_type_code: IcmpTypeCode.t option ;
      ipv6_cidr_block: String.t option ;
      port_range: PortRange.t option ;
      protocol: String.t option ;
      rule_action: RuleAction.t option ;
      rule_number: Integer.t option }
    let make ?cidr_block  ?egress  ?icmp_type_code  ?ipv6_cidr_block 
      ?port_range  ?protocol  ?rule_action  ?rule_number  () =
      {
        cidr_block;
        egress;
        icmp_type_code;
        ipv6_cidr_block;
        port_range;
        protocol;
        rule_action;
        rule_number
      }
    let parse xml =
      Some
        {
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse);
          egress = (Util.option_bind (Xml.member "egress" xml) Boolean.parse);
          icmp_type_code =
            (Util.option_bind (Xml.member "icmpTypeCode" xml)
               IcmpTypeCode.parse);
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "ipv6CidrBlock" xml) String.parse);
          port_range =
            (Util.option_bind (Xml.member "portRange" xml) PortRange.parse);
          protocol =
            (Util.option_bind (Xml.member "protocol" xml) String.parse);
          rule_action =
            (Util.option_bind (Xml.member "ruleAction" xml) RuleAction.parse);
          rule_number =
            (Util.option_bind (Xml.member "ruleNumber" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.rule_number
              (fun f -> Query.Pair ("RuleNumber", (Integer.to_query f)));
           Util.option_map v.rule_action
             (fun f -> Query.Pair ("RuleAction", (RuleAction.to_query f)));
           Util.option_map v.protocol
             (fun f -> Query.Pair ("Protocol", (String.to_query f)));
           Util.option_map v.port_range
             (fun f -> Query.Pair ("PortRange", (PortRange.to_query f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Util.option_map v.icmp_type_code
             (fun f -> Query.Pair ("IcmpTypeCode", (IcmpTypeCode.to_query f)));
           Util.option_map v.egress
             (fun f -> Query.Pair ("Egress", (Boolean.to_query f)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.cidr_block
                     (fun f ->
                        Ezxmlm.make_tag "cidrBlock" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.egress
                    (fun f ->
                       Ezxmlm.make_tag "egress" ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.icmp_type_code
                   (fun f ->
                      Ezxmlm.make_tag "icmpTypeCode"
                        ([], (IcmpTypeCode.to_xml f)))])
               @
               [Util.option_map v.ipv6_cidr_block
                  (fun f ->
                     Ezxmlm.make_tag "ipv6CidrBlock" ([], (String.to_xml f)))])
              @
              [Util.option_map v.port_range
                 (fun f ->
                    Ezxmlm.make_tag "portRange" ([], (PortRange.to_xml f)))])
             @
             [Util.option_map v.protocol
                (fun f -> Ezxmlm.make_tag "protocol" ([], (String.to_xml f)))])
            @
            [Util.option_map v.rule_action
               (fun f ->
                  Ezxmlm.make_tag "ruleAction" ([], (RuleAction.to_xml f)))])
           @
           [Util.option_map v.rule_number
              (fun f -> Ezxmlm.make_tag "ruleNumber" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.rule_number
              (fun f -> ("rule_number", (Integer.to_json f)));
           Util.option_map v.rule_action
             (fun f -> ("rule_action", (RuleAction.to_json f)));
           Util.option_map v.protocol
             (fun f -> ("protocol", (String.to_json f)));
           Util.option_map v.port_range
             (fun f -> ("port_range", (PortRange.to_json f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.icmp_type_code
             (fun f -> ("icmp_type_code", (IcmpTypeCode.to_json f)));
           Util.option_map v.egress
             (fun f -> ("egress", (Boolean.to_json f)));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)))])
    let of_json j =
      {
        cidr_block =
          (Util.option_map (Json.lookup j "cidr_block") String.of_json);
        egress = (Util.option_map (Json.lookup j "egress") Boolean.of_json);
        icmp_type_code =
          (Util.option_map (Json.lookup j "icmp_type_code")
             IcmpTypeCode.of_json);
        ipv6_cidr_block =
          (Util.option_map (Json.lookup j "ipv6_cidr_block") String.of_json);
        port_range =
          (Util.option_map (Json.lookup j "port_range") PortRange.of_json);
        protocol =
          (Util.option_map (Json.lookup j "protocol") String.of_json);
        rule_action =
          (Util.option_map (Json.lookup j "rule_action") RuleAction.of_json);
        rule_number =
          (Util.option_map (Json.lookup j "rule_number") Integer.of_json)
      }
  end
module CancelBatchErrorCode =
  struct
    type t =
      | FleetRequestIdDoesNotExist 
      | FleetRequestIdMalformed 
      | FleetRequestNotInCancellableState 
      | UnexpectedError 
    let str_to_t =
      [("unexpectedError", UnexpectedError);
      ("fleetRequestNotInCancellableState",
        FleetRequestNotInCancellableState);
      ("fleetRequestIdMalformed", FleetRequestIdMalformed);
      ("fleetRequestIdDoesNotExist", FleetRequestIdDoesNotExist)]
    let t_to_str =
      [(UnexpectedError, "unexpectedError");
      (FleetRequestNotInCancellableState,
        "fleetRequestNotInCancellableState");
      (FleetRequestIdMalformed, "fleetRequestIdMalformed");
      (FleetRequestIdDoesNotExist, "fleetRequestIdDoesNotExist")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AccountAttributeValue =
  struct
    type t = {
      attribute_value: String.t option }
    let make ?attribute_value  () = { attribute_value }
    let parse xml =
      Some
        {
          attribute_value =
            (Util.option_bind (Xml.member "attributeValue" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.attribute_value
              (fun f -> Query.Pair ("AttributeValue", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.attribute_value
              (fun f ->
                 Ezxmlm.make_tag "attributeValue" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.attribute_value
              (fun f -> ("attribute_value", (String.to_json f)))])
    let of_json j =
      {
        attribute_value =
          (Util.option_map (Json.lookup j "attribute_value") String.of_json)
      }
  end
module SecurityGroupIdentifier =
  struct
    type t = {
      group_id: String.t option ;
      group_name: String.t option }
    let make ?group_id  ?group_name  () = { group_id; group_name }
    let parse xml =
      Some
        {
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.group_id
               (fun f -> Ezxmlm.make_tag "groupId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.group_name
              (fun f -> Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)))])
    let of_json j =
      {
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json)
      }
  end
module TransitGatewayAssociationState =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
    let str_to_t =
      [("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NetworkInterfaceIpv6Address =
  struct
    type t = {
      ipv6_address: String.t option }
    let make ?ipv6_address  () = { ipv6_address }
    let parse xml =
      Some
        {
          ipv6_address =
            (Util.option_bind (Xml.member "ipv6Address" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> Query.Pair ("Ipv6Address", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ipv6_address
              (fun f -> Ezxmlm.make_tag "ipv6Address" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> ("ipv6_address", (String.to_json f)))])
    let of_json j =
      {
        ipv6_address =
          (Util.option_map (Json.lookup j "ipv6_address") String.of_json)
      }
  end
module NetworkInterfacePrivateIpAddress =
  struct
    type t =
      {
      association: NetworkInterfaceAssociation.t option ;
      primary: Boolean.t option ;
      private_dns_name: String.t option ;
      private_ip_address: String.t option }
    let make ?association  ?primary  ?private_dns_name  ?private_ip_address 
      () = { association; primary; private_dns_name; private_ip_address }
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               NetworkInterfaceAssociation.parse);
          primary =
            (Util.option_bind (Xml.member "primary" xml) Boolean.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.primary
             (fun f -> Query.Pair ("Primary", (Boolean.to_query f)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association", (NetworkInterfaceAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.association
                 (fun f ->
                    Ezxmlm.make_tag "association"
                      ([], (NetworkInterfaceAssociation.to_xml f)))])
             @
             [Util.option_map v.primary
                (fun f -> Ezxmlm.make_tag "primary" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.private_dns_name
               (fun f ->
                  Ezxmlm.make_tag "privateDnsName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.private_ip_address
              (fun f ->
                 Ezxmlm.make_tag "privateIpAddress" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.primary
             (fun f -> ("primary", (Boolean.to_json f)));
           Util.option_map v.association
             (fun f ->
                ("association", (NetworkInterfaceAssociation.to_json f)))])
    let of_json j =
      {
        association =
          (Util.option_map (Json.lookup j "association")
             NetworkInterfaceAssociation.of_json);
        primary = (Util.option_map (Json.lookup j "primary") Boolean.of_json);
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json)
      }
  end
module RecurringCharge =
  struct
    type t =
      {
      amount: Double.t option ;
      frequency: RecurringChargeFrequency.t option }
    let make ?amount  ?frequency  () = { amount; frequency }
    let parse xml =
      Some
        {
          amount = (Util.option_bind (Xml.member "amount" xml) Double.parse);
          frequency =
            (Util.option_bind (Xml.member "frequency" xml)
               RecurringChargeFrequency.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.frequency
              (fun f ->
                 Query.Pair
                   ("Frequency", (RecurringChargeFrequency.to_query f)));
           Util.option_map v.amount
             (fun f -> Query.Pair ("Amount", (Double.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.amount
               (fun f -> Ezxmlm.make_tag "amount" ([], (Double.to_xml f)))])
           @
           [Util.option_map v.frequency
              (fun f ->
                 Ezxmlm.make_tag "frequency"
                   ([], (RecurringChargeFrequency.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.frequency
              (fun f -> ("frequency", (RecurringChargeFrequency.to_json f)));
           Util.option_map v.amount (fun f -> ("amount", (Double.to_json f)))])
    let of_json j =
      {
        amount = (Util.option_map (Json.lookup j "amount") Double.of_json);
        frequency =
          (Util.option_map (Json.lookup j "frequency")
             RecurringChargeFrequency.of_json)
      }
  end
module ServiceTypeDetail =
  struct
    type t = {
      service_type: ServiceType.t option }
    let make ?service_type  () = { service_type }
    let parse xml =
      Some
        {
          service_type =
            (Util.option_bind (Xml.member "serviceType" xml)
               ServiceType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.service_type
              (fun f -> Query.Pair ("ServiceType", (ServiceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.service_type
              (fun f ->
                 Ezxmlm.make_tag "serviceType" ([], (ServiceType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.service_type
              (fun f -> ("service_type", (ServiceType.to_json f)))])
    let of_json j =
      {
        service_type =
          (Util.option_map (Json.lookup j "service_type") ServiceType.of_json)
      }
  end
module ImportInstanceVolumeDetailSet =
  struct
    type t = ImportInstanceVolumeDetailItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ImportInstanceVolumeDetailItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ImportInstanceVolumeDetailItem.to_query v
    let to_headers v =
      Headers.to_headers_list ImportInstanceVolumeDetailItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ImportInstanceVolumeDetailItem.to_xml x))) v
    let to_json v = `List (List.map ImportInstanceVolumeDetailItem.to_json v)
    let of_json j = Json.to_list ImportInstanceVolumeDetailItem.of_json j
  end
module Ipv6SupportValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TransitGatewayRouteAttachment =
  struct
    type t =
      {
      resource_id: String.t option ;
      transit_gateway_attachment_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option }
    let make ?resource_id  ?transit_gateway_attachment_id  ?resource_type  ()
      = { resource_id; transit_gateway_attachment_id; resource_type }
    let parse xml =
      Some
        {
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.resource_type
              (fun f ->
                 Query.Pair
                   ("ResourceType",
                     (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.resource_id
                (fun f ->
                   Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.transit_gateway_attachment_id
               (fun f ->
                  Ezxmlm.make_tag "transitGatewayAttachmentId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.resource_type
              (fun f ->
                 Ezxmlm.make_tag "resourceType"
                   ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.resource_type
              (fun f ->
                 ("resource_type",
                   (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)))])
    let of_json j =
      {
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json)
      }
  end
module FpgaImageStateCode =
  struct
    type t =
      | Pending 
      | Failed 
      | Available 
      | Unavailable 
    let str_to_t =
      [("unavailable", Unavailable);
      ("available", Available);
      ("failed", Failed);
      ("pending", Pending)]
    let t_to_str =
      [(Unavailable, "unavailable");
      (Available, "available");
      (Failed, "failed");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EnableFastSnapshotRestoreStateErrorItem =
  struct
    type t =
      {
      availability_zone: String.t option ;
      error: EnableFastSnapshotRestoreStateError.t option }
    let make ?availability_zone  ?error  () = { availability_zone; error }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          error =
            (Util.option_bind (Xml.member "error" xml)
               EnableFastSnapshotRestoreStateError.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 Query.Pair
                   ("Error",
                     (EnableFastSnapshotRestoreStateError.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.availability_zone
               (fun f ->
                  Ezxmlm.make_tag "availabilityZone" ([], (String.to_xml f)))])
           @
           [Util.option_map v.error
              (fun f ->
                 Ezxmlm.make_tag "error"
                   ([], (EnableFastSnapshotRestoreStateError.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 ("error", (EnableFastSnapshotRestoreStateError.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        error =
          (Util.option_map (Json.lookup j "error")
             EnableFastSnapshotRestoreStateError.of_json)
      }
  end
module PropagatingVgw =
  struct
    type t = {
      gateway_id: String.t option }
    let make ?gateway_id  () = { gateway_id }
    let parse xml =
      Some
        {
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.gateway_id
              (fun f -> Query.Pair ("GatewayId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.gateway_id
              (fun f -> Ezxmlm.make_tag "gatewayId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.gateway_id
              (fun f -> ("gateway_id", (String.to_json f)))])
    let of_json j =
      {
        gateway_id =
          (Util.option_map (Json.lookup j "gateway_id") String.of_json)
      }
  end
module Route =
  struct
    type t =
      {
      destination_cidr_block: String.t option ;
      destination_ipv6_cidr_block: String.t option ;
      destination_prefix_list_id: String.t option ;
      egress_only_internet_gateway_id: String.t option ;
      gateway_id: String.t option ;
      instance_id: String.t option ;
      instance_owner_id: String.t option ;
      nat_gateway_id: String.t option ;
      transit_gateway_id: String.t option ;
      local_gateway_id: String.t option ;
      network_interface_id: String.t option ;
      origin: RouteOrigin.t option ;
      state: RouteState.t option ;
      vpc_peering_connection_id: String.t option }
    let make ?destination_cidr_block  ?destination_ipv6_cidr_block 
      ?destination_prefix_list_id  ?egress_only_internet_gateway_id 
      ?gateway_id  ?instance_id  ?instance_owner_id  ?nat_gateway_id 
      ?transit_gateway_id  ?local_gateway_id  ?network_interface_id  ?origin 
      ?state  ?vpc_peering_connection_id  () =
      {
        destination_cidr_block;
        destination_ipv6_cidr_block;
        destination_prefix_list_id;
        egress_only_internet_gateway_id;
        gateway_id;
        instance_id;
        instance_owner_id;
        nat_gateway_id;
        transit_gateway_id;
        local_gateway_id;
        network_interface_id;
        origin;
        state;
        vpc_peering_connection_id
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          destination_ipv6_cidr_block =
            (Util.option_bind (Xml.member "destinationIpv6CidrBlock" xml)
               String.parse);
          destination_prefix_list_id =
            (Util.option_bind (Xml.member "destinationPrefixListId" xml)
               String.parse);
          egress_only_internet_gateway_id =
            (Util.option_bind (Xml.member "egressOnlyInternetGatewayId" xml)
               String.parse);
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_owner_id =
            (Util.option_bind (Xml.member "instanceOwnerId" xml) String.parse);
          nat_gateway_id =
            (Util.option_bind (Xml.member "natGatewayId" xml) String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          origin =
            (Util.option_bind (Xml.member "origin" xml) RouteOrigin.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) RouteState.parse);
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (RouteState.to_query f)));
           Util.option_map v.origin
             (fun f -> Query.Pair ("Origin", (RouteOrigin.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.nat_gateway_id
             (fun f -> Query.Pair ("NatGatewayId", (String.to_query f)));
           Util.option_map v.instance_owner_id
             (fun f -> Query.Pair ("InstanceOwnerId", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.gateway_id
             (fun f -> Query.Pair ("GatewayId", (String.to_query f)));
           Util.option_map v.egress_only_internet_gateway_id
             (fun f ->
                Query.Pair
                  ("EgressOnlyInternetGatewayId", (String.to_query f)));
           Util.option_map v.destination_prefix_list_id
             (fun f ->
                Query.Pair ("DestinationPrefixListId", (String.to_query f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f ->
                Query.Pair ("DestinationIpv6CidrBlock", (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        [Util.option_map v.destination_cidr_block
                           (fun f ->
                              Ezxmlm.make_tag "destinationCidrBlock"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.destination_ipv6_cidr_block
                          (fun f ->
                             Ezxmlm.make_tag "destinationIpv6CidrBlock"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.destination_prefix_list_id
                         (fun f ->
                            Ezxmlm.make_tag "destinationPrefixListId"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.egress_only_internet_gateway_id
                        (fun f ->
                           Ezxmlm.make_tag "egressOnlyInternetGatewayId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.gateway_id
                       (fun f ->
                          Ezxmlm.make_tag "gatewayId" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.instance_id
                      (fun f ->
                         Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.instance_owner_id
                     (fun f ->
                        Ezxmlm.make_tag "instanceOwnerId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.nat_gateway_id
                    (fun f ->
                       Ezxmlm.make_tag "natGatewayId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.transit_gateway_id
                   (fun f ->
                      Ezxmlm.make_tag "transitGatewayId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.local_gateway_id
                  (fun f ->
                     Ezxmlm.make_tag "localGatewayId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.network_interface_id
                 (fun f ->
                    Ezxmlm.make_tag "networkInterfaceId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.origin
                (fun f ->
                   Ezxmlm.make_tag "origin" ([], (RouteOrigin.to_xml f)))])
            @
            [Util.option_map v.state
               (fun f -> Ezxmlm.make_tag "state" ([], (RouteState.to_xml f)))])
           @
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Ezxmlm.make_tag "vpcPeeringConnectionId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (RouteState.to_json f)));
           Util.option_map v.origin
             (fun f -> ("origin", (RouteOrigin.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.nat_gateway_id
             (fun f -> ("nat_gateway_id", (String.to_json f)));
           Util.option_map v.instance_owner_id
             (fun f -> ("instance_owner_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.gateway_id
             (fun f -> ("gateway_id", (String.to_json f)));
           Util.option_map v.egress_only_internet_gateway_id
             (fun f ->
                ("egress_only_internet_gateway_id", (String.to_json f)));
           Util.option_map v.destination_prefix_list_id
             (fun f -> ("destination_prefix_list_id", (String.to_json f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f -> ("destination_ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        destination_ipv6_cidr_block =
          (Util.option_map (Json.lookup j "destination_ipv6_cidr_block")
             String.of_json);
        destination_prefix_list_id =
          (Util.option_map (Json.lookup j "destination_prefix_list_id")
             String.of_json);
        egress_only_internet_gateway_id =
          (Util.option_map (Json.lookup j "egress_only_internet_gateway_id")
             String.of_json);
        gateway_id =
          (Util.option_map (Json.lookup j "gateway_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_owner_id =
          (Util.option_map (Json.lookup j "instance_owner_id") String.of_json);
        nat_gateway_id =
          (Util.option_map (Json.lookup j "nat_gateway_id") String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        origin =
          (Util.option_map (Json.lookup j "origin") RouteOrigin.of_json);
        state = (Util.option_map (Json.lookup j "state") RouteState.of_json);
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module RouteTableAssociation =
  struct
    type t =
      {
      main: Boolean.t option ;
      route_table_association_id: String.t option ;
      route_table_id: String.t option ;
      subnet_id: String.t option ;
      gateway_id: String.t option ;
      association_state: RouteTableAssociationState.t option }
    let make ?main  ?route_table_association_id  ?route_table_id  ?subnet_id 
      ?gateway_id  ?association_state  () =
      {
        main;
        route_table_association_id;
        route_table_id;
        subnet_id;
        gateway_id;
        association_state
      }
    let parse xml =
      Some
        {
          main = (Util.option_bind (Xml.member "main" xml) Boolean.parse);
          route_table_association_id =
            (Util.option_bind (Xml.member "routeTableAssociationId" xml)
               String.parse);
          route_table_id =
            (Util.option_bind (Xml.member "routeTableId" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse);
          association_state =
            (Util.option_bind (Xml.member "associationState" xml)
               RouteTableAssociationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 Query.Pair
                   ("AssociationState",
                     (RouteTableAssociationState.to_query f)));
           Util.option_map v.gateway_id
             (fun f -> Query.Pair ("GatewayId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.route_table_id
             (fun f -> Query.Pair ("RouteTableId", (String.to_query f)));
           Util.option_map v.route_table_association_id
             (fun f ->
                Query.Pair ("RouteTableAssociationId", (String.to_query f)));
           Util.option_map v.main
             (fun f -> Query.Pair ("Main", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.main
                   (fun f -> Ezxmlm.make_tag "main" ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.route_table_association_id
                  (fun f ->
                     Ezxmlm.make_tag "routeTableAssociationId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.route_table_id
                 (fun f ->
                    Ezxmlm.make_tag "routeTableId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.subnet_id
                (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.gateway_id
               (fun f -> Ezxmlm.make_tag "gatewayId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.association_state
              (fun f ->
                 Ezxmlm.make_tag "associationState"
                   ([], (RouteTableAssociationState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 ("association_state",
                   (RouteTableAssociationState.to_json f)));
           Util.option_map v.gateway_id
             (fun f -> ("gateway_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.route_table_id
             (fun f -> ("route_table_id", (String.to_json f)));
           Util.option_map v.route_table_association_id
             (fun f -> ("route_table_association_id", (String.to_json f)));
           Util.option_map v.main (fun f -> ("main", (Boolean.to_json f)))])
    let of_json j =
      {
        main = (Util.option_map (Json.lookup j "main") Boolean.of_json);
        route_table_association_id =
          (Util.option_map (Json.lookup j "route_table_association_id")
             String.of_json);
        route_table_id =
          (Util.option_map (Json.lookup j "route_table_id") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        gateway_id =
          (Util.option_map (Json.lookup j "gateway_id") String.of_json);
        association_state =
          (Util.option_map (Json.lookup j "association_state")
             RouteTableAssociationState.of_json)
      }
  end
module CreditSpecification =
  struct
    type t = {
      cpu_credits: String.t option }
    let make ?cpu_credits  () = { cpu_credits }
    let parse xml =
      Some
        {
          cpu_credits =
            (Util.option_bind (Xml.member "cpuCredits" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> Query.Pair ("CpuCredits", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.cpu_credits
              (fun f -> Ezxmlm.make_tag "cpuCredits" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> ("cpu_credits", (String.to_json f)))])
    let of_json j =
      {
        cpu_credits =
          (Util.option_map (Json.lookup j "cpu_credits") String.of_json)
      }
  end
module ElasticGpuSpecificationResponseList =
  struct
    type t = ElasticGpuSpecificationResponse.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ElasticGpuSpecificationResponse.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ElasticGpuSpecificationResponse.to_query v
    let to_headers v =
      Headers.to_headers_list ElasticGpuSpecificationResponse.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ElasticGpuSpecificationResponse.to_xml x))) v
    let to_json v =
      `List (List.map ElasticGpuSpecificationResponse.to_json v)
    let of_json j = Json.to_list ElasticGpuSpecificationResponse.of_json j
  end
module LaunchTemplateBlockDeviceMappingList =
  struct
    type t = LaunchTemplateBlockDeviceMapping.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateBlockDeviceMapping.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LaunchTemplateBlockDeviceMapping.to_query v
    let to_headers v =
      Headers.to_headers_list LaunchTemplateBlockDeviceMapping.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LaunchTemplateBlockDeviceMapping.to_xml x))) v
    let to_json v =
      `List (List.map LaunchTemplateBlockDeviceMapping.to_json v)
    let of_json j = Json.to_list LaunchTemplateBlockDeviceMapping.of_json j
  end
module LaunchTemplateCapacityReservationSpecificationResponse =
  struct
    type t =
      {
      capacity_reservation_preference: CapacityReservationPreference.t option ;
      capacity_reservation_target: CapacityReservationTargetResponse.t option }
    let make ?capacity_reservation_preference  ?capacity_reservation_target 
      () = { capacity_reservation_preference; capacity_reservation_target }
    let parse xml =
      Some
        {
          capacity_reservation_preference =
            (Util.option_bind
               (Xml.member "capacityReservationPreference" xml)
               CapacityReservationPreference.parse);
          capacity_reservation_target =
            (Util.option_bind (Xml.member "capacityReservationTarget" xml)
               CapacityReservationTargetResponse.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Query.Pair
                   ("CapacityReservationTarget",
                     (CapacityReservationTargetResponse.to_query f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                Query.Pair
                  ("CapacityReservationPreference",
                    (CapacityReservationPreference.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.capacity_reservation_preference
               (fun f ->
                  Ezxmlm.make_tag "capacityReservationPreference"
                    ([], (CapacityReservationPreference.to_xml f)))])
           @
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Ezxmlm.make_tag "capacityReservationTarget"
                   ([], (CapacityReservationTargetResponse.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 ("capacity_reservation_target",
                   (CapacityReservationTargetResponse.to_json f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                ("capacity_reservation_preference",
                  (CapacityReservationPreference.to_json f)))])
    let of_json j =
      {
        capacity_reservation_preference =
          (Util.option_map (Json.lookup j "capacity_reservation_preference")
             CapacityReservationPreference.of_json);
        capacity_reservation_target =
          (Util.option_map (Json.lookup j "capacity_reservation_target")
             CapacityReservationTargetResponse.of_json)
      }
  end
module LaunchTemplateCpuOptions =
  struct
    type t =
      {
      core_count: Integer.t option ;
      threads_per_core: Integer.t option }
    let make ?core_count  ?threads_per_core  () =
      { core_count; threads_per_core }
    let parse xml =
      Some
        {
          core_count =
            (Util.option_bind (Xml.member "coreCount" xml) Integer.parse);
          threads_per_core =
            (Util.option_bind (Xml.member "threadsPerCore" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> Query.Pair ("ThreadsPerCore", (Integer.to_query f)));
           Util.option_map v.core_count
             (fun f -> Query.Pair ("CoreCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.core_count
               (fun f -> Ezxmlm.make_tag "coreCount" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.threads_per_core
              (fun f ->
                 Ezxmlm.make_tag "threadsPerCore" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> ("threads_per_core", (Integer.to_json f)));
           Util.option_map v.core_count
             (fun f -> ("core_count", (Integer.to_json f)))])
    let of_json j =
      {
        core_count =
          (Util.option_map (Json.lookup j "core_count") Integer.of_json);
        threads_per_core =
          (Util.option_map (Json.lookup j "threads_per_core") Integer.of_json)
      }
  end
module LaunchTemplateElasticInferenceAcceleratorResponseList =
  struct
    type t = LaunchTemplateElasticInferenceAcceleratorResponse.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateElasticInferenceAcceleratorResponse.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list
        LaunchTemplateElasticInferenceAcceleratorResponse.to_query v
    let to_headers v =
      Headers.to_headers_list
        LaunchTemplateElasticInferenceAcceleratorResponse.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([],
               (LaunchTemplateElasticInferenceAcceleratorResponse.to_xml x)))
        v
    let to_json v =
      `List
        (List.map LaunchTemplateElasticInferenceAcceleratorResponse.to_json v)
    let of_json j =
      Json.to_list LaunchTemplateElasticInferenceAcceleratorResponse.of_json
        j
  end
module LaunchTemplateHibernationOptions =
  struct
    type t = {
      configured: Boolean.t option }
    let make ?configured  () = { configured }
    let parse xml =
      Some
        {
          configured =
            (Util.option_bind (Xml.member "configured" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> Query.Pair ("Configured", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.configured
              (fun f -> Ezxmlm.make_tag "configured" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> ("configured", (Boolean.to_json f)))])
    let of_json j =
      {
        configured =
          (Util.option_map (Json.lookup j "configured") Boolean.of_json)
      }
  end
module LaunchTemplateIamInstanceProfileSpecification =
  struct
    type t = {
      arn: String.t option ;
      name: String.t option }
    let make ?arn  ?name  () = { arn; name }
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "arn" xml) String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.arn
               (fun f -> Ezxmlm.make_tag "arn" ([], (String.to_xml f)))])
           @
           [Util.option_map v.name
              (fun f -> Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      {
        arn = (Util.option_map (Json.lookup j "arn") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json)
      }
  end
module LaunchTemplateInstanceMarketOptions =
  struct
    type t =
      {
      market_type: MarketType.t option ;
      spot_options: LaunchTemplateSpotMarketOptions.t option }
    let make ?market_type  ?spot_options  () = { market_type; spot_options }
    let parse xml =
      Some
        {
          market_type =
            (Util.option_bind (Xml.member "marketType" xml) MarketType.parse);
          spot_options =
            (Util.option_bind (Xml.member "spotOptions" xml)
               LaunchTemplateSpotMarketOptions.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f ->
                 Query.Pair
                   ("SpotOptions",
                     (LaunchTemplateSpotMarketOptions.to_query f)));
           Util.option_map v.market_type
             (fun f -> Query.Pair ("MarketType", (MarketType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.market_type
               (fun f ->
                  Ezxmlm.make_tag "marketType" ([], (MarketType.to_xml f)))])
           @
           [Util.option_map v.spot_options
              (fun f ->
                 Ezxmlm.make_tag "spotOptions"
                   ([], (LaunchTemplateSpotMarketOptions.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f ->
                 ("spot_options",
                   (LaunchTemplateSpotMarketOptions.to_json f)));
           Util.option_map v.market_type
             (fun f -> ("market_type", (MarketType.to_json f)))])
    let of_json j =
      {
        market_type =
          (Util.option_map (Json.lookup j "market_type") MarketType.of_json);
        spot_options =
          (Util.option_map (Json.lookup j "spot_options")
             LaunchTemplateSpotMarketOptions.of_json)
      }
  end
module LaunchTemplateInstanceNetworkInterfaceSpecificationList =
  struct
    type t = LaunchTemplateInstanceNetworkInterfaceSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateInstanceNetworkInterfaceSpecification.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list
        LaunchTemplateInstanceNetworkInterfaceSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list
        LaunchTemplateInstanceNetworkInterfaceSpecification.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([],
               (LaunchTemplateInstanceNetworkInterfaceSpecification.to_xml x)))
        v
    let to_json v =
      `List
        (List.map LaunchTemplateInstanceNetworkInterfaceSpecification.to_json
           v)
    let of_json j =
      Json.to_list
        LaunchTemplateInstanceNetworkInterfaceSpecification.of_json j
  end
module LaunchTemplateLicenseList =
  struct
    type t = LaunchTemplateLicenseConfiguration.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateLicenseConfiguration.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LaunchTemplateLicenseConfiguration.to_query v
    let to_headers v =
      Headers.to_headers_list LaunchTemplateLicenseConfiguration.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LaunchTemplateLicenseConfiguration.to_xml x))) v
    let to_json v =
      `List (List.map LaunchTemplateLicenseConfiguration.to_json v)
    let of_json j = Json.to_list LaunchTemplateLicenseConfiguration.of_json j
  end
module LaunchTemplatePlacement =
  struct
    type t =
      {
      availability_zone: String.t option ;
      affinity: String.t option ;
      group_name: String.t option ;
      host_id: String.t option ;
      tenancy: Tenancy.t option ;
      spread_domain: String.t option ;
      host_resource_group_arn: String.t option }
    let make ?availability_zone  ?affinity  ?group_name  ?host_id  ?tenancy 
      ?spread_domain  ?host_resource_group_arn  () =
      {
        availability_zone;
        affinity;
        group_name;
        host_id;
        tenancy;
        spread_domain;
        host_resource_group_arn
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          affinity =
            (Util.option_bind (Xml.member "affinity" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          host_id = (Util.option_bind (Xml.member "hostId" xml) String.parse);
          tenancy =
            (Util.option_bind (Xml.member "tenancy" xml) Tenancy.parse);
          spread_domain =
            (Util.option_bind (Xml.member "spreadDomain" xml) String.parse);
          host_resource_group_arn =
            (Util.option_bind (Xml.member "hostResourceGroupArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f ->
                 Query.Pair ("HostResourceGroupArn", (String.to_query f)));
           Util.option_map v.spread_domain
             (fun f -> Query.Pair ("SpreadDomain", (String.to_query f)));
           Util.option_map v.tenancy
             (fun f -> Query.Pair ("Tenancy", (Tenancy.to_query f)));
           Util.option_map v.host_id
             (fun f -> Query.Pair ("HostId", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.affinity
             (fun f -> Query.Pair ("Affinity", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.availability_zone
                    (fun f ->
                       Ezxmlm.make_tag "availabilityZone"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.affinity
                   (fun f ->
                      Ezxmlm.make_tag "affinity" ([], (String.to_xml f)))])
               @
               [Util.option_map v.group_name
                  (fun f ->
                     Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.host_id
                 (fun f -> Ezxmlm.make_tag "hostId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.tenancy
                (fun f -> Ezxmlm.make_tag "tenancy" ([], (Tenancy.to_xml f)))])
            @
            [Util.option_map v.spread_domain
               (fun f ->
                  Ezxmlm.make_tag "spreadDomain" ([], (String.to_xml f)))])
           @
           [Util.option_map v.host_resource_group_arn
              (fun f ->
                 Ezxmlm.make_tag "hostResourceGroupArn"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f -> ("host_resource_group_arn", (String.to_json f)));
           Util.option_map v.spread_domain
             (fun f -> ("spread_domain", (String.to_json f)));
           Util.option_map v.tenancy
             (fun f -> ("tenancy", (Tenancy.to_json f)));
           Util.option_map v.host_id
             (fun f -> ("host_id", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.affinity
             (fun f -> ("affinity", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        affinity =
          (Util.option_map (Json.lookup j "affinity") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        host_id = (Util.option_map (Json.lookup j "host_id") String.of_json);
        tenancy = (Util.option_map (Json.lookup j "tenancy") Tenancy.of_json);
        spread_domain =
          (Util.option_map (Json.lookup j "spread_domain") String.of_json);
        host_resource_group_arn =
          (Util.option_map (Json.lookup j "host_resource_group_arn")
             String.of_json)
      }
  end
module LaunchTemplateTagSpecificationList =
  struct
    type t = LaunchTemplateTagSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateTagSpecification.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LaunchTemplateTagSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list LaunchTemplateTagSpecification.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LaunchTemplateTagSpecification.to_xml x))) v
    let to_json v = `List (List.map LaunchTemplateTagSpecification.to_json v)
    let of_json j = Json.to_list LaunchTemplateTagSpecification.of_json j
  end
module LaunchTemplatesMonitoring =
  struct
    type t = {
      enabled: Boolean.t option }
    let make ?enabled  () = { enabled }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "enabled" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.enabled
              (fun f -> Ezxmlm.make_tag "enabled" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      { enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json)
      }
  end
module ShutdownBehavior =
  struct
    type t =
      | Stop 
      | Terminate 
    let str_to_t = [("terminate", Terminate); ("stop", Stop)]
    let t_to_str = [(Terminate, "terminate"); (Stop, "stop")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ValueStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module LaunchTemplateEbsBlockDeviceRequest =
  struct
    type t =
      {
      encrypted: Boolean.t option ;
      delete_on_termination: Boolean.t option ;
      iops: Integer.t option ;
      kms_key_id: String.t option ;
      snapshot_id: String.t option ;
      volume_size: Integer.t option ;
      volume_type: VolumeType.t option }
    let make ?encrypted  ?delete_on_termination  ?iops  ?kms_key_id 
      ?snapshot_id  ?volume_size  ?volume_type  () =
      {
        encrypted;
        delete_on_termination;
        iops;
        kms_key_id;
        snapshot_id;
        volume_size;
        volume_type
      }
    let parse xml =
      Some
        {
          encrypted =
            (Util.option_bind (Xml.member "Encrypted" xml) Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "DeleteOnTermination" xml)
               Boolean.parse);
          iops = (Util.option_bind (Xml.member "Iops" xml) Integer.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "KmsKeyId" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "SnapshotId" xml) String.parse);
          volume_size =
            (Util.option_bind (Xml.member "VolumeSize" xml) Integer.parse);
          volume_type =
            (Util.option_bind (Xml.member "VolumeType" xml) VolumeType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> Query.Pair ("VolumeType", (VolumeType.to_query f)));
           Util.option_map v.volume_size
             (fun f -> Query.Pair ("VolumeSize", (Integer.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.encrypted
                    (fun f ->
                       Ezxmlm.make_tag "Encrypted" ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.delete_on_termination
                   (fun f ->
                      Ezxmlm.make_tag "DeleteOnTermination"
                        ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.iops
                  (fun f -> Ezxmlm.make_tag "Iops" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.kms_key_id
                 (fun f -> Ezxmlm.make_tag "KmsKeyId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.snapshot_id
                (fun f ->
                   Ezxmlm.make_tag "SnapshotId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.volume_size
               (fun f ->
                  Ezxmlm.make_tag "VolumeSize" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.volume_type
              (fun f ->
                 Ezxmlm.make_tag "VolumeType" ([], (VolumeType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> ("volume_type", (VolumeType.to_json f)));
           Util.option_map v.volume_size
             (fun f -> ("volume_size", (Integer.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)))])
    let of_json j =
      {
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        volume_size =
          (Util.option_map (Json.lookup j "volume_size") Integer.of_json);
        volume_type =
          (Util.option_map (Json.lookup j "volume_type") VolumeType.of_json)
      }
  end
module InstanceIpv6AddressListRequest =
  struct
    type t = InstanceIpv6AddressRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceIpv6AddressRequest.parse
           (Xml.members "InstanceIpv6Address" xml))
    let to_query v =
      Query.to_query_list InstanceIpv6AddressRequest.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceIpv6AddressRequest.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InstanceIpv6AddressRequest.to_xml x))) v
    let to_json v = `List (List.map InstanceIpv6AddressRequest.to_json v)
    let of_json j = Json.to_list InstanceIpv6AddressRequest.of_json j
  end
module LaunchTemplateErrorCode =
  struct
    type t =
      | LaunchTemplateIdDoesNotExist 
      | LaunchTemplateIdMalformed 
      | LaunchTemplateNameDoesNotExist 
      | LaunchTemplateNameMalformed 
      | LaunchTemplateVersionDoesNotExist 
      | UnexpectedError 
    let str_to_t =
      [("unexpectedError", UnexpectedError);
      ("launchTemplateVersionDoesNotExist",
        LaunchTemplateVersionDoesNotExist);
      ("launchTemplateNameMalformed", LaunchTemplateNameMalformed);
      ("launchTemplateNameDoesNotExist", LaunchTemplateNameDoesNotExist);
      ("launchTemplateIdMalformed", LaunchTemplateIdMalformed);
      ("launchTemplateIdDoesNotExist", LaunchTemplateIdDoesNotExist)]
    let t_to_str =
      [(UnexpectedError, "unexpectedError");
      (LaunchTemplateVersionDoesNotExist,
        "launchTemplateVersionDoesNotExist");
      (LaunchTemplateNameMalformed, "launchTemplateNameMalformed");
      (LaunchTemplateNameDoesNotExist, "launchTemplateNameDoesNotExist");
      (LaunchTemplateIdMalformed, "launchTemplateIdMalformed");
      (LaunchTemplateIdDoesNotExist, "launchTemplateIdDoesNotExist")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RunInstancesMonitoringEnabled =
  struct
    type t = {
      enabled: Boolean.t }
    let make ~enabled  () = { enabled }
    let parse xml =
      Some
        {
          enabled =
            (Xml.required "enabled"
               (Util.option_bind (Xml.member "enabled" xml) Boolean.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Enabled", (Boolean.to_query v.enabled)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some (Ezxmlm.make_tag "enabled" ([], (Boolean.to_xml v.enabled)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt [Some ("enabled", (Boolean.to_json v.enabled))])
    let of_json j =
      {
        enabled =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "enabled")))
      }
  end
module DeleteQueuedReservedInstancesErrorCode =
  struct
    type t =
      | Reserved_instances_id_invalid 
      | Reserved_instances_not_in_queued_state 
      | Unexpected_error 
    let str_to_t =
      [("unexpected-error", Unexpected_error);
      ("reserved-instances-not-in-queued-state",
        Reserved_instances_not_in_queued_state);
      ("reserved-instances-id-invalid", Reserved_instances_id_invalid)]
    let t_to_str =
      [(Unexpected_error, "unexpected-error");
      (Reserved_instances_not_in_queued_state,
        "reserved-instances-not-in-queued-state");
      (Reserved_instances_id_invalid, "reserved-instances-id-invalid")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ContainerFormat =
  struct
    type t =
      | Ova 
    let str_to_t = [("ova", Ova)]
    let t_to_str = [(Ova, "ova")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ExportEnvironment =
  struct
    type t =
      | Citrix 
      | Vmware 
      | Microsoft 
    let str_to_t =
      [("microsoft", Microsoft); ("vmware", Vmware); ("citrix", Citrix)]
    let t_to_str =
      [(Microsoft, "microsoft"); (Vmware, "vmware"); (Citrix, "citrix")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module IpPermission =
  struct
    type t =
      {
      from_port: Integer.t option ;
      ip_protocol: String.t ;
      ip_ranges: IpRangeList.t ;
      ipv6_ranges: Ipv6RangeList.t ;
      prefix_list_ids: PrefixListIdList.t ;
      to_port: Integer.t option ;
      user_id_group_pairs: UserIdGroupPairList.t }
    let make ?from_port  ~ip_protocol  ?(ip_ranges= [])  ?(ipv6_ranges= []) 
      ?(prefix_list_ids= [])  ?to_port  ?(user_id_group_pairs= [])  () =
      {
        from_port;
        ip_protocol;
        ip_ranges;
        ipv6_ranges;
        prefix_list_ids;
        to_port;
        user_id_group_pairs
      }
    let parse xml =
      Some
        {
          from_port =
            (Util.option_bind (Xml.member "fromPort" xml) Integer.parse);
          ip_protocol =
            (Xml.required "ipProtocol"
               (Util.option_bind (Xml.member "ipProtocol" xml) String.parse));
          ip_ranges =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipRanges" xml)
                  IpRangeList.parse));
          ipv6_ranges =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6Ranges" xml)
                  Ipv6RangeList.parse));
          prefix_list_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "prefixListIds" xml)
                  PrefixListIdList.parse));
          to_port =
            (Util.option_bind (Xml.member "toPort" xml) Integer.parse);
          user_id_group_pairs =
            (Util.of_option []
               (Util.option_bind (Xml.member "groups" xml)
                  UserIdGroupPairList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Groups",
                   (UserIdGroupPairList.to_query v.user_id_group_pairs)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrefixListIds",
                  (PrefixListIdList.to_query v.prefix_list_ids)));
           Some
             (Query.Pair
                ("Ipv6Ranges", (Ipv6RangeList.to_query v.ipv6_ranges)));
           Some (Query.Pair ("IpRanges", (IpRangeList.to_query v.ip_ranges)));
           Some (Query.Pair ("IpProtocol", (String.to_query v.ip_protocol)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.from_port
                    (fun f ->
                       Ezxmlm.make_tag "fromPort" ([], (Integer.to_xml f)))])
                @
                [Some
                   (Ezxmlm.make_tag "ipProtocol"
                      ([], (String.to_xml v.ip_protocol)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "ipRanges"
                          ([], (IpRangeList.to_xml [x])))) v.ip_ranges))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "ipv6Ranges"
                         ([], (Ipv6RangeList.to_xml [x])))) v.ipv6_ranges))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "prefixListIds"
                        ([], (PrefixListIdList.to_xml [x]))))
                v.prefix_list_ids))
            @
            [Util.option_map v.to_port
               (fun f -> Ezxmlm.make_tag "toPort" ([], (Integer.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "groups"
                      ([], (UserIdGroupPairList.to_xml [x]))))
              v.user_id_group_pairs))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("user_id_group_pairs",
                (UserIdGroupPairList.to_json v.user_id_group_pairs));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Some
             ("prefix_list_ids",
               (PrefixListIdList.to_json v.prefix_list_ids));
           Some ("ipv6_ranges", (Ipv6RangeList.to_json v.ipv6_ranges));
           Some ("ip_ranges", (IpRangeList.to_json v.ip_ranges));
           Some ("ip_protocol", (String.to_json v.ip_protocol));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)))])
    let of_json j =
      {
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        ip_protocol =
          (String.of_json (Util.of_option_exn (Json.lookup j "ip_protocol")));
        ip_ranges =
          (IpRangeList.of_json
             (Util.of_option_exn (Json.lookup j "ip_ranges")));
        ipv6_ranges =
          (Ipv6RangeList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_ranges")));
        prefix_list_ids =
          (PrefixListIdList.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_ids")));
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        user_id_group_pairs =
          (UserIdGroupPairList.of_json
             (Util.of_option_exn (Json.lookup j "user_id_group_pairs")))
      }
  end
module AssociatedTargetNetwork =
  struct
    type t =
      {
      network_id: String.t option ;
      network_type: AssociatedNetworkType.t option }
    let make ?network_id  ?network_type  () = { network_id; network_type }
    let parse xml =
      Some
        {
          network_id =
            (Util.option_bind (Xml.member "networkId" xml) String.parse);
          network_type =
            (Util.option_bind (Xml.member "networkType" xml)
               AssociatedNetworkType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_type
              (fun f ->
                 Query.Pair
                   ("NetworkType", (AssociatedNetworkType.to_query f)));
           Util.option_map v.network_id
             (fun f -> Query.Pair ("NetworkId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.network_id
               (fun f -> Ezxmlm.make_tag "networkId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.network_type
              (fun f ->
                 Ezxmlm.make_tag "networkType"
                   ([], (AssociatedNetworkType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_type
              (fun f -> ("network_type", (AssociatedNetworkType.to_json f)));
           Util.option_map v.network_id
             (fun f -> ("network_id", (String.to_json f)))])
    let of_json j =
      {
        network_id =
          (Util.option_map (Json.lookup j "network_id") String.of_json);
        network_type =
          (Util.option_map (Json.lookup j "network_type")
             AssociatedNetworkType.of_json)
      }
  end
module ClientVpnAuthentication =
  struct
    type t =
      {
      type_: ClientVpnAuthenticationType.t option ;
      active_directory: DirectoryServiceAuthentication.t option ;
      mutual_authentication: CertificateAuthentication.t option }
    let make ?type_  ?active_directory  ?mutual_authentication  () =
      { type_; active_directory; mutual_authentication }
    let parse xml =
      Some
        {
          type_ =
            (Util.option_bind (Xml.member "type" xml)
               ClientVpnAuthenticationType.parse);
          active_directory =
            (Util.option_bind (Xml.member "activeDirectory" xml)
               DirectoryServiceAuthentication.parse);
          mutual_authentication =
            (Util.option_bind (Xml.member "mutualAuthentication" xml)
               CertificateAuthentication.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.mutual_authentication
              (fun f ->
                 Query.Pair
                   ("MutualAuthentication",
                     (CertificateAuthentication.to_query f)));
           Util.option_map v.active_directory
             (fun f ->
                Query.Pair
                  ("ActiveDirectory",
                    (DirectoryServiceAuthentication.to_query f)));
           Util.option_map v.type_
             (fun f ->
                Query.Pair ("Type", (ClientVpnAuthenticationType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.type_
                (fun f ->
                   Ezxmlm.make_tag "type"
                     ([], (ClientVpnAuthenticationType.to_xml f)))])
            @
            [Util.option_map v.active_directory
               (fun f ->
                  Ezxmlm.make_tag "activeDirectory"
                    ([], (DirectoryServiceAuthentication.to_xml f)))])
           @
           [Util.option_map v.mutual_authentication
              (fun f ->
                 Ezxmlm.make_tag "mutualAuthentication"
                   ([], (CertificateAuthentication.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.mutual_authentication
              (fun f ->
                 ("mutual_authentication",
                   (CertificateAuthentication.to_json f)));
           Util.option_map v.active_directory
             (fun f ->
                ("active_directory",
                  (DirectoryServiceAuthentication.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (ClientVpnAuthenticationType.to_json f)))])
    let of_json j =
      {
        type_ =
          (Util.option_map (Json.lookup j "type_")
             ClientVpnAuthenticationType.of_json);
        active_directory =
          (Util.option_map (Json.lookup j "active_directory")
             DirectoryServiceAuthentication.of_json);
        mutual_authentication =
          (Util.option_map (Json.lookup j "mutual_authentication")
             CertificateAuthentication.of_json)
      }
  end
module ClientVpnEndpointStatusCode =
  struct
    type t =
      | Pending_associate 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending-associate", Pending_associate)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending_associate, "pending-associate")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FleetLaunchTemplateOverridesRequest =
  struct
    type t =
      {
      instance_type: InstanceType.t option ;
      max_price: String.t option ;
      subnet_id: String.t option ;
      availability_zone: String.t option ;
      weighted_capacity: Double.t option ;
      priority: Double.t option ;
      placement: Placement.t option }
    let make ?instance_type  ?max_price  ?subnet_id  ?availability_zone 
      ?weighted_capacity  ?priority  ?placement  () =
      {
        instance_type;
        max_price;
        subnet_id;
        availability_zone;
        weighted_capacity;
        priority;
        placement
      }
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml)
               InstanceType.parse);
          max_price =
            (Util.option_bind (Xml.member "MaxPrice" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "SubnetId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          weighted_capacity =
            (Util.option_bind (Xml.member "WeightedCapacity" xml)
               Double.parse);
          priority =
            (Util.option_bind (Xml.member "Priority" xml) Double.parse);
          placement =
            (Util.option_bind (Xml.member "Placement" xml) Placement.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.placement
              (fun f -> Query.Pair ("Placement", (Placement.to_query f)));
           Util.option_map v.priority
             (fun f -> Query.Pair ("Priority", (Double.to_query f)));
           Util.option_map v.weighted_capacity
             (fun f -> Query.Pair ("WeightedCapacity", (Double.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.max_price
             (fun f -> Query.Pair ("MaxPrice", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.instance_type
                    (fun f ->
                       Ezxmlm.make_tag "InstanceType"
                         ([], (InstanceType.to_xml f)))])
                @
                [Util.option_map v.max_price
                   (fun f ->
                      Ezxmlm.make_tag "MaxPrice" ([], (String.to_xml f)))])
               @
               [Util.option_map v.subnet_id
                  (fun f ->
                     Ezxmlm.make_tag "SubnetId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.availability_zone
                 (fun f ->
                    Ezxmlm.make_tag "AvailabilityZone"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.weighted_capacity
                (fun f ->
                   Ezxmlm.make_tag "WeightedCapacity" ([], (Double.to_xml f)))])
            @
            [Util.option_map v.priority
               (fun f -> Ezxmlm.make_tag "Priority" ([], (Double.to_xml f)))])
           @
           [Util.option_map v.placement
              (fun f ->
                 Ezxmlm.make_tag "Placement" ([], (Placement.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.placement
              (fun f -> ("placement", (Placement.to_json f)));
           Util.option_map v.priority
             (fun f -> ("priority", (Double.to_json f)));
           Util.option_map v.weighted_capacity
             (fun f -> ("weighted_capacity", (Double.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.max_price
             (fun f -> ("max_price", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)))])
    let of_json j =
      {
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        max_price =
          (Util.option_map (Json.lookup j "max_price") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        weighted_capacity =
          (Util.option_map (Json.lookup j "weighted_capacity") Double.of_json);
        priority =
          (Util.option_map (Json.lookup j "priority") Double.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement") Placement.of_json)
      }
  end
module InternetGatewayAttachment =
  struct
    type t = {
      state: AttachmentStatus.t ;
      vpc_id: String.t }
    let make ~state  ~vpc_id  () = { state; vpc_id }
    let parse xml =
      Some
        {
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml)
                  AttachmentStatus.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some (Query.Pair ("State", (AttachmentStatus.to_query v.state)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "state"
                  ([], (AttachmentStatus.to_xml v.state)))])
           @ [Some (Ezxmlm.make_tag "vpcId" ([], (String.to_xml v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("state", (AttachmentStatus.to_json v.state))])
    let of_json j =
      {
        state =
          (AttachmentStatus.of_json
             (Util.of_option_exn (Json.lookup j "state")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DescribeFleetError =
  struct
    type t =
      {
      launch_template_and_overrides:
        LaunchTemplateAndOverridesResponse.t option ;
      lifecycle: InstanceLifecycle.t option ;
      error_code: String.t option ;
      error_message: String.t option }
    let make ?launch_template_and_overrides  ?lifecycle  ?error_code 
      ?error_message  () =
      { launch_template_and_overrides; lifecycle; error_code; error_message }
    let parse xml =
      Some
        {
          launch_template_and_overrides =
            (Util.option_bind (Xml.member "launchTemplateAndOverrides" xml)
               LaunchTemplateAndOverridesResponse.parse);
          lifecycle =
            (Util.option_bind (Xml.member "lifecycle" xml)
               InstanceLifecycle.parse);
          error_code =
            (Util.option_bind (Xml.member "errorCode" xml) String.parse);
          error_message =
            (Util.option_bind (Xml.member "errorMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.error_message
              (fun f -> Query.Pair ("ErrorMessage", (String.to_query f)));
           Util.option_map v.error_code
             (fun f -> Query.Pair ("ErrorCode", (String.to_query f)));
           Util.option_map v.lifecycle
             (fun f ->
                Query.Pair ("Lifecycle", (InstanceLifecycle.to_query f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                Query.Pair
                  ("LaunchTemplateAndOverrides",
                    (LaunchTemplateAndOverridesResponse.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.launch_template_and_overrides
                 (fun f ->
                    Ezxmlm.make_tag "launchTemplateAndOverrides"
                      ([], (LaunchTemplateAndOverridesResponse.to_xml f)))])
             @
             [Util.option_map v.lifecycle
                (fun f ->
                   Ezxmlm.make_tag "lifecycle"
                     ([], (InstanceLifecycle.to_xml f)))])
            @
            [Util.option_map v.error_code
               (fun f -> Ezxmlm.make_tag "errorCode" ([], (String.to_xml f)))])
           @
           [Util.option_map v.error_message
              (fun f ->
                 Ezxmlm.make_tag "errorMessage" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.error_message
              (fun f -> ("error_message", (String.to_json f)));
           Util.option_map v.error_code
             (fun f -> ("error_code", (String.to_json f)));
           Util.option_map v.lifecycle
             (fun f -> ("lifecycle", (InstanceLifecycle.to_json f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                ("launch_template_and_overrides",
                  (LaunchTemplateAndOverridesResponse.to_json f)))])
    let of_json j =
      {
        launch_template_and_overrides =
          (Util.option_map (Json.lookup j "launch_template_and_overrides")
             LaunchTemplateAndOverridesResponse.of_json);
        lifecycle =
          (Util.option_map (Json.lookup j "lifecycle")
             InstanceLifecycle.of_json);
        error_code =
          (Util.option_map (Json.lookup j "error_code") String.of_json);
        error_message =
          (Util.option_map (Json.lookup j "error_message") String.of_json)
      }
  end
module DescribeFleetsInstances =
  struct
    type t =
      {
      launch_template_and_overrides:
        LaunchTemplateAndOverridesResponse.t option ;
      lifecycle: InstanceLifecycle.t option ;
      instance_ids: InstanceIdsSet.t ;
      instance_type: InstanceType.t option ;
      platform: PlatformValues.t option }
    let make ?launch_template_and_overrides  ?lifecycle  ?(instance_ids= []) 
      ?instance_type  ?platform  () =
      {
        launch_template_and_overrides;
        lifecycle;
        instance_ids;
        instance_type;
        platform
      }
    let parse xml =
      Some
        {
          launch_template_and_overrides =
            (Util.option_bind (Xml.member "launchTemplateAndOverrides" xml)
               LaunchTemplateAndOverridesResponse.parse);
          lifecycle =
            (Util.option_bind (Xml.member "lifecycle" xml)
               InstanceLifecycle.parse);
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceIds" xml)
                  InstanceIdsSet.parse));
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.platform
              (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Some
             (Query.Pair
                ("InstanceIds", (InstanceIdsSet.to_query v.instance_ids)));
           Util.option_map v.lifecycle
             (fun f ->
                Query.Pair ("Lifecycle", (InstanceLifecycle.to_query f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                Query.Pair
                  ("LaunchTemplateAndOverrides",
                    (LaunchTemplateAndOverridesResponse.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.launch_template_and_overrides
                  (fun f ->
                     Ezxmlm.make_tag "launchTemplateAndOverrides"
                       ([], (LaunchTemplateAndOverridesResponse.to_xml f)))])
              @
              [Util.option_map v.lifecycle
                 (fun f ->
                    Ezxmlm.make_tag "lifecycle"
                      ([], (InstanceLifecycle.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "instanceIds"
                        ([], (InstanceIdsSet.to_xml [x])))) v.instance_ids))
            @
            [Util.option_map v.instance_type
               (fun f ->
                  Ezxmlm.make_tag "instanceType"
                    ([], (InstanceType.to_xml f)))])
           @
           [Util.option_map v.platform
              (fun f ->
                 Ezxmlm.make_tag "platform" ([], (PlatformValues.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.platform
              (fun f -> ("platform", (PlatformValues.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Some ("instance_ids", (InstanceIdsSet.to_json v.instance_ids));
           Util.option_map v.lifecycle
             (fun f -> ("lifecycle", (InstanceLifecycle.to_json f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                ("launch_template_and_overrides",
                  (LaunchTemplateAndOverridesResponse.to_json f)))])
    let of_json j =
      {
        launch_template_and_overrides =
          (Util.option_map (Json.lookup j "launch_template_and_overrides")
             LaunchTemplateAndOverridesResponse.of_json);
        lifecycle =
          (Util.option_map (Json.lookup j "lifecycle")
             InstanceLifecycle.of_json);
        instance_ids =
          (InstanceIdsSet.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") PlatformValues.of_json)
      }
  end
module FleetLaunchTemplateConfig =
  struct
    type t =
      {
      launch_template_specification:
        FleetLaunchTemplateSpecification.t option ;
      overrides: FleetLaunchTemplateOverridesList.t }
    let make ?launch_template_specification  ?(overrides= [])  () =
      { launch_template_specification; overrides }
    let parse xml =
      Some
        {
          launch_template_specification =
            (Util.option_bind (Xml.member "launchTemplateSpecification" xml)
               FleetLaunchTemplateSpecification.parse);
          overrides =
            (Util.of_option []
               (Util.option_bind (Xml.member "overrides" xml)
                  FleetLaunchTemplateOverridesList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Overrides",
                   (FleetLaunchTemplateOverridesList.to_query v.overrides)));
           Util.option_map v.launch_template_specification
             (fun f ->
                Query.Pair
                  ("LaunchTemplateSpecification",
                    (FleetLaunchTemplateSpecification.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.launch_template_specification
               (fun f ->
                  Ezxmlm.make_tag "launchTemplateSpecification"
                    ([], (FleetLaunchTemplateSpecification.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "overrides"
                      ([], (FleetLaunchTemplateOverridesList.to_xml [x]))))
              v.overrides))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("overrides",
                (FleetLaunchTemplateOverridesList.to_json v.overrides));
           Util.option_map v.launch_template_specification
             (fun f ->
                ("launch_template_specification",
                  (FleetLaunchTemplateSpecification.to_json f)))])
    let of_json j =
      {
        launch_template_specification =
          (Util.option_map (Json.lookup j "launch_template_specification")
             FleetLaunchTemplateSpecification.of_json);
        overrides =
          (FleetLaunchTemplateOverridesList.of_json
             (Util.of_option_exn (Json.lookup j "overrides")))
      }
  end
module CapacityReservationOptions =
  struct
    type t =
      {
      usage_strategy: FleetCapacityReservationUsageStrategy.t option }
    let make ?usage_strategy  () = { usage_strategy }
    let parse xml =
      Some
        {
          usage_strategy =
            (Util.option_bind (Xml.member "usageStrategy" xml)
               FleetCapacityReservationUsageStrategy.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.usage_strategy
              (fun f ->
                 Query.Pair
                   ("UsageStrategy",
                     (FleetCapacityReservationUsageStrategy.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.usage_strategy
              (fun f ->
                 Ezxmlm.make_tag "usageStrategy"
                   ([], (FleetCapacityReservationUsageStrategy.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.usage_strategy
              (fun f ->
                 ("usage_strategy",
                   (FleetCapacityReservationUsageStrategy.to_json f)))])
    let of_json j =
      {
        usage_strategy =
          (Util.option_map (Json.lookup j "usage_strategy")
             FleetCapacityReservationUsageStrategy.of_json)
      }
  end
module FleetOnDemandAllocationStrategy =
  struct
    type t =
      | Lowest_price 
      | Prioritized 
    let str_to_t =
      [("prioritized", Prioritized); ("lowest-price", Lowest_price)]
    let t_to_str =
      [(Prioritized, "prioritized"); (Lowest_price, "lowest-price")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SpotAllocationStrategy =
  struct
    type t =
      | Lowest_price 
      | Diversified 
      | Capacity_optimized 
    let str_to_t =
      [("capacity-optimized", Capacity_optimized);
      ("diversified", Diversified);
      ("lowest-price", Lowest_price)]
    let t_to_str =
      [(Capacity_optimized, "capacity-optimized");
      (Diversified, "diversified");
      (Lowest_price, "lowest-price")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SpotInstanceInterruptionBehavior =
  struct
    type t =
      | Hibernate 
      | Stop 
      | Terminate 
    let str_to_t =
      [("terminate", Terminate); ("stop", Stop); ("hibernate", Hibernate)]
    let t_to_str =
      [(Terminate, "terminate"); (Stop, "stop"); (Hibernate, "hibernate")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DefaultTargetCapacityType =
  struct
    type t =
      | Spot 
      | On_demand 
    let str_to_t = [("on-demand", On_demand); ("spot", Spot)]
    let t_to_str = [(On_demand, "on-demand"); (Spot, "spot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AllocationStrategy =
  struct
    type t =
      | LowestPrice 
      | Diversified 
      | CapacityOptimized 
    let str_to_t =
      [("capacityOptimized", CapacityOptimized);
      ("diversified", Diversified);
      ("lowestPrice", LowestPrice)]
    let t_to_str =
      [(CapacityOptimized, "capacityOptimized");
      (Diversified, "diversified");
      (LowestPrice, "lowestPrice")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ExcessCapacityTerminationPolicy =
  struct
    type t =
      | NoTermination 
      | Default 
    let str_to_t = [("default", Default); ("noTermination", NoTermination)]
    let t_to_str = [(Default, "default"); (NoTermination, "noTermination")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FleetType =
  struct
    type t =
      | Request 
      | Maintain 
      | Instant 
    let str_to_t =
      [("instant", Instant); ("maintain", Maintain); ("request", Request)]
    let t_to_str =
      [(Instant, "instant"); (Maintain, "maintain"); (Request, "request")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LaunchSpecsList =
  struct
    type t = SpotFleetLaunchSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SpotFleetLaunchSpecification.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list SpotFleetLaunchSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list SpotFleetLaunchSpecification.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (SpotFleetLaunchSpecification.to_xml x))) v
    let to_json v = `List (List.map SpotFleetLaunchSpecification.to_json v)
    let of_json j = Json.to_list SpotFleetLaunchSpecification.of_json j
  end
module LaunchTemplateConfigList =
  struct
    type t = LaunchTemplateConfig.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateConfig.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LaunchTemplateConfig.to_query v
    let to_headers v =
      Headers.to_headers_list LaunchTemplateConfig.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (LaunchTemplateConfig.to_xml x))) v
    let to_json v = `List (List.map LaunchTemplateConfig.to_json v)
    let of_json j = Json.to_list LaunchTemplateConfig.of_json j
  end
module LoadBalancersConfig =
  struct
    type t =
      {
      classic_load_balancers_config: ClassicLoadBalancersConfig.t option ;
      target_groups_config: TargetGroupsConfig.t option }
    let make ?classic_load_balancers_config  ?target_groups_config  () =
      { classic_load_balancers_config; target_groups_config }
    let parse xml =
      Some
        {
          classic_load_balancers_config =
            (Util.option_bind (Xml.member "classicLoadBalancersConfig" xml)
               ClassicLoadBalancersConfig.parse);
          target_groups_config =
            (Util.option_bind (Xml.member "targetGroupsConfig" xml)
               TargetGroupsConfig.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.target_groups_config
              (fun f ->
                 Query.Pair
                   ("TargetGroupsConfig", (TargetGroupsConfig.to_query f)));
           Util.option_map v.classic_load_balancers_config
             (fun f ->
                Query.Pair
                  ("ClassicLoadBalancersConfig",
                    (ClassicLoadBalancersConfig.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.classic_load_balancers_config
               (fun f ->
                  Ezxmlm.make_tag "classicLoadBalancersConfig"
                    ([], (ClassicLoadBalancersConfig.to_xml f)))])
           @
           [Util.option_map v.target_groups_config
              (fun f ->
                 Ezxmlm.make_tag "targetGroupsConfig"
                   ([], (TargetGroupsConfig.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_groups_config
              (fun f ->
                 ("target_groups_config", (TargetGroupsConfig.to_json f)));
           Util.option_map v.classic_load_balancers_config
             (fun f ->
                ("classic_load_balancers_config",
                  (ClassicLoadBalancersConfig.to_json f)))])
    let of_json j =
      {
        classic_load_balancers_config =
          (Util.option_map (Json.lookup j "classic_load_balancers_config")
             ClassicLoadBalancersConfig.of_json);
        target_groups_config =
          (Util.option_map (Json.lookup j "target_groups_config")
             TargetGroupsConfig.of_json)
      }
  end
module OnDemandAllocationStrategy =
  struct
    type t =
      | LowestPrice 
      | Prioritized 
    let str_to_t =
      [("prioritized", Prioritized); ("lowestPrice", LowestPrice)]
    let t_to_str =
      [(Prioritized, "prioritized"); (LowestPrice, "lowestPrice")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AvailabilityZoneMessage =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module VolumeStatusAction =
  struct
    type t =
      {
      code: String.t option ;
      description: String.t option ;
      event_id: String.t option ;
      event_type: String.t option }
    let make ?code  ?description  ?event_id  ?event_type  () =
      { code; description; event_id; event_type }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          event_id =
            (Util.option_bind (Xml.member "eventId" xml) String.parse);
          event_type =
            (Util.option_bind (Xml.member "eventType" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.event_type
              (fun f -> Query.Pair ("EventType", (String.to_query f)));
           Util.option_map v.event_id
             (fun f -> Query.Pair ("EventId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.code
                 (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
            @
            [Util.option_map v.event_id
               (fun f -> Ezxmlm.make_tag "eventId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.event_type
              (fun f -> Ezxmlm.make_tag "eventType" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.event_type
              (fun f -> ("event_type", (String.to_json f)));
           Util.option_map v.event_id
             (fun f -> ("event_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        event_id =
          (Util.option_map (Json.lookup j "event_id") String.of_json);
        event_type =
          (Util.option_map (Json.lookup j "event_type") String.of_json)
      }
  end
module VolumeStatusEvent =
  struct
    type t =
      {
      description: String.t option ;
      event_id: String.t option ;
      event_type: String.t option ;
      not_after: DateTime.t option ;
      not_before: DateTime.t option }
    let make ?description  ?event_id  ?event_type  ?not_after  ?not_before 
      () = { description; event_id; event_type; not_after; not_before }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          event_id =
            (Util.option_bind (Xml.member "eventId" xml) String.parse);
          event_type =
            (Util.option_bind (Xml.member "eventType" xml) String.parse);
          not_after =
            (Util.option_bind (Xml.member "notAfter" xml) DateTime.parse);
          not_before =
            (Util.option_bind (Xml.member "notBefore" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.not_before
              (fun f -> Query.Pair ("NotBefore", (DateTime.to_query f)));
           Util.option_map v.not_after
             (fun f -> Query.Pair ("NotAfter", (DateTime.to_query f)));
           Util.option_map v.event_type
             (fun f -> Query.Pair ("EventType", (String.to_query f)));
           Util.option_map v.event_id
             (fun f -> Query.Pair ("EventId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.description
                  (fun f ->
                     Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
              @
              [Util.option_map v.event_id
                 (fun f -> Ezxmlm.make_tag "eventId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.event_type
                (fun f -> Ezxmlm.make_tag "eventType" ([], (String.to_xml f)))])
            @
            [Util.option_map v.not_after
               (fun f -> Ezxmlm.make_tag "notAfter" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.not_before
              (fun f -> Ezxmlm.make_tag "notBefore" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.not_before
              (fun f -> ("not_before", (DateTime.to_json f)));
           Util.option_map v.not_after
             (fun f -> ("not_after", (DateTime.to_json f)));
           Util.option_map v.event_type
             (fun f -> ("event_type", (String.to_json f)));
           Util.option_map v.event_id
             (fun f -> ("event_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        event_id =
          (Util.option_map (Json.lookup j "event_id") String.of_json);
        event_type =
          (Util.option_map (Json.lookup j "event_type") String.of_json);
        not_after =
          (Util.option_map (Json.lookup j "not_after") DateTime.of_json);
        not_before =
          (Util.option_map (Json.lookup j "not_before") DateTime.of_json)
      }
  end
module VolumeStatusDetailsList =
  struct
    type t = VolumeStatusDetails.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeStatusDetails.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeStatusDetails.to_query v
    let to_headers v =
      Headers.to_headers_list VolumeStatusDetails.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (VolumeStatusDetails.to_xml x))) v
    let to_json v = `List (List.map VolumeStatusDetails.to_json v)
    let of_json j = Json.to_list VolumeStatusDetails.of_json j
  end
module VolumeStatusInfoStatus =
  struct
    type t =
      | Ok 
      | Impaired 
      | Insufficient_data 
    let str_to_t =
      [("insufficient-data", Insufficient_data);
      ("impaired", Impaired);
      ("ok", Ok)]
    let t_to_str =
      [(Insufficient_data, "insufficient-data");
      (Impaired, "impaired");
      (Ok, "ok")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ClientVpnAuthorizationRuleStatusCode =
  struct
    type t =
      | Authorizing 
      | Active 
      | Failed 
      | Revoking 
    let str_to_t =
      [("revoking", Revoking);
      ("failed", Failed);
      ("active", Active);
      ("authorizing", Authorizing)]
    let t_to_str =
      [(Revoking, "revoking");
      (Failed, "failed");
      (Active, "active");
      (Authorizing, "authorizing")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module UnsuccessfulInstanceCreditSpecificationErrorCode =
  struct
    type t =
      | InvalidInstanceID_Malformed 
      | InvalidInstanceID_NotFound 
      | IncorrectInstanceState 
      | InstanceCreditSpecification_NotSupported 
    let str_to_t =
      [("InstanceCreditSpecification.NotSupported",
         InstanceCreditSpecification_NotSupported);
      ("IncorrectInstanceState", IncorrectInstanceState);
      ("InvalidInstanceID.NotFound", InvalidInstanceID_NotFound);
      ("InvalidInstanceID.Malformed", InvalidInstanceID_Malformed)]
    let t_to_str =
      [(InstanceCreditSpecification_NotSupported,
         "InstanceCreditSpecification.NotSupported");
      (IncorrectInstanceState, "IncorrectInstanceState");
      (InvalidInstanceID_NotFound, "InvalidInstanceID.NotFound");
      (InvalidInstanceID_Malformed, "InvalidInstanceID.Malformed")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PricingDetail =
  struct
    type t = {
      count: Integer.t option ;
      price: Double.t option }
    let make ?count  ?price  () = { count; price }
    let parse xml =
      Some
        {
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          price = (Util.option_bind (Xml.member "price" xml) Double.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.price
              (fun f -> Query.Pair ("Price", (Double.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.count
               (fun f -> Ezxmlm.make_tag "count" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.price
              (fun f -> Ezxmlm.make_tag "price" ([], (Double.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.price (fun f -> ("price", (Double.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)))])
    let of_json j =
      {
        count = (Util.option_map (Json.lookup j "count") Integer.of_json);
        price = (Util.option_map (Json.lookup j "price") Double.of_json)
      }
  end
module Instance =
  struct
    type t =
      {
      ami_launch_index: Integer.t ;
      image_id: String.t ;
      instance_id: String.t ;
      instance_type: InstanceType.t ;
      kernel_id: String.t option ;
      key_name: String.t option ;
      launch_time: DateTime.t ;
      monitoring: Monitoring.t ;
      placement: Placement.t ;
      platform: PlatformValues.t option ;
      private_dns_name: String.t option ;
      private_ip_address: String.t option ;
      product_codes: ProductCodeList.t ;
      public_dns_name: String.t option ;
      public_ip_address: String.t option ;
      ramdisk_id: String.t option ;
      state: InstanceState.t ;
      state_transition_reason: String.t option ;
      subnet_id: String.t option ;
      vpc_id: String.t option ;
      architecture: ArchitectureValues.t ;
      block_device_mappings: InstanceBlockDeviceMappingList.t ;
      client_token: String.t option ;
      ebs_optimized: Boolean.t option ;
      ena_support: Boolean.t option ;
      hypervisor: HypervisorType.t ;
      iam_instance_profile: IamInstanceProfile.t option ;
      instance_lifecycle: InstanceLifecycleType.t option ;
      elastic_gpu_associations: ElasticGpuAssociationList.t ;
      elastic_inference_accelerator_associations:
        ElasticInferenceAcceleratorAssociationList.t ;
      network_interfaces: InstanceNetworkInterfaceList.t ;
      outpost_arn: String.t option ;
      root_device_name: String.t option ;
      root_device_type: DeviceType.t ;
      security_groups: GroupIdentifierList.t ;
      source_dest_check: Boolean.t option ;
      spot_instance_request_id: String.t option ;
      sriov_net_support: String.t option ;
      state_reason: StateReason.t option ;
      tags: TagList.t ;
      virtualization_type: VirtualizationType.t ;
      cpu_options: CpuOptions.t option ;
      capacity_reservation_id: String.t option ;
      capacity_reservation_specification:
        CapacityReservationSpecificationResponse.t option ;
      hibernation_options: HibernationOptions.t option ;
      licenses: LicenseList.t ;
      metadata_options: InstanceMetadataOptionsResponse.t option }
    let make ~ami_launch_index  ~image_id  ~instance_id  ~instance_type 
      ?kernel_id  ?key_name  ~launch_time  ~monitoring  ~placement  ?platform
       ?private_dns_name  ?private_ip_address  ?(product_codes= []) 
      ?public_dns_name  ?public_ip_address  ?ramdisk_id  ~state 
      ?state_transition_reason  ?subnet_id  ?vpc_id  ~architecture 
      ?(block_device_mappings= [])  ?client_token  ?ebs_optimized 
      ?ena_support  ~hypervisor  ?iam_instance_profile  ?instance_lifecycle 
      ?(elastic_gpu_associations= []) 
      ?(elastic_inference_accelerator_associations= []) 
      ?(network_interfaces= [])  ?outpost_arn  ?root_device_name 
      ~root_device_type  ?(security_groups= [])  ?source_dest_check 
      ?spot_instance_request_id  ?sriov_net_support  ?state_reason  ?(tags=
      [])  ~virtualization_type  ?cpu_options  ?capacity_reservation_id 
      ?capacity_reservation_specification  ?hibernation_options  ?(licenses=
      [])  ?metadata_options  () =
      {
        ami_launch_index;
        image_id;
        instance_id;
        instance_type;
        kernel_id;
        key_name;
        launch_time;
        monitoring;
        placement;
        platform;
        private_dns_name;
        private_ip_address;
        product_codes;
        public_dns_name;
        public_ip_address;
        ramdisk_id;
        state;
        state_transition_reason;
        subnet_id;
        vpc_id;
        architecture;
        block_device_mappings;
        client_token;
        ebs_optimized;
        ena_support;
        hypervisor;
        iam_instance_profile;
        instance_lifecycle;
        elastic_gpu_associations;
        elastic_inference_accelerator_associations;
        network_interfaces;
        outpost_arn;
        root_device_name;
        root_device_type;
        security_groups;
        source_dest_check;
        spot_instance_request_id;
        sriov_net_support;
        state_reason;
        tags;
        virtualization_type;
        cpu_options;
        capacity_reservation_id;
        capacity_reservation_specification;
        hibernation_options;
        licenses;
        metadata_options
      }
    let parse xml =
      Some
        {
          ami_launch_index =
            (Xml.required "amiLaunchIndex"
               (Util.option_bind (Xml.member "amiLaunchIndex" xml)
                  Integer.parse));
          image_id =
            (Xml.required "imageId"
               (Util.option_bind (Xml.member "imageId" xml) String.parse));
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          instance_type =
            (Xml.required "instanceType"
               (Util.option_bind (Xml.member "instanceType" xml)
                  InstanceType.parse));
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          launch_time =
            (Xml.required "launchTime"
               (Util.option_bind (Xml.member "launchTime" xml) DateTime.parse));
          monitoring =
            (Xml.required "monitoring"
               (Util.option_bind (Xml.member "monitoring" xml)
                  Monitoring.parse));
          placement =
            (Xml.required "placement"
               (Util.option_bind (Xml.member "placement" xml) Placement.parse));
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          public_dns_name =
            (Util.option_bind (Xml.member "dnsName" xml) String.parse);
          public_ip_address =
            (Util.option_bind (Xml.member "ipAddress" xml) String.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          state =
            (Xml.required "instanceState"
               (Util.option_bind (Xml.member "instanceState" xml)
                  InstanceState.parse));
          state_transition_reason =
            (Util.option_bind (Xml.member "reason" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          architecture =
            (Xml.required "architecture"
               (Util.option_bind (Xml.member "architecture" xml)
                  ArchitectureValues.parse));
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  InstanceBlockDeviceMappingList.parse));
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          ena_support =
            (Util.option_bind (Xml.member "enaSupport" xml) Boolean.parse);
          hypervisor =
            (Xml.required "hypervisor"
               (Util.option_bind (Xml.member "hypervisor" xml)
                  HypervisorType.parse));
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfile.parse);
          instance_lifecycle =
            (Util.option_bind (Xml.member "instanceLifecycle" xml)
               InstanceLifecycleType.parse);
          elastic_gpu_associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "elasticGpuAssociationSet" xml)
                  ElasticGpuAssociationList.parse));
          elastic_inference_accelerator_associations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "elasticInferenceAcceleratorAssociationSet" xml)
                  ElasticInferenceAcceleratorAssociationList.parse));
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  InstanceNetworkInterfaceList.parse));
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          root_device_name =
            (Util.option_bind (Xml.member "rootDeviceName" xml) String.parse);
          root_device_type =
            (Xml.required "rootDeviceType"
               (Util.option_bind (Xml.member "rootDeviceType" xml)
                  DeviceType.parse));
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               Boolean.parse);
          spot_instance_request_id =
            (Util.option_bind (Xml.member "spotInstanceRequestId" xml)
               String.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml) String.parse);
          state_reason =
            (Util.option_bind (Xml.member "stateReason" xml)
               StateReason.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          virtualization_type =
            (Xml.required "virtualizationType"
               (Util.option_bind (Xml.member "virtualizationType" xml)
                  VirtualizationType.parse));
          cpu_options =
            (Util.option_bind (Xml.member "cpuOptions" xml) CpuOptions.parse);
          capacity_reservation_id =
            (Util.option_bind (Xml.member "capacityReservationId" xml)
               String.parse);
          capacity_reservation_specification =
            (Util.option_bind
               (Xml.member "capacityReservationSpecification" xml)
               CapacityReservationSpecificationResponse.parse);
          hibernation_options =
            (Util.option_bind (Xml.member "hibernationOptions" xml)
               HibernationOptions.parse);
          licenses =
            (Util.of_option []
               (Util.option_bind (Xml.member "licenseSet" xml)
                  LicenseList.parse));
          metadata_options =
            (Util.option_bind (Xml.member "metadataOptions" xml)
               InstanceMetadataOptionsResponse.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.metadata_options
              (fun f ->
                 Query.Pair
                   ("MetadataOptions",
                     (InstanceMetadataOptionsResponse.to_query f)));
           Some
             (Query.Pair ("LicenseSet", (LicenseList.to_query v.licenses)));
           Util.option_map v.hibernation_options
             (fun f ->
                Query.Pair
                  ("HibernationOptions", (HibernationOptions.to_query f)));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                Query.Pair
                  ("CapacityReservationSpecification",
                    (CapacityReservationSpecificationResponse.to_query f)));
           Util.option_map v.capacity_reservation_id
             (fun f ->
                Query.Pair ("CapacityReservationId", (String.to_query f)));
           Util.option_map v.cpu_options
             (fun f -> Query.Pair ("CpuOptions", (CpuOptions.to_query f)));
           Some
             (Query.Pair
                ("VirtualizationType",
                  (VirtualizationType.to_query v.virtualization_type)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.state_reason
             (fun f -> Query.Pair ("StateReason", (StateReason.to_query f)));
           Util.option_map v.sriov_net_support
             (fun f -> Query.Pair ("SriovNetSupport", (String.to_query f)));
           Util.option_map v.spot_instance_request_id
             (fun f ->
                Query.Pair ("SpotInstanceRequestId", (String.to_query f)));
           Util.option_map v.source_dest_check
             (fun f -> Query.Pair ("SourceDestCheck", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("GroupSet",
                  (GroupIdentifierList.to_query v.security_groups)));
           Some
             (Query.Pair
                ("RootDeviceType", (DeviceType.to_query v.root_device_type)));
           Util.option_map v.root_device_name
             (fun f -> Query.Pair ("RootDeviceName", (String.to_query f)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (InstanceNetworkInterfaceList.to_query v.network_interfaces)));
           Some
             (Query.Pair
                ("ElasticInferenceAcceleratorAssociationSet",
                  (ElasticInferenceAcceleratorAssociationList.to_query
                     v.elastic_inference_accelerator_associations)));
           Some
             (Query.Pair
                ("ElasticGpuAssociationSet",
                  (ElasticGpuAssociationList.to_query
                     v.elastic_gpu_associations)));
           Util.option_map v.instance_lifecycle
             (fun f ->
                Query.Pair
                  ("InstanceLifecycle", (InstanceLifecycleType.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile", (IamInstanceProfile.to_query f)));
           Some
             (Query.Pair
                ("Hypervisor", (HypervisorType.to_query v.hypervisor)));
           Util.option_map v.ena_support
             (fun f -> Query.Pair ("EnaSupport", (Boolean.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (InstanceBlockDeviceMappingList.to_query
                     v.block_device_mappings)));
           Some
             (Query.Pair
                ("Architecture",
                  (ArchitectureValues.to_query v.architecture)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.state_transition_reason
             (fun f -> Query.Pair ("Reason", (String.to_query f)));
           Some
             (Query.Pair ("InstanceState", (InstanceState.to_query v.state)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.public_ip_address
             (fun f -> Query.Pair ("IpAddress", (String.to_query f)));
           Util.option_map v.public_dns_name
             (fun f -> Query.Pair ("DnsName", (String.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Some (Query.Pair ("Placement", (Placement.to_query v.placement)));
           Some
             (Query.Pair ("Monitoring", (Monitoring.to_query v.monitoring)));
           Some
             (Query.Pair ("LaunchTime", (DateTime.to_query v.launch_time)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceType", (InstanceType.to_query v.instance_type)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Some
             (Query.Pair
                ("AmiLaunchIndex", (Integer.to_query v.ami_launch_index)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((((((((((((((((((((((((((((((((([] @
                                                         [Some
                                                            (Ezxmlm.make_tag
                                                               "amiLaunchIndex"
                                                               ([],
                                                                 (Integer.to_xml
                                                                    v.ami_launch_index)))])
                                                        @
                                                        [Some
                                                           (Ezxmlm.make_tag
                                                              "imageId"
                                                              ([],
                                                                (String.to_xml
                                                                   v.image_id)))])
                                                       @
                                                       [Some
                                                          (Ezxmlm.make_tag
                                                             "instanceId"
                                                             ([],
                                                               (String.to_xml
                                                                  v.instance_id)))])
                                                      @
                                                      [Some
                                                         (Ezxmlm.make_tag
                                                            "instanceType"
                                                            ([],
                                                              (InstanceType.to_xml
                                                                 v.instance_type)))])
                                                     @
                                                     [Util.option_map
                                                        v.kernel_id
                                                        (fun f ->
                                                           Ezxmlm.make_tag
                                                             "kernelId"
                                                             ([],
                                                               (String.to_xml
                                                                  f)))])
                                                    @
                                                    [Util.option_map
                                                       v.key_name
                                                       (fun f ->
                                                          Ezxmlm.make_tag
                                                            "keyName"
                                                            ([],
                                                              (String.to_xml
                                                                 f)))])
                                                   @
                                                   [Some
                                                      (Ezxmlm.make_tag
                                                         "launchTime"
                                                         ([],
                                                           (DateTime.to_xml
                                                              v.launch_time)))])
                                                  @
                                                  [Some
                                                     (Ezxmlm.make_tag
                                                        "monitoring"
                                                        ([],
                                                          (Monitoring.to_xml
                                                             v.monitoring)))])
                                                 @
                                                 [Some
                                                    (Ezxmlm.make_tag
                                                       "placement"
                                                       ([],
                                                         (Placement.to_xml
                                                            v.placement)))])
                                                @
                                                [Util.option_map v.platform
                                                   (fun f ->
                                                      Ezxmlm.make_tag
                                                        "platform"
                                                        ([],
                                                          (PlatformValues.to_xml
                                                             f)))])
                                               @
                                               [Util.option_map
                                                  v.private_dns_name
                                                  (fun f ->
                                                     Ezxmlm.make_tag
                                                       "privateDnsName"
                                                       ([],
                                                         (String.to_xml f)))])
                                              @
                                              [Util.option_map
                                                 v.private_ip_address
                                                 (fun f ->
                                                    Ezxmlm.make_tag
                                                      "privateIpAddress"
                                                      ([], (String.to_xml f)))])
                                             @
                                             (List.map
                                                (fun x ->
                                                   Some
                                                     (Ezxmlm.make_tag
                                                        "productCodes"
                                                        ([],
                                                          (ProductCodeList.to_xml
                                                             [x]))))
                                                v.product_codes))
                                            @
                                            [Util.option_map
                                               v.public_dns_name
                                               (fun f ->
                                                  Ezxmlm.make_tag "dnsName"
                                                    ([], (String.to_xml f)))])
                                           @
                                           [Util.option_map
                                              v.public_ip_address
                                              (fun f ->
                                                 Ezxmlm.make_tag "ipAddress"
                                                   ([], (String.to_xml f)))])
                                          @
                                          [Util.option_map v.ramdisk_id
                                             (fun f ->
                                                Ezxmlm.make_tag "ramdiskId"
                                                  ([], (String.to_xml f)))])
                                         @
                                         [Some
                                            (Ezxmlm.make_tag "instanceState"
                                               ([],
                                                 (InstanceState.to_xml
                                                    v.state)))])
                                        @
                                        [Util.option_map
                                           v.state_transition_reason
                                           (fun f ->
                                              Ezxmlm.make_tag "reason"
                                                ([], (String.to_xml f)))])
                                       @
                                       [Util.option_map v.subnet_id
                                          (fun f ->
                                             Ezxmlm.make_tag "subnetId"
                                               ([], (String.to_xml f)))])
                                      @
                                      [Util.option_map v.vpc_id
                                         (fun f ->
                                            Ezxmlm.make_tag "vpcId"
                                              ([], (String.to_xml f)))])
                                     @
                                     [Some
                                        (Ezxmlm.make_tag "architecture"
                                           ([],
                                             (ArchitectureValues.to_xml
                                                v.architecture)))])
                                    @
                                    (List.map
                                       (fun x ->
                                          Some
                                            (Ezxmlm.make_tag
                                               "blockDeviceMapping"
                                               ([],
                                                 (InstanceBlockDeviceMappingList.to_xml
                                                    [x]))))
                                       v.block_device_mappings))
                                   @
                                   [Util.option_map v.client_token
                                      (fun f ->
                                         Ezxmlm.make_tag "clientToken"
                                           ([], (String.to_xml f)))])
                                  @
                                  [Util.option_map v.ebs_optimized
                                     (fun f ->
                                        Ezxmlm.make_tag "ebsOptimized"
                                          ([], (Boolean.to_xml f)))])
                                 @
                                 [Util.option_map v.ena_support
                                    (fun f ->
                                       Ezxmlm.make_tag "enaSupport"
                                         ([], (Boolean.to_xml f)))])
                                @
                                [Some
                                   (Ezxmlm.make_tag "hypervisor"
                                      ([],
                                        (HypervisorType.to_xml v.hypervisor)))])
                               @
                               [Util.option_map v.iam_instance_profile
                                  (fun f ->
                                     Ezxmlm.make_tag "iamInstanceProfile"
                                       ([], (IamInstanceProfile.to_xml f)))])
                              @
                              [Util.option_map v.instance_lifecycle
                                 (fun f ->
                                    Ezxmlm.make_tag "instanceLifecycle"
                                      ([], (InstanceLifecycleType.to_xml f)))])
                             @
                             (List.map
                                (fun x ->
                                   Some
                                     (Ezxmlm.make_tag
                                        "elasticGpuAssociationSet"
                                        ([],
                                          (ElasticGpuAssociationList.to_xml
                                             [x]))))
                                v.elastic_gpu_associations))
                            @
                            (List.map
                               (fun x ->
                                  Some
                                    (Ezxmlm.make_tag
                                       "elasticInferenceAcceleratorAssociationSet"
                                       ([],
                                         (ElasticInferenceAcceleratorAssociationList.to_xml
                                            [x]))))
                               v.elastic_inference_accelerator_associations))
                           @
                           (List.map
                              (fun x ->
                                 Some
                                   (Ezxmlm.make_tag "networkInterfaceSet"
                                      ([],
                                        (InstanceNetworkInterfaceList.to_xml
                                           [x])))) v.network_interfaces))
                          @
                          [Util.option_map v.outpost_arn
                             (fun f ->
                                Ezxmlm.make_tag "outpostArn"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.root_device_name
                            (fun f ->
                               Ezxmlm.make_tag "rootDeviceName"
                                 ([], (String.to_xml f)))])
                        @
                        [Some
                           (Ezxmlm.make_tag "rootDeviceType"
                              ([], (DeviceType.to_xml v.root_device_type)))])
                       @
                       (List.map
                          (fun x ->
                             Some
                               (Ezxmlm.make_tag "groupSet"
                                  ([], (GroupIdentifierList.to_xml [x]))))
                          v.security_groups))
                      @
                      [Util.option_map v.source_dest_check
                         (fun f ->
                            Ezxmlm.make_tag "sourceDestCheck"
                              ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.spot_instance_request_id
                        (fun f ->
                           Ezxmlm.make_tag "spotInstanceRequestId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.sriov_net_support
                       (fun f ->
                          Ezxmlm.make_tag "sriovNetSupport"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.state_reason
                      (fun f ->
                         Ezxmlm.make_tag "stateReason"
                           ([], (StateReason.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "tagSet"
                             ([], (TagList.to_xml [x])))) v.tags))
                 @
                 [Some
                    (Ezxmlm.make_tag "virtualizationType"
                       ([],
                         (VirtualizationType.to_xml v.virtualization_type)))])
                @
                [Util.option_map v.cpu_options
                   (fun f ->
                      Ezxmlm.make_tag "cpuOptions"
                        ([], (CpuOptions.to_xml f)))])
               @
               [Util.option_map v.capacity_reservation_id
                  (fun f ->
                     Ezxmlm.make_tag "capacityReservationId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.capacity_reservation_specification
                 (fun f ->
                    Ezxmlm.make_tag "capacityReservationSpecification"
                      ([],
                        (CapacityReservationSpecificationResponse.to_xml f)))])
             @
             [Util.option_map v.hibernation_options
                (fun f ->
                   Ezxmlm.make_tag "hibernationOptions"
                     ([], (HibernationOptions.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "licenseSet"
                       ([], (LicenseList.to_xml [x])))) v.licenses))
           @
           [Util.option_map v.metadata_options
              (fun f ->
                 Ezxmlm.make_tag "metadataOptions"
                   ([], (InstanceMetadataOptionsResponse.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.metadata_options
              (fun f ->
                 ("metadata_options",
                   (InstanceMetadataOptionsResponse.to_json f)));
           Some ("licenses", (LicenseList.to_json v.licenses));
           Util.option_map v.hibernation_options
             (fun f ->
                ("hibernation_options", (HibernationOptions.to_json f)));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                ("capacity_reservation_specification",
                  (CapacityReservationSpecificationResponse.to_json f)));
           Util.option_map v.capacity_reservation_id
             (fun f -> ("capacity_reservation_id", (String.to_json f)));
           Util.option_map v.cpu_options
             (fun f -> ("cpu_options", (CpuOptions.to_json f)));
           Some
             ("virtualization_type",
               (VirtualizationType.to_json v.virtualization_type));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.state_reason
             (fun f -> ("state_reason", (StateReason.to_json f)));
           Util.option_map v.sriov_net_support
             (fun f -> ("sriov_net_support", (String.to_json f)));
           Util.option_map v.spot_instance_request_id
             (fun f -> ("spot_instance_request_id", (String.to_json f)));
           Util.option_map v.source_dest_check
             (fun f -> ("source_dest_check", (Boolean.to_json f)));
           Some
             ("security_groups",
               (GroupIdentifierList.to_json v.security_groups));
           Some ("root_device_type", (DeviceType.to_json v.root_device_type));
           Util.option_map v.root_device_name
             (fun f -> ("root_device_name", (String.to_json f)));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceList.to_json v.network_interfaces));
           Some
             ("elastic_inference_accelerator_associations",
               (ElasticInferenceAcceleratorAssociationList.to_json
                  v.elastic_inference_accelerator_associations));
           Some
             ("elastic_gpu_associations",
               (ElasticGpuAssociationList.to_json v.elastic_gpu_associations));
           Util.option_map v.instance_lifecycle
             (fun f ->
                ("instance_lifecycle", (InstanceLifecycleType.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile", (IamInstanceProfile.to_json f)));
           Some ("hypervisor", (HypervisorType.to_json v.hypervisor));
           Util.option_map v.ena_support
             (fun f -> ("ena_support", (Boolean.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some
             ("block_device_mappings",
               (InstanceBlockDeviceMappingList.to_json
                  v.block_device_mappings));
           Some ("architecture", (ArchitectureValues.to_json v.architecture));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.state_transition_reason
             (fun f -> ("state_transition_reason", (String.to_json f)));
           Some ("state", (InstanceState.to_json v.state));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.public_ip_address
             (fun f -> ("public_ip_address", (String.to_json f)));
           Util.option_map v.public_dns_name
             (fun f -> ("public_dns_name", (String.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (PlatformValues.to_json f)));
           Some ("placement", (Placement.to_json v.placement));
           Some ("monitoring", (Monitoring.to_json v.monitoring));
           Some ("launch_time", (DateTime.to_json v.launch_time));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Some ("instance_type", (InstanceType.to_json v.instance_type));
           Some ("instance_id", (String.to_json v.instance_id));
           Some ("image_id", (String.to_json v.image_id));
           Some ("ami_launch_index", (Integer.to_json v.ami_launch_index))])
    let of_json j =
      {
        ami_launch_index =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "ami_launch_index")));
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        instance_type =
          (InstanceType.of_json
             (Util.of_option_exn (Json.lookup j "instance_type")));
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        launch_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "launch_time")));
        monitoring =
          (Monitoring.of_json
             (Util.of_option_exn (Json.lookup j "monitoring")));
        placement =
          (Placement.of_json (Util.of_option_exn (Json.lookup j "placement")));
        platform =
          (Util.option_map (Json.lookup j "platform") PlatformValues.of_json);
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        public_dns_name =
          (Util.option_map (Json.lookup j "public_dns_name") String.of_json);
        public_ip_address =
          (Util.option_map (Json.lookup j "public_ip_address") String.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        state =
          (InstanceState.of_json (Util.of_option_exn (Json.lookup j "state")));
        state_transition_reason =
          (Util.option_map (Json.lookup j "state_transition_reason")
             String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        architecture =
          (ArchitectureValues.of_json
             (Util.of_option_exn (Json.lookup j "architecture")));
        block_device_mappings =
          (InstanceBlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        ena_support =
          (Util.option_map (Json.lookup j "ena_support") Boolean.of_json);
        hypervisor =
          (HypervisorType.of_json
             (Util.of_option_exn (Json.lookup j "hypervisor")));
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfile.of_json);
        instance_lifecycle =
          (Util.option_map (Json.lookup j "instance_lifecycle")
             InstanceLifecycleType.of_json);
        elastic_gpu_associations =
          (ElasticGpuAssociationList.of_json
             (Util.of_option_exn (Json.lookup j "elastic_gpu_associations")));
        elastic_inference_accelerator_associations =
          (ElasticInferenceAcceleratorAssociationList.of_json
             (Util.of_option_exn
                (Json.lookup j "elastic_inference_accelerator_associations")));
        network_interfaces =
          (InstanceNetworkInterfaceList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        root_device_name =
          (Util.option_map (Json.lookup j "root_device_name") String.of_json);
        root_device_type =
          (DeviceType.of_json
             (Util.of_option_exn (Json.lookup j "root_device_type")));
        security_groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             Boolean.of_json);
        spot_instance_request_id =
          (Util.option_map (Json.lookup j "spot_instance_request_id")
             String.of_json);
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support") String.of_json);
        state_reason =
          (Util.option_map (Json.lookup j "state_reason") StateReason.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        virtualization_type =
          (VirtualizationType.of_json
             (Util.of_option_exn (Json.lookup j "virtualization_type")));
        cpu_options =
          (Util.option_map (Json.lookup j "cpu_options") CpuOptions.of_json);
        capacity_reservation_id =
          (Util.option_map (Json.lookup j "capacity_reservation_id")
             String.of_json);
        capacity_reservation_specification =
          (Util.option_map
             (Json.lookup j "capacity_reservation_specification")
             CapacityReservationSpecificationResponse.of_json);
        hibernation_options =
          (Util.option_map (Json.lookup j "hibernation_options")
             HibernationOptions.of_json);
        licenses =
          (LicenseList.of_json
             (Util.of_option_exn (Json.lookup j "licenses")));
        metadata_options =
          (Util.option_map (Json.lookup j "metadata_options")
             InstanceMetadataOptionsResponse.of_json)
      }
  end
module PublicIpv4PoolRange =
  struct
    type t =
      {
      first_address: String.t option ;
      last_address: String.t option ;
      address_count: Integer.t option ;
      available_address_count: Integer.t option }
    let make ?first_address  ?last_address  ?address_count 
      ?available_address_count  () =
      { first_address; last_address; address_count; available_address_count }
    let parse xml =
      Some
        {
          first_address =
            (Util.option_bind (Xml.member "firstAddress" xml) String.parse);
          last_address =
            (Util.option_bind (Xml.member "lastAddress" xml) String.parse);
          address_count =
            (Util.option_bind (Xml.member "addressCount" xml) Integer.parse);
          available_address_count =
            (Util.option_bind (Xml.member "availableAddressCount" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.available_address_count
              (fun f ->
                 Query.Pair ("AvailableAddressCount", (Integer.to_query f)));
           Util.option_map v.address_count
             (fun f -> Query.Pair ("AddressCount", (Integer.to_query f)));
           Util.option_map v.last_address
             (fun f -> Query.Pair ("LastAddress", (String.to_query f)));
           Util.option_map v.first_address
             (fun f -> Query.Pair ("FirstAddress", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.first_address
                 (fun f ->
                    Ezxmlm.make_tag "firstAddress" ([], (String.to_xml f)))])
             @
             [Util.option_map v.last_address
                (fun f ->
                   Ezxmlm.make_tag "lastAddress" ([], (String.to_xml f)))])
            @
            [Util.option_map v.address_count
               (fun f ->
                  Ezxmlm.make_tag "addressCount" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.available_address_count
              (fun f ->
                 Ezxmlm.make_tag "availableAddressCount"
                   ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.available_address_count
              (fun f -> ("available_address_count", (Integer.to_json f)));
           Util.option_map v.address_count
             (fun f -> ("address_count", (Integer.to_json f)));
           Util.option_map v.last_address
             (fun f -> ("last_address", (String.to_json f)));
           Util.option_map v.first_address
             (fun f -> ("first_address", (String.to_json f)))])
    let of_json j =
      {
        first_address =
          (Util.option_map (Json.lookup j "first_address") String.of_json);
        last_address =
          (Util.option_map (Json.lookup j "last_address") String.of_json);
        address_count =
          (Util.option_map (Json.lookup j "address_count") Integer.of_json);
        available_address_count =
          (Util.option_map (Json.lookup j "available_address_count")
             Integer.of_json)
      }
  end
module VpcCidrBlockAssociation =
  struct
    type t =
      {
      association_id: String.t option ;
      cidr_block: String.t option ;
      cidr_block_state: VpcCidrBlockState.t option }
    let make ?association_id  ?cidr_block  ?cidr_block_state  () =
      { association_id; cidr_block; cidr_block_state }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse);
          cidr_block_state =
            (Util.option_bind (Xml.member "cidrBlockState" xml)
               VpcCidrBlockState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cidr_block_state
              (fun f ->
                 Query.Pair
                   ("CidrBlockState", (VpcCidrBlockState.to_query f)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.association_id
                (fun f ->
                   Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.cidr_block
               (fun f -> Ezxmlm.make_tag "cidrBlock" ([], (String.to_xml f)))])
           @
           [Util.option_map v.cidr_block_state
              (fun f ->
                 Ezxmlm.make_tag "cidrBlockState"
                   ([], (VpcCidrBlockState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cidr_block_state
              (fun f -> ("cidr_block_state", (VpcCidrBlockState.to_json f)));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        cidr_block =
          (Util.option_map (Json.lookup j "cidr_block") String.of_json);
        cidr_block_state =
          (Util.option_map (Json.lookup j "cidr_block_state")
             VpcCidrBlockState.of_json)
      }
  end
module VpcIpv6CidrBlockAssociation =
  struct
    type t =
      {
      association_id: String.t option ;
      ipv6_cidr_block: String.t option ;
      ipv6_cidr_block_state: VpcCidrBlockState.t option ;
      network_border_group: String.t option }
    let make ?association_id  ?ipv6_cidr_block  ?ipv6_cidr_block_state 
      ?network_border_group  () =
      {
        association_id;
        ipv6_cidr_block;
        ipv6_cidr_block_state;
        network_border_group
      }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "ipv6CidrBlock" xml) String.parse);
          ipv6_cidr_block_state =
            (Util.option_bind (Xml.member "ipv6CidrBlockState" xml)
               VpcCidrBlockState.parse);
          network_border_group =
            (Util.option_bind (Xml.member "networkBorderGroup" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_border_group
              (fun f ->
                 Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.ipv6_cidr_block_state
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockState", (VpcCidrBlockState.to_query f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.association_id
                 (fun f ->
                    Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.ipv6_cidr_block
                (fun f ->
                   Ezxmlm.make_tag "ipv6CidrBlock" ([], (String.to_xml f)))])
            @
            [Util.option_map v.ipv6_cidr_block_state
               (fun f ->
                  Ezxmlm.make_tag "ipv6CidrBlockState"
                    ([], (VpcCidrBlockState.to_xml f)))])
           @
           [Util.option_map v.network_border_group
              (fun f ->
                 Ezxmlm.make_tag "networkBorderGroup" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_border_group
              (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.ipv6_cidr_block_state
             (fun f ->
                ("ipv6_cidr_block_state", (VpcCidrBlockState.to_json f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        ipv6_cidr_block =
          (Util.option_map (Json.lookup j "ipv6_cidr_block") String.of_json);
        ipv6_cidr_block_state =
          (Util.option_map (Json.lookup j "ipv6_cidr_block_state")
             VpcCidrBlockState.of_json);
        network_border_group =
          (Util.option_map (Json.lookup j "network_border_group")
             String.of_json)
      }
  end
module SubnetIpv6CidrBlockAssociation =
  struct
    type t =
      {
      association_id: String.t option ;
      ipv6_cidr_block: String.t option ;
      ipv6_cidr_block_state: SubnetCidrBlockState.t option }
    let make ?association_id  ?ipv6_cidr_block  ?ipv6_cidr_block_state  () =
      { association_id; ipv6_cidr_block; ipv6_cidr_block_state }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "ipv6CidrBlock" xml) String.parse);
          ipv6_cidr_block_state =
            (Util.option_bind (Xml.member "ipv6CidrBlockState" xml)
               SubnetCidrBlockState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block_state
              (fun f ->
                 Query.Pair
                   ("Ipv6CidrBlockState", (SubnetCidrBlockState.to_query f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.association_id
                (fun f ->
                   Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.ipv6_cidr_block
               (fun f ->
                  Ezxmlm.make_tag "ipv6CidrBlock" ([], (String.to_xml f)))])
           @
           [Util.option_map v.ipv6_cidr_block_state
              (fun f ->
                 Ezxmlm.make_tag "ipv6CidrBlockState"
                   ([], (SubnetCidrBlockState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block_state
              (fun f ->
                 ("ipv6_cidr_block_state", (SubnetCidrBlockState.to_json f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        ipv6_cidr_block =
          (Util.option_map (Json.lookup j "ipv6_cidr_block") String.of_json);
        ipv6_cidr_block_state =
          (Util.option_map (Json.lookup j "ipv6_cidr_block_state")
             SubnetCidrBlockState.of_json)
      }
  end
module ElasticGpuStatus =
  struct
    type t =
      | OK 
      | IMPAIRED 
    let str_to_t = [("IMPAIRED", IMPAIRED); ("OK", OK)]
    let t_to_str = [(IMPAIRED, "IMPAIRED"); (OK, "OK")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ImportImageLicenseConfigurationResponse =
  struct
    type t = {
      license_configuration_arn: String.t option }
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "licenseConfigurationArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Ezxmlm.make_tag "licenseConfigurationArn"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let of_json j =
      {
        license_configuration_arn =
          (Util.option_map (Json.lookup j "license_configuration_arn")
             String.of_json)
      }
  end
module SnapshotDetail =
  struct
    type t =
      {
      description: String.t option ;
      device_name: String.t option ;
      disk_image_size: Double.t option ;
      format: String.t option ;
      progress: String.t option ;
      snapshot_id: String.t option ;
      status: String.t option ;
      status_message: String.t option ;
      url: String.t option ;
      user_bucket: UserBucketDetails.t option }
    let make ?description  ?device_name  ?disk_image_size  ?format  ?progress
       ?snapshot_id  ?status  ?status_message  ?url  ?user_bucket  () =
      {
        description;
        device_name;
        disk_image_size;
        format;
        progress;
        snapshot_id;
        status;
        status_message;
        url;
        user_bucket
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          disk_image_size =
            (Util.option_bind (Xml.member "diskImageSize" xml) Double.parse);
          format = (Util.option_bind (Xml.member "format" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          url = (Util.option_bind (Xml.member "url" xml) String.parse);
          user_bucket =
            (Util.option_bind (Xml.member "userBucket" xml)
               UserBucketDetails.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f ->
                 Query.Pair ("UserBucket", (UserBucketDetails.to_query f)));
           Util.option_map v.url
             (fun f -> Query.Pair ("Url", (String.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (String.to_query f)));
           Util.option_map v.disk_image_size
             (fun f -> Query.Pair ("DiskImageSize", (Double.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.description
                       (fun f ->
                          Ezxmlm.make_tag "description"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.device_name
                      (fun f ->
                         Ezxmlm.make_tag "deviceName" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.disk_image_size
                     (fun f ->
                        Ezxmlm.make_tag "diskImageSize"
                          ([], (Double.to_xml f)))])
                 @
                 [Util.option_map v.format
                    (fun f ->
                       Ezxmlm.make_tag "format" ([], (String.to_xml f)))])
                @
                [Util.option_map v.progress
                   (fun f ->
                      Ezxmlm.make_tag "progress" ([], (String.to_xml f)))])
               @
               [Util.option_map v.snapshot_id
                  (fun f ->
                     Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.status
                 (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
             @
             [Util.option_map v.status_message
                (fun f ->
                   Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
            @
            [Util.option_map v.url
               (fun f -> Ezxmlm.make_tag "url" ([], (String.to_xml f)))])
           @
           [Util.option_map v.user_bucket
              (fun f ->
                 Ezxmlm.make_tag "userBucket"
                   ([], (UserBucketDetails.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> ("user_bucket", (UserBucketDetails.to_json f)));
           Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.format (fun f -> ("format", (String.to_json f)));
           Util.option_map v.disk_image_size
             (fun f -> ("disk_image_size", (Double.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        disk_image_size =
          (Util.option_map (Json.lookup j "disk_image_size") Double.of_json);
        format = (Util.option_map (Json.lookup j "format") String.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        url = (Util.option_map (Json.lookup j "url") String.of_json);
        user_bucket =
          (Util.option_map (Json.lookup j "user_bucket")
             UserBucketDetails.of_json)
      }
  end
module ScheduledInstancesEbs =
  struct
    type t =
      {
      delete_on_termination: Boolean.t option ;
      encrypted: Boolean.t option ;
      iops: Integer.t option ;
      snapshot_id: String.t option ;
      volume_size: Integer.t option ;
      volume_type: String.t option }
    let make ?delete_on_termination  ?encrypted  ?iops  ?snapshot_id 
      ?volume_size  ?volume_type  () =
      {
        delete_on_termination;
        encrypted;
        iops;
        snapshot_id;
        volume_size;
        volume_type
      }
    let parse xml =
      Some
        {
          delete_on_termination =
            (Util.option_bind (Xml.member "DeleteOnTermination" xml)
               Boolean.parse);
          encrypted =
            (Util.option_bind (Xml.member "Encrypted" xml) Boolean.parse);
          iops = (Util.option_bind (Xml.member "Iops" xml) Integer.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "SnapshotId" xml) String.parse);
          volume_size =
            (Util.option_bind (Xml.member "VolumeSize" xml) Integer.parse);
          volume_type =
            (Util.option_bind (Xml.member "VolumeType" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> Query.Pair ("VolumeType", (String.to_query f)));
           Util.option_map v.volume_size
             (fun f -> Query.Pair ("VolumeSize", (Integer.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.delete_on_termination
                   (fun f ->
                      Ezxmlm.make_tag "DeleteOnTermination"
                        ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.encrypted
                  (fun f ->
                     Ezxmlm.make_tag "Encrypted" ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.iops
                 (fun f -> Ezxmlm.make_tag "Iops" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.snapshot_id
                (fun f ->
                   Ezxmlm.make_tag "SnapshotId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.volume_size
               (fun f ->
                  Ezxmlm.make_tag "VolumeSize" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.volume_type
              (fun f -> Ezxmlm.make_tag "VolumeType" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> ("volume_type", (String.to_json f)));
           Util.option_map v.volume_size
             (fun f -> ("volume_size", (Integer.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)))])
    let of_json j =
      {
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        volume_size =
          (Util.option_map (Json.lookup j "volume_size") Integer.of_json);
        volume_type =
          (Util.option_map (Json.lookup j "volume_type") String.of_json)
      }
  end
module PrivateIpAddressConfigSet =
  struct
    type t = ScheduledInstancesPrivateIpAddressConfig.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ScheduledInstancesPrivateIpAddressConfig.parse
           (Xml.members "PrivateIpAddressConfigSet" xml))
    let to_query v =
      Query.to_query_list ScheduledInstancesPrivateIpAddressConfig.to_query v
    let to_headers v =
      Headers.to_headers_list
        ScheduledInstancesPrivateIpAddressConfig.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ScheduledInstancesPrivateIpAddressConfig.to_xml x))) v
    let to_json v =
      `List (List.map ScheduledInstancesPrivateIpAddressConfig.to_json v)
    let of_json j =
      Json.to_list ScheduledInstancesPrivateIpAddressConfig.of_json j
  end
module ScheduledInstancesIpv6AddressList =
  struct
    type t = ScheduledInstancesIpv6Address.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ScheduledInstancesIpv6Address.parse
           (Xml.members "Ipv6Address" xml))
    let to_query v =
      Query.to_query_list ScheduledInstancesIpv6Address.to_query v
    let to_headers v =
      Headers.to_headers_list ScheduledInstancesIpv6Address.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ScheduledInstancesIpv6Address.to_xml x))) v
    let to_json v = `List (List.map ScheduledInstancesIpv6Address.to_json v)
    let of_json j = Json.to_list ScheduledInstancesIpv6Address.of_json j
  end
module ScheduledInstancesSecurityGroupIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "SecurityGroupId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module NatGatewayAddress =
  struct
    type t =
      {
      allocation_id: String.t option ;
      network_interface_id: String.t option ;
      private_ip: String.t option ;
      public_ip: String.t option }
    let make ?allocation_id  ?network_interface_id  ?private_ip  ?public_ip 
      () = { allocation_id; network_interface_id; private_ip; public_ip }
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          private_ip =
            (Util.option_bind (Xml.member "privateIp" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.private_ip
             (fun f -> Query.Pair ("PrivateIp", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.allocation_id
                 (fun f ->
                    Ezxmlm.make_tag "allocationId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.network_interface_id
                (fun f ->
                   Ezxmlm.make_tag "networkInterfaceId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.private_ip
               (fun f -> Ezxmlm.make_tag "privateIp" ([], (String.to_xml f)))])
           @
           [Util.option_map v.public_ip
              (fun f -> Ezxmlm.make_tag "publicIp" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.private_ip
             (fun f -> ("private_ip", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let of_json j =
      {
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        private_ip =
          (Util.option_map (Json.lookup j "private_ip") String.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json)
      }
  end
module DhcpConfigurationList =
  struct
    type t = DhcpConfiguration.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DhcpConfiguration.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DhcpConfiguration.to_query v
    let to_headers v = Headers.to_headers_list DhcpConfiguration.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (DhcpConfiguration.to_xml x)))
        v
    let to_json v = `List (List.map DhcpConfiguration.to_json v)
    let of_json j = Json.to_list DhcpConfiguration.of_json j
  end
module GatewayType =
  struct
    type t =
      | Ipsec_1 
    let str_to_t = [("ipsec.1", Ipsec_1)]
    let t_to_str = [(Ipsec_1, "ipsec.1")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpcAttachmentList =
  struct
    type t = VpcAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map VpcAttachment.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpcAttachment.to_query v
    let to_headers v = Headers.to_headers_list VpcAttachment.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VpcAttachment.to_xml x))) v
    let to_json v = `List (List.map VpcAttachment.to_json v)
    let of_json j = Json.to_list VpcAttachment.of_json j
  end
module TransitGatewayPropagationState =
  struct
    type t =
      | Enabling 
      | Enabled 
      | Disabling 
      | Disabled 
    let str_to_t =
      [("disabled", Disabled);
      ("disabling", Disabling);
      ("enabled", Enabled);
      ("enabling", Enabling)]
    let t_to_str =
      [(Disabled, "disabled");
      (Disabling, "disabling");
      (Enabled, "enabled");
      (Enabling, "enabling")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CapacityReservationInstancePlatform =
  struct
    type t =
      | Linux_UNIX 
      | Red_Hat_Enterprise_Linux 
      | SUSE_Linux 
      | Windows 
      | Windows_with_SQL_Server 
      | Windows_with_SQL_Server_Enterprise 
      | Windows_with_SQL_Server_Standard 
      | Windows_with_SQL_Server_Web 
      | Linux_with_SQL_Server_Standard 
      | Linux_with_SQL_Server_Web 
      | Linux_with_SQL_Server_Enterprise 
    let str_to_t =
      [("Linux with SQL Server Enterprise", Linux_with_SQL_Server_Enterprise);
      ("Linux with SQL Server Web", Linux_with_SQL_Server_Web);
      ("Linux with SQL Server Standard", Linux_with_SQL_Server_Standard);
      ("Windows with SQL Server Web", Windows_with_SQL_Server_Web);
      ("Windows with SQL Server Standard", Windows_with_SQL_Server_Standard);
      ("Windows with SQL Server Enterprise",
        Windows_with_SQL_Server_Enterprise);
      ("Windows with SQL Server", Windows_with_SQL_Server);
      ("Windows", Windows);
      ("SUSE Linux", SUSE_Linux);
      ("Red Hat Enterprise Linux", Red_Hat_Enterprise_Linux);
      ("Linux/UNIX", Linux_UNIX)]
    let t_to_str =
      [(Linux_with_SQL_Server_Enterprise, "Linux with SQL Server Enterprise");
      (Linux_with_SQL_Server_Web, "Linux with SQL Server Web");
      (Linux_with_SQL_Server_Standard, "Linux with SQL Server Standard");
      (Windows_with_SQL_Server_Web, "Windows with SQL Server Web");
      (Windows_with_SQL_Server_Standard, "Windows with SQL Server Standard");
      (Windows_with_SQL_Server_Enterprise,
        "Windows with SQL Server Enterprise");
      (Windows_with_SQL_Server, "Windows with SQL Server");
      (Windows, "Windows");
      (SUSE_Linux, "SUSE Linux");
      (Red_Hat_Enterprise_Linux, "Red Hat Enterprise Linux");
      (Linux_UNIX, "Linux/UNIX")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CapacityReservationState =
  struct
    type t =
      | Active 
      | Expired 
      | Cancelled 
      | Pending 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("pending", Pending);
      ("cancelled", Cancelled);
      ("expired", Expired);
      ("active", Active)]
    let t_to_str =
      [(Failed, "failed");
      (Pending, "pending");
      (Cancelled, "cancelled");
      (Expired, "expired");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CapacityReservationTenancy =
  struct
    type t =
      | Default 
      | Dedicated 
    let str_to_t = [("dedicated", Dedicated); ("default", Default)]
    let t_to_str = [(Dedicated, "dedicated"); (Default, "default")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EndDateType =
  struct
    type t =
      | Unlimited 
      | Limited 
    let str_to_t = [("limited", Limited); ("unlimited", Unlimited)]
    let t_to_str = [(Limited, "limited"); (Unlimited, "unlimited")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceMatchCriteria =
  struct
    type t =
      | Open 
      | Targeted 
    let str_to_t = [("targeted", Targeted); ("open", Open)]
    let t_to_str = [(Targeted, "targeted"); (Open, "open")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ReservedInstancesModificationResultList =
  struct
    type t = ReservedInstancesModificationResult.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesModificationResult.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ReservedInstancesModificationResult.to_query v
    let to_headers v =
      Headers.to_headers_list ReservedInstancesModificationResult.to_headers
        v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ReservedInstancesModificationResult.to_xml x))) v
    let to_json v =
      `List (List.map ReservedInstancesModificationResult.to_json v)
    let of_json j =
      Json.to_list ReservedInstancesModificationResult.of_json j
  end
module ReservedIntancesIds =
  struct
    type t = ReservedInstancesId.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesId.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ReservedInstancesId.to_query v
    let to_headers v =
      Headers.to_headers_list ReservedInstancesId.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ReservedInstancesId.to_xml x))) v
    let to_json v = `List (List.map ReservedInstancesId.to_json v)
    let of_json j = Json.to_list ReservedInstancesId.of_json j
  end
module PlacementGroupState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PlacementStrategy =
  struct
    type t =
      | Cluster 
      | Spread 
      | Partition 
    let str_to_t =
      [("partition", Partition); ("spread", Spread); ("cluster", Cluster)]
    let t_to_str =
      [(Partition, "partition"); (Spread, "spread"); (Cluster, "cluster")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EventInformation =
  struct
    type t =
      {
      event_description: String.t option ;
      event_sub_type: String.t option ;
      instance_id: String.t option }
    let make ?event_description  ?event_sub_type  ?instance_id  () =
      { event_description; event_sub_type; instance_id }
    let parse xml =
      Some
        {
          event_description =
            (Util.option_bind (Xml.member "eventDescription" xml)
               String.parse);
          event_sub_type =
            (Util.option_bind (Xml.member "eventSubType" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.event_sub_type
             (fun f -> Query.Pair ("EventSubType", (String.to_query f)));
           Util.option_map v.event_description
             (fun f -> Query.Pair ("EventDescription", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.event_description
                (fun f ->
                   Ezxmlm.make_tag "eventDescription" ([], (String.to_xml f)))])
            @
            [Util.option_map v.event_sub_type
               (fun f ->
                  Ezxmlm.make_tag "eventSubType" ([], (String.to_xml f)))])
           @
           [Util.option_map v.instance_id
              (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.event_sub_type
             (fun f -> ("event_sub_type", (String.to_json f)));
           Util.option_map v.event_description
             (fun f -> ("event_description", (String.to_json f)))])
    let of_json j =
      {
        event_description =
          (Util.option_map (Json.lookup j "event_description") String.of_json);
        event_sub_type =
          (Util.option_map (Json.lookup j "event_sub_type") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json)
      }
  end
module FleetEventType =
  struct
    type t =
      | Instance_change 
      | Fleet_change 
      | Service_error 
    let str_to_t =
      [("service-error", Service_error);
      ("fleet-change", Fleet_change);
      ("instance-change", Instance_change)]
    let t_to_str =
      [(Service_error, "service-error");
      (Fleet_change, "fleet-change");
      (Instance_change, "instance-change")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PaymentOption =
  struct
    type t =
      | AllUpfront 
      | PartialUpfront 
      | NoUpfront 
    let str_to_t =
      [("NoUpfront", NoUpfront);
      ("PartialUpfront", PartialUpfront);
      ("AllUpfront", AllUpfront)]
    let t_to_str =
      [(NoUpfront, "NoUpfront");
      (PartialUpfront, "PartialUpfront");
      (AllUpfront, "AllUpfront")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ReservationState =
  struct
    type t =
      | Payment_pending 
      | Payment_failed 
      | Active 
      | Retired 
    let str_to_t =
      [("retired", Retired);
      ("active", Active);
      ("payment-failed", Payment_failed);
      ("payment-pending", Payment_pending)]
    let t_to_str =
      [(Retired, "retired");
      (Active, "active");
      (Payment_failed, "payment-failed");
      (Payment_pending, "payment-pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ResponseHostIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module LaunchPermission =
  struct
    type t = {
      group: PermissionGroup.t option ;
      user_id: String.t option }
    let make ?group  ?user_id  () = { group; user_id }
    let parse xml =
      Some
        {
          group =
            (Util.option_bind (Xml.member "group" xml) PermissionGroup.parse);
          user_id = (Util.option_bind (Xml.member "userId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> Query.Pair ("UserId", (String.to_query f)));
           Util.option_map v.group
             (fun f -> Query.Pair ("Group", (PermissionGroup.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.group
               (fun f ->
                  Ezxmlm.make_tag "group" ([], (PermissionGroup.to_xml f)))])
           @
           [Util.option_map v.user_id
              (fun f -> Ezxmlm.make_tag "userId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> ("user_id", (String.to_json f)));
           Util.option_map v.group
             (fun f -> ("group", (PermissionGroup.to_json f)))])
    let of_json j =
      {
        group =
          (Util.option_map (Json.lookup j "group") PermissionGroup.of_json);
        user_id = (Util.option_map (Json.lookup j "user_id") String.of_json)
      }
  end
module DnsEntrySet =
  struct
    type t = DnsEntry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map DnsEntry.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DnsEntry.to_query v
    let to_headers v = Headers.to_headers_list DnsEntry.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (DnsEntry.to_xml x)))
        v
    let to_json v = `List (List.map DnsEntry.to_json v)
    let of_json j = Json.to_list DnsEntry.of_json j
  end
module State =
  struct
    type t =
      | PendingAcceptance 
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
      | Rejected 
      | Failed 
      | Expired 
    let str_to_t =
      [("Expired", Expired);
      ("Failed", Failed);
      ("Rejected", Rejected);
      ("Deleted", Deleted);
      ("Deleting", Deleting);
      ("Available", Available);
      ("Pending", Pending);
      ("PendingAcceptance", PendingAcceptance)]
    let t_to_str =
      [(Expired, "Expired");
      (Failed, "Failed");
      (Rejected, "Rejected");
      (Deleted, "Deleted");
      (Deleting, "Deleting");
      (Available, "Available");
      (Pending, "Pending");
      (PendingAcceptance, "PendingAcceptance")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ExportTaskS3Location =
  struct
    type t = {
      s3_bucket: String.t option ;
      s3_prefix: String.t option }
    let make ?s3_bucket  ?s3_prefix  () = { s3_bucket; s3_prefix }
    let parse xml =
      Some
        {
          s3_bucket =
            (Util.option_bind (Xml.member "s3Bucket" xml) String.parse);
          s3_prefix =
            (Util.option_bind (Xml.member "s3Prefix" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> Query.Pair ("S3Prefix", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.s3_bucket
               (fun f -> Ezxmlm.make_tag "s3Bucket" ([], (String.to_xml f)))])
           @
           [Util.option_map v.s3_prefix
              (fun f -> Ezxmlm.make_tag "s3Prefix" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> ("s3_prefix", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)))])
    let of_json j =
      {
        s3_bucket =
          (Util.option_map (Json.lookup j "s3_bucket") String.of_json);
        s3_prefix =
          (Util.option_map (Json.lookup j "s3_prefix") String.of_json)
      }
  end
module UnsuccessfulItemError =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module TrafficMirrorFilterRuleList =
  struct
    type t = TrafficMirrorFilterRule.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorFilterRule.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TrafficMirrorFilterRule.to_query v
    let to_headers v =
      Headers.to_headers_list TrafficMirrorFilterRule.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (TrafficMirrorFilterRule.to_xml x)))
        v
    let to_json v = `List (List.map TrafficMirrorFilterRule.to_json v)
    let of_json j = Json.to_list TrafficMirrorFilterRule.of_json j
  end
module TrafficMirrorNetworkServiceList =
  struct
    type t = TrafficMirrorNetworkService.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorNetworkService.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TrafficMirrorNetworkService.to_query v
    let to_headers v =
      Headers.to_headers_list TrafficMirrorNetworkService.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TrafficMirrorNetworkService.to_xml x))) v
    let to_json v = `List (List.map TrafficMirrorNetworkService.to_json v)
    let of_json j = Json.to_list TrafficMirrorNetworkService.of_json j
  end
module TransitGatewayOptions =
  struct
    type t =
      {
      amazon_side_asn: Long.t option ;
      auto_accept_shared_attachments:
        AutoAcceptSharedAttachmentsValue.t option ;
      default_route_table_association:
        DefaultRouteTableAssociationValue.t option ;
      association_default_route_table_id: String.t option ;
      default_route_table_propagation:
        DefaultRouteTablePropagationValue.t option ;
      propagation_default_route_table_id: String.t option ;
      vpn_ecmp_support: VpnEcmpSupportValue.t option ;
      dns_support: DnsSupportValue.t option ;
      multicast_support: MulticastSupportValue.t option }
    let make ?amazon_side_asn  ?auto_accept_shared_attachments 
      ?default_route_table_association  ?association_default_route_table_id 
      ?default_route_table_propagation  ?propagation_default_route_table_id 
      ?vpn_ecmp_support  ?dns_support  ?multicast_support  () =
      {
        amazon_side_asn;
        auto_accept_shared_attachments;
        default_route_table_association;
        association_default_route_table_id;
        default_route_table_propagation;
        propagation_default_route_table_id;
        vpn_ecmp_support;
        dns_support;
        multicast_support
      }
    let parse xml =
      Some
        {
          amazon_side_asn =
            (Util.option_bind (Xml.member "amazonSideAsn" xml) Long.parse);
          auto_accept_shared_attachments =
            (Util.option_bind (Xml.member "autoAcceptSharedAttachments" xml)
               AutoAcceptSharedAttachmentsValue.parse);
          default_route_table_association =
            (Util.option_bind (Xml.member "defaultRouteTableAssociation" xml)
               DefaultRouteTableAssociationValue.parse);
          association_default_route_table_id =
            (Util.option_bind
               (Xml.member "associationDefaultRouteTableId" xml) String.parse);
          default_route_table_propagation =
            (Util.option_bind (Xml.member "defaultRouteTablePropagation" xml)
               DefaultRouteTablePropagationValue.parse);
          propagation_default_route_table_id =
            (Util.option_bind
               (Xml.member "propagationDefaultRouteTableId" xml) String.parse);
          vpn_ecmp_support =
            (Util.option_bind (Xml.member "vpnEcmpSupport" xml)
               VpnEcmpSupportValue.parse);
          dns_support =
            (Util.option_bind (Xml.member "dnsSupport" xml)
               DnsSupportValue.parse);
          multicast_support =
            (Util.option_bind (Xml.member "multicastSupport" xml)
               MulticastSupportValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.multicast_support
              (fun f ->
                 Query.Pair
                   ("MulticastSupport", (MulticastSupportValue.to_query f)));
           Util.option_map v.dns_support
             (fun f ->
                Query.Pair ("DnsSupport", (DnsSupportValue.to_query f)));
           Util.option_map v.vpn_ecmp_support
             (fun f ->
                Query.Pair
                  ("VpnEcmpSupport", (VpnEcmpSupportValue.to_query f)));
           Util.option_map v.propagation_default_route_table_id
             (fun f ->
                Query.Pair
                  ("PropagationDefaultRouteTableId", (String.to_query f)));
           Util.option_map v.default_route_table_propagation
             (fun f ->
                Query.Pair
                  ("DefaultRouteTablePropagation",
                    (DefaultRouteTablePropagationValue.to_query f)));
           Util.option_map v.association_default_route_table_id
             (fun f ->
                Query.Pair
                  ("AssociationDefaultRouteTableId", (String.to_query f)));
           Util.option_map v.default_route_table_association
             (fun f ->
                Query.Pair
                  ("DefaultRouteTableAssociation",
                    (DefaultRouteTableAssociationValue.to_query f)));
           Util.option_map v.auto_accept_shared_attachments
             (fun f ->
                Query.Pair
                  ("AutoAcceptSharedAttachments",
                    (AutoAcceptSharedAttachmentsValue.to_query f)));
           Util.option_map v.amazon_side_asn
             (fun f -> Query.Pair ("AmazonSideAsn", (Long.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.amazon_side_asn
                      (fun f ->
                         Ezxmlm.make_tag "amazonSideAsn"
                           ([], (Long.to_xml f)))])
                  @
                  [Util.option_map v.auto_accept_shared_attachments
                     (fun f ->
                        Ezxmlm.make_tag "autoAcceptSharedAttachments"
                          ([], (AutoAcceptSharedAttachmentsValue.to_xml f)))])
                 @
                 [Util.option_map v.default_route_table_association
                    (fun f ->
                       Ezxmlm.make_tag "defaultRouteTableAssociation"
                         ([], (DefaultRouteTableAssociationValue.to_xml f)))])
                @
                [Util.option_map v.association_default_route_table_id
                   (fun f ->
                      Ezxmlm.make_tag "associationDefaultRouteTableId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.default_route_table_propagation
                  (fun f ->
                     Ezxmlm.make_tag "defaultRouteTablePropagation"
                       ([], (DefaultRouteTablePropagationValue.to_xml f)))])
              @
              [Util.option_map v.propagation_default_route_table_id
                 (fun f ->
                    Ezxmlm.make_tag "propagationDefaultRouteTableId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.vpn_ecmp_support
                (fun f ->
                   Ezxmlm.make_tag "vpnEcmpSupport"
                     ([], (VpnEcmpSupportValue.to_xml f)))])
            @
            [Util.option_map v.dns_support
               (fun f ->
                  Ezxmlm.make_tag "dnsSupport"
                    ([], (DnsSupportValue.to_xml f)))])
           @
           [Util.option_map v.multicast_support
              (fun f ->
                 Ezxmlm.make_tag "multicastSupport"
                   ([], (MulticastSupportValue.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.multicast_support
              (fun f ->
                 ("multicast_support", (MulticastSupportValue.to_json f)));
           Util.option_map v.dns_support
             (fun f -> ("dns_support", (DnsSupportValue.to_json f)));
           Util.option_map v.vpn_ecmp_support
             (fun f -> ("vpn_ecmp_support", (VpnEcmpSupportValue.to_json f)));
           Util.option_map v.propagation_default_route_table_id
             (fun f ->
                ("propagation_default_route_table_id", (String.to_json f)));
           Util.option_map v.default_route_table_propagation
             (fun f ->
                ("default_route_table_propagation",
                  (DefaultRouteTablePropagationValue.to_json f)));
           Util.option_map v.association_default_route_table_id
             (fun f ->
                ("association_default_route_table_id", (String.to_json f)));
           Util.option_map v.default_route_table_association
             (fun f ->
                ("default_route_table_association",
                  (DefaultRouteTableAssociationValue.to_json f)));
           Util.option_map v.auto_accept_shared_attachments
             (fun f ->
                ("auto_accept_shared_attachments",
                  (AutoAcceptSharedAttachmentsValue.to_json f)));
           Util.option_map v.amazon_side_asn
             (fun f -> ("amazon_side_asn", (Long.to_json f)))])
    let of_json j =
      {
        amazon_side_asn =
          (Util.option_map (Json.lookup j "amazon_side_asn") Long.of_json);
        auto_accept_shared_attachments =
          (Util.option_map (Json.lookup j "auto_accept_shared_attachments")
             AutoAcceptSharedAttachmentsValue.of_json);
        default_route_table_association =
          (Util.option_map (Json.lookup j "default_route_table_association")
             DefaultRouteTableAssociationValue.of_json);
        association_default_route_table_id =
          (Util.option_map
             (Json.lookup j "association_default_route_table_id")
             String.of_json);
        default_route_table_propagation =
          (Util.option_map (Json.lookup j "default_route_table_propagation")
             DefaultRouteTablePropagationValue.of_json);
        propagation_default_route_table_id =
          (Util.option_map
             (Json.lookup j "propagation_default_route_table_id")
             String.of_json);
        vpn_ecmp_support =
          (Util.option_map (Json.lookup j "vpn_ecmp_support")
             VpnEcmpSupportValue.of_json);
        dns_support =
          (Util.option_map (Json.lookup j "dns_support")
             DnsSupportValue.of_json);
        multicast_support =
          (Util.option_map (Json.lookup j "multicast_support")
             MulticastSupportValue.of_json)
      }
  end
module TransitGatewayState =
  struct
    type t =
      | Pending 
      | Available 
      | Modifying 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("modifying", Modifying);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Modifying, "modifying");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CertificateAuthenticationRequest =
  struct
    type t = {
      client_root_certificate_chain_arn: String.t option }
    let make ?client_root_certificate_chain_arn  () =
      { client_root_certificate_chain_arn }
    let parse xml =
      Some
        {
          client_root_certificate_chain_arn =
            (Util.option_bind
               (Xml.member "ClientRootCertificateChainArn" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_root_certificate_chain_arn
              (fun f ->
                 Query.Pair
                   ("ClientRootCertificateChainArn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.client_root_certificate_chain_arn
              (fun f ->
                 Ezxmlm.make_tag "ClientRootCertificateChainArn"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_root_certificate_chain_arn
              (fun f ->
                 ("client_root_certificate_chain_arn", (String.to_json f)))])
    let of_json j =
      {
        client_root_certificate_chain_arn =
          (Util.option_map
             (Json.lookup j "client_root_certificate_chain_arn")
             String.of_json)
      }
  end
module DirectoryServiceAuthenticationRequest =
  struct
    type t = {
      directory_id: String.t option }
    let make ?directory_id  () = { directory_id }
    let parse xml =
      Some
        {
          directory_id =
            (Util.option_bind (Xml.member "DirectoryId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.directory_id
              (fun f -> Query.Pair ("DirectoryId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.directory_id
              (fun f -> Ezxmlm.make_tag "DirectoryId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.directory_id
              (fun f -> ("directory_id", (String.to_json f)))])
    let of_json j =
      {
        directory_id =
          (Util.option_map (Json.lookup j "directory_id") String.of_json)
      }
  end
module InstanceCountList =
  struct
    type t = InstanceCount.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map InstanceCount.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceCount.to_query v
    let to_headers v = Headers.to_headers_list InstanceCount.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InstanceCount.to_xml x))) v
    let to_json v = `List (List.map InstanceCount.to_json v)
    let of_json j = Json.to_list InstanceCount.of_json j
  end
module ListingStatus =
  struct
    type t =
      | Active 
      | Pending 
      | Cancelled 
      | Closed 
    let str_to_t =
      [("closed", Closed);
      ("cancelled", Cancelled);
      ("pending", Pending);
      ("active", Active)]
    let t_to_str =
      [(Closed, "closed");
      (Cancelled, "cancelled");
      (Pending, "pending");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PriceScheduleList =
  struct
    type t = PriceSchedule.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map PriceSchedule.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PriceSchedule.to_query v
    let to_headers v = Headers.to_headers_list PriceSchedule.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PriceSchedule.to_xml x))) v
    let to_json v = `List (List.map PriceSchedule.to_json v)
    let of_json j = Json.to_list PriceSchedule.of_json j
  end
module ClientVpnConnectionStatus =
  struct
    type t =
      {
      code: ClientVpnConnectionStatusCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               ClientVpnConnectionStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code", (ClientVpnConnectionStatusCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (ClientVpnConnectionStatusCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (ClientVpnConnectionStatusCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             ClientVpnConnectionStatusCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module LocationType =
  struct
    type t =
      | Region 
      | Availability_zone 
      | Availability_zone_id 
    let str_to_t =
      [("availability-zone-id", Availability_zone_id);
      ("availability-zone", Availability_zone);
      ("region", Region)]
    let t_to_str =
      [(Availability_zone_id, "availability-zone-id");
      (Availability_zone, "availability-zone");
      (Region, "region")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceStatusEventList =
  struct
    type t = InstanceStatusEvent.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceStatusEvent.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceStatusEvent.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceStatusEvent.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstanceStatusEvent.to_xml x))) v
    let to_json v = `List (List.map InstanceStatusEvent.to_json v)
    let of_json j = Json.to_list InstanceStatusEvent.of_json j
  end
module InstanceStatusSummary =
  struct
    type t = {
      details: InstanceStatusDetailsList.t ;
      status: SummaryStatus.t }
    let make ?(details= [])  ~status  () = { details; status }
    let parse xml =
      Some
        {
          details =
            (Util.of_option []
               (Util.option_bind (Xml.member "details" xml)
                  InstanceStatusDetailsList.parse));
          status =
            (Xml.required "status"
               (Util.option_bind (Xml.member "status" xml)
                  SummaryStatus.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Status", (SummaryStatus.to_query v.status)));
           Some
             (Query.Pair
                ("Details", (InstanceStatusDetailsList.to_query v.details)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "details"
                       ([], (InstanceStatusDetailsList.to_xml [x]))))
               v.details))
           @
           [Some
              (Ezxmlm.make_tag "status" ([], (SummaryStatus.to_xml v.status)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("status", (SummaryStatus.to_json v.status));
           Some ("details", (InstanceStatusDetailsList.to_json v.details))])
    let of_json j =
      {
        details =
          (InstanceStatusDetailsList.of_json
             (Util.of_option_exn (Json.lookup j "details")));
        status =
          (SummaryStatus.of_json
             (Util.of_option_exn (Json.lookup j "status")))
      }
  end
module ImageState =
  struct
    type t =
      | Pending 
      | Available 
      | Invalid 
      | Deregistered 
      | Transient 
      | Failed 
      | Error 
    let str_to_t =
      [("error", Error);
      ("failed", Failed);
      ("transient", Transient);
      ("deregistered", Deregistered);
      ("invalid", Invalid);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Error, "error");
      (Failed, "failed");
      (Transient, "transient");
      (Deregistered, "deregistered");
      (Invalid, "invalid");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ImageTypeValues =
  struct
    type t =
      | Machine 
      | Kernel 
      | Ramdisk 
    let str_to_t =
      [("ramdisk", Ramdisk); ("kernel", Kernel); ("machine", Machine)]
    let t_to_str =
      [(Ramdisk, "ramdisk"); (Kernel, "kernel"); (Machine, "machine")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SnapshotTaskDetail =
  struct
    type t =
      {
      description: String.t option ;
      disk_image_size: Double.t option ;
      encrypted: Boolean.t option ;
      format: String.t option ;
      kms_key_id: String.t option ;
      progress: String.t option ;
      snapshot_id: String.t option ;
      status: String.t option ;
      status_message: String.t option ;
      url: String.t option ;
      user_bucket: UserBucketDetails.t option }
    let make ?description  ?disk_image_size  ?encrypted  ?format  ?kms_key_id
       ?progress  ?snapshot_id  ?status  ?status_message  ?url  ?user_bucket 
      () =
      {
        description;
        disk_image_size;
        encrypted;
        format;
        kms_key_id;
        progress;
        snapshot_id;
        status;
        status_message;
        url;
        user_bucket
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          disk_image_size =
            (Util.option_bind (Xml.member "diskImageSize" xml) Double.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          format = (Util.option_bind (Xml.member "format" xml) String.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          url = (Util.option_bind (Xml.member "url" xml) String.parse);
          user_bucket =
            (Util.option_bind (Xml.member "userBucket" xml)
               UserBucketDetails.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f ->
                 Query.Pair ("UserBucket", (UserBucketDetails.to_query f)));
           Util.option_map v.url
             (fun f -> Query.Pair ("Url", (String.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.disk_image_size
             (fun f -> Query.Pair ("DiskImageSize", (Double.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.description
                        (fun f ->
                           Ezxmlm.make_tag "description"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.disk_image_size
                       (fun f ->
                          Ezxmlm.make_tag "diskImageSize"
                            ([], (Double.to_xml f)))])
                   @
                   [Util.option_map v.encrypted
                      (fun f ->
                         Ezxmlm.make_tag "encrypted" ([], (Boolean.to_xml f)))])
                  @
                  [Util.option_map v.format
                     (fun f ->
                        Ezxmlm.make_tag "format" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.kms_key_id
                    (fun f ->
                       Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.progress
                   (fun f ->
                      Ezxmlm.make_tag "progress" ([], (String.to_xml f)))])
               @
               [Util.option_map v.snapshot_id
                  (fun f ->
                     Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.status
                 (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
             @
             [Util.option_map v.status_message
                (fun f ->
                   Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
            @
            [Util.option_map v.url
               (fun f -> Ezxmlm.make_tag "url" ([], (String.to_xml f)))])
           @
           [Util.option_map v.user_bucket
              (fun f ->
                 Ezxmlm.make_tag "userBucket"
                   ([], (UserBucketDetails.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> ("user_bucket", (UserBucketDetails.to_json f)));
           Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.format (fun f -> ("format", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.disk_image_size
             (fun f -> ("disk_image_size", (Double.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        disk_image_size =
          (Util.option_map (Json.lookup j "disk_image_size") Double.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        format = (Util.option_map (Json.lookup j "format") String.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        url = (Util.option_map (Json.lookup j "url") String.of_json);
        user_bucket =
          (Util.option_map (Json.lookup j "user_bucket")
             UserBucketDetails.of_json)
      }
  end
module InterfacePermissionType =
  struct
    type t =
      | INSTANCE_ATTACH 
      | EIP_ASSOCIATE 
    let str_to_t =
      [("EIP-ASSOCIATE", EIP_ASSOCIATE);
      ("INSTANCE-ATTACH", INSTANCE_ATTACH)]
    let t_to_str =
      [(EIP_ASSOCIATE, "EIP-ASSOCIATE");
      (INSTANCE_ATTACH, "INSTANCE-ATTACH")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NetworkInterfacePermissionState =
  struct
    type t =
      {
      state: NetworkInterfacePermissionStateCode.t option ;
      status_message: String.t option }
    let make ?state  ?status_message  () = { state; status_message }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml)
               NetworkInterfacePermissionStateCode.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (NetworkInterfacePermissionStateCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.state
               (fun f ->
                  Ezxmlm.make_tag "state"
                    ([], (NetworkInterfacePermissionStateCode.to_xml f)))])
           @
           [Util.option_map v.status_message
              (fun f ->
                 Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.state
             (fun f ->
                ("state", (NetworkInterfacePermissionStateCode.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state")
             NetworkInterfacePermissionStateCode.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json)
      }
  end
module AllocationState =
  struct
    type t =
      | Available 
      | Under_assessment 
      | Permanent_failure 
      | Released 
      | Released_permanent_failure 
      | Pending 
    let str_to_t =
      [("pending", Pending);
      ("released-permanent-failure", Released_permanent_failure);
      ("released", Released);
      ("permanent-failure", Permanent_failure);
      ("under-assessment", Under_assessment);
      ("available", Available)]
    let t_to_str =
      [(Pending, "pending");
      (Released_permanent_failure, "released-permanent-failure");
      (Released, "released");
      (Permanent_failure, "permanent-failure");
      (Under_assessment, "under-assessment");
      (Available, "available")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AllowsMultipleInstanceTypes =
  struct
    type t =
      | On 
      | Off 
    let str_to_t = [("off", Off); ("on", On)]
    let t_to_str = [(Off, "off"); (On, "on")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AutoPlacement =
  struct
    type t =
      | On 
      | Off 
    let str_to_t = [("off", Off); ("on", On)]
    let t_to_str = [(Off, "off"); (On, "on")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AvailableCapacity =
  struct
    type t =
      {
      available_instance_capacity: AvailableInstanceCapacityList.t ;
      available_v_cpus: Integer.t option }
    let make ?(available_instance_capacity= [])  ?available_v_cpus  () =
      { available_instance_capacity; available_v_cpus }
    let parse xml =
      Some
        {
          available_instance_capacity =
            (Util.of_option []
               (Util.option_bind (Xml.member "availableInstanceCapacity" xml)
                  AvailableInstanceCapacityList.parse));
          available_v_cpus =
            (Util.option_bind (Xml.member "availableVCpus" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.available_v_cpus
              (fun f -> Query.Pair ("AvailableVCpus", (Integer.to_query f)));
           Some
             (Query.Pair
                ("AvailableInstanceCapacity",
                  (AvailableInstanceCapacityList.to_query
                     v.available_instance_capacity)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "availableInstanceCapacity"
                       ([], (AvailableInstanceCapacityList.to_xml [x]))))
               v.available_instance_capacity))
           @
           [Util.option_map v.available_v_cpus
              (fun f ->
                 Ezxmlm.make_tag "availableVCpus" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.available_v_cpus
              (fun f -> ("available_v_cpus", (Integer.to_json f)));
           Some
             ("available_instance_capacity",
               (AvailableInstanceCapacityList.to_json
                  v.available_instance_capacity))])
    let of_json j =
      {
        available_instance_capacity =
          (AvailableInstanceCapacityList.of_json
             (Util.of_option_exn
                (Json.lookup j "available_instance_capacity")));
        available_v_cpus =
          (Util.option_map (Json.lookup j "available_v_cpus") Integer.of_json)
      }
  end
module HostInstanceList =
  struct
    type t = HostInstance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map HostInstance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list HostInstance.to_query v
    let to_headers v = Headers.to_headers_list HostInstance.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (HostInstance.to_xml x))) v
    let to_json v = `List (List.map HostInstance.to_json v)
    let of_json j = Json.to_list HostInstance.of_json j
  end
module HostProperties =
  struct
    type t =
      {
      cores: Integer.t option ;
      instance_type: String.t option ;
      instance_family: String.t option ;
      sockets: Integer.t option ;
      total_v_cpus: Integer.t option }
    let make ?cores  ?instance_type  ?instance_family  ?sockets 
      ?total_v_cpus  () =
      { cores; instance_type; instance_family; sockets; total_v_cpus }
    let parse xml =
      Some
        {
          cores = (Util.option_bind (Xml.member "cores" xml) Integer.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          instance_family =
            (Util.option_bind (Xml.member "instanceFamily" xml) String.parse);
          sockets =
            (Util.option_bind (Xml.member "sockets" xml) Integer.parse);
          total_v_cpus =
            (Util.option_bind (Xml.member "totalVCpus" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_v_cpus
              (fun f -> Query.Pair ("TotalVCpus", (Integer.to_query f)));
           Util.option_map v.sockets
             (fun f -> Query.Pair ("Sockets", (Integer.to_query f)));
           Util.option_map v.instance_family
             (fun f -> Query.Pair ("InstanceFamily", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.cores
             (fun f -> Query.Pair ("Cores", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.cores
                  (fun f -> Ezxmlm.make_tag "cores" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.instance_type
                 (fun f ->
                    Ezxmlm.make_tag "instanceType" ([], (String.to_xml f)))])
             @
             [Util.option_map v.instance_family
                (fun f ->
                   Ezxmlm.make_tag "instanceFamily" ([], (String.to_xml f)))])
            @
            [Util.option_map v.sockets
               (fun f -> Ezxmlm.make_tag "sockets" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.total_v_cpus
              (fun f -> Ezxmlm.make_tag "totalVCpus" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_v_cpus
              (fun f -> ("total_v_cpus", (Integer.to_json f)));
           Util.option_map v.sockets
             (fun f -> ("sockets", (Integer.to_json f)));
           Util.option_map v.instance_family
             (fun f -> ("instance_family", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.cores (fun f -> ("cores", (Integer.to_json f)))])
    let of_json j =
      {
        cores = (Util.option_map (Json.lookup j "cores") Integer.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        instance_family =
          (Util.option_map (Json.lookup j "instance_family") String.of_json);
        sockets = (Util.option_map (Json.lookup j "sockets") Integer.of_json);
        total_v_cpus =
          (Util.option_map (Json.lookup j "total_v_cpus") Integer.of_json)
      }
  end
module HostRecovery =
  struct
    type t =
      | On 
      | Off 
    let str_to_t = [("off", Off); ("on", On)]
    let t_to_str = [(Off, "off"); (On, "on")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SubnetAssociation =
  struct
    type t =
      {
      subnet_id: String.t option ;
      state: TransitGatewayMulitcastDomainAssociationState.t option }
    let make ?subnet_id  ?state  () = { subnet_id; state }
    let parse xml =
      Some
        {
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayMulitcastDomainAssociationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State",
                     (TransitGatewayMulitcastDomainAssociationState.to_query
                        f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.subnet_id
               (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([],
                     (TransitGatewayMulitcastDomainAssociationState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 ("state",
                   (TransitGatewayMulitcastDomainAssociationState.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)))])
    let of_json j =
      {
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayMulitcastDomainAssociationState.of_json)
      }
  end
module InstanceHealthStatus =
  struct
    type t =
      | Healthy 
      | Unhealthy 
    let str_to_t = [("unhealthy", Unhealthy); ("healthy", Healthy)]
    let t_to_str = [(Unhealthy, "unhealthy"); (Healthy, "healthy")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EbsInstanceBlockDeviceSpecification =
  struct
    type t =
      {
      delete_on_termination: Boolean.t option ;
      volume_id: String.t option }
    let make ?delete_on_termination  ?volume_id  () =
      { delete_on_termination; volume_id }
    let parse xml =
      Some
        {
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.delete_on_termination
               (fun f ->
                  Ezxmlm.make_tag "deleteOnTermination"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.volume_id
              (fun f -> Ezxmlm.make_tag "volumeId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> ("volume_id", (String.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)))])
    let of_json j =
      {
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json)
      }
  end
module LoadPermission =
  struct
    type t = {
      user_id: String.t option ;
      group: PermissionGroup.t option }
    let make ?user_id  ?group  () = { user_id; group }
    let parse xml =
      Some
        {
          user_id = (Util.option_bind (Xml.member "userId" xml) String.parse);
          group =
            (Util.option_bind (Xml.member "group" xml) PermissionGroup.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group
              (fun f -> Query.Pair ("Group", (PermissionGroup.to_query f)));
           Util.option_map v.user_id
             (fun f -> Query.Pair ("UserId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.user_id
               (fun f -> Ezxmlm.make_tag "userId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.group
              (fun f ->
                 Ezxmlm.make_tag "group" ([], (PermissionGroup.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group
              (fun f -> ("group", (PermissionGroup.to_json f)));
           Util.option_map v.user_id
             (fun f -> ("user_id", (String.to_json f)))])
    let of_json j =
      {
        user_id = (Util.option_map (Json.lookup j "user_id") String.of_json);
        group =
          (Util.option_map (Json.lookup j "group") PermissionGroup.of_json)
      }
  end
module TransitGatewayMulticastDomainState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module IdFormatList =
  struct
    type t = IdFormat.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map IdFormat.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list IdFormat.to_query v
    let to_headers v = Headers.to_headers_list IdFormat.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (IdFormat.to_xml x)))
        v
    let to_json v = `List (List.map IdFormat.to_json v)
    let of_json j = Json.to_list IdFormat.of_json j
  end
module PrincipalType =
  struct
    type t =
      | All 
      | Service 
      | OrganizationUnit 
      | Account 
      | User 
      | Role 
    let str_to_t =
      [("Role", Role);
      ("User", User);
      ("Account", Account);
      ("OrganizationUnit", OrganizationUnit);
      ("Service", Service);
      ("All", All)]
    let t_to_str =
      [(Role, "Role");
      (User, "User");
      (Account, "Account");
      (OrganizationUnit, "OrganizationUnit");
      (Service, "Service");
      (All, "All")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ByoipCidrState =
  struct
    type t =
      | Advertised 
      | Deprovisioned 
      | Failed_deprovision 
      | Failed_provision 
      | Pending_deprovision 
      | Pending_provision 
      | Provisioned 
    let str_to_t =
      [("provisioned", Provisioned);
      ("pending-provision", Pending_provision);
      ("pending-deprovision", Pending_deprovision);
      ("failed-provision", Failed_provision);
      ("failed-deprovision", Failed_deprovision);
      ("deprovisioned", Deprovisioned);
      ("advertised", Advertised)]
    let t_to_str =
      [(Provisioned, "provisioned");
      (Pending_provision, "pending-provision");
      (Pending_deprovision, "pending-deprovision");
      (Failed_provision, "failed-provision");
      (Failed_deprovision, "failed-deprovision");
      (Deprovisioned, "deprovisioned");
      (Advertised, "advertised")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DeleteFleetError =
  struct
    type t = {
      code: DeleteFleetErrorCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               DeleteFleetErrorCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (DeleteFleetErrorCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (DeleteFleetErrorCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (DeleteFleetErrorCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             DeleteFleetErrorCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module FleetStateCode =
  struct
    type t =
      | Submitted 
      | Active 
      | Deleted 
      | Failed 
      | Deleted_running 
      | Deleted_terminating 
      | Modifying 
    let str_to_t =
      [("modifying", Modifying);
      ("deleted_terminating", Deleted_terminating);
      ("deleted_running", Deleted_running);
      ("failed", Failed);
      ("deleted", Deleted);
      ("active", Active);
      ("submitted", Submitted)]
    let t_to_str =
      [(Modifying, "modifying");
      (Deleted_terminating, "deleted_terminating");
      (Deleted_running, "deleted_running");
      (Failed, "failed");
      (Deleted, "deleted");
      (Active, "active");
      (Submitted, "submitted")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DisableFastSnapshotRestoreStateErrorSet =
  struct
    type t = DisableFastSnapshotRestoreStateErrorItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DisableFastSnapshotRestoreStateErrorItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list DisableFastSnapshotRestoreStateErrorItem.to_query v
    let to_headers v =
      Headers.to_headers_list
        DisableFastSnapshotRestoreStateErrorItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (DisableFastSnapshotRestoreStateErrorItem.to_xml x))) v
    let to_json v =
      `List (List.map DisableFastSnapshotRestoreStateErrorItem.to_json v)
    let of_json j =
      Json.to_list DisableFastSnapshotRestoreStateErrorItem.of_json j
  end
module FastSnapshotRestoreStateCode =
  struct
    type t =
      | Enabling 
      | Optimizing 
      | Enabled 
      | Disabling 
      | Disabled 
    let str_to_t =
      [("disabled", Disabled);
      ("disabling", Disabling);
      ("enabled", Enabled);
      ("optimizing", Optimizing);
      ("enabling", Enabling)]
    let t_to_str =
      [(Disabled, "disabled");
      (Disabling, "disabling");
      (Enabled, "enabled");
      (Optimizing, "optimizing");
      (Enabling, "enabling")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ScheduledInstanceRecurrence =
  struct
    type t =
      {
      frequency: String.t option ;
      interval: Integer.t option ;
      occurrence_day_set: OccurrenceDaySet.t ;
      occurrence_relative_to_end: Boolean.t option ;
      occurrence_unit: String.t option }
    let make ?frequency  ?interval  ?(occurrence_day_set= []) 
      ?occurrence_relative_to_end  ?occurrence_unit  () =
      {
        frequency;
        interval;
        occurrence_day_set;
        occurrence_relative_to_end;
        occurrence_unit
      }
    let parse xml =
      Some
        {
          frequency =
            (Util.option_bind (Xml.member "frequency" xml) String.parse);
          interval =
            (Util.option_bind (Xml.member "interval" xml) Integer.parse);
          occurrence_day_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "occurrenceDaySet" xml)
                  OccurrenceDaySet.parse));
          occurrence_relative_to_end =
            (Util.option_bind (Xml.member "occurrenceRelativeToEnd" xml)
               Boolean.parse);
          occurrence_unit =
            (Util.option_bind (Xml.member "occurrenceUnit" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.occurrence_unit
              (fun f -> Query.Pair ("OccurrenceUnit", (String.to_query f)));
           Util.option_map v.occurrence_relative_to_end
             (fun f ->
                Query.Pair ("OccurrenceRelativeToEnd", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("OccurrenceDaySet",
                  (OccurrenceDaySet.to_query v.occurrence_day_set)));
           Util.option_map v.interval
             (fun f -> Query.Pair ("Interval", (Integer.to_query f)));
           Util.option_map v.frequency
             (fun f -> Query.Pair ("Frequency", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.frequency
                  (fun f ->
                     Ezxmlm.make_tag "frequency" ([], (String.to_xml f)))])
              @
              [Util.option_map v.interval
                 (fun f ->
                    Ezxmlm.make_tag "interval" ([], (Integer.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "occurrenceDaySet"
                        ([], (OccurrenceDaySet.to_xml [x]))))
                v.occurrence_day_set))
            @
            [Util.option_map v.occurrence_relative_to_end
               (fun f ->
                  Ezxmlm.make_tag "occurrenceRelativeToEnd"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.occurrence_unit
              (fun f ->
                 Ezxmlm.make_tag "occurrenceUnit" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.occurrence_unit
              (fun f -> ("occurrence_unit", (String.to_json f)));
           Util.option_map v.occurrence_relative_to_end
             (fun f -> ("occurrence_relative_to_end", (Boolean.to_json f)));
           Some
             ("occurrence_day_set",
               (OccurrenceDaySet.to_json v.occurrence_day_set));
           Util.option_map v.interval
             (fun f -> ("interval", (Integer.to_json f)));
           Util.option_map v.frequency
             (fun f -> ("frequency", (String.to_json f)))])
    let of_json j =
      {
        frequency =
          (Util.option_map (Json.lookup j "frequency") String.of_json);
        interval =
          (Util.option_map (Json.lookup j "interval") Integer.of_json);
        occurrence_day_set =
          (OccurrenceDaySet.of_json
             (Util.of_option_exn (Json.lookup j "occurrence_day_set")));
        occurrence_relative_to_end =
          (Util.option_map (Json.lookup j "occurrence_relative_to_end")
             Boolean.of_json);
        occurrence_unit =
          (Util.option_map (Json.lookup j "occurrence_unit") String.of_json)
      }
  end
module LogDestinationType =
  struct
    type t =
      | Cloud_watch_logs 
      | S3 
    let str_to_t = [("s3", S3); ("cloud-watch-logs", Cloud_watch_logs)]
    let t_to_str = [(S3, "s3"); (Cloud_watch_logs, "cloud-watch-logs")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TrafficType =
  struct
    type t =
      | ACCEPT 
      | REJECT 
      | ALL 
    let str_to_t = [("ALL", ALL); ("REJECT", REJECT); ("ACCEPT", ACCEPT)]
    let t_to_str = [(ALL, "ALL"); (REJECT, "REJECT"); (ACCEPT, "ACCEPT")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module BundleTaskError =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module BundleTaskState =
  struct
    type t =
      | Pending 
      | Waiting_for_shutdown 
      | Bundling 
      | Storing 
      | Cancelling 
      | Complete 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("complete", Complete);
      ("cancelling", Cancelling);
      ("storing", Storing);
      ("bundling", Bundling);
      ("waiting-for-shutdown", Waiting_for_shutdown);
      ("pending", Pending)]
    let t_to_str =
      [(Failed, "failed");
      (Complete, "complete");
      (Cancelling, "cancelling");
      (Storing, "storing");
      (Bundling, "bundling");
      (Waiting_for_shutdown, "waiting-for-shutdown");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module Storage =
  struct
    type t = {
      s3: S3Storage.t option }
    let make ?s3  () = { s3 }
    let parse xml =
      Some { s3 = (Util.option_bind (Xml.member "S3" xml) S3Storage.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3
              (fun f -> Query.Pair ("S3", (S3Storage.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.s3
              (fun f -> Ezxmlm.make_tag "S3" ([], (S3Storage.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3 (fun f -> ("s3", (S3Storage.to_json f)))])
    let of_json j =
      { s3 = (Util.option_map (Json.lookup j "s3") S3Storage.of_json) }
  end
module StaleIpPermissionSet =
  struct
    type t = StaleIpPermission.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map StaleIpPermission.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list StaleIpPermission.to_query v
    let to_headers v = Headers.to_headers_list StaleIpPermission.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (StaleIpPermission.to_xml x)))
        v
    let to_json v = `List (List.map StaleIpPermission.to_json v)
    let of_json j = Json.to_list StaleIpPermission.of_json j
  end
module CreateVolumePermission =
  struct
    type t = {
      group: PermissionGroup.t option ;
      user_id: String.t option }
    let make ?group  ?user_id  () = { group; user_id }
    let parse xml =
      Some
        {
          group =
            (Util.option_bind (Xml.member "group" xml) PermissionGroup.parse);
          user_id = (Util.option_bind (Xml.member "userId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> Query.Pair ("UserId", (String.to_query f)));
           Util.option_map v.group
             (fun f -> Query.Pair ("Group", (PermissionGroup.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.group
               (fun f ->
                  Ezxmlm.make_tag "group" ([], (PermissionGroup.to_xml f)))])
           @
           [Util.option_map v.user_id
              (fun f -> Ezxmlm.make_tag "userId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> ("user_id", (String.to_json f)));
           Util.option_map v.group
             (fun f -> ("group", (PermissionGroup.to_json f)))])
    let of_json j =
      {
        group =
          (Util.option_map (Json.lookup j "group") PermissionGroup.of_json);
        user_id = (Util.option_map (Json.lookup j "user_id") String.of_json)
      }
  end
module VolumeAttachmentList =
  struct
    type t = VolumeAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeAttachment.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeAttachment.to_query v
    let to_headers v = Headers.to_headers_list VolumeAttachment.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VolumeAttachment.to_xml x)))
        v
    let to_json v = `List (List.map VolumeAttachment.to_json v)
    let of_json j = Json.to_list VolumeAttachment.of_json j
  end
module VolumeState =
  struct
    type t =
      | Creating 
      | Available 
      | In_use 
      | Deleting 
      | Deleted 
      | Error 
    let str_to_t =
      [("error", Error);
      ("deleted", Deleted);
      ("deleting", Deleting);
      ("in-use", In_use);
      ("available", Available);
      ("creating", Creating)]
    let t_to_str =
      [(Error, "error");
      (Deleted, "deleted");
      (Deleting, "deleting");
      (In_use, "in-use");
      (Available, "available");
      (Creating, "creating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpnTunnelOptionsSpecification =
  struct
    type t =
      {
      tunnel_inside_cidr: String.t option ;
      pre_shared_key: String.t option ;
      phase1_lifetime_seconds: Integer.t option ;
      phase2_lifetime_seconds: Integer.t option ;
      rekey_margin_time_seconds: Integer.t option ;
      rekey_fuzz_percentage: Integer.t option ;
      replay_window_size: Integer.t option ;
      d_p_d_timeout_seconds: Integer.t option ;
      phase1_encryption_algorithms: Phase1EncryptionAlgorithmsRequestList.t ;
      phase2_encryption_algorithms: Phase2EncryptionAlgorithmsRequestList.t ;
      phase1_integrity_algorithms: Phase1IntegrityAlgorithmsRequestList.t ;
      phase2_integrity_algorithms: Phase2IntegrityAlgorithmsRequestList.t ;
      phase1_d_h_group_numbers: Phase1DHGroupNumbersRequestList.t ;
      phase2_d_h_group_numbers: Phase2DHGroupNumbersRequestList.t ;
      i_k_e_versions: IKEVersionsRequestList.t }
    let make ?tunnel_inside_cidr  ?pre_shared_key  ?phase1_lifetime_seconds 
      ?phase2_lifetime_seconds  ?rekey_margin_time_seconds 
      ?rekey_fuzz_percentage  ?replay_window_size  ?d_p_d_timeout_seconds 
      ?(phase1_encryption_algorithms= [])  ?(phase2_encryption_algorithms=
      [])  ?(phase1_integrity_algorithms= [])  ?(phase2_integrity_algorithms=
      [])  ?(phase1_d_h_group_numbers= [])  ?(phase2_d_h_group_numbers= []) 
      ?(i_k_e_versions= [])  () =
      {
        tunnel_inside_cidr;
        pre_shared_key;
        phase1_lifetime_seconds;
        phase2_lifetime_seconds;
        rekey_margin_time_seconds;
        rekey_fuzz_percentage;
        replay_window_size;
        d_p_d_timeout_seconds;
        phase1_encryption_algorithms;
        phase2_encryption_algorithms;
        phase1_integrity_algorithms;
        phase2_integrity_algorithms;
        phase1_d_h_group_numbers;
        phase2_d_h_group_numbers;
        i_k_e_versions
      }
    let parse xml =
      Some
        {
          tunnel_inside_cidr =
            (Util.option_bind (Xml.member "TunnelInsideCidr" xml)
               String.parse);
          pre_shared_key =
            (Util.option_bind (Xml.member "PreSharedKey" xml) String.parse);
          phase1_lifetime_seconds =
            (Util.option_bind (Xml.member "Phase1LifetimeSeconds" xml)
               Integer.parse);
          phase2_lifetime_seconds =
            (Util.option_bind (Xml.member "Phase2LifetimeSeconds" xml)
               Integer.parse);
          rekey_margin_time_seconds =
            (Util.option_bind (Xml.member "RekeyMarginTimeSeconds" xml)
               Integer.parse);
          rekey_fuzz_percentage =
            (Util.option_bind (Xml.member "RekeyFuzzPercentage" xml)
               Integer.parse);
          replay_window_size =
            (Util.option_bind (Xml.member "ReplayWindowSize" xml)
               Integer.parse);
          d_p_d_timeout_seconds =
            (Util.option_bind (Xml.member "DPDTimeoutSeconds" xml)
               Integer.parse);
          phase1_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1EncryptionAlgorithm" xml)
                  Phase1EncryptionAlgorithmsRequestList.parse));
          phase2_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2EncryptionAlgorithm" xml)
                  Phase2EncryptionAlgorithmsRequestList.parse));
          phase1_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1IntegrityAlgorithm" xml)
                  Phase1IntegrityAlgorithmsRequestList.parse));
          phase2_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2IntegrityAlgorithm" xml)
                  Phase2IntegrityAlgorithmsRequestList.parse));
          phase1_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1DHGroupNumber" xml)
                  Phase1DHGroupNumbersRequestList.parse));
          phase2_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2DHGroupNumber" xml)
                  Phase2DHGroupNumbersRequestList.parse));
          i_k_e_versions =
            (Util.of_option []
               (Util.option_bind (Xml.member "IKEVersion" xml)
                  IKEVersionsRequestList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("IKEVersion",
                   (IKEVersionsRequestList.to_query v.i_k_e_versions)));
           Some
             (Query.Pair
                ("Phase2DHGroupNumber",
                  (Phase2DHGroupNumbersRequestList.to_query
                     v.phase2_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase1DHGroupNumber",
                  (Phase1DHGroupNumbersRequestList.to_query
                     v.phase1_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase2IntegrityAlgorithm",
                  (Phase2IntegrityAlgorithmsRequestList.to_query
                     v.phase2_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase1IntegrityAlgorithm",
                  (Phase1IntegrityAlgorithmsRequestList.to_query
                     v.phase1_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase2EncryptionAlgorithm",
                  (Phase2EncryptionAlgorithmsRequestList.to_query
                     v.phase2_encryption_algorithms)));
           Some
             (Query.Pair
                ("Phase1EncryptionAlgorithm",
                  (Phase1EncryptionAlgorithmsRequestList.to_query
                     v.phase1_encryption_algorithms)));
           Util.option_map v.d_p_d_timeout_seconds
             (fun f -> Query.Pair ("DPDTimeoutSeconds", (Integer.to_query f)));
           Util.option_map v.replay_window_size
             (fun f -> Query.Pair ("ReplayWindowSize", (Integer.to_query f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f ->
                Query.Pair ("RekeyFuzzPercentage", (Integer.to_query f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f ->
                Query.Pair ("RekeyMarginTimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase2LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase1LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.pre_shared_key
             (fun f -> Query.Pair ("PreSharedKey", (String.to_query f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> Query.Pair ("TunnelInsideCidr", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Util.option_map v.tunnel_inside_cidr
                            (fun f ->
                               Ezxmlm.make_tag "TunnelInsideCidr"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.pre_shared_key
                           (fun f ->
                              Ezxmlm.make_tag "PreSharedKey"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.phase1_lifetime_seconds
                          (fun f ->
                             Ezxmlm.make_tag "Phase1LifetimeSeconds"
                               ([], (Integer.to_xml f)))])
                      @
                      [Util.option_map v.phase2_lifetime_seconds
                         (fun f ->
                            Ezxmlm.make_tag "Phase2LifetimeSeconds"
                              ([], (Integer.to_xml f)))])
                     @
                     [Util.option_map v.rekey_margin_time_seconds
                        (fun f ->
                           Ezxmlm.make_tag "RekeyMarginTimeSeconds"
                             ([], (Integer.to_xml f)))])
                    @
                    [Util.option_map v.rekey_fuzz_percentage
                       (fun f ->
                          Ezxmlm.make_tag "RekeyFuzzPercentage"
                            ([], (Integer.to_xml f)))])
                   @
                   [Util.option_map v.replay_window_size
                      (fun f ->
                         Ezxmlm.make_tag "ReplayWindowSize"
                           ([], (Integer.to_xml f)))])
                  @
                  [Util.option_map v.d_p_d_timeout_seconds
                     (fun f ->
                        Ezxmlm.make_tag "DPDTimeoutSeconds"
                          ([], (Integer.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "Phase1EncryptionAlgorithm"
                            ([],
                              (Phase1EncryptionAlgorithmsRequestList.to_xml
                                 [x])))) v.phase1_encryption_algorithms))
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "Phase2EncryptionAlgorithm"
                           ([],
                             (Phase2EncryptionAlgorithmsRequestList.to_xml
                                [x])))) v.phase2_encryption_algorithms))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Phase1IntegrityAlgorithm"
                          ([],
                            (Phase1IntegrityAlgorithmsRequestList.to_xml [x]))))
                  v.phase1_integrity_algorithms))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Phase2IntegrityAlgorithm"
                         ([],
                           (Phase2IntegrityAlgorithmsRequestList.to_xml [x]))))
                 v.phase2_integrity_algorithms))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Phase1DHGroupNumber"
                        ([], (Phase1DHGroupNumbersRequestList.to_xml [x]))))
                v.phase1_d_h_group_numbers))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Phase2DHGroupNumber"
                       ([], (Phase2DHGroupNumbersRequestList.to_xml [x]))))
               v.phase2_d_h_group_numbers))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "IKEVersion"
                      ([], (IKEVersionsRequestList.to_xml [x]))))
              v.i_k_e_versions))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("i_k_e_versions",
                (IKEVersionsRequestList.to_json v.i_k_e_versions));
           Some
             ("phase2_d_h_group_numbers",
               (Phase2DHGroupNumbersRequestList.to_json
                  v.phase2_d_h_group_numbers));
           Some
             ("phase1_d_h_group_numbers",
               (Phase1DHGroupNumbersRequestList.to_json
                  v.phase1_d_h_group_numbers));
           Some
             ("phase2_integrity_algorithms",
               (Phase2IntegrityAlgorithmsRequestList.to_json
                  v.phase2_integrity_algorithms));
           Some
             ("phase1_integrity_algorithms",
               (Phase1IntegrityAlgorithmsRequestList.to_json
                  v.phase1_integrity_algorithms));
           Some
             ("phase2_encryption_algorithms",
               (Phase2EncryptionAlgorithmsRequestList.to_json
                  v.phase2_encryption_algorithms));
           Some
             ("phase1_encryption_algorithms",
               (Phase1EncryptionAlgorithmsRequestList.to_json
                  v.phase1_encryption_algorithms));
           Util.option_map v.d_p_d_timeout_seconds
             (fun f -> ("d_p_d_timeout_seconds", (Integer.to_json f)));
           Util.option_map v.replay_window_size
             (fun f -> ("replay_window_size", (Integer.to_json f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f -> ("rekey_fuzz_percentage", (Integer.to_json f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f -> ("rekey_margin_time_seconds", (Integer.to_json f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f -> ("phase2_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f -> ("phase1_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.pre_shared_key
             (fun f -> ("pre_shared_key", (String.to_json f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> ("tunnel_inside_cidr", (String.to_json f)))])
    let of_json j =
      {
        tunnel_inside_cidr =
          (Util.option_map (Json.lookup j "tunnel_inside_cidr")
             String.of_json);
        pre_shared_key =
          (Util.option_map (Json.lookup j "pre_shared_key") String.of_json);
        phase1_lifetime_seconds =
          (Util.option_map (Json.lookup j "phase1_lifetime_seconds")
             Integer.of_json);
        phase2_lifetime_seconds =
          (Util.option_map (Json.lookup j "phase2_lifetime_seconds")
             Integer.of_json);
        rekey_margin_time_seconds =
          (Util.option_map (Json.lookup j "rekey_margin_time_seconds")
             Integer.of_json);
        rekey_fuzz_percentage =
          (Util.option_map (Json.lookup j "rekey_fuzz_percentage")
             Integer.of_json);
        replay_window_size =
          (Util.option_map (Json.lookup j "replay_window_size")
             Integer.of_json);
        d_p_d_timeout_seconds =
          (Util.option_map (Json.lookup j "d_p_d_timeout_seconds")
             Integer.of_json);
        phase1_encryption_algorithms =
          (Phase1EncryptionAlgorithmsRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase1_encryption_algorithms")));
        phase2_encryption_algorithms =
          (Phase2EncryptionAlgorithmsRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase2_encryption_algorithms")));
        phase1_integrity_algorithms =
          (Phase1IntegrityAlgorithmsRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase1_integrity_algorithms")));
        phase2_integrity_algorithms =
          (Phase2IntegrityAlgorithmsRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase2_integrity_algorithms")));
        phase1_d_h_group_numbers =
          (Phase1DHGroupNumbersRequestList.of_json
             (Util.of_option_exn (Json.lookup j "phase1_d_h_group_numbers")));
        phase2_d_h_group_numbers =
          (Phase2DHGroupNumbersRequestList.of_json
             (Util.of_option_exn (Json.lookup j "phase2_d_h_group_numbers")));
        i_k_e_versions =
          (IKEVersionsRequestList.of_json
             (Util.of_option_exn (Json.lookup j "i_k_e_versions")))
      }
  end
module DomainType =
  struct
    type t =
      | Vpc 
      | Standard 
    let str_to_t = [("standard", Standard); ("vpc", Vpc)]
    let t_to_str = [(Standard, "standard"); (Vpc, "vpc")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EbsInfo =
  struct
    type t =
      {
      ebs_optimized_support: EbsOptimizedSupport.t option ;
      encryption_support: EbsEncryptionSupport.t option }
    let make ?ebs_optimized_support  ?encryption_support  () =
      { ebs_optimized_support; encryption_support }
    let parse xml =
      Some
        {
          ebs_optimized_support =
            (Util.option_bind (Xml.member "ebsOptimizedSupport" xml)
               EbsOptimizedSupport.parse);
          encryption_support =
            (Util.option_bind (Xml.member "encryptionSupport" xml)
               EbsEncryptionSupport.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.encryption_support
              (fun f ->
                 Query.Pair
                   ("EncryptionSupport", (EbsEncryptionSupport.to_query f)));
           Util.option_map v.ebs_optimized_support
             (fun f ->
                Query.Pair
                  ("EbsOptimizedSupport", (EbsOptimizedSupport.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.ebs_optimized_support
               (fun f ->
                  Ezxmlm.make_tag "ebsOptimizedSupport"
                    ([], (EbsOptimizedSupport.to_xml f)))])
           @
           [Util.option_map v.encryption_support
              (fun f ->
                 Ezxmlm.make_tag "encryptionSupport"
                   ([], (EbsEncryptionSupport.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.encryption_support
              (fun f ->
                 ("encryption_support", (EbsEncryptionSupport.to_json f)));
           Util.option_map v.ebs_optimized_support
             (fun f ->
                ("ebs_optimized_support", (EbsOptimizedSupport.to_json f)))])
    let of_json j =
      {
        ebs_optimized_support =
          (Util.option_map (Json.lookup j "ebs_optimized_support")
             EbsOptimizedSupport.of_json);
        encryption_support =
          (Util.option_map (Json.lookup j "encryption_support")
             EbsEncryptionSupport.of_json)
      }
  end
module FpgaInfo =
  struct
    type t =
      {
      fpgas: FpgaDeviceInfoList.t ;
      total_fpga_memory_in_mi_b: Integer.t option }
    let make ?(fpgas= [])  ?total_fpga_memory_in_mi_b  () =
      { fpgas; total_fpga_memory_in_mi_b }
    let parse xml =
      Some
        {
          fpgas =
            (Util.of_option []
               (Util.option_bind (Xml.member "fpgas" xml)
                  FpgaDeviceInfoList.parse));
          total_fpga_memory_in_mi_b =
            (Util.option_bind (Xml.member "totalFpgaMemoryInMiB" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_fpga_memory_in_mi_b
              (fun f ->
                 Query.Pair ("TotalFpgaMemoryInMiB", (Integer.to_query f)));
           Some (Query.Pair ("Fpgas", (FpgaDeviceInfoList.to_query v.fpgas)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "fpgas"
                       ([], (FpgaDeviceInfoList.to_xml [x])))) v.fpgas))
           @
           [Util.option_map v.total_fpga_memory_in_mi_b
              (fun f ->
                 Ezxmlm.make_tag "totalFpgaMemoryInMiB"
                   ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_fpga_memory_in_mi_b
              (fun f -> ("total_fpga_memory_in_mi_b", (Integer.to_json f)));
           Some ("fpgas", (FpgaDeviceInfoList.to_json v.fpgas))])
    let of_json j =
      {
        fpgas =
          (FpgaDeviceInfoList.of_json
             (Util.of_option_exn (Json.lookup j "fpgas")));
        total_fpga_memory_in_mi_b =
          (Util.option_map (Json.lookup j "total_fpga_memory_in_mi_b")
             Integer.of_json)
      }
  end
module GpuInfo =
  struct
    type t =
      {
      gpus: GpuDeviceInfoList.t ;
      total_gpu_memory_in_mi_b: Integer.t option }
    let make ?(gpus= [])  ?total_gpu_memory_in_mi_b  () =
      { gpus; total_gpu_memory_in_mi_b }
    let parse xml =
      Some
        {
          gpus =
            (Util.of_option []
               (Util.option_bind (Xml.member "gpus" xml)
                  GpuDeviceInfoList.parse));
          total_gpu_memory_in_mi_b =
            (Util.option_bind (Xml.member "totalGpuMemoryInMiB" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_gpu_memory_in_mi_b
              (fun f ->
                 Query.Pair ("TotalGpuMemoryInMiB", (Integer.to_query f)));
           Some (Query.Pair ("Gpus", (GpuDeviceInfoList.to_query v.gpus)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "gpus"
                       ([], (GpuDeviceInfoList.to_xml [x])))) v.gpus))
           @
           [Util.option_map v.total_gpu_memory_in_mi_b
              (fun f ->
                 Ezxmlm.make_tag "totalGpuMemoryInMiB"
                   ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_gpu_memory_in_mi_b
              (fun f -> ("total_gpu_memory_in_mi_b", (Integer.to_json f)));
           Some ("gpus", (GpuDeviceInfoList.to_json v.gpus))])
    let of_json j =
      {
        gpus =
          (GpuDeviceInfoList.of_json
             (Util.of_option_exn (Json.lookup j "gpus")));
        total_gpu_memory_in_mi_b =
          (Util.option_map (Json.lookup j "total_gpu_memory_in_mi_b")
             Integer.of_json)
      }
  end
module InferenceAcceleratorInfo =
  struct
    type t = {
      accelerators: InferenceDeviceInfoList.t }
    let make ?(accelerators= [])  () = { accelerators }
    let parse xml =
      Some
        {
          accelerators =
            (Util.of_option []
               (Util.option_bind (Xml.member "accelerators" xml)
                  InferenceDeviceInfoList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Accelerators",
                   (InferenceDeviceInfoList.to_query v.accelerators)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "accelerators"
                      ([], (InferenceDeviceInfoList.to_xml [x]))))
              v.accelerators))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("accelerators",
                (InferenceDeviceInfoList.to_json v.accelerators))])
    let of_json j =
      {
        accelerators =
          (InferenceDeviceInfoList.of_json
             (Util.of_option_exn (Json.lookup j "accelerators")))
      }
  end
module InstanceStorageInfo =
  struct
    type t = {
      total_size_in_g_b: Long.t option ;
      disks: DiskInfoList.t }
    let make ?total_size_in_g_b  ?(disks= [])  () =
      { total_size_in_g_b; disks }
    let parse xml =
      Some
        {
          total_size_in_g_b =
            (Util.option_bind (Xml.member "totalSizeInGB" xml) Long.parse);
          disks =
            (Util.of_option []
               (Util.option_bind (Xml.member "disks" xml) DiskInfoList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Disks", (DiskInfoList.to_query v.disks)));
           Util.option_map v.total_size_in_g_b
             (fun f -> Query.Pair ("TotalSizeInGB", (Long.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.total_size_in_g_b
               (fun f ->
                  Ezxmlm.make_tag "totalSizeInGB" ([], (Long.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "disks" ([], (DiskInfoList.to_xml [x]))))
              v.disks))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("disks", (DiskInfoList.to_json v.disks));
           Util.option_map v.total_size_in_g_b
             (fun f -> ("total_size_in_g_b", (Long.to_json f)))])
    let of_json j =
      {
        total_size_in_g_b =
          (Util.option_map (Json.lookup j "total_size_in_g_b") Long.of_json);
        disks =
          (DiskInfoList.of_json (Util.of_option_exn (Json.lookup j "disks")))
      }
  end
module InstanceTypeHypervisor =
  struct
    type t =
      | Nitro 
      | Xen 
    let str_to_t = [("xen", Xen); ("nitro", Nitro)]
    let t_to_str = [(Xen, "xen"); (Nitro, "nitro")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module MemoryInfo =
  struct
    type t = {
      size_in_mi_b: Long.t option }
    let make ?size_in_mi_b  () = { size_in_mi_b }
    let parse xml =
      Some
        {
          size_in_mi_b =
            (Util.option_bind (Xml.member "sizeInMiB" xml) Long.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> Query.Pair ("SizeInMiB", (Long.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.size_in_mi_b
              (fun f -> Ezxmlm.make_tag "sizeInMiB" ([], (Long.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> ("size_in_mi_b", (Long.to_json f)))])
    let of_json j =
      {
        size_in_mi_b =
          (Util.option_map (Json.lookup j "size_in_mi_b") Long.of_json)
      }
  end
module NetworkInfo =
  struct
    type t =
      {
      network_performance: String.t option ;
      maximum_network_interfaces: Integer.t option ;
      ipv4_addresses_per_interface: Integer.t option ;
      ipv6_addresses_per_interface: Integer.t option ;
      ipv6_supported: Boolean.t option ;
      ena_support: EnaSupport.t option }
    let make ?network_performance  ?maximum_network_interfaces 
      ?ipv4_addresses_per_interface  ?ipv6_addresses_per_interface 
      ?ipv6_supported  ?ena_support  () =
      {
        network_performance;
        maximum_network_interfaces;
        ipv4_addresses_per_interface;
        ipv6_addresses_per_interface;
        ipv6_supported;
        ena_support
      }
    let parse xml =
      Some
        {
          network_performance =
            (Util.option_bind (Xml.member "networkPerformance" xml)
               String.parse);
          maximum_network_interfaces =
            (Util.option_bind (Xml.member "maximumNetworkInterfaces" xml)
               Integer.parse);
          ipv4_addresses_per_interface =
            (Util.option_bind (Xml.member "ipv4AddressesPerInterface" xml)
               Integer.parse);
          ipv6_addresses_per_interface =
            (Util.option_bind (Xml.member "ipv6AddressesPerInterface" xml)
               Integer.parse);
          ipv6_supported =
            (Util.option_bind (Xml.member "ipv6Supported" xml) Boolean.parse);
          ena_support =
            (Util.option_bind (Xml.member "enaSupport" xml) EnaSupport.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ena_support
              (fun f -> Query.Pair ("EnaSupport", (EnaSupport.to_query f)));
           Util.option_map v.ipv6_supported
             (fun f -> Query.Pair ("Ipv6Supported", (Boolean.to_query f)));
           Util.option_map v.ipv6_addresses_per_interface
             (fun f ->
                Query.Pair
                  ("Ipv6AddressesPerInterface", (Integer.to_query f)));
           Util.option_map v.ipv4_addresses_per_interface
             (fun f ->
                Query.Pair
                  ("Ipv4AddressesPerInterface", (Integer.to_query f)));
           Util.option_map v.maximum_network_interfaces
             (fun f ->
                Query.Pair ("MaximumNetworkInterfaces", (Integer.to_query f)));
           Util.option_map v.network_performance
             (fun f -> Query.Pair ("NetworkPerformance", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.network_performance
                   (fun f ->
                      Ezxmlm.make_tag "networkPerformance"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.maximum_network_interfaces
                  (fun f ->
                     Ezxmlm.make_tag "maximumNetworkInterfaces"
                       ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.ipv4_addresses_per_interface
                 (fun f ->
                    Ezxmlm.make_tag "ipv4AddressesPerInterface"
                      ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.ipv6_addresses_per_interface
                (fun f ->
                   Ezxmlm.make_tag "ipv6AddressesPerInterface"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.ipv6_supported
               (fun f ->
                  Ezxmlm.make_tag "ipv6Supported" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.ena_support
              (fun f ->
                 Ezxmlm.make_tag "enaSupport" ([], (EnaSupport.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ena_support
              (fun f -> ("ena_support", (EnaSupport.to_json f)));
           Util.option_map v.ipv6_supported
             (fun f -> ("ipv6_supported", (Boolean.to_json f)));
           Util.option_map v.ipv6_addresses_per_interface
             (fun f -> ("ipv6_addresses_per_interface", (Integer.to_json f)));
           Util.option_map v.ipv4_addresses_per_interface
             (fun f -> ("ipv4_addresses_per_interface", (Integer.to_json f)));
           Util.option_map v.maximum_network_interfaces
             (fun f -> ("maximum_network_interfaces", (Integer.to_json f)));
           Util.option_map v.network_performance
             (fun f -> ("network_performance", (String.to_json f)))])
    let of_json j =
      {
        network_performance =
          (Util.option_map (Json.lookup j "network_performance")
             String.of_json);
        maximum_network_interfaces =
          (Util.option_map (Json.lookup j "maximum_network_interfaces")
             Integer.of_json);
        ipv4_addresses_per_interface =
          (Util.option_map (Json.lookup j "ipv4_addresses_per_interface")
             Integer.of_json);
        ipv6_addresses_per_interface =
          (Util.option_map (Json.lookup j "ipv6_addresses_per_interface")
             Integer.of_json);
        ipv6_supported =
          (Util.option_map (Json.lookup j "ipv6_supported") Boolean.of_json);
        ena_support =
          (Util.option_map (Json.lookup j "ena_support") EnaSupport.of_json)
      }
  end
module PlacementGroupInfo =
  struct
    type t = {
      supported_strategies: PlacementGroupStrategyList.t }
    let make ?(supported_strategies= [])  () = { supported_strategies }
    let parse xml =
      Some
        {
          supported_strategies =
            (Util.of_option []
               (Util.option_bind (Xml.member "supportedStrategies" xml)
                  PlacementGroupStrategyList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SupportedStrategies",
                   (PlacementGroupStrategyList.to_query
                      v.supported_strategies)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "supportedStrategies"
                      ([], (PlacementGroupStrategyList.to_xml [x]))))
              v.supported_strategies))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("supported_strategies",
                (PlacementGroupStrategyList.to_json v.supported_strategies))])
    let of_json j =
      {
        supported_strategies =
          (PlacementGroupStrategyList.of_json
             (Util.of_option_exn (Json.lookup j "supported_strategies")))
      }
  end
module ProcessorInfo =
  struct
    type t =
      {
      supported_architectures: ArchitectureTypeList.t ;
      sustained_clock_speed_in_ghz: Double.t option }
    let make ?(supported_architectures= [])  ?sustained_clock_speed_in_ghz 
      () = { supported_architectures; sustained_clock_speed_in_ghz }
    let parse xml =
      Some
        {
          supported_architectures =
            (Util.of_option []
               (Util.option_bind (Xml.member "supportedArchitectures" xml)
                  ArchitectureTypeList.parse));
          sustained_clock_speed_in_ghz =
            (Util.option_bind (Xml.member "sustainedClockSpeedInGhz" xml)
               Double.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.sustained_clock_speed_in_ghz
              (fun f ->
                 Query.Pair ("SustainedClockSpeedInGhz", (Double.to_query f)));
           Some
             (Query.Pair
                ("SupportedArchitectures",
                  (ArchitectureTypeList.to_query v.supported_architectures)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "supportedArchitectures"
                       ([], (ArchitectureTypeList.to_xml [x]))))
               v.supported_architectures))
           @
           [Util.option_map v.sustained_clock_speed_in_ghz
              (fun f ->
                 Ezxmlm.make_tag "sustainedClockSpeedInGhz"
                   ([], (Double.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.sustained_clock_speed_in_ghz
              (fun f -> ("sustained_clock_speed_in_ghz", (Double.to_json f)));
           Some
             ("supported_architectures",
               (ArchitectureTypeList.to_json v.supported_architectures))])
    let of_json j =
      {
        supported_architectures =
          (ArchitectureTypeList.of_json
             (Util.of_option_exn (Json.lookup j "supported_architectures")));
        sustained_clock_speed_in_ghz =
          (Util.option_map (Json.lookup j "sustained_clock_speed_in_ghz")
             Double.of_json)
      }
  end
module RootDeviceTypeList =
  struct
    type t = RootDeviceType.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map RootDeviceType.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list RootDeviceType.to_query v
    let to_headers v = Headers.to_headers_list RootDeviceType.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (RootDeviceType.to_xml x))) v
    let to_json v = `List (List.map RootDeviceType.to_json v)
    let of_json j = Json.to_list RootDeviceType.of_json j
  end
module UsageClassTypeList =
  struct
    type t = UsageClassType.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map UsageClassType.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list UsageClassType.to_query v
    let to_headers v = Headers.to_headers_list UsageClassType.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (UsageClassType.to_xml x))) v
    let to_json v = `List (List.map UsageClassType.to_json v)
    let of_json j = Json.to_list UsageClassType.of_json j
  end
module VCpuInfo =
  struct
    type t =
      {
      default_v_cpus: Integer.t option ;
      default_cores: Integer.t option ;
      default_threads_per_core: Integer.t option ;
      valid_cores: CoreCountList.t ;
      valid_threads_per_core: ThreadsPerCoreList.t }
    let make ?default_v_cpus  ?default_cores  ?default_threads_per_core 
      ?(valid_cores= [])  ?(valid_threads_per_core= [])  () =
      {
        default_v_cpus;
        default_cores;
        default_threads_per_core;
        valid_cores;
        valid_threads_per_core
      }
    let parse xml =
      Some
        {
          default_v_cpus =
            (Util.option_bind (Xml.member "defaultVCpus" xml) Integer.parse);
          default_cores =
            (Util.option_bind (Xml.member "defaultCores" xml) Integer.parse);
          default_threads_per_core =
            (Util.option_bind (Xml.member "defaultThreadsPerCore" xml)
               Integer.parse);
          valid_cores =
            (Util.of_option []
               (Util.option_bind (Xml.member "validCores" xml)
                  CoreCountList.parse));
          valid_threads_per_core =
            (Util.of_option []
               (Util.option_bind (Xml.member "validThreadsPerCore" xml)
                  ThreadsPerCoreList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ValidThreadsPerCore",
                   (ThreadsPerCoreList.to_query v.valid_threads_per_core)));
           Some
             (Query.Pair
                ("ValidCores", (CoreCountList.to_query v.valid_cores)));
           Util.option_map v.default_threads_per_core
             (fun f ->
                Query.Pair ("DefaultThreadsPerCore", (Integer.to_query f)));
           Util.option_map v.default_cores
             (fun f -> Query.Pair ("DefaultCores", (Integer.to_query f)));
           Util.option_map v.default_v_cpus
             (fun f -> Query.Pair ("DefaultVCpus", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.default_v_cpus
                  (fun f ->
                     Ezxmlm.make_tag "defaultVCpus" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.default_cores
                 (fun f ->
                    Ezxmlm.make_tag "defaultCores" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.default_threads_per_core
                (fun f ->
                   Ezxmlm.make_tag "defaultThreadsPerCore"
                     ([], (Integer.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "validCores"
                       ([], (CoreCountList.to_xml [x])))) v.valid_cores))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "validThreadsPerCore"
                      ([], (ThreadsPerCoreList.to_xml [x]))))
              v.valid_threads_per_core))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("valid_threads_per_core",
                (ThreadsPerCoreList.to_json v.valid_threads_per_core));
           Some ("valid_cores", (CoreCountList.to_json v.valid_cores));
           Util.option_map v.default_threads_per_core
             (fun f -> ("default_threads_per_core", (Integer.to_json f)));
           Util.option_map v.default_cores
             (fun f -> ("default_cores", (Integer.to_json f)));
           Util.option_map v.default_v_cpus
             (fun f -> ("default_v_cpus", (Integer.to_json f)))])
    let of_json j =
      {
        default_v_cpus =
          (Util.option_map (Json.lookup j "default_v_cpus") Integer.of_json);
        default_cores =
          (Util.option_map (Json.lookup j "default_cores") Integer.of_json);
        default_threads_per_core =
          (Util.option_map (Json.lookup j "default_threads_per_core")
             Integer.of_json);
        valid_cores =
          (CoreCountList.of_json
             (Util.of_option_exn (Json.lookup j "valid_cores")));
        valid_threads_per_core =
          (ThreadsPerCoreList.of_json
             (Util.of_option_exn (Json.lookup j "valid_threads_per_core")))
      }
  end
module ClientVpnRouteStatus =
  struct
    type t =
      {
      code: ClientVpnRouteStatusCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               ClientVpnRouteStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair ("Code", (ClientVpnRouteStatusCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (ClientVpnRouteStatusCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (ClientVpnRouteStatusCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             ClientVpnRouteStatusCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module VgwTelemetryList =
  struct
    type t = VgwTelemetry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map VgwTelemetry.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VgwTelemetry.to_query v
    let to_headers v = Headers.to_headers_list VgwTelemetry.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VgwTelemetry.to_xml x))) v
    let to_json v = `List (List.map VgwTelemetry.to_json v)
    let of_json j = Json.to_list VgwTelemetry.of_json j
  end
module VpnConnectionOptions =
  struct
    type t =
      {
      enable_acceleration: Boolean.t option ;
      static_routes_only: Boolean.t option ;
      tunnel_options: TunnelOptionsList.t }
    let make ?enable_acceleration  ?static_routes_only  ?(tunnel_options= [])
       () = { enable_acceleration; static_routes_only; tunnel_options }
    let parse xml =
      Some
        {
          enable_acceleration =
            (Util.option_bind (Xml.member "enableAcceleration" xml)
               Boolean.parse);
          static_routes_only =
            (Util.option_bind (Xml.member "staticRoutesOnly" xml)
               Boolean.parse);
          tunnel_options =
            (Util.of_option []
               (Util.option_bind (Xml.member "tunnelOptionSet" xml)
                  TunnelOptionsList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TunnelOptionSet",
                   (TunnelOptionsList.to_query v.tunnel_options)));
           Util.option_map v.static_routes_only
             (fun f -> Query.Pair ("StaticRoutesOnly", (Boolean.to_query f)));
           Util.option_map v.enable_acceleration
             (fun f ->
                Query.Pair ("EnableAcceleration", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.enable_acceleration
                (fun f ->
                   Ezxmlm.make_tag "enableAcceleration"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.static_routes_only
               (fun f ->
                  Ezxmlm.make_tag "staticRoutesOnly" ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "tunnelOptionSet"
                      ([], (TunnelOptionsList.to_xml [x])))) v.tunnel_options))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tunnel_options",
                (TunnelOptionsList.to_json v.tunnel_options));
           Util.option_map v.static_routes_only
             (fun f -> ("static_routes_only", (Boolean.to_json f)));
           Util.option_map v.enable_acceleration
             (fun f -> ("enable_acceleration", (Boolean.to_json f)))])
    let of_json j =
      {
        enable_acceleration =
          (Util.option_map (Json.lookup j "enable_acceleration")
             Boolean.of_json);
        static_routes_only =
          (Util.option_map (Json.lookup j "static_routes_only")
             Boolean.of_json);
        tunnel_options =
          (TunnelOptionsList.of_json
             (Util.of_option_exn (Json.lookup j "tunnel_options")))
      }
  end
module VpnStaticRouteList =
  struct
    type t = VpnStaticRoute.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpnStaticRoute.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpnStaticRoute.to_query v
    let to_headers v = Headers.to_headers_list VpnStaticRoute.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VpnStaticRoute.to_xml x))) v
    let to_json v = `List (List.map VpnStaticRoute.to_json v)
    let of_json j = Json.to_list VpnStaticRoute.of_json j
  end
module AssociationStatus =
  struct
    type t =
      {
      code: AssociationStatusCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               AssociationStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair ("Code", (AssociationStatusCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (AssociationStatusCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (AssociationStatusCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             AssociationStatusCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module VpcPeeringConnectionStateReason =
  struct
    type t =
      {
      code: VpcPeeringConnectionStateReasonCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               VpcPeeringConnectionStateReasonCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code", (VpcPeeringConnectionStateReasonCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (VpcPeeringConnectionStateReasonCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code", (VpcPeeringConnectionStateReasonCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             VpcPeeringConnectionStateReasonCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module VpcPeeringConnectionVpcInfo =
  struct
    type t =
      {
      cidr_block: String.t option ;
      ipv6_cidr_block_set: Ipv6CidrBlockSet.t ;
      cidr_block_set: CidrBlockSet.t ;
      owner_id: String.t option ;
      peering_options: VpcPeeringConnectionOptionsDescription.t option ;
      vpc_id: String.t option ;
      region: String.t option }
    let make ?cidr_block  ?(ipv6_cidr_block_set= [])  ?(cidr_block_set= []) 
      ?owner_id  ?peering_options  ?vpc_id  ?region  () =
      {
        cidr_block;
        ipv6_cidr_block_set;
        cidr_block_set;
        owner_id;
        peering_options;
        vpc_id;
        region
      }
    let parse xml =
      Some
        {
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse);
          ipv6_cidr_block_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6CidrBlockSet" xml)
                  Ipv6CidrBlockSet.parse));
          cidr_block_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "cidrBlockSet" xml)
                  CidrBlockSet.parse));
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          peering_options =
            (Util.option_bind (Xml.member "peeringOptions" xml)
               VpcPeeringConnectionOptionsDescription.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          region = (Util.option_bind (Xml.member "region" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.region
              (fun f -> Query.Pair ("Region", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.peering_options
             (fun f ->
                Query.Pair
                  ("PeeringOptions",
                    (VpcPeeringConnectionOptionsDescription.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Some
             (Query.Pair
                ("CidrBlockSet", (CidrBlockSet.to_query v.cidr_block_set)));
           Some
             (Query.Pair
                ("Ipv6CidrBlockSet",
                  (Ipv6CidrBlockSet.to_query v.ipv6_cidr_block_set)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.cidr_block
                    (fun f ->
                       Ezxmlm.make_tag "cidrBlock" ([], (String.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "ipv6CidrBlockSet"
                           ([], (Ipv6CidrBlockSet.to_xml [x]))))
                   v.ipv6_cidr_block_set))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "cidrBlockSet"
                          ([], (CidrBlockSet.to_xml [x])))) v.cidr_block_set))
              @
              [Util.option_map v.owner_id
                 (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.peering_options
                (fun f ->
                   Ezxmlm.make_tag "peeringOptions"
                     ([], (VpcPeeringConnectionOptionsDescription.to_xml f)))])
            @
            [Util.option_map v.vpc_id
               (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.region
              (fun f -> Ezxmlm.make_tag "region" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.region
              (fun f -> ("region", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.peering_options
             (fun f ->
                ("peering_options",
                  (VpcPeeringConnectionOptionsDescription.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Some ("cidr_block_set", (CidrBlockSet.to_json v.cidr_block_set));
           Some
             ("ipv6_cidr_block_set",
               (Ipv6CidrBlockSet.to_json v.ipv6_cidr_block_set));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)))])
    let of_json j =
      {
        cidr_block =
          (Util.option_map (Json.lookup j "cidr_block") String.of_json);
        ipv6_cidr_block_set =
          (Ipv6CidrBlockSet.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_cidr_block_set")));
        cidr_block_set =
          (CidrBlockSet.of_json
             (Util.of_option_exn (Json.lookup j "cidr_block_set")));
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        peering_options =
          (Util.option_map (Json.lookup j "peering_options")
             VpcPeeringConnectionOptionsDescription.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        region = (Util.option_map (Json.lookup j "region") String.of_json)
      }
  end
module NetworkAclAssociationList =
  struct
    type t = NetworkAclAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkAclAssociation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NetworkAclAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list NetworkAclAssociation.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (NetworkAclAssociation.to_xml x))) v
    let to_json v = `List (List.map NetworkAclAssociation.to_json v)
    let of_json j = Json.to_list NetworkAclAssociation.of_json j
  end
module NetworkAclEntryList =
  struct
    type t = NetworkAclEntry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkAclEntry.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NetworkAclEntry.to_query v
    let to_headers v = Headers.to_headers_list NetworkAclEntry.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (NetworkAclEntry.to_xml x)))
        v
    let to_json v = `List (List.map NetworkAclEntry.to_json v)
    let of_json j = Json.to_list NetworkAclEntry.of_json j
  end
module CancelSpotFleetRequestsError =
  struct
    type t = {
      code: CancelBatchErrorCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               CancelBatchErrorCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (CancelBatchErrorCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (CancelBatchErrorCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (CancelBatchErrorCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             CancelBatchErrorCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module BatchState =
  struct
    type t =
      | Submitted 
      | Active 
      | Cancelled 
      | Failed 
      | Cancelled_running 
      | Cancelled_terminating 
      | Modifying 
    let str_to_t =
      [("modifying", Modifying);
      ("cancelled_terminating", Cancelled_terminating);
      ("cancelled_running", Cancelled_running);
      ("failed", Failed);
      ("cancelled", Cancelled);
      ("active", Active);
      ("submitted", Submitted)]
    let t_to_str =
      [(Modifying, "modifying");
      (Cancelled_terminating, "cancelled_terminating");
      (Cancelled_running, "cancelled_running");
      (Failed, "failed");
      (Cancelled, "cancelled");
      (Active, "active");
      (Submitted, "submitted")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AccountAttributeValueList =
  struct
    type t = AccountAttributeValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AccountAttributeValue.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AccountAttributeValue.to_query v
    let to_headers v =
      Headers.to_headers_list AccountAttributeValue.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (AccountAttributeValue.to_xml x))) v
    let to_json v = `List (List.map AccountAttributeValue.to_json v)
    let of_json j = Json.to_list AccountAttributeValue.of_json j
  end
module DiskImageDetail =
  struct
    type t =
      {
      bytes: Long.t ;
      format: DiskImageFormat.t ;
      import_manifest_url: String.t }
    let make ~bytes  ~format  ~import_manifest_url  () =
      { bytes; format; import_manifest_url }
    let parse xml =
      Some
        {
          bytes =
            (Xml.required "bytes"
               (Util.option_bind (Xml.member "bytes" xml) Long.parse));
          format =
            (Xml.required "format"
               (Util.option_bind (Xml.member "format" xml)
                  DiskImageFormat.parse));
          import_manifest_url =
            (Xml.required "importManifestUrl"
               (Util.option_bind (Xml.member "importManifestUrl" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ImportManifestUrl",
                   (String.to_query v.import_manifest_url)));
           Some (Query.Pair ("Format", (DiskImageFormat.to_query v.format)));
           Some (Query.Pair ("Bytes", (Long.to_query v.bytes)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @ [Some (Ezxmlm.make_tag "bytes" ([], (Long.to_xml v.bytes)))])
            @
            [Some
               (Ezxmlm.make_tag "format"
                  ([], (DiskImageFormat.to_xml v.format)))])
           @
           [Some
              (Ezxmlm.make_tag "importManifestUrl"
                 ([], (String.to_xml v.import_manifest_url)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("import_manifest_url", (String.to_json v.import_manifest_url));
           Some ("format", (DiskImageFormat.to_json v.format));
           Some ("bytes", (Long.to_json v.bytes))])
    let of_json j =
      {
        bytes = (Long.of_json (Util.of_option_exn (Json.lookup j "bytes")));
        format =
          (DiskImageFormat.of_json
             (Util.of_option_exn (Json.lookup j "format")));
        import_manifest_url =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "import_manifest_url")))
      }
  end
module VolumeDetail =
  struct
    type t = {
      size: Long.t }
    let make ~size  () = { size }
    let parse xml =
      Some
        {
          size =
            (Xml.required "size"
               (Util.option_bind (Xml.member "size" xml) Long.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Size", (Long.to_query v.size)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @ [Some (Ezxmlm.make_tag "size" ([], (Long.to_xml v.size)))])
    let to_json v =
      `Assoc (Util.list_filter_opt [Some ("size", (Long.to_json v.size))])
    let of_json j =
      { size = (Long.of_json (Util.of_option_exn (Json.lookup j "size"))) }
  end
module GroupIdentifierSet =
  struct
    type t = SecurityGroupIdentifier.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SecurityGroupIdentifier.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SecurityGroupIdentifier.to_query v
    let to_headers v =
      Headers.to_headers_list SecurityGroupIdentifier.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (SecurityGroupIdentifier.to_xml x)))
        v
    let to_json v = `List (List.map SecurityGroupIdentifier.to_json v)
    let of_json j = Json.to_list SecurityGroupIdentifier.of_json j
  end
module VpcEndpointType =
  struct
    type t =
      | Interface 
      | Gateway 
    let str_to_t = [("Gateway", Gateway); ("Interface", Interface)]
    let t_to_str = [(Gateway, "Gateway"); (Interface, "Interface")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TransitGatewayAttachmentAssociation =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t option ;
      state: TransitGatewayAssociationState.t option }
    let make ?transit_gateway_route_table_id  ?state  () =
      { transit_gateway_route_table_id; state }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Util.option_bind (Xml.member "transitGatewayRouteTableId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAssociationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayAssociationState.to_query f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayRouteTableId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.transit_gateway_route_table_id
               (fun f ->
                  Ezxmlm.make_tag "transitGatewayRouteTableId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (TransitGatewayAssociationState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayAssociationState.to_json f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f -> ("transit_gateway_route_table_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (Util.option_map (Json.lookup j "transit_gateway_route_table_id")
             String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayAssociationState.of_json)
      }
  end
module TransitGatewayAttachmentState =
  struct
    type t =
      | Initiating 
      | PendingAcceptance 
      | RollingBack 
      | Pending 
      | Available 
      | Modifying 
      | Deleting 
      | Deleted 
      | Failed 
      | Rejected 
      | Rejecting 
      | Failing 
    let str_to_t =
      [("failing", Failing);
      ("rejecting", Rejecting);
      ("rejected", Rejected);
      ("failed", Failed);
      ("deleted", Deleted);
      ("deleting", Deleting);
      ("modifying", Modifying);
      ("available", Available);
      ("pending", Pending);
      ("rollingBack", RollingBack);
      ("pendingAcceptance", PendingAcceptance);
      ("initiating", Initiating)]
    let t_to_str =
      [(Failing, "failing");
      (Rejecting, "rejecting");
      (Rejected, "rejected");
      (Failed, "failed");
      (Deleted, "deleted");
      (Deleting, "deleting");
      (Modifying, "modifying");
      (Available, "available");
      (Pending, "pending");
      (RollingBack, "rollingBack");
      (PendingAcceptance, "pendingAcceptance");
      (Initiating, "initiating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SnapshotState =
  struct
    type t =
      | Pending 
      | Completed 
      | Error 
    let str_to_t =
      [("error", Error); ("completed", Completed); ("pending", Pending)]
    let t_to_str =
      [(Error, "error"); (Completed, "completed"); (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TrafficMirrorTargetType =
  struct
    type t =
      | Network_interface 
      | Network_load_balancer 
    let str_to_t =
      [("network-load-balancer", Network_load_balancer);
      ("network-interface", Network_interface)]
    let t_to_str =
      [(Network_load_balancer, "network-load-balancer");
      (Network_interface, "network-interface")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VolumeModificationState =
  struct
    type t =
      | Modifying 
      | Optimizing 
      | Completed 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("completed", Completed);
      ("optimizing", Optimizing);
      ("modifying", Modifying)]
    let t_to_str =
      [(Failed, "failed");
      (Completed, "completed");
      (Optimizing, "optimizing");
      (Modifying, "modifying")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NetworkInterfaceAttachment =
  struct
    type t =
      {
      attach_time: DateTime.t option ;
      attachment_id: String.t option ;
      delete_on_termination: Boolean.t option ;
      device_index: Integer.t option ;
      instance_id: String.t option ;
      instance_owner_id: String.t option ;
      status: AttachmentStatus.t option }
    let make ?attach_time  ?attachment_id  ?delete_on_termination 
      ?device_index  ?instance_id  ?instance_owner_id  ?status  () =
      {
        attach_time;
        attachment_id;
        delete_on_termination;
        device_index;
        instance_id;
        instance_owner_id;
        status
      }
    let parse xml =
      Some
        {
          attach_time =
            (Util.option_bind (Xml.member "attachTime" xml) DateTime.parse);
          attachment_id =
            (Util.option_bind (Xml.member "attachmentId" xml) String.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          device_index =
            (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_owner_id =
            (Util.option_bind (Xml.member "instanceOwnerId" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AttachmentStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (AttachmentStatus.to_query f)));
           Util.option_map v.instance_owner_id
             (fun f -> Query.Pair ("InstanceOwnerId", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attachment_id
             (fun f -> Query.Pair ("AttachmentId", (String.to_query f)));
           Util.option_map v.attach_time
             (fun f -> Query.Pair ("AttachTime", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.attach_time
                    (fun f ->
                       Ezxmlm.make_tag "attachTime" ([], (DateTime.to_xml f)))])
                @
                [Util.option_map v.attachment_id
                   (fun f ->
                      Ezxmlm.make_tag "attachmentId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.delete_on_termination
                  (fun f ->
                     Ezxmlm.make_tag "deleteOnTermination"
                       ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.device_index
                 (fun f ->
                    Ezxmlm.make_tag "deviceIndex" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.instance_id
                (fun f ->
                   Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.instance_owner_id
               (fun f ->
                  Ezxmlm.make_tag "instanceOwnerId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status" ([], (AttachmentStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (AttachmentStatus.to_json f)));
           Util.option_map v.instance_owner_id
             (fun f -> ("instance_owner_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attachment_id
             (fun f -> ("attachment_id", (String.to_json f)));
           Util.option_map v.attach_time
             (fun f -> ("attach_time", (DateTime.to_json f)))])
    let of_json j =
      {
        attach_time =
          (Util.option_map (Json.lookup j "attach_time") DateTime.of_json);
        attachment_id =
          (Util.option_map (Json.lookup j "attachment_id") String.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        device_index =
          (Util.option_map (Json.lookup j "device_index") Integer.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_owner_id =
          (Util.option_map (Json.lookup j "instance_owner_id") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") AttachmentStatus.of_json)
      }
  end
module NetworkInterfaceIpv6AddressesList =
  struct
    type t = NetworkInterfaceIpv6Address.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkInterfaceIpv6Address.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list NetworkInterfaceIpv6Address.to_query v
    let to_headers v =
      Headers.to_headers_list NetworkInterfaceIpv6Address.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (NetworkInterfaceIpv6Address.to_xml x))) v
    let to_json v = `List (List.map NetworkInterfaceIpv6Address.to_json v)
    let of_json j = Json.to_list NetworkInterfaceIpv6Address.of_json j
  end
module NetworkInterfacePrivateIpAddressList =
  struct
    type t = NetworkInterfacePrivateIpAddress.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkInterfacePrivateIpAddress.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list NetworkInterfacePrivateIpAddress.to_query v
    let to_headers v =
      Headers.to_headers_list NetworkInterfacePrivateIpAddress.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (NetworkInterfacePrivateIpAddress.to_xml x))) v
    let to_json v =
      `List (List.map NetworkInterfacePrivateIpAddress.to_json v)
    let of_json j = Json.to_list NetworkInterfacePrivateIpAddress.of_json j
  end
module NetworkInterfaceType =
  struct
    type t =
      | Interface 
      | NatGateway 
      | Efa 
    let str_to_t =
      [("efa", Efa); ("natGateway", NatGateway); ("interface", Interface)]
    let t_to_str =
      [(Efa, "efa"); (NatGateway, "natGateway"); (Interface, "interface")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ConnectionNotificationState =
  struct
    type t =
      | Enabled 
      | Disabled 
    let str_to_t = [("Disabled", Disabled); ("Enabled", Enabled)]
    let t_to_str = [(Disabled, "Disabled"); (Enabled, "Enabled")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ConnectionNotificationType =
  struct
    type t =
      | Topic 
    let str_to_t = [("Topic", Topic)]
    let t_to_str = [(Topic, "Topic")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module OfferingClassType =
  struct
    type t =
      | Standard 
      | Convertible 
    let str_to_t = [("convertible", Convertible); ("standard", Standard)]
    let t_to_str = [(Convertible, "convertible"); (Standard, "standard")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module OfferingTypeValues =
  struct
    type t =
      | Heavy_Utilization 
      | Medium_Utilization 
      | Light_Utilization 
      | No_Upfront 
      | Partial_Upfront 
      | All_Upfront 
    let str_to_t =
      [("All Upfront", All_Upfront);
      ("Partial Upfront", Partial_Upfront);
      ("No Upfront", No_Upfront);
      ("Light Utilization", Light_Utilization);
      ("Medium Utilization", Medium_Utilization);
      ("Heavy Utilization", Heavy_Utilization)]
    let t_to_str =
      [(All_Upfront, "All Upfront");
      (Partial_Upfront, "Partial Upfront");
      (No_Upfront, "No Upfront");
      (Light_Utilization, "Light Utilization");
      (Medium_Utilization, "Medium Utilization");
      (Heavy_Utilization, "Heavy Utilization")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RIProductDescription =
  struct
    type t =
      | Linux_UNIX 
      | Linux_UNIX__Amazon_VPC_ 
      | Windows 
      | Windows__Amazon_VPC_ 
    let str_to_t =
      [("Windows (Amazon VPC)", Windows__Amazon_VPC_);
      ("Windows", Windows);
      ("Linux/UNIX (Amazon VPC)", Linux_UNIX__Amazon_VPC_);
      ("Linux/UNIX", Linux_UNIX)]
    let t_to_str =
      [(Windows__Amazon_VPC_, "Windows (Amazon VPC)");
      (Windows, "Windows");
      (Linux_UNIX__Amazon_VPC_, "Linux/UNIX (Amazon VPC)");
      (Linux_UNIX, "Linux/UNIX")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RecurringChargesList =
  struct
    type t = RecurringCharge.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map RecurringCharge.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list RecurringCharge.to_query v
    let to_headers v = Headers.to_headers_list RecurringCharge.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (RecurringCharge.to_xml x)))
        v
    let to_json v = `List (List.map RecurringCharge.to_json v)
    let of_json j = Json.to_list RecurringCharge.of_json j
  end
module ReservedInstanceState =
  struct
    type t =
      | Payment_pending 
      | Active 
      | Payment_failed 
      | Retired 
      | Queued 
      | Queued_deleted 
    let str_to_t =
      [("queued-deleted", Queued_deleted);
      ("queued", Queued);
      ("retired", Retired);
      ("payment-failed", Payment_failed);
      ("active", Active);
      ("payment-pending", Payment_pending)]
    let t_to_str =
      [(Queued_deleted, "queued-deleted");
      (Queued, "queued");
      (Retired, "retired");
      (Payment_failed, "payment-failed");
      (Active, "active");
      (Payment_pending, "payment-pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PeeringAttachmentStatus =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module PeeringTgwInfo =
  struct
    type t =
      {
      transit_gateway_id: String.t option ;
      owner_id: String.t option ;
      region: String.t option }
    let make ?transit_gateway_id  ?owner_id  ?region  () =
      { transit_gateway_id; owner_id; region }
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          region = (Util.option_bind (Xml.member "region" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.region
              (fun f -> Query.Pair ("Region", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.transit_gateway_id
                (fun f ->
                   Ezxmlm.make_tag "transitGatewayId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.owner_id
               (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.region
              (fun f -> Ezxmlm.make_tag "region" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.region
              (fun f -> ("region", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        region = (Util.option_map (Json.lookup j "region") String.of_json)
      }
  end
module CancelSpotInstanceRequestState =
  struct
    type t =
      | Active 
      | Open 
      | Closed 
      | Cancelled 
      | Completed 
    let str_to_t =
      [("completed", Completed);
      ("cancelled", Cancelled);
      ("closed", Closed);
      ("open", Open);
      ("active", Active)]
    let t_to_str =
      [(Completed, "completed");
      (Cancelled, "cancelled");
      (Closed, "closed");
      (Open, "open");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ServiceState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
      | Failed 
    let str_to_t =
      [("Failed", Failed);
      ("Deleted", Deleted);
      ("Deleting", Deleting);
      ("Available", Available);
      ("Pending", Pending)]
    let t_to_str =
      [(Failed, "Failed");
      (Deleted, "Deleted");
      (Deleting, "Deleting");
      (Available, "Available");
      (Pending, "Pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ServiceTypeDetailSet =
  struct
    type t = ServiceTypeDetail.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ServiceTypeDetail.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ServiceTypeDetail.to_query v
    let to_headers v = Headers.to_headers_list ServiceTypeDetail.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ServiceTypeDetail.to_xml x)))
        v
    let to_json v = `List (List.map ServiceTypeDetail.to_json v)
    let of_json j = Json.to_list ServiceTypeDetail.of_json j
  end
module ConversionTaskState =
  struct
    type t =
      | Active 
      | Cancelling 
      | Cancelled 
      | Completed 
    let str_to_t =
      [("completed", Completed);
      ("cancelled", Cancelled);
      ("cancelling", Cancelling);
      ("active", Active)]
    let t_to_str =
      [(Completed, "completed");
      (Cancelled, "cancelled");
      (Cancelling, "cancelling");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ImportInstanceTaskDetails =
  struct
    type t =
      {
      description: String.t option ;
      instance_id: String.t option ;
      platform: PlatformValues.t option ;
      volumes: ImportInstanceVolumeDetailSet.t }
    let make ?description  ?instance_id  ?platform  ?(volumes= [])  () =
      { description; instance_id; platform; volumes }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse);
          volumes =
            (Util.of_option []
               (Util.option_bind (Xml.member "volumes" xml)
                  ImportInstanceVolumeDetailSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Volumes",
                   (ImportInstanceVolumeDetailSet.to_query v.volumes)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
             @
             [Util.option_map v.instance_id
                (fun f ->
                   Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.platform
               (fun f ->
                  Ezxmlm.make_tag "platform" ([], (PlatformValues.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "volumes"
                      ([], (ImportInstanceVolumeDetailSet.to_xml [x]))))
              v.volumes))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("volumes", (ImportInstanceVolumeDetailSet.to_json v.volumes));
           Util.option_map v.platform
             (fun f -> ("platform", (PlatformValues.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") PlatformValues.of_json);
        volumes =
          (ImportInstanceVolumeDetailSet.of_json
             (Util.of_option_exn (Json.lookup j "volumes")))
      }
  end
module ImportVolumeTaskDetails =
  struct
    type t =
      {
      availability_zone: String.t option ;
      bytes_converted: Long.t option ;
      description: String.t option ;
      image: DiskImageDescription.t option ;
      volume: DiskImageVolumeDescription.t option }
    let make ?availability_zone  ?bytes_converted  ?description  ?image 
      ?volume  () =
      { availability_zone; bytes_converted; description; image; volume }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          bytes_converted =
            (Util.option_bind (Xml.member "bytesConverted" xml) Long.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          image =
            (Util.option_bind (Xml.member "image" xml)
               DiskImageDescription.parse);
          volume =
            (Util.option_bind (Xml.member "volume" xml)
               DiskImageVolumeDescription.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f ->
                 Query.Pair
                   ("Volume", (DiskImageVolumeDescription.to_query f)));
           Util.option_map v.image
             (fun f ->
                Query.Pair ("Image", (DiskImageDescription.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.bytes_converted
             (fun f -> Query.Pair ("BytesConverted", (Long.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.availability_zone
                  (fun f ->
                     Ezxmlm.make_tag "availabilityZone"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.bytes_converted
                 (fun f ->
                    Ezxmlm.make_tag "bytesConverted" ([], (Long.to_xml f)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
            @
            [Util.option_map v.image
               (fun f ->
                  Ezxmlm.make_tag "image"
                    ([], (DiskImageDescription.to_xml f)))])
           @
           [Util.option_map v.volume
              (fun f ->
                 Ezxmlm.make_tag "volume"
                   ([], (DiskImageVolumeDescription.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f -> ("volume", (DiskImageVolumeDescription.to_json f)));
           Util.option_map v.image
             (fun f -> ("image", (DiskImageDescription.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.bytes_converted
             (fun f -> ("bytes_converted", (Long.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        bytes_converted =
          (Util.option_map (Json.lookup j "bytes_converted") Long.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        image =
          (Util.option_map (Json.lookup j "image")
             DiskImageDescription.of_json);
        volume =
          (Util.option_map (Json.lookup j "volume")
             DiskImageVolumeDescription.of_json)
      }
  end
module TransitGatewayVpcAttachmentOptions =
  struct
    type t =
      {
      dns_support: DnsSupportValue.t option ;
      ipv6_support: Ipv6SupportValue.t option }
    let make ?dns_support  ?ipv6_support  () = { dns_support; ipv6_support }
    let parse xml =
      Some
        {
          dns_support =
            (Util.option_bind (Xml.member "dnsSupport" xml)
               DnsSupportValue.parse);
          ipv6_support =
            (Util.option_bind (Xml.member "ipv6Support" xml)
               Ipv6SupportValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_support
              (fun f ->
                 Query.Pair ("Ipv6Support", (Ipv6SupportValue.to_query f)));
           Util.option_map v.dns_support
             (fun f ->
                Query.Pair ("DnsSupport", (DnsSupportValue.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dns_support
               (fun f ->
                  Ezxmlm.make_tag "dnsSupport"
                    ([], (DnsSupportValue.to_xml f)))])
           @
           [Util.option_map v.ipv6_support
              (fun f ->
                 Ezxmlm.make_tag "ipv6Support"
                   ([], (Ipv6SupportValue.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_support
              (fun f -> ("ipv6_support", (Ipv6SupportValue.to_json f)));
           Util.option_map v.dns_support
             (fun f -> ("dns_support", (DnsSupportValue.to_json f)))])
    let of_json j =
      {
        dns_support =
          (Util.option_map (Json.lookup j "dns_support")
             DnsSupportValue.of_json);
        ipv6_support =
          (Util.option_map (Json.lookup j "ipv6_support")
             Ipv6SupportValue.of_json)
      }
  end
module ReservationValue =
  struct
    type t =
      {
      hourly_price: String.t option ;
      remaining_total_value: String.t option ;
      remaining_upfront_value: String.t option }
    let make ?hourly_price  ?remaining_total_value  ?remaining_upfront_value 
      () = { hourly_price; remaining_total_value; remaining_upfront_value }
    let parse xml =
      Some
        {
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          remaining_total_value =
            (Util.option_bind (Xml.member "remainingTotalValue" xml)
               String.parse);
          remaining_upfront_value =
            (Util.option_bind (Xml.member "remainingUpfrontValue" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.remaining_upfront_value
              (fun f ->
                 Query.Pair ("RemainingUpfrontValue", (String.to_query f)));
           Util.option_map v.remaining_total_value
             (fun f ->
                Query.Pair ("RemainingTotalValue", (String.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.hourly_price
                (fun f ->
                   Ezxmlm.make_tag "hourlyPrice" ([], (String.to_xml f)))])
            @
            [Util.option_map v.remaining_total_value
               (fun f ->
                  Ezxmlm.make_tag "remainingTotalValue"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.remaining_upfront_value
              (fun f ->
                 Ezxmlm.make_tag "remainingUpfrontValue"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.remaining_upfront_value
              (fun f -> ("remaining_upfront_value", (String.to_json f)));
           Util.option_map v.remaining_total_value
             (fun f -> ("remaining_total_value", (String.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)))])
    let of_json j =
      {
        hourly_price =
          (Util.option_map (Json.lookup j "hourly_price") String.of_json);
        remaining_total_value =
          (Util.option_map (Json.lookup j "remaining_total_value")
             String.of_json);
        remaining_upfront_value =
          (Util.option_map (Json.lookup j "remaining_upfront_value")
             String.of_json)
      }
  end
module TargetConfiguration =
  struct
    type t =
      {
      instance_count: Integer.t option ;
      offering_id: String.t option }
    let make ?instance_count  ?offering_id  () =
      { instance_count; offering_id }
    let parse xml =
      Some
        {
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          offering_id =
            (Util.option_bind (Xml.member "offeringId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.offering_id
              (fun f -> Query.Pair ("OfferingId", (String.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_count
               (fun f ->
                  Ezxmlm.make_tag "instanceCount" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.offering_id
              (fun f -> Ezxmlm.make_tag "offeringId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.offering_id
              (fun f -> ("offering_id", (String.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)))])
    let of_json j =
      {
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        offering_id =
          (Util.option_map (Json.lookup j "offering_id") String.of_json)
      }
  end
module TransitGatewayRouteAttachmentList =
  struct
    type t = TransitGatewayRouteAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayRouteAttachment.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayRouteAttachment.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayRouteAttachment.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayRouteAttachment.to_xml x))) v
    let to_json v = `List (List.map TransitGatewayRouteAttachment.to_json v)
    let of_json j = Json.to_list TransitGatewayRouteAttachment.of_json j
  end
module TransitGatewayRouteState =
  struct
    type t =
      | Pending 
      | Active 
      | Blackhole 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("blackhole", Blackhole);
      ("active", Active);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Blackhole, "blackhole");
      (Active, "active");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TransitGatewayRouteType =
  struct
    type t =
      | Static 
      | Propagated 
    let str_to_t = [("propagated", Propagated); ("static", Static)]
    let t_to_str = [(Propagated, "propagated"); (Static, "static")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EventType =
  struct
    type t =
      | InstanceChange 
      | FleetRequestChange 
      | Error 
      | Information 
    let str_to_t =
      [("information", Information);
      ("error", Error);
      ("fleetRequestChange", FleetRequestChange);
      ("instanceChange", InstanceChange)]
    let t_to_str =
      [(Information, "information");
      (Error, "error");
      (FleetRequestChange, "fleetRequestChange");
      (InstanceChange, "instanceChange")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FpgaImageState =
  struct
    type t = {
      code: FpgaImageStateCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               FpgaImageStateCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (FpgaImageStateCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code" ([], (FpgaImageStateCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (FpgaImageStateCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code") FpgaImageStateCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module PciId =
  struct
    type t =
      {
      device_id: String.t option ;
      vendor_id: String.t option ;
      subsystem_id: String.t option ;
      subsystem_vendor_id: String.t option }
    let make ?device_id  ?vendor_id  ?subsystem_id  ?subsystem_vendor_id  ()
      = { device_id; vendor_id; subsystem_id; subsystem_vendor_id }
    let parse xml =
      Some
        {
          device_id =
            (Util.option_bind (Xml.member "DeviceId" xml) String.parse);
          vendor_id =
            (Util.option_bind (Xml.member "VendorId" xml) String.parse);
          subsystem_id =
            (Util.option_bind (Xml.member "SubsystemId" xml) String.parse);
          subsystem_vendor_id =
            (Util.option_bind (Xml.member "SubsystemVendorId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subsystem_vendor_id
              (fun f -> Query.Pair ("SubsystemVendorId", (String.to_query f)));
           Util.option_map v.subsystem_id
             (fun f -> Query.Pair ("SubsystemId", (String.to_query f)));
           Util.option_map v.vendor_id
             (fun f -> Query.Pair ("VendorId", (String.to_query f)));
           Util.option_map v.device_id
             (fun f -> Query.Pair ("DeviceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.device_id
                 (fun f -> Ezxmlm.make_tag "DeviceId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.vendor_id
                (fun f -> Ezxmlm.make_tag "VendorId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.subsystem_id
               (fun f ->
                  Ezxmlm.make_tag "SubsystemId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.subsystem_vendor_id
              (fun f ->
                 Ezxmlm.make_tag "SubsystemVendorId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subsystem_vendor_id
              (fun f -> ("subsystem_vendor_id", (String.to_json f)));
           Util.option_map v.subsystem_id
             (fun f -> ("subsystem_id", (String.to_json f)));
           Util.option_map v.vendor_id
             (fun f -> ("vendor_id", (String.to_json f)));
           Util.option_map v.device_id
             (fun f -> ("device_id", (String.to_json f)))])
    let of_json j =
      {
        device_id =
          (Util.option_map (Json.lookup j "device_id") String.of_json);
        vendor_id =
          (Util.option_map (Json.lookup j "vendor_id") String.of_json);
        subsystem_id =
          (Util.option_map (Json.lookup j "subsystem_id") String.of_json);
        subsystem_vendor_id =
          (Util.option_map (Json.lookup j "subsystem_vendor_id")
             String.of_json)
      }
  end
module EnableFastSnapshotRestoreStateErrorSet =
  struct
    type t = EnableFastSnapshotRestoreStateErrorItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map EnableFastSnapshotRestoreStateErrorItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list EnableFastSnapshotRestoreStateErrorItem.to_query v
    let to_headers v =
      Headers.to_headers_list
        EnableFastSnapshotRestoreStateErrorItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (EnableFastSnapshotRestoreStateErrorItem.to_xml x))) v
    let to_json v =
      `List (List.map EnableFastSnapshotRestoreStateErrorItem.to_json v)
    let of_json j =
      Json.to_list EnableFastSnapshotRestoreStateErrorItem.of_json j
  end
module PropagatingVgwList =
  struct
    type t = PropagatingVgw.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PropagatingVgw.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PropagatingVgw.to_query v
    let to_headers v = Headers.to_headers_list PropagatingVgw.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PropagatingVgw.to_xml x))) v
    let to_json v = `List (List.map PropagatingVgw.to_json v)
    let of_json j = Json.to_list PropagatingVgw.of_json j
  end
module RouteList =
  struct
    type t = Route.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Route.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Route.to_query v
    let to_headers v = Headers.to_headers_list Route.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Route.to_xml x))) v
    let to_json v = `List (List.map Route.to_json v)
    let of_json j = Json.to_list Route.of_json j
  end
module RouteTableAssociationList =
  struct
    type t = RouteTableAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map RouteTableAssociation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list RouteTableAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list RouteTableAssociation.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (RouteTableAssociation.to_xml x))) v
    let to_json v = `List (List.map RouteTableAssociation.to_json v)
    let of_json j = Json.to_list RouteTableAssociation.of_json j
  end
module IamInstanceProfileAssociationState =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
    let str_to_t =
      [("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ResponseLaunchTemplateData =
  struct
    type t =
      {
      kernel_id: String.t option ;
      ebs_optimized: Boolean.t option ;
      iam_instance_profile:
        LaunchTemplateIamInstanceProfileSpecification.t option ;
      block_device_mappings: LaunchTemplateBlockDeviceMappingList.t ;
      network_interfaces:
        LaunchTemplateInstanceNetworkInterfaceSpecificationList.t ;
      image_id: String.t option ;
      instance_type: InstanceType.t option ;
      key_name: String.t option ;
      monitoring: LaunchTemplatesMonitoring.t option ;
      placement: LaunchTemplatePlacement.t option ;
      ram_disk_id: String.t option ;
      disable_api_termination: Boolean.t option ;
      instance_initiated_shutdown_behavior: ShutdownBehavior.t option ;
      user_data: String.t option ;
      tag_specifications: LaunchTemplateTagSpecificationList.t ;
      elastic_gpu_specifications: ElasticGpuSpecificationResponseList.t ;
      elastic_inference_accelerators:
        LaunchTemplateElasticInferenceAcceleratorResponseList.t ;
      security_group_ids: ValueStringList.t ;
      security_groups: ValueStringList.t ;
      instance_market_options: LaunchTemplateInstanceMarketOptions.t option ;
      credit_specification: CreditSpecification.t option ;
      cpu_options: LaunchTemplateCpuOptions.t option ;
      capacity_reservation_specification:
        LaunchTemplateCapacityReservationSpecificationResponse.t option ;
      license_specifications: LaunchTemplateLicenseList.t ;
      hibernation_options: LaunchTemplateHibernationOptions.t option }
    let make ?kernel_id  ?ebs_optimized  ?iam_instance_profile 
      ?(block_device_mappings= [])  ?(network_interfaces= [])  ?image_id 
      ?instance_type  ?key_name  ?monitoring  ?placement  ?ram_disk_id 
      ?disable_api_termination  ?instance_initiated_shutdown_behavior 
      ?user_data  ?(tag_specifications= [])  ?(elastic_gpu_specifications=
      [])  ?(elastic_inference_accelerators= [])  ?(security_group_ids= []) 
      ?(security_groups= [])  ?instance_market_options  ?credit_specification
       ?cpu_options  ?capacity_reservation_specification 
      ?(license_specifications= [])  ?hibernation_options  () =
      {
        kernel_id;
        ebs_optimized;
        iam_instance_profile;
        block_device_mappings;
        network_interfaces;
        image_id;
        instance_type;
        key_name;
        monitoring;
        placement;
        ram_disk_id;
        disable_api_termination;
        instance_initiated_shutdown_behavior;
        user_data;
        tag_specifications;
        elastic_gpu_specifications;
        elastic_inference_accelerators;
        security_group_ids;
        security_groups;
        instance_market_options;
        credit_specification;
        cpu_options;
        capacity_reservation_specification;
        license_specifications;
        hibernation_options
      }
    let parse xml =
      Some
        {
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               LaunchTemplateIamInstanceProfileSpecification.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMappingSet" xml)
                  LaunchTemplateBlockDeviceMappingList.parse));
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  LaunchTemplateInstanceNetworkInterfaceSpecificationList.parse));
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml)
               LaunchTemplatesMonitoring.parse);
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               LaunchTemplatePlacement.parse);
          ram_disk_id =
            (Util.option_bind (Xml.member "ramDiskId" xml) String.parse);
          disable_api_termination =
            (Util.option_bind (Xml.member "disableApiTermination" xml)
               Boolean.parse);
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               ShutdownBehavior.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSpecificationSet" xml)
                  LaunchTemplateTagSpecificationList.parse));
          elastic_gpu_specifications =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "elasticGpuSpecificationSet" xml)
                  ElasticGpuSpecificationResponseList.parse));
          elastic_inference_accelerators =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "elasticInferenceAcceleratorSet" xml)
                  LaunchTemplateElasticInferenceAcceleratorResponseList.parse));
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupIdSet" xml)
                  ValueStringList.parse));
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupSet" xml)
                  ValueStringList.parse));
          instance_market_options =
            (Util.option_bind (Xml.member "instanceMarketOptions" xml)
               LaunchTemplateInstanceMarketOptions.parse);
          credit_specification =
            (Util.option_bind (Xml.member "creditSpecification" xml)
               CreditSpecification.parse);
          cpu_options =
            (Util.option_bind (Xml.member "cpuOptions" xml)
               LaunchTemplateCpuOptions.parse);
          capacity_reservation_specification =
            (Util.option_bind
               (Xml.member "capacityReservationSpecification" xml)
               LaunchTemplateCapacityReservationSpecificationResponse.parse);
          license_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "licenseSet" xml)
                  LaunchTemplateLicenseList.parse));
          hibernation_options =
            (Util.option_bind (Xml.member "hibernationOptions" xml)
               LaunchTemplateHibernationOptions.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.hibernation_options
              (fun f ->
                 Query.Pair
                   ("HibernationOptions",
                     (LaunchTemplateHibernationOptions.to_query f)));
           Some
             (Query.Pair
                ("LicenseSet",
                  (LaunchTemplateLicenseList.to_query
                     v.license_specifications)));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                Query.Pair
                  ("CapacityReservationSpecification",
                    (LaunchTemplateCapacityReservationSpecificationResponse.to_query
                       f)));
           Util.option_map v.cpu_options
             (fun f ->
                Query.Pair
                  ("CpuOptions", (LaunchTemplateCpuOptions.to_query f)));
           Util.option_map v.credit_specification
             (fun f ->
                Query.Pair
                  ("CreditSpecification", (CreditSpecification.to_query f)));
           Util.option_map v.instance_market_options
             (fun f ->
                Query.Pair
                  ("InstanceMarketOptions",
                    (LaunchTemplateInstanceMarketOptions.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupSet",
                  (ValueStringList.to_query v.security_groups)));
           Some
             (Query.Pair
                ("SecurityGroupIdSet",
                  (ValueStringList.to_query v.security_group_ids)));
           Some
             (Query.Pair
                ("ElasticInferenceAcceleratorSet",
                  (LaunchTemplateElasticInferenceAcceleratorResponseList.to_query
                     v.elastic_inference_accelerators)));
           Some
             (Query.Pair
                ("ElasticGpuSpecificationSet",
                  (ElasticGpuSpecificationResponseList.to_query
                     v.elastic_gpu_specifications)));
           Some
             (Query.Pair
                ("TagSpecificationSet",
                  (LaunchTemplateTagSpecificationList.to_query
                     v.tag_specifications)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (ShutdownBehavior.to_query f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                Query.Pair ("DisableApiTermination", (Boolean.to_query f)));
           Util.option_map v.ram_disk_id
             (fun f -> Query.Pair ("RamDiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f ->
                Query.Pair
                  ("Placement", (LaunchTemplatePlacement.to_query f)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair
                  ("Monitoring", (LaunchTemplatesMonitoring.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (LaunchTemplateInstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Some
             (Query.Pair
                ("BlockDeviceMappingSet",
                  (LaunchTemplateBlockDeviceMappingList.to_query
                     v.block_device_mappings)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (LaunchTemplateIamInstanceProfileSpecification.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((((((((((([] @
                                   [Util.option_map v.kernel_id
                                      (fun f ->
                                         Ezxmlm.make_tag "kernelId"
                                           ([], (String.to_xml f)))])
                                  @
                                  [Util.option_map v.ebs_optimized
                                     (fun f ->
                                        Ezxmlm.make_tag "ebsOptimized"
                                          ([], (Boolean.to_xml f)))])
                                 @
                                 [Util.option_map v.iam_instance_profile
                                    (fun f ->
                                       Ezxmlm.make_tag "iamInstanceProfile"
                                         ([],
                                           (LaunchTemplateIamInstanceProfileSpecification.to_xml
                                              f)))])
                                @
                                (List.map
                                   (fun x ->
                                      Some
                                        (Ezxmlm.make_tag
                                           "blockDeviceMappingSet"
                                           ([],
                                             (LaunchTemplateBlockDeviceMappingList.to_xml
                                                [x]))))
                                   v.block_device_mappings))
                               @
                               (List.map
                                  (fun x ->
                                     Some
                                       (Ezxmlm.make_tag "networkInterfaceSet"
                                          ([],
                                            (LaunchTemplateInstanceNetworkInterfaceSpecificationList.to_xml
                                               [x])))) v.network_interfaces))
                              @
                              [Util.option_map v.image_id
                                 (fun f ->
                                    Ezxmlm.make_tag "imageId"
                                      ([], (String.to_xml f)))])
                             @
                             [Util.option_map v.instance_type
                                (fun f ->
                                   Ezxmlm.make_tag "instanceType"
                                     ([], (InstanceType.to_xml f)))])
                            @
                            [Util.option_map v.key_name
                               (fun f ->
                                  Ezxmlm.make_tag "keyName"
                                    ([], (String.to_xml f)))])
                           @
                           [Util.option_map v.monitoring
                              (fun f ->
                                 Ezxmlm.make_tag "monitoring"
                                   ([], (LaunchTemplatesMonitoring.to_xml f)))])
                          @
                          [Util.option_map v.placement
                             (fun f ->
                                Ezxmlm.make_tag "placement"
                                  ([], (LaunchTemplatePlacement.to_xml f)))])
                         @
                         [Util.option_map v.ram_disk_id
                            (fun f ->
                               Ezxmlm.make_tag "ramDiskId"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.disable_api_termination
                           (fun f ->
                              Ezxmlm.make_tag "disableApiTermination"
                                ([], (Boolean.to_xml f)))])
                       @
                       [Util.option_map
                          v.instance_initiated_shutdown_behavior
                          (fun f ->
                             Ezxmlm.make_tag
                               "instanceInitiatedShutdownBehavior"
                               ([], (ShutdownBehavior.to_xml f)))])
                      @
                      [Util.option_map v.user_data
                         (fun f ->
                            Ezxmlm.make_tag "userData"
                              ([], (String.to_xml f)))])
                     @
                     (List.map
                        (fun x ->
                           Some
                             (Ezxmlm.make_tag "tagSpecificationSet"
                                ([],
                                  (LaunchTemplateTagSpecificationList.to_xml
                                     [x])))) v.tag_specifications))
                    @
                    (List.map
                       (fun x ->
                          Some
                            (Ezxmlm.make_tag "elasticGpuSpecificationSet"
                               ([],
                                 (ElasticGpuSpecificationResponseList.to_xml
                                    [x])))) v.elastic_gpu_specifications))
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "elasticInferenceAcceleratorSet"
                              ([],
                                (LaunchTemplateElasticInferenceAcceleratorResponseList.to_xml
                                   [x])))) v.elastic_inference_accelerators))
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "securityGroupIdSet"
                             ([], (ValueStringList.to_xml [x]))))
                     v.security_group_ids))
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "securityGroupSet"
                            ([], (ValueStringList.to_xml [x]))))
                    v.security_groups))
                @
                [Util.option_map v.instance_market_options
                   (fun f ->
                      Ezxmlm.make_tag "instanceMarketOptions"
                        ([], (LaunchTemplateInstanceMarketOptions.to_xml f)))])
               @
               [Util.option_map v.credit_specification
                  (fun f ->
                     Ezxmlm.make_tag "creditSpecification"
                       ([], (CreditSpecification.to_xml f)))])
              @
              [Util.option_map v.cpu_options
                 (fun f ->
                    Ezxmlm.make_tag "cpuOptions"
                      ([], (LaunchTemplateCpuOptions.to_xml f)))])
             @
             [Util.option_map v.capacity_reservation_specification
                (fun f ->
                   Ezxmlm.make_tag "capacityReservationSpecification"
                     ([],
                       (LaunchTemplateCapacityReservationSpecificationResponse.to_xml
                          f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "licenseSet"
                       ([], (LaunchTemplateLicenseList.to_xml [x]))))
               v.license_specifications))
           @
           [Util.option_map v.hibernation_options
              (fun f ->
                 Ezxmlm.make_tag "hibernationOptions"
                   ([], (LaunchTemplateHibernationOptions.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.hibernation_options
              (fun f ->
                 ("hibernation_options",
                   (LaunchTemplateHibernationOptions.to_json f)));
           Some
             ("license_specifications",
               (LaunchTemplateLicenseList.to_json v.license_specifications));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                ("capacity_reservation_specification",
                  (LaunchTemplateCapacityReservationSpecificationResponse.to_json
                     f)));
           Util.option_map v.cpu_options
             (fun f -> ("cpu_options", (LaunchTemplateCpuOptions.to_json f)));
           Util.option_map v.credit_specification
             (fun f ->
                ("credit_specification", (CreditSpecification.to_json f)));
           Util.option_map v.instance_market_options
             (fun f ->
                ("instance_market_options",
                  (LaunchTemplateInstanceMarketOptions.to_json f)));
           Some
             ("security_groups", (ValueStringList.to_json v.security_groups));
           Some
             ("security_group_ids",
               (ValueStringList.to_json v.security_group_ids));
           Some
             ("elastic_inference_accelerators",
               (LaunchTemplateElasticInferenceAcceleratorResponseList.to_json
                  v.elastic_inference_accelerators));
           Some
             ("elastic_gpu_specifications",
               (ElasticGpuSpecificationResponseList.to_json
                  v.elastic_gpu_specifications));
           Some
             ("tag_specifications",
               (LaunchTemplateTagSpecificationList.to_json
                  v.tag_specifications));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (ShutdownBehavior.to_json f)));
           Util.option_map v.disable_api_termination
             (fun f -> ("disable_api_termination", (Boolean.to_json f)));
           Util.option_map v.ram_disk_id
             (fun f -> ("ram_disk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (LaunchTemplatePlacement.to_json f)));
           Util.option_map v.monitoring
             (fun f -> ("monitoring", (LaunchTemplatesMonitoring.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Some
             ("network_interfaces",
               (LaunchTemplateInstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Some
             ("block_device_mappings",
               (LaunchTemplateBlockDeviceMappingList.to_json
                  v.block_device_mappings));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (LaunchTemplateIamInstanceProfileSpecification.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)))])
    let of_json j =
      {
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             LaunchTemplateIamInstanceProfileSpecification.of_json);
        block_device_mappings =
          (LaunchTemplateBlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        network_interfaces =
          (LaunchTemplateInstanceNetworkInterfaceSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             LaunchTemplatesMonitoring.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement")
             LaunchTemplatePlacement.of_json);
        ram_disk_id =
          (Util.option_map (Json.lookup j "ram_disk_id") String.of_json);
        disable_api_termination =
          (Util.option_map (Json.lookup j "disable_api_termination")
             Boolean.of_json);
        instance_initiated_shutdown_behavior =
          (Util.option_map
             (Json.lookup j "instance_initiated_shutdown_behavior")
             ShutdownBehavior.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json);
        tag_specifications =
          (LaunchTemplateTagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        elastic_gpu_specifications =
          (ElasticGpuSpecificationResponseList.of_json
             (Util.of_option_exn (Json.lookup j "elastic_gpu_specifications")));
        elastic_inference_accelerators =
          (LaunchTemplateElasticInferenceAcceleratorResponseList.of_json
             (Util.of_option_exn
                (Json.lookup j "elastic_inference_accelerators")));
        security_group_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        security_groups =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        instance_market_options =
          (Util.option_map (Json.lookup j "instance_market_options")
             LaunchTemplateInstanceMarketOptions.of_json);
        credit_specification =
          (Util.option_map (Json.lookup j "credit_specification")
             CreditSpecification.of_json);
        cpu_options =
          (Util.option_map (Json.lookup j "cpu_options")
             LaunchTemplateCpuOptions.of_json);
        capacity_reservation_specification =
          (Util.option_map
             (Json.lookup j "capacity_reservation_specification")
             LaunchTemplateCapacityReservationSpecificationResponse.of_json);
        license_specifications =
          (LaunchTemplateLicenseList.of_json
             (Util.of_option_exn (Json.lookup j "license_specifications")));
        hibernation_options =
          (Util.option_map (Json.lookup j "hibernation_options")
             LaunchTemplateHibernationOptions.of_json)
      }
  end
module MembershipType =
  struct
    type t =
      | Static 
      | Igmp 
    let str_to_t = [("igmp", Igmp); ("static", Static)]
    let t_to_str = [(Igmp, "igmp"); (Static, "static")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LocalGatewayVirtualInterfaceIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module MoveStatus =
  struct
    type t =
      | MovingToVpc 
      | RestoringToClassic 
    let str_to_t =
      [("restoringToClassic", RestoringToClassic);
      ("movingToVpc", MovingToVpc)]
    let t_to_str =
      [(RestoringToClassic, "restoringToClassic");
      (MovingToVpc, "movingToVpc")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ElasticGpuSpecification =
  struct
    type t = {
      type_: String.t }
    let make ~type_  () = { type_ }
    let parse xml =
      Some
        {
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Type", (String.to_query v.type_)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @ [Some (Ezxmlm.make_tag "Type" ([], (String.to_xml v.type_)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt [Some ("type_", (String.to_json v.type_))])
    let of_json j =
      { type_ = (String.of_json (Util.of_option_exn (Json.lookup j "type_")))
      }
  end
module LaunchTemplateBlockDeviceMappingRequest =
  struct
    type t =
      {
      device_name: String.t option ;
      virtual_name: String.t option ;
      ebs: LaunchTemplateEbsBlockDeviceRequest.t option ;
      no_device: String.t option }
    let make ?device_name  ?virtual_name  ?ebs  ?no_device  () =
      { device_name; virtual_name; ebs; no_device }
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "DeviceName" xml) String.parse);
          virtual_name =
            (Util.option_bind (Xml.member "VirtualName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "Ebs" xml)
               LaunchTemplateEbsBlockDeviceRequest.parse);
          no_device =
            (Util.option_bind (Xml.member "NoDevice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.ebs
             (fun f ->
                Query.Pair
                  ("Ebs", (LaunchTemplateEbsBlockDeviceRequest.to_query f)));
           Util.option_map v.virtual_name
             (fun f -> Query.Pair ("VirtualName", (String.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.device_name
                 (fun f ->
                    Ezxmlm.make_tag "DeviceName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.virtual_name
                (fun f ->
                   Ezxmlm.make_tag "VirtualName" ([], (String.to_xml f)))])
            @
            [Util.option_map v.ebs
               (fun f ->
                  Ezxmlm.make_tag "Ebs"
                    ([], (LaunchTemplateEbsBlockDeviceRequest.to_xml f)))])
           @
           [Util.option_map v.no_device
              (fun f -> Ezxmlm.make_tag "NoDevice" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.ebs
             (fun f ->
                ("ebs", (LaunchTemplateEbsBlockDeviceRequest.to_json f)));
           Util.option_map v.virtual_name
             (fun f -> ("virtual_name", (String.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let of_json j =
      {
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        virtual_name =
          (Util.option_map (Json.lookup j "virtual_name") String.of_json);
        ebs =
          (Util.option_map (Json.lookup j "ebs")
             LaunchTemplateEbsBlockDeviceRequest.of_json);
        no_device =
          (Util.option_map (Json.lookup j "no_device") String.of_json)
      }
  end
module CapacityReservationTarget =
  struct
    type t = {
      capacity_reservation_id: String.t option }
    let make ?capacity_reservation_id  () = { capacity_reservation_id }
    let parse xml =
      Some
        {
          capacity_reservation_id =
            (Util.option_bind (Xml.member "CapacityReservationId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_id
              (fun f ->
                 Query.Pair ("CapacityReservationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.capacity_reservation_id
              (fun f ->
                 Ezxmlm.make_tag "CapacityReservationId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_id
              (fun f -> ("capacity_reservation_id", (String.to_json f)))])
    let of_json j =
      {
        capacity_reservation_id =
          (Util.option_map (Json.lookup j "capacity_reservation_id")
             String.of_json)
      }
  end
module LaunchTemplateElasticInferenceAccelerator =
  struct
    type t = {
      type_: String.t ;
      count: Integer.t option }
    let make ~type_  ?count  () = { type_; count }
    let parse xml =
      Some
        {
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) String.parse));
          count = (Util.option_bind (Xml.member "Count" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.count
              (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Some (Query.Pair ("Type", (String.to_query v.type_)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Type" ([], (String.to_xml v.type_)))])
           @
           [Util.option_map v.count
              (fun f -> Ezxmlm.make_tag "Count" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Some ("type_", (String.to_json v.type_))])
    let of_json j =
      {
        type_ = (String.of_json (Util.of_option_exn (Json.lookup j "type_")));
        count = (Util.option_map (Json.lookup j "count") Integer.of_json)
      }
  end
module LaunchTemplateSpotMarketOptionsRequest =
  struct
    type t =
      {
      max_price: String.t option ;
      spot_instance_type: SpotInstanceType.t option ;
      block_duration_minutes: Integer.t option ;
      valid_until: DateTime.t option ;
      instance_interruption_behavior: InstanceInterruptionBehavior.t option }
    let make ?max_price  ?spot_instance_type  ?block_duration_minutes 
      ?valid_until  ?instance_interruption_behavior  () =
      {
        max_price;
        spot_instance_type;
        block_duration_minutes;
        valid_until;
        instance_interruption_behavior
      }
    let parse xml =
      Some
        {
          max_price =
            (Util.option_bind (Xml.member "MaxPrice" xml) String.parse);
          spot_instance_type =
            (Util.option_bind (Xml.member "SpotInstanceType" xml)
               SpotInstanceType.parse);
          block_duration_minutes =
            (Util.option_bind (Xml.member "BlockDurationMinutes" xml)
               Integer.parse);
          valid_until =
            (Util.option_bind (Xml.member "ValidUntil" xml) DateTime.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "InstanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Query.Pair
                   ("InstanceInterruptionBehavior",
                     (InstanceInterruptionBehavior.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.block_duration_minutes
             (fun f ->
                Query.Pair ("BlockDurationMinutes", (Integer.to_query f)));
           Util.option_map v.spot_instance_type
             (fun f ->
                Query.Pair
                  ("SpotInstanceType", (SpotInstanceType.to_query f)));
           Util.option_map v.max_price
             (fun f -> Query.Pair ("MaxPrice", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.max_price
                  (fun f ->
                     Ezxmlm.make_tag "MaxPrice" ([], (String.to_xml f)))])
              @
              [Util.option_map v.spot_instance_type
                 (fun f ->
                    Ezxmlm.make_tag "SpotInstanceType"
                      ([], (SpotInstanceType.to_xml f)))])
             @
             [Util.option_map v.block_duration_minutes
                (fun f ->
                   Ezxmlm.make_tag "BlockDurationMinutes"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.valid_until
               (fun f ->
                  Ezxmlm.make_tag "ValidUntil" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Ezxmlm.make_tag "InstanceInterruptionBehavior"
                   ([], (InstanceInterruptionBehavior.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 ("instance_interruption_behavior",
                   (InstanceInterruptionBehavior.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.block_duration_minutes
             (fun f -> ("block_duration_minutes", (Integer.to_json f)));
           Util.option_map v.spot_instance_type
             (fun f -> ("spot_instance_type", (SpotInstanceType.to_json f)));
           Util.option_map v.max_price
             (fun f -> ("max_price", (String.to_json f)))])
    let of_json j =
      {
        max_price =
          (Util.option_map (Json.lookup j "max_price") String.of_json);
        spot_instance_type =
          (Util.option_map (Json.lookup j "spot_instance_type")
             SpotInstanceType.of_json);
        block_duration_minutes =
          (Util.option_map (Json.lookup j "block_duration_minutes")
             Integer.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        instance_interruption_behavior =
          (Util.option_map (Json.lookup j "instance_interruption_behavior")
             InstanceInterruptionBehavior.of_json)
      }
  end
module LaunchTemplateInstanceNetworkInterfaceSpecificationRequest =
  struct
    type t =
      {
      associate_public_ip_address: Boolean.t option ;
      delete_on_termination: Boolean.t option ;
      description: String.t option ;
      device_index: Integer.t option ;
      groups: SecurityGroupIdStringList.t ;
      interface_type: String.t option ;
      ipv6_address_count: Integer.t option ;
      ipv6_addresses: InstanceIpv6AddressListRequest.t ;
      network_interface_id: String.t option ;
      private_ip_address: String.t option ;
      private_ip_addresses: PrivateIpAddressSpecificationList.t ;
      secondary_private_ip_address_count: Integer.t option ;
      subnet_id: String.t option }
    let make ?associate_public_ip_address  ?delete_on_termination 
      ?description  ?device_index  ?(groups= [])  ?interface_type 
      ?ipv6_address_count  ?(ipv6_addresses= [])  ?network_interface_id 
      ?private_ip_address  ?(private_ip_addresses= []) 
      ?secondary_private_ip_address_count  ?subnet_id  () =
      {
        associate_public_ip_address;
        delete_on_termination;
        description;
        device_index;
        groups;
        interface_type;
        ipv6_address_count;
        ipv6_addresses;
        network_interface_id;
        private_ip_address;
        private_ip_addresses;
        secondary_private_ip_address_count;
        subnet_id
      }
    let parse xml =
      Some
        {
          associate_public_ip_address =
            (Util.option_bind (Xml.member "AssociatePublicIpAddress" xml)
               Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "DeleteOnTermination" xml)
               Boolean.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          device_index =
            (Util.option_bind (Xml.member "DeviceIndex" xml) Integer.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          interface_type =
            (Util.option_bind (Xml.member "InterfaceType" xml) String.parse);
          ipv6_address_count =
            (Util.option_bind (Xml.member "Ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "Ipv6Addresses" xml)
                  InstanceIpv6AddressListRequest.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "NetworkInterfaceId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "PrivateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "PrivateIpAddresses" xml)
                  PrivateIpAddressSpecificationList.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "SecondaryPrivateIpAddressCount" xml)
               Integer.parse);
          subnet_id =
            (Util.option_bind (Xml.member "SubnetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddresses",
                  (PrivateIpAddressSpecificationList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6Addresses",
                  (InstanceIpv6AddressListRequest.to_query v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)));
           Util.option_map v.interface_type
             (fun f -> Query.Pair ("InterfaceType", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.groups)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.associate_public_ip_address
             (fun f ->
                Query.Pair ("AssociatePublicIpAddress", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.associate_public_ip_address
                          (fun f ->
                             Ezxmlm.make_tag "AssociatePublicIpAddress"
                               ([], (Boolean.to_xml f)))])
                      @
                      [Util.option_map v.delete_on_termination
                         (fun f ->
                            Ezxmlm.make_tag "DeleteOnTermination"
                              ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.description
                        (fun f ->
                           Ezxmlm.make_tag "Description"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.device_index
                       (fun f ->
                          Ezxmlm.make_tag "DeviceIndex"
                            ([], (Integer.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "SecurityGroupId"
                              ([], (SecurityGroupIdStringList.to_xml [x]))))
                      v.groups))
                  @
                  [Util.option_map v.interface_type
                     (fun f ->
                        Ezxmlm.make_tag "InterfaceType"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.ipv6_address_count
                    (fun f ->
                       Ezxmlm.make_tag "Ipv6AddressCount"
                         ([], (Integer.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "Ipv6Addresses"
                           ([], (InstanceIpv6AddressListRequest.to_xml [x]))))
                   v.ipv6_addresses))
               @
               [Util.option_map v.network_interface_id
                  (fun f ->
                     Ezxmlm.make_tag "NetworkInterfaceId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.private_ip_address
                 (fun f ->
                    Ezxmlm.make_tag "PrivateIpAddress"
                      ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "PrivateIpAddresses"
                        ([], (PrivateIpAddressSpecificationList.to_xml [x]))))
                v.private_ip_addresses))
            @
            [Util.option_map v.secondary_private_ip_address_count
               (fun f ->
                  Ezxmlm.make_tag "SecondaryPrivateIpAddressCount"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.subnet_id
              (fun f -> Ezxmlm.make_tag "SubnetId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_addresses",
               (PrivateIpAddressSpecificationList.to_json
                  v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (InstanceIpv6AddressListRequest.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)));
           Util.option_map v.interface_type
             (fun f -> ("interface_type", (String.to_json f)));
           Some ("groups", (SecurityGroupIdStringList.to_json v.groups));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.associate_public_ip_address
             (fun f -> ("associate_public_ip_address", (Boolean.to_json f)))])
    let of_json j =
      {
        associate_public_ip_address =
          (Util.option_map (Json.lookup j "associate_public_ip_address")
             Boolean.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        device_index =
          (Util.option_map (Json.lookup j "device_index") Integer.of_json);
        groups =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        interface_type =
          (Util.option_map (Json.lookup j "interface_type") String.of_json);
        ipv6_address_count =
          (Util.option_map (Json.lookup j "ipv6_address_count")
             Integer.of_json);
        ipv6_addresses =
          (InstanceIpv6AddressListRequest.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_ip_addresses =
          (PrivateIpAddressSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        secondary_private_ip_address_count =
          (Util.option_map
             (Json.lookup j "secondary_private_ip_address_count")
             Integer.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json)
      }
  end
module LaunchTemplateLicenseConfigurationRequest =
  struct
    type t = {
      license_configuration_arn: String.t option }
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "LicenseConfigurationArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Ezxmlm.make_tag "LicenseConfigurationArn"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let of_json j =
      {
        license_configuration_arn =
          (Util.option_map (Json.lookup j "license_configuration_arn")
             String.of_json)
      }
  end
module LaunchTemplateTagSpecificationRequest =
  struct
    type t = {
      resource_type: ResourceType.t option ;
      tags: TagList.t }
    let make ?resource_type  ?(tags= [])  () = { resource_type; tags }
    let parse xml =
      Some
        {
          resource_type =
            (Util.option_bind (Xml.member "ResourceType" xml)
               ResourceType.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tag" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Tag", (TagList.to_query v.tags)));
           Util.option_map v.resource_type
             (fun f -> Query.Pair ("ResourceType", (ResourceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "ResourceType"
                    ([], (ResourceType.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "Tag" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.resource_type
             (fun f -> ("resource_type", (ResourceType.to_json f)))])
    let of_json j =
      {
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             ResourceType.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ResponseError =
  struct
    type t =
      {
      code: LaunchTemplateErrorCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               LaunchTemplateErrorCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair ("Code", (LaunchTemplateErrorCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (LaunchTemplateErrorCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (LaunchTemplateErrorCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             LaunchTemplateErrorCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module LaunchSpecification =
  struct
    type t =
      {
      user_data: String.t option ;
      security_groups: GroupIdentifierList.t ;
      addressing_type: String.t option ;
      block_device_mappings: BlockDeviceMappingList.t ;
      ebs_optimized: Boolean.t option ;
      iam_instance_profile: IamInstanceProfileSpecification.t option ;
      image_id: String.t option ;
      instance_type: InstanceType.t option ;
      kernel_id: String.t option ;
      key_name: String.t option ;
      network_interfaces: InstanceNetworkInterfaceSpecificationList.t ;
      placement: SpotPlacement.t option ;
      ramdisk_id: String.t option ;
      subnet_id: String.t option ;
      monitoring: RunInstancesMonitoringEnabled.t option }
    let make ?user_data  ?(security_groups= [])  ?addressing_type 
      ?(block_device_mappings= [])  ?ebs_optimized  ?iam_instance_profile 
      ?image_id  ?instance_type  ?kernel_id  ?key_name  ?(network_interfaces=
      [])  ?placement  ?ramdisk_id  ?subnet_id  ?monitoring  () =
      {
        user_data;
        security_groups;
        addressing_type;
        block_device_mappings;
        ebs_optimized;
        iam_instance_profile;
        image_id;
        instance_type;
        kernel_id;
        key_name;
        network_interfaces;
        placement;
        ramdisk_id;
        subnet_id;
        monitoring
      }
    let parse xml =
      Some
        {
          user_data =
            (Util.option_bind (Xml.member "userData" xml) String.parse);
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          addressing_type =
            (Util.option_bind (Xml.member "addressingType" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  InstanceNetworkInterfaceSpecificationList.parse));
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               SpotPlacement.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml)
               RunInstancesMonitoringEnabled.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.monitoring
              (fun f ->
                 Query.Pair
                   ("Monitoring", (RunInstancesMonitoringEnabled.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (SpotPlacement.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (InstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (IamInstanceProfileSpecification.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Util.option_map v.addressing_type
             (fun f -> Query.Pair ("AddressingType", (String.to_query f)));
           Some
             (Query.Pair
                ("GroupSet",
                  (GroupIdentifierList.to_query v.security_groups)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Util.option_map v.user_data
                            (fun f ->
                               Ezxmlm.make_tag "userData"
                                 ([], (String.to_xml f)))])
                        @
                        (List.map
                           (fun x ->
                              Some
                                (Ezxmlm.make_tag "groupSet"
                                   ([], (GroupIdentifierList.to_xml [x]))))
                           v.security_groups))
                       @
                       [Util.option_map v.addressing_type
                          (fun f ->
                             Ezxmlm.make_tag "addressingType"
                               ([], (String.to_xml f)))])
                      @
                      (List.map
                         (fun x ->
                            Some
                              (Ezxmlm.make_tag "blockDeviceMapping"
                                 ([], (BlockDeviceMappingList.to_xml [x]))))
                         v.block_device_mappings))
                     @
                     [Util.option_map v.ebs_optimized
                        (fun f ->
                           Ezxmlm.make_tag "ebsOptimized"
                             ([], (Boolean.to_xml f)))])
                    @
                    [Util.option_map v.iam_instance_profile
                       (fun f ->
                          Ezxmlm.make_tag "iamInstanceProfile"
                            ([], (IamInstanceProfileSpecification.to_xml f)))])
                   @
                   [Util.option_map v.image_id
                      (fun f ->
                         Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.instance_type
                     (fun f ->
                        Ezxmlm.make_tag "instanceType"
                          ([], (InstanceType.to_xml f)))])
                 @
                 [Util.option_map v.kernel_id
                    (fun f ->
                       Ezxmlm.make_tag "kernelId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.key_name
                   (fun f ->
                      Ezxmlm.make_tag "keyName" ([], (String.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "networkInterfaceSet"
                          ([],
                            (InstanceNetworkInterfaceSpecificationList.to_xml
                               [x])))) v.network_interfaces))
              @
              [Util.option_map v.placement
                 (fun f ->
                    Ezxmlm.make_tag "placement"
                      ([], (SpotPlacement.to_xml f)))])
             @
             [Util.option_map v.ramdisk_id
                (fun f -> Ezxmlm.make_tag "ramdiskId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.subnet_id
               (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.monitoring
              (fun f ->
                 Ezxmlm.make_tag "monitoring"
                   ([], (RunInstancesMonitoringEnabled.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.monitoring
              (fun f ->
                 ("monitoring", (RunInstancesMonitoringEnabled.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (SpotPlacement.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (IamInstanceProfileSpecification.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings));
           Util.option_map v.addressing_type
             (fun f -> ("addressing_type", (String.to_json f)));
           Some
             ("security_groups",
               (GroupIdentifierList.to_json v.security_groups));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)))])
    let of_json j =
      {
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json);
        security_groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        addressing_type =
          (Util.option_map (Json.lookup j "addressing_type") String.of_json);
        block_device_mappings =
          (BlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfileSpecification.of_json);
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        network_interfaces =
          (InstanceNetworkInterfaceSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        placement =
          (Util.option_map (Json.lookup j "placement") SpotPlacement.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             RunInstancesMonitoringEnabled.of_json)
      }
  end
module SpotInstanceState =
  struct
    type t =
      | Open 
      | Active 
      | Closed 
      | Cancelled 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("cancelled", Cancelled);
      ("closed", Closed);
      ("active", Active);
      ("open", Open)]
    let t_to_str =
      [(Failed, "failed");
      (Cancelled, "cancelled");
      (Closed, "closed");
      (Active, "active");
      (Open, "open")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SpotInstanceStateFault =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module SpotInstanceStatus =
  struct
    type t =
      {
      code: String.t option ;
      message: String.t option ;
      update_time: DateTime.t option }
    let make ?code  ?message  ?update_time  () =
      { code; message; update_time }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse);
          update_time =
            (Util.option_bind (Xml.member "updateTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.update_time
              (fun f -> Query.Pair ("UpdateTime", (DateTime.to_query f)));
           Util.option_map v.message
             (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.code
                (fun f -> Ezxmlm.make_tag "code" ([], (String.to_xml f)))])
            @
            [Util.option_map v.message
               (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
           @
           [Util.option_map v.update_time
              (fun f ->
                 Ezxmlm.make_tag "updateTime" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.update_time
              (fun f -> ("update_time", (DateTime.to_json f)));
           Util.option_map v.message
             (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json);
        update_time =
          (Util.option_map (Json.lookup j "update_time") DateTime.of_json)
      }
  end
module DeleteQueuedReservedInstancesError =
  struct
    type t =
      {
      code: DeleteQueuedReservedInstancesErrorCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               DeleteQueuedReservedInstancesErrorCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code",
                    (DeleteQueuedReservedInstancesErrorCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (DeleteQueuedReservedInstancesErrorCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code", (DeleteQueuedReservedInstancesErrorCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             DeleteQueuedReservedInstancesErrorCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ExportTaskState =
  struct
    type t =
      | Active 
      | Cancelling 
      | Cancelled 
      | Completed 
    let str_to_t =
      [("completed", Completed);
      ("cancelled", Cancelled);
      ("cancelling", Cancelling);
      ("active", Active)]
    let t_to_str =
      [(Completed, "completed");
      (Cancelled, "cancelled");
      (Cancelling, "cancelling");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ExportToS3Task =
  struct
    type t =
      {
      container_format: ContainerFormat.t option ;
      disk_image_format: DiskImageFormat.t option ;
      s3_bucket: String.t option ;
      s3_key: String.t option }
    let make ?container_format  ?disk_image_format  ?s3_bucket  ?s3_key  () =
      { container_format; disk_image_format; s3_bucket; s3_key }
    let parse xml =
      Some
        {
          container_format =
            (Util.option_bind (Xml.member "containerFormat" xml)
               ContainerFormat.parse);
          disk_image_format =
            (Util.option_bind (Xml.member "diskImageFormat" xml)
               DiskImageFormat.parse);
          s3_bucket =
            (Util.option_bind (Xml.member "s3Bucket" xml) String.parse);
          s3_key = (Util.option_bind (Xml.member "s3Key" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> Query.Pair ("S3Key", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)));
           Util.option_map v.disk_image_format
             (fun f ->
                Query.Pair ("DiskImageFormat", (DiskImageFormat.to_query f)));
           Util.option_map v.container_format
             (fun f ->
                Query.Pair ("ContainerFormat", (ContainerFormat.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.container_format
                 (fun f ->
                    Ezxmlm.make_tag "containerFormat"
                      ([], (ContainerFormat.to_xml f)))])
             @
             [Util.option_map v.disk_image_format
                (fun f ->
                   Ezxmlm.make_tag "diskImageFormat"
                     ([], (DiskImageFormat.to_xml f)))])
            @
            [Util.option_map v.s3_bucket
               (fun f -> Ezxmlm.make_tag "s3Bucket" ([], (String.to_xml f)))])
           @
           [Util.option_map v.s3_key
              (fun f -> Ezxmlm.make_tag "s3Key" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> ("s3_key", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)));
           Util.option_map v.disk_image_format
             (fun f -> ("disk_image_format", (DiskImageFormat.to_json f)));
           Util.option_map v.container_format
             (fun f -> ("container_format", (ContainerFormat.to_json f)))])
    let of_json j =
      {
        container_format =
          (Util.option_map (Json.lookup j "container_format")
             ContainerFormat.of_json);
        disk_image_format =
          (Util.option_map (Json.lookup j "disk_image_format")
             DiskImageFormat.of_json);
        s3_bucket =
          (Util.option_map (Json.lookup j "s3_bucket") String.of_json);
        s3_key = (Util.option_map (Json.lookup j "s3_key") String.of_json)
      }
  end
module InstanceExportDetails =
  struct
    type t =
      {
      instance_id: String.t option ;
      target_environment: ExportEnvironment.t option }
    let make ?instance_id  ?target_environment  () =
      { instance_id; target_environment }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          target_environment =
            (Util.option_bind (Xml.member "targetEnvironment" xml)
               ExportEnvironment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.target_environment
              (fun f ->
                 Query.Pair
                   ("TargetEnvironment", (ExportEnvironment.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.target_environment
              (fun f ->
                 Ezxmlm.make_tag "targetEnvironment"
                   ([], (ExportEnvironment.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_environment
              (fun f -> ("target_environment", (ExportEnvironment.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        target_environment =
          (Util.option_map (Json.lookup j "target_environment")
             ExportEnvironment.of_json)
      }
  end
module IpPermissionList =
  struct
    type t = IpPermission.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map IpPermission.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list IpPermission.to_query v
    let to_headers v = Headers.to_headers_list IpPermission.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (IpPermission.to_xml x))) v
    let to_json v = `List (List.map IpPermission.to_json v)
    let of_json j = Json.to_list IpPermission.of_json j
  end
module AssociatedTargetNetworkSet =
  struct
    type t = AssociatedTargetNetwork.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AssociatedTargetNetwork.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AssociatedTargetNetwork.to_query v
    let to_headers v =
      Headers.to_headers_list AssociatedTargetNetwork.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (AssociatedTargetNetwork.to_xml x)))
        v
    let to_json v = `List (List.map AssociatedTargetNetwork.to_json v)
    let of_json j = Json.to_list AssociatedTargetNetwork.of_json j
  end
module ClientVpnAuthenticationList =
  struct
    type t = ClientVpnAuthentication.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClientVpnAuthentication.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ClientVpnAuthentication.to_query v
    let to_headers v =
      Headers.to_headers_list ClientVpnAuthentication.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ClientVpnAuthentication.to_xml x)))
        v
    let to_json v = `List (List.map ClientVpnAuthentication.to_json v)
    let of_json j = Json.to_list ClientVpnAuthentication.of_json j
  end
module ClientVpnEndpointStatus =
  struct
    type t =
      {
      code: ClientVpnEndpointStatusCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               ClientVpnEndpointStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair ("Code", (ClientVpnEndpointStatusCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (ClientVpnEndpointStatusCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (ClientVpnEndpointStatusCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             ClientVpnEndpointStatusCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ConnectionLogResponseOptions =
  struct
    type t =
      {
      enabled: Boolean.t option ;
      cloudwatch_log_group: String.t option ;
      cloudwatch_log_stream: String.t option }
    let make ?enabled  ?cloudwatch_log_group  ?cloudwatch_log_stream  () =
      { enabled; cloudwatch_log_group; cloudwatch_log_stream }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse);
          cloudwatch_log_group =
            (Util.option_bind (Xml.member "CloudwatchLogGroup" xml)
               String.parse);
          cloudwatch_log_stream =
            (Util.option_bind (Xml.member "CloudwatchLogStream" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cloudwatch_log_stream
              (fun f ->
                 Query.Pair ("CloudwatchLogStream", (String.to_query f)));
           Util.option_map v.cloudwatch_log_group
             (fun f -> Query.Pair ("CloudwatchLogGroup", (String.to_query f)));
           Util.option_map v.enabled
             (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.enabled
                (fun f -> Ezxmlm.make_tag "Enabled" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.cloudwatch_log_group
               (fun f ->
                  Ezxmlm.make_tag "CloudwatchLogGroup"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.cloudwatch_log_stream
              (fun f ->
                 Ezxmlm.make_tag "CloudwatchLogStream"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cloudwatch_log_stream
              (fun f -> ("cloudwatch_log_stream", (String.to_json f)));
           Util.option_map v.cloudwatch_log_group
             (fun f -> ("cloudwatch_log_group", (String.to_json f)));
           Util.option_map v.enabled
             (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      {
        enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json);
        cloudwatch_log_group =
          (Util.option_map (Json.lookup j "cloudwatch_log_group")
             String.of_json);
        cloudwatch_log_stream =
          (Util.option_map (Json.lookup j "cloudwatch_log_stream")
             String.of_json)
      }
  end
module TransportProtocol =
  struct
    type t =
      | Tcp 
      | Udp 
    let str_to_t = [("udp", Udp); ("tcp", Tcp)]
    let t_to_str = [(Udp, "udp"); (Tcp, "tcp")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpnProtocol =
  struct
    type t =
      | Openvpn 
    let str_to_t = [("openvpn", Openvpn)]
    let t_to_str = [(Openvpn, "openvpn")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FleetLaunchTemplateOverridesListRequest =
  struct
    type t = FleetLaunchTemplateOverridesRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map FleetLaunchTemplateOverridesRequest.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list FleetLaunchTemplateOverridesRequest.to_query v
    let to_headers v =
      Headers.to_headers_list FleetLaunchTemplateOverridesRequest.to_headers
        v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (FleetLaunchTemplateOverridesRequest.to_xml x))) v
    let to_json v =
      `List (List.map FleetLaunchTemplateOverridesRequest.to_json v)
    let of_json j =
      Json.to_list FleetLaunchTemplateOverridesRequest.of_json j
  end
module FleetLaunchTemplateSpecificationRequest =
  struct
    type t =
      {
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      version: String.t option }
    let make ?launch_template_id  ?launch_template_name  ?version  () =
      { launch_template_id; launch_template_name; version }
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "LaunchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "LaunchTemplateName" xml)
               String.parse);
          version =
            (Util.option_bind (Xml.member "Version" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> Query.Pair ("Version", (String.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.launch_template_id
                (fun f ->
                   Ezxmlm.make_tag "LaunchTemplateId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.launch_template_name
               (fun f ->
                  Ezxmlm.make_tag "LaunchTemplateName"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.version
              (fun f -> Ezxmlm.make_tag "Version" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> ("version", (String.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let of_json j =
      {
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        version = (Util.option_map (Json.lookup j "version") String.of_json)
      }
  end
module InternetGatewayAttachmentList =
  struct
    type t = InternetGatewayAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InternetGatewayAttachment.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InternetGatewayAttachment.to_query v
    let to_headers v =
      Headers.to_headers_list InternetGatewayAttachment.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InternetGatewayAttachment.to_xml x))) v
    let to_json v = `List (List.map InternetGatewayAttachment.to_json v)
    let of_json j = Json.to_list InternetGatewayAttachment.of_json j
  end
module DescribeFleetsErrorSet =
  struct
    type t = DescribeFleetError.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DescribeFleetError.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DescribeFleetError.to_query v
    let to_headers v =
      Headers.to_headers_list DescribeFleetError.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (DescribeFleetError.to_xml x))) v
    let to_json v = `List (List.map DescribeFleetError.to_json v)
    let of_json j = Json.to_list DescribeFleetError.of_json j
  end
module DescribeFleetsInstancesSet =
  struct
    type t = DescribeFleetsInstances.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DescribeFleetsInstances.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DescribeFleetsInstances.to_query v
    let to_headers v =
      Headers.to_headers_list DescribeFleetsInstances.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (DescribeFleetsInstances.to_xml x)))
        v
    let to_json v = `List (List.map DescribeFleetsInstances.to_json v)
    let of_json j = Json.to_list DescribeFleetsInstances.of_json j
  end
module FleetActivityStatus =
  struct
    type t =
      | Error 
      | Pending_fulfillment 
      | Pending_termination 
      | Fulfilled 
    let str_to_t =
      [("fulfilled", Fulfilled);
      ("pending_termination", Pending_termination);
      ("pending_fulfillment", Pending_fulfillment);
      ("error", Error)]
    let t_to_str =
      [(Fulfilled, "fulfilled");
      (Pending_termination, "pending_termination");
      (Pending_fulfillment, "pending_fulfillment");
      (Error, "error")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FleetExcessCapacityTerminationPolicy =
  struct
    type t =
      | No_termination 
      | Termination 
    let str_to_t =
      [("termination", Termination); ("no-termination", No_termination)]
    let t_to_str =
      [(Termination, "termination"); (No_termination, "no-termination")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FleetLaunchTemplateConfigList =
  struct
    type t = FleetLaunchTemplateConfig.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map FleetLaunchTemplateConfig.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list FleetLaunchTemplateConfig.to_query v
    let to_headers v =
      Headers.to_headers_list FleetLaunchTemplateConfig.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (FleetLaunchTemplateConfig.to_xml x))) v
    let to_json v = `List (List.map FleetLaunchTemplateConfig.to_json v)
    let of_json j = Json.to_list FleetLaunchTemplateConfig.of_json j
  end
module OnDemandOptions =
  struct
    type t =
      {
      allocation_strategy: FleetOnDemandAllocationStrategy.t option ;
      capacity_reservation_options: CapacityReservationOptions.t option ;
      single_instance_type: Boolean.t option ;
      single_availability_zone: Boolean.t option ;
      min_target_capacity: Integer.t option ;
      max_total_price: String.t option }
    let make ?allocation_strategy  ?capacity_reservation_options 
      ?single_instance_type  ?single_availability_zone  ?min_target_capacity 
      ?max_total_price  () =
      {
        allocation_strategy;
        capacity_reservation_options;
        single_instance_type;
        single_availability_zone;
        min_target_capacity;
        max_total_price
      }
    let parse xml =
      Some
        {
          allocation_strategy =
            (Util.option_bind (Xml.member "allocationStrategy" xml)
               FleetOnDemandAllocationStrategy.parse);
          capacity_reservation_options =
            (Util.option_bind (Xml.member "capacityReservationOptions" xml)
               CapacityReservationOptions.parse);
          single_instance_type =
            (Util.option_bind (Xml.member "singleInstanceType" xml)
               Boolean.parse);
          single_availability_zone =
            (Util.option_bind (Xml.member "singleAvailabilityZone" xml)
               Boolean.parse);
          min_target_capacity =
            (Util.option_bind (Xml.member "minTargetCapacity" xml)
               Integer.parse);
          max_total_price =
            (Util.option_bind (Xml.member "maxTotalPrice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> Query.Pair ("MaxTotalPrice", (String.to_query f)));
           Util.option_map v.min_target_capacity
             (fun f -> Query.Pair ("MinTargetCapacity", (Integer.to_query f)));
           Util.option_map v.single_availability_zone
             (fun f ->
                Query.Pair ("SingleAvailabilityZone", (Boolean.to_query f)));
           Util.option_map v.single_instance_type
             (fun f ->
                Query.Pair ("SingleInstanceType", (Boolean.to_query f)));
           Util.option_map v.capacity_reservation_options
             (fun f ->
                Query.Pair
                  ("CapacityReservationOptions",
                    (CapacityReservationOptions.to_query f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                Query.Pair
                  ("AllocationStrategy",
                    (FleetOnDemandAllocationStrategy.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.allocation_strategy
                   (fun f ->
                      Ezxmlm.make_tag "allocationStrategy"
                        ([], (FleetOnDemandAllocationStrategy.to_xml f)))])
               @
               [Util.option_map v.capacity_reservation_options
                  (fun f ->
                     Ezxmlm.make_tag "capacityReservationOptions"
                       ([], (CapacityReservationOptions.to_xml f)))])
              @
              [Util.option_map v.single_instance_type
                 (fun f ->
                    Ezxmlm.make_tag "singleInstanceType"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.single_availability_zone
                (fun f ->
                   Ezxmlm.make_tag "singleAvailabilityZone"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.min_target_capacity
               (fun f ->
                  Ezxmlm.make_tag "minTargetCapacity"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.max_total_price
              (fun f ->
                 Ezxmlm.make_tag "maxTotalPrice" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> ("max_total_price", (String.to_json f)));
           Util.option_map v.min_target_capacity
             (fun f -> ("min_target_capacity", (Integer.to_json f)));
           Util.option_map v.single_availability_zone
             (fun f -> ("single_availability_zone", (Boolean.to_json f)));
           Util.option_map v.single_instance_type
             (fun f -> ("single_instance_type", (Boolean.to_json f)));
           Util.option_map v.capacity_reservation_options
             (fun f ->
                ("capacity_reservation_options",
                  (CapacityReservationOptions.to_json f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                ("allocation_strategy",
                  (FleetOnDemandAllocationStrategy.to_json f)))])
    let of_json j =
      {
        allocation_strategy =
          (Util.option_map (Json.lookup j "allocation_strategy")
             FleetOnDemandAllocationStrategy.of_json);
        capacity_reservation_options =
          (Util.option_map (Json.lookup j "capacity_reservation_options")
             CapacityReservationOptions.of_json);
        single_instance_type =
          (Util.option_map (Json.lookup j "single_instance_type")
             Boolean.of_json);
        single_availability_zone =
          (Util.option_map (Json.lookup j "single_availability_zone")
             Boolean.of_json);
        min_target_capacity =
          (Util.option_map (Json.lookup j "min_target_capacity")
             Integer.of_json);
        max_total_price =
          (Util.option_map (Json.lookup j "max_total_price") String.of_json)
      }
  end
module SpotOptions =
  struct
    type t =
      {
      allocation_strategy: SpotAllocationStrategy.t option ;
      instance_interruption_behavior:
        SpotInstanceInterruptionBehavior.t option ;
      instance_pools_to_use_count: Integer.t option ;
      single_instance_type: Boolean.t option ;
      single_availability_zone: Boolean.t option ;
      min_target_capacity: Integer.t option ;
      max_total_price: String.t option }
    let make ?allocation_strategy  ?instance_interruption_behavior 
      ?instance_pools_to_use_count  ?single_instance_type 
      ?single_availability_zone  ?min_target_capacity  ?max_total_price  () =
      {
        allocation_strategy;
        instance_interruption_behavior;
        instance_pools_to_use_count;
        single_instance_type;
        single_availability_zone;
        min_target_capacity;
        max_total_price
      }
    let parse xml =
      Some
        {
          allocation_strategy =
            (Util.option_bind (Xml.member "allocationStrategy" xml)
               SpotAllocationStrategy.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "instanceInterruptionBehavior" xml)
               SpotInstanceInterruptionBehavior.parse);
          instance_pools_to_use_count =
            (Util.option_bind (Xml.member "instancePoolsToUseCount" xml)
               Integer.parse);
          single_instance_type =
            (Util.option_bind (Xml.member "singleInstanceType" xml)
               Boolean.parse);
          single_availability_zone =
            (Util.option_bind (Xml.member "singleAvailabilityZone" xml)
               Boolean.parse);
          min_target_capacity =
            (Util.option_bind (Xml.member "minTargetCapacity" xml)
               Integer.parse);
          max_total_price =
            (Util.option_bind (Xml.member "maxTotalPrice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> Query.Pair ("MaxTotalPrice", (String.to_query f)));
           Util.option_map v.min_target_capacity
             (fun f -> Query.Pair ("MinTargetCapacity", (Integer.to_query f)));
           Util.option_map v.single_availability_zone
             (fun f ->
                Query.Pair ("SingleAvailabilityZone", (Boolean.to_query f)));
           Util.option_map v.single_instance_type
             (fun f ->
                Query.Pair ("SingleInstanceType", (Boolean.to_query f)));
           Util.option_map v.instance_pools_to_use_count
             (fun f ->
                Query.Pair ("InstancePoolsToUseCount", (Integer.to_query f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInterruptionBehavior",
                    (SpotInstanceInterruptionBehavior.to_query f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                Query.Pair
                  ("AllocationStrategy", (SpotAllocationStrategy.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.allocation_strategy
                    (fun f ->
                       Ezxmlm.make_tag "allocationStrategy"
                         ([], (SpotAllocationStrategy.to_xml f)))])
                @
                [Util.option_map v.instance_interruption_behavior
                   (fun f ->
                      Ezxmlm.make_tag "instanceInterruptionBehavior"
                        ([], (SpotInstanceInterruptionBehavior.to_xml f)))])
               @
               [Util.option_map v.instance_pools_to_use_count
                  (fun f ->
                     Ezxmlm.make_tag "instancePoolsToUseCount"
                       ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.single_instance_type
                 (fun f ->
                    Ezxmlm.make_tag "singleInstanceType"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.single_availability_zone
                (fun f ->
                   Ezxmlm.make_tag "singleAvailabilityZone"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.min_target_capacity
               (fun f ->
                  Ezxmlm.make_tag "minTargetCapacity"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.max_total_price
              (fun f ->
                 Ezxmlm.make_tag "maxTotalPrice" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> ("max_total_price", (String.to_json f)));
           Util.option_map v.min_target_capacity
             (fun f -> ("min_target_capacity", (Integer.to_json f)));
           Util.option_map v.single_availability_zone
             (fun f -> ("single_availability_zone", (Boolean.to_json f)));
           Util.option_map v.single_instance_type
             (fun f -> ("single_instance_type", (Boolean.to_json f)));
           Util.option_map v.instance_pools_to_use_count
             (fun f -> ("instance_pools_to_use_count", (Integer.to_json f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                ("instance_interruption_behavior",
                  (SpotInstanceInterruptionBehavior.to_json f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                ("allocation_strategy", (SpotAllocationStrategy.to_json f)))])
    let of_json j =
      {
        allocation_strategy =
          (Util.option_map (Json.lookup j "allocation_strategy")
             SpotAllocationStrategy.of_json);
        instance_interruption_behavior =
          (Util.option_map (Json.lookup j "instance_interruption_behavior")
             SpotInstanceInterruptionBehavior.of_json);
        instance_pools_to_use_count =
          (Util.option_map (Json.lookup j "instance_pools_to_use_count")
             Integer.of_json);
        single_instance_type =
          (Util.option_map (Json.lookup j "single_instance_type")
             Boolean.of_json);
        single_availability_zone =
          (Util.option_map (Json.lookup j "single_availability_zone")
             Boolean.of_json);
        min_target_capacity =
          (Util.option_map (Json.lookup j "min_target_capacity")
             Integer.of_json);
        max_total_price =
          (Util.option_map (Json.lookup j "max_total_price") String.of_json)
      }
  end
module TargetCapacitySpecification =
  struct
    type t =
      {
      total_target_capacity: Integer.t option ;
      on_demand_target_capacity: Integer.t option ;
      spot_target_capacity: Integer.t option ;
      default_target_capacity_type: DefaultTargetCapacityType.t option }
    let make ?total_target_capacity  ?on_demand_target_capacity 
      ?spot_target_capacity  ?default_target_capacity_type  () =
      {
        total_target_capacity;
        on_demand_target_capacity;
        spot_target_capacity;
        default_target_capacity_type
      }
    let parse xml =
      Some
        {
          total_target_capacity =
            (Util.option_bind (Xml.member "totalTargetCapacity" xml)
               Integer.parse);
          on_demand_target_capacity =
            (Util.option_bind (Xml.member "onDemandTargetCapacity" xml)
               Integer.parse);
          spot_target_capacity =
            (Util.option_bind (Xml.member "spotTargetCapacity" xml)
               Integer.parse);
          default_target_capacity_type =
            (Util.option_bind (Xml.member "defaultTargetCapacityType" xml)
               DefaultTargetCapacityType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.default_target_capacity_type
              (fun f ->
                 Query.Pair
                   ("DefaultTargetCapacityType",
                     (DefaultTargetCapacityType.to_query f)));
           Util.option_map v.spot_target_capacity
             (fun f ->
                Query.Pair ("SpotTargetCapacity", (Integer.to_query f)));
           Util.option_map v.on_demand_target_capacity
             (fun f ->
                Query.Pair ("OnDemandTargetCapacity", (Integer.to_query f)));
           Util.option_map v.total_target_capacity
             (fun f ->
                Query.Pair ("TotalTargetCapacity", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.total_target_capacity
                 (fun f ->
                    Ezxmlm.make_tag "totalTargetCapacity"
                      ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.on_demand_target_capacity
                (fun f ->
                   Ezxmlm.make_tag "onDemandTargetCapacity"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.spot_target_capacity
               (fun f ->
                  Ezxmlm.make_tag "spotTargetCapacity"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.default_target_capacity_type
              (fun f ->
                 Ezxmlm.make_tag "defaultTargetCapacityType"
                   ([], (DefaultTargetCapacityType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.default_target_capacity_type
              (fun f ->
                 ("default_target_capacity_type",
                   (DefaultTargetCapacityType.to_json f)));
           Util.option_map v.spot_target_capacity
             (fun f -> ("spot_target_capacity", (Integer.to_json f)));
           Util.option_map v.on_demand_target_capacity
             (fun f -> ("on_demand_target_capacity", (Integer.to_json f)));
           Util.option_map v.total_target_capacity
             (fun f -> ("total_target_capacity", (Integer.to_json f)))])
    let of_json j =
      {
        total_target_capacity =
          (Util.option_map (Json.lookup j "total_target_capacity")
             Integer.of_json);
        on_demand_target_capacity =
          (Util.option_map (Json.lookup j "on_demand_target_capacity")
             Integer.of_json);
        spot_target_capacity =
          (Util.option_map (Json.lookup j "spot_target_capacity")
             Integer.of_json);
        default_target_capacity_type =
          (Util.option_map (Json.lookup j "default_target_capacity_type")
             DefaultTargetCapacityType.of_json)
      }
  end
module ActivityStatus =
  struct
    type t =
      | Error 
      | Pending_fulfillment 
      | Pending_termination 
      | Fulfilled 
    let str_to_t =
      [("fulfilled", Fulfilled);
      ("pending_termination", Pending_termination);
      ("pending_fulfillment", Pending_fulfillment);
      ("error", Error)]
    let t_to_str =
      [(Fulfilled, "fulfilled");
      (Pending_termination, "pending_termination");
      (Pending_fulfillment, "pending_fulfillment");
      (Error, "error")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SpotFleetRequestConfigData =
  struct
    type t =
      {
      allocation_strategy: AllocationStrategy.t option ;
      on_demand_allocation_strategy: OnDemandAllocationStrategy.t option ;
      client_token: String.t option ;
      excess_capacity_termination_policy:
        ExcessCapacityTerminationPolicy.t option ;
      fulfilled_capacity: Double.t option ;
      on_demand_fulfilled_capacity: Double.t option ;
      iam_fleet_role: String.t ;
      launch_specifications: LaunchSpecsList.t ;
      launch_template_configs: LaunchTemplateConfigList.t ;
      spot_price: String.t option ;
      target_capacity: Integer.t ;
      on_demand_target_capacity: Integer.t option ;
      on_demand_max_total_price: String.t option ;
      spot_max_total_price: String.t option ;
      terminate_instances_with_expiration: Boolean.t option ;
      type_: FleetType.t option ;
      valid_from: DateTime.t option ;
      valid_until: DateTime.t option ;
      replace_unhealthy_instances: Boolean.t option ;
      instance_interruption_behavior: InstanceInterruptionBehavior.t option ;
      load_balancers_config: LoadBalancersConfig.t option ;
      instance_pools_to_use_count: Integer.t option }
    let make ?allocation_strategy  ?on_demand_allocation_strategy 
      ?client_token  ?excess_capacity_termination_policy  ?fulfilled_capacity
       ?on_demand_fulfilled_capacity  ~iam_fleet_role 
      ?(launch_specifications= [])  ?(launch_template_configs= []) 
      ?spot_price  ~target_capacity  ?on_demand_target_capacity 
      ?on_demand_max_total_price  ?spot_max_total_price 
      ?terminate_instances_with_expiration  ?type_  ?valid_from  ?valid_until
       ?replace_unhealthy_instances  ?instance_interruption_behavior 
      ?load_balancers_config  ?instance_pools_to_use_count  () =
      {
        allocation_strategy;
        on_demand_allocation_strategy;
        client_token;
        excess_capacity_termination_policy;
        fulfilled_capacity;
        on_demand_fulfilled_capacity;
        iam_fleet_role;
        launch_specifications;
        launch_template_configs;
        spot_price;
        target_capacity;
        on_demand_target_capacity;
        on_demand_max_total_price;
        spot_max_total_price;
        terminate_instances_with_expiration;
        type_;
        valid_from;
        valid_until;
        replace_unhealthy_instances;
        instance_interruption_behavior;
        load_balancers_config;
        instance_pools_to_use_count
      }
    let parse xml =
      Some
        {
          allocation_strategy =
            (Util.option_bind (Xml.member "allocationStrategy" xml)
               AllocationStrategy.parse);
          on_demand_allocation_strategy =
            (Util.option_bind (Xml.member "onDemandAllocationStrategy" xml)
               OnDemandAllocationStrategy.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          excess_capacity_termination_policy =
            (Util.option_bind
               (Xml.member "excessCapacityTerminationPolicy" xml)
               ExcessCapacityTerminationPolicy.parse);
          fulfilled_capacity =
            (Util.option_bind (Xml.member "fulfilledCapacity" xml)
               Double.parse);
          on_demand_fulfilled_capacity =
            (Util.option_bind (Xml.member "onDemandFulfilledCapacity" xml)
               Double.parse);
          iam_fleet_role =
            (Xml.required "iamFleetRole"
               (Util.option_bind (Xml.member "iamFleetRole" xml) String.parse));
          launch_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchSpecifications" xml)
                  LaunchSpecsList.parse));
          launch_template_configs =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchTemplateConfigs" xml)
                  LaunchTemplateConfigList.parse));
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          target_capacity =
            (Xml.required "targetCapacity"
               (Util.option_bind (Xml.member "targetCapacity" xml)
                  Integer.parse));
          on_demand_target_capacity =
            (Util.option_bind (Xml.member "onDemandTargetCapacity" xml)
               Integer.parse);
          on_demand_max_total_price =
            (Util.option_bind (Xml.member "onDemandMaxTotalPrice" xml)
               String.parse);
          spot_max_total_price =
            (Util.option_bind (Xml.member "spotMaxTotalPrice" xml)
               String.parse);
          terminate_instances_with_expiration =
            (Util.option_bind
               (Xml.member "terminateInstancesWithExpiration" xml)
               Boolean.parse);
          type_ = (Util.option_bind (Xml.member "type" xml) FleetType.parse);
          valid_from =
            (Util.option_bind (Xml.member "validFrom" xml) DateTime.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          replace_unhealthy_instances =
            (Util.option_bind (Xml.member "replaceUnhealthyInstances" xml)
               Boolean.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "instanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse);
          load_balancers_config =
            (Util.option_bind (Xml.member "loadBalancersConfig" xml)
               LoadBalancersConfig.parse);
          instance_pools_to_use_count =
            (Util.option_bind (Xml.member "instancePoolsToUseCount" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_pools_to_use_count
              (fun f ->
                 Query.Pair ("InstancePoolsToUseCount", (Integer.to_query f)));
           Util.option_map v.load_balancers_config
             (fun f ->
                Query.Pair
                  ("LoadBalancersConfig", (LoadBalancersConfig.to_query f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInterruptionBehavior",
                    (InstanceInterruptionBehavior.to_query f)));
           Util.option_map v.replace_unhealthy_instances
             (fun f ->
                Query.Pair
                  ("ReplaceUnhealthyInstances", (Boolean.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.valid_from
             (fun f -> Query.Pair ("ValidFrom", (DateTime.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (FleetType.to_query f)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                Query.Pair
                  ("TerminateInstancesWithExpiration", (Boolean.to_query f)));
           Util.option_map v.spot_max_total_price
             (fun f -> Query.Pair ("SpotMaxTotalPrice", (String.to_query f)));
           Util.option_map v.on_demand_max_total_price
             (fun f ->
                Query.Pair ("OnDemandMaxTotalPrice", (String.to_query f)));
           Util.option_map v.on_demand_target_capacity
             (fun f ->
                Query.Pair ("OnDemandTargetCapacity", (Integer.to_query f)));
           Some
             (Query.Pair
                ("TargetCapacity", (Integer.to_query v.target_capacity)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Some
             (Query.Pair
                ("LaunchTemplateConfigs",
                  (LaunchTemplateConfigList.to_query
                     v.launch_template_configs)));
           Some
             (Query.Pair
                ("LaunchSpecifications",
                  (LaunchSpecsList.to_query v.launch_specifications)));
           Some
             (Query.Pair ("IamFleetRole", (String.to_query v.iam_fleet_role)));
           Util.option_map v.on_demand_fulfilled_capacity
             (fun f ->
                Query.Pair ("OnDemandFulfilledCapacity", (Double.to_query f)));
           Util.option_map v.fulfilled_capacity
             (fun f -> Query.Pair ("FulfilledCapacity", (Double.to_query f)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                Query.Pair
                  ("ExcessCapacityTerminationPolicy",
                    (ExcessCapacityTerminationPolicy.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.on_demand_allocation_strategy
             (fun f ->
                Query.Pair
                  ("OnDemandAllocationStrategy",
                    (OnDemandAllocationStrategy.to_query f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                Query.Pair
                  ("AllocationStrategy", (AllocationStrategy.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((((((([] @
                                [Util.option_map v.allocation_strategy
                                   (fun f ->
                                      Ezxmlm.make_tag "allocationStrategy"
                                        ([], (AllocationStrategy.to_xml f)))])
                               @
                               [Util.option_map
                                  v.on_demand_allocation_strategy
                                  (fun f ->
                                     Ezxmlm.make_tag
                                       "onDemandAllocationStrategy"
                                       ([],
                                         (OnDemandAllocationStrategy.to_xml f)))])
                              @
                              [Util.option_map v.client_token
                                 (fun f ->
                                    Ezxmlm.make_tag "clientToken"
                                      ([], (String.to_xml f)))])
                             @
                             [Util.option_map
                                v.excess_capacity_termination_policy
                                (fun f ->
                                   Ezxmlm.make_tag
                                     "excessCapacityTerminationPolicy"
                                     ([],
                                       (ExcessCapacityTerminationPolicy.to_xml
                                          f)))])
                            @
                            [Util.option_map v.fulfilled_capacity
                               (fun f ->
                                  Ezxmlm.make_tag "fulfilledCapacity"
                                    ([], (Double.to_xml f)))])
                           @
                           [Util.option_map v.on_demand_fulfilled_capacity
                              (fun f ->
                                 Ezxmlm.make_tag "onDemandFulfilledCapacity"
                                   ([], (Double.to_xml f)))])
                          @
                          [Some
                             (Ezxmlm.make_tag "iamFleetRole"
                                ([], (String.to_xml v.iam_fleet_role)))])
                         @
                         (List.map
                            (fun x ->
                               Some
                                 (Ezxmlm.make_tag "launchSpecifications"
                                    ([], (LaunchSpecsList.to_xml [x]))))
                            v.launch_specifications))
                        @
                        (List.map
                           (fun x ->
                              Some
                                (Ezxmlm.make_tag "launchTemplateConfigs"
                                   ([],
                                     (LaunchTemplateConfigList.to_xml [x]))))
                           v.launch_template_configs))
                       @
                       [Util.option_map v.spot_price
                          (fun f ->
                             Ezxmlm.make_tag "spotPrice"
                               ([], (String.to_xml f)))])
                      @
                      [Some
                         (Ezxmlm.make_tag "targetCapacity"
                            ([], (Integer.to_xml v.target_capacity)))])
                     @
                     [Util.option_map v.on_demand_target_capacity
                        (fun f ->
                           Ezxmlm.make_tag "onDemandTargetCapacity"
                             ([], (Integer.to_xml f)))])
                    @
                    [Util.option_map v.on_demand_max_total_price
                       (fun f ->
                          Ezxmlm.make_tag "onDemandMaxTotalPrice"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.spot_max_total_price
                      (fun f ->
                         Ezxmlm.make_tag "spotMaxTotalPrice"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.terminate_instances_with_expiration
                     (fun f ->
                        Ezxmlm.make_tag "terminateInstancesWithExpiration"
                          ([], (Boolean.to_xml f)))])
                 @
                 [Util.option_map v.type_
                    (fun f ->
                       Ezxmlm.make_tag "type" ([], (FleetType.to_xml f)))])
                @
                [Util.option_map v.valid_from
                   (fun f ->
                      Ezxmlm.make_tag "validFrom" ([], (DateTime.to_xml f)))])
               @
               [Util.option_map v.valid_until
                  (fun f ->
                     Ezxmlm.make_tag "validUntil" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.replace_unhealthy_instances
                 (fun f ->
                    Ezxmlm.make_tag "replaceUnhealthyInstances"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.instance_interruption_behavior
                (fun f ->
                   Ezxmlm.make_tag "instanceInterruptionBehavior"
                     ([], (InstanceInterruptionBehavior.to_xml f)))])
            @
            [Util.option_map v.load_balancers_config
               (fun f ->
                  Ezxmlm.make_tag "loadBalancersConfig"
                    ([], (LoadBalancersConfig.to_xml f)))])
           @
           [Util.option_map v.instance_pools_to_use_count
              (fun f ->
                 Ezxmlm.make_tag "instancePoolsToUseCount"
                   ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_pools_to_use_count
              (fun f -> ("instance_pools_to_use_count", (Integer.to_json f)));
           Util.option_map v.load_balancers_config
             (fun f ->
                ("load_balancers_config", (LoadBalancersConfig.to_json f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                ("instance_interruption_behavior",
                  (InstanceInterruptionBehavior.to_json f)));
           Util.option_map v.replace_unhealthy_instances
             (fun f -> ("replace_unhealthy_instances", (Boolean.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.valid_from
             (fun f -> ("valid_from", (DateTime.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (FleetType.to_json f)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                ("terminate_instances_with_expiration", (Boolean.to_json f)));
           Util.option_map v.spot_max_total_price
             (fun f -> ("spot_max_total_price", (String.to_json f)));
           Util.option_map v.on_demand_max_total_price
             (fun f -> ("on_demand_max_total_price", (String.to_json f)));
           Util.option_map v.on_demand_target_capacity
             (fun f -> ("on_demand_target_capacity", (Integer.to_json f)));
           Some ("target_capacity", (Integer.to_json v.target_capacity));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Some
             ("launch_template_configs",
               (LaunchTemplateConfigList.to_json v.launch_template_configs));
           Some
             ("launch_specifications",
               (LaunchSpecsList.to_json v.launch_specifications));
           Some ("iam_fleet_role", (String.to_json v.iam_fleet_role));
           Util.option_map v.on_demand_fulfilled_capacity
             (fun f -> ("on_demand_fulfilled_capacity", (Double.to_json f)));
           Util.option_map v.fulfilled_capacity
             (fun f -> ("fulfilled_capacity", (Double.to_json f)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                ("excess_capacity_termination_policy",
                  (ExcessCapacityTerminationPolicy.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.on_demand_allocation_strategy
             (fun f ->
                ("on_demand_allocation_strategy",
                  (OnDemandAllocationStrategy.to_json f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                ("allocation_strategy", (AllocationStrategy.to_json f)))])
    let of_json j =
      {
        allocation_strategy =
          (Util.option_map (Json.lookup j "allocation_strategy")
             AllocationStrategy.of_json);
        on_demand_allocation_strategy =
          (Util.option_map (Json.lookup j "on_demand_allocation_strategy")
             OnDemandAllocationStrategy.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        excess_capacity_termination_policy =
          (Util.option_map
             (Json.lookup j "excess_capacity_termination_policy")
             ExcessCapacityTerminationPolicy.of_json);
        fulfilled_capacity =
          (Util.option_map (Json.lookup j "fulfilled_capacity")
             Double.of_json);
        on_demand_fulfilled_capacity =
          (Util.option_map (Json.lookup j "on_demand_fulfilled_capacity")
             Double.of_json);
        iam_fleet_role =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "iam_fleet_role")));
        launch_specifications =
          (LaunchSpecsList.of_json
             (Util.of_option_exn (Json.lookup j "launch_specifications")));
        launch_template_configs =
          (LaunchTemplateConfigList.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_configs")));
        spot_price =
          (Util.option_map (Json.lookup j "spot_price") String.of_json);
        target_capacity =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "target_capacity")));
        on_demand_target_capacity =
          (Util.option_map (Json.lookup j "on_demand_target_capacity")
             Integer.of_json);
        on_demand_max_total_price =
          (Util.option_map (Json.lookup j "on_demand_max_total_price")
             String.of_json);
        spot_max_total_price =
          (Util.option_map (Json.lookup j "spot_max_total_price")
             String.of_json);
        terminate_instances_with_expiration =
          (Util.option_map
             (Json.lookup j "terminate_instances_with_expiration")
             Boolean.of_json);
        type_ = (Util.option_map (Json.lookup j "type_") FleetType.of_json);
        valid_from =
          (Util.option_map (Json.lookup j "valid_from") DateTime.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        replace_unhealthy_instances =
          (Util.option_map (Json.lookup j "replace_unhealthy_instances")
             Boolean.of_json);
        instance_interruption_behavior =
          (Util.option_map (Json.lookup j "instance_interruption_behavior")
             InstanceInterruptionBehavior.of_json);
        load_balancers_config =
          (Util.option_map (Json.lookup j "load_balancers_config")
             LoadBalancersConfig.of_json);
        instance_pools_to_use_count =
          (Util.option_map (Json.lookup j "instance_pools_to_use_count")
             Integer.of_json)
      }
  end
module AvailabilityZoneMessageList =
  struct
    type t = AvailabilityZoneMessage.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AvailabilityZoneMessage.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AvailabilityZoneMessage.to_query v
    let to_headers v =
      Headers.to_headers_list AvailabilityZoneMessage.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (AvailabilityZoneMessage.to_xml x)))
        v
    let to_json v = `List (List.map AvailabilityZoneMessage.to_json v)
    let of_json j = Json.to_list AvailabilityZoneMessage.of_json j
  end
module AvailabilityZoneOptInStatus =
  struct
    type t =
      | Opt_in_not_required 
      | Opted_in 
      | Not_opted_in 
    let str_to_t =
      [("not-opted-in", Not_opted_in);
      ("opted-in", Opted_in);
      ("opt-in-not-required", Opt_in_not_required)]
    let t_to_str =
      [(Not_opted_in, "not-opted-in");
      (Opted_in, "opted-in");
      (Opt_in_not_required, "opt-in-not-required")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AvailabilityZoneState =
  struct
    type t =
      | Available 
      | Information 
      | Impaired 
      | Unavailable 
    let str_to_t =
      [("unavailable", Unavailable);
      ("impaired", Impaired);
      ("information", Information);
      ("available", Available)]
    let t_to_str =
      [(Unavailable, "unavailable");
      (Impaired, "impaired");
      (Information, "information");
      (Available, "available")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VolumeStatusActionsList =
  struct
    type t = VolumeStatusAction.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeStatusAction.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeStatusAction.to_query v
    let to_headers v =
      Headers.to_headers_list VolumeStatusAction.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (VolumeStatusAction.to_xml x))) v
    let to_json v = `List (List.map VolumeStatusAction.to_json v)
    let of_json j = Json.to_list VolumeStatusAction.of_json j
  end
module VolumeStatusEventsList =
  struct
    type t = VolumeStatusEvent.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeStatusEvent.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeStatusEvent.to_query v
    let to_headers v = Headers.to_headers_list VolumeStatusEvent.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VolumeStatusEvent.to_xml x)))
        v
    let to_json v = `List (List.map VolumeStatusEvent.to_json v)
    let of_json j = Json.to_list VolumeStatusEvent.of_json j
  end
module VolumeStatusInfo =
  struct
    type t =
      {
      details: VolumeStatusDetailsList.t ;
      status: VolumeStatusInfoStatus.t option }
    let make ?(details= [])  ?status  () = { details; status }
    let parse xml =
      Some
        {
          details =
            (Util.of_option []
               (Util.option_bind (Xml.member "details" xml)
                  VolumeStatusDetailsList.parse));
          status =
            (Util.option_bind (Xml.member "status" xml)
               VolumeStatusInfoStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair ("Status", (VolumeStatusInfoStatus.to_query f)));
           Some
             (Query.Pair
                ("Details", (VolumeStatusDetailsList.to_query v.details)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "details"
                       ([], (VolumeStatusDetailsList.to_xml [x])))) v.details))
           @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status"
                   ([], (VolumeStatusInfoStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (VolumeStatusInfoStatus.to_json f)));
           Some ("details", (VolumeStatusDetailsList.to_json v.details))])
    let of_json j =
      {
        details =
          (VolumeStatusDetailsList.of_json
             (Util.of_option_exn (Json.lookup j "details")));
        status =
          (Util.option_map (Json.lookup j "status")
             VolumeStatusInfoStatus.of_json)
      }
  end
module TransitGatewayRouteTableState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ClientVpnAuthorizationRuleStatus =
  struct
    type t =
      {
      code: ClientVpnAuthorizationRuleStatusCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               ClientVpnAuthorizationRuleStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code", (ClientVpnAuthorizationRuleStatusCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([], (ClientVpnAuthorizationRuleStatusCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code", (ClientVpnAuthorizationRuleStatusCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             ClientVpnAuthorizationRuleStatusCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module UnsuccessfulInstanceCreditSpecificationItemError =
  struct
    type t =
      {
      code: UnsuccessfulInstanceCreditSpecificationErrorCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               UnsuccessfulInstanceCreditSpecificationErrorCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code",
                    (UnsuccessfulInstanceCreditSpecificationErrorCode.to_query
                       f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([],
                      (UnsuccessfulInstanceCreditSpecificationErrorCode.to_xml
                         f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code",
                  (UnsuccessfulInstanceCreditSpecificationErrorCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             UnsuccessfulInstanceCreditSpecificationErrorCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module PricingDetailsList =
  struct
    type t = PricingDetail.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map PricingDetail.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PricingDetail.to_query v
    let to_headers v = Headers.to_headers_list PricingDetail.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PricingDetail.to_xml x))) v
    let to_json v = `List (List.map PricingDetail.to_json v)
    let of_json j = Json.to_list PricingDetail.of_json j
  end
module InstanceList =
  struct
    type t = Instance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Instance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Instance.to_query v
    let to_headers v = Headers.to_headers_list Instance.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Instance.to_xml x)))
        v
    let to_json v = `List (List.map Instance.to_json v)
    let of_json j = Json.to_list Instance.of_json j
  end
module PublicIpv4PoolRangeSet =
  struct
    type t = PublicIpv4PoolRange.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PublicIpv4PoolRange.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PublicIpv4PoolRange.to_query v
    let to_headers v =
      Headers.to_headers_list PublicIpv4PoolRange.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (PublicIpv4PoolRange.to_xml x))) v
    let to_json v = `List (List.map PublicIpv4PoolRange.to_json v)
    let of_json j = Json.to_list PublicIpv4PoolRange.of_json j
  end
module VpcCidrBlockAssociationSet =
  struct
    type t = VpcCidrBlockAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpcCidrBlockAssociation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpcCidrBlockAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list VpcCidrBlockAssociation.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (VpcCidrBlockAssociation.to_xml x)))
        v
    let to_json v = `List (List.map VpcCidrBlockAssociation.to_json v)
    let of_json j = Json.to_list VpcCidrBlockAssociation.of_json j
  end
module VpcIpv6CidrBlockAssociationSet =
  struct
    type t = VpcIpv6CidrBlockAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpcIpv6CidrBlockAssociation.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list VpcIpv6CidrBlockAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list VpcIpv6CidrBlockAssociation.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (VpcIpv6CidrBlockAssociation.to_xml x))) v
    let to_json v = `List (List.map VpcIpv6CidrBlockAssociation.to_json v)
    let of_json j = Json.to_list VpcIpv6CidrBlockAssociation.of_json j
  end
module VpcState =
  struct
    type t =
      | Pending 
      | Available 
    let str_to_t = [("available", Available); ("pending", Pending)]
    let t_to_str = [(Available, "available"); (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SubnetIpv6CidrBlockAssociationSet =
  struct
    type t = SubnetIpv6CidrBlockAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SubnetIpv6CidrBlockAssociation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list SubnetIpv6CidrBlockAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list SubnetIpv6CidrBlockAssociation.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (SubnetIpv6CidrBlockAssociation.to_xml x))) v
    let to_json v = `List (List.map SubnetIpv6CidrBlockAssociation.to_json v)
    let of_json j = Json.to_list SubnetIpv6CidrBlockAssociation.of_json j
  end
module SubnetState =
  struct
    type t =
      | Pending 
      | Available 
    let str_to_t = [("available", Available); ("pending", Pending)]
    let t_to_str = [(Available, "available"); (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ElasticGpuHealth =
  struct
    type t = {
      status: ElasticGpuStatus.t option }
    let make ?status  () = { status }
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ElasticGpuStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (ElasticGpuStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status" ([], (ElasticGpuStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (ElasticGpuStatus.to_json f)))])
    let of_json j =
      {
        status =
          (Util.option_map (Json.lookup j "status") ElasticGpuStatus.of_json)
      }
  end
module ElasticGpuState =
  struct
    type t =
      | ATTACHED 
    let str_to_t = [("ATTACHED", ATTACHED)]
    let t_to_str = [(ATTACHED, "ATTACHED")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ImportImageLicenseSpecificationListResponse =
  struct
    type t = ImportImageLicenseConfigurationResponse.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ImportImageLicenseConfigurationResponse.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ImportImageLicenseConfigurationResponse.to_query v
    let to_headers v =
      Headers.to_headers_list
        ImportImageLicenseConfigurationResponse.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ImportImageLicenseConfigurationResponse.to_xml x))) v
    let to_json v =
      `List (List.map ImportImageLicenseConfigurationResponse.to_json v)
    let of_json j =
      Json.to_list ImportImageLicenseConfigurationResponse.of_json j
  end
module SnapshotDetailList =
  struct
    type t = SnapshotDetail.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SnapshotDetail.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SnapshotDetail.to_query v
    let to_headers v = Headers.to_headers_list SnapshotDetail.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (SnapshotDetail.to_xml x))) v
    let to_json v = `List (List.map SnapshotDetail.to_json v)
    let of_json j = Json.to_list SnapshotDetail.of_json j
  end
module UserBucket =
  struct
    type t = {
      s3_bucket: String.t option ;
      s3_key: String.t option }
    let make ?s3_bucket  ?s3_key  () = { s3_bucket; s3_key }
    let parse xml =
      Some
        {
          s3_bucket =
            (Util.option_bind (Xml.member "S3Bucket" xml) String.parse);
          s3_key = (Util.option_bind (Xml.member "S3Key" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> Query.Pair ("S3Key", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.s3_bucket
               (fun f -> Ezxmlm.make_tag "S3Bucket" ([], (String.to_xml f)))])
           @
           [Util.option_map v.s3_key
              (fun f -> Ezxmlm.make_tag "S3Key" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> ("s3_key", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)))])
    let of_json j =
      {
        s3_bucket =
          (Util.option_map (Json.lookup j "s3_bucket") String.of_json);
        s3_key = (Util.option_map (Json.lookup j "s3_key") String.of_json)
      }
  end
module LocalGatewayRouteState =
  struct
    type t =
      | Pending 
      | Active 
      | Blackhole 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("blackhole", Blackhole);
      ("active", Active);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Blackhole, "blackhole");
      (Active, "active");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LocalGatewayRouteType =
  struct
    type t =
      | Static 
      | Propagated 
    let str_to_t = [("propagated", Propagated); ("static", Static)]
    let t_to_str = [(Propagated, "propagated"); (Static, "static")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ScheduledInstancesBlockDeviceMapping =
  struct
    type t =
      {
      device_name: String.t option ;
      ebs: ScheduledInstancesEbs.t option ;
      no_device: String.t option ;
      virtual_name: String.t option }
    let make ?device_name  ?ebs  ?no_device  ?virtual_name  () =
      { device_name; ebs; no_device; virtual_name }
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "DeviceName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "Ebs" xml)
               ScheduledInstancesEbs.parse);
          no_device =
            (Util.option_bind (Xml.member "NoDevice" xml) String.parse);
          virtual_name =
            (Util.option_bind (Xml.member "VirtualName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.virtual_name
              (fun f -> Query.Pair ("VirtualName", (String.to_query f)));
           Util.option_map v.no_device
             (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.ebs
             (fun f -> Query.Pair ("Ebs", (ScheduledInstancesEbs.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.device_name
                 (fun f ->
                    Ezxmlm.make_tag "DeviceName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.ebs
                (fun f ->
                   Ezxmlm.make_tag "Ebs"
                     ([], (ScheduledInstancesEbs.to_xml f)))])
            @
            [Util.option_map v.no_device
               (fun f -> Ezxmlm.make_tag "NoDevice" ([], (String.to_xml f)))])
           @
           [Util.option_map v.virtual_name
              (fun f -> Ezxmlm.make_tag "VirtualName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.virtual_name
              (fun f -> ("virtual_name", (String.to_json f)));
           Util.option_map v.no_device
             (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.ebs
             (fun f -> ("ebs", (ScheduledInstancesEbs.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let of_json j =
      {
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        ebs =
          (Util.option_map (Json.lookup j "ebs")
             ScheduledInstancesEbs.of_json);
        no_device =
          (Util.option_map (Json.lookup j "no_device") String.of_json);
        virtual_name =
          (Util.option_map (Json.lookup j "virtual_name") String.of_json)
      }
  end
module ScheduledInstancesNetworkInterface =
  struct
    type t =
      {
      associate_public_ip_address: Boolean.t option ;
      delete_on_termination: Boolean.t option ;
      description: String.t option ;
      device_index: Integer.t option ;
      groups: ScheduledInstancesSecurityGroupIdSet.t ;
      ipv6_address_count: Integer.t option ;
      ipv6_addresses: ScheduledInstancesIpv6AddressList.t ;
      network_interface_id: String.t option ;
      private_ip_address: String.t option ;
      private_ip_address_configs: PrivateIpAddressConfigSet.t ;
      secondary_private_ip_address_count: Integer.t option ;
      subnet_id: String.t option }
    let make ?associate_public_ip_address  ?delete_on_termination 
      ?description  ?device_index  ?(groups= [])  ?ipv6_address_count 
      ?(ipv6_addresses= [])  ?network_interface_id  ?private_ip_address 
      ?(private_ip_address_configs= [])  ?secondary_private_ip_address_count 
      ?subnet_id  () =
      {
        associate_public_ip_address;
        delete_on_termination;
        description;
        device_index;
        groups;
        ipv6_address_count;
        ipv6_addresses;
        network_interface_id;
        private_ip_address;
        private_ip_address_configs;
        secondary_private_ip_address_count;
        subnet_id
      }
    let parse xml =
      Some
        {
          associate_public_ip_address =
            (Util.option_bind (Xml.member "AssociatePublicIpAddress" xml)
               Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "DeleteOnTermination" xml)
               Boolean.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          device_index =
            (Util.option_bind (Xml.member "DeviceIndex" xml) Integer.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "Group" xml)
                  ScheduledInstancesSecurityGroupIdSet.parse));
          ipv6_address_count =
            (Util.option_bind (Xml.member "Ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "Ipv6Address" xml)
                  ScheduledInstancesIpv6AddressList.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "NetworkInterfaceId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "PrivateIpAddress" xml)
               String.parse);
          private_ip_address_configs =
            (Util.of_option []
               (Util.option_bind (Xml.member "PrivateIpAddressConfig" xml)
                  PrivateIpAddressConfigSet.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "SecondaryPrivateIpAddressCount" xml)
               Integer.parse);
          subnet_id =
            (Util.option_bind (Xml.member "SubnetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddressConfig",
                  (PrivateIpAddressConfigSet.to_query
                     v.private_ip_address_configs)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6Address",
                  (ScheduledInstancesIpv6AddressList.to_query
                     v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("Group",
                  (ScheduledInstancesSecurityGroupIdSet.to_query v.groups)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.associate_public_ip_address
             (fun f ->
                Query.Pair ("AssociatePublicIpAddress", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Util.option_map v.associate_public_ip_address
                         (fun f ->
                            Ezxmlm.make_tag "AssociatePublicIpAddress"
                              ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.delete_on_termination
                        (fun f ->
                           Ezxmlm.make_tag "DeleteOnTermination"
                             ([], (Boolean.to_xml f)))])
                    @
                    [Util.option_map v.description
                       (fun f ->
                          Ezxmlm.make_tag "Description"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.device_index
                      (fun f ->
                         Ezxmlm.make_tag "DeviceIndex"
                           ([], (Integer.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "Group"
                             ([],
                               (ScheduledInstancesSecurityGroupIdSet.to_xml
                                  [x])))) v.groups))
                 @
                 [Util.option_map v.ipv6_address_count
                    (fun f ->
                       Ezxmlm.make_tag "Ipv6AddressCount"
                         ([], (Integer.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "Ipv6Address"
                           ([],
                             (ScheduledInstancesIpv6AddressList.to_xml [x]))))
                   v.ipv6_addresses))
               @
               [Util.option_map v.network_interface_id
                  (fun f ->
                     Ezxmlm.make_tag "NetworkInterfaceId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.private_ip_address
                 (fun f ->
                    Ezxmlm.make_tag "PrivateIpAddress"
                      ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "PrivateIpAddressConfig"
                        ([], (PrivateIpAddressConfigSet.to_xml [x]))))
                v.private_ip_address_configs))
            @
            [Util.option_map v.secondary_private_ip_address_count
               (fun f ->
                  Ezxmlm.make_tag "SecondaryPrivateIpAddressCount"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.subnet_id
              (fun f -> Ezxmlm.make_tag "SubnetId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_address_configs",
               (PrivateIpAddressConfigSet.to_json
                  v.private_ip_address_configs));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (ScheduledInstancesIpv6AddressList.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)));
           Some
             ("groups",
               (ScheduledInstancesSecurityGroupIdSet.to_json v.groups));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.associate_public_ip_address
             (fun f -> ("associate_public_ip_address", (Boolean.to_json f)))])
    let of_json j =
      {
        associate_public_ip_address =
          (Util.option_map (Json.lookup j "associate_public_ip_address")
             Boolean.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        device_index =
          (Util.option_map (Json.lookup j "device_index") Integer.of_json);
        groups =
          (ScheduledInstancesSecurityGroupIdSet.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        ipv6_address_count =
          (Util.option_map (Json.lookup j "ipv6_address_count")
             Integer.of_json);
        ipv6_addresses =
          (ScheduledInstancesIpv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_ip_address_configs =
          (PrivateIpAddressConfigSet.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_address_configs")));
        secondary_private_ip_address_count =
          (Util.option_map
             (Json.lookup j "secondary_private_ip_address_count")
             Integer.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json)
      }
  end
module NatGatewayAddressList =
  struct
    type t = NatGatewayAddress.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NatGatewayAddress.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NatGatewayAddress.to_query v
    let to_headers v = Headers.to_headers_list NatGatewayAddress.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (NatGatewayAddress.to_xml x)))
        v
    let to_json v = `List (List.map NatGatewayAddress.to_json v)
    let of_json j = Json.to_list NatGatewayAddress.of_json j
  end
module NatGatewayState =
  struct
    type t =
      | Pending 
      | Failed 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("failed", Failed);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Failed, "failed");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ProvisionedBandwidth =
  struct
    type t =
      {
      provision_time: DateTime.t option ;
      provisioned: String.t option ;
      request_time: DateTime.t option ;
      requested: String.t option ;
      status: String.t option }
    let make ?provision_time  ?provisioned  ?request_time  ?requested 
      ?status  () =
      { provision_time; provisioned; request_time; requested; status }
    let parse xml =
      Some
        {
          provision_time =
            (Util.option_bind (Xml.member "provisionTime" xml) DateTime.parse);
          provisioned =
            (Util.option_bind (Xml.member "provisioned" xml) String.parse);
          request_time =
            (Util.option_bind (Xml.member "requestTime" xml) DateTime.parse);
          requested =
            (Util.option_bind (Xml.member "requested" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.requested
             (fun f -> Query.Pair ("Requested", (String.to_query f)));
           Util.option_map v.request_time
             (fun f -> Query.Pair ("RequestTime", (DateTime.to_query f)));
           Util.option_map v.provisioned
             (fun f -> Query.Pair ("Provisioned", (String.to_query f)));
           Util.option_map v.provision_time
             (fun f -> Query.Pair ("ProvisionTime", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.provision_time
                  (fun f ->
                     Ezxmlm.make_tag "provisionTime"
                       ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.provisioned
                 (fun f ->
                    Ezxmlm.make_tag "provisioned" ([], (String.to_xml f)))])
             @
             [Util.option_map v.request_time
                (fun f ->
                   Ezxmlm.make_tag "requestTime" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.requested
               (fun f -> Ezxmlm.make_tag "requested" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (String.to_json f)));
           Util.option_map v.requested
             (fun f -> ("requested", (String.to_json f)));
           Util.option_map v.request_time
             (fun f -> ("request_time", (DateTime.to_json f)));
           Util.option_map v.provisioned
             (fun f -> ("provisioned", (String.to_json f)));
           Util.option_map v.provision_time
             (fun f -> ("provision_time", (DateTime.to_json f)))])
    let of_json j =
      {
        provision_time =
          (Util.option_map (Json.lookup j "provision_time") DateTime.of_json);
        provisioned =
          (Util.option_map (Json.lookup j "provisioned") String.of_json);
        request_time =
          (Util.option_map (Json.lookup j "request_time") DateTime.of_json);
        requested =
          (Util.option_map (Json.lookup j "requested") String.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json)
      }
  end
module LoadPermissionRequest =
  struct
    type t = {
      group: PermissionGroup.t option ;
      user_id: String.t option }
    let make ?group  ?user_id  () = { group; user_id }
    let parse xml =
      Some
        {
          group =
            (Util.option_bind (Xml.member "Group" xml) PermissionGroup.parse);
          user_id = (Util.option_bind (Xml.member "UserId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> Query.Pair ("UserId", (String.to_query f)));
           Util.option_map v.group
             (fun f -> Query.Pair ("Group", (PermissionGroup.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.group
               (fun f ->
                  Ezxmlm.make_tag "Group" ([], (PermissionGroup.to_xml f)))])
           @
           [Util.option_map v.user_id
              (fun f -> Ezxmlm.make_tag "UserId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> ("user_id", (String.to_json f)));
           Util.option_map v.group
             (fun f -> ("group", (PermissionGroup.to_json f)))])
    let of_json j =
      {
        group =
          (Util.option_map (Json.lookup j "group") PermissionGroup.of_json);
        user_id = (Util.option_map (Json.lookup j "user_id") String.of_json)
      }
  end
module Filter =
  struct
    type t = {
      name: String.t ;
      values: ValueStringList.t }
    let make ~name  ?(values= [])  () = { name; values }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "Value" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Value", (ValueStringList.to_query v.values)));
           Some (Query.Pair ("Name", (String.to_query v.name)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Value"
                      ([], (ValueStringList.to_xml [x])))) v.values))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (ValueStringList.to_json v.values));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        values =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module TagSpecification =
  struct
    type t = {
      resource_type: ResourceType.t option ;
      tags: TagList.t }
    let make ?resource_type  ?(tags= [])  () = { resource_type; tags }
    let parse xml =
      Some
        {
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               ResourceType.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tag" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Tag", (TagList.to_query v.tags)));
           Util.option_map v.resource_type
             (fun f -> Query.Pair ("ResourceType", (ResourceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "resourceType"
                    ([], (ResourceType.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "Tag" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.resource_type
             (fun f -> ("resource_type", (ResourceType.to_json f)))])
    let of_json j =
      {
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             ResourceType.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module TagDescription =
  struct
    type t =
      {
      key: String.t ;
      resource_id: String.t ;
      resource_type: ResourceType.t ;
      value: String.t }
    let make ~key  ~resource_id  ~resource_type  ~value  () =
      { key; resource_id; resource_type; value }
    let parse xml =
      Some
        {
          key =
            (Xml.required "key"
               (Util.option_bind (Xml.member "key" xml) String.parse));
          resource_id =
            (Xml.required "resourceId"
               (Util.option_bind (Xml.member "resourceId" xml) String.parse));
          resource_type =
            (Xml.required "resourceType"
               (Util.option_bind (Xml.member "resourceType" xml)
                  ResourceType.parse));
          value =
            (Xml.required "value"
               (Util.option_bind (Xml.member "value" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Value", (String.to_query v.value)));
           Some
             (Query.Pair
                ("ResourceType", (ResourceType.to_query v.resource_type)));
           Some (Query.Pair ("ResourceId", (String.to_query v.resource_id)));
           Some (Query.Pair ("Key", (String.to_query v.key)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @ [Some (Ezxmlm.make_tag "key" ([], (String.to_xml v.key)))])
             @
             [Some
                (Ezxmlm.make_tag "resourceId"
                   ([], (String.to_xml v.resource_id)))])
            @
            [Some
               (Ezxmlm.make_tag "resourceType"
                  ([], (ResourceType.to_xml v.resource_type)))])
           @ [Some (Ezxmlm.make_tag "value" ([], (String.to_xml v.value)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("value", (String.to_json v.value));
           Some ("resource_type", (ResourceType.to_json v.resource_type));
           Some ("resource_id", (String.to_json v.resource_id));
           Some ("key", (String.to_json v.key))])
    let of_json j =
      {
        key = (String.of_json (Util.of_option_exn (Json.lookup j "key")));
        resource_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "resource_id")));
        resource_type =
          (ResourceType.of_json
             (Util.of_option_exn (Json.lookup j "resource_type")));
        value = (String.of_json (Util.of_option_exn (Json.lookup j "value")))
      }
  end
module DhcpOptions =
  struct
    type t =
      {
      dhcp_configurations: DhcpConfigurationList.t ;
      dhcp_options_id: String.t option ;
      owner_id: String.t option ;
      tags: TagList.t }
    let make ?(dhcp_configurations= [])  ?dhcp_options_id  ?owner_id  ?(tags=
      [])  () = { dhcp_configurations; dhcp_options_id; owner_id; tags }
    let parse xml =
      Some
        {
          dhcp_configurations =
            (Util.of_option []
               (Util.option_bind (Xml.member "dhcpConfigurationSet" xml)
                  DhcpConfigurationList.parse));
          dhcp_options_id =
            (Util.option_bind (Xml.member "dhcpOptionsId" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.dhcp_options_id
             (fun f -> Query.Pair ("DhcpOptionsId", (String.to_query f)));
           Some
             (Query.Pair
                ("DhcpConfigurationSet",
                  (DhcpConfigurationList.to_query v.dhcp_configurations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "dhcpConfigurationSet"
                         ([], (DhcpConfigurationList.to_xml [x]))))
                 v.dhcp_configurations))
             @
             [Util.option_map v.dhcp_options_id
                (fun f ->
                   Ezxmlm.make_tag "dhcpOptionsId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.owner_id
               (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.dhcp_options_id
             (fun f -> ("dhcp_options_id", (String.to_json f)));
           Some
             ("dhcp_configurations",
               (DhcpConfigurationList.to_json v.dhcp_configurations))])
    let of_json j =
      {
        dhcp_configurations =
          (DhcpConfigurationList.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_configurations")));
        dhcp_options_id =
          (Util.option_map (Json.lookup j "dhcp_options_id") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module VpnGateway =
  struct
    type t =
      {
      availability_zone: String.t option ;
      state: VpnState.t option ;
      type_: GatewayType.t option ;
      vpc_attachments: VpcAttachmentList.t ;
      vpn_gateway_id: String.t option ;
      amazon_side_asn: Long.t option ;
      tags: TagList.t }
    let make ?availability_zone  ?state  ?type_  ?(vpc_attachments= []) 
      ?vpn_gateway_id  ?amazon_side_asn  ?(tags= [])  () =
      {
        availability_zone;
        state;
        type_;
        vpc_attachments;
        vpn_gateway_id;
        amazon_side_asn;
        tags
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          state = (Util.option_bind (Xml.member "state" xml) VpnState.parse);
          type_ =
            (Util.option_bind (Xml.member "type" xml) GatewayType.parse);
          vpc_attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "attachments" xml)
                  VpcAttachmentList.parse));
          vpn_gateway_id =
            (Util.option_bind (Xml.member "vpnGatewayId" xml) String.parse);
          amazon_side_asn =
            (Util.option_bind (Xml.member "amazonSideAsn" xml) Long.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.amazon_side_asn
             (fun f -> Query.Pair ("AmazonSideAsn", (Long.to_query f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> Query.Pair ("VpnGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("Attachments",
                  (VpcAttachmentList.to_query v.vpc_attachments)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (GatewayType.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (VpnState.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.availability_zone
                    (fun f ->
                       Ezxmlm.make_tag "availabilityZone"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.state
                   (fun f ->
                      Ezxmlm.make_tag "state" ([], (VpnState.to_xml f)))])
               @
               [Util.option_map v.type_
                  (fun f ->
                     Ezxmlm.make_tag "type" ([], (GatewayType.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "attachments"
                         ([], (VpcAttachmentList.to_xml [x]))))
                 v.vpc_attachments))
             @
             [Util.option_map v.vpn_gateway_id
                (fun f ->
                   Ezxmlm.make_tag "vpnGatewayId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.amazon_side_asn
               (fun f ->
                  Ezxmlm.make_tag "amazonSideAsn" ([], (Long.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.amazon_side_asn
             (fun f -> ("amazon_side_asn", (Long.to_json f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> ("vpn_gateway_id", (String.to_json f)));
           Some
             ("vpc_attachments",
               (VpcAttachmentList.to_json v.vpc_attachments));
           Util.option_map v.type_
             (fun f -> ("type_", (GatewayType.to_json f)));
           Util.option_map v.state (fun f -> ("state", (VpnState.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        state = (Util.option_map (Json.lookup j "state") VpnState.of_json);
        type_ = (Util.option_map (Json.lookup j "type_") GatewayType.of_json);
        vpc_attachments =
          (VpcAttachmentList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_attachments")));
        vpn_gateway_id =
          (Util.option_map (Json.lookup j "vpn_gateway_id") String.of_json);
        amazon_side_asn =
          (Util.option_map (Json.lookup j "amazon_side_asn") Long.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module TransitGatewayAttachmentPropagation =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t option ;
      state: TransitGatewayPropagationState.t option }
    let make ?transit_gateway_route_table_id  ?state  () =
      { transit_gateway_route_table_id; state }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Util.option_bind (Xml.member "transitGatewayRouteTableId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayPropagationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayPropagationState.to_query f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayRouteTableId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.transit_gateway_route_table_id
               (fun f ->
                  Ezxmlm.make_tag "transitGatewayRouteTableId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (TransitGatewayPropagationState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayPropagationState.to_json f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f -> ("transit_gateway_route_table_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (Util.option_map (Json.lookup j "transit_gateway_route_table_id")
             String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayPropagationState.of_json)
      }
  end
module CapacityReservation =
  struct
    type t =
      {
      capacity_reservation_id: String.t option ;
      owner_id: String.t option ;
      capacity_reservation_arn: String.t option ;
      availability_zone_id: String.t option ;
      instance_type: String.t option ;
      instance_platform: CapacityReservationInstancePlatform.t option ;
      availability_zone: String.t option ;
      tenancy: CapacityReservationTenancy.t option ;
      total_instance_count: Integer.t option ;
      available_instance_count: Integer.t option ;
      ebs_optimized: Boolean.t option ;
      ephemeral_storage: Boolean.t option ;
      state: CapacityReservationState.t option ;
      end_date: DateTime.t option ;
      end_date_type: EndDateType.t option ;
      instance_match_criteria: InstanceMatchCriteria.t option ;
      create_date: DateTime.t option ;
      tags: TagList.t }
    let make ?capacity_reservation_id  ?owner_id  ?capacity_reservation_arn 
      ?availability_zone_id  ?instance_type  ?instance_platform 
      ?availability_zone  ?tenancy  ?total_instance_count 
      ?available_instance_count  ?ebs_optimized  ?ephemeral_storage  ?state 
      ?end_date  ?end_date_type  ?instance_match_criteria  ?create_date 
      ?(tags= [])  () =
      {
        capacity_reservation_id;
        owner_id;
        capacity_reservation_arn;
        availability_zone_id;
        instance_type;
        instance_platform;
        availability_zone;
        tenancy;
        total_instance_count;
        available_instance_count;
        ebs_optimized;
        ephemeral_storage;
        state;
        end_date;
        end_date_type;
        instance_match_criteria;
        create_date;
        tags
      }
    let parse xml =
      Some
        {
          capacity_reservation_id =
            (Util.option_bind (Xml.member "capacityReservationId" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          capacity_reservation_arn =
            (Util.option_bind (Xml.member "capacityReservationArn" xml)
               String.parse);
          availability_zone_id =
            (Util.option_bind (Xml.member "availabilityZoneId" xml)
               String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          instance_platform =
            (Util.option_bind (Xml.member "instancePlatform" xml)
               CapacityReservationInstancePlatform.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          tenancy =
            (Util.option_bind (Xml.member "tenancy" xml)
               CapacityReservationTenancy.parse);
          total_instance_count =
            (Util.option_bind (Xml.member "totalInstanceCount" xml)
               Integer.parse);
          available_instance_count =
            (Util.option_bind (Xml.member "availableInstanceCount" xml)
               Integer.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          ephemeral_storage =
            (Util.option_bind (Xml.member "ephemeralStorage" xml)
               Boolean.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               CapacityReservationState.parse);
          end_date =
            (Util.option_bind (Xml.member "endDate" xml) DateTime.parse);
          end_date_type =
            (Util.option_bind (Xml.member "endDateType" xml)
               EndDateType.parse);
          instance_match_criteria =
            (Util.option_bind (Xml.member "instanceMatchCriteria" xml)
               InstanceMatchCriteria.parse);
          create_date =
            (Util.option_bind (Xml.member "createDate" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.create_date
             (fun f -> Query.Pair ("CreateDate", (DateTime.to_query f)));
           Util.option_map v.instance_match_criteria
             (fun f ->
                Query.Pair
                  ("InstanceMatchCriteria",
                    (InstanceMatchCriteria.to_query f)));
           Util.option_map v.end_date_type
             (fun f -> Query.Pair ("EndDateType", (EndDateType.to_query f)));
           Util.option_map v.end_date
             (fun f -> Query.Pair ("EndDate", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (CapacityReservationState.to_query f)));
           Util.option_map v.ephemeral_storage
             (fun f -> Query.Pair ("EphemeralStorage", (Boolean.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.available_instance_count
             (fun f ->
                Query.Pair ("AvailableInstanceCount", (Integer.to_query f)));
           Util.option_map v.total_instance_count
             (fun f ->
                Query.Pair ("TotalInstanceCount", (Integer.to_query f)));
           Util.option_map v.tenancy
             (fun f ->
                Query.Pair
                  ("Tenancy", (CapacityReservationTenancy.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.instance_platform
             (fun f ->
                Query.Pair
                  ("InstancePlatform",
                    (CapacityReservationInstancePlatform.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.availability_zone_id
             (fun f -> Query.Pair ("AvailabilityZoneId", (String.to_query f)));
           Util.option_map v.capacity_reservation_arn
             (fun f ->
                Query.Pair ("CapacityReservationArn", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.capacity_reservation_id
             (fun f ->
                Query.Pair ("CapacityReservationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((([] @
                            [Util.option_map v.capacity_reservation_id
                               (fun f ->
                                  Ezxmlm.make_tag "capacityReservationId"
                                    ([], (String.to_xml f)))])
                           @
                           [Util.option_map v.owner_id
                              (fun f ->
                                 Ezxmlm.make_tag "ownerId"
                                   ([], (String.to_xml f)))])
                          @
                          [Util.option_map v.capacity_reservation_arn
                             (fun f ->
                                Ezxmlm.make_tag "capacityReservationArn"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.availability_zone_id
                            (fun f ->
                               Ezxmlm.make_tag "availabilityZoneId"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.instance_type
                           (fun f ->
                              Ezxmlm.make_tag "instanceType"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.instance_platform
                          (fun f ->
                             Ezxmlm.make_tag "instancePlatform"
                               ([],
                                 (CapacityReservationInstancePlatform.to_xml
                                    f)))])
                      @
                      [Util.option_map v.availability_zone
                         (fun f ->
                            Ezxmlm.make_tag "availabilityZone"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.tenancy
                        (fun f ->
                           Ezxmlm.make_tag "tenancy"
                             ([], (CapacityReservationTenancy.to_xml f)))])
                    @
                    [Util.option_map v.total_instance_count
                       (fun f ->
                          Ezxmlm.make_tag "totalInstanceCount"
                            ([], (Integer.to_xml f)))])
                   @
                   [Util.option_map v.available_instance_count
                      (fun f ->
                         Ezxmlm.make_tag "availableInstanceCount"
                           ([], (Integer.to_xml f)))])
                  @
                  [Util.option_map v.ebs_optimized
                     (fun f ->
                        Ezxmlm.make_tag "ebsOptimized"
                          ([], (Boolean.to_xml f)))])
                 @
                 [Util.option_map v.ephemeral_storage
                    (fun f ->
                       Ezxmlm.make_tag "ephemeralStorage"
                         ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.state
                   (fun f ->
                      Ezxmlm.make_tag "state"
                        ([], (CapacityReservationState.to_xml f)))])
               @
               [Util.option_map v.end_date
                  (fun f ->
                     Ezxmlm.make_tag "endDate" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.end_date_type
                 (fun f ->
                    Ezxmlm.make_tag "endDateType"
                      ([], (EndDateType.to_xml f)))])
             @
             [Util.option_map v.instance_match_criteria
                (fun f ->
                   Ezxmlm.make_tag "instanceMatchCriteria"
                     ([], (InstanceMatchCriteria.to_xml f)))])
            @
            [Util.option_map v.create_date
               (fun f ->
                  Ezxmlm.make_tag "createDate" ([], (DateTime.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.create_date
             (fun f -> ("create_date", (DateTime.to_json f)));
           Util.option_map v.instance_match_criteria
             (fun f ->
                ("instance_match_criteria",
                  (InstanceMatchCriteria.to_json f)));
           Util.option_map v.end_date_type
             (fun f -> ("end_date_type", (EndDateType.to_json f)));
           Util.option_map v.end_date
             (fun f -> ("end_date", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (CapacityReservationState.to_json f)));
           Util.option_map v.ephemeral_storage
             (fun f -> ("ephemeral_storage", (Boolean.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.available_instance_count
             (fun f -> ("available_instance_count", (Integer.to_json f)));
           Util.option_map v.total_instance_count
             (fun f -> ("total_instance_count", (Integer.to_json f)));
           Util.option_map v.tenancy
             (fun f -> ("tenancy", (CapacityReservationTenancy.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.instance_platform
             (fun f ->
                ("instance_platform",
                  (CapacityReservationInstancePlatform.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.availability_zone_id
             (fun f -> ("availability_zone_id", (String.to_json f)));
           Util.option_map v.capacity_reservation_arn
             (fun f -> ("capacity_reservation_arn", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.capacity_reservation_id
             (fun f -> ("capacity_reservation_id", (String.to_json f)))])
    let of_json j =
      {
        capacity_reservation_id =
          (Util.option_map (Json.lookup j "capacity_reservation_id")
             String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        capacity_reservation_arn =
          (Util.option_map (Json.lookup j "capacity_reservation_arn")
             String.of_json);
        availability_zone_id =
          (Util.option_map (Json.lookup j "availability_zone_id")
             String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        instance_platform =
          (Util.option_map (Json.lookup j "instance_platform")
             CapacityReservationInstancePlatform.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        tenancy =
          (Util.option_map (Json.lookup j "tenancy")
             CapacityReservationTenancy.of_json);
        total_instance_count =
          (Util.option_map (Json.lookup j "total_instance_count")
             Integer.of_json);
        available_instance_count =
          (Util.option_map (Json.lookup j "available_instance_count")
             Integer.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        ephemeral_storage =
          (Util.option_map (Json.lookup j "ephemeral_storage")
             Boolean.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             CapacityReservationState.of_json);
        end_date =
          (Util.option_map (Json.lookup j "end_date") DateTime.of_json);
        end_date_type =
          (Util.option_map (Json.lookup j "end_date_type")
             EndDateType.of_json);
        instance_match_criteria =
          (Util.option_map (Json.lookup j "instance_match_criteria")
             InstanceMatchCriteria.of_json);
        create_date =
          (Util.option_map (Json.lookup j "create_date") DateTime.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ReservedInstancesModification =
  struct
    type t =
      {
      client_token: String.t option ;
      create_date: DateTime.t option ;
      effective_date: DateTime.t option ;
      modification_results: ReservedInstancesModificationResultList.t ;
      reserved_instances_ids: ReservedIntancesIds.t ;
      reserved_instances_modification_id: String.t option ;
      status: String.t option ;
      status_message: String.t option ;
      update_date: DateTime.t option }
    let make ?client_token  ?create_date  ?effective_date 
      ?(modification_results= [])  ?(reserved_instances_ids= []) 
      ?reserved_instances_modification_id  ?status  ?status_message 
      ?update_date  () =
      {
        client_token;
        create_date;
        effective_date;
        modification_results;
        reserved_instances_ids;
        reserved_instances_modification_id;
        status;
        status_message;
        update_date
      }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          create_date =
            (Util.option_bind (Xml.member "createDate" xml) DateTime.parse);
          effective_date =
            (Util.option_bind (Xml.member "effectiveDate" xml) DateTime.parse);
          modification_results =
            (Util.of_option []
               (Util.option_bind (Xml.member "modificationResultSet" xml)
                  ReservedInstancesModificationResultList.parse));
          reserved_instances_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "reservedInstancesSet" xml)
                  ReservedIntancesIds.parse));
          reserved_instances_modification_id =
            (Util.option_bind
               (Xml.member "reservedInstancesModificationId" xml)
               String.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          update_date =
            (Util.option_bind (Xml.member "updateDate" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.update_date
              (fun f -> Query.Pair ("UpdateDate", (DateTime.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.reserved_instances_modification_id
             (fun f ->
                Query.Pair
                  ("ReservedInstancesModificationId", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesSet",
                  (ReservedIntancesIds.to_query v.reserved_instances_ids)));
           Some
             (Query.Pair
                ("ModificationResultSet",
                  (ReservedInstancesModificationResultList.to_query
                     v.modification_results)));
           Util.option_map v.effective_date
             (fun f -> Query.Pair ("EffectiveDate", (DateTime.to_query f)));
           Util.option_map v.create_date
             (fun f -> Query.Pair ("CreateDate", (DateTime.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.client_token
                      (fun f ->
                         Ezxmlm.make_tag "clientToken"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.create_date
                     (fun f ->
                        Ezxmlm.make_tag "createDate"
                          ([], (DateTime.to_xml f)))])
                 @
                 [Util.option_map v.effective_date
                    (fun f ->
                       Ezxmlm.make_tag "effectiveDate"
                         ([], (DateTime.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "modificationResultSet"
                           ([],
                             (ReservedInstancesModificationResultList.to_xml
                                [x])))) v.modification_results))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "reservedInstancesSet"
                          ([], (ReservedIntancesIds.to_xml [x]))))
                  v.reserved_instances_ids))
              @
              [Util.option_map v.reserved_instances_modification_id
                 (fun f ->
                    Ezxmlm.make_tag "reservedInstancesModificationId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.status
                (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
            @
            [Util.option_map v.status_message
               (fun f ->
                  Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
           @
           [Util.option_map v.update_date
              (fun f ->
                 Ezxmlm.make_tag "updateDate" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.update_date
              (fun f -> ("update_date", (DateTime.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.reserved_instances_modification_id
             (fun f ->
                ("reserved_instances_modification_id", (String.to_json f)));
           Some
             ("reserved_instances_ids",
               (ReservedIntancesIds.to_json v.reserved_instances_ids));
           Some
             ("modification_results",
               (ReservedInstancesModificationResultList.to_json
                  v.modification_results));
           Util.option_map v.effective_date
             (fun f -> ("effective_date", (DateTime.to_json f)));
           Util.option_map v.create_date
             (fun f -> ("create_date", (DateTime.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        create_date =
          (Util.option_map (Json.lookup j "create_date") DateTime.of_json);
        effective_date =
          (Util.option_map (Json.lookup j "effective_date") DateTime.of_json);
        modification_results =
          (ReservedInstancesModificationResultList.of_json
             (Util.of_option_exn (Json.lookup j "modification_results")));
        reserved_instances_ids =
          (ReservedIntancesIds.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances_ids")));
        reserved_instances_modification_id =
          (Util.option_map
             (Json.lookup j "reserved_instances_modification_id")
             String.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        update_date =
          (Util.option_map (Json.lookup j "update_date") DateTime.of_json)
      }
  end
module PlacementGroup =
  struct
    type t =
      {
      group_name: String.t option ;
      state: PlacementGroupState.t option ;
      strategy: PlacementStrategy.t option ;
      partition_count: Integer.t option ;
      group_id: String.t option ;
      tags: TagList.t }
    let make ?group_name  ?state  ?strategy  ?partition_count  ?group_id 
      ?(tags= [])  () =
      { group_name; state; strategy; partition_count; group_id; tags }
    let parse xml =
      Some
        {
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               PlacementGroupState.parse);
          strategy =
            (Util.option_bind (Xml.member "strategy" xml)
               PlacementStrategy.parse);
          partition_count =
            (Util.option_bind (Xml.member "partitionCount" xml) Integer.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.partition_count
             (fun f -> Query.Pair ("PartitionCount", (Integer.to_query f)));
           Util.option_map v.strategy
             (fun f ->
                Query.Pair ("Strategy", (PlacementStrategy.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (PlacementGroupState.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.group_name
                   (fun f ->
                      Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
               @
               [Util.option_map v.state
                  (fun f ->
                     Ezxmlm.make_tag "state"
                       ([], (PlacementGroupState.to_xml f)))])
              @
              [Util.option_map v.strategy
                 (fun f ->
                    Ezxmlm.make_tag "strategy"
                      ([], (PlacementStrategy.to_xml f)))])
             @
             [Util.option_map v.partition_count
                (fun f ->
                   Ezxmlm.make_tag "partitionCount" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.group_id
               (fun f -> Ezxmlm.make_tag "groupId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.partition_count
             (fun f -> ("partition_count", (Integer.to_json f)));
           Util.option_map v.strategy
             (fun f -> ("strategy", (PlacementStrategy.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (PlacementGroupState.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)))])
    let of_json j =
      {
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             PlacementGroupState.of_json);
        strategy =
          (Util.option_map (Json.lookup j "strategy")
             PlacementStrategy.of_json);
        partition_count =
          (Util.option_map (Json.lookup j "partition_count") Integer.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module TransitGatewayRouteTablePropagation =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option ;
      resource_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      state: TransitGatewayPropagationState.t option }
    let make ?transit_gateway_attachment_id  ?resource_id  ?resource_type 
      ?state  () =
      { transit_gateway_attachment_id; resource_id; resource_type; state }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayPropagationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayPropagationState.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.transit_gateway_attachment_id
                 (fun f ->
                    Ezxmlm.make_tag "transitGatewayAttachmentId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.resource_id
                (fun f ->
                   Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "resourceType"
                    ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (TransitGatewayPropagationState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayPropagationState.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayPropagationState.of_json)
      }
  end
module KeyPairInfo =
  struct
    type t =
      {
      key_pair_id: String.t option ;
      key_fingerprint: String.t option ;
      key_name: String.t option ;
      tags: TagList.t }
    let make ?key_pair_id  ?key_fingerprint  ?key_name  ?(tags= [])  () =
      { key_pair_id; key_fingerprint; key_name; tags }
    let parse xml =
      Some
        {
          key_pair_id =
            (Util.option_bind (Xml.member "keyPairId" xml) String.parse);
          key_fingerprint =
            (Util.option_bind (Xml.member "keyFingerprint" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.key_fingerprint
             (fun f -> Query.Pair ("KeyFingerprint", (String.to_query f)));
           Util.option_map v.key_pair_id
             (fun f -> Query.Pair ("KeyPairId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.key_pair_id
                 (fun f ->
                    Ezxmlm.make_tag "keyPairId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.key_fingerprint
                (fun f ->
                   Ezxmlm.make_tag "keyFingerprint" ([], (String.to_xml f)))])
            @
            [Util.option_map v.key_name
               (fun f -> Ezxmlm.make_tag "keyName" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.key_fingerprint
             (fun f -> ("key_fingerprint", (String.to_json f)));
           Util.option_map v.key_pair_id
             (fun f -> ("key_pair_id", (String.to_json f)))])
    let of_json j =
      {
        key_pair_id =
          (Util.option_map (Json.lookup j "key_pair_id") String.of_json);
        key_fingerprint =
          (Util.option_map (Json.lookup j "key_fingerprint") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module HistoryRecordEntry =
  struct
    type t =
      {
      event_information: EventInformation.t option ;
      event_type: FleetEventType.t option ;
      timestamp: DateTime.t option }
    let make ?event_information  ?event_type  ?timestamp  () =
      { event_information; event_type; timestamp }
    let parse xml =
      Some
        {
          event_information =
            (Util.option_bind (Xml.member "eventInformation" xml)
               EventInformation.parse);
          event_type =
            (Util.option_bind (Xml.member "eventType" xml)
               FleetEventType.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.event_type
             (fun f -> Query.Pair ("EventType", (FleetEventType.to_query f)));
           Util.option_map v.event_information
             (fun f ->
                Query.Pair
                  ("EventInformation", (EventInformation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.event_information
                (fun f ->
                   Ezxmlm.make_tag "eventInformation"
                     ([], (EventInformation.to_xml f)))])
            @
            [Util.option_map v.event_type
               (fun f ->
                  Ezxmlm.make_tag "eventType" ([], (FleetEventType.to_xml f)))])
           @
           [Util.option_map v.timestamp
              (fun f -> Ezxmlm.make_tag "timestamp" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.event_type
             (fun f -> ("event_type", (FleetEventType.to_json f)));
           Util.option_map v.event_information
             (fun f -> ("event_information", (EventInformation.to_json f)))])
    let of_json j =
      {
        event_information =
          (Util.option_map (Json.lookup j "event_information")
             EventInformation.of_json);
        event_type =
          (Util.option_map (Json.lookup j "event_type")
             FleetEventType.of_json);
        timestamp =
          (Util.option_map (Json.lookup j "timestamp") DateTime.of_json)
      }
  end
module HostReservation =
  struct
    type t =
      {
      count: Integer.t option ;
      currency_code: CurrencyCodeValues.t option ;
      duration: Integer.t option ;
      end_: DateTime.t option ;
      host_id_set: ResponseHostIdSet.t ;
      host_reservation_id: String.t option ;
      hourly_price: String.t option ;
      instance_family: String.t option ;
      offering_id: String.t option ;
      payment_option: PaymentOption.t option ;
      start: DateTime.t option ;
      state: ReservationState.t option ;
      upfront_price: String.t option ;
      tags: TagList.t }
    let make ?count  ?currency_code  ?duration  ?end_  ?(host_id_set= []) 
      ?host_reservation_id  ?hourly_price  ?instance_family  ?offering_id 
      ?payment_option  ?start  ?state  ?upfront_price  ?(tags= [])  () =
      {
        count;
        currency_code;
        duration;
        end_;
        host_id_set;
        host_reservation_id;
        hourly_price;
        instance_family;
        offering_id;
        payment_option;
        start;
        state;
        upfront_price;
        tags
      }
    let parse xml =
      Some
        {
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Integer.parse);
          end_ = (Util.option_bind (Xml.member "end" xml) DateTime.parse);
          host_id_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostIdSet" xml)
                  ResponseHostIdSet.parse));
          host_reservation_id =
            (Util.option_bind (Xml.member "hostReservationId" xml)
               String.parse);
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          instance_family =
            (Util.option_bind (Xml.member "instanceFamily" xml) String.parse);
          offering_id =
            (Util.option_bind (Xml.member "offeringId" xml) String.parse);
          payment_option =
            (Util.option_bind (Xml.member "paymentOption" xml)
               PaymentOption.parse);
          start = (Util.option_bind (Xml.member "start" xml) DateTime.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) ReservationState.parse);
          upfront_price =
            (Util.option_bind (Xml.member "upfrontPrice" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.upfront_price
             (fun f -> Query.Pair ("UpfrontPrice", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (ReservationState.to_query f)));
           Util.option_map v.start
             (fun f -> Query.Pair ("Start", (DateTime.to_query f)));
           Util.option_map v.payment_option
             (fun f ->
                Query.Pair ("PaymentOption", (PaymentOption.to_query f)));
           Util.option_map v.offering_id
             (fun f -> Query.Pair ("OfferingId", (String.to_query f)));
           Util.option_map v.instance_family
             (fun f -> Query.Pair ("InstanceFamily", (String.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)));
           Util.option_map v.host_reservation_id
             (fun f -> Query.Pair ("HostReservationId", (String.to_query f)));
           Some
             (Query.Pair
                ("HostIdSet", (ResponseHostIdSet.to_query v.host_id_set)));
           Util.option_map v.end_
             (fun f -> Query.Pair ("End", (DateTime.to_query f)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Integer.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        [Util.option_map v.count
                           (fun f ->
                              Ezxmlm.make_tag "count"
                                ([], (Integer.to_xml f)))])
                       @
                       [Util.option_map v.currency_code
                          (fun f ->
                             Ezxmlm.make_tag "currencyCode"
                               ([], (CurrencyCodeValues.to_xml f)))])
                      @
                      [Util.option_map v.duration
                         (fun f ->
                            Ezxmlm.make_tag "duration"
                              ([], (Integer.to_xml f)))])
                     @
                     [Util.option_map v.end_
                        (fun f ->
                           Ezxmlm.make_tag "end" ([], (DateTime.to_xml f)))])
                    @
                    (List.map
                       (fun x ->
                          Some
                            (Ezxmlm.make_tag "hostIdSet"
                               ([], (ResponseHostIdSet.to_xml [x]))))
                       v.host_id_set))
                   @
                   [Util.option_map v.host_reservation_id
                      (fun f ->
                         Ezxmlm.make_tag "hostReservationId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.hourly_price
                     (fun f ->
                        Ezxmlm.make_tag "hourlyPrice" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.instance_family
                    (fun f ->
                       Ezxmlm.make_tag "instanceFamily"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.offering_id
                   (fun f ->
                      Ezxmlm.make_tag "offeringId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.payment_option
                  (fun f ->
                     Ezxmlm.make_tag "paymentOption"
                       ([], (PaymentOption.to_xml f)))])
              @
              [Util.option_map v.start
                 (fun f -> Ezxmlm.make_tag "start" ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.state
                (fun f ->
                   Ezxmlm.make_tag "state" ([], (ReservationState.to_xml f)))])
            @
            [Util.option_map v.upfront_price
               (fun f ->
                  Ezxmlm.make_tag "upfrontPrice" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.upfront_price
             (fun f -> ("upfront_price", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (ReservationState.to_json f)));
           Util.option_map v.start (fun f -> ("start", (DateTime.to_json f)));
           Util.option_map v.payment_option
             (fun f -> ("payment_option", (PaymentOption.to_json f)));
           Util.option_map v.offering_id
             (fun f -> ("offering_id", (String.to_json f)));
           Util.option_map v.instance_family
             (fun f -> ("instance_family", (String.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)));
           Util.option_map v.host_reservation_id
             (fun f -> ("host_reservation_id", (String.to_json f)));
           Some ("host_id_set", (ResponseHostIdSet.to_json v.host_id_set));
           Util.option_map v.end_ (fun f -> ("end_", (DateTime.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Integer.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)))])
    let of_json j =
      {
        count = (Util.option_map (Json.lookup j "count") Integer.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        duration =
          (Util.option_map (Json.lookup j "duration") Integer.of_json);
        end_ = (Util.option_map (Json.lookup j "end_") DateTime.of_json);
        host_id_set =
          (ResponseHostIdSet.of_json
             (Util.of_option_exn (Json.lookup j "host_id_set")));
        host_reservation_id =
          (Util.option_map (Json.lookup j "host_reservation_id")
             String.of_json);
        hourly_price =
          (Util.option_map (Json.lookup j "hourly_price") String.of_json);
        instance_family =
          (Util.option_map (Json.lookup j "instance_family") String.of_json);
        offering_id =
          (Util.option_map (Json.lookup j "offering_id") String.of_json);
        payment_option =
          (Util.option_map (Json.lookup j "payment_option")
             PaymentOption.of_json);
        start = (Util.option_map (Json.lookup j "start") DateTime.of_json);
        state =
          (Util.option_map (Json.lookup j "state") ReservationState.of_json);
        upfront_price =
          (Util.option_map (Json.lookup j "upfront_price") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module LaunchPermissionList =
  struct
    type t = LaunchPermission.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchPermission.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LaunchPermission.to_query v
    let to_headers v = Headers.to_headers_list LaunchPermission.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (LaunchPermission.to_xml x)))
        v
    let to_json v = `List (List.map LaunchPermission.to_json v)
    let of_json j = Json.to_list LaunchPermission.of_json j
  end
module VpcEndpointConnection =
  struct
    type t =
      {
      service_id: String.t option ;
      vpc_endpoint_id: String.t option ;
      vpc_endpoint_owner: String.t option ;
      vpc_endpoint_state: State.t option ;
      creation_timestamp: DateTime.t option ;
      dns_entries: DnsEntrySet.t ;
      network_load_balancer_arns: ValueStringList.t }
    let make ?service_id  ?vpc_endpoint_id  ?vpc_endpoint_owner 
      ?vpc_endpoint_state  ?creation_timestamp  ?(dns_entries= []) 
      ?(network_load_balancer_arns= [])  () =
      {
        service_id;
        vpc_endpoint_id;
        vpc_endpoint_owner;
        vpc_endpoint_state;
        creation_timestamp;
        dns_entries;
        network_load_balancer_arns
      }
    let parse xml =
      Some
        {
          service_id =
            (Util.option_bind (Xml.member "serviceId" xml) String.parse);
          vpc_endpoint_id =
            (Util.option_bind (Xml.member "vpcEndpointId" xml) String.parse);
          vpc_endpoint_owner =
            (Util.option_bind (Xml.member "vpcEndpointOwner" xml)
               String.parse);
          vpc_endpoint_state =
            (Util.option_bind (Xml.member "vpcEndpointState" xml) State.parse);
          creation_timestamp =
            (Util.option_bind (Xml.member "creationTimestamp" xml)
               DateTime.parse);
          dns_entries =
            (Util.of_option []
               (Util.option_bind (Xml.member "dnsEntrySet" xml)
                  DnsEntrySet.parse));
          network_load_balancer_arns =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkLoadBalancerArnSet" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkLoadBalancerArnSet",
                   (ValueStringList.to_query v.network_load_balancer_arns)));
           Some
             (Query.Pair
                ("DnsEntrySet", (DnsEntrySet.to_query v.dns_entries)));
           Util.option_map v.creation_timestamp
             (fun f ->
                Query.Pair ("CreationTimestamp", (DateTime.to_query f)));
           Util.option_map v.vpc_endpoint_state
             (fun f -> Query.Pair ("VpcEndpointState", (State.to_query f)));
           Util.option_map v.vpc_endpoint_owner
             (fun f -> Query.Pair ("VpcEndpointOwner", (String.to_query f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> Query.Pair ("VpcEndpointId", (String.to_query f)));
           Util.option_map v.service_id
             (fun f -> Query.Pair ("ServiceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.service_id
                    (fun f ->
                       Ezxmlm.make_tag "serviceId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.vpc_endpoint_id
                   (fun f ->
                      Ezxmlm.make_tag "vpcEndpointId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.vpc_endpoint_owner
                  (fun f ->
                     Ezxmlm.make_tag "vpcEndpointOwner"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.vpc_endpoint_state
                 (fun f ->
                    Ezxmlm.make_tag "vpcEndpointState" ([], (State.to_xml f)))])
             @
             [Util.option_map v.creation_timestamp
                (fun f ->
                   Ezxmlm.make_tag "creationTimestamp"
                     ([], (DateTime.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "dnsEntrySet"
                       ([], (DnsEntrySet.to_xml [x])))) v.dns_entries))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "networkLoadBalancerArnSet"
                      ([], (ValueStringList.to_xml [x]))))
              v.network_load_balancer_arns))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("network_load_balancer_arns",
                (ValueStringList.to_json v.network_load_balancer_arns));
           Some ("dns_entries", (DnsEntrySet.to_json v.dns_entries));
           Util.option_map v.creation_timestamp
             (fun f -> ("creation_timestamp", (DateTime.to_json f)));
           Util.option_map v.vpc_endpoint_state
             (fun f -> ("vpc_endpoint_state", (State.to_json f)));
           Util.option_map v.vpc_endpoint_owner
             (fun f -> ("vpc_endpoint_owner", (String.to_json f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> ("vpc_endpoint_id", (String.to_json f)));
           Util.option_map v.service_id
             (fun f -> ("service_id", (String.to_json f)))])
    let of_json j =
      {
        service_id =
          (Util.option_map (Json.lookup j "service_id") String.of_json);
        vpc_endpoint_id =
          (Util.option_map (Json.lookup j "vpc_endpoint_id") String.of_json);
        vpc_endpoint_owner =
          (Util.option_map (Json.lookup j "vpc_endpoint_owner")
             String.of_json);
        vpc_endpoint_state =
          (Util.option_map (Json.lookup j "vpc_endpoint_state") State.of_json);
        creation_timestamp =
          (Util.option_map (Json.lookup j "creation_timestamp")
             DateTime.of_json);
        dns_entries =
          (DnsEntrySet.of_json
             (Util.of_option_exn (Json.lookup j "dns_entries")));
        network_load_balancer_arns =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "network_load_balancer_arns")))
      }
  end
module ExportImageTask =
  struct
    type t =
      {
      description: String.t option ;
      export_image_task_id: String.t option ;
      image_id: String.t option ;
      progress: String.t option ;
      s3_export_location: ExportTaskS3Location.t option ;
      status: String.t option ;
      status_message: String.t option }
    let make ?description  ?export_image_task_id  ?image_id  ?progress 
      ?s3_export_location  ?status  ?status_message  () =
      {
        description;
        export_image_task_id;
        image_id;
        progress;
        s3_export_location;
        status;
        status_message
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          export_image_task_id =
            (Util.option_bind (Xml.member "exportImageTaskId" xml)
               String.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          s3_export_location =
            (Util.option_bind (Xml.member "s3ExportLocation" xml)
               ExportTaskS3Location.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.s3_export_location
             (fun f ->
                Query.Pair
                  ("S3ExportLocation", (ExportTaskS3Location.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.export_image_task_id
             (fun f -> Query.Pair ("ExportImageTaskId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.description
                    (fun f ->
                       Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
                @
                [Util.option_map v.export_image_task_id
                   (fun f ->
                      Ezxmlm.make_tag "exportImageTaskId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.image_id
                  (fun f -> Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.progress
                 (fun f -> Ezxmlm.make_tag "progress" ([], (String.to_xml f)))])
             @
             [Util.option_map v.s3_export_location
                (fun f ->
                   Ezxmlm.make_tag "s3ExportLocation"
                     ([], (ExportTaskS3Location.to_xml f)))])
            @
            [Util.option_map v.status
               (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status_message
              (fun f ->
                 Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.s3_export_location
             (fun f ->
                ("s3_export_location", (ExportTaskS3Location.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.export_image_task_id
             (fun f -> ("export_image_task_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        export_image_task_id =
          (Util.option_map (Json.lookup j "export_image_task_id")
             String.of_json);
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        s3_export_location =
          (Util.option_map (Json.lookup j "s3_export_location")
             ExportTaskS3Location.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json)
      }
  end
module UnsuccessfulItem =
  struct
    type t =
      {
      error: UnsuccessfulItemError.t option ;
      resource_id: String.t option }
    let make ?error  ?resource_id  () = { error; resource_id }
    let parse xml =
      Some
        {
          error =
            (Util.option_bind (Xml.member "error" xml)
               UnsuccessfulItemError.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.resource_id
              (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.error
             (fun f ->
                Query.Pair ("Error", (UnsuccessfulItemError.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.error
               (fun f ->
                  Ezxmlm.make_tag "error"
                    ([], (UnsuccessfulItemError.to_xml f)))])
           @
           [Util.option_map v.resource_id
              (fun f -> Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.resource_id
              (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.error
             (fun f -> ("error", (UnsuccessfulItemError.to_json f)))])
    let of_json j =
      {
        error =
          (Util.option_map (Json.lookup j "error")
             UnsuccessfulItemError.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json)
      }
  end
module TrafficMirrorFilter =
  struct
    type t =
      {
      traffic_mirror_filter_id: String.t option ;
      ingress_filter_rules: TrafficMirrorFilterRuleList.t ;
      egress_filter_rules: TrafficMirrorFilterRuleList.t ;
      network_services: TrafficMirrorNetworkServiceList.t ;
      description: String.t option ;
      tags: TagList.t }
    let make ?traffic_mirror_filter_id  ?(ingress_filter_rules= []) 
      ?(egress_filter_rules= [])  ?(network_services= [])  ?description 
      ?(tags= [])  () =
      {
        traffic_mirror_filter_id;
        ingress_filter_rules;
        egress_filter_rules;
        network_services;
        description;
        tags
      }
    let parse xml =
      Some
        {
          traffic_mirror_filter_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterId" xml)
               String.parse);
          ingress_filter_rules =
            (Util.of_option []
               (Util.option_bind (Xml.member "ingressFilterRuleSet" xml)
                  TrafficMirrorFilterRuleList.parse));
          egress_filter_rules =
            (Util.of_option []
               (Util.option_bind (Xml.member "egressFilterRuleSet" xml)
                  TrafficMirrorFilterRuleList.parse));
          network_services =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkServiceSet" xml)
                  TrafficMirrorNetworkServiceList.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkServiceSet",
                  (TrafficMirrorNetworkServiceList.to_query
                     v.network_services)));
           Some
             (Query.Pair
                ("EgressFilterRuleSet",
                  (TrafficMirrorFilterRuleList.to_query v.egress_filter_rules)));
           Some
             (Query.Pair
                ("IngressFilterRuleSet",
                  (TrafficMirrorFilterRuleList.to_query
                     v.ingress_filter_rules)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f ->
                Query.Pair ("TrafficMirrorFilterId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.traffic_mirror_filter_id
                   (fun f ->
                      Ezxmlm.make_tag "trafficMirrorFilterId"
                        ([], (String.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "ingressFilterRuleSet"
                          ([], (TrafficMirrorFilterRuleList.to_xml [x]))))
                  v.ingress_filter_rules))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "egressFilterRuleSet"
                         ([], (TrafficMirrorFilterRuleList.to_xml [x]))))
                 v.egress_filter_rules))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "networkServiceSet"
                        ([], (TrafficMirrorNetworkServiceList.to_xml [x]))))
                v.network_services))
            @
            [Util.option_map v.description
               (fun f ->
                  Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some
             ("network_services",
               (TrafficMirrorNetworkServiceList.to_json v.network_services));
           Some
             ("egress_filter_rules",
               (TrafficMirrorFilterRuleList.to_json v.egress_filter_rules));
           Some
             ("ingress_filter_rules",
               (TrafficMirrorFilterRuleList.to_json v.ingress_filter_rules));
           Util.option_map v.traffic_mirror_filter_id
             (fun f -> ("traffic_mirror_filter_id", (String.to_json f)))])
    let of_json j =
      {
        traffic_mirror_filter_id =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_id")
             String.of_json);
        ingress_filter_rules =
          (TrafficMirrorFilterRuleList.of_json
             (Util.of_option_exn (Json.lookup j "ingress_filter_rules")));
        egress_filter_rules =
          (TrafficMirrorFilterRuleList.of_json
             (Util.of_option_exn (Json.lookup j "egress_filter_rules")));
        network_services =
          (TrafficMirrorNetworkServiceList.of_json
             (Util.of_option_exn (Json.lookup j "network_services")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module TransitGateway =
  struct
    type t =
      {
      transit_gateway_id: String.t option ;
      transit_gateway_arn: String.t option ;
      state: TransitGatewayState.t option ;
      owner_id: String.t option ;
      description: String.t option ;
      creation_time: DateTime.t option ;
      options: TransitGatewayOptions.t option ;
      tags: TagList.t }
    let make ?transit_gateway_id  ?transit_gateway_arn  ?state  ?owner_id 
      ?description  ?creation_time  ?options  ?(tags= [])  () =
      {
        transit_gateway_id;
        transit_gateway_arn;
        state;
        owner_id;
        description;
        creation_time;
        options;
        tags
      }
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          transit_gateway_arn =
            (Util.option_bind (Xml.member "transitGatewayArn" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayState.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          options =
            (Util.option_bind (Xml.member "options" xml)
               TransitGatewayOptions.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.options
             (fun f ->
                Query.Pair ("Options", (TransitGatewayOptions.to_query f)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (TransitGatewayState.to_query f)));
           Util.option_map v.transit_gateway_arn
             (fun f -> Query.Pair ("TransitGatewayArn", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.transit_gateway_id
                     (fun f ->
                        Ezxmlm.make_tag "transitGatewayId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.transit_gateway_arn
                    (fun f ->
                       Ezxmlm.make_tag "transitGatewayArn"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.state
                   (fun f ->
                      Ezxmlm.make_tag "state"
                        ([], (TransitGatewayState.to_xml f)))])
               @
               [Util.option_map v.owner_id
                  (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
             @
             [Util.option_map v.creation_time
                (fun f ->
                   Ezxmlm.make_tag "creationTime" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.options
               (fun f ->
                  Ezxmlm.make_tag "options"
                    ([], (TransitGatewayOptions.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.options
             (fun f -> ("options", (TransitGatewayOptions.to_json f)));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (TransitGatewayState.to_json f)));
           Util.option_map v.transit_gateway_arn
             (fun f -> ("transit_gateway_arn", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        transit_gateway_arn =
          (Util.option_map (Json.lookup j "transit_gateway_arn")
             String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayState.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") DateTime.of_json);
        options =
          (Util.option_map (Json.lookup j "options")
             TransitGatewayOptions.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ClientVpnAuthenticationRequest =
  struct
    type t =
      {
      type_: ClientVpnAuthenticationType.t option ;
      active_directory: DirectoryServiceAuthenticationRequest.t option ;
      mutual_authentication: CertificateAuthenticationRequest.t option }
    let make ?type_  ?active_directory  ?mutual_authentication  () =
      { type_; active_directory; mutual_authentication }
    let parse xml =
      Some
        {
          type_ =
            (Util.option_bind (Xml.member "Type" xml)
               ClientVpnAuthenticationType.parse);
          active_directory =
            (Util.option_bind (Xml.member "ActiveDirectory" xml)
               DirectoryServiceAuthenticationRequest.parse);
          mutual_authentication =
            (Util.option_bind (Xml.member "MutualAuthentication" xml)
               CertificateAuthenticationRequest.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.mutual_authentication
              (fun f ->
                 Query.Pair
                   ("MutualAuthentication",
                     (CertificateAuthenticationRequest.to_query f)));
           Util.option_map v.active_directory
             (fun f ->
                Query.Pair
                  ("ActiveDirectory",
                    (DirectoryServiceAuthenticationRequest.to_query f)));
           Util.option_map v.type_
             (fun f ->
                Query.Pair ("Type", (ClientVpnAuthenticationType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.type_
                (fun f ->
                   Ezxmlm.make_tag "Type"
                     ([], (ClientVpnAuthenticationType.to_xml f)))])
            @
            [Util.option_map v.active_directory
               (fun f ->
                  Ezxmlm.make_tag "ActiveDirectory"
                    ([], (DirectoryServiceAuthenticationRequest.to_xml f)))])
           @
           [Util.option_map v.mutual_authentication
              (fun f ->
                 Ezxmlm.make_tag "MutualAuthentication"
                   ([], (CertificateAuthenticationRequest.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.mutual_authentication
              (fun f ->
                 ("mutual_authentication",
                   (CertificateAuthenticationRequest.to_json f)));
           Util.option_map v.active_directory
             (fun f ->
                ("active_directory",
                  (DirectoryServiceAuthenticationRequest.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (ClientVpnAuthenticationType.to_json f)))])
    let of_json j =
      {
        type_ =
          (Util.option_map (Json.lookup j "type_")
             ClientVpnAuthenticationType.of_json);
        active_directory =
          (Util.option_map (Json.lookup j "active_directory")
             DirectoryServiceAuthenticationRequest.of_json);
        mutual_authentication =
          (Util.option_map (Json.lookup j "mutual_authentication")
             CertificateAuthenticationRequest.of_json)
      }
  end
module ClassicLinkDnsSupport =
  struct
    type t =
      {
      classic_link_dns_supported: Boolean.t option ;
      vpc_id: String.t option }
    let make ?classic_link_dns_supported  ?vpc_id  () =
      { classic_link_dns_supported; vpc_id }
    let parse xml =
      Some
        {
          classic_link_dns_supported =
            (Util.option_bind (Xml.member "classicLinkDnsSupported" xml)
               Boolean.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.classic_link_dns_supported
             (fun f ->
                Query.Pair ("ClassicLinkDnsSupported", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.classic_link_dns_supported
               (fun f ->
                  Ezxmlm.make_tag "classicLinkDnsSupported"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.classic_link_dns_supported
             (fun f -> ("classic_link_dns_supported", (Boolean.to_json f)))])
    let of_json j =
      {
        classic_link_dns_supported =
          (Util.option_map (Json.lookup j "classic_link_dns_supported")
             Boolean.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module ReservedInstancesListing =
  struct
    type t =
      {
      client_token: String.t option ;
      create_date: DateTime.t option ;
      instance_counts: InstanceCountList.t ;
      price_schedules: PriceScheduleList.t ;
      reserved_instances_id: String.t option ;
      reserved_instances_listing_id: String.t option ;
      status: ListingStatus.t option ;
      status_message: String.t option ;
      tags: TagList.t ;
      update_date: DateTime.t option }
    let make ?client_token  ?create_date  ?(instance_counts= []) 
      ?(price_schedules= [])  ?reserved_instances_id 
      ?reserved_instances_listing_id  ?status  ?status_message  ?(tags= []) 
      ?update_date  () =
      {
        client_token;
        create_date;
        instance_counts;
        price_schedules;
        reserved_instances_id;
        reserved_instances_listing_id;
        status;
        status_message;
        tags;
        update_date
      }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          create_date =
            (Util.option_bind (Xml.member "createDate" xml) DateTime.parse);
          instance_counts =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceCounts" xml)
                  InstanceCountList.parse));
          price_schedules =
            (Util.of_option []
               (Util.option_bind (Xml.member "priceSchedules" xml)
                  PriceScheduleList.parse));
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse);
          reserved_instances_listing_id =
            (Util.option_bind (Xml.member "reservedInstancesListingId" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml) ListingStatus.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          update_date =
            (Util.option_bind (Xml.member "updateDate" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.update_date
              (fun f -> Query.Pair ("UpdateDate", (DateTime.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (ListingStatus.to_query f)));
           Util.option_map v.reserved_instances_listing_id
             (fun f ->
                Query.Pair
                  ("ReservedInstancesListingId", (String.to_query f)));
           Util.option_map v.reserved_instances_id
             (fun f ->
                Query.Pair ("ReservedInstancesId", (String.to_query f)));
           Some
             (Query.Pair
                ("PriceSchedules",
                  (PriceScheduleList.to_query v.price_schedules)));
           Some
             (Query.Pair
                ("InstanceCounts",
                  (InstanceCountList.to_query v.instance_counts)));
           Util.option_map v.create_date
             (fun f -> Query.Pair ("CreateDate", (DateTime.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.client_token
                       (fun f ->
                          Ezxmlm.make_tag "clientToken"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.create_date
                      (fun f ->
                         Ezxmlm.make_tag "createDate"
                           ([], (DateTime.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "instanceCounts"
                             ([], (InstanceCountList.to_xml [x]))))
                     v.instance_counts))
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "priceSchedules"
                            ([], (PriceScheduleList.to_xml [x]))))
                    v.price_schedules))
                @
                [Util.option_map v.reserved_instances_id
                   (fun f ->
                      Ezxmlm.make_tag "reservedInstancesId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.reserved_instances_listing_id
                  (fun f ->
                     Ezxmlm.make_tag "reservedInstancesListingId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.status
                 (fun f ->
                    Ezxmlm.make_tag "status" ([], (ListingStatus.to_xml f)))])
             @
             [Util.option_map v.status_message
                (fun f ->
                   Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           [Util.option_map v.update_date
              (fun f ->
                 Ezxmlm.make_tag "updateDate" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.update_date
              (fun f -> ("update_date", (DateTime.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ListingStatus.to_json f)));
           Util.option_map v.reserved_instances_listing_id
             (fun f -> ("reserved_instances_listing_id", (String.to_json f)));
           Util.option_map v.reserved_instances_id
             (fun f -> ("reserved_instances_id", (String.to_json f)));
           Some
             ("price_schedules",
               (PriceScheduleList.to_json v.price_schedules));
           Some
             ("instance_counts",
               (InstanceCountList.to_json v.instance_counts));
           Util.option_map v.create_date
             (fun f -> ("create_date", (DateTime.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        create_date =
          (Util.option_map (Json.lookup j "create_date") DateTime.of_json);
        instance_counts =
          (InstanceCountList.of_json
             (Util.of_option_exn (Json.lookup j "instance_counts")));
        price_schedules =
          (PriceScheduleList.of_json
             (Util.of_option_exn (Json.lookup j "price_schedules")));
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json);
        reserved_instances_listing_id =
          (Util.option_map (Json.lookup j "reserved_instances_listing_id")
             String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") ListingStatus.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        update_date =
          (Util.option_map (Json.lookup j "update_date") DateTime.of_json)
      }
  end
module InstanceStateChange =
  struct
    type t =
      {
      current_state: InstanceState.t option ;
      instance_id: String.t option ;
      previous_state: InstanceState.t option }
    let make ?current_state  ?instance_id  ?previous_state  () =
      { current_state; instance_id; previous_state }
    let parse xml =
      Some
        {
          current_state =
            (Util.option_bind (Xml.member "currentState" xml)
               InstanceState.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          previous_state =
            (Util.option_bind (Xml.member "previousState" xml)
               InstanceState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.previous_state
              (fun f ->
                 Query.Pair ("PreviousState", (InstanceState.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.current_state
             (fun f ->
                Query.Pair ("CurrentState", (InstanceState.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.current_state
                (fun f ->
                   Ezxmlm.make_tag "currentState"
                     ([], (InstanceState.to_xml f)))])
            @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.previous_state
              (fun f ->
                 Ezxmlm.make_tag "previousState"
                   ([], (InstanceState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.previous_state
              (fun f -> ("previous_state", (InstanceState.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.current_state
             (fun f -> ("current_state", (InstanceState.to_json f)))])
    let of_json j =
      {
        current_state =
          (Util.option_map (Json.lookup j "current_state")
             InstanceState.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        previous_state =
          (Util.option_map (Json.lookup j "previous_state")
             InstanceState.of_json)
      }
  end
module ClientCertificateRevocationListStatusCode =
  struct
    type t =
      | Pending 
      | Active 
    let str_to_t = [("active", Active); ("pending", Pending)]
    let t_to_str = [(Active, "active"); (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TerminateConnectionStatus =
  struct
    type t =
      {
      connection_id: String.t option ;
      previous_status: ClientVpnConnectionStatus.t option ;
      current_status: ClientVpnConnectionStatus.t option }
    let make ?connection_id  ?previous_status  ?current_status  () =
      { connection_id; previous_status; current_status }
    let parse xml =
      Some
        {
          connection_id =
            (Util.option_bind (Xml.member "connectionId" xml) String.parse);
          previous_status =
            (Util.option_bind (Xml.member "previousStatus" xml)
               ClientVpnConnectionStatus.parse);
          current_status =
            (Util.option_bind (Xml.member "currentStatus" xml)
               ClientVpnConnectionStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.current_status
              (fun f ->
                 Query.Pair
                   ("CurrentStatus", (ClientVpnConnectionStatus.to_query f)));
           Util.option_map v.previous_status
             (fun f ->
                Query.Pair
                  ("PreviousStatus", (ClientVpnConnectionStatus.to_query f)));
           Util.option_map v.connection_id
             (fun f -> Query.Pair ("ConnectionId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.connection_id
                (fun f ->
                   Ezxmlm.make_tag "connectionId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.previous_status
               (fun f ->
                  Ezxmlm.make_tag "previousStatus"
                    ([], (ClientVpnConnectionStatus.to_xml f)))])
           @
           [Util.option_map v.current_status
              (fun f ->
                 Ezxmlm.make_tag "currentStatus"
                   ([], (ClientVpnConnectionStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.current_status
              (fun f ->
                 ("current_status", (ClientVpnConnectionStatus.to_json f)));
           Util.option_map v.previous_status
             (fun f ->
                ("previous_status", (ClientVpnConnectionStatus.to_json f)));
           Util.option_map v.connection_id
             (fun f -> ("connection_id", (String.to_json f)))])
    let of_json j =
      {
        connection_id =
          (Util.option_map (Json.lookup j "connection_id") String.of_json);
        previous_status =
          (Util.option_map (Json.lookup j "previous_status")
             ClientVpnConnectionStatus.of_json);
        current_status =
          (Util.option_map (Json.lookup j "current_status")
             ClientVpnConnectionStatus.of_json)
      }
  end
module InstanceTypeOffering =
  struct
    type t =
      {
      instance_type: InstanceType.t option ;
      location_type: LocationType.t option ;
      location: String.t option }
    let make ?instance_type  ?location_type  ?location  () =
      { instance_type; location_type; location }
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          location_type =
            (Util.option_bind (Xml.member "locationType" xml)
               LocationType.parse);
          location =
            (Util.option_bind (Xml.member "location" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.location
              (fun f -> Query.Pair ("Location", (String.to_query f)));
           Util.option_map v.location_type
             (fun f -> Query.Pair ("LocationType", (LocationType.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.instance_type
                (fun f ->
                   Ezxmlm.make_tag "instanceType"
                     ([], (InstanceType.to_xml f)))])
            @
            [Util.option_map v.location_type
               (fun f ->
                  Ezxmlm.make_tag "locationType"
                    ([], (LocationType.to_xml f)))])
           @
           [Util.option_map v.location
              (fun f -> Ezxmlm.make_tag "location" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.location
              (fun f -> ("location", (String.to_json f)));
           Util.option_map v.location_type
             (fun f -> ("location_type", (LocationType.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)))])
    let of_json j =
      {
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        location_type =
          (Util.option_map (Json.lookup j "location_type")
             LocationType.of_json);
        location =
          (Util.option_map (Json.lookup j "location") String.of_json)
      }
  end
module InstanceStatus =
  struct
    type t =
      {
      availability_zone: String.t option ;
      outpost_arn: String.t option ;
      events: InstanceStatusEventList.t ;
      instance_id: String.t option ;
      instance_state: InstanceState.t option ;
      instance_status: InstanceStatusSummary.t option ;
      system_status: InstanceStatusSummary.t option }
    let make ?availability_zone  ?outpost_arn  ?(events= [])  ?instance_id 
      ?instance_state  ?instance_status  ?system_status  () =
      {
        availability_zone;
        outpost_arn;
        events;
        instance_id;
        instance_state;
        instance_status;
        system_status
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          events =
            (Util.of_option []
               (Util.option_bind (Xml.member "eventsSet" xml)
                  InstanceStatusEventList.parse));
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_state =
            (Util.option_bind (Xml.member "instanceState" xml)
               InstanceState.parse);
          instance_status =
            (Util.option_bind (Xml.member "instanceStatus" xml)
               InstanceStatusSummary.parse);
          system_status =
            (Util.option_bind (Xml.member "systemStatus" xml)
               InstanceStatusSummary.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.system_status
              (fun f ->
                 Query.Pair
                   ("SystemStatus", (InstanceStatusSummary.to_query f)));
           Util.option_map v.instance_status
             (fun f ->
                Query.Pair
                  ("InstanceStatus", (InstanceStatusSummary.to_query f)));
           Util.option_map v.instance_state
             (fun f ->
                Query.Pair ("InstanceState", (InstanceState.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Some
             (Query.Pair
                ("EventsSet", (InstanceStatusEventList.to_query v.events)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.availability_zone
                    (fun f ->
                       Ezxmlm.make_tag "availabilityZone"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.outpost_arn
                   (fun f ->
                      Ezxmlm.make_tag "outpostArn" ([], (String.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "eventsSet"
                          ([], (InstanceStatusEventList.to_xml [x]))))
                  v.events))
              @
              [Util.option_map v.instance_id
                 (fun f ->
                    Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.instance_state
                (fun f ->
                   Ezxmlm.make_tag "instanceState"
                     ([], (InstanceState.to_xml f)))])
            @
            [Util.option_map v.instance_status
               (fun f ->
                  Ezxmlm.make_tag "instanceStatus"
                    ([], (InstanceStatusSummary.to_xml f)))])
           @
           [Util.option_map v.system_status
              (fun f ->
                 Ezxmlm.make_tag "systemStatus"
                   ([], (InstanceStatusSummary.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.system_status
              (fun f -> ("system_status", (InstanceStatusSummary.to_json f)));
           Util.option_map v.instance_status
             (fun f -> ("instance_status", (InstanceStatusSummary.to_json f)));
           Util.option_map v.instance_state
             (fun f -> ("instance_state", (InstanceState.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Some ("events", (InstanceStatusEventList.to_json v.events));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        events =
          (InstanceStatusEventList.of_json
             (Util.of_option_exn (Json.lookup j "events")));
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_state =
          (Util.option_map (Json.lookup j "instance_state")
             InstanceState.of_json);
        instance_status =
          (Util.option_map (Json.lookup j "instance_status")
             InstanceStatusSummary.of_json);
        system_status =
          (Util.option_map (Json.lookup j "system_status")
             InstanceStatusSummary.of_json)
      }
  end
module Image =
  struct
    type t =
      {
      architecture: ArchitectureValues.t ;
      creation_date: String.t option ;
      image_id: String.t ;
      image_location: String.t ;
      image_type: ImageTypeValues.t ;
      public: Boolean.t ;
      kernel_id: String.t option ;
      owner_id: String.t ;
      platform: PlatformValues.t option ;
      product_codes: ProductCodeList.t ;
      ramdisk_id: String.t option ;
      state: ImageState.t ;
      block_device_mappings: BlockDeviceMappingList.t ;
      description: String.t option ;
      ena_support: Boolean.t option ;
      hypervisor: HypervisorType.t ;
      image_owner_alias: String.t option ;
      name: String.t option ;
      root_device_name: String.t option ;
      root_device_type: DeviceType.t ;
      sriov_net_support: String.t option ;
      state_reason: StateReason.t option ;
      tags: TagList.t ;
      virtualization_type: VirtualizationType.t }
    let make ~architecture  ?creation_date  ~image_id  ~image_location 
      ~image_type  ~public  ?kernel_id  ~owner_id  ?platform 
      ?(product_codes= [])  ?ramdisk_id  ~state  ?(block_device_mappings= [])
       ?description  ?ena_support  ~hypervisor  ?image_owner_alias  ?name 
      ?root_device_name  ~root_device_type  ?sriov_net_support  ?state_reason
       ?(tags= [])  ~virtualization_type  () =
      {
        architecture;
        creation_date;
        image_id;
        image_location;
        image_type;
        public;
        kernel_id;
        owner_id;
        platform;
        product_codes;
        ramdisk_id;
        state;
        block_device_mappings;
        description;
        ena_support;
        hypervisor;
        image_owner_alias;
        name;
        root_device_name;
        root_device_type;
        sriov_net_support;
        state_reason;
        tags;
        virtualization_type
      }
    let parse xml =
      Some
        {
          architecture =
            (Xml.required "architecture"
               (Util.option_bind (Xml.member "architecture" xml)
                  ArchitectureValues.parse));
          creation_date =
            (Util.option_bind (Xml.member "creationDate" xml) String.parse);
          image_id =
            (Xml.required "imageId"
               (Util.option_bind (Xml.member "imageId" xml) String.parse));
          image_location =
            (Xml.required "imageLocation"
               (Util.option_bind (Xml.member "imageLocation" xml)
                  String.parse));
          image_type =
            (Xml.required "imageType"
               (Util.option_bind (Xml.member "imageType" xml)
                  ImageTypeValues.parse));
          public =
            (Xml.required "isPublic"
               (Util.option_bind (Xml.member "isPublic" xml) Boolean.parse));
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          owner_id =
            (Xml.required "imageOwnerId"
               (Util.option_bind (Xml.member "imageOwnerId" xml) String.parse));
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          state =
            (Xml.required "imageState"
               (Util.option_bind (Xml.member "imageState" xml)
                  ImageState.parse));
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          ena_support =
            (Util.option_bind (Xml.member "enaSupport" xml) Boolean.parse);
          hypervisor =
            (Xml.required "hypervisor"
               (Util.option_bind (Xml.member "hypervisor" xml)
                  HypervisorType.parse));
          image_owner_alias =
            (Util.option_bind (Xml.member "imageOwnerAlias" xml) String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          root_device_name =
            (Util.option_bind (Xml.member "rootDeviceName" xml) String.parse);
          root_device_type =
            (Xml.required "rootDeviceType"
               (Util.option_bind (Xml.member "rootDeviceType" xml)
                  DeviceType.parse));
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml) String.parse);
          state_reason =
            (Util.option_bind (Xml.member "stateReason" xml)
               StateReason.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          virtualization_type =
            (Xml.required "virtualizationType"
               (Util.option_bind (Xml.member "virtualizationType" xml)
                  VirtualizationType.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VirtualizationType",
                   (VirtualizationType.to_query v.virtualization_type)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.state_reason
             (fun f -> Query.Pair ("StateReason", (StateReason.to_query f)));
           Util.option_map v.sriov_net_support
             (fun f -> Query.Pair ("SriovNetSupport", (String.to_query f)));
           Some
             (Query.Pair
                ("RootDeviceType", (DeviceType.to_query v.root_device_type)));
           Util.option_map v.root_device_name
             (fun f -> Query.Pair ("RootDeviceName", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.image_owner_alias
             (fun f -> Query.Pair ("ImageOwnerAlias", (String.to_query f)));
           Some
             (Query.Pair
                ("Hypervisor", (HypervisorType.to_query v.hypervisor)));
           Util.option_map v.ena_support
             (fun f -> Query.Pair ("EnaSupport", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Some (Query.Pair ("ImageState", (ImageState.to_query v.state)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Some (Query.Pair ("ImageOwnerId", (String.to_query v.owner_id)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Some (Query.Pair ("IsPublic", (Boolean.to_query v.public)));
           Some
             (Query.Pair
                ("ImageType", (ImageTypeValues.to_query v.image_type)));
           Some
             (Query.Pair
                ("ImageLocation", (String.to_query v.image_location)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Util.option_map v.creation_date
             (fun f -> Query.Pair ("CreationDate", (String.to_query f)));
           Some
             (Query.Pair
                ("Architecture",
                  (ArchitectureValues.to_query v.architecture)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((((((((([] @
                                  [Some
                                     (Ezxmlm.make_tag "architecture"
                                        ([],
                                          (ArchitectureValues.to_xml
                                             v.architecture)))])
                                 @
                                 [Util.option_map v.creation_date
                                    (fun f ->
                                       Ezxmlm.make_tag "creationDate"
                                         ([], (String.to_xml f)))])
                                @
                                [Some
                                   (Ezxmlm.make_tag "imageId"
                                      ([], (String.to_xml v.image_id)))])
                               @
                               [Some
                                  (Ezxmlm.make_tag "imageLocation"
                                     ([], (String.to_xml v.image_location)))])
                              @
                              [Some
                                 (Ezxmlm.make_tag "imageType"
                                    ([],
                                      (ImageTypeValues.to_xml v.image_type)))])
                             @
                             [Some
                                (Ezxmlm.make_tag "isPublic"
                                   ([], (Boolean.to_xml v.public)))])
                            @
                            [Util.option_map v.kernel_id
                               (fun f ->
                                  Ezxmlm.make_tag "kernelId"
                                    ([], (String.to_xml f)))])
                           @
                           [Some
                              (Ezxmlm.make_tag "imageOwnerId"
                                 ([], (String.to_xml v.owner_id)))])
                          @
                          [Util.option_map v.platform
                             (fun f ->
                                Ezxmlm.make_tag "platform"
                                  ([], (PlatformValues.to_xml f)))])
                         @
                         (List.map
                            (fun x ->
                               Some
                                 (Ezxmlm.make_tag "productCodes"
                                    ([], (ProductCodeList.to_xml [x]))))
                            v.product_codes))
                        @
                        [Util.option_map v.ramdisk_id
                           (fun f ->
                              Ezxmlm.make_tag "ramdiskId"
                                ([], (String.to_xml f)))])
                       @
                       [Some
                          (Ezxmlm.make_tag "imageState"
                             ([], (ImageState.to_xml v.state)))])
                      @
                      (List.map
                         (fun x ->
                            Some
                              (Ezxmlm.make_tag "blockDeviceMapping"
                                 ([], (BlockDeviceMappingList.to_xml [x]))))
                         v.block_device_mappings))
                     @
                     [Util.option_map v.description
                        (fun f ->
                           Ezxmlm.make_tag "description"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.ena_support
                       (fun f ->
                          Ezxmlm.make_tag "enaSupport"
                            ([], (Boolean.to_xml f)))])
                   @
                   [Some
                      (Ezxmlm.make_tag "hypervisor"
                         ([], (HypervisorType.to_xml v.hypervisor)))])
                  @
                  [Util.option_map v.image_owner_alias
                     (fun f ->
                        Ezxmlm.make_tag "imageOwnerAlias"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.name
                    (fun f -> Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
                @
                [Util.option_map v.root_device_name
                   (fun f ->
                      Ezxmlm.make_tag "rootDeviceName"
                        ([], (String.to_xml f)))])
               @
               [Some
                  (Ezxmlm.make_tag "rootDeviceType"
                     ([], (DeviceType.to_xml v.root_device_type)))])
              @
              [Util.option_map v.sriov_net_support
                 (fun f ->
                    Ezxmlm.make_tag "sriovNetSupport" ([], (String.to_xml f)))])
             @
             [Util.option_map v.state_reason
                (fun f ->
                   Ezxmlm.make_tag "stateReason" ([], (StateReason.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           [Some
              (Ezxmlm.make_tag "virtualizationType"
                 ([], (VirtualizationType.to_xml v.virtualization_type)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("virtualization_type",
                (VirtualizationType.to_json v.virtualization_type));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.state_reason
             (fun f -> ("state_reason", (StateReason.to_json f)));
           Util.option_map v.sriov_net_support
             (fun f -> ("sriov_net_support", (String.to_json f)));
           Some ("root_device_type", (DeviceType.to_json v.root_device_type));
           Util.option_map v.root_device_name
             (fun f -> ("root_device_name", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.image_owner_alias
             (fun f -> ("image_owner_alias", (String.to_json f)));
           Some ("hypervisor", (HypervisorType.to_json v.hypervisor));
           Util.option_map v.ena_support
             (fun f -> ("ena_support", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings));
           Some ("state", (ImageState.to_json v.state));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Util.option_map v.platform
             (fun f -> ("platform", (PlatformValues.to_json f)));
           Some ("owner_id", (String.to_json v.owner_id));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Some ("public", (Boolean.to_json v.public));
           Some ("image_type", (ImageTypeValues.to_json v.image_type));
           Some ("image_location", (String.to_json v.image_location));
           Some ("image_id", (String.to_json v.image_id));
           Util.option_map v.creation_date
             (fun f -> ("creation_date", (String.to_json f)));
           Some ("architecture", (ArchitectureValues.to_json v.architecture))])
    let of_json j =
      {
        architecture =
          (ArchitectureValues.of_json
             (Util.of_option_exn (Json.lookup j "architecture")));
        creation_date =
          (Util.option_map (Json.lookup j "creation_date") String.of_json);
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        image_location =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "image_location")));
        image_type =
          (ImageTypeValues.of_json
             (Util.of_option_exn (Json.lookup j "image_type")));
        public =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "public")));
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        owner_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "owner_id")));
        platform =
          (Util.option_map (Json.lookup j "platform") PlatformValues.of_json);
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        state =
          (ImageState.of_json (Util.of_option_exn (Json.lookup j "state")));
        block_device_mappings =
          (BlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        ena_support =
          (Util.option_map (Json.lookup j "ena_support") Boolean.of_json);
        hypervisor =
          (HypervisorType.of_json
             (Util.of_option_exn (Json.lookup j "hypervisor")));
        image_owner_alias =
          (Util.option_map (Json.lookup j "image_owner_alias") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        root_device_name =
          (Util.option_map (Json.lookup j "root_device_name") String.of_json);
        root_device_type =
          (DeviceType.of_json
             (Util.of_option_exn (Json.lookup j "root_device_type")));
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support") String.of_json);
        state_reason =
          (Util.option_map (Json.lookup j "state_reason") StateReason.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        virtualization_type =
          (VirtualizationType.of_json
             (Util.of_option_exn (Json.lookup j "virtualization_type")))
      }
  end
module PriceScheduleSpecification =
  struct
    type t =
      {
      currency_code: CurrencyCodeValues.t option ;
      price: Double.t option ;
      term: Long.t option }
    let make ?currency_code  ?price  ?term  () =
      { currency_code; price; term }
    let parse xml =
      Some
        {
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          price = (Util.option_bind (Xml.member "price" xml) Double.parse);
          term = (Util.option_bind (Xml.member "term" xml) Long.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.term
              (fun f -> Query.Pair ("Term", (Long.to_query f)));
           Util.option_map v.price
             (fun f -> Query.Pair ("Price", (Double.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.currency_code
                (fun f ->
                   Ezxmlm.make_tag "currencyCode"
                     ([], (CurrencyCodeValues.to_xml f)))])
            @
            [Util.option_map v.price
               (fun f -> Ezxmlm.make_tag "price" ([], (Double.to_xml f)))])
           @
           [Util.option_map v.term
              (fun f -> Ezxmlm.make_tag "term" ([], (Long.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.term (fun f -> ("term", (Long.to_json f)));
           Util.option_map v.price (fun f -> ("price", (Double.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)))])
    let of_json j =
      {
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        price = (Util.option_map (Json.lookup j "price") Double.of_json);
        term = (Util.option_map (Json.lookup j "term") Long.of_json)
      }
  end
module ImportSnapshotTask =
  struct
    type t =
      {
      description: String.t option ;
      import_task_id: String.t option ;
      snapshot_task_detail: SnapshotTaskDetail.t option ;
      tags: TagList.t }
    let make ?description  ?import_task_id  ?snapshot_task_detail  ?(tags=
      [])  () = { description; import_task_id; snapshot_task_detail; tags }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          snapshot_task_detail =
            (Util.option_bind (Xml.member "snapshotTaskDetail" xml)
               SnapshotTaskDetail.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.snapshot_task_detail
             (fun f ->
                Query.Pair
                  ("SnapshotTaskDetail", (SnapshotTaskDetail.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
             @
             [Util.option_map v.import_task_id
                (fun f ->
                   Ezxmlm.make_tag "importTaskId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.snapshot_task_detail
               (fun f ->
                  Ezxmlm.make_tag "snapshotTaskDetail"
                    ([], (SnapshotTaskDetail.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.snapshot_task_detail
             (fun f ->
                ("snapshot_task_detail", (SnapshotTaskDetail.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json);
        snapshot_task_detail =
          (Util.option_map (Json.lookup j "snapshot_task_detail")
             SnapshotTaskDetail.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module NetworkInterfacePermission =
  struct
    type t =
      {
      network_interface_permission_id: String.t option ;
      network_interface_id: String.t option ;
      aws_account_id: String.t option ;
      aws_service: String.t option ;
      permission: InterfacePermissionType.t option ;
      permission_state: NetworkInterfacePermissionState.t option }
    let make ?network_interface_permission_id  ?network_interface_id 
      ?aws_account_id  ?aws_service  ?permission  ?permission_state  () =
      {
        network_interface_permission_id;
        network_interface_id;
        aws_account_id;
        aws_service;
        permission;
        permission_state
      }
    let parse xml =
      Some
        {
          network_interface_permission_id =
            (Util.option_bind (Xml.member "networkInterfacePermissionId" xml)
               String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          aws_account_id =
            (Util.option_bind (Xml.member "awsAccountId" xml) String.parse);
          aws_service =
            (Util.option_bind (Xml.member "awsService" xml) String.parse);
          permission =
            (Util.option_bind (Xml.member "permission" xml)
               InterfacePermissionType.parse);
          permission_state =
            (Util.option_bind (Xml.member "permissionState" xml)
               NetworkInterfacePermissionState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.permission_state
              (fun f ->
                 Query.Pair
                   ("PermissionState",
                     (NetworkInterfacePermissionState.to_query f)));
           Util.option_map v.permission
             (fun f ->
                Query.Pair
                  ("Permission", (InterfacePermissionType.to_query f)));
           Util.option_map v.aws_service
             (fun f -> Query.Pair ("AwsService", (String.to_query f)));
           Util.option_map v.aws_account_id
             (fun f -> Query.Pair ("AwsAccountId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.network_interface_permission_id
             (fun f ->
                Query.Pair
                  ("NetworkInterfacePermissionId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.network_interface_permission_id
                   (fun f ->
                      Ezxmlm.make_tag "networkInterfacePermissionId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.network_interface_id
                  (fun f ->
                     Ezxmlm.make_tag "networkInterfaceId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.aws_account_id
                 (fun f ->
                    Ezxmlm.make_tag "awsAccountId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.aws_service
                (fun f ->
                   Ezxmlm.make_tag "awsService" ([], (String.to_xml f)))])
            @
            [Util.option_map v.permission
               (fun f ->
                  Ezxmlm.make_tag "permission"
                    ([], (InterfacePermissionType.to_xml f)))])
           @
           [Util.option_map v.permission_state
              (fun f ->
                 Ezxmlm.make_tag "permissionState"
                   ([], (NetworkInterfacePermissionState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.permission_state
              (fun f ->
                 ("permission_state",
                   (NetworkInterfacePermissionState.to_json f)));
           Util.option_map v.permission
             (fun f -> ("permission", (InterfacePermissionType.to_json f)));
           Util.option_map v.aws_service
             (fun f -> ("aws_service", (String.to_json f)));
           Util.option_map v.aws_account_id
             (fun f -> ("aws_account_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.network_interface_permission_id
             (fun f ->
                ("network_interface_permission_id", (String.to_json f)))])
    let of_json j =
      {
        network_interface_permission_id =
          (Util.option_map (Json.lookup j "network_interface_permission_id")
             String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        aws_account_id =
          (Util.option_map (Json.lookup j "aws_account_id") String.of_json);
        aws_service =
          (Util.option_map (Json.lookup j "aws_service") String.of_json);
        permission =
          (Util.option_map (Json.lookup j "permission")
             InterfacePermissionType.of_json);
        permission_state =
          (Util.option_map (Json.lookup j "permission_state")
             NetworkInterfacePermissionState.of_json)
      }
  end
module Host =
  struct
    type t =
      {
      auto_placement: AutoPlacement.t option ;
      availability_zone: String.t option ;
      available_capacity: AvailableCapacity.t option ;
      client_token: String.t option ;
      host_id: String.t option ;
      host_properties: HostProperties.t option ;
      host_reservation_id: String.t option ;
      instances: HostInstanceList.t ;
      state: AllocationState.t option ;
      allocation_time: DateTime.t option ;
      release_time: DateTime.t option ;
      tags: TagList.t ;
      host_recovery: HostRecovery.t option ;
      allows_multiple_instance_types: AllowsMultipleInstanceTypes.t option ;
      owner_id: String.t option ;
      availability_zone_id: String.t option ;
      member_of_service_linked_resource_group: Boolean.t option }
    let make ?auto_placement  ?availability_zone  ?available_capacity 
      ?client_token  ?host_id  ?host_properties  ?host_reservation_id 
      ?(instances= [])  ?state  ?allocation_time  ?release_time  ?(tags= []) 
      ?host_recovery  ?allows_multiple_instance_types  ?owner_id 
      ?availability_zone_id  ?member_of_service_linked_resource_group  () =
      {
        auto_placement;
        availability_zone;
        available_capacity;
        client_token;
        host_id;
        host_properties;
        host_reservation_id;
        instances;
        state;
        allocation_time;
        release_time;
        tags;
        host_recovery;
        allows_multiple_instance_types;
        owner_id;
        availability_zone_id;
        member_of_service_linked_resource_group
      }
    let parse xml =
      Some
        {
          auto_placement =
            (Util.option_bind (Xml.member "autoPlacement" xml)
               AutoPlacement.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          available_capacity =
            (Util.option_bind (Xml.member "availableCapacity" xml)
               AvailableCapacity.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          host_id = (Util.option_bind (Xml.member "hostId" xml) String.parse);
          host_properties =
            (Util.option_bind (Xml.member "hostProperties" xml)
               HostProperties.parse);
          host_reservation_id =
            (Util.option_bind (Xml.member "hostReservationId" xml)
               String.parse);
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instances" xml)
                  HostInstanceList.parse));
          state =
            (Util.option_bind (Xml.member "state" xml) AllocationState.parse);
          allocation_time =
            (Util.option_bind (Xml.member "allocationTime" xml)
               DateTime.parse);
          release_time =
            (Util.option_bind (Xml.member "releaseTime" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          host_recovery =
            (Util.option_bind (Xml.member "hostRecovery" xml)
               HostRecovery.parse);
          allows_multiple_instance_types =
            (Util.option_bind (Xml.member "allowsMultipleInstanceTypes" xml)
               AllowsMultipleInstanceTypes.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          availability_zone_id =
            (Util.option_bind (Xml.member "availabilityZoneId" xml)
               String.parse);
          member_of_service_linked_resource_group =
            (Util.option_bind
               (Xml.member "memberOfServiceLinkedResourceGroup" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.member_of_service_linked_resource_group
              (fun f ->
                 Query.Pair
                   ("MemberOfServiceLinkedResourceGroup",
                     (Boolean.to_query f)));
           Util.option_map v.availability_zone_id
             (fun f -> Query.Pair ("AvailabilityZoneId", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.allows_multiple_instance_types
             (fun f ->
                Query.Pair
                  ("AllowsMultipleInstanceTypes",
                    (AllowsMultipleInstanceTypes.to_query f)));
           Util.option_map v.host_recovery
             (fun f -> Query.Pair ("HostRecovery", (HostRecovery.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.release_time
             (fun f -> Query.Pair ("ReleaseTime", (DateTime.to_query f)));
           Util.option_map v.allocation_time
             (fun f -> Query.Pair ("AllocationTime", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (AllocationState.to_query f)));
           Some
             (Query.Pair
                ("Instances", (HostInstanceList.to_query v.instances)));
           Util.option_map v.host_reservation_id
             (fun f -> Query.Pair ("HostReservationId", (String.to_query f)));
           Util.option_map v.host_properties
             (fun f ->
                Query.Pair ("HostProperties", (HostProperties.to_query f)));
           Util.option_map v.host_id
             (fun f -> Query.Pair ("HostId", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.available_capacity
             (fun f ->
                Query.Pair
                  ("AvailableCapacity", (AvailableCapacity.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.auto_placement
             (fun f ->
                Query.Pair ("AutoPlacement", (AutoPlacement.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((([] @
                           [Util.option_map v.auto_placement
                              (fun f ->
                                 Ezxmlm.make_tag "autoPlacement"
                                   ([], (AutoPlacement.to_xml f)))])
                          @
                          [Util.option_map v.availability_zone
                             (fun f ->
                                Ezxmlm.make_tag "availabilityZone"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.available_capacity
                            (fun f ->
                               Ezxmlm.make_tag "availableCapacity"
                                 ([], (AvailableCapacity.to_xml f)))])
                        @
                        [Util.option_map v.client_token
                           (fun f ->
                              Ezxmlm.make_tag "clientToken"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.host_id
                          (fun f ->
                             Ezxmlm.make_tag "hostId" ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.host_properties
                         (fun f ->
                            Ezxmlm.make_tag "hostProperties"
                              ([], (HostProperties.to_xml f)))])
                     @
                     [Util.option_map v.host_reservation_id
                        (fun f ->
                           Ezxmlm.make_tag "hostReservationId"
                             ([], (String.to_xml f)))])
                    @
                    (List.map
                       (fun x ->
                          Some
                            (Ezxmlm.make_tag "instances"
                               ([], (HostInstanceList.to_xml [x]))))
                       v.instances))
                   @
                   [Util.option_map v.state
                      (fun f ->
                         Ezxmlm.make_tag "state"
                           ([], (AllocationState.to_xml f)))])
                  @
                  [Util.option_map v.allocation_time
                     (fun f ->
                        Ezxmlm.make_tag "allocationTime"
                          ([], (DateTime.to_xml f)))])
                 @
                 [Util.option_map v.release_time
                    (fun f ->
                       Ezxmlm.make_tag "releaseTime"
                         ([], (DateTime.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
                   v.tags))
               @
               [Util.option_map v.host_recovery
                  (fun f ->
                     Ezxmlm.make_tag "hostRecovery"
                       ([], (HostRecovery.to_xml f)))])
              @
              [Util.option_map v.allows_multiple_instance_types
                 (fun f ->
                    Ezxmlm.make_tag "allowsMultipleInstanceTypes"
                      ([], (AllowsMultipleInstanceTypes.to_xml f)))])
             @
             [Util.option_map v.owner_id
                (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.availability_zone_id
               (fun f ->
                  Ezxmlm.make_tag "availabilityZoneId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.member_of_service_linked_resource_group
              (fun f ->
                 Ezxmlm.make_tag "memberOfServiceLinkedResourceGroup"
                   ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.member_of_service_linked_resource_group
              (fun f ->
                 ("member_of_service_linked_resource_group",
                   (Boolean.to_json f)));
           Util.option_map v.availability_zone_id
             (fun f -> ("availability_zone_id", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.allows_multiple_instance_types
             (fun f ->
                ("allows_multiple_instance_types",
                  (AllowsMultipleInstanceTypes.to_json f)));
           Util.option_map v.host_recovery
             (fun f -> ("host_recovery", (HostRecovery.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.release_time
             (fun f -> ("release_time", (DateTime.to_json f)));
           Util.option_map v.allocation_time
             (fun f -> ("allocation_time", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (AllocationState.to_json f)));
           Some ("instances", (HostInstanceList.to_json v.instances));
           Util.option_map v.host_reservation_id
             (fun f -> ("host_reservation_id", (String.to_json f)));
           Util.option_map v.host_properties
             (fun f -> ("host_properties", (HostProperties.to_json f)));
           Util.option_map v.host_id
             (fun f -> ("host_id", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.available_capacity
             (fun f -> ("available_capacity", (AvailableCapacity.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.auto_placement
             (fun f -> ("auto_placement", (AutoPlacement.to_json f)))])
    let of_json j =
      {
        auto_placement =
          (Util.option_map (Json.lookup j "auto_placement")
             AutoPlacement.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        available_capacity =
          (Util.option_map (Json.lookup j "available_capacity")
             AvailableCapacity.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        host_id = (Util.option_map (Json.lookup j "host_id") String.of_json);
        host_properties =
          (Util.option_map (Json.lookup j "host_properties")
             HostProperties.of_json);
        host_reservation_id =
          (Util.option_map (Json.lookup j "host_reservation_id")
             String.of_json);
        instances =
          (HostInstanceList.of_json
             (Util.of_option_exn (Json.lookup j "instances")));
        state =
          (Util.option_map (Json.lookup j "state") AllocationState.of_json);
        allocation_time =
          (Util.option_map (Json.lookup j "allocation_time") DateTime.of_json);
        release_time =
          (Util.option_map (Json.lookup j "release_time") DateTime.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        host_recovery =
          (Util.option_map (Json.lookup j "host_recovery")
             HostRecovery.of_json);
        allows_multiple_instance_types =
          (Util.option_map (Json.lookup j "allows_multiple_instance_types")
             AllowsMultipleInstanceTypes.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        availability_zone_id =
          (Util.option_map (Json.lookup j "availability_zone_id")
             String.of_json);
        member_of_service_linked_resource_group =
          (Util.option_map
             (Json.lookup j "member_of_service_linked_resource_group")
             Boolean.of_json)
      }
  end
module SubnetAssociationList =
  struct
    type t = SubnetAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SubnetAssociation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SubnetAssociation.to_query v
    let to_headers v = Headers.to_headers_list SubnetAssociation.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (SubnetAssociation.to_xml x)))
        v
    let to_json v = `List (List.map SubnetAssociation.to_json v)
    let of_json j = Json.to_list SubnetAssociation.of_json j
  end
module LaunchTemplate =
  struct
    type t =
      {
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      create_time: DateTime.t option ;
      created_by: String.t option ;
      default_version_number: Long.t option ;
      latest_version_number: Long.t option ;
      tags: TagList.t }
    let make ?launch_template_id  ?launch_template_name  ?create_time 
      ?created_by  ?default_version_number  ?latest_version_number  ?(tags=
      [])  () =
      {
        launch_template_id;
        launch_template_name;
        create_time;
        created_by;
        default_version_number;
        latest_version_number;
        tags
      }
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "launchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "launchTemplateName" xml)
               String.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          created_by =
            (Util.option_bind (Xml.member "createdBy" xml) String.parse);
          default_version_number =
            (Util.option_bind (Xml.member "defaultVersionNumber" xml)
               Long.parse);
          latest_version_number =
            (Util.option_bind (Xml.member "latestVersionNumber" xml)
               Long.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.latest_version_number
             (fun f -> Query.Pair ("LatestVersionNumber", (Long.to_query f)));
           Util.option_map v.default_version_number
             (fun f -> Query.Pair ("DefaultVersionNumber", (Long.to_query f)));
           Util.option_map v.created_by
             (fun f -> Query.Pair ("CreatedBy", (String.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.launch_template_id
                    (fun f ->
                       Ezxmlm.make_tag "launchTemplateId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.launch_template_name
                   (fun f ->
                      Ezxmlm.make_tag "launchTemplateName"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.create_time
                  (fun f ->
                     Ezxmlm.make_tag "createTime" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.created_by
                 (fun f ->
                    Ezxmlm.make_tag "createdBy" ([], (String.to_xml f)))])
             @
             [Util.option_map v.default_version_number
                (fun f ->
                   Ezxmlm.make_tag "defaultVersionNumber"
                     ([], (Long.to_xml f)))])
            @
            [Util.option_map v.latest_version_number
               (fun f ->
                  Ezxmlm.make_tag "latestVersionNumber" ([], (Long.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.latest_version_number
             (fun f -> ("latest_version_number", (Long.to_json f)));
           Util.option_map v.default_version_number
             (fun f -> ("default_version_number", (Long.to_json f)));
           Util.option_map v.created_by
             (fun f -> ("created_by", (String.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let of_json j =
      {
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        create_time =
          (Util.option_map (Json.lookup j "create_time") DateTime.of_json);
        created_by =
          (Util.option_map (Json.lookup j "created_by") String.of_json);
        default_version_number =
          (Util.option_map (Json.lookup j "default_version_number")
             Long.of_json);
        latest_version_number =
          (Util.option_map (Json.lookup j "latest_version_number")
             Long.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module PrefixList =
  struct
    type t =
      {
      cidrs: ValueStringList.t ;
      prefix_list_id: String.t option ;
      prefix_list_name: String.t option }
    let make ?(cidrs= [])  ?prefix_list_id  ?prefix_list_name  () =
      { cidrs; prefix_list_id; prefix_list_name }
    let parse xml =
      Some
        {
          cidrs =
            (Util.of_option []
               (Util.option_bind (Xml.member "cidrSet" xml)
                  ValueStringList.parse));
          prefix_list_id =
            (Util.option_bind (Xml.member "prefixListId" xml) String.parse);
          prefix_list_name =
            (Util.option_bind (Xml.member "prefixListName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.prefix_list_name
              (fun f -> Query.Pair ("PrefixListName", (String.to_query f)));
           Util.option_map v.prefix_list_id
             (fun f -> Query.Pair ("PrefixListId", (String.to_query f)));
           Some (Query.Pair ("CidrSet", (ValueStringList.to_query v.cidrs)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "cidrSet"
                        ([], (ValueStringList.to_xml [x])))) v.cidrs))
            @
            [Util.option_map v.prefix_list_id
               (fun f ->
                  Ezxmlm.make_tag "prefixListId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.prefix_list_name
              (fun f ->
                 Ezxmlm.make_tag "prefixListName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.prefix_list_name
              (fun f -> ("prefix_list_name", (String.to_json f)));
           Util.option_map v.prefix_list_id
             (fun f -> ("prefix_list_id", (String.to_json f)));
           Some ("cidrs", (ValueStringList.to_json v.cidrs))])
    let of_json j =
      {
        cidrs =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "cidrs")));
        prefix_list_id =
          (Util.option_map (Json.lookup j "prefix_list_id") String.of_json);
        prefix_list_name =
          (Util.option_map (Json.lookup j "prefix_list_name") String.of_json)
      }
  end
module UnlimitedSupportedInstanceFamily =
  struct
    type t =
      | T2 
      | T3 
      | T3a 
    let str_to_t = [("t3a", T3a); ("t3", T3); ("t2", T2)]
    let t_to_str = [(T3a, "t3a"); (T3, "t3"); (T2, "t2")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ActiveInstance =
  struct
    type t =
      {
      instance_id: String.t option ;
      instance_type: String.t option ;
      spot_instance_request_id: String.t option ;
      instance_health: InstanceHealthStatus.t option }
    let make ?instance_id  ?instance_type  ?spot_instance_request_id 
      ?instance_health  () =
      { instance_id; instance_type; spot_instance_request_id; instance_health
      }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          spot_instance_request_id =
            (Util.option_bind (Xml.member "spotInstanceRequestId" xml)
               String.parse);
          instance_health =
            (Util.option_bind (Xml.member "instanceHealth" xml)
               InstanceHealthStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_health
              (fun f ->
                 Query.Pair
                   ("InstanceHealth", (InstanceHealthStatus.to_query f)));
           Util.option_map v.spot_instance_request_id
             (fun f ->
                Query.Pair ("SpotInstanceRequestId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.instance_id
                 (fun f ->
                    Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.instance_type
                (fun f ->
                   Ezxmlm.make_tag "instanceType" ([], (String.to_xml f)))])
            @
            [Util.option_map v.spot_instance_request_id
               (fun f ->
                  Ezxmlm.make_tag "spotInstanceRequestId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.instance_health
              (fun f ->
                 Ezxmlm.make_tag "instanceHealth"
                   ([], (InstanceHealthStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_health
              (fun f -> ("instance_health", (InstanceHealthStatus.to_json f)));
           Util.option_map v.spot_instance_request_id
             (fun f -> ("spot_instance_request_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        spot_instance_request_id =
          (Util.option_map (Json.lookup j "spot_instance_request_id")
             String.of_json);
        instance_health =
          (Util.option_map (Json.lookup j "instance_health")
             InstanceHealthStatus.of_json)
      }
  end
module InstanceBlockDeviceMappingSpecification =
  struct
    type t =
      {
      device_name: String.t option ;
      ebs: EbsInstanceBlockDeviceSpecification.t option ;
      no_device: String.t option ;
      virtual_name: String.t option }
    let make ?device_name  ?ebs  ?no_device  ?virtual_name  () =
      { device_name; ebs; no_device; virtual_name }
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "ebs" xml)
               EbsInstanceBlockDeviceSpecification.parse);
          no_device =
            (Util.option_bind (Xml.member "noDevice" xml) String.parse);
          virtual_name =
            (Util.option_bind (Xml.member "virtualName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.virtual_name
              (fun f -> Query.Pair ("VirtualName", (String.to_query f)));
           Util.option_map v.no_device
             (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.ebs
             (fun f ->
                Query.Pair
                  ("Ebs", (EbsInstanceBlockDeviceSpecification.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.device_name
                 (fun f ->
                    Ezxmlm.make_tag "deviceName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.ebs
                (fun f ->
                   Ezxmlm.make_tag "ebs"
                     ([], (EbsInstanceBlockDeviceSpecification.to_xml f)))])
            @
            [Util.option_map v.no_device
               (fun f -> Ezxmlm.make_tag "noDevice" ([], (String.to_xml f)))])
           @
           [Util.option_map v.virtual_name
              (fun f -> Ezxmlm.make_tag "virtualName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.virtual_name
              (fun f -> ("virtual_name", (String.to_json f)));
           Util.option_map v.no_device
             (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.ebs
             (fun f ->
                ("ebs", (EbsInstanceBlockDeviceSpecification.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let of_json j =
      {
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        ebs =
          (Util.option_map (Json.lookup j "ebs")
             EbsInstanceBlockDeviceSpecification.of_json);
        no_device =
          (Util.option_map (Json.lookup j "no_device") String.of_json);
        virtual_name =
          (Util.option_map (Json.lookup j "virtual_name") String.of_json)
      }
  end
module LoadPermissionList =
  struct
    type t = LoadPermission.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LoadPermission.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LoadPermission.to_query v
    let to_headers v = Headers.to_headers_list LoadPermission.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (LoadPermission.to_xml x))) v
    let to_json v = `List (List.map LoadPermission.to_json v)
    let of_json j = Json.to_list LoadPermission.of_json j
  end
module TransitGatewayMulticastDomain =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      transit_gateway_id: String.t option ;
      state: TransitGatewayMulticastDomainState.t option ;
      creation_time: DateTime.t option ;
      tags: TagList.t }
    let make ?transit_gateway_multicast_domain_id  ?transit_gateway_id 
      ?state  ?creation_time  ?(tags= [])  () =
      {
        transit_gateway_multicast_domain_id;
        transit_gateway_id;
        state;
        creation_time;
        tags
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayMulticastDomainState.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (TransitGatewayMulticastDomainState.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.transit_gateway_multicast_domain_id
                  (fun f ->
                     Ezxmlm.make_tag "transitGatewayMulticastDomainId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.transit_gateway_id
                 (fun f ->
                    Ezxmlm.make_tag "transitGatewayId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.state
                (fun f ->
                   Ezxmlm.make_tag "state"
                     ([], (TransitGatewayMulticastDomainState.to_xml f)))])
            @
            [Util.option_map v.creation_time
               (fun f ->
                  Ezxmlm.make_tag "creationTime" ([], (DateTime.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f ->
                ("state", (TransitGatewayMulticastDomainState.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayMulticastDomainState.of_json);
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") DateTime.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module PrincipalIdFormat =
  struct
    type t = {
      arn: String.t option ;
      statuses: IdFormatList.t }
    let make ?arn  ?(statuses= [])  () = { arn; statuses }
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "arn" xml) String.parse);
          statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "statusSet" xml)
                  IdFormatList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("StatusSet", (IdFormatList.to_query v.statuses)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.arn
               (fun f -> Ezxmlm.make_tag "arn" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "statusSet"
                      ([], (IdFormatList.to_xml [x])))) v.statuses))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("statuses", (IdFormatList.to_json v.statuses));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      {
        arn = (Util.option_map (Json.lookup j "arn") String.of_json);
        statuses =
          (IdFormatList.of_json
             (Util.of_option_exn (Json.lookup j "statuses")))
      }
  end
module AllowedPrincipal =
  struct
    type t =
      {
      principal_type: PrincipalType.t option ;
      principal: String.t option }
    let make ?principal_type  ?principal  () = { principal_type; principal }
    let parse xml =
      Some
        {
          principal_type =
            (Util.option_bind (Xml.member "principalType" xml)
               PrincipalType.parse);
          principal =
            (Util.option_bind (Xml.member "principal" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.principal
              (fun f -> Query.Pair ("Principal", (String.to_query f)));
           Util.option_map v.principal_type
             (fun f ->
                Query.Pair ("PrincipalType", (PrincipalType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.principal_type
               (fun f ->
                  Ezxmlm.make_tag "principalType"
                    ([], (PrincipalType.to_xml f)))])
           @
           [Util.option_map v.principal
              (fun f -> Ezxmlm.make_tag "principal" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.principal
              (fun f -> ("principal", (String.to_json f)));
           Util.option_map v.principal_type
             (fun f -> ("principal_type", (PrincipalType.to_json f)))])
    let of_json j =
      {
        principal_type =
          (Util.option_map (Json.lookup j "principal_type")
             PrincipalType.of_json);
        principal =
          (Util.option_map (Json.lookup j "principal") String.of_json)
      }
  end
module ByoipCidr =
  struct
    type t =
      {
      cidr: String.t option ;
      description: String.t option ;
      status_message: String.t option ;
      state: ByoipCidrState.t option }
    let make ?cidr  ?description  ?status_message  ?state  () =
      { cidr; description; status_message; state }
    let parse xml =
      Some
        {
          cidr = (Util.option_bind (Xml.member "cidr" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) ByoipCidrState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (ByoipCidrState.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.cidr
             (fun f -> Query.Pair ("Cidr", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.cidr
                 (fun f -> Ezxmlm.make_tag "cidr" ([], (String.to_xml f)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
            @
            [Util.option_map v.status_message
               (fun f ->
                  Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state" ([], (ByoipCidrState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (ByoipCidrState.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.cidr (fun f -> ("cidr", (String.to_json f)))])
    let of_json j =
      {
        cidr = (Util.option_map (Json.lookup j "cidr") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state") ByoipCidrState.of_json)
      }
  end
module CoipPool =
  struct
    type t =
      {
      pool_id: String.t option ;
      pool_cidrs: ValueStringList.t ;
      local_gateway_route_table_id: String.t option ;
      tags: TagList.t }
    let make ?pool_id  ?(pool_cidrs= [])  ?local_gateway_route_table_id 
      ?(tags= [])  () =
      { pool_id; pool_cidrs; local_gateway_route_table_id; tags }
    let parse xml =
      Some
        {
          pool_id = (Util.option_bind (Xml.member "poolId" xml) String.parse);
          pool_cidrs =
            (Util.of_option []
               (Util.option_bind (Xml.member "poolCidrSet" xml)
                  ValueStringList.parse));
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.local_gateway_route_table_id
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)));
           Some
             (Query.Pair
                ("PoolCidrSet", (ValueStringList.to_query v.pool_cidrs)));
           Util.option_map v.pool_id
             (fun f -> Query.Pair ("PoolId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.pool_id
                 (fun f -> Ezxmlm.make_tag "poolId" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "poolCidrSet"
                        ([], (ValueStringList.to_xml [x])))) v.pool_cidrs))
            @
            [Util.option_map v.local_gateway_route_table_id
               (fun f ->
                  Ezxmlm.make_tag "localGatewayRouteTableId"
                    ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.local_gateway_route_table_id
             (fun f -> ("local_gateway_route_table_id", (String.to_json f)));
           Some ("pool_cidrs", (ValueStringList.to_json v.pool_cidrs));
           Util.option_map v.pool_id
             (fun f -> ("pool_id", (String.to_json f)))])
    let of_json j =
      {
        pool_id = (Util.option_map (Json.lookup j "pool_id") String.of_json);
        pool_cidrs =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "pool_cidrs")));
        local_gateway_route_table_id =
          (Util.option_map (Json.lookup j "local_gateway_route_table_id")
             String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module DatafeedSubscriptionState =
  struct
    type t =
      | Active 
      | Inactive 
    let str_to_t = [("Inactive", Inactive); ("Active", Active)]
    let t_to_str = [(Inactive, "Inactive"); (Active, "Active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DeleteFleetErrorItem =
  struct
    type t = {
      error: DeleteFleetError.t option ;
      fleet_id: String.t option }
    let make ?error  ?fleet_id  () = { error; fleet_id }
    let parse xml =
      Some
        {
          error =
            (Util.option_bind (Xml.member "error" xml) DeleteFleetError.parse);
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> Query.Pair ("FleetId", (String.to_query f)));
           Util.option_map v.error
             (fun f -> Query.Pair ("Error", (DeleteFleetError.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.error
               (fun f ->
                  Ezxmlm.make_tag "error" ([], (DeleteFleetError.to_xml f)))])
           @
           [Util.option_map v.fleet_id
              (fun f -> Ezxmlm.make_tag "fleetId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> ("fleet_id", (String.to_json f)));
           Util.option_map v.error
             (fun f -> ("error", (DeleteFleetError.to_json f)))])
    let of_json j =
      {
        error =
          (Util.option_map (Json.lookup j "error") DeleteFleetError.of_json);
        fleet_id =
          (Util.option_map (Json.lookup j "fleet_id") String.of_json)
      }
  end
module DeleteFleetSuccessItem =
  struct
    type t =
      {
      current_fleet_state: FleetStateCode.t option ;
      previous_fleet_state: FleetStateCode.t option ;
      fleet_id: String.t option }
    let make ?current_fleet_state  ?previous_fleet_state  ?fleet_id  () =
      { current_fleet_state; previous_fleet_state; fleet_id }
    let parse xml =
      Some
        {
          current_fleet_state =
            (Util.option_bind (Xml.member "currentFleetState" xml)
               FleetStateCode.parse);
          previous_fleet_state =
            (Util.option_bind (Xml.member "previousFleetState" xml)
               FleetStateCode.parse);
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> Query.Pair ("FleetId", (String.to_query f)));
           Util.option_map v.previous_fleet_state
             (fun f ->
                Query.Pair
                  ("PreviousFleetState", (FleetStateCode.to_query f)));
           Util.option_map v.current_fleet_state
             (fun f ->
                Query.Pair ("CurrentFleetState", (FleetStateCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.current_fleet_state
                (fun f ->
                   Ezxmlm.make_tag "currentFleetState"
                     ([], (FleetStateCode.to_xml f)))])
            @
            [Util.option_map v.previous_fleet_state
               (fun f ->
                  Ezxmlm.make_tag "previousFleetState"
                    ([], (FleetStateCode.to_xml f)))])
           @
           [Util.option_map v.fleet_id
              (fun f -> Ezxmlm.make_tag "fleetId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> ("fleet_id", (String.to_json f)));
           Util.option_map v.previous_fleet_state
             (fun f -> ("previous_fleet_state", (FleetStateCode.to_json f)));
           Util.option_map v.current_fleet_state
             (fun f -> ("current_fleet_state", (FleetStateCode.to_json f)))])
    let of_json j =
      {
        current_fleet_state =
          (Util.option_map (Json.lookup j "current_fleet_state")
             FleetStateCode.of_json);
        previous_fleet_state =
          (Util.option_map (Json.lookup j "previous_fleet_state")
             FleetStateCode.of_json);
        fleet_id =
          (Util.option_map (Json.lookup j "fleet_id") String.of_json)
      }
  end
module DisableFastSnapshotRestoreErrorItem =
  struct
    type t =
      {
      snapshot_id: String.t option ;
      fast_snapshot_restore_state_errors:
        DisableFastSnapshotRestoreStateErrorSet.t }
    let make ?snapshot_id  ?(fast_snapshot_restore_state_errors= [])  () =
      { snapshot_id; fast_snapshot_restore_state_errors }
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          fast_snapshot_restore_state_errors =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "fastSnapshotRestoreStateErrorSet" xml)
                  DisableFastSnapshotRestoreStateErrorSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FastSnapshotRestoreStateErrorSet",
                   (DisableFastSnapshotRestoreStateErrorSet.to_query
                      v.fast_snapshot_restore_state_errors)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.snapshot_id
               (fun f -> Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "fastSnapshotRestoreStateErrorSet"
                      ([],
                        (DisableFastSnapshotRestoreStateErrorSet.to_xml [x]))))
              v.fast_snapshot_restore_state_errors))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("fast_snapshot_restore_state_errors",
                (DisableFastSnapshotRestoreStateErrorSet.to_json
                   v.fast_snapshot_restore_state_errors));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let of_json j =
      {
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        fast_snapshot_restore_state_errors =
          (DisableFastSnapshotRestoreStateErrorSet.of_json
             (Util.of_option_exn
                (Json.lookup j "fast_snapshot_restore_state_errors")))
      }
  end
module DisableFastSnapshotRestoreSuccessItem =
  struct
    type t =
      {
      snapshot_id: String.t option ;
      availability_zone: String.t option ;
      state: FastSnapshotRestoreStateCode.t option ;
      state_transition_reason: String.t option ;
      owner_id: String.t option ;
      owner_alias: String.t option ;
      enabling_time: DateTime.t option ;
      optimizing_time: DateTime.t option ;
      enabled_time: DateTime.t option ;
      disabling_time: DateTime.t option ;
      disabled_time: DateTime.t option }
    let make ?snapshot_id  ?availability_zone  ?state 
      ?state_transition_reason  ?owner_id  ?owner_alias  ?enabling_time 
      ?optimizing_time  ?enabled_time  ?disabling_time  ?disabled_time  () =
      {
        snapshot_id;
        availability_zone;
        state;
        state_transition_reason;
        owner_id;
        owner_alias;
        enabling_time;
        optimizing_time;
        enabled_time;
        disabling_time;
        disabled_time
      }
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               FastSnapshotRestoreStateCode.parse);
          state_transition_reason =
            (Util.option_bind (Xml.member "stateTransitionReason" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          owner_alias =
            (Util.option_bind (Xml.member "ownerAlias" xml) String.parse);
          enabling_time =
            (Util.option_bind (Xml.member "enablingTime" xml) DateTime.parse);
          optimizing_time =
            (Util.option_bind (Xml.member "optimizingTime" xml)
               DateTime.parse);
          enabled_time =
            (Util.option_bind (Xml.member "enabledTime" xml) DateTime.parse);
          disabling_time =
            (Util.option_bind (Xml.member "disablingTime" xml) DateTime.parse);
          disabled_time =
            (Util.option_bind (Xml.member "disabledTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> Query.Pair ("DisabledTime", (DateTime.to_query f)));
           Util.option_map v.disabling_time
             (fun f -> Query.Pair ("DisablingTime", (DateTime.to_query f)));
           Util.option_map v.enabled_time
             (fun f -> Query.Pair ("EnabledTime", (DateTime.to_query f)));
           Util.option_map v.optimizing_time
             (fun f -> Query.Pair ("OptimizingTime", (DateTime.to_query f)));
           Util.option_map v.enabling_time
             (fun f -> Query.Pair ("EnablingTime", (DateTime.to_query f)));
           Util.option_map v.owner_alias
             (fun f -> Query.Pair ("OwnerAlias", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.state_transition_reason
             (fun f ->
                Query.Pair ("StateTransitionReason", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (FastSnapshotRestoreStateCode.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.snapshot_id
                        (fun f ->
                           Ezxmlm.make_tag "snapshotId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.availability_zone
                       (fun f ->
                          Ezxmlm.make_tag "availabilityZone"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.state
                      (fun f ->
                         Ezxmlm.make_tag "state"
                           ([], (FastSnapshotRestoreStateCode.to_xml f)))])
                  @
                  [Util.option_map v.state_transition_reason
                     (fun f ->
                        Ezxmlm.make_tag "stateTransitionReason"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.owner_id
                    (fun f ->
                       Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.owner_alias
                   (fun f ->
                      Ezxmlm.make_tag "ownerAlias" ([], (String.to_xml f)))])
               @
               [Util.option_map v.enabling_time
                  (fun f ->
                     Ezxmlm.make_tag "enablingTime" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.optimizing_time
                 (fun f ->
                    Ezxmlm.make_tag "optimizingTime"
                      ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.enabled_time
                (fun f ->
                   Ezxmlm.make_tag "enabledTime" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.disabling_time
               (fun f ->
                  Ezxmlm.make_tag "disablingTime" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.disabled_time
              (fun f ->
                 Ezxmlm.make_tag "disabledTime" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> ("disabled_time", (DateTime.to_json f)));
           Util.option_map v.disabling_time
             (fun f -> ("disabling_time", (DateTime.to_json f)));
           Util.option_map v.enabled_time
             (fun f -> ("enabled_time", (DateTime.to_json f)));
           Util.option_map v.optimizing_time
             (fun f -> ("optimizing_time", (DateTime.to_json f)));
           Util.option_map v.enabling_time
             (fun f -> ("enabling_time", (DateTime.to_json f)));
           Util.option_map v.owner_alias
             (fun f -> ("owner_alias", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.state_transition_reason
             (fun f -> ("state_transition_reason", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (FastSnapshotRestoreStateCode.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let of_json j =
      {
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             FastSnapshotRestoreStateCode.of_json);
        state_transition_reason =
          (Util.option_map (Json.lookup j "state_transition_reason")
             String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        owner_alias =
          (Util.option_map (Json.lookup j "owner_alias") String.of_json);
        enabling_time =
          (Util.option_map (Json.lookup j "enabling_time") DateTime.of_json);
        optimizing_time =
          (Util.option_map (Json.lookup j "optimizing_time") DateTime.of_json);
        enabled_time =
          (Util.option_map (Json.lookup j "enabled_time") DateTime.of_json);
        disabling_time =
          (Util.option_map (Json.lookup j "disabling_time") DateTime.of_json);
        disabled_time =
          (Util.option_map (Json.lookup j "disabled_time") DateTime.of_json)
      }
  end
module ScheduledInstance =
  struct
    type t =
      {
      availability_zone: String.t option ;
      create_date: DateTime.t option ;
      hourly_price: String.t option ;
      instance_count: Integer.t option ;
      instance_type: String.t option ;
      network_platform: String.t option ;
      next_slot_start_time: DateTime.t option ;
      platform: String.t option ;
      previous_slot_end_time: DateTime.t option ;
      recurrence: ScheduledInstanceRecurrence.t option ;
      scheduled_instance_id: String.t option ;
      slot_duration_in_hours: Integer.t option ;
      term_end_date: DateTime.t option ;
      term_start_date: DateTime.t option ;
      total_scheduled_instance_hours: Integer.t option }
    let make ?availability_zone  ?create_date  ?hourly_price  ?instance_count
       ?instance_type  ?network_platform  ?next_slot_start_time  ?platform 
      ?previous_slot_end_time  ?recurrence  ?scheduled_instance_id 
      ?slot_duration_in_hours  ?term_end_date  ?term_start_date 
      ?total_scheduled_instance_hours  () =
      {
        availability_zone;
        create_date;
        hourly_price;
        instance_count;
        instance_type;
        network_platform;
        next_slot_start_time;
        platform;
        previous_slot_end_time;
        recurrence;
        scheduled_instance_id;
        slot_duration_in_hours;
        term_end_date;
        term_start_date;
        total_scheduled_instance_hours
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          create_date =
            (Util.option_bind (Xml.member "createDate" xml) DateTime.parse);
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          network_platform =
            (Util.option_bind (Xml.member "networkPlatform" xml) String.parse);
          next_slot_start_time =
            (Util.option_bind (Xml.member "nextSlotStartTime" xml)
               DateTime.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          previous_slot_end_time =
            (Util.option_bind (Xml.member "previousSlotEndTime" xml)
               DateTime.parse);
          recurrence =
            (Util.option_bind (Xml.member "recurrence" xml)
               ScheduledInstanceRecurrence.parse);
          scheduled_instance_id =
            (Util.option_bind (Xml.member "scheduledInstanceId" xml)
               String.parse);
          slot_duration_in_hours =
            (Util.option_bind (Xml.member "slotDurationInHours" xml)
               Integer.parse);
          term_end_date =
            (Util.option_bind (Xml.member "termEndDate" xml) DateTime.parse);
          term_start_date =
            (Util.option_bind (Xml.member "termStartDate" xml) DateTime.parse);
          total_scheduled_instance_hours =
            (Util.option_bind (Xml.member "totalScheduledInstanceHours" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_scheduled_instance_hours
              (fun f ->
                 Query.Pair
                   ("TotalScheduledInstanceHours", (Integer.to_query f)));
           Util.option_map v.term_start_date
             (fun f -> Query.Pair ("TermStartDate", (DateTime.to_query f)));
           Util.option_map v.term_end_date
             (fun f -> Query.Pair ("TermEndDate", (DateTime.to_query f)));
           Util.option_map v.slot_duration_in_hours
             (fun f ->
                Query.Pair ("SlotDurationInHours", (Integer.to_query f)));
           Util.option_map v.scheduled_instance_id
             (fun f ->
                Query.Pair ("ScheduledInstanceId", (String.to_query f)));
           Util.option_map v.recurrence
             (fun f ->
                Query.Pair
                  ("Recurrence", (ScheduledInstanceRecurrence.to_query f)));
           Util.option_map v.previous_slot_end_time
             (fun f ->
                Query.Pair ("PreviousSlotEndTime", (DateTime.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.next_slot_start_time
             (fun f ->
                Query.Pair ("NextSlotStartTime", (DateTime.to_query f)));
           Util.option_map v.network_platform
             (fun f -> Query.Pair ("NetworkPlatform", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)));
           Util.option_map v.create_date
             (fun f -> Query.Pair ("CreateDate", (DateTime.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Util.option_map v.availability_zone
                            (fun f ->
                               Ezxmlm.make_tag "availabilityZone"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.create_date
                           (fun f ->
                              Ezxmlm.make_tag "createDate"
                                ([], (DateTime.to_xml f)))])
                       @
                       [Util.option_map v.hourly_price
                          (fun f ->
                             Ezxmlm.make_tag "hourlyPrice"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.instance_count
                         (fun f ->
                            Ezxmlm.make_tag "instanceCount"
                              ([], (Integer.to_xml f)))])
                     @
                     [Util.option_map v.instance_type
                        (fun f ->
                           Ezxmlm.make_tag "instanceType"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.network_platform
                       (fun f ->
                          Ezxmlm.make_tag "networkPlatform"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.next_slot_start_time
                      (fun f ->
                         Ezxmlm.make_tag "nextSlotStartTime"
                           ([], (DateTime.to_xml f)))])
                  @
                  [Util.option_map v.platform
                     (fun f ->
                        Ezxmlm.make_tag "platform" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.previous_slot_end_time
                    (fun f ->
                       Ezxmlm.make_tag "previousSlotEndTime"
                         ([], (DateTime.to_xml f)))])
                @
                [Util.option_map v.recurrence
                   (fun f ->
                      Ezxmlm.make_tag "recurrence"
                        ([], (ScheduledInstanceRecurrence.to_xml f)))])
               @
               [Util.option_map v.scheduled_instance_id
                  (fun f ->
                     Ezxmlm.make_tag "scheduledInstanceId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.slot_duration_in_hours
                 (fun f ->
                    Ezxmlm.make_tag "slotDurationInHours"
                      ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.term_end_date
                (fun f ->
                   Ezxmlm.make_tag "termEndDate" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.term_start_date
               (fun f ->
                  Ezxmlm.make_tag "termStartDate" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.total_scheduled_instance_hours
              (fun f ->
                 Ezxmlm.make_tag "totalScheduledInstanceHours"
                   ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_scheduled_instance_hours
              (fun f ->
                 ("total_scheduled_instance_hours", (Integer.to_json f)));
           Util.option_map v.term_start_date
             (fun f -> ("term_start_date", (DateTime.to_json f)));
           Util.option_map v.term_end_date
             (fun f -> ("term_end_date", (DateTime.to_json f)));
           Util.option_map v.slot_duration_in_hours
             (fun f -> ("slot_duration_in_hours", (Integer.to_json f)));
           Util.option_map v.scheduled_instance_id
             (fun f -> ("scheduled_instance_id", (String.to_json f)));
           Util.option_map v.recurrence
             (fun f ->
                ("recurrence", (ScheduledInstanceRecurrence.to_json f)));
           Util.option_map v.previous_slot_end_time
             (fun f -> ("previous_slot_end_time", (DateTime.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.next_slot_start_time
             (fun f -> ("next_slot_start_time", (DateTime.to_json f)));
           Util.option_map v.network_platform
             (fun f -> ("network_platform", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)));
           Util.option_map v.create_date
             (fun f -> ("create_date", (DateTime.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        create_date =
          (Util.option_map (Json.lookup j "create_date") DateTime.of_json);
        hourly_price =
          (Util.option_map (Json.lookup j "hourly_price") String.of_json);
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        network_platform =
          (Util.option_map (Json.lookup j "network_platform") String.of_json);
        next_slot_start_time =
          (Util.option_map (Json.lookup j "next_slot_start_time")
             DateTime.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") String.of_json);
        previous_slot_end_time =
          (Util.option_map (Json.lookup j "previous_slot_end_time")
             DateTime.of_json);
        recurrence =
          (Util.option_map (Json.lookup j "recurrence")
             ScheduledInstanceRecurrence.of_json);
        scheduled_instance_id =
          (Util.option_map (Json.lookup j "scheduled_instance_id")
             String.of_json);
        slot_duration_in_hours =
          (Util.option_map (Json.lookup j "slot_duration_in_hours")
             Integer.of_json);
        term_end_date =
          (Util.option_map (Json.lookup j "term_end_date") DateTime.of_json);
        term_start_date =
          (Util.option_map (Json.lookup j "term_start_date") DateTime.of_json);
        total_scheduled_instance_hours =
          (Util.option_map (Json.lookup j "total_scheduled_instance_hours")
             Integer.of_json)
      }
  end
module FlowLog =
  struct
    type t =
      {
      creation_time: DateTime.t option ;
      deliver_logs_error_message: String.t option ;
      deliver_logs_permission_arn: String.t option ;
      deliver_logs_status: String.t option ;
      flow_log_id: String.t option ;
      flow_log_status: String.t option ;
      log_group_name: String.t option ;
      resource_id: String.t option ;
      traffic_type: TrafficType.t option ;
      log_destination_type: LogDestinationType.t option ;
      log_destination: String.t option ;
      log_format: String.t option }
    let make ?creation_time  ?deliver_logs_error_message 
      ?deliver_logs_permission_arn  ?deliver_logs_status  ?flow_log_id 
      ?flow_log_status  ?log_group_name  ?resource_id  ?traffic_type 
      ?log_destination_type  ?log_destination  ?log_format  () =
      {
        creation_time;
        deliver_logs_error_message;
        deliver_logs_permission_arn;
        deliver_logs_status;
        flow_log_id;
        flow_log_status;
        log_group_name;
        resource_id;
        traffic_type;
        log_destination_type;
        log_destination;
        log_format
      }
    let parse xml =
      Some
        {
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          deliver_logs_error_message =
            (Util.option_bind (Xml.member "deliverLogsErrorMessage" xml)
               String.parse);
          deliver_logs_permission_arn =
            (Util.option_bind (Xml.member "deliverLogsPermissionArn" xml)
               String.parse);
          deliver_logs_status =
            (Util.option_bind (Xml.member "deliverLogsStatus" xml)
               String.parse);
          flow_log_id =
            (Util.option_bind (Xml.member "flowLogId" xml) String.parse);
          flow_log_status =
            (Util.option_bind (Xml.member "flowLogStatus" xml) String.parse);
          log_group_name =
            (Util.option_bind (Xml.member "logGroupName" xml) String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          traffic_type =
            (Util.option_bind (Xml.member "trafficType" xml)
               TrafficType.parse);
          log_destination_type =
            (Util.option_bind (Xml.member "logDestinationType" xml)
               LogDestinationType.parse);
          log_destination =
            (Util.option_bind (Xml.member "logDestination" xml) String.parse);
          log_format =
            (Util.option_bind (Xml.member "logFormat" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.log_format
              (fun f -> Query.Pair ("LogFormat", (String.to_query f)));
           Util.option_map v.log_destination
             (fun f -> Query.Pair ("LogDestination", (String.to_query f)));
           Util.option_map v.log_destination_type
             (fun f ->
                Query.Pair
                  ("LogDestinationType", (LogDestinationType.to_query f)));
           Util.option_map v.traffic_type
             (fun f -> Query.Pair ("TrafficType", (TrafficType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.log_group_name
             (fun f -> Query.Pair ("LogGroupName", (String.to_query f)));
           Util.option_map v.flow_log_status
             (fun f -> Query.Pair ("FlowLogStatus", (String.to_query f)));
           Util.option_map v.flow_log_id
             (fun f -> Query.Pair ("FlowLogId", (String.to_query f)));
           Util.option_map v.deliver_logs_status
             (fun f -> Query.Pair ("DeliverLogsStatus", (String.to_query f)));
           Util.option_map v.deliver_logs_permission_arn
             (fun f ->
                Query.Pair ("DeliverLogsPermissionArn", (String.to_query f)));
           Util.option_map v.deliver_logs_error_message
             (fun f ->
                Query.Pair ("DeliverLogsErrorMessage", (String.to_query f)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Util.option_map v.creation_time
                         (fun f ->
                            Ezxmlm.make_tag "creationTime"
                              ([], (DateTime.to_xml f)))])
                     @
                     [Util.option_map v.deliver_logs_error_message
                        (fun f ->
                           Ezxmlm.make_tag "deliverLogsErrorMessage"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.deliver_logs_permission_arn
                       (fun f ->
                          Ezxmlm.make_tag "deliverLogsPermissionArn"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.deliver_logs_status
                      (fun f ->
                         Ezxmlm.make_tag "deliverLogsStatus"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.flow_log_id
                     (fun f ->
                        Ezxmlm.make_tag "flowLogId" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.flow_log_status
                    (fun f ->
                       Ezxmlm.make_tag "flowLogStatus"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.log_group_name
                   (fun f ->
                      Ezxmlm.make_tag "logGroupName" ([], (String.to_xml f)))])
               @
               [Util.option_map v.resource_id
                  (fun f ->
                     Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.traffic_type
                 (fun f ->
                    Ezxmlm.make_tag "trafficType"
                      ([], (TrafficType.to_xml f)))])
             @
             [Util.option_map v.log_destination_type
                (fun f ->
                   Ezxmlm.make_tag "logDestinationType"
                     ([], (LogDestinationType.to_xml f)))])
            @
            [Util.option_map v.log_destination
               (fun f ->
                  Ezxmlm.make_tag "logDestination" ([], (String.to_xml f)))])
           @
           [Util.option_map v.log_format
              (fun f -> Ezxmlm.make_tag "logFormat" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.log_format
              (fun f -> ("log_format", (String.to_json f)));
           Util.option_map v.log_destination
             (fun f -> ("log_destination", (String.to_json f)));
           Util.option_map v.log_destination_type
             (fun f ->
                ("log_destination_type", (LogDestinationType.to_json f)));
           Util.option_map v.traffic_type
             (fun f -> ("traffic_type", (TrafficType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.log_group_name
             (fun f -> ("log_group_name", (String.to_json f)));
           Util.option_map v.flow_log_status
             (fun f -> ("flow_log_status", (String.to_json f)));
           Util.option_map v.flow_log_id
             (fun f -> ("flow_log_id", (String.to_json f)));
           Util.option_map v.deliver_logs_status
             (fun f -> ("deliver_logs_status", (String.to_json f)));
           Util.option_map v.deliver_logs_permission_arn
             (fun f -> ("deliver_logs_permission_arn", (String.to_json f)));
           Util.option_map v.deliver_logs_error_message
             (fun f -> ("deliver_logs_error_message", (String.to_json f)));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)))])
    let of_json j =
      {
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") DateTime.of_json);
        deliver_logs_error_message =
          (Util.option_map (Json.lookup j "deliver_logs_error_message")
             String.of_json);
        deliver_logs_permission_arn =
          (Util.option_map (Json.lookup j "deliver_logs_permission_arn")
             String.of_json);
        deliver_logs_status =
          (Util.option_map (Json.lookup j "deliver_logs_status")
             String.of_json);
        flow_log_id =
          (Util.option_map (Json.lookup j "flow_log_id") String.of_json);
        flow_log_status =
          (Util.option_map (Json.lookup j "flow_log_status") String.of_json);
        log_group_name =
          (Util.option_map (Json.lookup j "log_group_name") String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        traffic_type =
          (Util.option_map (Json.lookup j "traffic_type") TrafficType.of_json);
        log_destination_type =
          (Util.option_map (Json.lookup j "log_destination_type")
             LogDestinationType.of_json);
        log_destination =
          (Util.option_map (Json.lookup j "log_destination") String.of_json);
        log_format =
          (Util.option_map (Json.lookup j "log_format") String.of_json)
      }
  end
module BundleTask =
  struct
    type t =
      {
      bundle_id: String.t ;
      bundle_task_error: BundleTaskError.t option ;
      instance_id: String.t ;
      progress: String.t ;
      start_time: DateTime.t ;
      state: BundleTaskState.t ;
      storage: Storage.t ;
      update_time: DateTime.t }
    let make ~bundle_id  ?bundle_task_error  ~instance_id  ~progress 
      ~start_time  ~state  ~storage  ~update_time  () =
      {
        bundle_id;
        bundle_task_error;
        instance_id;
        progress;
        start_time;
        state;
        storage;
        update_time
      }
    let parse xml =
      Some
        {
          bundle_id =
            (Xml.required "bundleId"
               (Util.option_bind (Xml.member "bundleId" xml) String.parse));
          bundle_task_error =
            (Util.option_bind (Xml.member "error" xml) BundleTaskError.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          progress =
            (Xml.required "progress"
               (Util.option_bind (Xml.member "progress" xml) String.parse));
          start_time =
            (Xml.required "startTime"
               (Util.option_bind (Xml.member "startTime" xml) DateTime.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml)
                  BundleTaskState.parse));
          storage =
            (Xml.required "storage"
               (Util.option_bind (Xml.member "storage" xml) Storage.parse));
          update_time =
            (Xml.required "updateTime"
               (Util.option_bind (Xml.member "updateTime" xml) DateTime.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("UpdateTime", (DateTime.to_query v.update_time)));
           Some (Query.Pair ("Storage", (Storage.to_query v.storage)));
           Some (Query.Pair ("State", (BundleTaskState.to_query v.state)));
           Some (Query.Pair ("StartTime", (DateTime.to_query v.start_time)));
           Some (Query.Pair ("Progress", (String.to_query v.progress)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.bundle_task_error
             (fun f -> Query.Pair ("Error", (BundleTaskError.to_query f)));
           Some (Query.Pair ("BundleId", (String.to_query v.bundle_id)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Some
                     (Ezxmlm.make_tag "bundleId"
                        ([], (String.to_xml v.bundle_id)))])
                 @
                 [Util.option_map v.bundle_task_error
                    (fun f ->
                       Ezxmlm.make_tag "error"
                         ([], (BundleTaskError.to_xml f)))])
                @
                [Some
                   (Ezxmlm.make_tag "instanceId"
                      ([], (String.to_xml v.instance_id)))])
               @
               [Some
                  (Ezxmlm.make_tag "progress"
                     ([], (String.to_xml v.progress)))])
              @
              [Some
                 (Ezxmlm.make_tag "startTime"
                    ([], (DateTime.to_xml v.start_time)))])
             @
             [Some
                (Ezxmlm.make_tag "state"
                   ([], (BundleTaskState.to_xml v.state)))])
            @
            [Some
               (Ezxmlm.make_tag "storage" ([], (Storage.to_xml v.storage)))])
           @
           [Some
              (Ezxmlm.make_tag "updateTime"
                 ([], (DateTime.to_xml v.update_time)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("update_time", (DateTime.to_json v.update_time));
           Some ("storage", (Storage.to_json v.storage));
           Some ("state", (BundleTaskState.to_json v.state));
           Some ("start_time", (DateTime.to_json v.start_time));
           Some ("progress", (String.to_json v.progress));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.bundle_task_error
             (fun f -> ("bundle_task_error", (BundleTaskError.to_json f)));
           Some ("bundle_id", (String.to_json v.bundle_id))])
    let of_json j =
      {
        bundle_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "bundle_id")));
        bundle_task_error =
          (Util.option_map (Json.lookup j "bundle_task_error")
             BundleTaskError.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        progress =
          (String.of_json (Util.of_option_exn (Json.lookup j "progress")));
        start_time =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "start_time")));
        state =
          (BundleTaskState.of_json
             (Util.of_option_exn (Json.lookup j "state")));
        storage =
          (Storage.of_json (Util.of_option_exn (Json.lookup j "storage")));
        update_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "update_time")))
      }
  end
module InstanceCreditSpecification =
  struct
    type t = {
      instance_id: String.t option ;
      cpu_credits: String.t option }
    let make ?instance_id  ?cpu_credits  () = { instance_id; cpu_credits }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          cpu_credits =
            (Util.option_bind (Xml.member "cpuCredits" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> Query.Pair ("CpuCredits", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.cpu_credits
              (fun f -> Ezxmlm.make_tag "cpuCredits" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> ("cpu_credits", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        cpu_credits =
          (Util.option_map (Json.lookup j "cpu_credits") String.of_json)
      }
  end
module CoipAddressUsage =
  struct
    type t =
      {
      allocation_id: String.t option ;
      aws_account_id: String.t option ;
      aws_service: String.t option ;
      co_ip: String.t option }
    let make ?allocation_id  ?aws_account_id  ?aws_service  ?co_ip  () =
      { allocation_id; aws_account_id; aws_service; co_ip }
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          aws_account_id =
            (Util.option_bind (Xml.member "awsAccountId" xml) String.parse);
          aws_service =
            (Util.option_bind (Xml.member "awsService" xml) String.parse);
          co_ip = (Util.option_bind (Xml.member "coIp" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.co_ip
              (fun f -> Query.Pair ("CoIp", (String.to_query f)));
           Util.option_map v.aws_service
             (fun f -> Query.Pair ("AwsService", (String.to_query f)));
           Util.option_map v.aws_account_id
             (fun f -> Query.Pair ("AwsAccountId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.allocation_id
                 (fun f ->
                    Ezxmlm.make_tag "allocationId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.aws_account_id
                (fun f ->
                   Ezxmlm.make_tag "awsAccountId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.aws_service
               (fun f -> Ezxmlm.make_tag "awsService" ([], (String.to_xml f)))])
           @
           [Util.option_map v.co_ip
              (fun f -> Ezxmlm.make_tag "coIp" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.co_ip (fun f -> ("co_ip", (String.to_json f)));
           Util.option_map v.aws_service
             (fun f -> ("aws_service", (String.to_json f)));
           Util.option_map v.aws_account_id
             (fun f -> ("aws_account_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let of_json j =
      {
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        aws_account_id =
          (Util.option_map (Json.lookup j "aws_account_id") String.of_json);
        aws_service =
          (Util.option_map (Json.lookup j "aws_service") String.of_json);
        co_ip = (Util.option_map (Json.lookup j "co_ip") String.of_json)
      }
  end
module TargetConfigurationRequest =
  struct
    type t = {
      instance_count: Integer.t option ;
      offering_id: String.t }
    let make ?instance_count  ~offering_id  () =
      { instance_count; offering_id }
    let parse xml =
      Some
        {
          instance_count =
            (Util.option_bind (Xml.member "InstanceCount" xml) Integer.parse);
          offering_id =
            (Xml.required "OfferingId"
               (Util.option_bind (Xml.member "OfferingId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("OfferingId", (String.to_query v.offering_id)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_count
               (fun f ->
                  Ezxmlm.make_tag "InstanceCount" ([], (Integer.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "OfferingId"
                 ([], (String.to_xml v.offering_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("offering_id", (String.to_json v.offering_id));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)))])
    let of_json j =
      {
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        offering_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "offering_id")))
      }
  end
module StaleSecurityGroup =
  struct
    type t =
      {
      description: String.t option ;
      group_id: String.t option ;
      group_name: String.t option ;
      stale_ip_permissions: StaleIpPermissionSet.t ;
      stale_ip_permissions_egress: StaleIpPermissionSet.t ;
      vpc_id: String.t option }
    let make ?description  ?group_id  ?group_name  ?(stale_ip_permissions=
      [])  ?(stale_ip_permissions_egress= [])  ?vpc_id  () =
      {
        description;
        group_id;
        group_name;
        stale_ip_permissions;
        stale_ip_permissions_egress;
        vpc_id
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          stale_ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "staleIpPermissions" xml)
                  StaleIpPermissionSet.parse));
          stale_ip_permissions_egress =
            (Util.of_option []
               (Util.option_bind (Xml.member "staleIpPermissionsEgress" xml)
                  StaleIpPermissionSet.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some
             (Query.Pair
                ("StaleIpPermissionsEgress",
                  (StaleIpPermissionSet.to_query
                     v.stale_ip_permissions_egress)));
           Some
             (Query.Pair
                ("StaleIpPermissions",
                  (StaleIpPermissionSet.to_query v.stale_ip_permissions)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.description
                   (fun f ->
                      Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
               @
               [Util.option_map v.group_id
                  (fun f -> Ezxmlm.make_tag "groupId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.group_name
                 (fun f ->
                    Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "staleIpPermissions"
                        ([], (StaleIpPermissionSet.to_xml [x]))))
                v.stale_ip_permissions))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "staleIpPermissionsEgress"
                       ([], (StaleIpPermissionSet.to_xml [x]))))
               v.stale_ip_permissions_egress))
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Some
             ("stale_ip_permissions_egress",
               (StaleIpPermissionSet.to_json v.stale_ip_permissions_egress));
           Some
             ("stale_ip_permissions",
               (StaleIpPermissionSet.to_json v.stale_ip_permissions));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        stale_ip_permissions =
          (StaleIpPermissionSet.of_json
             (Util.of_option_exn (Json.lookup j "stale_ip_permissions")));
        stale_ip_permissions_egress =
          (StaleIpPermissionSet.of_json
             (Util.of_option_exn
                (Json.lookup j "stale_ip_permissions_egress")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module SecurityGroupReference =
  struct
    type t =
      {
      group_id: String.t option ;
      referencing_vpc_id: String.t option ;
      vpc_peering_connection_id: String.t option }
    let make ?group_id  ?referencing_vpc_id  ?vpc_peering_connection_id  () =
      { group_id; referencing_vpc_id; vpc_peering_connection_id }
    let parse xml =
      Some
        {
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          referencing_vpc_id =
            (Util.option_bind (Xml.member "referencingVpcId" xml)
               String.parse);
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Util.option_map v.referencing_vpc_id
             (fun f -> Query.Pair ("ReferencingVpcId", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.group_id
                (fun f -> Ezxmlm.make_tag "groupId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.referencing_vpc_id
               (fun f ->
                  Ezxmlm.make_tag "referencingVpcId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Ezxmlm.make_tag "vpcPeeringConnectionId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Util.option_map v.referencing_vpc_id
             (fun f -> ("referencing_vpc_id", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)))])
    let of_json j =
      {
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        referencing_vpc_id =
          (Util.option_map (Json.lookup j "referencing_vpc_id")
             String.of_json);
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module AssignedPrivateIpAddress =
  struct
    type t = {
      private_ip_address: String.t option }
    let make ?private_ip_address  () = { private_ip_address }
    let parse xml =
      Some
        {
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.private_ip_address
              (fun f ->
                 Ezxmlm.make_tag "privateIpAddress" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)))])
    let of_json j =
      {
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json)
      }
  end
module LocalGatewayRouteTableVpcAssociation =
  struct
    type t =
      {
      local_gateway_route_table_vpc_association_id: String.t option ;
      local_gateway_route_table_id: String.t option ;
      local_gateway_id: String.t option ;
      vpc_id: String.t option ;
      state: String.t option }
    let make ?local_gateway_route_table_vpc_association_id 
      ?local_gateway_route_table_id  ?local_gateway_id  ?vpc_id  ?state  () =
      {
        local_gateway_route_table_vpc_association_id;
        local_gateway_route_table_id;
        local_gateway_id;
        vpc_id;
        state
      }
    let parse xml =
      Some
        {
          local_gateway_route_table_vpc_association_id =
            (Util.option_bind
               (Xml.member "localGatewayRouteTableVpcAssociationId" xml)
               String.parse);
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_vpc_association_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayRouteTableVpcAssociationId",
                    (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map
                  v.local_gateway_route_table_vpc_association_id
                  (fun f ->
                     Ezxmlm.make_tag "localGatewayRouteTableVpcAssociationId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.local_gateway_route_table_id
                 (fun f ->
                    Ezxmlm.make_tag "localGatewayRouteTableId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.local_gateway_id
                (fun f ->
                   Ezxmlm.make_tag "localGatewayId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.vpc_id
               (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f -> Ezxmlm.make_tag "state" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f -> ("local_gateway_route_table_id", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_vpc_association_id
             (fun f ->
                ("local_gateway_route_table_vpc_association_id",
                  (String.to_json f)))])
    let of_json j =
      {
        local_gateway_route_table_vpc_association_id =
          (Util.option_map
             (Json.lookup j "local_gateway_route_table_vpc_association_id")
             String.of_json);
        local_gateway_route_table_id =
          (Util.option_map (Json.lookup j "local_gateway_route_table_id")
             String.of_json);
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        state = (Util.option_map (Json.lookup j "state") String.of_json)
      }
  end
module CreateVolumePermissionList =
  struct
    type t = CreateVolumePermission.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CreateVolumePermission.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CreateVolumePermission.to_query v
    let to_headers v =
      Headers.to_headers_list CreateVolumePermission.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (CreateVolumePermission.to_xml x)))
        v
    let to_json v = `List (List.map CreateVolumePermission.to_json v)
    let of_json j = Json.to_list CreateVolumePermission.of_json j
  end
module Volume =
  struct
    type t =
      {
      attachments: VolumeAttachmentList.t ;
      availability_zone: String.t ;
      create_time: DateTime.t ;
      encrypted: Boolean.t ;
      kms_key_id: String.t option ;
      outpost_arn: String.t option ;
      size: Integer.t ;
      snapshot_id: String.t ;
      state: VolumeState.t ;
      volume_id: String.t ;
      iops: Integer.t option ;
      tags: TagList.t ;
      volume_type: VolumeType.t ;
      fast_restored: Boolean.t option }
    let make ?(attachments= [])  ~availability_zone  ~create_time  ~encrypted
       ?kms_key_id  ?outpost_arn  ~size  ~snapshot_id  ~state  ~volume_id 
      ?iops  ?(tags= [])  ~volume_type  ?fast_restored  () =
      {
        attachments;
        availability_zone;
        create_time;
        encrypted;
        kms_key_id;
        outpost_arn;
        size;
        snapshot_id;
        state;
        volume_id;
        iops;
        tags;
        volume_type;
        fast_restored
      }
    let parse xml =
      Some
        {
          attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "attachmentSet" xml)
                  VolumeAttachmentList.parse));
          availability_zone =
            (Xml.required "availabilityZone"
               (Util.option_bind (Xml.member "availabilityZone" xml)
                  String.parse));
          create_time =
            (Xml.required "createTime"
               (Util.option_bind (Xml.member "createTime" xml) DateTime.parse));
          encrypted =
            (Xml.required "encrypted"
               (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse));
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          size =
            (Xml.required "size"
               (Util.option_bind (Xml.member "size" xml) Integer.parse));
          snapshot_id =
            (Xml.required "snapshotId"
               (Util.option_bind (Xml.member "snapshotId" xml) String.parse));
          state =
            (Xml.required "status"
               (Util.option_bind (Xml.member "status" xml) VolumeState.parse));
          volume_id =
            (Xml.required "volumeId"
               (Util.option_bind (Xml.member "volumeId" xml) String.parse));
          iops = (Util.option_bind (Xml.member "iops" xml) Integer.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          volume_type =
            (Xml.required "volumeType"
               (Util.option_bind (Xml.member "volumeType" xml)
                  VolumeType.parse));
          fast_restored =
            (Util.option_bind (Xml.member "fastRestored" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fast_restored
              (fun f -> Query.Pair ("FastRestored", (Boolean.to_query f)));
           Some
             (Query.Pair ("VolumeType", (VolumeType.to_query v.volume_type)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Some (Query.Pair ("Status", (VolumeState.to_query v.state)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Some (Query.Pair ("Size", (Integer.to_query v.size)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Some (Query.Pair ("Encrypted", (Boolean.to_query v.encrypted)));
           Some
             (Query.Pair ("CreateTime", (DateTime.to_query v.create_time)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)));
           Some
             (Query.Pair
                ("AttachmentSet",
                  (VolumeAttachmentList.to_query v.attachments)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        (List.map
                           (fun x ->
                              Some
                                (Ezxmlm.make_tag "attachmentSet"
                                   ([], (VolumeAttachmentList.to_xml [x]))))
                           v.attachments))
                       @
                       [Some
                          (Ezxmlm.make_tag "availabilityZone"
                             ([], (String.to_xml v.availability_zone)))])
                      @
                      [Some
                         (Ezxmlm.make_tag "createTime"
                            ([], (DateTime.to_xml v.create_time)))])
                     @
                     [Some
                        (Ezxmlm.make_tag "encrypted"
                           ([], (Boolean.to_xml v.encrypted)))])
                    @
                    [Util.option_map v.kms_key_id
                       (fun f ->
                          Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.outpost_arn
                      (fun f ->
                         Ezxmlm.make_tag "outpostArn" ([], (String.to_xml f)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "size" ([], (Integer.to_xml v.size)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "snapshotId"
                       ([], (String.to_xml v.snapshot_id)))])
                @
                [Some
                   (Ezxmlm.make_tag "status"
                      ([], (VolumeState.to_xml v.state)))])
               @
               [Some
                  (Ezxmlm.make_tag "volumeId"
                     ([], (String.to_xml v.volume_id)))])
              @
              [Util.option_map v.iops
                 (fun f -> Ezxmlm.make_tag "iops" ([], (Integer.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
                v.tags))
            @
            [Some
               (Ezxmlm.make_tag "volumeType"
                  ([], (VolumeType.to_xml v.volume_type)))])
           @
           [Util.option_map v.fast_restored
              (fun f ->
                 Ezxmlm.make_tag "fastRestored" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fast_restored
              (fun f -> ("fast_restored", (Boolean.to_json f)));
           Some ("volume_type", (VolumeType.to_json v.volume_type));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Some ("state", (VolumeState.to_json v.state));
           Some ("snapshot_id", (String.to_json v.snapshot_id));
           Some ("size", (Integer.to_json v.size));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Some ("encrypted", (Boolean.to_json v.encrypted));
           Some ("create_time", (DateTime.to_json v.create_time));
           Some ("availability_zone", (String.to_json v.availability_zone));
           Some ("attachments", (VolumeAttachmentList.to_json v.attachments))])
    let of_json j =
      {
        attachments =
          (VolumeAttachmentList.of_json
             (Util.of_option_exn (Json.lookup j "attachments")));
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        create_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "create_time")));
        encrypted =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "encrypted")));
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        size = (Integer.of_json (Util.of_option_exn (Json.lookup j "size")));
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        state =
          (VolumeState.of_json (Util.of_option_exn (Json.lookup j "state")));
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        volume_type =
          (VolumeType.of_json
             (Util.of_option_exn (Json.lookup j "volume_type")));
        fast_restored =
          (Util.option_map (Json.lookup j "fast_restored") Boolean.of_json)
      }
  end
module ClientVpnConnection =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option ;
      timestamp: String.t option ;
      connection_id: String.t option ;
      username: String.t option ;
      connection_established_time: String.t option ;
      ingress_bytes: String.t option ;
      egress_bytes: String.t option ;
      ingress_packets: String.t option ;
      egress_packets: String.t option ;
      client_ip: String.t option ;
      common_name: String.t option ;
      status: ClientVpnConnectionStatus.t option ;
      connection_end_time: String.t option }
    let make ?client_vpn_endpoint_id  ?timestamp  ?connection_id  ?username 
      ?connection_established_time  ?ingress_bytes  ?egress_bytes 
      ?ingress_packets  ?egress_packets  ?client_ip  ?common_name  ?status 
      ?connection_end_time  () =
      {
        client_vpn_endpoint_id;
        timestamp;
        connection_id;
        username;
        connection_established_time;
        ingress_bytes;
        egress_bytes;
        ingress_packets;
        egress_packets;
        client_ip;
        common_name;
        status;
        connection_end_time
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) String.parse);
          connection_id =
            (Util.option_bind (Xml.member "connectionId" xml) String.parse);
          username =
            (Util.option_bind (Xml.member "username" xml) String.parse);
          connection_established_time =
            (Util.option_bind (Xml.member "connectionEstablishedTime" xml)
               String.parse);
          ingress_bytes =
            (Util.option_bind (Xml.member "ingressBytes" xml) String.parse);
          egress_bytes =
            (Util.option_bind (Xml.member "egressBytes" xml) String.parse);
          ingress_packets =
            (Util.option_bind (Xml.member "ingressPackets" xml) String.parse);
          egress_packets =
            (Util.option_bind (Xml.member "egressPackets" xml) String.parse);
          client_ip =
            (Util.option_bind (Xml.member "clientIp" xml) String.parse);
          common_name =
            (Util.option_bind (Xml.member "commonName" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnConnectionStatus.parse);
          connection_end_time =
            (Util.option_bind (Xml.member "connectionEndTime" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.connection_end_time
              (fun f -> Query.Pair ("ConnectionEndTime", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (ClientVpnConnectionStatus.to_query f)));
           Util.option_map v.common_name
             (fun f -> Query.Pair ("CommonName", (String.to_query f)));
           Util.option_map v.client_ip
             (fun f -> Query.Pair ("ClientIp", (String.to_query f)));
           Util.option_map v.egress_packets
             (fun f -> Query.Pair ("EgressPackets", (String.to_query f)));
           Util.option_map v.ingress_packets
             (fun f -> Query.Pair ("IngressPackets", (String.to_query f)));
           Util.option_map v.egress_bytes
             (fun f -> Query.Pair ("EgressBytes", (String.to_query f)));
           Util.option_map v.ingress_bytes
             (fun f -> Query.Pair ("IngressBytes", (String.to_query f)));
           Util.option_map v.connection_established_time
             (fun f ->
                Query.Pair ("ConnectionEstablishedTime", (String.to_query f)));
           Util.option_map v.username
             (fun f -> Query.Pair ("Username", (String.to_query f)));
           Util.option_map v.connection_id
             (fun f -> Query.Pair ("ConnectionId", (String.to_query f)));
           Util.option_map v.timestamp
             (fun f -> Query.Pair ("Timestamp", (String.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.client_vpn_endpoint_id
                          (fun f ->
                             Ezxmlm.make_tag "clientVpnEndpointId"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.timestamp
                         (fun f ->
                            Ezxmlm.make_tag "timestamp"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.connection_id
                        (fun f ->
                           Ezxmlm.make_tag "connectionId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.username
                       (fun f ->
                          Ezxmlm.make_tag "username" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.connection_established_time
                      (fun f ->
                         Ezxmlm.make_tag "connectionEstablishedTime"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.ingress_bytes
                     (fun f ->
                        Ezxmlm.make_tag "ingressBytes"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.egress_bytes
                    (fun f ->
                       Ezxmlm.make_tag "egressBytes" ([], (String.to_xml f)))])
                @
                [Util.option_map v.ingress_packets
                   (fun f ->
                      Ezxmlm.make_tag "ingressPackets"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.egress_packets
                  (fun f ->
                     Ezxmlm.make_tag "egressPackets" ([], (String.to_xml f)))])
              @
              [Util.option_map v.client_ip
                 (fun f -> Ezxmlm.make_tag "clientIp" ([], (String.to_xml f)))])
             @
             [Util.option_map v.common_name
                (fun f ->
                   Ezxmlm.make_tag "commonName" ([], (String.to_xml f)))])
            @
            [Util.option_map v.status
               (fun f ->
                  Ezxmlm.make_tag "status"
                    ([], (ClientVpnConnectionStatus.to_xml f)))])
           @
           [Util.option_map v.connection_end_time
              (fun f ->
                 Ezxmlm.make_tag "connectionEndTime" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.connection_end_time
              (fun f -> ("connection_end_time", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ClientVpnConnectionStatus.to_json f)));
           Util.option_map v.common_name
             (fun f -> ("common_name", (String.to_json f)));
           Util.option_map v.client_ip
             (fun f -> ("client_ip", (String.to_json f)));
           Util.option_map v.egress_packets
             (fun f -> ("egress_packets", (String.to_json f)));
           Util.option_map v.ingress_packets
             (fun f -> ("ingress_packets", (String.to_json f)));
           Util.option_map v.egress_bytes
             (fun f -> ("egress_bytes", (String.to_json f)));
           Util.option_map v.ingress_bytes
             (fun f -> ("ingress_bytes", (String.to_json f)));
           Util.option_map v.connection_established_time
             (fun f -> ("connection_established_time", (String.to_json f)));
           Util.option_map v.username
             (fun f -> ("username", (String.to_json f)));
           Util.option_map v.connection_id
             (fun f -> ("connection_id", (String.to_json f)));
           Util.option_map v.timestamp
             (fun f -> ("timestamp", (String.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (Util.option_map (Json.lookup j "client_vpn_endpoint_id")
             String.of_json);
        timestamp =
          (Util.option_map (Json.lookup j "timestamp") String.of_json);
        connection_id =
          (Util.option_map (Json.lookup j "connection_id") String.of_json);
        username =
          (Util.option_map (Json.lookup j "username") String.of_json);
        connection_established_time =
          (Util.option_map (Json.lookup j "connection_established_time")
             String.of_json);
        ingress_bytes =
          (Util.option_map (Json.lookup j "ingress_bytes") String.of_json);
        egress_bytes =
          (Util.option_map (Json.lookup j "egress_bytes") String.of_json);
        ingress_packets =
          (Util.option_map (Json.lookup j "ingress_packets") String.of_json);
        egress_packets =
          (Util.option_map (Json.lookup j "egress_packets") String.of_json);
        client_ip =
          (Util.option_map (Json.lookup j "client_ip") String.of_json);
        common_name =
          (Util.option_map (Json.lookup j "common_name") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnConnectionStatus.of_json);
        connection_end_time =
          (Util.option_map (Json.lookup j "connection_end_time")
             String.of_json)
      }
  end
module LocalGatewayRouteTable =
  struct
    type t =
      {
      local_gateway_route_table_id: String.t option ;
      local_gateway_id: String.t option ;
      outpost_arn: String.t option ;
      state: String.t option }
    let make ?local_gateway_route_table_id  ?local_gateway_id  ?outpost_arn 
      ?state  () =
      { local_gateway_route_table_id; local_gateway_id; outpost_arn; state }
    let parse xml =
      Some
        {
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (String.to_query f)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.local_gateway_route_table_id
                 (fun f ->
                    Ezxmlm.make_tag "localGatewayRouteTableId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.local_gateway_id
                (fun f ->
                   Ezxmlm.make_tag "localGatewayId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.outpost_arn
               (fun f -> Ezxmlm.make_tag "outpostArn" ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f -> Ezxmlm.make_tag "state" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f -> ("local_gateway_route_table_id", (String.to_json f)))])
    let of_json j =
      {
        local_gateway_route_table_id =
          (Util.option_map (Json.lookup j "local_gateway_route_table_id")
             String.of_json);
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        state = (Util.option_map (Json.lookup j "state") String.of_json)
      }
  end
module Region =
  struct
    type t =
      {
      endpoint: String.t option ;
      region_name: String.t option ;
      opt_in_status: String.t option }
    let make ?endpoint  ?region_name  ?opt_in_status  () =
      { endpoint; region_name; opt_in_status }
    let parse xml =
      Some
        {
          endpoint =
            (Util.option_bind (Xml.member "regionEndpoint" xml) String.parse);
          region_name =
            (Util.option_bind (Xml.member "regionName" xml) String.parse);
          opt_in_status =
            (Util.option_bind (Xml.member "optInStatus" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.opt_in_status
              (fun f -> Query.Pair ("OptInStatus", (String.to_query f)));
           Util.option_map v.region_name
             (fun f -> Query.Pair ("RegionName", (String.to_query f)));
           Util.option_map v.endpoint
             (fun f -> Query.Pair ("RegionEndpoint", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.endpoint
                (fun f ->
                   Ezxmlm.make_tag "regionEndpoint" ([], (String.to_xml f)))])
            @
            [Util.option_map v.region_name
               (fun f -> Ezxmlm.make_tag "regionName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.opt_in_status
              (fun f -> Ezxmlm.make_tag "optInStatus" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.opt_in_status
              (fun f -> ("opt_in_status", (String.to_json f)));
           Util.option_map v.region_name
             (fun f -> ("region_name", (String.to_json f)));
           Util.option_map v.endpoint
             (fun f -> ("endpoint", (String.to_json f)))])
    let of_json j =
      {
        endpoint =
          (Util.option_map (Json.lookup j "endpoint") String.of_json);
        region_name =
          (Util.option_map (Json.lookup j "region_name") String.of_json);
        opt_in_status =
          (Util.option_map (Json.lookup j "opt_in_status") String.of_json)
      }
  end
module VpnTunnelOptionsSpecificationsList =
  struct
    type t = VpnTunnelOptionsSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpnTunnelOptionsSpecification.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list VpnTunnelOptionsSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list VpnTunnelOptionsSpecification.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (VpnTunnelOptionsSpecification.to_xml x))) v
    let to_json v = `List (List.map VpnTunnelOptionsSpecification.to_json v)
    let of_json j = Json.to_list VpnTunnelOptionsSpecification.of_json j
  end
module Address =
  struct
    type t =
      {
      instance_id: String.t option ;
      public_ip: String.t option ;
      allocation_id: String.t option ;
      association_id: String.t option ;
      domain: DomainType.t option ;
      network_interface_id: String.t option ;
      network_interface_owner_id: String.t option ;
      private_ip_address: String.t option ;
      tags: TagList.t ;
      public_ipv4_pool: String.t option ;
      network_border_group: String.t option ;
      customer_owned_ip: String.t option ;
      customer_owned_ipv4_pool: String.t option }
    let make ?instance_id  ?public_ip  ?allocation_id  ?association_id 
      ?domain  ?network_interface_id  ?network_interface_owner_id 
      ?private_ip_address  ?(tags= [])  ?public_ipv4_pool 
      ?network_border_group  ?customer_owned_ip  ?customer_owned_ipv4_pool 
      () =
      {
        instance_id;
        public_ip;
        allocation_id;
        association_id;
        domain;
        network_interface_id;
        network_interface_owner_id;
        private_ip_address;
        tags;
        public_ipv4_pool;
        network_border_group;
        customer_owned_ip;
        customer_owned_ipv4_pool
      }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse);
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          domain =
            (Util.option_bind (Xml.member "domain" xml) DomainType.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          network_interface_owner_id =
            (Util.option_bind (Xml.member "networkInterfaceOwnerId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          public_ipv4_pool =
            (Util.option_bind (Xml.member "publicIpv4Pool" xml) String.parse);
          network_border_group =
            (Util.option_bind (Xml.member "networkBorderGroup" xml)
               String.parse);
          customer_owned_ip =
            (Util.option_bind (Xml.member "customerOwnedIp" xml) String.parse);
          customer_owned_ipv4_pool =
            (Util.option_bind (Xml.member "customerOwnedIpv4Pool" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.customer_owned_ipv4_pool
              (fun f ->
                 Query.Pair ("CustomerOwnedIpv4Pool", (String.to_query f)));
           Util.option_map v.customer_owned_ip
             (fun f -> Query.Pair ("CustomerOwnedIp", (String.to_query f)));
           Util.option_map v.network_border_group
             (fun f -> Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.public_ipv4_pool
             (fun f -> Query.Pair ("PublicIpv4Pool", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_owner_id
             (fun f ->
                Query.Pair ("NetworkInterfaceOwnerId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.domain
             (fun f -> Query.Pair ("Domain", (DomainType.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.instance_id
                          (fun f ->
                             Ezxmlm.make_tag "instanceId"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.public_ip
                         (fun f ->
                            Ezxmlm.make_tag "publicIp"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.allocation_id
                        (fun f ->
                           Ezxmlm.make_tag "allocationId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.association_id
                       (fun f ->
                          Ezxmlm.make_tag "associationId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.domain
                      (fun f ->
                         Ezxmlm.make_tag "domain" ([], (DomainType.to_xml f)))])
                  @
                  [Util.option_map v.network_interface_id
                     (fun f ->
                        Ezxmlm.make_tag "networkInterfaceId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.network_interface_owner_id
                    (fun f ->
                       Ezxmlm.make_tag "networkInterfaceOwnerId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.private_ip_address
                   (fun f ->
                      Ezxmlm.make_tag "privateIpAddress"
                        ([], (String.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
                  v.tags))
              @
              [Util.option_map v.public_ipv4_pool
                 (fun f ->
                    Ezxmlm.make_tag "publicIpv4Pool" ([], (String.to_xml f)))])
             @
             [Util.option_map v.network_border_group
                (fun f ->
                   Ezxmlm.make_tag "networkBorderGroup"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.customer_owned_ip
               (fun f ->
                  Ezxmlm.make_tag "customerOwnedIp" ([], (String.to_xml f)))])
           @
           [Util.option_map v.customer_owned_ipv4_pool
              (fun f ->
                 Ezxmlm.make_tag "customerOwnedIpv4Pool"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.customer_owned_ipv4_pool
              (fun f -> ("customer_owned_ipv4_pool", (String.to_json f)));
           Util.option_map v.customer_owned_ip
             (fun f -> ("customer_owned_ip", (String.to_json f)));
           Util.option_map v.network_border_group
             (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.public_ipv4_pool
             (fun f -> ("public_ipv4_pool", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_owner_id
             (fun f -> ("network_interface_owner_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.domain
             (fun f -> ("domain", (DomainType.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        domain =
          (Util.option_map (Json.lookup j "domain") DomainType.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        network_interface_owner_id =
          (Util.option_map (Json.lookup j "network_interface_owner_id")
             String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        public_ipv4_pool =
          (Util.option_map (Json.lookup j "public_ipv4_pool") String.of_json);
        network_border_group =
          (Util.option_map (Json.lookup j "network_border_group")
             String.of_json);
        customer_owned_ip =
          (Util.option_map (Json.lookup j "customer_owned_ip") String.of_json);
        customer_owned_ipv4_pool =
          (Util.option_map (Json.lookup j "customer_owned_ipv4_pool")
             String.of_json)
      }
  end
module InstanceTypeInfo =
  struct
    type t =
      {
      instance_type: InstanceType.t option ;
      current_generation: Boolean.t option ;
      free_tier_eligible: Boolean.t option ;
      supported_usage_classes: UsageClassTypeList.t ;
      supported_root_device_types: RootDeviceTypeList.t ;
      bare_metal: Boolean.t option ;
      hypervisor: InstanceTypeHypervisor.t option ;
      processor_info: ProcessorInfo.t option ;
      v_cpu_info: VCpuInfo.t option ;
      memory_info: MemoryInfo.t option ;
      instance_storage_supported: Boolean.t option ;
      instance_storage_info: InstanceStorageInfo.t option ;
      ebs_info: EbsInfo.t option ;
      network_info: NetworkInfo.t option ;
      gpu_info: GpuInfo.t option ;
      fpga_info: FpgaInfo.t option ;
      placement_group_info: PlacementGroupInfo.t option ;
      inference_accelerator_info: InferenceAcceleratorInfo.t option ;
      hibernation_supported: Boolean.t option ;
      burstable_performance_supported: Boolean.t option ;
      dedicated_hosts_supported: Boolean.t option ;
      auto_recovery_supported: Boolean.t option }
    let make ?instance_type  ?current_generation  ?free_tier_eligible 
      ?(supported_usage_classes= [])  ?(supported_root_device_types= []) 
      ?bare_metal  ?hypervisor  ?processor_info  ?v_cpu_info  ?memory_info 
      ?instance_storage_supported  ?instance_storage_info  ?ebs_info 
      ?network_info  ?gpu_info  ?fpga_info  ?placement_group_info 
      ?inference_accelerator_info  ?hibernation_supported 
      ?burstable_performance_supported  ?dedicated_hosts_supported 
      ?auto_recovery_supported  () =
      {
        instance_type;
        current_generation;
        free_tier_eligible;
        supported_usage_classes;
        supported_root_device_types;
        bare_metal;
        hypervisor;
        processor_info;
        v_cpu_info;
        memory_info;
        instance_storage_supported;
        instance_storage_info;
        ebs_info;
        network_info;
        gpu_info;
        fpga_info;
        placement_group_info;
        inference_accelerator_info;
        hibernation_supported;
        burstable_performance_supported;
        dedicated_hosts_supported;
        auto_recovery_supported
      }
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          current_generation =
            (Util.option_bind (Xml.member "currentGeneration" xml)
               Boolean.parse);
          free_tier_eligible =
            (Util.option_bind (Xml.member "freeTierEligible" xml)
               Boolean.parse);
          supported_usage_classes =
            (Util.of_option []
               (Util.option_bind (Xml.member "supportedUsageClasses" xml)
                  UsageClassTypeList.parse));
          supported_root_device_types =
            (Util.of_option []
               (Util.option_bind (Xml.member "supportedRootDeviceTypes" xml)
                  RootDeviceTypeList.parse));
          bare_metal =
            (Util.option_bind (Xml.member "bareMetal" xml) Boolean.parse);
          hypervisor =
            (Util.option_bind (Xml.member "hypervisor" xml)
               InstanceTypeHypervisor.parse);
          processor_info =
            (Util.option_bind (Xml.member "processorInfo" xml)
               ProcessorInfo.parse);
          v_cpu_info =
            (Util.option_bind (Xml.member "vCpuInfo" xml) VCpuInfo.parse);
          memory_info =
            (Util.option_bind (Xml.member "memoryInfo" xml) MemoryInfo.parse);
          instance_storage_supported =
            (Util.option_bind (Xml.member "instanceStorageSupported" xml)
               Boolean.parse);
          instance_storage_info =
            (Util.option_bind (Xml.member "instanceStorageInfo" xml)
               InstanceStorageInfo.parse);
          ebs_info =
            (Util.option_bind (Xml.member "ebsInfo" xml) EbsInfo.parse);
          network_info =
            (Util.option_bind (Xml.member "networkInfo" xml)
               NetworkInfo.parse);
          gpu_info =
            (Util.option_bind (Xml.member "gpuInfo" xml) GpuInfo.parse);
          fpga_info =
            (Util.option_bind (Xml.member "fpgaInfo" xml) FpgaInfo.parse);
          placement_group_info =
            (Util.option_bind (Xml.member "placementGroupInfo" xml)
               PlacementGroupInfo.parse);
          inference_accelerator_info =
            (Util.option_bind (Xml.member "inferenceAcceleratorInfo" xml)
               InferenceAcceleratorInfo.parse);
          hibernation_supported =
            (Util.option_bind (Xml.member "hibernationSupported" xml)
               Boolean.parse);
          burstable_performance_supported =
            (Util.option_bind
               (Xml.member "burstablePerformanceSupported" xml) Boolean.parse);
          dedicated_hosts_supported =
            (Util.option_bind (Xml.member "dedicatedHostsSupported" xml)
               Boolean.parse);
          auto_recovery_supported =
            (Util.option_bind (Xml.member "autoRecoverySupported" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.auto_recovery_supported
              (fun f ->
                 Query.Pair ("AutoRecoverySupported", (Boolean.to_query f)));
           Util.option_map v.dedicated_hosts_supported
             (fun f ->
                Query.Pair ("DedicatedHostsSupported", (Boolean.to_query f)));
           Util.option_map v.burstable_performance_supported
             (fun f ->
                Query.Pair
                  ("BurstablePerformanceSupported", (Boolean.to_query f)));
           Util.option_map v.hibernation_supported
             (fun f ->
                Query.Pair ("HibernationSupported", (Boolean.to_query f)));
           Util.option_map v.inference_accelerator_info
             (fun f ->
                Query.Pair
                  ("InferenceAcceleratorInfo",
                    (InferenceAcceleratorInfo.to_query f)));
           Util.option_map v.placement_group_info
             (fun f ->
                Query.Pair
                  ("PlacementGroupInfo", (PlacementGroupInfo.to_query f)));
           Util.option_map v.fpga_info
             (fun f -> Query.Pair ("FpgaInfo", (FpgaInfo.to_query f)));
           Util.option_map v.gpu_info
             (fun f -> Query.Pair ("GpuInfo", (GpuInfo.to_query f)));
           Util.option_map v.network_info
             (fun f -> Query.Pair ("NetworkInfo", (NetworkInfo.to_query f)));
           Util.option_map v.ebs_info
             (fun f -> Query.Pair ("EbsInfo", (EbsInfo.to_query f)));
           Util.option_map v.instance_storage_info
             (fun f ->
                Query.Pair
                  ("InstanceStorageInfo", (InstanceStorageInfo.to_query f)));
           Util.option_map v.instance_storage_supported
             (fun f ->
                Query.Pair ("InstanceStorageSupported", (Boolean.to_query f)));
           Util.option_map v.memory_info
             (fun f -> Query.Pair ("MemoryInfo", (MemoryInfo.to_query f)));
           Util.option_map v.v_cpu_info
             (fun f -> Query.Pair ("VCpuInfo", (VCpuInfo.to_query f)));
           Util.option_map v.processor_info
             (fun f ->
                Query.Pair ("ProcessorInfo", (ProcessorInfo.to_query f)));
           Util.option_map v.hypervisor
             (fun f ->
                Query.Pair
                  ("Hypervisor", (InstanceTypeHypervisor.to_query f)));
           Util.option_map v.bare_metal
             (fun f -> Query.Pair ("BareMetal", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SupportedRootDeviceTypes",
                  (RootDeviceTypeList.to_query v.supported_root_device_types)));
           Some
             (Query.Pair
                ("SupportedUsageClasses",
                  (UsageClassTypeList.to_query v.supported_usage_classes)));
           Util.option_map v.free_tier_eligible
             (fun f -> Query.Pair ("FreeTierEligible", (Boolean.to_query f)));
           Util.option_map v.current_generation
             (fun f -> Query.Pair ("CurrentGeneration", (Boolean.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((((((([] @
                                [Util.option_map v.instance_type
                                   (fun f ->
                                      Ezxmlm.make_tag "instanceType"
                                        ([], (InstanceType.to_xml f)))])
                               @
                               [Util.option_map v.current_generation
                                  (fun f ->
                                     Ezxmlm.make_tag "currentGeneration"
                                       ([], (Boolean.to_xml f)))])
                              @
                              [Util.option_map v.free_tier_eligible
                                 (fun f ->
                                    Ezxmlm.make_tag "freeTierEligible"
                                      ([], (Boolean.to_xml f)))])
                             @
                             (List.map
                                (fun x ->
                                   Some
                                     (Ezxmlm.make_tag "supportedUsageClasses"
                                        ([], (UsageClassTypeList.to_xml [x]))))
                                v.supported_usage_classes))
                            @
                            (List.map
                               (fun x ->
                                  Some
                                    (Ezxmlm.make_tag
                                       "supportedRootDeviceTypes"
                                       ([], (RootDeviceTypeList.to_xml [x]))))
                               v.supported_root_device_types))
                           @
                           [Util.option_map v.bare_metal
                              (fun f ->
                                 Ezxmlm.make_tag "bareMetal"
                                   ([], (Boolean.to_xml f)))])
                          @
                          [Util.option_map v.hypervisor
                             (fun f ->
                                Ezxmlm.make_tag "hypervisor"
                                  ([], (InstanceTypeHypervisor.to_xml f)))])
                         @
                         [Util.option_map v.processor_info
                            (fun f ->
                               Ezxmlm.make_tag "processorInfo"
                                 ([], (ProcessorInfo.to_xml f)))])
                        @
                        [Util.option_map v.v_cpu_info
                           (fun f ->
                              Ezxmlm.make_tag "vCpuInfo"
                                ([], (VCpuInfo.to_xml f)))])
                       @
                       [Util.option_map v.memory_info
                          (fun f ->
                             Ezxmlm.make_tag "memoryInfo"
                               ([], (MemoryInfo.to_xml f)))])
                      @
                      [Util.option_map v.instance_storage_supported
                         (fun f ->
                            Ezxmlm.make_tag "instanceStorageSupported"
                              ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.instance_storage_info
                        (fun f ->
                           Ezxmlm.make_tag "instanceStorageInfo"
                             ([], (InstanceStorageInfo.to_xml f)))])
                    @
                    [Util.option_map v.ebs_info
                       (fun f ->
                          Ezxmlm.make_tag "ebsInfo" ([], (EbsInfo.to_xml f)))])
                   @
                   [Util.option_map v.network_info
                      (fun f ->
                         Ezxmlm.make_tag "networkInfo"
                           ([], (NetworkInfo.to_xml f)))])
                  @
                  [Util.option_map v.gpu_info
                     (fun f ->
                        Ezxmlm.make_tag "gpuInfo" ([], (GpuInfo.to_xml f)))])
                 @
                 [Util.option_map v.fpga_info
                    (fun f ->
                       Ezxmlm.make_tag "fpgaInfo" ([], (FpgaInfo.to_xml f)))])
                @
                [Util.option_map v.placement_group_info
                   (fun f ->
                      Ezxmlm.make_tag "placementGroupInfo"
                        ([], (PlacementGroupInfo.to_xml f)))])
               @
               [Util.option_map v.inference_accelerator_info
                  (fun f ->
                     Ezxmlm.make_tag "inferenceAcceleratorInfo"
                       ([], (InferenceAcceleratorInfo.to_xml f)))])
              @
              [Util.option_map v.hibernation_supported
                 (fun f ->
                    Ezxmlm.make_tag "hibernationSupported"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.burstable_performance_supported
                (fun f ->
                   Ezxmlm.make_tag "burstablePerformanceSupported"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.dedicated_hosts_supported
               (fun f ->
                  Ezxmlm.make_tag "dedicatedHostsSupported"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.auto_recovery_supported
              (fun f ->
                 Ezxmlm.make_tag "autoRecoverySupported"
                   ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.auto_recovery_supported
              (fun f -> ("auto_recovery_supported", (Boolean.to_json f)));
           Util.option_map v.dedicated_hosts_supported
             (fun f -> ("dedicated_hosts_supported", (Boolean.to_json f)));
           Util.option_map v.burstable_performance_supported
             (fun f ->
                ("burstable_performance_supported", (Boolean.to_json f)));
           Util.option_map v.hibernation_supported
             (fun f -> ("hibernation_supported", (Boolean.to_json f)));
           Util.option_map v.inference_accelerator_info
             (fun f ->
                ("inference_accelerator_info",
                  (InferenceAcceleratorInfo.to_json f)));
           Util.option_map v.placement_group_info
             (fun f ->
                ("placement_group_info", (PlacementGroupInfo.to_json f)));
           Util.option_map v.fpga_info
             (fun f -> ("fpga_info", (FpgaInfo.to_json f)));
           Util.option_map v.gpu_info
             (fun f -> ("gpu_info", (GpuInfo.to_json f)));
           Util.option_map v.network_info
             (fun f -> ("network_info", (NetworkInfo.to_json f)));
           Util.option_map v.ebs_info
             (fun f -> ("ebs_info", (EbsInfo.to_json f)));
           Util.option_map v.instance_storage_info
             (fun f ->
                ("instance_storage_info", (InstanceStorageInfo.to_json f)));
           Util.option_map v.instance_storage_supported
             (fun f -> ("instance_storage_supported", (Boolean.to_json f)));
           Util.option_map v.memory_info
             (fun f -> ("memory_info", (MemoryInfo.to_json f)));
           Util.option_map v.v_cpu_info
             (fun f -> ("v_cpu_info", (VCpuInfo.to_json f)));
           Util.option_map v.processor_info
             (fun f -> ("processor_info", (ProcessorInfo.to_json f)));
           Util.option_map v.hypervisor
             (fun f -> ("hypervisor", (InstanceTypeHypervisor.to_json f)));
           Util.option_map v.bare_metal
             (fun f -> ("bare_metal", (Boolean.to_json f)));
           Some
             ("supported_root_device_types",
               (RootDeviceTypeList.to_json v.supported_root_device_types));
           Some
             ("supported_usage_classes",
               (UsageClassTypeList.to_json v.supported_usage_classes));
           Util.option_map v.free_tier_eligible
             (fun f -> ("free_tier_eligible", (Boolean.to_json f)));
           Util.option_map v.current_generation
             (fun f -> ("current_generation", (Boolean.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)))])
    let of_json j =
      {
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        current_generation =
          (Util.option_map (Json.lookup j "current_generation")
             Boolean.of_json);
        free_tier_eligible =
          (Util.option_map (Json.lookup j "free_tier_eligible")
             Boolean.of_json);
        supported_usage_classes =
          (UsageClassTypeList.of_json
             (Util.of_option_exn (Json.lookup j "supported_usage_classes")));
        supported_root_device_types =
          (RootDeviceTypeList.of_json
             (Util.of_option_exn
                (Json.lookup j "supported_root_device_types")));
        bare_metal =
          (Util.option_map (Json.lookup j "bare_metal") Boolean.of_json);
        hypervisor =
          (Util.option_map (Json.lookup j "hypervisor")
             InstanceTypeHypervisor.of_json);
        processor_info =
          (Util.option_map (Json.lookup j "processor_info")
             ProcessorInfo.of_json);
        v_cpu_info =
          (Util.option_map (Json.lookup j "v_cpu_info") VCpuInfo.of_json);
        memory_info =
          (Util.option_map (Json.lookup j "memory_info") MemoryInfo.of_json);
        instance_storage_supported =
          (Util.option_map (Json.lookup j "instance_storage_supported")
             Boolean.of_json);
        instance_storage_info =
          (Util.option_map (Json.lookup j "instance_storage_info")
             InstanceStorageInfo.of_json);
        ebs_info =
          (Util.option_map (Json.lookup j "ebs_info") EbsInfo.of_json);
        network_info =
          (Util.option_map (Json.lookup j "network_info") NetworkInfo.of_json);
        gpu_info =
          (Util.option_map (Json.lookup j "gpu_info") GpuInfo.of_json);
        fpga_info =
          (Util.option_map (Json.lookup j "fpga_info") FpgaInfo.of_json);
        placement_group_info =
          (Util.option_map (Json.lookup j "placement_group_info")
             PlacementGroupInfo.of_json);
        inference_accelerator_info =
          (Util.option_map (Json.lookup j "inference_accelerator_info")
             InferenceAcceleratorInfo.of_json);
        hibernation_supported =
          (Util.option_map (Json.lookup j "hibernation_supported")
             Boolean.of_json);
        burstable_performance_supported =
          (Util.option_map (Json.lookup j "burstable_performance_supported")
             Boolean.of_json);
        dedicated_hosts_supported =
          (Util.option_map (Json.lookup j "dedicated_hosts_supported")
             Boolean.of_json);
        auto_recovery_supported =
          (Util.option_map (Json.lookup j "auto_recovery_supported")
             Boolean.of_json)
      }
  end
module ClientVpnRoute =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option ;
      destination_cidr: String.t option ;
      target_subnet: String.t option ;
      type_: String.t option ;
      origin: String.t option ;
      status: ClientVpnRouteStatus.t option ;
      description: String.t option }
    let make ?client_vpn_endpoint_id  ?destination_cidr  ?target_subnet 
      ?type_  ?origin  ?status  ?description  () =
      {
        client_vpn_endpoint_id;
        destination_cidr;
        target_subnet;
        type_;
        origin;
        status;
        description
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          destination_cidr =
            (Util.option_bind (Xml.member "destinationCidr" xml) String.parse);
          target_subnet =
            (Util.option_bind (Xml.member "targetSubnet" xml) String.parse);
          type_ = (Util.option_bind (Xml.member "type" xml) String.parse);
          origin = (Util.option_bind (Xml.member "origin" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnRouteStatus.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (ClientVpnRouteStatus.to_query f)));
           Util.option_map v.origin
             (fun f -> Query.Pair ("Origin", (String.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (String.to_query f)));
           Util.option_map v.target_subnet
             (fun f -> Query.Pair ("TargetSubnet", (String.to_query f)));
           Util.option_map v.destination_cidr
             (fun f -> Query.Pair ("DestinationCidr", (String.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.client_vpn_endpoint_id
                    (fun f ->
                       Ezxmlm.make_tag "clientVpnEndpointId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.destination_cidr
                   (fun f ->
                      Ezxmlm.make_tag "destinationCidr"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.target_subnet
                  (fun f ->
                     Ezxmlm.make_tag "targetSubnet" ([], (String.to_xml f)))])
              @
              [Util.option_map v.type_
                 (fun f -> Ezxmlm.make_tag "type" ([], (String.to_xml f)))])
             @
             [Util.option_map v.origin
                (fun f -> Ezxmlm.make_tag "origin" ([], (String.to_xml f)))])
            @
            [Util.option_map v.status
               (fun f ->
                  Ezxmlm.make_tag "status"
                    ([], (ClientVpnRouteStatus.to_xml f)))])
           @
           [Util.option_map v.description
              (fun f -> Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ClientVpnRouteStatus.to_json f)));
           Util.option_map v.origin (fun f -> ("origin", (String.to_json f)));
           Util.option_map v.type_ (fun f -> ("type_", (String.to_json f)));
           Util.option_map v.target_subnet
             (fun f -> ("target_subnet", (String.to_json f)));
           Util.option_map v.destination_cidr
             (fun f -> ("destination_cidr", (String.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (Util.option_map (Json.lookup j "client_vpn_endpoint_id")
             String.of_json);
        destination_cidr =
          (Util.option_map (Json.lookup j "destination_cidr") String.of_json);
        target_subnet =
          (Util.option_map (Json.lookup j "target_subnet") String.of_json);
        type_ = (Util.option_map (Json.lookup j "type_") String.of_json);
        origin = (Util.option_map (Json.lookup j "origin") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnRouteStatus.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module VpnConnection =
  struct
    type t =
      {
      customer_gateway_configuration: String.t option ;
      customer_gateway_id: String.t ;
      category: String.t option ;
      state: VpnState.t ;
      type_: GatewayType.t ;
      vpn_connection_id: String.t ;
      vpn_gateway_id: String.t option ;
      transit_gateway_id: String.t option ;
      options: VpnConnectionOptions.t option ;
      routes: VpnStaticRouteList.t ;
      tags: TagList.t ;
      vgw_telemetry: VgwTelemetryList.t }
    let make ?customer_gateway_configuration  ~customer_gateway_id  ?category
       ~state  ~type_  ~vpn_connection_id  ?vpn_gateway_id 
      ?transit_gateway_id  ?options  ?(routes= [])  ?(tags= []) 
      ?(vgw_telemetry= [])  () =
      {
        customer_gateway_configuration;
        customer_gateway_id;
        category;
        state;
        type_;
        vpn_connection_id;
        vpn_gateway_id;
        transit_gateway_id;
        options;
        routes;
        tags;
        vgw_telemetry
      }
    let parse xml =
      Some
        {
          customer_gateway_configuration =
            (Util.option_bind (Xml.member "customerGatewayConfiguration" xml)
               String.parse);
          customer_gateway_id =
            (Xml.required "customerGatewayId"
               (Util.option_bind (Xml.member "customerGatewayId" xml)
                  String.parse));
          category =
            (Util.option_bind (Xml.member "category" xml) String.parse);
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml) VpnState.parse));
          type_ =
            (Xml.required "type"
               (Util.option_bind (Xml.member "type" xml) GatewayType.parse));
          vpn_connection_id =
            (Xml.required "vpnConnectionId"
               (Util.option_bind (Xml.member "vpnConnectionId" xml)
                  String.parse));
          vpn_gateway_id =
            (Util.option_bind (Xml.member "vpnGatewayId" xml) String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          options =
            (Util.option_bind (Xml.member "options" xml)
               VpnConnectionOptions.parse);
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routes" xml)
                  VpnStaticRouteList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vgw_telemetry =
            (Util.of_option []
               (Util.option_bind (Xml.member "vgwTelemetry" xml)
                  VgwTelemetryList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VgwTelemetry",
                   (VgwTelemetryList.to_query v.vgw_telemetry)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair ("Routes", (VpnStaticRouteList.to_query v.routes)));
           Util.option_map v.options
             (fun f ->
                Query.Pair ("Options", (VpnConnectionOptions.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> Query.Pair ("VpnGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("VpnConnectionId", (String.to_query v.vpn_connection_id)));
           Some (Query.Pair ("Type", (GatewayType.to_query v.type_)));
           Some (Query.Pair ("State", (VpnState.to_query v.state)));
           Util.option_map v.category
             (fun f -> Query.Pair ("Category", (String.to_query f)));
           Some
             (Query.Pair
                ("CustomerGatewayId",
                  (String.to_query v.customer_gateway_id)));
           Util.option_map v.customer_gateway_configuration
             (fun f ->
                Query.Pair
                  ("CustomerGatewayConfiguration", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Util.option_map v.customer_gateway_configuration
                         (fun f ->
                            Ezxmlm.make_tag "customerGatewayConfiguration"
                              ([], (String.to_xml f)))])
                     @
                     [Some
                        (Ezxmlm.make_tag "customerGatewayId"
                           ([], (String.to_xml v.customer_gateway_id)))])
                    @
                    [Util.option_map v.category
                       (fun f ->
                          Ezxmlm.make_tag "category" ([], (String.to_xml f)))])
                   @
                   [Some
                      (Ezxmlm.make_tag "state"
                         ([], (VpnState.to_xml v.state)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "type"
                        ([], (GatewayType.to_xml v.type_)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "vpnConnectionId"
                       ([], (String.to_xml v.vpn_connection_id)))])
                @
                [Util.option_map v.vpn_gateway_id
                   (fun f ->
                      Ezxmlm.make_tag "vpnGatewayId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.transit_gateway_id
                  (fun f ->
                     Ezxmlm.make_tag "transitGatewayId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.options
                 (fun f ->
                    Ezxmlm.make_tag "options"
                      ([], (VpnConnectionOptions.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "routes"
                        ([], (VpnStaticRouteList.to_xml [x])))) v.routes))
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "vgwTelemetry"
                      ([], (VgwTelemetryList.to_xml [x])))) v.vgw_telemetry))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vgw_telemetry", (VgwTelemetryList.to_json v.vgw_telemetry));
           Some ("tags", (TagList.to_json v.tags));
           Some ("routes", (VpnStaticRouteList.to_json v.routes));
           Util.option_map v.options
             (fun f -> ("options", (VpnConnectionOptions.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> ("vpn_gateway_id", (String.to_json f)));
           Some ("vpn_connection_id", (String.to_json v.vpn_connection_id));
           Some ("type_", (GatewayType.to_json v.type_));
           Some ("state", (VpnState.to_json v.state));
           Util.option_map v.category
             (fun f -> ("category", (String.to_json f)));
           Some
             ("customer_gateway_id", (String.to_json v.customer_gateway_id));
           Util.option_map v.customer_gateway_configuration
             (fun f -> ("customer_gateway_configuration", (String.to_json f)))])
    let of_json j =
      {
        customer_gateway_configuration =
          (Util.option_map (Json.lookup j "customer_gateway_configuration")
             String.of_json);
        customer_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateway_id")));
        category =
          (Util.option_map (Json.lookup j "category") String.of_json);
        state =
          (VpnState.of_json (Util.of_option_exn (Json.lookup j "state")));
        type_ =
          (GatewayType.of_json (Util.of_option_exn (Json.lookup j "type_")));
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")));
        vpn_gateway_id =
          (Util.option_map (Json.lookup j "vpn_gateway_id") String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        options =
          (Util.option_map (Json.lookup j "options")
             VpnConnectionOptions.of_json);
        routes =
          (VpnStaticRouteList.of_json
             (Util.of_option_exn (Json.lookup j "routes")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        vgw_telemetry =
          (VgwTelemetryList.of_json
             (Util.of_option_exn (Json.lookup j "vgw_telemetry")))
      }
  end
module TargetNetwork =
  struct
    type t =
      {
      association_id: String.t option ;
      vpc_id: String.t option ;
      target_network_id: String.t option ;
      client_vpn_endpoint_id: String.t option ;
      status: AssociationStatus.t option ;
      security_groups: ValueStringList.t }
    let make ?association_id  ?vpc_id  ?target_network_id 
      ?client_vpn_endpoint_id  ?status  ?(security_groups= [])  () =
      {
        association_id;
        vpc_id;
        target_network_id;
        client_vpn_endpoint_id;
        status;
        security_groups
      }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          target_network_id =
            (Util.option_bind (Xml.member "targetNetworkId" xml) String.parse);
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AssociationStatus.parse);
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroups" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SecurityGroups",
                   (ValueStringList.to_query v.security_groups)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (AssociationStatus.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)));
           Util.option_map v.target_network_id
             (fun f -> Query.Pair ("TargetNetworkId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.association_id
                   (fun f ->
                      Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.vpc_id
                  (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.target_network_id
                 (fun f ->
                    Ezxmlm.make_tag "targetNetworkId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.client_vpn_endpoint_id
                (fun f ->
                   Ezxmlm.make_tag "clientVpnEndpointId"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.status
               (fun f ->
                  Ezxmlm.make_tag "status" ([], (AssociationStatus.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "securityGroups"
                      ([], (ValueStringList.to_xml [x])))) v.security_groups))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("security_groups",
                (ValueStringList.to_json v.security_groups));
           Util.option_map v.status
             (fun f -> ("status", (AssociationStatus.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)));
           Util.option_map v.target_network_id
             (fun f -> ("target_network_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        target_network_id =
          (Util.option_map (Json.lookup j "target_network_id") String.of_json);
        client_vpn_endpoint_id =
          (Util.option_map (Json.lookup j "client_vpn_endpoint_id")
             String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") AssociationStatus.of_json);
        security_groups =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")))
      }
  end
module VpcPeeringConnection =
  struct
    type t =
      {
      accepter_vpc_info: VpcPeeringConnectionVpcInfo.t option ;
      expiration_time: DateTime.t option ;
      requester_vpc_info: VpcPeeringConnectionVpcInfo.t option ;
      status: VpcPeeringConnectionStateReason.t option ;
      tags: TagList.t ;
      vpc_peering_connection_id: String.t option }
    let make ?accepter_vpc_info  ?expiration_time  ?requester_vpc_info 
      ?status  ?(tags= [])  ?vpc_peering_connection_id  () =
      {
        accepter_vpc_info;
        expiration_time;
        requester_vpc_info;
        status;
        tags;
        vpc_peering_connection_id
      }
    let parse xml =
      Some
        {
          accepter_vpc_info =
            (Util.option_bind (Xml.member "accepterVpcInfo" xml)
               VpcPeeringConnectionVpcInfo.parse);
          expiration_time =
            (Util.option_bind (Xml.member "expirationTime" xml)
               DateTime.parse);
          requester_vpc_info =
            (Util.option_bind (Xml.member "requesterVpcInfo" xml)
               VpcPeeringConnectionVpcInfo.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               VpcPeeringConnectionStateReason.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status
             (fun f ->
                Query.Pair
                  ("Status", (VpcPeeringConnectionStateReason.to_query f)));
           Util.option_map v.requester_vpc_info
             (fun f ->
                Query.Pair
                  ("RequesterVpcInfo",
                    (VpcPeeringConnectionVpcInfo.to_query f)));
           Util.option_map v.expiration_time
             (fun f -> Query.Pair ("ExpirationTime", (DateTime.to_query f)));
           Util.option_map v.accepter_vpc_info
             (fun f ->
                Query.Pair
                  ("AccepterVpcInfo",
                    (VpcPeeringConnectionVpcInfo.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.accepter_vpc_info
                   (fun f ->
                      Ezxmlm.make_tag "accepterVpcInfo"
                        ([], (VpcPeeringConnectionVpcInfo.to_xml f)))])
               @
               [Util.option_map v.expiration_time
                  (fun f ->
                     Ezxmlm.make_tag "expirationTime"
                       ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.requester_vpc_info
                 (fun f ->
                    Ezxmlm.make_tag "requesterVpcInfo"
                      ([], (VpcPeeringConnectionVpcInfo.to_xml f)))])
             @
             [Util.option_map v.status
                (fun f ->
                   Ezxmlm.make_tag "status"
                     ([], (VpcPeeringConnectionStateReason.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Ezxmlm.make_tag "vpcPeeringConnectionId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status
             (fun f ->
                ("status", (VpcPeeringConnectionStateReason.to_json f)));
           Util.option_map v.requester_vpc_info
             (fun f ->
                ("requester_vpc_info",
                  (VpcPeeringConnectionVpcInfo.to_json f)));
           Util.option_map v.expiration_time
             (fun f -> ("expiration_time", (DateTime.to_json f)));
           Util.option_map v.accepter_vpc_info
             (fun f ->
                ("accepter_vpc_info",
                  (VpcPeeringConnectionVpcInfo.to_json f)))])
    let of_json j =
      {
        accepter_vpc_info =
          (Util.option_map (Json.lookup j "accepter_vpc_info")
             VpcPeeringConnectionVpcInfo.of_json);
        expiration_time =
          (Util.option_map (Json.lookup j "expiration_time") DateTime.of_json);
        requester_vpc_info =
          (Util.option_map (Json.lookup j "requester_vpc_info")
             VpcPeeringConnectionVpcInfo.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             VpcPeeringConnectionStateReason.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module NetworkAcl =
  struct
    type t =
      {
      associations: NetworkAclAssociationList.t ;
      entries: NetworkAclEntryList.t ;
      is_default: Boolean.t option ;
      network_acl_id: String.t option ;
      tags: TagList.t ;
      vpc_id: String.t option ;
      owner_id: String.t option }
    let make ?(associations= [])  ?(entries= [])  ?is_default 
      ?network_acl_id  ?(tags= [])  ?vpc_id  ?owner_id  () =
      {
        associations;
        entries;
        is_default;
        network_acl_id;
        tags;
        vpc_id;
        owner_id
      }
    let parse xml =
      Some
        {
          associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "associationSet" xml)
                  NetworkAclAssociationList.parse));
          entries =
            (Util.of_option []
               (Util.option_bind (Xml.member "entrySet" xml)
                  NetworkAclEntryList.parse));
          is_default =
            (Util.option_bind (Xml.member "default" xml) Boolean.parse);
          network_acl_id =
            (Util.option_bind (Xml.member "networkAclId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.network_acl_id
             (fun f -> Query.Pair ("NetworkAclId", (String.to_query f)));
           Util.option_map v.is_default
             (fun f -> Query.Pair ("Default", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("EntrySet", (NetworkAclEntryList.to_query v.entries)));
           Some
             (Query.Pair
                ("AssociationSet",
                  (NetworkAclAssociationList.to_query v.associations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "associationSet"
                            ([], (NetworkAclAssociationList.to_xml [x]))))
                    v.associations))
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "entrySet"
                           ([], (NetworkAclEntryList.to_xml [x])))) v.entries))
               @
               [Util.option_map v.is_default
                  (fun f ->
                     Ezxmlm.make_tag "default" ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.network_acl_id
                 (fun f ->
                    Ezxmlm.make_tag "networkAclId" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
                v.tags))
            @
            [Util.option_map v.vpc_id
               (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.owner_id
              (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.network_acl_id
             (fun f -> ("network_acl_id", (String.to_json f)));
           Util.option_map v.is_default
             (fun f -> ("is_default", (Boolean.to_json f)));
           Some ("entries", (NetworkAclEntryList.to_json v.entries));
           Some
             ("associations",
               (NetworkAclAssociationList.to_json v.associations))])
    let of_json j =
      {
        associations =
          (NetworkAclAssociationList.of_json
             (Util.of_option_exn (Json.lookup j "associations")));
        entries =
          (NetworkAclEntryList.of_json
             (Util.of_option_exn (Json.lookup j "entries")));
        is_default =
          (Util.option_map (Json.lookup j "is_default") Boolean.of_json);
        network_acl_id =
          (Util.option_map (Json.lookup j "network_acl_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json)
      }
  end
module LocalGatewayRouteTableVirtualInterfaceGroupAssociation =
  struct
    type t =
      {
      local_gateway_route_table_virtual_interface_group_association_id:
        String.t option ;
      local_gateway_virtual_interface_group_id: String.t option ;
      local_gateway_id: String.t option ;
      local_gateway_route_table_id: String.t option ;
      state: String.t option }
    let make
      ?local_gateway_route_table_virtual_interface_group_association_id 
      ?local_gateway_virtual_interface_group_id  ?local_gateway_id 
      ?local_gateway_route_table_id  ?state  () =
      {
        local_gateway_route_table_virtual_interface_group_association_id;
        local_gateway_virtual_interface_group_id;
        local_gateway_id;
        local_gateway_route_table_id;
        state
      }
    let parse xml =
      Some
        {
          local_gateway_route_table_virtual_interface_group_association_id =
            (Util.option_bind
               (Xml.member
                  "localGatewayRouteTableVirtualInterfaceGroupAssociationId"
                  xml) String.parse);
          local_gateway_virtual_interface_group_id =
            (Util.option_bind
               (Xml.member "localGatewayVirtualInterfaceGroupId" xml)
               String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse);
          state = (Util.option_bind (Xml.member "state" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayVirtualInterfaceGroupId",
                    (String.to_query f)));
           Util.option_map
             v.local_gateway_route_table_virtual_interface_group_association_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayRouteTableVirtualInterfaceGroupAssociationId",
                    (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map
                  v.local_gateway_route_table_virtual_interface_group_association_id
                  (fun f ->
                     Ezxmlm.make_tag
                       "localGatewayRouteTableVirtualInterfaceGroupAssociationId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.local_gateway_virtual_interface_group_id
                 (fun f ->
                    Ezxmlm.make_tag "localGatewayVirtualInterfaceGroupId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.local_gateway_id
                (fun f ->
                   Ezxmlm.make_tag "localGatewayId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.local_gateway_route_table_id
               (fun f ->
                  Ezxmlm.make_tag "localGatewayRouteTableId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f -> Ezxmlm.make_tag "state" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f -> ("local_gateway_route_table_id", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                ("local_gateway_virtual_interface_group_id",
                  (String.to_json f)));
           Util.option_map
             v.local_gateway_route_table_virtual_interface_group_association_id
             (fun f ->
                ("local_gateway_route_table_virtual_interface_group_association_id",
                  (String.to_json f)))])
    let of_json j =
      {
        local_gateway_route_table_virtual_interface_group_association_id =
          (Util.option_map
             (Json.lookup j
                "local_gateway_route_table_virtual_interface_group_association_id")
             String.of_json);
        local_gateway_virtual_interface_group_id =
          (Util.option_map
             (Json.lookup j "local_gateway_virtual_interface_group_id")
             String.of_json);
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        local_gateway_route_table_id =
          (Util.option_map (Json.lookup j "local_gateway_route_table_id")
             String.of_json);
        state = (Util.option_map (Json.lookup j "state") String.of_json)
      }
  end
module CancelSpotFleetRequestsErrorItem =
  struct
    type t =
      {
      error: CancelSpotFleetRequestsError.t option ;
      spot_fleet_request_id: String.t option }
    let make ?error  ?spot_fleet_request_id  () =
      { error; spot_fleet_request_id }
    let parse xml =
      Some
        {
          error =
            (Util.option_bind (Xml.member "error" xml)
               CancelSpotFleetRequestsError.parse);
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Query.Pair ("SpotFleetRequestId", (String.to_query f)));
           Util.option_map v.error
             (fun f ->
                Query.Pair
                  ("Error", (CancelSpotFleetRequestsError.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.error
               (fun f ->
                  Ezxmlm.make_tag "error"
                    ([], (CancelSpotFleetRequestsError.to_xml f)))])
           @
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Ezxmlm.make_tag "spotFleetRequestId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f -> ("spot_fleet_request_id", (String.to_json f)));
           Util.option_map v.error
             (fun f -> ("error", (CancelSpotFleetRequestsError.to_json f)))])
    let of_json j =
      {
        error =
          (Util.option_map (Json.lookup j "error")
             CancelSpotFleetRequestsError.of_json);
        spot_fleet_request_id =
          (Util.option_map (Json.lookup j "spot_fleet_request_id")
             String.of_json)
      }
  end
module CancelSpotFleetRequestsSuccessItem =
  struct
    type t =
      {
      current_spot_fleet_request_state: BatchState.t option ;
      previous_spot_fleet_request_state: BatchState.t option ;
      spot_fleet_request_id: String.t option }
    let make ?current_spot_fleet_request_state 
      ?previous_spot_fleet_request_state  ?spot_fleet_request_id  () =
      {
        current_spot_fleet_request_state;
        previous_spot_fleet_request_state;
        spot_fleet_request_id
      }
    let parse xml =
      Some
        {
          current_spot_fleet_request_state =
            (Util.option_bind (Xml.member "currentSpotFleetRequestState" xml)
               BatchState.parse);
          previous_spot_fleet_request_state =
            (Util.option_bind
               (Xml.member "previousSpotFleetRequestState" xml)
               BatchState.parse);
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Query.Pair ("SpotFleetRequestId", (String.to_query f)));
           Util.option_map v.previous_spot_fleet_request_state
             (fun f ->
                Query.Pair
                  ("PreviousSpotFleetRequestState", (BatchState.to_query f)));
           Util.option_map v.current_spot_fleet_request_state
             (fun f ->
                Query.Pair
                  ("CurrentSpotFleetRequestState", (BatchState.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.current_spot_fleet_request_state
                (fun f ->
                   Ezxmlm.make_tag "currentSpotFleetRequestState"
                     ([], (BatchState.to_xml f)))])
            @
            [Util.option_map v.previous_spot_fleet_request_state
               (fun f ->
                  Ezxmlm.make_tag "previousSpotFleetRequestState"
                    ([], (BatchState.to_xml f)))])
           @
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Ezxmlm.make_tag "spotFleetRequestId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f -> ("spot_fleet_request_id", (String.to_json f)));
           Util.option_map v.previous_spot_fleet_request_state
             (fun f ->
                ("previous_spot_fleet_request_state", (BatchState.to_json f)));
           Util.option_map v.current_spot_fleet_request_state
             (fun f ->
                ("current_spot_fleet_request_state", (BatchState.to_json f)))])
    let of_json j =
      {
        current_spot_fleet_request_state =
          (Util.option_map (Json.lookup j "current_spot_fleet_request_state")
             BatchState.of_json);
        previous_spot_fleet_request_state =
          (Util.option_map
             (Json.lookup j "previous_spot_fleet_request_state")
             BatchState.of_json);
        spot_fleet_request_id =
          (Util.option_map (Json.lookup j "spot_fleet_request_id")
             String.of_json)
      }
  end
module AccountAttribute =
  struct
    type t =
      {
      attribute_name: String.t option ;
      attribute_values: AccountAttributeValueList.t }
    let make ?attribute_name  ?(attribute_values= [])  () =
      { attribute_name; attribute_values }
    let parse xml =
      Some
        {
          attribute_name =
            (Util.option_bind (Xml.member "attributeName" xml) String.parse);
          attribute_values =
            (Util.of_option []
               (Util.option_bind (Xml.member "attributeValueSet" xml)
                  AccountAttributeValueList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AttributeValueSet",
                   (AccountAttributeValueList.to_query v.attribute_values)));
           Util.option_map v.attribute_name
             (fun f -> Query.Pair ("AttributeName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.attribute_name
               (fun f ->
                  Ezxmlm.make_tag "attributeName" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "attributeValueSet"
                      ([], (AccountAttributeValueList.to_xml [x]))))
              v.attribute_values))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("attribute_values",
                (AccountAttributeValueList.to_json v.attribute_values));
           Util.option_map v.attribute_name
             (fun f -> ("attribute_name", (String.to_json f)))])
    let of_json j =
      {
        attribute_name =
          (Util.option_map (Json.lookup j "attribute_name") String.of_json);
        attribute_values =
          (AccountAttributeValueList.of_json
             (Util.of_option_exn (Json.lookup j "attribute_values")))
      }
  end
module DiskImage =
  struct
    type t =
      {
      description: String.t option ;
      image: DiskImageDetail.t option ;
      volume: VolumeDetail.t option }
    let make ?description  ?image  ?volume  () =
      { description; image; volume }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          image =
            (Util.option_bind (Xml.member "Image" xml) DiskImageDetail.parse);
          volume =
            (Util.option_bind (Xml.member "Volume" xml) VolumeDetail.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f -> Query.Pair ("Volume", (VolumeDetail.to_query f)));
           Util.option_map v.image
             (fun f -> Query.Pair ("Image", (DiskImageDetail.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
            @
            [Util.option_map v.image
               (fun f ->
                  Ezxmlm.make_tag "Image" ([], (DiskImageDetail.to_xml f)))])
           @
           [Util.option_map v.volume
              (fun f ->
                 Ezxmlm.make_tag "Volume" ([], (VolumeDetail.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f -> ("volume", (VolumeDetail.to_json f)));
           Util.option_map v.image
             (fun f -> ("image", (DiskImageDetail.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        image =
          (Util.option_map (Json.lookup j "image") DiskImageDetail.of_json);
        volume =
          (Util.option_map (Json.lookup j "volume") VolumeDetail.of_json)
      }
  end
module SecurityGroupStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "SecurityGroup" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module UserData =
  struct
    type t = {
      data: String.t option }
    let make ?data  () = { data }
    let parse xml =
      Some { data = (Util.option_bind (Xml.member "data" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.data
              (fun f -> Query.Pair ("Data", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.data
              (fun f -> Ezxmlm.make_tag "data" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.data (fun f -> ("data", (String.to_json f)))])
    let of_json j =
      { data = (Util.option_map (Json.lookup j "data") String.of_json) }
  end
module VpcEndpoint =
  struct
    type t =
      {
      vpc_endpoint_id: String.t option ;
      vpc_endpoint_type: VpcEndpointType.t option ;
      vpc_id: String.t option ;
      service_name: String.t option ;
      state: State.t option ;
      policy_document: String.t option ;
      route_table_ids: ValueStringList.t ;
      subnet_ids: ValueStringList.t ;
      groups: GroupIdentifierSet.t ;
      private_dns_enabled: Boolean.t option ;
      requester_managed: Boolean.t option ;
      network_interface_ids: ValueStringList.t ;
      dns_entries: DnsEntrySet.t ;
      creation_timestamp: DateTime.t option ;
      tags: TagList.t ;
      owner_id: String.t option }
    let make ?vpc_endpoint_id  ?vpc_endpoint_type  ?vpc_id  ?service_name 
      ?state  ?policy_document  ?(route_table_ids= [])  ?(subnet_ids= []) 
      ?(groups= [])  ?private_dns_enabled  ?requester_managed 
      ?(network_interface_ids= [])  ?(dns_entries= [])  ?creation_timestamp 
      ?(tags= [])  ?owner_id  () =
      {
        vpc_endpoint_id;
        vpc_endpoint_type;
        vpc_id;
        service_name;
        state;
        policy_document;
        route_table_ids;
        subnet_ids;
        groups;
        private_dns_enabled;
        requester_managed;
        network_interface_ids;
        dns_entries;
        creation_timestamp;
        tags;
        owner_id
      }
    let parse xml =
      Some
        {
          vpc_endpoint_id =
            (Util.option_bind (Xml.member "vpcEndpointId" xml) String.parse);
          vpc_endpoint_type =
            (Util.option_bind (Xml.member "vpcEndpointType" xml)
               VpcEndpointType.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          service_name =
            (Util.option_bind (Xml.member "serviceName" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) State.parse);
          policy_document =
            (Util.option_bind (Xml.member "policyDocument" xml) String.parse);
          route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeTableIdSet" xml)
                  ValueStringList.parse));
          subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "subnetIdSet" xml)
                  ValueStringList.parse));
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierSet.parse));
          private_dns_enabled =
            (Util.option_bind (Xml.member "privateDnsEnabled" xml)
               Boolean.parse);
          requester_managed =
            (Util.option_bind (Xml.member "requesterManaged" xml)
               Boolean.parse);
          network_interface_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceIdSet" xml)
                  ValueStringList.parse));
          dns_entries =
            (Util.of_option []
               (Util.option_bind (Xml.member "dnsEntrySet" xml)
                  DnsEntrySet.parse));
          creation_timestamp =
            (Util.option_bind (Xml.member "creationTimestamp" xml)
               DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.creation_timestamp
             (fun f ->
                Query.Pair ("CreationTimestamp", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("DnsEntrySet", (DnsEntrySet.to_query v.dns_entries)));
           Some
             (Query.Pair
                ("NetworkInterfaceIdSet",
                  (ValueStringList.to_query v.network_interface_ids)));
           Util.option_map v.requester_managed
             (fun f -> Query.Pair ("RequesterManaged", (Boolean.to_query f)));
           Util.option_map v.private_dns_enabled
             (fun f -> Query.Pair ("PrivateDnsEnabled", (Boolean.to_query f)));
           Some
             (Query.Pair ("GroupSet", (GroupIdentifierSet.to_query v.groups)));
           Some
             (Query.Pair
                ("SubnetIdSet", (ValueStringList.to_query v.subnet_ids)));
           Some
             (Query.Pair
                ("RouteTableIdSet",
                  (ValueStringList.to_query v.route_table_ids)));
           Util.option_map v.policy_document
             (fun f -> Query.Pair ("PolicyDocument", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (State.to_query f)));
           Util.option_map v.service_name
             (fun f -> Query.Pair ("ServiceName", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.vpc_endpoint_type
             (fun f ->
                Query.Pair ("VpcEndpointType", (VpcEndpointType.to_query f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> Query.Pair ("VpcEndpointId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((([] @
                          [Util.option_map v.vpc_endpoint_id
                             (fun f ->
                                Ezxmlm.make_tag "vpcEndpointId"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.vpc_endpoint_type
                            (fun f ->
                               Ezxmlm.make_tag "vpcEndpointType"
                                 ([], (VpcEndpointType.to_xml f)))])
                        @
                        [Util.option_map v.vpc_id
                           (fun f ->
                              Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.service_name
                          (fun f ->
                             Ezxmlm.make_tag "serviceName"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.state
                         (fun f ->
                            Ezxmlm.make_tag "state" ([], (State.to_xml f)))])
                     @
                     [Util.option_map v.policy_document
                        (fun f ->
                           Ezxmlm.make_tag "policyDocument"
                             ([], (String.to_xml f)))])
                    @
                    (List.map
                       (fun x ->
                          Some
                            (Ezxmlm.make_tag "routeTableIdSet"
                               ([], (ValueStringList.to_xml [x]))))
                       v.route_table_ids))
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "subnetIdSet"
                              ([], (ValueStringList.to_xml [x]))))
                      v.subnet_ids))
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "groupSet"
                             ([], (GroupIdentifierSet.to_xml [x])))) v.groups))
                 @
                 [Util.option_map v.private_dns_enabled
                    (fun f ->
                       Ezxmlm.make_tag "privateDnsEnabled"
                         ([], (Boolean.to_xml f)))])
                @
                [Util.option_map v.requester_managed
                   (fun f ->
                      Ezxmlm.make_tag "requesterManaged"
                        ([], (Boolean.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "networkInterfaceIdSet"
                          ([], (ValueStringList.to_xml [x]))))
                  v.network_interface_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "dnsEntrySet"
                         ([], (DnsEntrySet.to_xml [x])))) v.dns_entries))
             @
             [Util.option_map v.creation_timestamp
                (fun f ->
                   Ezxmlm.make_tag "creationTimestamp"
                     ([], (DateTime.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           [Util.option_map v.owner_id
              (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> ("owner_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.creation_timestamp
             (fun f -> ("creation_timestamp", (DateTime.to_json f)));
           Some ("dns_entries", (DnsEntrySet.to_json v.dns_entries));
           Some
             ("network_interface_ids",
               (ValueStringList.to_json v.network_interface_ids));
           Util.option_map v.requester_managed
             (fun f -> ("requester_managed", (Boolean.to_json f)));
           Util.option_map v.private_dns_enabled
             (fun f -> ("private_dns_enabled", (Boolean.to_json f)));
           Some ("groups", (GroupIdentifierSet.to_json v.groups));
           Some ("subnet_ids", (ValueStringList.to_json v.subnet_ids));
           Some
             ("route_table_ids", (ValueStringList.to_json v.route_table_ids));
           Util.option_map v.policy_document
             (fun f -> ("policy_document", (String.to_json f)));
           Util.option_map v.state (fun f -> ("state", (State.to_json f)));
           Util.option_map v.service_name
             (fun f -> ("service_name", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.vpc_endpoint_type
             (fun f -> ("vpc_endpoint_type", (VpcEndpointType.to_json f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> ("vpc_endpoint_id", (String.to_json f)))])
    let of_json j =
      {
        vpc_endpoint_id =
          (Util.option_map (Json.lookup j "vpc_endpoint_id") String.of_json);
        vpc_endpoint_type =
          (Util.option_map (Json.lookup j "vpc_endpoint_type")
             VpcEndpointType.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        service_name =
          (Util.option_map (Json.lookup j "service_name") String.of_json);
        state = (Util.option_map (Json.lookup j "state") State.of_json);
        policy_document =
          (Util.option_map (Json.lookup j "policy_document") String.of_json);
        route_table_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "route_table_ids")));
        subnet_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "subnet_ids")));
        groups =
          (GroupIdentifierSet.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        private_dns_enabled =
          (Util.option_map (Json.lookup j "private_dns_enabled")
             Boolean.of_json);
        requester_managed =
          (Util.option_map (Json.lookup j "requester_managed")
             Boolean.of_json);
        network_interface_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_ids")));
        dns_entries =
          (DnsEntrySet.of_json
             (Util.of_option_exn (Json.lookup j "dns_entries")));
        creation_timestamp =
          (Util.option_map (Json.lookup j "creation_timestamp")
             DateTime.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json)
      }
  end
module ClassicLinkInstance =
  struct
    type t =
      {
      groups: GroupIdentifierList.t ;
      instance_id: String.t option ;
      tags: TagList.t ;
      vpc_id: String.t option }
    let make ?(groups= [])  ?instance_id  ?(tags= [])  ?vpc_id  () =
      { groups; instance_id; tags; vpc_id }
    let parse xml =
      Some
        {
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "groupSet"
                         ([], (GroupIdentifierList.to_xml [x])))) v.groups))
             @
             [Util.option_map v.instance_id
                (fun f ->
                   Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Some ("groups", (GroupIdentifierList.to_json v.groups))])
    let of_json j =
      {
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module Purchase =
  struct
    type t =
      {
      currency_code: CurrencyCodeValues.t option ;
      duration: Integer.t option ;
      host_id_set: ResponseHostIdSet.t ;
      host_reservation_id: String.t option ;
      hourly_price: String.t option ;
      instance_family: String.t option ;
      payment_option: PaymentOption.t option ;
      upfront_price: String.t option }
    let make ?currency_code  ?duration  ?(host_id_set= []) 
      ?host_reservation_id  ?hourly_price  ?instance_family  ?payment_option 
      ?upfront_price  () =
      {
        currency_code;
        duration;
        host_id_set;
        host_reservation_id;
        hourly_price;
        instance_family;
        payment_option;
        upfront_price
      }
    let parse xml =
      Some
        {
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Integer.parse);
          host_id_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostIdSet" xml)
                  ResponseHostIdSet.parse));
          host_reservation_id =
            (Util.option_bind (Xml.member "hostReservationId" xml)
               String.parse);
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          instance_family =
            (Util.option_bind (Xml.member "instanceFamily" xml) String.parse);
          payment_option =
            (Util.option_bind (Xml.member "paymentOption" xml)
               PaymentOption.parse);
          upfront_price =
            (Util.option_bind (Xml.member "upfrontPrice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.upfront_price
              (fun f -> Query.Pair ("UpfrontPrice", (String.to_query f)));
           Util.option_map v.payment_option
             (fun f ->
                Query.Pair ("PaymentOption", (PaymentOption.to_query f)));
           Util.option_map v.instance_family
             (fun f -> Query.Pair ("InstanceFamily", (String.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)));
           Util.option_map v.host_reservation_id
             (fun f -> Query.Pair ("HostReservationId", (String.to_query f)));
           Some
             (Query.Pair
                ("HostIdSet", (ResponseHostIdSet.to_query v.host_id_set)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Integer.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.currency_code
                     (fun f ->
                        Ezxmlm.make_tag "currencyCode"
                          ([], (CurrencyCodeValues.to_xml f)))])
                 @
                 [Util.option_map v.duration
                    (fun f ->
                       Ezxmlm.make_tag "duration" ([], (Integer.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "hostIdSet"
                           ([], (ResponseHostIdSet.to_xml [x]))))
                   v.host_id_set))
               @
               [Util.option_map v.host_reservation_id
                  (fun f ->
                     Ezxmlm.make_tag "hostReservationId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.hourly_price
                 (fun f ->
                    Ezxmlm.make_tag "hourlyPrice" ([], (String.to_xml f)))])
             @
             [Util.option_map v.instance_family
                (fun f ->
                   Ezxmlm.make_tag "instanceFamily" ([], (String.to_xml f)))])
            @
            [Util.option_map v.payment_option
               (fun f ->
                  Ezxmlm.make_tag "paymentOption"
                    ([], (PaymentOption.to_xml f)))])
           @
           [Util.option_map v.upfront_price
              (fun f ->
                 Ezxmlm.make_tag "upfrontPrice" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.upfront_price
              (fun f -> ("upfront_price", (String.to_json f)));
           Util.option_map v.payment_option
             (fun f -> ("payment_option", (PaymentOption.to_json f)));
           Util.option_map v.instance_family
             (fun f -> ("instance_family", (String.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)));
           Util.option_map v.host_reservation_id
             (fun f -> ("host_reservation_id", (String.to_json f)));
           Some ("host_id_set", (ResponseHostIdSet.to_json v.host_id_set));
           Util.option_map v.duration
             (fun f -> ("duration", (Integer.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)))])
    let of_json j =
      {
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        duration =
          (Util.option_map (Json.lookup j "duration") Integer.of_json);
        host_id_set =
          (ResponseHostIdSet.of_json
             (Util.of_option_exn (Json.lookup j "host_id_set")));
        host_reservation_id =
          (Util.option_map (Json.lookup j "host_reservation_id")
             String.of_json);
        hourly_price =
          (Util.option_map (Json.lookup j "hourly_price") String.of_json);
        instance_family =
          (Util.option_map (Json.lookup j "instance_family") String.of_json);
        payment_option =
          (Util.option_map (Json.lookup j "payment_option")
             PaymentOption.of_json);
        upfront_price =
          (Util.option_map (Json.lookup j "upfront_price") String.of_json)
      }
  end
module TransitGatewayAttachment =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option ;
      transit_gateway_id: String.t option ;
      transit_gateway_owner_id: String.t option ;
      resource_owner_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      resource_id: String.t option ;
      state: TransitGatewayAttachmentState.t option ;
      association: TransitGatewayAttachmentAssociation.t option ;
      creation_time: DateTime.t option ;
      tags: TagList.t }
    let make ?transit_gateway_attachment_id  ?transit_gateway_id 
      ?transit_gateway_owner_id  ?resource_owner_id  ?resource_type 
      ?resource_id  ?state  ?association  ?creation_time  ?(tags= [])  () =
      {
        transit_gateway_attachment_id;
        transit_gateway_id;
        transit_gateway_owner_id;
        resource_owner_id;
        resource_type;
        resource_id;
        state;
        association;
        creation_time;
        tags
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          transit_gateway_owner_id =
            (Util.option_bind (Xml.member "transitGatewayOwnerId" xml)
               String.parse);
          resource_owner_id =
            (Util.option_bind (Xml.member "resourceOwnerId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAttachmentState.parse);
          association =
            (Util.option_bind (Xml.member "association" xml)
               TransitGatewayAttachmentAssociation.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association",
                    (TransitGatewayAttachmentAssociation.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (TransitGatewayAttachmentState.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_owner_id
             (fun f -> Query.Pair ("ResourceOwnerId", (String.to_query f)));
           Util.option_map v.transit_gateway_owner_id
             (fun f ->
                Query.Pair ("TransitGatewayOwnerId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.transit_gateway_attachment_id
                       (fun f ->
                          Ezxmlm.make_tag "transitGatewayAttachmentId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.transit_gateway_id
                      (fun f ->
                         Ezxmlm.make_tag "transitGatewayId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.transit_gateway_owner_id
                     (fun f ->
                        Ezxmlm.make_tag "transitGatewayOwnerId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.resource_owner_id
                    (fun f ->
                       Ezxmlm.make_tag "resourceOwnerId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.resource_type
                   (fun f ->
                      Ezxmlm.make_tag "resourceType"
                        ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
               @
               [Util.option_map v.resource_id
                  (fun f ->
                     Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.state
                 (fun f ->
                    Ezxmlm.make_tag "state"
                      ([], (TransitGatewayAttachmentState.to_xml f)))])
             @
             [Util.option_map v.association
                (fun f ->
                   Ezxmlm.make_tag "association"
                     ([], (TransitGatewayAttachmentAssociation.to_xml f)))])
            @
            [Util.option_map v.creation_time
               (fun f ->
                  Ezxmlm.make_tag "creationTime" ([], (DateTime.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Util.option_map v.association
             (fun f ->
                ("association",
                  (TransitGatewayAttachmentAssociation.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (TransitGatewayAttachmentState.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_owner_id
             (fun f -> ("resource_owner_id", (String.to_json f)));
           Util.option_map v.transit_gateway_owner_id
             (fun f -> ("transit_gateway_owner_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        transit_gateway_owner_id =
          (Util.option_map (Json.lookup j "transit_gateway_owner_id")
             String.of_json);
        resource_owner_id =
          (Util.option_map (Json.lookup j "resource_owner_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayAttachmentState.of_json);
        association =
          (Util.option_map (Json.lookup j "association")
             TransitGatewayAttachmentAssociation.of_json);
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") DateTime.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module Snapshot =
  struct
    type t =
      {
      data_encryption_key_id: String.t option ;
      description: String.t ;
      encrypted: Boolean.t ;
      kms_key_id: String.t option ;
      owner_id: String.t ;
      progress: String.t ;
      snapshot_id: String.t ;
      start_time: DateTime.t ;
      state: SnapshotState.t ;
      state_message: String.t option ;
      volume_id: String.t ;
      volume_size: Integer.t ;
      owner_alias: String.t option ;
      tags: TagList.t }
    let make ?data_encryption_key_id  ~description  ~encrypted  ?kms_key_id 
      ~owner_id  ~progress  ~snapshot_id  ~start_time  ~state  ?state_message
       ~volume_id  ~volume_size  ?owner_alias  ?(tags= [])  () =
      {
        data_encryption_key_id;
        description;
        encrypted;
        kms_key_id;
        owner_id;
        progress;
        snapshot_id;
        start_time;
        state;
        state_message;
        volume_id;
        volume_size;
        owner_alias;
        tags
      }
    let parse xml =
      Some
        {
          data_encryption_key_id =
            (Util.option_bind (Xml.member "dataEncryptionKeyId" xml)
               String.parse);
          description =
            (Xml.required "description"
               (Util.option_bind (Xml.member "description" xml) String.parse));
          encrypted =
            (Xml.required "encrypted"
               (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse));
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          owner_id =
            (Xml.required "ownerId"
               (Util.option_bind (Xml.member "ownerId" xml) String.parse));
          progress =
            (Xml.required "progress"
               (Util.option_bind (Xml.member "progress" xml) String.parse));
          snapshot_id =
            (Xml.required "snapshotId"
               (Util.option_bind (Xml.member "snapshotId" xml) String.parse));
          start_time =
            (Xml.required "startTime"
               (Util.option_bind (Xml.member "startTime" xml) DateTime.parse));
          state =
            (Xml.required "status"
               (Util.option_bind (Xml.member "status" xml)
                  SnapshotState.parse));
          state_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          volume_id =
            (Xml.required "volumeId"
               (Util.option_bind (Xml.member "volumeId" xml) String.parse));
          volume_size =
            (Xml.required "volumeSize"
               (Util.option_bind (Xml.member "volumeSize" xml) Integer.parse));
          owner_alias =
            (Util.option_bind (Xml.member "ownerAlias" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.owner_alias
             (fun f -> Query.Pair ("OwnerAlias", (String.to_query f)));
           Some (Query.Pair ("VolumeSize", (Integer.to_query v.volume_size)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.state_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Some (Query.Pair ("Status", (SnapshotState.to_query v.state)));
           Some (Query.Pair ("StartTime", (DateTime.to_query v.start_time)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Some (Query.Pair ("Progress", (String.to_query v.progress)));
           Some (Query.Pair ("OwnerId", (String.to_query v.owner_id)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Some (Query.Pair ("Encrypted", (Boolean.to_query v.encrypted)));
           Some (Query.Pair ("Description", (String.to_query v.description)));
           Util.option_map v.data_encryption_key_id
             (fun f ->
                Query.Pair ("DataEncryptionKeyId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        [Util.option_map v.data_encryption_key_id
                           (fun f ->
                              Ezxmlm.make_tag "dataEncryptionKeyId"
                                ([], (String.to_xml f)))])
                       @
                       [Some
                          (Ezxmlm.make_tag "description"
                             ([], (String.to_xml v.description)))])
                      @
                      [Some
                         (Ezxmlm.make_tag "encrypted"
                            ([], (Boolean.to_xml v.encrypted)))])
                     @
                     [Util.option_map v.kms_key_id
                        (fun f ->
                           Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
                    @
                    [Some
                       (Ezxmlm.make_tag "ownerId"
                          ([], (String.to_xml v.owner_id)))])
                   @
                   [Some
                      (Ezxmlm.make_tag "progress"
                         ([], (String.to_xml v.progress)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "snapshotId"
                        ([], (String.to_xml v.snapshot_id)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "startTime"
                       ([], (DateTime.to_xml v.start_time)))])
                @
                [Some
                   (Ezxmlm.make_tag "status"
                      ([], (SnapshotState.to_xml v.state)))])
               @
               [Util.option_map v.state_message
                  (fun f ->
                     Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
              @
              [Some
                 (Ezxmlm.make_tag "volumeId"
                    ([], (String.to_xml v.volume_id)))])
             @
             [Some
                (Ezxmlm.make_tag "volumeSize"
                   ([], (Integer.to_xml v.volume_size)))])
            @
            [Util.option_map v.owner_alias
               (fun f -> Ezxmlm.make_tag "ownerAlias" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.owner_alias
             (fun f -> ("owner_alias", (String.to_json f)));
           Some ("volume_size", (Integer.to_json v.volume_size));
           Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.state_message
             (fun f -> ("state_message", (String.to_json f)));
           Some ("state", (SnapshotState.to_json v.state));
           Some ("start_time", (DateTime.to_json v.start_time));
           Some ("snapshot_id", (String.to_json v.snapshot_id));
           Some ("progress", (String.to_json v.progress));
           Some ("owner_id", (String.to_json v.owner_id));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Some ("encrypted", (Boolean.to_json v.encrypted));
           Some ("description", (String.to_json v.description));
           Util.option_map v.data_encryption_key_id
             (fun f -> ("data_encryption_key_id", (String.to_json f)))])
    let of_json j =
      {
        data_encryption_key_id =
          (Util.option_map (Json.lookup j "data_encryption_key_id")
             String.of_json);
        description =
          (String.of_json (Util.of_option_exn (Json.lookup j "description")));
        encrypted =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "encrypted")));
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        owner_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "owner_id")));
        progress =
          (String.of_json (Util.of_option_exn (Json.lookup j "progress")));
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        start_time =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "start_time")));
        state =
          (SnapshotState.of_json (Util.of_option_exn (Json.lookup j "state")));
        state_message =
          (Util.option_map (Json.lookup j "state_message") String.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        volume_size =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "volume_size")));
        owner_alias =
          (Util.option_map (Json.lookup j "owner_alias") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module CreateFleetError =
  struct
    type t =
      {
      launch_template_and_overrides:
        LaunchTemplateAndOverridesResponse.t option ;
      lifecycle: InstanceLifecycle.t option ;
      error_code: String.t option ;
      error_message: String.t option }
    let make ?launch_template_and_overrides  ?lifecycle  ?error_code 
      ?error_message  () =
      { launch_template_and_overrides; lifecycle; error_code; error_message }
    let parse xml =
      Some
        {
          launch_template_and_overrides =
            (Util.option_bind (Xml.member "launchTemplateAndOverrides" xml)
               LaunchTemplateAndOverridesResponse.parse);
          lifecycle =
            (Util.option_bind (Xml.member "lifecycle" xml)
               InstanceLifecycle.parse);
          error_code =
            (Util.option_bind (Xml.member "errorCode" xml) String.parse);
          error_message =
            (Util.option_bind (Xml.member "errorMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.error_message
              (fun f -> Query.Pair ("ErrorMessage", (String.to_query f)));
           Util.option_map v.error_code
             (fun f -> Query.Pair ("ErrorCode", (String.to_query f)));
           Util.option_map v.lifecycle
             (fun f ->
                Query.Pair ("Lifecycle", (InstanceLifecycle.to_query f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                Query.Pair
                  ("LaunchTemplateAndOverrides",
                    (LaunchTemplateAndOverridesResponse.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.launch_template_and_overrides
                 (fun f ->
                    Ezxmlm.make_tag "launchTemplateAndOverrides"
                      ([], (LaunchTemplateAndOverridesResponse.to_xml f)))])
             @
             [Util.option_map v.lifecycle
                (fun f ->
                   Ezxmlm.make_tag "lifecycle"
                     ([], (InstanceLifecycle.to_xml f)))])
            @
            [Util.option_map v.error_code
               (fun f -> Ezxmlm.make_tag "errorCode" ([], (String.to_xml f)))])
           @
           [Util.option_map v.error_message
              (fun f ->
                 Ezxmlm.make_tag "errorMessage" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.error_message
              (fun f -> ("error_message", (String.to_json f)));
           Util.option_map v.error_code
             (fun f -> ("error_code", (String.to_json f)));
           Util.option_map v.lifecycle
             (fun f -> ("lifecycle", (InstanceLifecycle.to_json f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                ("launch_template_and_overrides",
                  (LaunchTemplateAndOverridesResponse.to_json f)))])
    let of_json j =
      {
        launch_template_and_overrides =
          (Util.option_map (Json.lookup j "launch_template_and_overrides")
             LaunchTemplateAndOverridesResponse.of_json);
        lifecycle =
          (Util.option_map (Json.lookup j "lifecycle")
             InstanceLifecycle.of_json);
        error_code =
          (Util.option_map (Json.lookup j "error_code") String.of_json);
        error_message =
          (Util.option_map (Json.lookup j "error_message") String.of_json)
      }
  end
module CreateFleetInstance =
  struct
    type t =
      {
      launch_template_and_overrides:
        LaunchTemplateAndOverridesResponse.t option ;
      lifecycle: InstanceLifecycle.t option ;
      instance_ids: InstanceIdsSet.t ;
      instance_type: InstanceType.t option ;
      platform: PlatformValues.t option }
    let make ?launch_template_and_overrides  ?lifecycle  ?(instance_ids= []) 
      ?instance_type  ?platform  () =
      {
        launch_template_and_overrides;
        lifecycle;
        instance_ids;
        instance_type;
        platform
      }
    let parse xml =
      Some
        {
          launch_template_and_overrides =
            (Util.option_bind (Xml.member "launchTemplateAndOverrides" xml)
               LaunchTemplateAndOverridesResponse.parse);
          lifecycle =
            (Util.option_bind (Xml.member "lifecycle" xml)
               InstanceLifecycle.parse);
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceIds" xml)
                  InstanceIdsSet.parse));
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.platform
              (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Some
             (Query.Pair
                ("InstanceIds", (InstanceIdsSet.to_query v.instance_ids)));
           Util.option_map v.lifecycle
             (fun f ->
                Query.Pair ("Lifecycle", (InstanceLifecycle.to_query f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                Query.Pair
                  ("LaunchTemplateAndOverrides",
                    (LaunchTemplateAndOverridesResponse.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.launch_template_and_overrides
                  (fun f ->
                     Ezxmlm.make_tag "launchTemplateAndOverrides"
                       ([], (LaunchTemplateAndOverridesResponse.to_xml f)))])
              @
              [Util.option_map v.lifecycle
                 (fun f ->
                    Ezxmlm.make_tag "lifecycle"
                      ([], (InstanceLifecycle.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "instanceIds"
                        ([], (InstanceIdsSet.to_xml [x])))) v.instance_ids))
            @
            [Util.option_map v.instance_type
               (fun f ->
                  Ezxmlm.make_tag "instanceType"
                    ([], (InstanceType.to_xml f)))])
           @
           [Util.option_map v.platform
              (fun f ->
                 Ezxmlm.make_tag "platform" ([], (PlatformValues.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.platform
              (fun f -> ("platform", (PlatformValues.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Some ("instance_ids", (InstanceIdsSet.to_json v.instance_ids));
           Util.option_map v.lifecycle
             (fun f -> ("lifecycle", (InstanceLifecycle.to_json f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                ("launch_template_and_overrides",
                  (LaunchTemplateAndOverridesResponse.to_json f)))])
    let of_json j =
      {
        launch_template_and_overrides =
          (Util.option_map (Json.lookup j "launch_template_and_overrides")
             LaunchTemplateAndOverridesResponse.of_json);
        lifecycle =
          (Util.option_map (Json.lookup j "lifecycle")
             InstanceLifecycle.of_json);
        instance_ids =
          (InstanceIdsSet.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") PlatformValues.of_json)
      }
  end
module SnapshotInfo =
  struct
    type t =
      {
      description: String.t option ;
      tags: TagList.t ;
      encrypted: Boolean.t option ;
      volume_id: String.t option ;
      state: SnapshotState.t option ;
      volume_size: Integer.t option ;
      start_time: DateTime.t option ;
      progress: String.t option ;
      owner_id: String.t option ;
      snapshot_id: String.t option }
    let make ?description  ?(tags= [])  ?encrypted  ?volume_id  ?state 
      ?volume_size  ?start_time  ?progress  ?owner_id  ?snapshot_id  () =
      {
        description;
        tags;
        encrypted;
        volume_id;
        state;
        volume_size;
        start_time;
        progress;
        owner_id;
        snapshot_id
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) SnapshotState.parse);
          volume_size =
            (Util.option_bind (Xml.member "volumeSize" xml) Integer.parse);
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.snapshot_id
              (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.start_time
             (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Util.option_map v.volume_size
             (fun f -> Query.Pair ("VolumeSize", (Integer.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (SnapshotState.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.description
                       (fun f ->
                          Ezxmlm.make_tag "description"
                            ([], (String.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "tagSet"
                              ([], (TagList.to_xml [x])))) v.tags))
                  @
                  [Util.option_map v.encrypted
                     (fun f ->
                        Ezxmlm.make_tag "encrypted" ([], (Boolean.to_xml f)))])
                 @
                 [Util.option_map v.volume_id
                    (fun f ->
                       Ezxmlm.make_tag "volumeId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.state
                   (fun f ->
                      Ezxmlm.make_tag "state" ([], (SnapshotState.to_xml f)))])
               @
               [Util.option_map v.volume_size
                  (fun f ->
                     Ezxmlm.make_tag "volumeSize" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.start_time
                 (fun f ->
                    Ezxmlm.make_tag "startTime" ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.progress
                (fun f -> Ezxmlm.make_tag "progress" ([], (String.to_xml f)))])
            @
            [Util.option_map v.owner_id
               (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.snapshot_id
              (fun f -> Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.snapshot_id
              (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.start_time
             (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.volume_size
             (fun f -> ("volume_size", (Integer.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (SnapshotState.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state") SnapshotState.of_json);
        volume_size =
          (Util.option_map (Json.lookup j "volume_size") Integer.of_json);
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json)
      }
  end
module TrafficMirrorTarget =
  struct
    type t =
      {
      traffic_mirror_target_id: String.t option ;
      network_interface_id: String.t option ;
      network_load_balancer_arn: String.t option ;
      type_: TrafficMirrorTargetType.t option ;
      description: String.t option ;
      owner_id: String.t option ;
      tags: TagList.t }
    let make ?traffic_mirror_target_id  ?network_interface_id 
      ?network_load_balancer_arn  ?type_  ?description  ?owner_id  ?(tags=
      [])  () =
      {
        traffic_mirror_target_id;
        network_interface_id;
        network_load_balancer_arn;
        type_;
        description;
        owner_id;
        tags
      }
    let parse xml =
      Some
        {
          traffic_mirror_target_id =
            (Util.option_bind (Xml.member "trafficMirrorTargetId" xml)
               String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          network_load_balancer_arn =
            (Util.option_bind (Xml.member "networkLoadBalancerArn" xml)
               String.parse);
          type_ =
            (Util.option_bind (Xml.member "type" xml)
               TrafficMirrorTargetType.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.type_
             (fun f ->
                Query.Pair ("Type", (TrafficMirrorTargetType.to_query f)));
           Util.option_map v.network_load_balancer_arn
             (fun f ->
                Query.Pair ("NetworkLoadBalancerArn", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.traffic_mirror_target_id
             (fun f ->
                Query.Pair ("TrafficMirrorTargetId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.traffic_mirror_target_id
                    (fun f ->
                       Ezxmlm.make_tag "trafficMirrorTargetId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.network_interface_id
                   (fun f ->
                      Ezxmlm.make_tag "networkInterfaceId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.network_load_balancer_arn
                  (fun f ->
                     Ezxmlm.make_tag "networkLoadBalancerArn"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.type_
                 (fun f ->
                    Ezxmlm.make_tag "type"
                      ([], (TrafficMirrorTargetType.to_xml f)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
            @
            [Util.option_map v.owner_id
               (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (TrafficMirrorTargetType.to_json f)));
           Util.option_map v.network_load_balancer_arn
             (fun f -> ("network_load_balancer_arn", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_target_id
             (fun f -> ("traffic_mirror_target_id", (String.to_json f)))])
    let of_json j =
      {
        traffic_mirror_target_id =
          (Util.option_map (Json.lookup j "traffic_mirror_target_id")
             String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        network_load_balancer_arn =
          (Util.option_map (Json.lookup j "network_load_balancer_arn")
             String.of_json);
        type_ =
          (Util.option_map (Json.lookup j "type_")
             TrafficMirrorTargetType.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module TrafficMirrorFilterRuleField =
  struct
    type t =
      | Destination_port_range 
      | Source_port_range 
      | Protocol 
      | Description 
    let str_to_t =
      [("description", Description);
      ("protocol", Protocol);
      ("source-port-range", Source_port_range);
      ("destination-port-range", Destination_port_range)]
    let t_to_str =
      [(Description, "description");
      (Protocol, "protocol");
      (Source_port_range, "source-port-range");
      (Destination_port_range, "destination-port-range")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VolumeModification =
  struct
    type t =
      {
      volume_id: String.t option ;
      modification_state: VolumeModificationState.t option ;
      status_message: String.t option ;
      target_size: Integer.t option ;
      target_iops: Integer.t option ;
      target_volume_type: VolumeType.t option ;
      original_size: Integer.t option ;
      original_iops: Integer.t option ;
      original_volume_type: VolumeType.t option ;
      progress: Long.t option ;
      start_time: DateTime.t option ;
      end_time: DateTime.t option }
    let make ?volume_id  ?modification_state  ?status_message  ?target_size 
      ?target_iops  ?target_volume_type  ?original_size  ?original_iops 
      ?original_volume_type  ?progress  ?start_time  ?end_time  () =
      {
        volume_id;
        modification_state;
        status_message;
        target_size;
        target_iops;
        target_volume_type;
        original_size;
        original_iops;
        original_volume_type;
        progress;
        start_time;
        end_time
      }
    let parse xml =
      Some
        {
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          modification_state =
            (Util.option_bind (Xml.member "modificationState" xml)
               VolumeModificationState.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          target_size =
            (Util.option_bind (Xml.member "targetSize" xml) Integer.parse);
          target_iops =
            (Util.option_bind (Xml.member "targetIops" xml) Integer.parse);
          target_volume_type =
            (Util.option_bind (Xml.member "targetVolumeType" xml)
               VolumeType.parse);
          original_size =
            (Util.option_bind (Xml.member "originalSize" xml) Integer.parse);
          original_iops =
            (Util.option_bind (Xml.member "originalIops" xml) Integer.parse);
          original_volume_type =
            (Util.option_bind (Xml.member "originalVolumeType" xml)
               VolumeType.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) Long.parse);
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse);
          end_time =
            (Util.option_bind (Xml.member "endTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.end_time
              (fun f -> Query.Pair ("EndTime", (DateTime.to_query f)));
           Util.option_map v.start_time
             (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (Long.to_query f)));
           Util.option_map v.original_volume_type
             (fun f ->
                Query.Pair ("OriginalVolumeType", (VolumeType.to_query f)));
           Util.option_map v.original_iops
             (fun f -> Query.Pair ("OriginalIops", (Integer.to_query f)));
           Util.option_map v.original_size
             (fun f -> Query.Pair ("OriginalSize", (Integer.to_query f)));
           Util.option_map v.target_volume_type
             (fun f ->
                Query.Pair ("TargetVolumeType", (VolumeType.to_query f)));
           Util.option_map v.target_iops
             (fun f -> Query.Pair ("TargetIops", (Integer.to_query f)));
           Util.option_map v.target_size
             (fun f -> Query.Pair ("TargetSize", (Integer.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.modification_state
             (fun f ->
                Query.Pair
                  ("ModificationState", (VolumeModificationState.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Util.option_map v.volume_id
                         (fun f ->
                            Ezxmlm.make_tag "volumeId"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.modification_state
                        (fun f ->
                           Ezxmlm.make_tag "modificationState"
                             ([], (VolumeModificationState.to_xml f)))])
                    @
                    [Util.option_map v.status_message
                       (fun f ->
                          Ezxmlm.make_tag "statusMessage"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.target_size
                      (fun f ->
                         Ezxmlm.make_tag "targetSize"
                           ([], (Integer.to_xml f)))])
                  @
                  [Util.option_map v.target_iops
                     (fun f ->
                        Ezxmlm.make_tag "targetIops" ([], (Integer.to_xml f)))])
                 @
                 [Util.option_map v.target_volume_type
                    (fun f ->
                       Ezxmlm.make_tag "targetVolumeType"
                         ([], (VolumeType.to_xml f)))])
                @
                [Util.option_map v.original_size
                   (fun f ->
                      Ezxmlm.make_tag "originalSize" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.original_iops
                  (fun f ->
                     Ezxmlm.make_tag "originalIops" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.original_volume_type
                 (fun f ->
                    Ezxmlm.make_tag "originalVolumeType"
                      ([], (VolumeType.to_xml f)))])
             @
             [Util.option_map v.progress
                (fun f -> Ezxmlm.make_tag "progress" ([], (Long.to_xml f)))])
            @
            [Util.option_map v.start_time
               (fun f ->
                  Ezxmlm.make_tag "startTime" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.end_time
              (fun f -> Ezxmlm.make_tag "endTime" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.end_time
              (fun f -> ("end_time", (DateTime.to_json f)));
           Util.option_map v.start_time
             (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (Long.to_json f)));
           Util.option_map v.original_volume_type
             (fun f -> ("original_volume_type", (VolumeType.to_json f)));
           Util.option_map v.original_iops
             (fun f -> ("original_iops", (Integer.to_json f)));
           Util.option_map v.original_size
             (fun f -> ("original_size", (Integer.to_json f)));
           Util.option_map v.target_volume_type
             (fun f -> ("target_volume_type", (VolumeType.to_json f)));
           Util.option_map v.target_iops
             (fun f -> ("target_iops", (Integer.to_json f)));
           Util.option_map v.target_size
             (fun f -> ("target_size", (Integer.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.modification_state
             (fun f ->
                ("modification_state", (VolumeModificationState.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)))])
    let of_json j =
      {
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json);
        modification_state =
          (Util.option_map (Json.lookup j "modification_state")
             VolumeModificationState.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        target_size =
          (Util.option_map (Json.lookup j "target_size") Integer.of_json);
        target_iops =
          (Util.option_map (Json.lookup j "target_iops") Integer.of_json);
        target_volume_type =
          (Util.option_map (Json.lookup j "target_volume_type")
             VolumeType.of_json);
        original_size =
          (Util.option_map (Json.lookup j "original_size") Integer.of_json);
        original_iops =
          (Util.option_map (Json.lookup j "original_iops") Integer.of_json);
        original_volume_type =
          (Util.option_map (Json.lookup j "original_volume_type")
             VolumeType.of_json);
        progress = (Util.option_map (Json.lookup j "progress") Long.of_json);
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json);
        end_time =
          (Util.option_map (Json.lookup j "end_time") DateTime.of_json)
      }
  end
module NewDhcpConfiguration =
  struct
    type t = {
      key: String.t option ;
      values: ValueStringList.t }
    let make ?key  ?(values= [])  () = { key; values }
    let parse xml =
      Some
        {
          key = (Util.option_bind (Xml.member "key" xml) String.parse);
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "Value" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Value", (ValueStringList.to_query v.values)));
           Util.option_map v.key
             (fun f -> Query.Pair ("Key", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.key
               (fun f -> Ezxmlm.make_tag "key" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Value"
                      ([], (ValueStringList.to_xml [x])))) v.values))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (ValueStringList.to_json v.values));
           Util.option_map v.key (fun f -> ("key", (String.to_json f)))])
    let of_json j =
      {
        key = (Util.option_map (Json.lookup j "key") String.of_json);
        values =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module NetworkInterface =
  struct
    type t =
      {
      association: NetworkInterfaceAssociation.t option ;
      attachment: NetworkInterfaceAttachment.t option ;
      availability_zone: String.t option ;
      description: String.t option ;
      groups: GroupIdentifierList.t ;
      interface_type: NetworkInterfaceType.t option ;
      ipv6_addresses: NetworkInterfaceIpv6AddressesList.t ;
      mac_address: String.t option ;
      network_interface_id: String.t option ;
      outpost_arn: String.t option ;
      owner_id: String.t option ;
      private_dns_name: String.t option ;
      private_ip_address: String.t option ;
      private_ip_addresses: NetworkInterfacePrivateIpAddressList.t ;
      requester_id: String.t option ;
      requester_managed: Boolean.t option ;
      source_dest_check: Boolean.t option ;
      status: NetworkInterfaceStatus.t option ;
      subnet_id: String.t option ;
      tag_set: TagList.t ;
      vpc_id: String.t option }
    let make ?association  ?attachment  ?availability_zone  ?description 
      ?(groups= [])  ?interface_type  ?(ipv6_addresses= [])  ?mac_address 
      ?network_interface_id  ?outpost_arn  ?owner_id  ?private_dns_name 
      ?private_ip_address  ?(private_ip_addresses= [])  ?requester_id 
      ?requester_managed  ?source_dest_check  ?status  ?subnet_id  ?(tag_set=
      [])  ?vpc_id  () =
      {
        association;
        attachment;
        availability_zone;
        description;
        groups;
        interface_type;
        ipv6_addresses;
        mac_address;
        network_interface_id;
        outpost_arn;
        owner_id;
        private_dns_name;
        private_ip_address;
        private_ip_addresses;
        requester_id;
        requester_managed;
        source_dest_check;
        status;
        subnet_id;
        tag_set;
        vpc_id
      }
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               NetworkInterfaceAssociation.parse);
          attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               NetworkInterfaceAttachment.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          interface_type =
            (Util.option_bind (Xml.member "interfaceType" xml)
               NetworkInterfaceType.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6AddressesSet" xml)
                  NetworkInterfaceIpv6AddressesList.parse));
          mac_address =
            (Util.option_bind (Xml.member "macAddress" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddressesSet" xml)
                  NetworkInterfacePrivateIpAddressList.parse));
          requester_id =
            (Util.option_bind (Xml.member "requesterId" xml) String.parse);
          requester_managed =
            (Util.option_bind (Xml.member "requesterManaged" xml)
               Boolean.parse);
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               Boolean.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               NetworkInterfaceStatus.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          tag_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tag_set)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (NetworkInterfaceStatus.to_query f)));
           Util.option_map v.source_dest_check
             (fun f -> Query.Pair ("SourceDestCheck", (Boolean.to_query f)));
           Util.option_map v.requester_managed
             (fun f -> Query.Pair ("RequesterManaged", (Boolean.to_query f)));
           Util.option_map v.requester_id
             (fun f -> Query.Pair ("RequesterId", (String.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddressesSet",
                  (NetworkInterfacePrivateIpAddressList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.mac_address
             (fun f -> Query.Pair ("MacAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6AddressesSet",
                  (NetworkInterfaceIpv6AddressesList.to_query
                     v.ipv6_addresses)));
           Util.option_map v.interface_type
             (fun f ->
                Query.Pair
                  ("InterfaceType", (NetworkInterfaceType.to_query f)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.attachment
             (fun f ->
                Query.Pair
                  ("Attachment", (NetworkInterfaceAttachment.to_query f)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association", (NetworkInterfaceAssociation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((((((([] @
                               [Util.option_map v.association
                                  (fun f ->
                                     Ezxmlm.make_tag "association"
                                       ([],
                                         (NetworkInterfaceAssociation.to_xml
                                            f)))])
                              @
                              [Util.option_map v.attachment
                                 (fun f ->
                                    Ezxmlm.make_tag "attachment"
                                      ([],
                                        (NetworkInterfaceAttachment.to_xml f)))])
                             @
                             [Util.option_map v.availability_zone
                                (fun f ->
                                   Ezxmlm.make_tag "availabilityZone"
                                     ([], (String.to_xml f)))])
                            @
                            [Util.option_map v.description
                               (fun f ->
                                  Ezxmlm.make_tag "description"
                                    ([], (String.to_xml f)))])
                           @
                           (List.map
                              (fun x ->
                                 Some
                                   (Ezxmlm.make_tag "groupSet"
                                      ([], (GroupIdentifierList.to_xml [x]))))
                              v.groups))
                          @
                          [Util.option_map v.interface_type
                             (fun f ->
                                Ezxmlm.make_tag "interfaceType"
                                  ([], (NetworkInterfaceType.to_xml f)))])
                         @
                         (List.map
                            (fun x ->
                               Some
                                 (Ezxmlm.make_tag "ipv6AddressesSet"
                                    ([],
                                      (NetworkInterfaceIpv6AddressesList.to_xml
                                         [x])))) v.ipv6_addresses))
                        @
                        [Util.option_map v.mac_address
                           (fun f ->
                              Ezxmlm.make_tag "macAddress"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.network_interface_id
                          (fun f ->
                             Ezxmlm.make_tag "networkInterfaceId"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.outpost_arn
                         (fun f ->
                            Ezxmlm.make_tag "outpostArn"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.owner_id
                        (fun f ->
                           Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.private_dns_name
                       (fun f ->
                          Ezxmlm.make_tag "privateDnsName"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.private_ip_address
                      (fun f ->
                         Ezxmlm.make_tag "privateIpAddress"
                           ([], (String.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "privateIpAddressesSet"
                             ([],
                               (NetworkInterfacePrivateIpAddressList.to_xml
                                  [x])))) v.private_ip_addresses))
                 @
                 [Util.option_map v.requester_id
                    (fun f ->
                       Ezxmlm.make_tag "requesterId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.requester_managed
                   (fun f ->
                      Ezxmlm.make_tag "requesterManaged"
                        ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.source_dest_check
                  (fun f ->
                     Ezxmlm.make_tag "sourceDestCheck"
                       ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.status
                 (fun f ->
                    Ezxmlm.make_tag "status"
                      ([], (NetworkInterfaceStatus.to_xml f)))])
             @
             [Util.option_map v.subnet_id
                (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tag_set))
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tag_set", (TagList.to_json v.tag_set));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (NetworkInterfaceStatus.to_json f)));
           Util.option_map v.source_dest_check
             (fun f -> ("source_dest_check", (Boolean.to_json f)));
           Util.option_map v.requester_managed
             (fun f -> ("requester_managed", (Boolean.to_json f)));
           Util.option_map v.requester_id
             (fun f -> ("requester_id", (String.to_json f)));
           Some
             ("private_ip_addresses",
               (NetworkInterfacePrivateIpAddressList.to_json
                  v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.mac_address
             (fun f -> ("mac_address", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (NetworkInterfaceIpv6AddressesList.to_json v.ipv6_addresses));
           Util.option_map v.interface_type
             (fun f -> ("interface_type", (NetworkInterfaceType.to_json f)));
           Some ("groups", (GroupIdentifierList.to_json v.groups));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.attachment
             (fun f -> ("attachment", (NetworkInterfaceAttachment.to_json f)));
           Util.option_map v.association
             (fun f ->
                ("association", (NetworkInterfaceAssociation.to_json f)))])
    let of_json j =
      {
        association =
          (Util.option_map (Json.lookup j "association")
             NetworkInterfaceAssociation.of_json);
        attachment =
          (Util.option_map (Json.lookup j "attachment")
             NetworkInterfaceAttachment.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        interface_type =
          (Util.option_map (Json.lookup j "interface_type")
             NetworkInterfaceType.of_json);
        ipv6_addresses =
          (NetworkInterfaceIpv6AddressesList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        mac_address =
          (Util.option_map (Json.lookup j "mac_address") String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_ip_addresses =
          (NetworkInterfacePrivateIpAddressList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        requester_id =
          (Util.option_map (Json.lookup j "requester_id") String.of_json);
        requester_managed =
          (Util.option_map (Json.lookup j "requester_managed")
             Boolean.of_json);
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             Boolean.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             NetworkInterfaceStatus.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        tag_set =
          (TagList.of_json (Util.of_option_exn (Json.lookup j "tag_set")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module ConnectionNotification =
  struct
    type t =
      {
      connection_notification_id: String.t option ;
      service_id: String.t option ;
      vpc_endpoint_id: String.t option ;
      connection_notification_type: ConnectionNotificationType.t option ;
      connection_notification_arn: String.t option ;
      connection_events: ValueStringList.t ;
      connection_notification_state: ConnectionNotificationState.t option }
    let make ?connection_notification_id  ?service_id  ?vpc_endpoint_id 
      ?connection_notification_type  ?connection_notification_arn 
      ?(connection_events= [])  ?connection_notification_state  () =
      {
        connection_notification_id;
        service_id;
        vpc_endpoint_id;
        connection_notification_type;
        connection_notification_arn;
        connection_events;
        connection_notification_state
      }
    let parse xml =
      Some
        {
          connection_notification_id =
            (Util.option_bind (Xml.member "connectionNotificationId" xml)
               String.parse);
          service_id =
            (Util.option_bind (Xml.member "serviceId" xml) String.parse);
          vpc_endpoint_id =
            (Util.option_bind (Xml.member "vpcEndpointId" xml) String.parse);
          connection_notification_type =
            (Util.option_bind (Xml.member "connectionNotificationType" xml)
               ConnectionNotificationType.parse);
          connection_notification_arn =
            (Util.option_bind (Xml.member "connectionNotificationArn" xml)
               String.parse);
          connection_events =
            (Util.of_option []
               (Util.option_bind (Xml.member "connectionEvents" xml)
                  ValueStringList.parse));
          connection_notification_state =
            (Util.option_bind (Xml.member "connectionNotificationState" xml)
               ConnectionNotificationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.connection_notification_state
              (fun f ->
                 Query.Pair
                   ("ConnectionNotificationState",
                     (ConnectionNotificationState.to_query f)));
           Some
             (Query.Pair
                ("ConnectionEvents",
                  (ValueStringList.to_query v.connection_events)));
           Util.option_map v.connection_notification_arn
             (fun f ->
                Query.Pair ("ConnectionNotificationArn", (String.to_query f)));
           Util.option_map v.connection_notification_type
             (fun f ->
                Query.Pair
                  ("ConnectionNotificationType",
                    (ConnectionNotificationType.to_query f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> Query.Pair ("VpcEndpointId", (String.to_query f)));
           Util.option_map v.service_id
             (fun f -> Query.Pair ("ServiceId", (String.to_query f)));
           Util.option_map v.connection_notification_id
             (fun f ->
                Query.Pair ("ConnectionNotificationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.connection_notification_id
                    (fun f ->
                       Ezxmlm.make_tag "connectionNotificationId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.service_id
                   (fun f ->
                      Ezxmlm.make_tag "serviceId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.vpc_endpoint_id
                  (fun f ->
                     Ezxmlm.make_tag "vpcEndpointId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.connection_notification_type
                 (fun f ->
                    Ezxmlm.make_tag "connectionNotificationType"
                      ([], (ConnectionNotificationType.to_xml f)))])
             @
             [Util.option_map v.connection_notification_arn
                (fun f ->
                   Ezxmlm.make_tag "connectionNotificationArn"
                     ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "connectionEvents"
                       ([], (ValueStringList.to_xml [x]))))
               v.connection_events))
           @
           [Util.option_map v.connection_notification_state
              (fun f ->
                 Ezxmlm.make_tag "connectionNotificationState"
                   ([], (ConnectionNotificationState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.connection_notification_state
              (fun f ->
                 ("connection_notification_state",
                   (ConnectionNotificationState.to_json f)));
           Some
             ("connection_events",
               (ValueStringList.to_json v.connection_events));
           Util.option_map v.connection_notification_arn
             (fun f -> ("connection_notification_arn", (String.to_json f)));
           Util.option_map v.connection_notification_type
             (fun f ->
                ("connection_notification_type",
                  (ConnectionNotificationType.to_json f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> ("vpc_endpoint_id", (String.to_json f)));
           Util.option_map v.service_id
             (fun f -> ("service_id", (String.to_json f)));
           Util.option_map v.connection_notification_id
             (fun f -> ("connection_notification_id", (String.to_json f)))])
    let of_json j =
      {
        connection_notification_id =
          (Util.option_map (Json.lookup j "connection_notification_id")
             String.of_json);
        service_id =
          (Util.option_map (Json.lookup j "service_id") String.of_json);
        vpc_endpoint_id =
          (Util.option_map (Json.lookup j "vpc_endpoint_id") String.of_json);
        connection_notification_type =
          (Util.option_map (Json.lookup j "connection_notification_type")
             ConnectionNotificationType.of_json);
        connection_notification_arn =
          (Util.option_map (Json.lookup j "connection_notification_arn")
             String.of_json);
        connection_events =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "connection_events")));
        connection_notification_state =
          (Util.option_map (Json.lookup j "connection_notification_state")
             ConnectionNotificationState.of_json)
      }
  end
module ReservedInstances =
  struct
    type t =
      {
      availability_zone: String.t option ;
      duration: Long.t option ;
      end_: DateTime.t option ;
      fixed_price: Float.t option ;
      instance_count: Integer.t option ;
      instance_type: InstanceType.t option ;
      product_description: RIProductDescription.t option ;
      reserved_instances_id: String.t option ;
      start: DateTime.t option ;
      state: ReservedInstanceState.t option ;
      usage_price: Float.t option ;
      currency_code: CurrencyCodeValues.t option ;
      instance_tenancy: Tenancy.t option ;
      offering_class: OfferingClassType.t option ;
      offering_type: OfferingTypeValues.t option ;
      recurring_charges: RecurringChargesList.t ;
      scope: Scope.t option ;
      tags: TagList.t }
    let make ?availability_zone  ?duration  ?end_  ?fixed_price 
      ?instance_count  ?instance_type  ?product_description 
      ?reserved_instances_id  ?start  ?state  ?usage_price  ?currency_code 
      ?instance_tenancy  ?offering_class  ?offering_type 
      ?(recurring_charges= [])  ?scope  ?(tags= [])  () =
      {
        availability_zone;
        duration;
        end_;
        fixed_price;
        instance_count;
        instance_type;
        product_description;
        reserved_instances_id;
        start;
        state;
        usage_price;
        currency_code;
        instance_tenancy;
        offering_class;
        offering_type;
        recurring_charges;
        scope;
        tags
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Long.parse);
          end_ = (Util.option_bind (Xml.member "end" xml) DateTime.parse);
          fixed_price =
            (Util.option_bind (Xml.member "fixedPrice" xml) Float.parse);
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          product_description =
            (Util.option_bind (Xml.member "productDescription" xml)
               RIProductDescription.parse);
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse);
          start = (Util.option_bind (Xml.member "start" xml) DateTime.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               ReservedInstanceState.parse);
          usage_price =
            (Util.option_bind (Xml.member "usagePrice" xml) Float.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          instance_tenancy =
            (Util.option_bind (Xml.member "instanceTenancy" xml)
               Tenancy.parse);
          offering_class =
            (Util.option_bind (Xml.member "offeringClass" xml)
               OfferingClassType.parse);
          offering_type =
            (Util.option_bind (Xml.member "offeringType" xml)
               OfferingTypeValues.parse);
          recurring_charges =
            (Util.of_option []
               (Util.option_bind (Xml.member "recurringCharges" xml)
                  RecurringChargesList.parse));
          scope = (Util.option_bind (Xml.member "scope" xml) Scope.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.scope
             (fun f -> Query.Pair ("Scope", (Scope.to_query f)));
           Some
             (Query.Pair
                ("RecurringCharges",
                  (RecurringChargesList.to_query v.recurring_charges)));
           Util.option_map v.offering_type
             (fun f ->
                Query.Pair ("OfferingType", (OfferingTypeValues.to_query f)));
           Util.option_map v.offering_class
             (fun f ->
                Query.Pair ("OfferingClass", (OfferingClassType.to_query f)));
           Util.option_map v.instance_tenancy
             (fun f -> Query.Pair ("InstanceTenancy", (Tenancy.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.usage_price
             (fun f -> Query.Pair ("UsagePrice", (Float.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (ReservedInstanceState.to_query f)));
           Util.option_map v.start
             (fun f -> Query.Pair ("Start", (DateTime.to_query f)));
           Util.option_map v.reserved_instances_id
             (fun f ->
                Query.Pair ("ReservedInstancesId", (String.to_query f)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.fixed_price
             (fun f -> Query.Pair ("FixedPrice", (Float.to_query f)));
           Util.option_map v.end_
             (fun f -> Query.Pair ("End", (DateTime.to_query f)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Long.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((([] @
                            [Util.option_map v.availability_zone
                               (fun f ->
                                  Ezxmlm.make_tag "availabilityZone"
                                    ([], (String.to_xml f)))])
                           @
                           [Util.option_map v.duration
                              (fun f ->
                                 Ezxmlm.make_tag "duration"
                                   ([], (Long.to_xml f)))])
                          @
                          [Util.option_map v.end_
                             (fun f ->
                                Ezxmlm.make_tag "end"
                                  ([], (DateTime.to_xml f)))])
                         @
                         [Util.option_map v.fixed_price
                            (fun f ->
                               Ezxmlm.make_tag "fixedPrice"
                                 ([], (Float.to_xml f)))])
                        @
                        [Util.option_map v.instance_count
                           (fun f ->
                              Ezxmlm.make_tag "instanceCount"
                                ([], (Integer.to_xml f)))])
                       @
                       [Util.option_map v.instance_type
                          (fun f ->
                             Ezxmlm.make_tag "instanceType"
                               ([], (InstanceType.to_xml f)))])
                      @
                      [Util.option_map v.product_description
                         (fun f ->
                            Ezxmlm.make_tag "productDescription"
                              ([], (RIProductDescription.to_xml f)))])
                     @
                     [Util.option_map v.reserved_instances_id
                        (fun f ->
                           Ezxmlm.make_tag "reservedInstancesId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.start
                       (fun f ->
                          Ezxmlm.make_tag "start" ([], (DateTime.to_xml f)))])
                   @
                   [Util.option_map v.state
                      (fun f ->
                         Ezxmlm.make_tag "state"
                           ([], (ReservedInstanceState.to_xml f)))])
                  @
                  [Util.option_map v.usage_price
                     (fun f ->
                        Ezxmlm.make_tag "usagePrice" ([], (Float.to_xml f)))])
                 @
                 [Util.option_map v.currency_code
                    (fun f ->
                       Ezxmlm.make_tag "currencyCode"
                         ([], (CurrencyCodeValues.to_xml f)))])
                @
                [Util.option_map v.instance_tenancy
                   (fun f ->
                      Ezxmlm.make_tag "instanceTenancy"
                        ([], (Tenancy.to_xml f)))])
               @
               [Util.option_map v.offering_class
                  (fun f ->
                     Ezxmlm.make_tag "offeringClass"
                       ([], (OfferingClassType.to_xml f)))])
              @
              [Util.option_map v.offering_type
                 (fun f ->
                    Ezxmlm.make_tag "offeringType"
                      ([], (OfferingTypeValues.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "recurringCharges"
                        ([], (RecurringChargesList.to_xml [x]))))
                v.recurring_charges))
            @
            [Util.option_map v.scope
               (fun f -> Ezxmlm.make_tag "scope" ([], (Scope.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.scope (fun f -> ("scope", (Scope.to_json f)));
           Some
             ("recurring_charges",
               (RecurringChargesList.to_json v.recurring_charges));
           Util.option_map v.offering_type
             (fun f -> ("offering_type", (OfferingTypeValues.to_json f)));
           Util.option_map v.offering_class
             (fun f -> ("offering_class", (OfferingClassType.to_json f)));
           Util.option_map v.instance_tenancy
             (fun f -> ("instance_tenancy", (Tenancy.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.usage_price
             (fun f -> ("usage_price", (Float.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (ReservedInstanceState.to_json f)));
           Util.option_map v.start (fun f -> ("start", (DateTime.to_json f)));
           Util.option_map v.reserved_instances_id
             (fun f -> ("reserved_instances_id", (String.to_json f)));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.fixed_price
             (fun f -> ("fixed_price", (Float.to_json f)));
           Util.option_map v.end_ (fun f -> ("end_", (DateTime.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Long.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        duration = (Util.option_map (Json.lookup j "duration") Long.of_json);
        end_ = (Util.option_map (Json.lookup j "end_") DateTime.of_json);
        fixed_price =
          (Util.option_map (Json.lookup j "fixed_price") Float.of_json);
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        product_description =
          (Util.option_map (Json.lookup j "product_description")
             RIProductDescription.of_json);
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json);
        start = (Util.option_map (Json.lookup j "start") DateTime.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             ReservedInstanceState.of_json);
        usage_price =
          (Util.option_map (Json.lookup j "usage_price") Float.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        instance_tenancy =
          (Util.option_map (Json.lookup j "instance_tenancy") Tenancy.of_json);
        offering_class =
          (Util.option_map (Json.lookup j "offering_class")
             OfferingClassType.of_json);
        offering_type =
          (Util.option_map (Json.lookup j "offering_type")
             OfferingTypeValues.of_json);
        recurring_charges =
          (RecurringChargesList.of_json
             (Util.of_option_exn (Json.lookup j "recurring_charges")));
        scope = (Util.option_map (Json.lookup j "scope") Scope.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module TransitGatewayPeeringAttachment =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option ;
      requester_tgw_info: PeeringTgwInfo.t option ;
      accepter_tgw_info: PeeringTgwInfo.t option ;
      status: PeeringAttachmentStatus.t option ;
      state: TransitGatewayAttachmentState.t option ;
      creation_time: DateTime.t option ;
      tags: TagList.t }
    let make ?transit_gateway_attachment_id  ?requester_tgw_info 
      ?accepter_tgw_info  ?status  ?state  ?creation_time  ?(tags= [])  () =
      {
        transit_gateway_attachment_id;
        requester_tgw_info;
        accepter_tgw_info;
        status;
        state;
        creation_time;
        tags
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          requester_tgw_info =
            (Util.option_bind (Xml.member "requesterTgwInfo" xml)
               PeeringTgwInfo.parse);
          accepter_tgw_info =
            (Util.option_bind (Xml.member "accepterTgwInfo" xml)
               PeeringTgwInfo.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               PeeringAttachmentStatus.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAttachmentState.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (TransitGatewayAttachmentState.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (PeeringAttachmentStatus.to_query f)));
           Util.option_map v.accepter_tgw_info
             (fun f ->
                Query.Pair ("AccepterTgwInfo", (PeeringTgwInfo.to_query f)));
           Util.option_map v.requester_tgw_info
             (fun f ->
                Query.Pair ("RequesterTgwInfo", (PeeringTgwInfo.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.transit_gateway_attachment_id
                    (fun f ->
                       Ezxmlm.make_tag "transitGatewayAttachmentId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.requester_tgw_info
                   (fun f ->
                      Ezxmlm.make_tag "requesterTgwInfo"
                        ([], (PeeringTgwInfo.to_xml f)))])
               @
               [Util.option_map v.accepter_tgw_info
                  (fun f ->
                     Ezxmlm.make_tag "accepterTgwInfo"
                       ([], (PeeringTgwInfo.to_xml f)))])
              @
              [Util.option_map v.status
                 (fun f ->
                    Ezxmlm.make_tag "status"
                      ([], (PeeringAttachmentStatus.to_xml f)))])
             @
             [Util.option_map v.state
                (fun f ->
                   Ezxmlm.make_tag "state"
                     ([], (TransitGatewayAttachmentState.to_xml f)))])
            @
            [Util.option_map v.creation_time
               (fun f ->
                  Ezxmlm.make_tag "creationTime" ([], (DateTime.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (TransitGatewayAttachmentState.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (PeeringAttachmentStatus.to_json f)));
           Util.option_map v.accepter_tgw_info
             (fun f -> ("accepter_tgw_info", (PeeringTgwInfo.to_json f)));
           Util.option_map v.requester_tgw_info
             (fun f -> ("requester_tgw_info", (PeeringTgwInfo.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        requester_tgw_info =
          (Util.option_map (Json.lookup j "requester_tgw_info")
             PeeringTgwInfo.of_json);
        accepter_tgw_info =
          (Util.option_map (Json.lookup j "accepter_tgw_info")
             PeeringTgwInfo.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             PeeringAttachmentStatus.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayAttachmentState.of_json);
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") DateTime.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module CancelledSpotInstanceRequest =
  struct
    type t =
      {
      spot_instance_request_id: String.t option ;
      state: CancelSpotInstanceRequestState.t option }
    let make ?spot_instance_request_id  ?state  () =
      { spot_instance_request_id; state }
    let parse xml =
      Some
        {
          spot_instance_request_id =
            (Util.option_bind (Xml.member "spotInstanceRequestId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               CancelSpotInstanceRequestState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (CancelSpotInstanceRequestState.to_query f)));
           Util.option_map v.spot_instance_request_id
             (fun f ->
                Query.Pair ("SpotInstanceRequestId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.spot_instance_request_id
               (fun f ->
                  Ezxmlm.make_tag "spotInstanceRequestId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (CancelSpotInstanceRequestState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (CancelSpotInstanceRequestState.to_json f)));
           Util.option_map v.spot_instance_request_id
             (fun f -> ("spot_instance_request_id", (String.to_json f)))])
    let of_json j =
      {
        spot_instance_request_id =
          (Util.option_map (Json.lookup j "spot_instance_request_id")
             String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             CancelSpotInstanceRequestState.of_json)
      }
  end
module ServiceConfiguration =
  struct
    type t =
      {
      service_type: ServiceTypeDetailSet.t ;
      service_id: String.t option ;
      service_name: String.t option ;
      service_state: ServiceState.t option ;
      availability_zones: ValueStringList.t ;
      acceptance_required: Boolean.t option ;
      manages_vpc_endpoints: Boolean.t option ;
      network_load_balancer_arns: ValueStringList.t ;
      base_endpoint_dns_names: ValueStringList.t ;
      private_dns_name: String.t option ;
      tags: TagList.t }
    let make ?(service_type= [])  ?service_id  ?service_name  ?service_state 
      ?(availability_zones= [])  ?acceptance_required  ?manages_vpc_endpoints
       ?(network_load_balancer_arns= [])  ?(base_endpoint_dns_names= []) 
      ?private_dns_name  ?(tags= [])  () =
      {
        service_type;
        service_id;
        service_name;
        service_state;
        availability_zones;
        acceptance_required;
        manages_vpc_endpoints;
        network_load_balancer_arns;
        base_endpoint_dns_names;
        private_dns_name;
        tags
      }
    let parse xml =
      Some
        {
          service_type =
            (Util.of_option []
               (Util.option_bind (Xml.member "serviceType" xml)
                  ServiceTypeDetailSet.parse));
          service_id =
            (Util.option_bind (Xml.member "serviceId" xml) String.parse);
          service_name =
            (Util.option_bind (Xml.member "serviceName" xml) String.parse);
          service_state =
            (Util.option_bind (Xml.member "serviceState" xml)
               ServiceState.parse);
          availability_zones =
            (Util.of_option []
               (Util.option_bind (Xml.member "availabilityZoneSet" xml)
                  ValueStringList.parse));
          acceptance_required =
            (Util.option_bind (Xml.member "acceptanceRequired" xml)
               Boolean.parse);
          manages_vpc_endpoints =
            (Util.option_bind (Xml.member "managesVpcEndpoints" xml)
               Boolean.parse);
          network_load_balancer_arns =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkLoadBalancerArnSet" xml)
                  ValueStringList.parse));
          base_endpoint_dns_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "baseEndpointDnsNameSet" xml)
                  ValueStringList.parse));
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Some
             (Query.Pair
                ("BaseEndpointDnsNameSet",
                  (ValueStringList.to_query v.base_endpoint_dns_names)));
           Some
             (Query.Pair
                ("NetworkLoadBalancerArnSet",
                  (ValueStringList.to_query v.network_load_balancer_arns)));
           Util.option_map v.manages_vpc_endpoints
             (fun f ->
                Query.Pair ("ManagesVpcEndpoints", (Boolean.to_query f)));
           Util.option_map v.acceptance_required
             (fun f ->
                Query.Pair ("AcceptanceRequired", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZoneSet",
                  (ValueStringList.to_query v.availability_zones)));
           Util.option_map v.service_state
             (fun f -> Query.Pair ("ServiceState", (ServiceState.to_query f)));
           Util.option_map v.service_name
             (fun f -> Query.Pair ("ServiceName", (String.to_query f)));
           Util.option_map v.service_id
             (fun f -> Query.Pair ("ServiceId", (String.to_query f)));
           Some
             (Query.Pair
                ("ServiceType",
                  (ServiceTypeDetailSet.to_query v.service_type)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     (List.map
                        (fun x ->
                           Some
                             (Ezxmlm.make_tag "serviceType"
                                ([], (ServiceTypeDetailSet.to_xml [x]))))
                        v.service_type))
                    @
                    [Util.option_map v.service_id
                       (fun f ->
                          Ezxmlm.make_tag "serviceId" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.service_name
                      (fun f ->
                         Ezxmlm.make_tag "serviceName"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.service_state
                     (fun f ->
                        Ezxmlm.make_tag "serviceState"
                          ([], (ServiceState.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "availabilityZoneSet"
                            ([], (ValueStringList.to_xml [x]))))
                    v.availability_zones))
                @
                [Util.option_map v.acceptance_required
                   (fun f ->
                      Ezxmlm.make_tag "acceptanceRequired"
                        ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.manages_vpc_endpoints
                  (fun f ->
                     Ezxmlm.make_tag "managesVpcEndpoints"
                       ([], (Boolean.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "networkLoadBalancerArnSet"
                         ([], (ValueStringList.to_xml [x]))))
                 v.network_load_balancer_arns))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "baseEndpointDnsNameSet"
                        ([], (ValueStringList.to_xml [x]))))
                v.base_endpoint_dns_names))
            @
            [Util.option_map v.private_dns_name
               (fun f ->
                  Ezxmlm.make_tag "privateDnsName" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Some
             ("base_endpoint_dns_names",
               (ValueStringList.to_json v.base_endpoint_dns_names));
           Some
             ("network_load_balancer_arns",
               (ValueStringList.to_json v.network_load_balancer_arns));
           Util.option_map v.manages_vpc_endpoints
             (fun f -> ("manages_vpc_endpoints", (Boolean.to_json f)));
           Util.option_map v.acceptance_required
             (fun f -> ("acceptance_required", (Boolean.to_json f)));
           Some
             ("availability_zones",
               (ValueStringList.to_json v.availability_zones));
           Util.option_map v.service_state
             (fun f -> ("service_state", (ServiceState.to_json f)));
           Util.option_map v.service_name
             (fun f -> ("service_name", (String.to_json f)));
           Util.option_map v.service_id
             (fun f -> ("service_id", (String.to_json f)));
           Some
             ("service_type", (ServiceTypeDetailSet.to_json v.service_type))])
    let of_json j =
      {
        service_type =
          (ServiceTypeDetailSet.of_json
             (Util.of_option_exn (Json.lookup j "service_type")));
        service_id =
          (Util.option_map (Json.lookup j "service_id") String.of_json);
        service_name =
          (Util.option_map (Json.lookup j "service_name") String.of_json);
        service_state =
          (Util.option_map (Json.lookup j "service_state")
             ServiceState.of_json);
        availability_zones =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "availability_zones")));
        acceptance_required =
          (Util.option_map (Json.lookup j "acceptance_required")
             Boolean.of_json);
        manages_vpc_endpoints =
          (Util.option_map (Json.lookup j "manages_vpc_endpoints")
             Boolean.of_json);
        network_load_balancer_arns =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "network_load_balancer_arns")));
        base_endpoint_dns_names =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "base_endpoint_dns_names")));
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ConversionTask =
  struct
    type t =
      {
      conversion_task_id: String.t option ;
      expiration_time: String.t option ;
      import_instance: ImportInstanceTaskDetails.t option ;
      import_volume: ImportVolumeTaskDetails.t option ;
      state: ConversionTaskState.t option ;
      status_message: String.t option ;
      tags: TagList.t }
    let make ?conversion_task_id  ?expiration_time  ?import_instance 
      ?import_volume  ?state  ?status_message  ?(tags= [])  () =
      {
        conversion_task_id;
        expiration_time;
        import_instance;
        import_volume;
        state;
        status_message;
        tags
      }
    let parse xml =
      Some
        {
          conversion_task_id =
            (Util.option_bind (Xml.member "conversionTaskId" xml)
               String.parse);
          expiration_time =
            (Util.option_bind (Xml.member "expirationTime" xml) String.parse);
          import_instance =
            (Util.option_bind (Xml.member "importInstance" xml)
               ImportInstanceTaskDetails.parse);
          import_volume =
            (Util.option_bind (Xml.member "importVolume" xml)
               ImportVolumeTaskDetails.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               ConversionTaskState.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (ConversionTaskState.to_query f)));
           Util.option_map v.import_volume
             (fun f ->
                Query.Pair
                  ("ImportVolume", (ImportVolumeTaskDetails.to_query f)));
           Util.option_map v.import_instance
             (fun f ->
                Query.Pair
                  ("ImportInstance", (ImportInstanceTaskDetails.to_query f)));
           Util.option_map v.expiration_time
             (fun f -> Query.Pair ("ExpirationTime", (String.to_query f)));
           Util.option_map v.conversion_task_id
             (fun f -> Query.Pair ("ConversionTaskId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.conversion_task_id
                    (fun f ->
                       Ezxmlm.make_tag "conversionTaskId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.expiration_time
                   (fun f ->
                      Ezxmlm.make_tag "expirationTime"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.import_instance
                  (fun f ->
                     Ezxmlm.make_tag "importInstance"
                       ([], (ImportInstanceTaskDetails.to_xml f)))])
              @
              [Util.option_map v.import_volume
                 (fun f ->
                    Ezxmlm.make_tag "importVolume"
                      ([], (ImportVolumeTaskDetails.to_xml f)))])
             @
             [Util.option_map v.state
                (fun f ->
                   Ezxmlm.make_tag "state"
                     ([], (ConversionTaskState.to_xml f)))])
            @
            [Util.option_map v.status_message
               (fun f ->
                  Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (ConversionTaskState.to_json f)));
           Util.option_map v.import_volume
             (fun f -> ("import_volume", (ImportVolumeTaskDetails.to_json f)));
           Util.option_map v.import_instance
             (fun f ->
                ("import_instance", (ImportInstanceTaskDetails.to_json f)));
           Util.option_map v.expiration_time
             (fun f -> ("expiration_time", (String.to_json f)));
           Util.option_map v.conversion_task_id
             (fun f -> ("conversion_task_id", (String.to_json f)))])
    let of_json j =
      {
        conversion_task_id =
          (Util.option_map (Json.lookup j "conversion_task_id")
             String.of_json);
        expiration_time =
          (Util.option_map (Json.lookup j "expiration_time") String.of_json);
        import_instance =
          (Util.option_map (Json.lookup j "import_instance")
             ImportInstanceTaskDetails.of_json);
        import_volume =
          (Util.option_map (Json.lookup j "import_volume")
             ImportVolumeTaskDetails.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             ConversionTaskState.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module TransitGatewayVpcAttachment =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option ;
      transit_gateway_id: String.t option ;
      vpc_id: String.t option ;
      vpc_owner_id: String.t option ;
      state: TransitGatewayAttachmentState.t option ;
      subnet_ids: ValueStringList.t ;
      creation_time: DateTime.t option ;
      options: TransitGatewayVpcAttachmentOptions.t option ;
      tags: TagList.t }
    let make ?transit_gateway_attachment_id  ?transit_gateway_id  ?vpc_id 
      ?vpc_owner_id  ?state  ?(subnet_ids= [])  ?creation_time  ?options 
      ?(tags= [])  () =
      {
        transit_gateway_attachment_id;
        transit_gateway_id;
        vpc_id;
        vpc_owner_id;
        state;
        subnet_ids;
        creation_time;
        options;
        tags
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          vpc_owner_id =
            (Util.option_bind (Xml.member "vpcOwnerId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAttachmentState.parse);
          subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "subnetIds" xml)
                  ValueStringList.parse));
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          options =
            (Util.option_bind (Xml.member "options" xml)
               TransitGatewayVpcAttachmentOptions.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.options
             (fun f ->
                Query.Pair
                  ("Options",
                    (TransitGatewayVpcAttachmentOptions.to_query f)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("SubnetIds", (ValueStringList.to_query v.subnet_ids)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (TransitGatewayAttachmentState.to_query f)));
           Util.option_map v.vpc_owner_id
             (fun f -> Query.Pair ("VpcOwnerId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.transit_gateway_attachment_id
                      (fun f ->
                         Ezxmlm.make_tag "transitGatewayAttachmentId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.transit_gateway_id
                     (fun f ->
                        Ezxmlm.make_tag "transitGatewayId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.vpc_id
                    (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.vpc_owner_id
                   (fun f ->
                      Ezxmlm.make_tag "vpcOwnerId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.state
                  (fun f ->
                     Ezxmlm.make_tag "state"
                       ([], (TransitGatewayAttachmentState.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "subnetIds"
                         ([], (ValueStringList.to_xml [x])))) v.subnet_ids))
             @
             [Util.option_map v.creation_time
                (fun f ->
                   Ezxmlm.make_tag "creationTime" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.options
               (fun f ->
                  Ezxmlm.make_tag "options"
                    ([], (TransitGatewayVpcAttachmentOptions.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.options
             (fun f ->
                ("options", (TransitGatewayVpcAttachmentOptions.to_json f)));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Some ("subnet_ids", (ValueStringList.to_json v.subnet_ids));
           Util.option_map v.state
             (fun f -> ("state", (TransitGatewayAttachmentState.to_json f)));
           Util.option_map v.vpc_owner_id
             (fun f -> ("vpc_owner_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        vpc_owner_id =
          (Util.option_map (Json.lookup j "vpc_owner_id") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayAttachmentState.of_json);
        subnet_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "subnet_ids")));
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") DateTime.of_json);
        options =
          (Util.option_map (Json.lookup j "options")
             TransitGatewayVpcAttachmentOptions.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ReservedInstanceReservationValue =
  struct
    type t =
      {
      reservation_value: ReservationValue.t option ;
      reserved_instance_id: String.t option }
    let make ?reservation_value  ?reserved_instance_id  () =
      { reservation_value; reserved_instance_id }
    let parse xml =
      Some
        {
          reservation_value =
            (Util.option_bind (Xml.member "reservationValue" xml)
               ReservationValue.parse);
          reserved_instance_id =
            (Util.option_bind (Xml.member "reservedInstanceId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instance_id
              (fun f ->
                 Query.Pair ("ReservedInstanceId", (String.to_query f)));
           Util.option_map v.reservation_value
             (fun f ->
                Query.Pair
                  ("ReservationValue", (ReservationValue.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.reservation_value
               (fun f ->
                  Ezxmlm.make_tag "reservationValue"
                    ([], (ReservationValue.to_xml f)))])
           @
           [Util.option_map v.reserved_instance_id
              (fun f ->
                 Ezxmlm.make_tag "reservedInstanceId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instance_id
              (fun f -> ("reserved_instance_id", (String.to_json f)));
           Util.option_map v.reservation_value
             (fun f -> ("reservation_value", (ReservationValue.to_json f)))])
    let of_json j =
      {
        reservation_value =
          (Util.option_map (Json.lookup j "reservation_value")
             ReservationValue.of_json);
        reserved_instance_id =
          (Util.option_map (Json.lookup j "reserved_instance_id")
             String.of_json)
      }
  end
module TargetReservationValue =
  struct
    type t =
      {
      reservation_value: ReservationValue.t option ;
      target_configuration: TargetConfiguration.t option }
    let make ?reservation_value  ?target_configuration  () =
      { reservation_value; target_configuration }
    let parse xml =
      Some
        {
          reservation_value =
            (Util.option_bind (Xml.member "reservationValue" xml)
               ReservationValue.parse);
          target_configuration =
            (Util.option_bind (Xml.member "targetConfiguration" xml)
               TargetConfiguration.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.target_configuration
              (fun f ->
                 Query.Pair
                   ("TargetConfiguration", (TargetConfiguration.to_query f)));
           Util.option_map v.reservation_value
             (fun f ->
                Query.Pair
                  ("ReservationValue", (ReservationValue.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.reservation_value
               (fun f ->
                  Ezxmlm.make_tag "reservationValue"
                    ([], (ReservationValue.to_xml f)))])
           @
           [Util.option_map v.target_configuration
              (fun f ->
                 Ezxmlm.make_tag "targetConfiguration"
                   ([], (TargetConfiguration.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_configuration
              (fun f ->
                 ("target_configuration", (TargetConfiguration.to_json f)));
           Util.option_map v.reservation_value
             (fun f -> ("reservation_value", (ReservationValue.to_json f)))])
    let of_json j =
      {
        reservation_value =
          (Util.option_map (Json.lookup j "reservation_value")
             ReservationValue.of_json);
        target_configuration =
          (Util.option_map (Json.lookup j "target_configuration")
             TargetConfiguration.of_json)
      }
  end
module TransitGatewayRoute =
  struct
    type t =
      {
      destination_cidr_block: String.t option ;
      transit_gateway_attachments: TransitGatewayRouteAttachmentList.t ;
      type_: TransitGatewayRouteType.t option ;
      state: TransitGatewayRouteState.t option }
    let make ?destination_cidr_block  ?(transit_gateway_attachments= []) 
      ?type_  ?state  () =
      { destination_cidr_block; transit_gateway_attachments; type_; state }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          transit_gateway_attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "transitGatewayAttachments" xml)
                  TransitGatewayRouteAttachmentList.parse));
          type_ =
            (Util.option_bind (Xml.member "type" xml)
               TransitGatewayRouteType.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayRouteState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair ("State", (TransitGatewayRouteState.to_query f)));
           Util.option_map v.type_
             (fun f ->
                Query.Pair ("Type", (TransitGatewayRouteType.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachments",
                  (TransitGatewayRouteAttachmentList.to_query
                     v.transit_gateway_attachments)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.destination_cidr_block
                 (fun f ->
                    Ezxmlm.make_tag "destinationCidrBlock"
                      ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "transitGatewayAttachments"
                        ([], (TransitGatewayRouteAttachmentList.to_xml [x]))))
                v.transit_gateway_attachments))
            @
            [Util.option_map v.type_
               (fun f ->
                  Ezxmlm.make_tag "type"
                    ([], (TransitGatewayRouteType.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (TransitGatewayRouteState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayRouteState.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (TransitGatewayRouteType.to_json f)));
           Some
             ("transit_gateway_attachments",
               (TransitGatewayRouteAttachmentList.to_json
                  v.transit_gateway_attachments));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        transit_gateway_attachments =
          (TransitGatewayRouteAttachmentList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachments")));
        type_ =
          (Util.option_map (Json.lookup j "type_")
             TransitGatewayRouteType.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayRouteState.of_json)
      }
  end
module HistoryRecord =
  struct
    type t =
      {
      event_information: EventInformation.t option ;
      event_type: EventType.t option ;
      timestamp: DateTime.t option }
    let make ?event_information  ?event_type  ?timestamp  () =
      { event_information; event_type; timestamp }
    let parse xml =
      Some
        {
          event_information =
            (Util.option_bind (Xml.member "eventInformation" xml)
               EventInformation.parse);
          event_type =
            (Util.option_bind (Xml.member "eventType" xml) EventType.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.event_type
             (fun f -> Query.Pair ("EventType", (EventType.to_query f)));
           Util.option_map v.event_information
             (fun f ->
                Query.Pair
                  ("EventInformation", (EventInformation.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.event_information
                (fun f ->
                   Ezxmlm.make_tag "eventInformation"
                     ([], (EventInformation.to_xml f)))])
            @
            [Util.option_map v.event_type
               (fun f ->
                  Ezxmlm.make_tag "eventType" ([], (EventType.to_xml f)))])
           @
           [Util.option_map v.timestamp
              (fun f -> Ezxmlm.make_tag "timestamp" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.event_type
             (fun f -> ("event_type", (EventType.to_json f)));
           Util.option_map v.event_information
             (fun f -> ("event_information", (EventInformation.to_json f)))])
    let of_json j =
      {
        event_information =
          (Util.option_map (Json.lookup j "event_information")
             EventInformation.of_json);
        event_type =
          (Util.option_map (Json.lookup j "event_type") EventType.of_json);
        timestamp =
          (Util.option_map (Json.lookup j "timestamp") DateTime.of_json)
      }
  end
module FpgaImage =
  struct
    type t =
      {
      fpga_image_id: String.t option ;
      fpga_image_global_id: String.t option ;
      name: String.t option ;
      description: String.t option ;
      shell_version: String.t option ;
      pci_id: PciId.t option ;
      state: FpgaImageState.t option ;
      create_time: DateTime.t option ;
      update_time: DateTime.t option ;
      owner_id: String.t option ;
      owner_alias: String.t option ;
      product_codes: ProductCodeList.t ;
      tags: TagList.t ;
      public: Boolean.t option ;
      data_retention_support: Boolean.t option }
    let make ?fpga_image_id  ?fpga_image_global_id  ?name  ?description 
      ?shell_version  ?pci_id  ?state  ?create_time  ?update_time  ?owner_id 
      ?owner_alias  ?(product_codes= [])  ?(tags= [])  ?public 
      ?data_retention_support  () =
      {
        fpga_image_id;
        fpga_image_global_id;
        name;
        description;
        shell_version;
        pci_id;
        state;
        create_time;
        update_time;
        owner_id;
        owner_alias;
        product_codes;
        tags;
        public;
        data_retention_support
      }
    let parse xml =
      Some
        {
          fpga_image_id =
            (Util.option_bind (Xml.member "fpgaImageId" xml) String.parse);
          fpga_image_global_id =
            (Util.option_bind (Xml.member "fpgaImageGlobalId" xml)
               String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          shell_version =
            (Util.option_bind (Xml.member "shellVersion" xml) String.parse);
          pci_id = (Util.option_bind (Xml.member "pciId" xml) PciId.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) FpgaImageState.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          update_time =
            (Util.option_bind (Xml.member "updateTime" xml) DateTime.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          owner_alias =
            (Util.option_bind (Xml.member "ownerAlias" xml) String.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tags" xml) TagList.parse));
          public = (Util.option_bind (Xml.member "public" xml) Boolean.parse);
          data_retention_support =
            (Util.option_bind (Xml.member "dataRetentionSupport" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.data_retention_support
              (fun f ->
                 Query.Pair ("DataRetentionSupport", (Boolean.to_query f)));
           Util.option_map v.public
             (fun f -> Query.Pair ("Public", (Boolean.to_query f)));
           Some (Query.Pair ("Tags", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Util.option_map v.owner_alias
             (fun f -> Query.Pair ("OwnerAlias", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.update_time
             (fun f -> Query.Pair ("UpdateTime", (DateTime.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (FpgaImageState.to_query f)));
           Util.option_map v.pci_id
             (fun f -> Query.Pair ("PciId", (PciId.to_query f)));
           Util.option_map v.shell_version
             (fun f -> Query.Pair ("ShellVersion", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.fpga_image_global_id
             (fun f -> Query.Pair ("FpgaImageGlobalId", (String.to_query f)));
           Util.option_map v.fpga_image_id
             (fun f -> Query.Pair ("FpgaImageId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Util.option_map v.fpga_image_id
                            (fun f ->
                               Ezxmlm.make_tag "fpgaImageId"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.fpga_image_global_id
                           (fun f ->
                              Ezxmlm.make_tag "fpgaImageGlobalId"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.name
                          (fun f ->
                             Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.description
                         (fun f ->
                            Ezxmlm.make_tag "description"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.shell_version
                        (fun f ->
                           Ezxmlm.make_tag "shellVersion"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.pci_id
                       (fun f ->
                          Ezxmlm.make_tag "pciId" ([], (PciId.to_xml f)))])
                   @
                   [Util.option_map v.state
                      (fun f ->
                         Ezxmlm.make_tag "state"
                           ([], (FpgaImageState.to_xml f)))])
                  @
                  [Util.option_map v.create_time
                     (fun f ->
                        Ezxmlm.make_tag "createTime"
                          ([], (DateTime.to_xml f)))])
                 @
                 [Util.option_map v.update_time
                    (fun f ->
                       Ezxmlm.make_tag "updateTime" ([], (DateTime.to_xml f)))])
                @
                [Util.option_map v.owner_id
                   (fun f ->
                      Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.owner_alias
                  (fun f ->
                     Ezxmlm.make_tag "ownerAlias" ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "productCodes"
                         ([], (ProductCodeList.to_xml [x])))) v.product_codes))
             @
             (List.map
                (fun x ->
                   Some (Ezxmlm.make_tag "tags" ([], (TagList.to_xml [x]))))
                v.tags))
            @
            [Util.option_map v.public
               (fun f -> Ezxmlm.make_tag "public" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.data_retention_support
              (fun f ->
                 Ezxmlm.make_tag "dataRetentionSupport"
                   ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.data_retention_support
              (fun f -> ("data_retention_support", (Boolean.to_json f)));
           Util.option_map v.public
             (fun f -> ("public", (Boolean.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Util.option_map v.owner_alias
             (fun f -> ("owner_alias", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.update_time
             (fun f -> ("update_time", (DateTime.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (FpgaImageState.to_json f)));
           Util.option_map v.pci_id (fun f -> ("pci_id", (PciId.to_json f)));
           Util.option_map v.shell_version
             (fun f -> ("shell_version", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.fpga_image_global_id
             (fun f -> ("fpga_image_global_id", (String.to_json f)));
           Util.option_map v.fpga_image_id
             (fun f -> ("fpga_image_id", (String.to_json f)))])
    let of_json j =
      {
        fpga_image_id =
          (Util.option_map (Json.lookup j "fpga_image_id") String.of_json);
        fpga_image_global_id =
          (Util.option_map (Json.lookup j "fpga_image_global_id")
             String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        shell_version =
          (Util.option_map (Json.lookup j "shell_version") String.of_json);
        pci_id = (Util.option_map (Json.lookup j "pci_id") PciId.of_json);
        state =
          (Util.option_map (Json.lookup j "state") FpgaImageState.of_json);
        create_time =
          (Util.option_map (Json.lookup j "create_time") DateTime.of_json);
        update_time =
          (Util.option_map (Json.lookup j "update_time") DateTime.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        owner_alias =
          (Util.option_map (Json.lookup j "owner_alias") String.of_json);
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        public = (Util.option_map (Json.lookup j "public") Boolean.of_json);
        data_retention_support =
          (Util.option_map (Json.lookup j "data_retention_support")
             Boolean.of_json)
      }
  end
module EnableFastSnapshotRestoreErrorItem =
  struct
    type t =
      {
      snapshot_id: String.t option ;
      fast_snapshot_restore_state_errors:
        EnableFastSnapshotRestoreStateErrorSet.t }
    let make ?snapshot_id  ?(fast_snapshot_restore_state_errors= [])  () =
      { snapshot_id; fast_snapshot_restore_state_errors }
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          fast_snapshot_restore_state_errors =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "fastSnapshotRestoreStateErrorSet" xml)
                  EnableFastSnapshotRestoreStateErrorSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FastSnapshotRestoreStateErrorSet",
                   (EnableFastSnapshotRestoreStateErrorSet.to_query
                      v.fast_snapshot_restore_state_errors)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.snapshot_id
               (fun f -> Ezxmlm.make_tag "snapshotId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "fastSnapshotRestoreStateErrorSet"
                      ([],
                        (EnableFastSnapshotRestoreStateErrorSet.to_xml [x]))))
              v.fast_snapshot_restore_state_errors))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("fast_snapshot_restore_state_errors",
                (EnableFastSnapshotRestoreStateErrorSet.to_json
                   v.fast_snapshot_restore_state_errors));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let of_json j =
      {
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        fast_snapshot_restore_state_errors =
          (EnableFastSnapshotRestoreStateErrorSet.of_json
             (Util.of_option_exn
                (Json.lookup j "fast_snapshot_restore_state_errors")))
      }
  end
module EnableFastSnapshotRestoreSuccessItem =
  struct
    type t =
      {
      snapshot_id: String.t option ;
      availability_zone: String.t option ;
      state: FastSnapshotRestoreStateCode.t option ;
      state_transition_reason: String.t option ;
      owner_id: String.t option ;
      owner_alias: String.t option ;
      enabling_time: DateTime.t option ;
      optimizing_time: DateTime.t option ;
      enabled_time: DateTime.t option ;
      disabling_time: DateTime.t option ;
      disabled_time: DateTime.t option }
    let make ?snapshot_id  ?availability_zone  ?state 
      ?state_transition_reason  ?owner_id  ?owner_alias  ?enabling_time 
      ?optimizing_time  ?enabled_time  ?disabling_time  ?disabled_time  () =
      {
        snapshot_id;
        availability_zone;
        state;
        state_transition_reason;
        owner_id;
        owner_alias;
        enabling_time;
        optimizing_time;
        enabled_time;
        disabling_time;
        disabled_time
      }
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               FastSnapshotRestoreStateCode.parse);
          state_transition_reason =
            (Util.option_bind (Xml.member "stateTransitionReason" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          owner_alias =
            (Util.option_bind (Xml.member "ownerAlias" xml) String.parse);
          enabling_time =
            (Util.option_bind (Xml.member "enablingTime" xml) DateTime.parse);
          optimizing_time =
            (Util.option_bind (Xml.member "optimizingTime" xml)
               DateTime.parse);
          enabled_time =
            (Util.option_bind (Xml.member "enabledTime" xml) DateTime.parse);
          disabling_time =
            (Util.option_bind (Xml.member "disablingTime" xml) DateTime.parse);
          disabled_time =
            (Util.option_bind (Xml.member "disabledTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> Query.Pair ("DisabledTime", (DateTime.to_query f)));
           Util.option_map v.disabling_time
             (fun f -> Query.Pair ("DisablingTime", (DateTime.to_query f)));
           Util.option_map v.enabled_time
             (fun f -> Query.Pair ("EnabledTime", (DateTime.to_query f)));
           Util.option_map v.optimizing_time
             (fun f -> Query.Pair ("OptimizingTime", (DateTime.to_query f)));
           Util.option_map v.enabling_time
             (fun f -> Query.Pair ("EnablingTime", (DateTime.to_query f)));
           Util.option_map v.owner_alias
             (fun f -> Query.Pair ("OwnerAlias", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.state_transition_reason
             (fun f ->
                Query.Pair ("StateTransitionReason", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (FastSnapshotRestoreStateCode.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.snapshot_id
                        (fun f ->
                           Ezxmlm.make_tag "snapshotId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.availability_zone
                       (fun f ->
                          Ezxmlm.make_tag "availabilityZone"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.state
                      (fun f ->
                         Ezxmlm.make_tag "state"
                           ([], (FastSnapshotRestoreStateCode.to_xml f)))])
                  @
                  [Util.option_map v.state_transition_reason
                     (fun f ->
                        Ezxmlm.make_tag "stateTransitionReason"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.owner_id
                    (fun f ->
                       Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.owner_alias
                   (fun f ->
                      Ezxmlm.make_tag "ownerAlias" ([], (String.to_xml f)))])
               @
               [Util.option_map v.enabling_time
                  (fun f ->
                     Ezxmlm.make_tag "enablingTime" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.optimizing_time
                 (fun f ->
                    Ezxmlm.make_tag "optimizingTime"
                      ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.enabled_time
                (fun f ->
                   Ezxmlm.make_tag "enabledTime" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.disabling_time
               (fun f ->
                  Ezxmlm.make_tag "disablingTime" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.disabled_time
              (fun f ->
                 Ezxmlm.make_tag "disabledTime" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> ("disabled_time", (DateTime.to_json f)));
           Util.option_map v.disabling_time
             (fun f -> ("disabling_time", (DateTime.to_json f)));
           Util.option_map v.enabled_time
             (fun f -> ("enabled_time", (DateTime.to_json f)));
           Util.option_map v.optimizing_time
             (fun f -> ("optimizing_time", (DateTime.to_json f)));
           Util.option_map v.enabling_time
             (fun f -> ("enabling_time", (DateTime.to_json f)));
           Util.option_map v.owner_alias
             (fun f -> ("owner_alias", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.state_transition_reason
             (fun f -> ("state_transition_reason", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (FastSnapshotRestoreStateCode.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let of_json j =
      {
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             FastSnapshotRestoreStateCode.of_json);
        state_transition_reason =
          (Util.option_map (Json.lookup j "state_transition_reason")
             String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        owner_alias =
          (Util.option_map (Json.lookup j "owner_alias") String.of_json);
        enabling_time =
          (Util.option_map (Json.lookup j "enabling_time") DateTime.of_json);
        optimizing_time =
          (Util.option_map (Json.lookup j "optimizing_time") DateTime.of_json);
        enabled_time =
          (Util.option_map (Json.lookup j "enabled_time") DateTime.of_json);
        disabling_time =
          (Util.option_map (Json.lookup j "disabling_time") DateTime.of_json);
        disabled_time =
          (Util.option_map (Json.lookup j "disabled_time") DateTime.of_json)
      }
  end
module RouteTable =
  struct
    type t =
      {
      associations: RouteTableAssociationList.t ;
      propagating_vgws: PropagatingVgwList.t ;
      route_table_id: String.t option ;
      routes: RouteList.t ;
      tags: TagList.t ;
      vpc_id: String.t option ;
      owner_id: String.t option }
    let make ?(associations= [])  ?(propagating_vgws= [])  ?route_table_id 
      ?(routes= [])  ?(tags= [])  ?vpc_id  ?owner_id  () =
      {
        associations;
        propagating_vgws;
        route_table_id;
        routes;
        tags;
        vpc_id;
        owner_id
      }
    let parse xml =
      Some
        {
          associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "associationSet" xml)
                  RouteTableAssociationList.parse));
          propagating_vgws =
            (Util.of_option []
               (Util.option_bind (Xml.member "propagatingVgwSet" xml)
                  PropagatingVgwList.parse));
          route_table_id =
            (Util.option_bind (Xml.member "routeTableId" xml) String.parse);
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeSet" xml) RouteList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some (Query.Pair ("RouteSet", (RouteList.to_query v.routes)));
           Util.option_map v.route_table_id
             (fun f -> Query.Pair ("RouteTableId", (String.to_query f)));
           Some
             (Query.Pair
                ("PropagatingVgwSet",
                  (PropagatingVgwList.to_query v.propagating_vgws)));
           Some
             (Query.Pair
                ("AssociationSet",
                  (RouteTableAssociationList.to_query v.associations)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "associationSet"
                            ([], (RouteTableAssociationList.to_xml [x]))))
                    v.associations))
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "propagatingVgwSet"
                           ([], (PropagatingVgwList.to_xml [x]))))
                   v.propagating_vgws))
               @
               [Util.option_map v.route_table_id
                  (fun f ->
                     Ezxmlm.make_tag "routeTableId" ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "routeSet"
                         ([], (RouteList.to_xml [x])))) v.routes))
             @
             (List.map
                (fun x ->
                   Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
                v.tags))
            @
            [Util.option_map v.vpc_id
               (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.owner_id
              (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Some ("routes", (RouteList.to_json v.routes));
           Util.option_map v.route_table_id
             (fun f -> ("route_table_id", (String.to_json f)));
           Some
             ("propagating_vgws",
               (PropagatingVgwList.to_json v.propagating_vgws));
           Some
             ("associations",
               (RouteTableAssociationList.to_json v.associations))])
    let of_json j =
      {
        associations =
          (RouteTableAssociationList.of_json
             (Util.of_option_exn (Json.lookup j "associations")));
        propagating_vgws =
          (PropagatingVgwList.of_json
             (Util.of_option_exn (Json.lookup j "propagating_vgws")));
        route_table_id =
          (Util.option_map (Json.lookup j "route_table_id") String.of_json);
        routes =
          (RouteList.of_json (Util.of_option_exn (Json.lookup j "routes")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json)
      }
  end
module IamInstanceProfileAssociation =
  struct
    type t =
      {
      association_id: String.t option ;
      instance_id: String.t option ;
      iam_instance_profile: IamInstanceProfile.t option ;
      state: IamInstanceProfileAssociationState.t option ;
      timestamp: DateTime.t option }
    let make ?association_id  ?instance_id  ?iam_instance_profile  ?state 
      ?timestamp  () =
      { association_id; instance_id; iam_instance_profile; state; timestamp }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfile.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               IamInstanceProfileAssociationState.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (IamInstanceProfileAssociationState.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile", (IamInstanceProfile.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.association_id
                  (fun f ->
                     Ezxmlm.make_tag "associationId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.instance_id
                 (fun f ->
                    Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.iam_instance_profile
                (fun f ->
                   Ezxmlm.make_tag "iamInstanceProfile"
                     ([], (IamInstanceProfile.to_xml f)))])
            @
            [Util.option_map v.state
               (fun f ->
                  Ezxmlm.make_tag "state"
                    ([], (IamInstanceProfileAssociationState.to_xml f)))])
           @
           [Util.option_map v.timestamp
              (fun f -> Ezxmlm.make_tag "timestamp" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f ->
                ("state", (IamInstanceProfileAssociationState.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile", (IamInstanceProfile.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfile.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             IamInstanceProfileAssociationState.of_json);
        timestamp =
          (Util.option_map (Json.lookup j "timestamp") DateTime.of_json)
      }
  end
module LaunchTemplateVersion =
  struct
    type t =
      {
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      version_number: Long.t option ;
      version_description: String.t option ;
      create_time: DateTime.t option ;
      created_by: String.t option ;
      default_version: Boolean.t option ;
      launch_template_data: ResponseLaunchTemplateData.t option }
    let make ?launch_template_id  ?launch_template_name  ?version_number 
      ?version_description  ?create_time  ?created_by  ?default_version 
      ?launch_template_data  () =
      {
        launch_template_id;
        launch_template_name;
        version_number;
        version_description;
        create_time;
        created_by;
        default_version;
        launch_template_data
      }
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "launchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "launchTemplateName" xml)
               String.parse);
          version_number =
            (Util.option_bind (Xml.member "versionNumber" xml) Long.parse);
          version_description =
            (Util.option_bind (Xml.member "versionDescription" xml)
               String.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          created_by =
            (Util.option_bind (Xml.member "createdBy" xml) String.parse);
          default_version =
            (Util.option_bind (Xml.member "defaultVersion" xml) Boolean.parse);
          launch_template_data =
            (Util.option_bind (Xml.member "launchTemplateData" xml)
               ResponseLaunchTemplateData.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template_data
              (fun f ->
                 Query.Pair
                   ("LaunchTemplateData",
                     (ResponseLaunchTemplateData.to_query f)));
           Util.option_map v.default_version
             (fun f -> Query.Pair ("DefaultVersion", (Boolean.to_query f)));
           Util.option_map v.created_by
             (fun f -> Query.Pair ("CreatedBy", (String.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.version_description
             (fun f -> Query.Pair ("VersionDescription", (String.to_query f)));
           Util.option_map v.version_number
             (fun f -> Query.Pair ("VersionNumber", (Long.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.launch_template_id
                     (fun f ->
                        Ezxmlm.make_tag "launchTemplateId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.launch_template_name
                    (fun f ->
                       Ezxmlm.make_tag "launchTemplateName"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.version_number
                   (fun f ->
                      Ezxmlm.make_tag "versionNumber" ([], (Long.to_xml f)))])
               @
               [Util.option_map v.version_description
                  (fun f ->
                     Ezxmlm.make_tag "versionDescription"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.create_time
                 (fun f ->
                    Ezxmlm.make_tag "createTime" ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.created_by
                (fun f -> Ezxmlm.make_tag "createdBy" ([], (String.to_xml f)))])
            @
            [Util.option_map v.default_version
               (fun f ->
                  Ezxmlm.make_tag "defaultVersion" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.launch_template_data
              (fun f ->
                 Ezxmlm.make_tag "launchTemplateData"
                   ([], (ResponseLaunchTemplateData.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template_data
              (fun f ->
                 ("launch_template_data",
                   (ResponseLaunchTemplateData.to_json f)));
           Util.option_map v.default_version
             (fun f -> ("default_version", (Boolean.to_json f)));
           Util.option_map v.created_by
             (fun f -> ("created_by", (String.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.version_description
             (fun f -> ("version_description", (String.to_json f)));
           Util.option_map v.version_number
             (fun f -> ("version_number", (Long.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let of_json j =
      {
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        version_number =
          (Util.option_map (Json.lookup j "version_number") Long.of_json);
        version_description =
          (Util.option_map (Json.lookup j "version_description")
             String.of_json);
        create_time =
          (Util.option_map (Json.lookup j "create_time") DateTime.of_json);
        created_by =
          (Util.option_map (Json.lookup j "created_by") String.of_json);
        default_version =
          (Util.option_map (Json.lookup j "default_version") Boolean.of_json);
        launch_template_data =
          (Util.option_map (Json.lookup j "launch_template_data")
             ResponseLaunchTemplateData.of_json)
      }
  end
module TransitGatewayMulticastGroup =
  struct
    type t =
      {
      group_ip_address: String.t option ;
      transit_gateway_attachment_id: String.t option ;
      subnet_id: String.t option ;
      resource_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      network_interface_id: String.t option ;
      group_member: Boolean.t option ;
      group_source: Boolean.t option ;
      member_type: MembershipType.t option ;
      source_type: MembershipType.t option }
    let make ?group_ip_address  ?transit_gateway_attachment_id  ?subnet_id 
      ?resource_id  ?resource_type  ?network_interface_id  ?group_member 
      ?group_source  ?member_type  ?source_type  () =
      {
        group_ip_address;
        transit_gateway_attachment_id;
        subnet_id;
        resource_id;
        resource_type;
        network_interface_id;
        group_member;
        group_source;
        member_type;
        source_type
      }
    let parse xml =
      Some
        {
          group_ip_address =
            (Util.option_bind (Xml.member "groupIpAddress" xml) String.parse);
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          group_member =
            (Util.option_bind (Xml.member "groupMember" xml) Boolean.parse);
          group_source =
            (Util.option_bind (Xml.member "groupSource" xml) Boolean.parse);
          member_type =
            (Util.option_bind (Xml.member "memberType" xml)
               MembershipType.parse);
          source_type =
            (Util.option_bind (Xml.member "sourceType" xml)
               MembershipType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.source_type
              (fun f ->
                 Query.Pair ("SourceType", (MembershipType.to_query f)));
           Util.option_map v.member_type
             (fun f -> Query.Pair ("MemberType", (MembershipType.to_query f)));
           Util.option_map v.group_source
             (fun f -> Query.Pair ("GroupSource", (Boolean.to_query f)));
           Util.option_map v.group_member
             (fun f -> Query.Pair ("GroupMember", (Boolean.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Util.option_map v.group_ip_address
             (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.group_ip_address
                       (fun f ->
                          Ezxmlm.make_tag "groupIpAddress"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.transit_gateway_attachment_id
                      (fun f ->
                         Ezxmlm.make_tag "transitGatewayAttachmentId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.subnet_id
                     (fun f ->
                        Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.resource_id
                    (fun f ->
                       Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.resource_type
                   (fun f ->
                      Ezxmlm.make_tag "resourceType"
                        ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
               @
               [Util.option_map v.network_interface_id
                  (fun f ->
                     Ezxmlm.make_tag "networkInterfaceId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.group_member
                 (fun f ->
                    Ezxmlm.make_tag "groupMember" ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.group_source
                (fun f ->
                   Ezxmlm.make_tag "groupSource" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.member_type
               (fun f ->
                  Ezxmlm.make_tag "memberType"
                    ([], (MembershipType.to_xml f)))])
           @
           [Util.option_map v.source_type
              (fun f ->
                 Ezxmlm.make_tag "sourceType" ([], (MembershipType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.source_type
              (fun f -> ("source_type", (MembershipType.to_json f)));
           Util.option_map v.member_type
             (fun f -> ("member_type", (MembershipType.to_json f)));
           Util.option_map v.group_source
             (fun f -> ("group_source", (Boolean.to_json f)));
           Util.option_map v.group_member
             (fun f -> ("group_member", (Boolean.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Util.option_map v.group_ip_address
             (fun f -> ("group_ip_address", (String.to_json f)))])
    let of_json j =
      {
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json);
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        group_member =
          (Util.option_map (Json.lookup j "group_member") Boolean.of_json);
        group_source =
          (Util.option_map (Json.lookup j "group_source") Boolean.of_json);
        member_type =
          (Util.option_map (Json.lookup j "member_type")
             MembershipType.of_json);
        source_type =
          (Util.option_map (Json.lookup j "source_type")
             MembershipType.of_json)
      }
  end
module LocalGatewayVirtualInterface =
  struct
    type t =
      {
      local_gateway_virtual_interface_id: String.t option ;
      local_gateway_id: String.t option ;
      vlan: Integer.t option ;
      local_address: String.t option ;
      peer_address: String.t option ;
      local_bgp_asn: Integer.t option ;
      peer_bgp_asn: Integer.t option }
    let make ?local_gateway_virtual_interface_id  ?local_gateway_id  ?vlan 
      ?local_address  ?peer_address  ?local_bgp_asn  ?peer_bgp_asn  () =
      {
        local_gateway_virtual_interface_id;
        local_gateway_id;
        vlan;
        local_address;
        peer_address;
        local_bgp_asn;
        peer_bgp_asn
      }
    let parse xml =
      Some
        {
          local_gateway_virtual_interface_id =
            (Util.option_bind
               (Xml.member "localGatewayVirtualInterfaceId" xml) String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          vlan = (Util.option_bind (Xml.member "vlan" xml) Integer.parse);
          local_address =
            (Util.option_bind (Xml.member "localAddress" xml) String.parse);
          peer_address =
            (Util.option_bind (Xml.member "peerAddress" xml) String.parse);
          local_bgp_asn =
            (Util.option_bind (Xml.member "localBgpAsn" xml) Integer.parse);
          peer_bgp_asn =
            (Util.option_bind (Xml.member "peerBgpAsn" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.peer_bgp_asn
              (fun f -> Query.Pair ("PeerBgpAsn", (Integer.to_query f)));
           Util.option_map v.local_bgp_asn
             (fun f -> Query.Pair ("LocalBgpAsn", (Integer.to_query f)));
           Util.option_map v.peer_address
             (fun f -> Query.Pair ("PeerAddress", (String.to_query f)));
           Util.option_map v.local_address
             (fun f -> Query.Pair ("LocalAddress", (String.to_query f)));
           Util.option_map v.vlan
             (fun f -> Query.Pair ("Vlan", (Integer.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.local_gateway_virtual_interface_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayVirtualInterfaceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.local_gateway_virtual_interface_id
                    (fun f ->
                       Ezxmlm.make_tag "localGatewayVirtualInterfaceId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.local_gateway_id
                   (fun f ->
                      Ezxmlm.make_tag "localGatewayId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.vlan
                  (fun f -> Ezxmlm.make_tag "vlan" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.local_address
                 (fun f ->
                    Ezxmlm.make_tag "localAddress" ([], (String.to_xml f)))])
             @
             [Util.option_map v.peer_address
                (fun f ->
                   Ezxmlm.make_tag "peerAddress" ([], (String.to_xml f)))])
            @
            [Util.option_map v.local_bgp_asn
               (fun f ->
                  Ezxmlm.make_tag "localBgpAsn" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.peer_bgp_asn
              (fun f -> Ezxmlm.make_tag "peerBgpAsn" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.peer_bgp_asn
              (fun f -> ("peer_bgp_asn", (Integer.to_json f)));
           Util.option_map v.local_bgp_asn
             (fun f -> ("local_bgp_asn", (Integer.to_json f)));
           Util.option_map v.peer_address
             (fun f -> ("peer_address", (String.to_json f)));
           Util.option_map v.local_address
             (fun f -> ("local_address", (String.to_json f)));
           Util.option_map v.vlan (fun f -> ("vlan", (Integer.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.local_gateway_virtual_interface_id
             (fun f ->
                ("local_gateway_virtual_interface_id", (String.to_json f)))])
    let of_json j =
      {
        local_gateway_virtual_interface_id =
          (Util.option_map
             (Json.lookup j "local_gateway_virtual_interface_id")
             String.of_json);
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        vlan = (Util.option_map (Json.lookup j "vlan") Integer.of_json);
        local_address =
          (Util.option_map (Json.lookup j "local_address") String.of_json);
        peer_address =
          (Util.option_map (Json.lookup j "peer_address") String.of_json);
        local_bgp_asn =
          (Util.option_map (Json.lookup j "local_bgp_asn") Integer.of_json);
        peer_bgp_asn =
          (Util.option_map (Json.lookup j "peer_bgp_asn") Integer.of_json)
      }
  end
module ElasticInferenceAccelerator =
  struct
    type t = {
      type_: String.t ;
      count: Integer.t option }
    let make ~type_  ?count  () = { type_; count }
    let parse xml =
      Some
        {
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) String.parse));
          count = (Util.option_bind (Xml.member "Count" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.count
              (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Some (Query.Pair ("Type", (String.to_query v.type_)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Type" ([], (String.to_xml v.type_)))])
           @
           [Util.option_map v.count
              (fun f -> Ezxmlm.make_tag "Count" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Some ("type_", (String.to_json v.type_))])
    let of_json j =
      {
        type_ = (String.of_json (Util.of_option_exn (Json.lookup j "type_")));
        count = (Util.option_map (Json.lookup j "count") Integer.of_json)
      }
  end
module SpotMarketOptions =
  struct
    type t =
      {
      max_price: String.t option ;
      spot_instance_type: SpotInstanceType.t option ;
      block_duration_minutes: Integer.t option ;
      valid_until: DateTime.t option ;
      instance_interruption_behavior: InstanceInterruptionBehavior.t option }
    let make ?max_price  ?spot_instance_type  ?block_duration_minutes 
      ?valid_until  ?instance_interruption_behavior  () =
      {
        max_price;
        spot_instance_type;
        block_duration_minutes;
        valid_until;
        instance_interruption_behavior
      }
    let parse xml =
      Some
        {
          max_price =
            (Util.option_bind (Xml.member "MaxPrice" xml) String.parse);
          spot_instance_type =
            (Util.option_bind (Xml.member "SpotInstanceType" xml)
               SpotInstanceType.parse);
          block_duration_minutes =
            (Util.option_bind (Xml.member "BlockDurationMinutes" xml)
               Integer.parse);
          valid_until =
            (Util.option_bind (Xml.member "ValidUntil" xml) DateTime.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "InstanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Query.Pair
                   ("InstanceInterruptionBehavior",
                     (InstanceInterruptionBehavior.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.block_duration_minutes
             (fun f ->
                Query.Pair ("BlockDurationMinutes", (Integer.to_query f)));
           Util.option_map v.spot_instance_type
             (fun f ->
                Query.Pair
                  ("SpotInstanceType", (SpotInstanceType.to_query f)));
           Util.option_map v.max_price
             (fun f -> Query.Pair ("MaxPrice", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.max_price
                  (fun f ->
                     Ezxmlm.make_tag "MaxPrice" ([], (String.to_xml f)))])
              @
              [Util.option_map v.spot_instance_type
                 (fun f ->
                    Ezxmlm.make_tag "SpotInstanceType"
                      ([], (SpotInstanceType.to_xml f)))])
             @
             [Util.option_map v.block_duration_minutes
                (fun f ->
                   Ezxmlm.make_tag "BlockDurationMinutes"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.valid_until
               (fun f ->
                  Ezxmlm.make_tag "ValidUntil" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Ezxmlm.make_tag "InstanceInterruptionBehavior"
                   ([], (InstanceInterruptionBehavior.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 ("instance_interruption_behavior",
                   (InstanceInterruptionBehavior.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.block_duration_minutes
             (fun f -> ("block_duration_minutes", (Integer.to_json f)));
           Util.option_map v.spot_instance_type
             (fun f -> ("spot_instance_type", (SpotInstanceType.to_json f)));
           Util.option_map v.max_price
             (fun f -> ("max_price", (String.to_json f)))])
    let of_json j =
      {
        max_price =
          (Util.option_map (Json.lookup j "max_price") String.of_json);
        spot_instance_type =
          (Util.option_map (Json.lookup j "spot_instance_type")
             SpotInstanceType.of_json);
        block_duration_minutes =
          (Util.option_map (Json.lookup j "block_duration_minutes")
             Integer.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        instance_interruption_behavior =
          (Util.option_map (Json.lookup j "instance_interruption_behavior")
             InstanceInterruptionBehavior.of_json)
      }
  end
module LicenseConfigurationRequest =
  struct
    type t = {
      license_configuration_arn: String.t option }
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "LicenseConfigurationArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Ezxmlm.make_tag "LicenseConfigurationArn"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let of_json j =
      {
        license_configuration_arn =
          (Util.option_map (Json.lookup j "license_configuration_arn")
             String.of_json)
      }
  end
module LocalGatewayVirtualInterfaceGroup =
  struct
    type t =
      {
      local_gateway_virtual_interface_group_id: String.t option ;
      local_gateway_virtual_interface_ids:
        LocalGatewayVirtualInterfaceIdSet.t ;
      local_gateway_id: String.t option }
    let make ?local_gateway_virtual_interface_group_id 
      ?(local_gateway_virtual_interface_ids= [])  ?local_gateway_id  () =
      {
        local_gateway_virtual_interface_group_id;
        local_gateway_virtual_interface_ids;
        local_gateway_id
      }
    let parse xml =
      Some
        {
          local_gateway_virtual_interface_group_id =
            (Util.option_bind
               (Xml.member "localGatewayVirtualInterfaceGroupId" xml)
               String.parse);
          local_gateway_virtual_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "localGatewayVirtualInterfaceIdSet" xml)
                  LocalGatewayVirtualInterfaceIdSet.parse));
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_id
              (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayVirtualInterfaceIdSet",
                  (LocalGatewayVirtualInterfaceIdSet.to_query
                     v.local_gateway_virtual_interface_ids)));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayVirtualInterfaceGroupId",
                    (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.local_gateway_virtual_interface_group_id
                (fun f ->
                   Ezxmlm.make_tag "localGatewayVirtualInterfaceGroupId"
                     ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "localGatewayVirtualInterfaceIdSet"
                       ([], (LocalGatewayVirtualInterfaceIdSet.to_xml [x]))))
               v.local_gateway_virtual_interface_ids))
           @
           [Util.option_map v.local_gateway_id
              (fun f ->
                 Ezxmlm.make_tag "localGatewayId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_id
              (fun f -> ("local_gateway_id", (String.to_json f)));
           Some
             ("local_gateway_virtual_interface_ids",
               (LocalGatewayVirtualInterfaceIdSet.to_json
                  v.local_gateway_virtual_interface_ids));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                ("local_gateway_virtual_interface_group_id",
                  (String.to_json f)))])
    let of_json j =
      {
        local_gateway_virtual_interface_group_id =
          (Util.option_map
             (Json.lookup j "local_gateway_virtual_interface_group_id")
             String.of_json);
        local_gateway_virtual_interface_ids =
          (LocalGatewayVirtualInterfaceIdSet.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_virtual_interface_ids")));
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json)
      }
  end
module MovingAddressStatus =
  struct
    type t = {
      move_status: MoveStatus.t option ;
      public_ip: String.t option }
    let make ?move_status  ?public_ip  () = { move_status; public_ip }
    let parse xml =
      Some
        {
          move_status =
            (Util.option_bind (Xml.member "moveStatus" xml) MoveStatus.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.move_status
             (fun f -> Query.Pair ("MoveStatus", (MoveStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.move_status
               (fun f ->
                  Ezxmlm.make_tag "moveStatus" ([], (MoveStatus.to_xml f)))])
           @
           [Util.option_map v.public_ip
              (fun f -> Ezxmlm.make_tag "publicIp" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.move_status
             (fun f -> ("move_status", (MoveStatus.to_json f)))])
    let of_json j =
      {
        move_status =
          (Util.option_map (Json.lookup j "move_status") MoveStatus.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json)
      }
  end
module CreditSpecificationRequest =
  struct
    type t = {
      cpu_credits: String.t }
    let make ~cpu_credits  () = { cpu_credits }
    let parse xml =
      Some
        {
          cpu_credits =
            (Xml.required "CpuCredits"
               (Util.option_bind (Xml.member "CpuCredits" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("CpuCredits", (String.to_query v.cpu_credits)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "CpuCredits"
                 ([], (String.to_xml v.cpu_credits)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("cpu_credits", (String.to_json v.cpu_credits))])
    let of_json j =
      {
        cpu_credits =
          (String.of_json (Util.of_option_exn (Json.lookup j "cpu_credits")))
      }
  end
module ElasticGpuSpecificationList =
  struct
    type t = ElasticGpuSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ElasticGpuSpecification.parse
           (Xml.members "ElasticGpuSpecification" xml))
    let to_query v = Query.to_query_list ElasticGpuSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list ElasticGpuSpecification.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ElasticGpuSpecification.to_xml x)))
        v
    let to_json v = `List (List.map ElasticGpuSpecification.to_json v)
    let of_json j = Json.to_list ElasticGpuSpecification.of_json j
  end
module LaunchTemplateBlockDeviceMappingRequestList =
  struct
    type t = LaunchTemplateBlockDeviceMappingRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateBlockDeviceMappingRequest.parse
           (Xml.members "BlockDeviceMapping" xml))
    let to_query v =
      Query.to_query_list LaunchTemplateBlockDeviceMappingRequest.to_query v
    let to_headers v =
      Headers.to_headers_list
        LaunchTemplateBlockDeviceMappingRequest.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LaunchTemplateBlockDeviceMappingRequest.to_xml x))) v
    let to_json v =
      `List (List.map LaunchTemplateBlockDeviceMappingRequest.to_json v)
    let of_json j =
      Json.to_list LaunchTemplateBlockDeviceMappingRequest.of_json j
  end
module LaunchTemplateCapacityReservationSpecificationRequest =
  struct
    type t =
      {
      capacity_reservation_preference: CapacityReservationPreference.t option ;
      capacity_reservation_target: CapacityReservationTarget.t option }
    let make ?capacity_reservation_preference  ?capacity_reservation_target 
      () = { capacity_reservation_preference; capacity_reservation_target }
    let parse xml =
      Some
        {
          capacity_reservation_preference =
            (Util.option_bind
               (Xml.member "CapacityReservationPreference" xml)
               CapacityReservationPreference.parse);
          capacity_reservation_target =
            (Util.option_bind (Xml.member "CapacityReservationTarget" xml)
               CapacityReservationTarget.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Query.Pair
                   ("CapacityReservationTarget",
                     (CapacityReservationTarget.to_query f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                Query.Pair
                  ("CapacityReservationPreference",
                    (CapacityReservationPreference.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.capacity_reservation_preference
               (fun f ->
                  Ezxmlm.make_tag "CapacityReservationPreference"
                    ([], (CapacityReservationPreference.to_xml f)))])
           @
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Ezxmlm.make_tag "CapacityReservationTarget"
                   ([], (CapacityReservationTarget.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 ("capacity_reservation_target",
                   (CapacityReservationTarget.to_json f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                ("capacity_reservation_preference",
                  (CapacityReservationPreference.to_json f)))])
    let of_json j =
      {
        capacity_reservation_preference =
          (Util.option_map (Json.lookup j "capacity_reservation_preference")
             CapacityReservationPreference.of_json);
        capacity_reservation_target =
          (Util.option_map (Json.lookup j "capacity_reservation_target")
             CapacityReservationTarget.of_json)
      }
  end
module LaunchTemplateCpuOptionsRequest =
  struct
    type t =
      {
      core_count: Integer.t option ;
      threads_per_core: Integer.t option }
    let make ?core_count  ?threads_per_core  () =
      { core_count; threads_per_core }
    let parse xml =
      Some
        {
          core_count =
            (Util.option_bind (Xml.member "CoreCount" xml) Integer.parse);
          threads_per_core =
            (Util.option_bind (Xml.member "ThreadsPerCore" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> Query.Pair ("ThreadsPerCore", (Integer.to_query f)));
           Util.option_map v.core_count
             (fun f -> Query.Pair ("CoreCount", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.core_count
               (fun f -> Ezxmlm.make_tag "CoreCount" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.threads_per_core
              (fun f ->
                 Ezxmlm.make_tag "ThreadsPerCore" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> ("threads_per_core", (Integer.to_json f)));
           Util.option_map v.core_count
             (fun f -> ("core_count", (Integer.to_json f)))])
    let of_json j =
      {
        core_count =
          (Util.option_map (Json.lookup j "core_count") Integer.of_json);
        threads_per_core =
          (Util.option_map (Json.lookup j "threads_per_core") Integer.of_json)
      }
  end
module LaunchTemplateElasticInferenceAcceleratorList =
  struct
    type t = LaunchTemplateElasticInferenceAccelerator.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateElasticInferenceAccelerator.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LaunchTemplateElasticInferenceAccelerator.to_query
        v
    let to_headers v =
      Headers.to_headers_list
        LaunchTemplateElasticInferenceAccelerator.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LaunchTemplateElasticInferenceAccelerator.to_xml x))) v
    let to_json v =
      `List (List.map LaunchTemplateElasticInferenceAccelerator.to_json v)
    let of_json j =
      Json.to_list LaunchTemplateElasticInferenceAccelerator.of_json j
  end
module LaunchTemplateHibernationOptionsRequest =
  struct
    type t = {
      configured: Boolean.t option }
    let make ?configured  () = { configured }
    let parse xml =
      Some
        {
          configured =
            (Util.option_bind (Xml.member "Configured" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> Query.Pair ("Configured", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.configured
              (fun f -> Ezxmlm.make_tag "Configured" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> ("configured", (Boolean.to_json f)))])
    let of_json j =
      {
        configured =
          (Util.option_map (Json.lookup j "configured") Boolean.of_json)
      }
  end
module LaunchTemplateIamInstanceProfileSpecificationRequest =
  struct
    type t = {
      arn: String.t option ;
      name: String.t option }
    let make ?arn  ?name  () = { arn; name }
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "Arn" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.arn
               (fun f -> Ezxmlm.make_tag "Arn" ([], (String.to_xml f)))])
           @
           [Util.option_map v.name
              (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      {
        arn = (Util.option_map (Json.lookup j "arn") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json)
      }
  end
module LaunchTemplateInstanceMarketOptionsRequest =
  struct
    type t =
      {
      market_type: MarketType.t option ;
      spot_options: LaunchTemplateSpotMarketOptionsRequest.t option }
    let make ?market_type  ?spot_options  () = { market_type; spot_options }
    let parse xml =
      Some
        {
          market_type =
            (Util.option_bind (Xml.member "MarketType" xml) MarketType.parse);
          spot_options =
            (Util.option_bind (Xml.member "SpotOptions" xml)
               LaunchTemplateSpotMarketOptionsRequest.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f ->
                 Query.Pair
                   ("SpotOptions",
                     (LaunchTemplateSpotMarketOptionsRequest.to_query f)));
           Util.option_map v.market_type
             (fun f -> Query.Pair ("MarketType", (MarketType.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.market_type
               (fun f ->
                  Ezxmlm.make_tag "MarketType" ([], (MarketType.to_xml f)))])
           @
           [Util.option_map v.spot_options
              (fun f ->
                 Ezxmlm.make_tag "SpotOptions"
                   ([], (LaunchTemplateSpotMarketOptionsRequest.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f ->
                 ("spot_options",
                   (LaunchTemplateSpotMarketOptionsRequest.to_json f)));
           Util.option_map v.market_type
             (fun f -> ("market_type", (MarketType.to_json f)))])
    let of_json j =
      {
        market_type =
          (Util.option_map (Json.lookup j "market_type") MarketType.of_json);
        spot_options =
          (Util.option_map (Json.lookup j "spot_options")
             LaunchTemplateSpotMarketOptionsRequest.of_json)
      }
  end
module LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList =
  struct
    type t =
      LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map
           LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.parse
           (Xml.members "InstanceNetworkInterfaceSpecification" xml))
    let to_query v =
      Query.to_query_list
        LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.to_query v
    let to_headers v =
      Headers.to_headers_list
        LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.to_headers
        v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([],
               (LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.to_xml
                  x))) v
    let to_json v =
      `List
        (List.map
           LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.to_json
           v)
    let of_json j =
      Json.to_list
        LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.of_json j
  end
module LaunchTemplateLicenseSpecificationListRequest =
  struct
    type t = LaunchTemplateLicenseConfigurationRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateLicenseConfigurationRequest.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LaunchTemplateLicenseConfigurationRequest.to_query
        v
    let to_headers v =
      Headers.to_headers_list
        LaunchTemplateLicenseConfigurationRequest.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LaunchTemplateLicenseConfigurationRequest.to_xml x))) v
    let to_json v =
      `List (List.map LaunchTemplateLicenseConfigurationRequest.to_json v)
    let of_json j =
      Json.to_list LaunchTemplateLicenseConfigurationRequest.of_json j
  end
module LaunchTemplatePlacementRequest =
  struct
    type t =
      {
      availability_zone: String.t option ;
      affinity: String.t option ;
      group_name: String.t option ;
      host_id: String.t option ;
      tenancy: Tenancy.t option ;
      spread_domain: String.t option ;
      host_resource_group_arn: String.t option }
    let make ?availability_zone  ?affinity  ?group_name  ?host_id  ?tenancy 
      ?spread_domain  ?host_resource_group_arn  () =
      {
        availability_zone;
        affinity;
        group_name;
        host_id;
        tenancy;
        spread_domain;
        host_resource_group_arn
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          affinity =
            (Util.option_bind (Xml.member "Affinity" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          host_id = (Util.option_bind (Xml.member "HostId" xml) String.parse);
          tenancy =
            (Util.option_bind (Xml.member "Tenancy" xml) Tenancy.parse);
          spread_domain =
            (Util.option_bind (Xml.member "SpreadDomain" xml) String.parse);
          host_resource_group_arn =
            (Util.option_bind (Xml.member "HostResourceGroupArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f ->
                 Query.Pair ("HostResourceGroupArn", (String.to_query f)));
           Util.option_map v.spread_domain
             (fun f -> Query.Pair ("SpreadDomain", (String.to_query f)));
           Util.option_map v.tenancy
             (fun f -> Query.Pair ("Tenancy", (Tenancy.to_query f)));
           Util.option_map v.host_id
             (fun f -> Query.Pair ("HostId", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.affinity
             (fun f -> Query.Pair ("Affinity", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.availability_zone
                    (fun f ->
                       Ezxmlm.make_tag "AvailabilityZone"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.affinity
                   (fun f ->
                      Ezxmlm.make_tag "Affinity" ([], (String.to_xml f)))])
               @
               [Util.option_map v.group_name
                  (fun f ->
                     Ezxmlm.make_tag "GroupName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.host_id
                 (fun f -> Ezxmlm.make_tag "HostId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.tenancy
                (fun f -> Ezxmlm.make_tag "Tenancy" ([], (Tenancy.to_xml f)))])
            @
            [Util.option_map v.spread_domain
               (fun f ->
                  Ezxmlm.make_tag "SpreadDomain" ([], (String.to_xml f)))])
           @
           [Util.option_map v.host_resource_group_arn
              (fun f ->
                 Ezxmlm.make_tag "HostResourceGroupArn"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f -> ("host_resource_group_arn", (String.to_json f)));
           Util.option_map v.spread_domain
             (fun f -> ("spread_domain", (String.to_json f)));
           Util.option_map v.tenancy
             (fun f -> ("tenancy", (Tenancy.to_json f)));
           Util.option_map v.host_id
             (fun f -> ("host_id", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.affinity
             (fun f -> ("affinity", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        affinity =
          (Util.option_map (Json.lookup j "affinity") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        host_id = (Util.option_map (Json.lookup j "host_id") String.of_json);
        tenancy = (Util.option_map (Json.lookup j "tenancy") Tenancy.of_json);
        spread_domain =
          (Util.option_map (Json.lookup j "spread_domain") String.of_json);
        host_resource_group_arn =
          (Util.option_map (Json.lookup j "host_resource_group_arn")
             String.of_json)
      }
  end
module LaunchTemplateTagSpecificationRequestList =
  struct
    type t = LaunchTemplateTagSpecificationRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateTagSpecificationRequest.parse
           (Xml.members "LaunchTemplateTagSpecificationRequest" xml))
    let to_query v =
      Query.to_query_list LaunchTemplateTagSpecificationRequest.to_query v
    let to_headers v =
      Headers.to_headers_list
        LaunchTemplateTagSpecificationRequest.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LaunchTemplateTagSpecificationRequest.to_xml x))) v
    let to_json v =
      `List (List.map LaunchTemplateTagSpecificationRequest.to_json v)
    let of_json j =
      Json.to_list LaunchTemplateTagSpecificationRequest.of_json j
  end
module LaunchTemplatesMonitoringRequest =
  struct
    type t = {
      enabled: Boolean.t option }
    let make ?enabled  () = { enabled }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.enabled
              (fun f -> Ezxmlm.make_tag "Enabled" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      { enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json)
      }
  end
module TrafficMirrorSession =
  struct
    type t =
      {
      traffic_mirror_session_id: String.t option ;
      traffic_mirror_target_id: String.t option ;
      traffic_mirror_filter_id: String.t option ;
      network_interface_id: String.t option ;
      owner_id: String.t option ;
      packet_length: Integer.t option ;
      session_number: Integer.t option ;
      virtual_network_id: Integer.t option ;
      description: String.t option ;
      tags: TagList.t }
    let make ?traffic_mirror_session_id  ?traffic_mirror_target_id 
      ?traffic_mirror_filter_id  ?network_interface_id  ?owner_id 
      ?packet_length  ?session_number  ?virtual_network_id  ?description 
      ?(tags= [])  () =
      {
        traffic_mirror_session_id;
        traffic_mirror_target_id;
        traffic_mirror_filter_id;
        network_interface_id;
        owner_id;
        packet_length;
        session_number;
        virtual_network_id;
        description;
        tags
      }
    let parse xml =
      Some
        {
          traffic_mirror_session_id =
            (Util.option_bind (Xml.member "trafficMirrorSessionId" xml)
               String.parse);
          traffic_mirror_target_id =
            (Util.option_bind (Xml.member "trafficMirrorTargetId" xml)
               String.parse);
          traffic_mirror_filter_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterId" xml)
               String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          packet_length =
            (Util.option_bind (Xml.member "packetLength" xml) Integer.parse);
          session_number =
            (Util.option_bind (Xml.member "sessionNumber" xml) Integer.parse);
          virtual_network_id =
            (Util.option_bind (Xml.member "virtualNetworkId" xml)
               Integer.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.virtual_network_id
             (fun f -> Query.Pair ("VirtualNetworkId", (Integer.to_query f)));
           Util.option_map v.session_number
             (fun f -> Query.Pair ("SessionNumber", (Integer.to_query f)));
           Util.option_map v.packet_length
             (fun f -> Query.Pair ("PacketLength", (Integer.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f ->
                Query.Pair ("TrafficMirrorFilterId", (String.to_query f)));
           Util.option_map v.traffic_mirror_target_id
             (fun f ->
                Query.Pair ("TrafficMirrorTargetId", (String.to_query f)));
           Util.option_map v.traffic_mirror_session_id
             (fun f ->
                Query.Pair ("TrafficMirrorSessionId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.traffic_mirror_session_id
                       (fun f ->
                          Ezxmlm.make_tag "trafficMirrorSessionId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.traffic_mirror_target_id
                      (fun f ->
                         Ezxmlm.make_tag "trafficMirrorTargetId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.traffic_mirror_filter_id
                     (fun f ->
                        Ezxmlm.make_tag "trafficMirrorFilterId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.network_interface_id
                    (fun f ->
                       Ezxmlm.make_tag "networkInterfaceId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.owner_id
                   (fun f ->
                      Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.packet_length
                  (fun f ->
                     Ezxmlm.make_tag "packetLength" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.session_number
                 (fun f ->
                    Ezxmlm.make_tag "sessionNumber" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.virtual_network_id
                (fun f ->
                   Ezxmlm.make_tag "virtualNetworkId"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.description
               (fun f ->
                  Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.virtual_network_id
             (fun f -> ("virtual_network_id", (Integer.to_json f)));
           Util.option_map v.session_number
             (fun f -> ("session_number", (Integer.to_json f)));
           Util.option_map v.packet_length
             (fun f -> ("packet_length", (Integer.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f -> ("traffic_mirror_filter_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_target_id
             (fun f -> ("traffic_mirror_target_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_session_id
             (fun f -> ("traffic_mirror_session_id", (String.to_json f)))])
    let of_json j =
      {
        traffic_mirror_session_id =
          (Util.option_map (Json.lookup j "traffic_mirror_session_id")
             String.of_json);
        traffic_mirror_target_id =
          (Util.option_map (Json.lookup j "traffic_mirror_target_id")
             String.of_json);
        traffic_mirror_filter_id =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_id")
             String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        packet_length =
          (Util.option_map (Json.lookup j "packet_length") Integer.of_json);
        session_number =
          (Util.option_map (Json.lookup j "session_number") Integer.of_json);
        virtual_network_id =
          (Util.option_map (Json.lookup j "virtual_network_id")
             Integer.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module DeleteLaunchTemplateVersionsResponseErrorItem =
  struct
    type t =
      {
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      version_number: Long.t option ;
      response_error: ResponseError.t option }
    let make ?launch_template_id  ?launch_template_name  ?version_number 
      ?response_error  () =
      {
        launch_template_id;
        launch_template_name;
        version_number;
        response_error
      }
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "launchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "launchTemplateName" xml)
               String.parse);
          version_number =
            (Util.option_bind (Xml.member "versionNumber" xml) Long.parse);
          response_error =
            (Util.option_bind (Xml.member "responseError" xml)
               ResponseError.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.response_error
              (fun f ->
                 Query.Pair ("ResponseError", (ResponseError.to_query f)));
           Util.option_map v.version_number
             (fun f -> Query.Pair ("VersionNumber", (Long.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.launch_template_id
                 (fun f ->
                    Ezxmlm.make_tag "launchTemplateId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.launch_template_name
                (fun f ->
                   Ezxmlm.make_tag "launchTemplateName"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.version_number
               (fun f ->
                  Ezxmlm.make_tag "versionNumber" ([], (Long.to_xml f)))])
           @
           [Util.option_map v.response_error
              (fun f ->
                 Ezxmlm.make_tag "responseError"
                   ([], (ResponseError.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.response_error
              (fun f -> ("response_error", (ResponseError.to_json f)));
           Util.option_map v.version_number
             (fun f -> ("version_number", (Long.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let of_json j =
      {
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        version_number =
          (Util.option_map (Json.lookup j "version_number") Long.of_json);
        response_error =
          (Util.option_map (Json.lookup j "response_error")
             ResponseError.of_json)
      }
  end
module DeleteLaunchTemplateVersionsResponseSuccessItem =
  struct
    type t =
      {
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      version_number: Long.t option }
    let make ?launch_template_id  ?launch_template_name  ?version_number  ()
      = { launch_template_id; launch_template_name; version_number }
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "launchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "launchTemplateName" xml)
               String.parse);
          version_number =
            (Util.option_bind (Xml.member "versionNumber" xml) Long.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.version_number
              (fun f -> Query.Pair ("VersionNumber", (Long.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.launch_template_id
                (fun f ->
                   Ezxmlm.make_tag "launchTemplateId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.launch_template_name
               (fun f ->
                  Ezxmlm.make_tag "launchTemplateName"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.version_number
              (fun f -> Ezxmlm.make_tag "versionNumber" ([], (Long.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.version_number
              (fun f -> ("version_number", (Long.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let of_json j =
      {
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        version_number =
          (Util.option_map (Json.lookup j "version_number") Long.of_json)
      }
  end
module SpotInstanceRequest =
  struct
    type t =
      {
      actual_block_hourly_price: String.t option ;
      availability_zone_group: String.t option ;
      block_duration_minutes: Integer.t option ;
      create_time: DateTime.t option ;
      fault: SpotInstanceStateFault.t option ;
      instance_id: String.t option ;
      launch_group: String.t option ;
      launch_specification: LaunchSpecification.t option ;
      launched_availability_zone: String.t option ;
      product_description: RIProductDescription.t option ;
      spot_instance_request_id: String.t option ;
      spot_price: String.t option ;
      state: SpotInstanceState.t option ;
      status: SpotInstanceStatus.t option ;
      tags: TagList.t ;
      type_: SpotInstanceType.t option ;
      valid_from: DateTime.t option ;
      valid_until: DateTime.t option ;
      instance_interruption_behavior: InstanceInterruptionBehavior.t option }
    let make ?actual_block_hourly_price  ?availability_zone_group 
      ?block_duration_minutes  ?create_time  ?fault  ?instance_id 
      ?launch_group  ?launch_specification  ?launched_availability_zone 
      ?product_description  ?spot_instance_request_id  ?spot_price  ?state 
      ?status  ?(tags= [])  ?type_  ?valid_from  ?valid_until 
      ?instance_interruption_behavior  () =
      {
        actual_block_hourly_price;
        availability_zone_group;
        block_duration_minutes;
        create_time;
        fault;
        instance_id;
        launch_group;
        launch_specification;
        launched_availability_zone;
        product_description;
        spot_instance_request_id;
        spot_price;
        state;
        status;
        tags;
        type_;
        valid_from;
        valid_until;
        instance_interruption_behavior
      }
    let parse xml =
      Some
        {
          actual_block_hourly_price =
            (Util.option_bind (Xml.member "actualBlockHourlyPrice" xml)
               String.parse);
          availability_zone_group =
            (Util.option_bind (Xml.member "availabilityZoneGroup" xml)
               String.parse);
          block_duration_minutes =
            (Util.option_bind (Xml.member "blockDurationMinutes" xml)
               Integer.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          fault =
            (Util.option_bind (Xml.member "fault" xml)
               SpotInstanceStateFault.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          launch_group =
            (Util.option_bind (Xml.member "launchGroup" xml) String.parse);
          launch_specification =
            (Util.option_bind (Xml.member "launchSpecification" xml)
               LaunchSpecification.parse);
          launched_availability_zone =
            (Util.option_bind (Xml.member "launchedAvailabilityZone" xml)
               String.parse);
          product_description =
            (Util.option_bind (Xml.member "productDescription" xml)
               RIProductDescription.parse);
          spot_instance_request_id =
            (Util.option_bind (Xml.member "spotInstanceRequestId" xml)
               String.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               SpotInstanceState.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               SpotInstanceStatus.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          type_ =
            (Util.option_bind (Xml.member "type" xml) SpotInstanceType.parse);
          valid_from =
            (Util.option_bind (Xml.member "validFrom" xml) DateTime.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "instanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Query.Pair
                   ("InstanceInterruptionBehavior",
                     (InstanceInterruptionBehavior.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.valid_from
             (fun f -> Query.Pair ("ValidFrom", (DateTime.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (SpotInstanceType.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (SpotInstanceStatus.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (SpotInstanceState.to_query f)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.spot_instance_request_id
             (fun f ->
                Query.Pair ("SpotInstanceRequestId", (String.to_query f)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.launched_availability_zone
             (fun f ->
                Query.Pair ("LaunchedAvailabilityZone", (String.to_query f)));
           Util.option_map v.launch_specification
             (fun f ->
                Query.Pair
                  ("LaunchSpecification", (LaunchSpecification.to_query f)));
           Util.option_map v.launch_group
             (fun f -> Query.Pair ("LaunchGroup", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.fault
             (fun f ->
                Query.Pair ("Fault", (SpotInstanceStateFault.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.block_duration_minutes
             (fun f ->
                Query.Pair ("BlockDurationMinutes", (Integer.to_query f)));
           Util.option_map v.availability_zone_group
             (fun f ->
                Query.Pair ("AvailabilityZoneGroup", (String.to_query f)));
           Util.option_map v.actual_block_hourly_price
             (fun f ->
                Query.Pair ("ActualBlockHourlyPrice", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((((([] @
                             [Util.option_map v.actual_block_hourly_price
                                (fun f ->
                                   Ezxmlm.make_tag "actualBlockHourlyPrice"
                                     ([], (String.to_xml f)))])
                            @
                            [Util.option_map v.availability_zone_group
                               (fun f ->
                                  Ezxmlm.make_tag "availabilityZoneGroup"
                                    ([], (String.to_xml f)))])
                           @
                           [Util.option_map v.block_duration_minutes
                              (fun f ->
                                 Ezxmlm.make_tag "blockDurationMinutes"
                                   ([], (Integer.to_xml f)))])
                          @
                          [Util.option_map v.create_time
                             (fun f ->
                                Ezxmlm.make_tag "createTime"
                                  ([], (DateTime.to_xml f)))])
                         @
                         [Util.option_map v.fault
                            (fun f ->
                               Ezxmlm.make_tag "fault"
                                 ([], (SpotInstanceStateFault.to_xml f)))])
                        @
                        [Util.option_map v.instance_id
                           (fun f ->
                              Ezxmlm.make_tag "instanceId"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.launch_group
                          (fun f ->
                             Ezxmlm.make_tag "launchGroup"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.launch_specification
                         (fun f ->
                            Ezxmlm.make_tag "launchSpecification"
                              ([], (LaunchSpecification.to_xml f)))])
                     @
                     [Util.option_map v.launched_availability_zone
                        (fun f ->
                           Ezxmlm.make_tag "launchedAvailabilityZone"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.product_description
                       (fun f ->
                          Ezxmlm.make_tag "productDescription"
                            ([], (RIProductDescription.to_xml f)))])
                   @
                   [Util.option_map v.spot_instance_request_id
                      (fun f ->
                         Ezxmlm.make_tag "spotInstanceRequestId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.spot_price
                     (fun f ->
                        Ezxmlm.make_tag "spotPrice" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.state
                    (fun f ->
                       Ezxmlm.make_tag "state"
                         ([], (SpotInstanceState.to_xml f)))])
                @
                [Util.option_map v.status
                   (fun f ->
                      Ezxmlm.make_tag "status"
                        ([], (SpotInstanceStatus.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
                  v.tags))
              @
              [Util.option_map v.type_
                 (fun f ->
                    Ezxmlm.make_tag "type" ([], (SpotInstanceType.to_xml f)))])
             @
             [Util.option_map v.valid_from
                (fun f ->
                   Ezxmlm.make_tag "validFrom" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.valid_until
               (fun f ->
                  Ezxmlm.make_tag "validUntil" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Ezxmlm.make_tag "instanceInterruptionBehavior"
                   ([], (InstanceInterruptionBehavior.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 ("instance_interruption_behavior",
                   (InstanceInterruptionBehavior.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.valid_from
             (fun f -> ("valid_from", (DateTime.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (SpotInstanceType.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status
             (fun f -> ("status", (SpotInstanceStatus.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (SpotInstanceState.to_json f)));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.spot_instance_request_id
             (fun f -> ("spot_instance_request_id", (String.to_json f)));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.launched_availability_zone
             (fun f -> ("launched_availability_zone", (String.to_json f)));
           Util.option_map v.launch_specification
             (fun f ->
                ("launch_specification", (LaunchSpecification.to_json f)));
           Util.option_map v.launch_group
             (fun f -> ("launch_group", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.fault
             (fun f -> ("fault", (SpotInstanceStateFault.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.block_duration_minutes
             (fun f -> ("block_duration_minutes", (Integer.to_json f)));
           Util.option_map v.availability_zone_group
             (fun f -> ("availability_zone_group", (String.to_json f)));
           Util.option_map v.actual_block_hourly_price
             (fun f -> ("actual_block_hourly_price", (String.to_json f)))])
    let of_json j =
      {
        actual_block_hourly_price =
          (Util.option_map (Json.lookup j "actual_block_hourly_price")
             String.of_json);
        availability_zone_group =
          (Util.option_map (Json.lookup j "availability_zone_group")
             String.of_json);
        block_duration_minutes =
          (Util.option_map (Json.lookup j "block_duration_minutes")
             Integer.of_json);
        create_time =
          (Util.option_map (Json.lookup j "create_time") DateTime.of_json);
        fault =
          (Util.option_map (Json.lookup j "fault")
             SpotInstanceStateFault.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        launch_group =
          (Util.option_map (Json.lookup j "launch_group") String.of_json);
        launch_specification =
          (Util.option_map (Json.lookup j "launch_specification")
             LaunchSpecification.of_json);
        launched_availability_zone =
          (Util.option_map (Json.lookup j "launched_availability_zone")
             String.of_json);
        product_description =
          (Util.option_map (Json.lookup j "product_description")
             RIProductDescription.of_json);
        spot_instance_request_id =
          (Util.option_map (Json.lookup j "spot_instance_request_id")
             String.of_json);
        spot_price =
          (Util.option_map (Json.lookup j "spot_price") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state") SpotInstanceState.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             SpotInstanceStatus.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        type_ =
          (Util.option_map (Json.lookup j "type_") SpotInstanceType.of_json);
        valid_from =
          (Util.option_map (Json.lookup j "valid_from") DateTime.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        instance_interruption_behavior =
          (Util.option_map (Json.lookup j "instance_interruption_behavior")
             InstanceInterruptionBehavior.of_json)
      }
  end
module FailedQueuedPurchaseDeletion =
  struct
    type t =
      {
      error: DeleteQueuedReservedInstancesError.t option ;
      reserved_instances_id: String.t option }
    let make ?error  ?reserved_instances_id  () =
      { error; reserved_instances_id }
    let parse xml =
      Some
        {
          error =
            (Util.option_bind (Xml.member "error" xml)
               DeleteQueuedReservedInstancesError.parse);
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Query.Pair ("ReservedInstancesId", (String.to_query f)));
           Util.option_map v.error
             (fun f ->
                Query.Pair
                  ("Error", (DeleteQueuedReservedInstancesError.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.error
               (fun f ->
                  Ezxmlm.make_tag "error"
                    ([], (DeleteQueuedReservedInstancesError.to_xml f)))])
           @
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Ezxmlm.make_tag "reservedInstancesId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f -> ("reserved_instances_id", (String.to_json f)));
           Util.option_map v.error
             (fun f ->
                ("error", (DeleteQueuedReservedInstancesError.to_json f)))])
    let of_json j =
      {
        error =
          (Util.option_map (Json.lookup j "error")
             DeleteQueuedReservedInstancesError.of_json);
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json)
      }
  end
module SuccessfulQueuedPurchaseDeletion =
  struct
    type t = {
      reserved_instances_id: String.t option }
    let make ?reserved_instances_id  () = { reserved_instances_id }
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Ezxmlm.make_tag "reservedInstancesId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json)
      }
  end
module ExportTask =
  struct
    type t =
      {
      description: String.t ;
      export_task_id: String.t ;
      export_to_s3_task: ExportToS3Task.t ;
      instance_export_details: InstanceExportDetails.t ;
      state: ExportTaskState.t ;
      status_message: String.t ;
      tags: TagList.t }
    let make ~description  ~export_task_id  ~export_to_s3_task 
      ~instance_export_details  ~state  ~status_message  ?(tags= [])  () =
      {
        description;
        export_task_id;
        export_to_s3_task;
        instance_export_details;
        state;
        status_message;
        tags
      }
    let parse xml =
      Some
        {
          description =
            (Xml.required "description"
               (Util.option_bind (Xml.member "description" xml) String.parse));
          export_task_id =
            (Xml.required "exportTaskId"
               (Util.option_bind (Xml.member "exportTaskId" xml) String.parse));
          export_to_s3_task =
            (Xml.required "exportToS3"
               (Util.option_bind (Xml.member "exportToS3" xml)
                  ExportToS3Task.parse));
          instance_export_details =
            (Xml.required "instanceExport"
               (Util.option_bind (Xml.member "instanceExport" xml)
                  InstanceExportDetails.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml)
                  ExportTaskState.parse));
          status_message =
            (Xml.required "statusMessage"
               (Util.option_bind (Xml.member "statusMessage" xml)
                  String.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("StatusMessage", (String.to_query v.status_message)));
           Some (Query.Pair ("State", (ExportTaskState.to_query v.state)));
           Some
             (Query.Pair
                ("InstanceExport",
                  (InstanceExportDetails.to_query v.instance_export_details)));
           Some
             (Query.Pair
                ("ExportToS3", (ExportToS3Task.to_query v.export_to_s3_task)));
           Some
             (Query.Pair ("ExportTaskId", (String.to_query v.export_task_id)));
           Some (Query.Pair ("Description", (String.to_query v.description)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Some
                    (Ezxmlm.make_tag "description"
                       ([], (String.to_xml v.description)))])
                @
                [Some
                   (Ezxmlm.make_tag "exportTaskId"
                      ([], (String.to_xml v.export_task_id)))])
               @
               [Some
                  (Ezxmlm.make_tag "exportToS3"
                     ([], (ExportToS3Task.to_xml v.export_to_s3_task)))])
              @
              [Some
                 (Ezxmlm.make_tag "instanceExport"
                    ([],
                      (InstanceExportDetails.to_xml v.instance_export_details)))])
             @
             [Some
                (Ezxmlm.make_tag "state"
                   ([], (ExportTaskState.to_xml v.state)))])
            @
            [Some
               (Ezxmlm.make_tag "statusMessage"
                  ([], (String.to_xml v.status_message)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some ("status_message", (String.to_json v.status_message));
           Some ("state", (ExportTaskState.to_json v.state));
           Some
             ("instance_export_details",
               (InstanceExportDetails.to_json v.instance_export_details));
           Some
             ("export_to_s3_task",
               (ExportToS3Task.to_json v.export_to_s3_task));
           Some ("export_task_id", (String.to_json v.export_task_id));
           Some ("description", (String.to_json v.description))])
    let of_json j =
      {
        description =
          (String.of_json (Util.of_option_exn (Json.lookup j "description")));
        export_task_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "export_task_id")));
        export_to_s3_task =
          (ExportToS3Task.of_json
             (Util.of_option_exn (Json.lookup j "export_to_s3_task")));
        instance_export_details =
          (InstanceExportDetails.of_json
             (Util.of_option_exn (Json.lookup j "instance_export_details")));
        state =
          (ExportTaskState.of_json
             (Util.of_option_exn (Json.lookup j "state")));
        status_message =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "status_message")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module InstanceMonitoring =
  struct
    type t = {
      instance_id: String.t option ;
      monitoring: Monitoring.t option }
    let make ?instance_id  ?monitoring  () = { instance_id; monitoring }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml) Monitoring.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.monitoring
              (fun f -> Query.Pair ("Monitoring", (Monitoring.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.monitoring
              (fun f ->
                 Ezxmlm.make_tag "monitoring" ([], (Monitoring.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.monitoring
              (fun f -> ("monitoring", (Monitoring.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring") Monitoring.of_json)
      }
  end
module SecurityGroup =
  struct
    type t =
      {
      description: String.t ;
      group_name: String.t ;
      ip_permissions: IpPermissionList.t ;
      owner_id: String.t ;
      group_id: String.t ;
      ip_permissions_egress: IpPermissionList.t ;
      tags: TagList.t ;
      vpc_id: String.t option }
    let make ~description  ~group_name  ?(ip_permissions= [])  ~owner_id 
      ~group_id  ?(ip_permissions_egress= [])  ?(tags= [])  ?vpc_id  () =
      {
        description;
        group_name;
        ip_permissions;
        owner_id;
        group_id;
        ip_permissions_egress;
        tags;
        vpc_id
      }
    let parse xml =
      Some
        {
          description =
            (Xml.required "groupDescription"
               (Util.option_bind (Xml.member "groupDescription" xml)
                  String.parse));
          group_name =
            (Xml.required "groupName"
               (Util.option_bind (Xml.member "groupName" xml) String.parse));
          ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipPermissions" xml)
                  IpPermissionList.parse));
          owner_id =
            (Xml.required "ownerId"
               (Util.option_bind (Xml.member "ownerId" xml) String.parse));
          group_id =
            (Xml.required "groupId"
               (Util.option_bind (Xml.member "groupId" xml) String.parse));
          ip_permissions_egress =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipPermissionsEgress" xml)
                  IpPermissionList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("IpPermissionsEgress",
                  (IpPermissionList.to_query v.ip_permissions_egress)));
           Some (Query.Pair ("GroupId", (String.to_query v.group_id)));
           Some (Query.Pair ("OwnerId", (String.to_query v.owner_id)));
           Some
             (Query.Pair
                ("IpPermissions",
                  (IpPermissionList.to_query v.ip_permissions)));
           Some (Query.Pair ("GroupName", (String.to_query v.group_name)));
           Some
             (Query.Pair
                ("GroupDescription", (String.to_query v.description)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Some
                     (Ezxmlm.make_tag "groupDescription"
                        ([], (String.to_xml v.description)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "groupName"
                       ([], (String.to_xml v.group_name)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "ipPermissions"
                           ([], (IpPermissionList.to_xml [x]))))
                   v.ip_permissions))
               @
               [Some
                  (Ezxmlm.make_tag "ownerId" ([], (String.to_xml v.owner_id)))])
              @
              [Some
                 (Ezxmlm.make_tag "groupId" ([], (String.to_xml v.group_id)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "ipPermissionsEgress"
                        ([], (IpPermissionList.to_xml [x]))))
                v.ip_permissions_egress))
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Some
             ("ip_permissions_egress",
               (IpPermissionList.to_json v.ip_permissions_egress));
           Some ("group_id", (String.to_json v.group_id));
           Some ("owner_id", (String.to_json v.owner_id));
           Some
             ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Some ("group_name", (String.to_json v.group_name));
           Some ("description", (String.to_json v.description))])
    let of_json j =
      {
        description =
          (String.of_json (Util.of_option_exn (Json.lookup j "description")));
        group_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_name")));
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")));
        owner_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "owner_id")));
        group_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_id")));
        ip_permissions_egress =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions_egress")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module ServiceDetail =
  struct
    type t =
      {
      service_name: String.t option ;
      service_id: String.t option ;
      service_type: ServiceTypeDetailSet.t ;
      availability_zones: ValueStringList.t ;
      owner: String.t option ;
      base_endpoint_dns_names: ValueStringList.t ;
      private_dns_name: String.t option ;
      vpc_endpoint_policy_supported: Boolean.t option ;
      acceptance_required: Boolean.t option ;
      manages_vpc_endpoints: Boolean.t option ;
      tags: TagList.t }
    let make ?service_name  ?service_id  ?(service_type= []) 
      ?(availability_zones= [])  ?owner  ?(base_endpoint_dns_names= []) 
      ?private_dns_name  ?vpc_endpoint_policy_supported  ?acceptance_required
       ?manages_vpc_endpoints  ?(tags= [])  () =
      {
        service_name;
        service_id;
        service_type;
        availability_zones;
        owner;
        base_endpoint_dns_names;
        private_dns_name;
        vpc_endpoint_policy_supported;
        acceptance_required;
        manages_vpc_endpoints;
        tags
      }
    let parse xml =
      Some
        {
          service_name =
            (Util.option_bind (Xml.member "serviceName" xml) String.parse);
          service_id =
            (Util.option_bind (Xml.member "serviceId" xml) String.parse);
          service_type =
            (Util.of_option []
               (Util.option_bind (Xml.member "serviceType" xml)
                  ServiceTypeDetailSet.parse));
          availability_zones =
            (Util.of_option []
               (Util.option_bind (Xml.member "availabilityZoneSet" xml)
                  ValueStringList.parse));
          owner = (Util.option_bind (Xml.member "owner" xml) String.parse);
          base_endpoint_dns_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "baseEndpointDnsNameSet" xml)
                  ValueStringList.parse));
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          vpc_endpoint_policy_supported =
            (Util.option_bind (Xml.member "vpcEndpointPolicySupported" xml)
               Boolean.parse);
          acceptance_required =
            (Util.option_bind (Xml.member "acceptanceRequired" xml)
               Boolean.parse);
          manages_vpc_endpoints =
            (Util.option_bind (Xml.member "managesVpcEndpoints" xml)
               Boolean.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.manages_vpc_endpoints
             (fun f ->
                Query.Pair ("ManagesVpcEndpoints", (Boolean.to_query f)));
           Util.option_map v.acceptance_required
             (fun f ->
                Query.Pair ("AcceptanceRequired", (Boolean.to_query f)));
           Util.option_map v.vpc_endpoint_policy_supported
             (fun f ->
                Query.Pair
                  ("VpcEndpointPolicySupported", (Boolean.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Some
             (Query.Pair
                ("BaseEndpointDnsNameSet",
                  (ValueStringList.to_query v.base_endpoint_dns_names)));
           Util.option_map v.owner
             (fun f -> Query.Pair ("Owner", (String.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZoneSet",
                  (ValueStringList.to_query v.availability_zones)));
           Some
             (Query.Pair
                ("ServiceType",
                  (ServiceTypeDetailSet.to_query v.service_type)));
           Util.option_map v.service_id
             (fun f -> Query.Pair ("ServiceId", (String.to_query f)));
           Util.option_map v.service_name
             (fun f -> Query.Pair ("ServiceName", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.service_name
                        (fun f ->
                           Ezxmlm.make_tag "serviceName"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.service_id
                       (fun f ->
                          Ezxmlm.make_tag "serviceId" ([], (String.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "serviceType"
                              ([], (ServiceTypeDetailSet.to_xml [x]))))
                      v.service_type))
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "availabilityZoneSet"
                             ([], (ValueStringList.to_xml [x]))))
                     v.availability_zones))
                 @
                 [Util.option_map v.owner
                    (fun f -> Ezxmlm.make_tag "owner" ([], (String.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "baseEndpointDnsNameSet"
                           ([], (ValueStringList.to_xml [x]))))
                   v.base_endpoint_dns_names))
               @
               [Util.option_map v.private_dns_name
                  (fun f ->
                     Ezxmlm.make_tag "privateDnsName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.vpc_endpoint_policy_supported
                 (fun f ->
                    Ezxmlm.make_tag "vpcEndpointPolicySupported"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.acceptance_required
                (fun f ->
                   Ezxmlm.make_tag "acceptanceRequired"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.manages_vpc_endpoints
               (fun f ->
                  Ezxmlm.make_tag "managesVpcEndpoints"
                    ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.manages_vpc_endpoints
             (fun f -> ("manages_vpc_endpoints", (Boolean.to_json f)));
           Util.option_map v.acceptance_required
             (fun f -> ("acceptance_required", (Boolean.to_json f)));
           Util.option_map v.vpc_endpoint_policy_supported
             (fun f -> ("vpc_endpoint_policy_supported", (Boolean.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Some
             ("base_endpoint_dns_names",
               (ValueStringList.to_json v.base_endpoint_dns_names));
           Util.option_map v.owner (fun f -> ("owner", (String.to_json f)));
           Some
             ("availability_zones",
               (ValueStringList.to_json v.availability_zones));
           Some
             ("service_type", (ServiceTypeDetailSet.to_json v.service_type));
           Util.option_map v.service_id
             (fun f -> ("service_id", (String.to_json f)));
           Util.option_map v.service_name
             (fun f -> ("service_name", (String.to_json f)))])
    let of_json j =
      {
        service_name =
          (Util.option_map (Json.lookup j "service_name") String.of_json);
        service_id =
          (Util.option_map (Json.lookup j "service_id") String.of_json);
        service_type =
          (ServiceTypeDetailSet.of_json
             (Util.of_option_exn (Json.lookup j "service_type")));
        availability_zones =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "availability_zones")));
        owner = (Util.option_map (Json.lookup j "owner") String.of_json);
        base_endpoint_dns_names =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "base_endpoint_dns_names")));
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        vpc_endpoint_policy_supported =
          (Util.option_map (Json.lookup j "vpc_endpoint_policy_supported")
             Boolean.of_json);
        acceptance_required =
          (Util.option_map (Json.lookup j "acceptance_required")
             Boolean.of_json);
        manages_vpc_endpoints =
          (Util.option_map (Json.lookup j "manages_vpc_endpoints")
             Boolean.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ClientVpnEndpoint =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option ;
      description: String.t option ;
      status: ClientVpnEndpointStatus.t option ;
      creation_time: String.t option ;
      deletion_time: String.t option ;
      dns_name: String.t option ;
      client_cidr_block: String.t option ;
      dns_servers: ValueStringList.t ;
      split_tunnel: Boolean.t option ;
      vpn_protocol: VpnProtocol.t option ;
      transport_protocol: TransportProtocol.t option ;
      associated_target_networks: AssociatedTargetNetworkSet.t ;
      server_certificate_arn: String.t option ;
      authentication_options: ClientVpnAuthenticationList.t ;
      connection_log_options: ConnectionLogResponseOptions.t option ;
      tags: TagList.t }
    let make ?client_vpn_endpoint_id  ?description  ?status  ?creation_time 
      ?deletion_time  ?dns_name  ?client_cidr_block  ?(dns_servers= []) 
      ?split_tunnel  ?vpn_protocol  ?transport_protocol 
      ?(associated_target_networks= [])  ?server_certificate_arn 
      ?(authentication_options= [])  ?connection_log_options  ?(tags= [])  ()
      =
      {
        client_vpn_endpoint_id;
        description;
        status;
        creation_time;
        deletion_time;
        dns_name;
        client_cidr_block;
        dns_servers;
        split_tunnel;
        vpn_protocol;
        transport_protocol;
        associated_target_networks;
        server_certificate_arn;
        authentication_options;
        connection_log_options;
        tags
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnEndpointStatus.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) String.parse);
          deletion_time =
            (Util.option_bind (Xml.member "deletionTime" xml) String.parse);
          dns_name =
            (Util.option_bind (Xml.member "dnsName" xml) String.parse);
          client_cidr_block =
            (Util.option_bind (Xml.member "clientCidrBlock" xml) String.parse);
          dns_servers =
            (Util.of_option []
               (Util.option_bind (Xml.member "dnsServer" xml)
                  ValueStringList.parse));
          split_tunnel =
            (Util.option_bind (Xml.member "splitTunnel" xml) Boolean.parse);
          vpn_protocol =
            (Util.option_bind (Xml.member "vpnProtocol" xml)
               VpnProtocol.parse);
          transport_protocol =
            (Util.option_bind (Xml.member "transportProtocol" xml)
               TransportProtocol.parse);
          associated_target_networks =
            (Util.of_option []
               (Util.option_bind (Xml.member "associatedTargetNetwork" xml)
                  AssociatedTargetNetworkSet.parse));
          server_certificate_arn =
            (Util.option_bind (Xml.member "serverCertificateArn" xml)
               String.parse);
          authentication_options =
            (Util.of_option []
               (Util.option_bind (Xml.member "authenticationOptions" xml)
                  ClientVpnAuthenticationList.parse));
          connection_log_options =
            (Util.option_bind (Xml.member "connectionLogOptions" xml)
               ConnectionLogResponseOptions.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.connection_log_options
             (fun f ->
                Query.Pair
                  ("ConnectionLogOptions",
                    (ConnectionLogResponseOptions.to_query f)));
           Some
             (Query.Pair
                ("AuthenticationOptions",
                  (ClientVpnAuthenticationList.to_query
                     v.authentication_options)));
           Util.option_map v.server_certificate_arn
             (fun f ->
                Query.Pair ("ServerCertificateArn", (String.to_query f)));
           Some
             (Query.Pair
                ("AssociatedTargetNetwork",
                  (AssociatedTargetNetworkSet.to_query
                     v.associated_target_networks)));
           Util.option_map v.transport_protocol
             (fun f ->
                Query.Pair
                  ("TransportProtocol", (TransportProtocol.to_query f)));
           Util.option_map v.vpn_protocol
             (fun f -> Query.Pair ("VpnProtocol", (VpnProtocol.to_query f)));
           Util.option_map v.split_tunnel
             (fun f -> Query.Pair ("SplitTunnel", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("DnsServer", (ValueStringList.to_query v.dns_servers)));
           Util.option_map v.client_cidr_block
             (fun f -> Query.Pair ("ClientCidrBlock", (String.to_query f)));
           Util.option_map v.dns_name
             (fun f -> Query.Pair ("DnsName", (String.to_query f)));
           Util.option_map v.deletion_time
             (fun f -> Query.Pair ("DeletionTime", (String.to_query f)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (ClientVpnEndpointStatus.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((([] @
                          [Util.option_map v.client_vpn_endpoint_id
                             (fun f ->
                                Ezxmlm.make_tag "clientVpnEndpointId"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.description
                            (fun f ->
                               Ezxmlm.make_tag "description"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.status
                           (fun f ->
                              Ezxmlm.make_tag "status"
                                ([], (ClientVpnEndpointStatus.to_xml f)))])
                       @
                       [Util.option_map v.creation_time
                          (fun f ->
                             Ezxmlm.make_tag "creationTime"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.deletion_time
                         (fun f ->
                            Ezxmlm.make_tag "deletionTime"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.dns_name
                        (fun f ->
                           Ezxmlm.make_tag "dnsName" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.client_cidr_block
                       (fun f ->
                          Ezxmlm.make_tag "clientCidrBlock"
                            ([], (String.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "dnsServer"
                              ([], (ValueStringList.to_xml [x]))))
                      v.dns_servers))
                  @
                  [Util.option_map v.split_tunnel
                     (fun f ->
                        Ezxmlm.make_tag "splitTunnel"
                          ([], (Boolean.to_xml f)))])
                 @
                 [Util.option_map v.vpn_protocol
                    (fun f ->
                       Ezxmlm.make_tag "vpnProtocol"
                         ([], (VpnProtocol.to_xml f)))])
                @
                [Util.option_map v.transport_protocol
                   (fun f ->
                      Ezxmlm.make_tag "transportProtocol"
                        ([], (TransportProtocol.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "associatedTargetNetwork"
                          ([], (AssociatedTargetNetworkSet.to_xml [x]))))
                  v.associated_target_networks))
              @
              [Util.option_map v.server_certificate_arn
                 (fun f ->
                    Ezxmlm.make_tag "serverCertificateArn"
                      ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "authenticationOptions"
                        ([], (ClientVpnAuthenticationList.to_xml [x]))))
                v.authentication_options))
            @
            [Util.option_map v.connection_log_options
               (fun f ->
                  Ezxmlm.make_tag "connectionLogOptions"
                    ([], (ConnectionLogResponseOptions.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.connection_log_options
             (fun f ->
                ("connection_log_options",
                  (ConnectionLogResponseOptions.to_json f)));
           Some
             ("authentication_options",
               (ClientVpnAuthenticationList.to_json v.authentication_options));
           Util.option_map v.server_certificate_arn
             (fun f -> ("server_certificate_arn", (String.to_json f)));
           Some
             ("associated_target_networks",
               (AssociatedTargetNetworkSet.to_json
                  v.associated_target_networks));
           Util.option_map v.transport_protocol
             (fun f -> ("transport_protocol", (TransportProtocol.to_json f)));
           Util.option_map v.vpn_protocol
             (fun f -> ("vpn_protocol", (VpnProtocol.to_json f)));
           Util.option_map v.split_tunnel
             (fun f -> ("split_tunnel", (Boolean.to_json f)));
           Some ("dns_servers", (ValueStringList.to_json v.dns_servers));
           Util.option_map v.client_cidr_block
             (fun f -> ("client_cidr_block", (String.to_json f)));
           Util.option_map v.dns_name
             (fun f -> ("dns_name", (String.to_json f)));
           Util.option_map v.deletion_time
             (fun f -> ("deletion_time", (String.to_json f)));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ClientVpnEndpointStatus.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (Util.option_map (Json.lookup j "client_vpn_endpoint_id")
             String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnEndpointStatus.of_json);
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") String.of_json);
        deletion_time =
          (Util.option_map (Json.lookup j "deletion_time") String.of_json);
        dns_name =
          (Util.option_map (Json.lookup j "dns_name") String.of_json);
        client_cidr_block =
          (Util.option_map (Json.lookup j "client_cidr_block") String.of_json);
        dns_servers =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "dns_servers")));
        split_tunnel =
          (Util.option_map (Json.lookup j "split_tunnel") Boolean.of_json);
        vpn_protocol =
          (Util.option_map (Json.lookup j "vpn_protocol") VpnProtocol.of_json);
        transport_protocol =
          (Util.option_map (Json.lookup j "transport_protocol")
             TransportProtocol.of_json);
        associated_target_networks =
          (AssociatedTargetNetworkSet.of_json
             (Util.of_option_exn (Json.lookup j "associated_target_networks")));
        server_certificate_arn =
          (Util.option_map (Json.lookup j "server_certificate_arn")
             String.of_json);
        authentication_options =
          (ClientVpnAuthenticationList.of_json
             (Util.of_option_exn (Json.lookup j "authentication_options")));
        connection_log_options =
          (Util.option_map (Json.lookup j "connection_log_options")
             ConnectionLogResponseOptions.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module FleetLaunchTemplateConfigRequest =
  struct
    type t =
      {
      launch_template_specification:
        FleetLaunchTemplateSpecificationRequest.t option ;
      overrides: FleetLaunchTemplateOverridesListRequest.t }
    let make ?launch_template_specification  ?(overrides= [])  () =
      { launch_template_specification; overrides }
    let parse xml =
      Some
        {
          launch_template_specification =
            (Util.option_bind (Xml.member "LaunchTemplateSpecification" xml)
               FleetLaunchTemplateSpecificationRequest.parse);
          overrides =
            (Util.of_option []
               (Util.option_bind (Xml.member "Overrides" xml)
                  FleetLaunchTemplateOverridesListRequest.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Overrides",
                   (FleetLaunchTemplateOverridesListRequest.to_query
                      v.overrides)));
           Util.option_map v.launch_template_specification
             (fun f ->
                Query.Pair
                  ("LaunchTemplateSpecification",
                    (FleetLaunchTemplateSpecificationRequest.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.launch_template_specification
               (fun f ->
                  Ezxmlm.make_tag "LaunchTemplateSpecification"
                    ([], (FleetLaunchTemplateSpecificationRequest.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Overrides"
                      ([],
                        (FleetLaunchTemplateOverridesListRequest.to_xml [x]))))
              v.overrides))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("overrides",
                (FleetLaunchTemplateOverridesListRequest.to_json v.overrides));
           Util.option_map v.launch_template_specification
             (fun f ->
                ("launch_template_specification",
                  (FleetLaunchTemplateSpecificationRequest.to_json f)))])
    let of_json j =
      {
        launch_template_specification =
          (Util.option_map (Json.lookup j "launch_template_specification")
             FleetLaunchTemplateSpecificationRequest.of_json);
        overrides =
          (FleetLaunchTemplateOverridesListRequest.of_json
             (Util.of_option_exn (Json.lookup j "overrides")))
      }
  end
module CapacityReservationOptionsRequest =
  struct
    type t =
      {
      usage_strategy: FleetCapacityReservationUsageStrategy.t option }
    let make ?usage_strategy  () = { usage_strategy }
    let parse xml =
      Some
        {
          usage_strategy =
            (Util.option_bind (Xml.member "UsageStrategy" xml)
               FleetCapacityReservationUsageStrategy.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.usage_strategy
              (fun f ->
                 Query.Pair
                   ("UsageStrategy",
                     (FleetCapacityReservationUsageStrategy.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.usage_strategy
              (fun f ->
                 Ezxmlm.make_tag "UsageStrategy"
                   ([], (FleetCapacityReservationUsageStrategy.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.usage_strategy
              (fun f ->
                 ("usage_strategy",
                   (FleetCapacityReservationUsageStrategy.to_json f)))])
    let of_json j =
      {
        usage_strategy =
          (Util.option_map (Json.lookup j "usage_strategy")
             FleetCapacityReservationUsageStrategy.of_json)
      }
  end
module InternetGateway =
  struct
    type t =
      {
      attachments: InternetGatewayAttachmentList.t ;
      internet_gateway_id: String.t ;
      owner_id: String.t option ;
      tags: TagList.t }
    let make ?(attachments= [])  ~internet_gateway_id  ?owner_id  ?(tags= [])
       () = { attachments; internet_gateway_id; owner_id; tags }
    let parse xml =
      Some
        {
          attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "attachmentSet" xml)
                  InternetGatewayAttachmentList.parse));
          internet_gateway_id =
            (Xml.required "internetGatewayId"
               (Util.option_bind (Xml.member "internetGatewayId" xml)
                  String.parse));
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Some
             (Query.Pair
                ("InternetGatewayId",
                  (String.to_query v.internet_gateway_id)));
           Some
             (Query.Pair
                ("AttachmentSet",
                  (InternetGatewayAttachmentList.to_query v.attachments)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "attachmentSet"
                         ([], (InternetGatewayAttachmentList.to_xml [x]))))
                 v.attachments))
             @
             [Some
                (Ezxmlm.make_tag "internetGatewayId"
                   ([], (String.to_xml v.internet_gateway_id)))])
            @
            [Util.option_map v.owner_id
               (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Some
             ("internet_gateway_id", (String.to_json v.internet_gateway_id));
           Some
             ("attachments",
               (InternetGatewayAttachmentList.to_json v.attachments))])
    let of_json j =
      {
        attachments =
          (InternetGatewayAttachmentList.of_json
             (Util.of_option_exn (Json.lookup j "attachments")));
        internet_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateway_id")));
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module AccountAttributeName =
  struct
    type t =
      | Supported_platforms 
      | Default_vpc 
    let str_to_t =
      [("default-vpc", Default_vpc);
      ("supported-platforms", Supported_platforms)]
    let t_to_str =
      [(Default_vpc, "default-vpc");
      (Supported_platforms, "supported-platforms")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FleetData =
  struct
    type t =
      {
      activity_status: FleetActivityStatus.t option ;
      create_time: DateTime.t option ;
      fleet_id: String.t option ;
      fleet_state: FleetStateCode.t option ;
      client_token: String.t option ;
      excess_capacity_termination_policy:
        FleetExcessCapacityTerminationPolicy.t option ;
      fulfilled_capacity: Double.t option ;
      fulfilled_on_demand_capacity: Double.t option ;
      launch_template_configs: FleetLaunchTemplateConfigList.t ;
      target_capacity_specification: TargetCapacitySpecification.t option ;
      terminate_instances_with_expiration: Boolean.t option ;
      type_: FleetType.t option ;
      valid_from: DateTime.t option ;
      valid_until: DateTime.t option ;
      replace_unhealthy_instances: Boolean.t option ;
      spot_options: SpotOptions.t option ;
      on_demand_options: OnDemandOptions.t option ;
      tags: TagList.t ;
      errors: DescribeFleetsErrorSet.t ;
      instances: DescribeFleetsInstancesSet.t }
    let make ?activity_status  ?create_time  ?fleet_id  ?fleet_state 
      ?client_token  ?excess_capacity_termination_policy  ?fulfilled_capacity
       ?fulfilled_on_demand_capacity  ?(launch_template_configs= []) 
      ?target_capacity_specification  ?terminate_instances_with_expiration 
      ?type_  ?valid_from  ?valid_until  ?replace_unhealthy_instances 
      ?spot_options  ?on_demand_options  ?(tags= [])  ?(errors= []) 
      ?(instances= [])  () =
      {
        activity_status;
        create_time;
        fleet_id;
        fleet_state;
        client_token;
        excess_capacity_termination_policy;
        fulfilled_capacity;
        fulfilled_on_demand_capacity;
        launch_template_configs;
        target_capacity_specification;
        terminate_instances_with_expiration;
        type_;
        valid_from;
        valid_until;
        replace_unhealthy_instances;
        spot_options;
        on_demand_options;
        tags;
        errors;
        instances
      }
    let parse xml =
      Some
        {
          activity_status =
            (Util.option_bind (Xml.member "activityStatus" xml)
               FleetActivityStatus.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse);
          fleet_state =
            (Util.option_bind (Xml.member "fleetState" xml)
               FleetStateCode.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          excess_capacity_termination_policy =
            (Util.option_bind
               (Xml.member "excessCapacityTerminationPolicy" xml)
               FleetExcessCapacityTerminationPolicy.parse);
          fulfilled_capacity =
            (Util.option_bind (Xml.member "fulfilledCapacity" xml)
               Double.parse);
          fulfilled_on_demand_capacity =
            (Util.option_bind (Xml.member "fulfilledOnDemandCapacity" xml)
               Double.parse);
          launch_template_configs =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchTemplateConfigs" xml)
                  FleetLaunchTemplateConfigList.parse));
          target_capacity_specification =
            (Util.option_bind (Xml.member "targetCapacitySpecification" xml)
               TargetCapacitySpecification.parse);
          terminate_instances_with_expiration =
            (Util.option_bind
               (Xml.member "terminateInstancesWithExpiration" xml)
               Boolean.parse);
          type_ = (Util.option_bind (Xml.member "type" xml) FleetType.parse);
          valid_from =
            (Util.option_bind (Xml.member "validFrom" xml) DateTime.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          replace_unhealthy_instances =
            (Util.option_bind (Xml.member "replaceUnhealthyInstances" xml)
               Boolean.parse);
          spot_options =
            (Util.option_bind (Xml.member "spotOptions" xml)
               SpotOptions.parse);
          on_demand_options =
            (Util.option_bind (Xml.member "onDemandOptions" xml)
               OnDemandOptions.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          errors =
            (Util.of_option []
               (Util.option_bind (Xml.member "errorSet" xml)
                  DescribeFleetsErrorSet.parse));
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "fleetInstanceSet" xml)
                  DescribeFleetsInstancesSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FleetInstanceSet",
                   (DescribeFleetsInstancesSet.to_query v.instances)));
           Some
             (Query.Pair
                ("ErrorSet", (DescribeFleetsErrorSet.to_query v.errors)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.on_demand_options
             (fun f ->
                Query.Pair ("OnDemandOptions", (OnDemandOptions.to_query f)));
           Util.option_map v.spot_options
             (fun f -> Query.Pair ("SpotOptions", (SpotOptions.to_query f)));
           Util.option_map v.replace_unhealthy_instances
             (fun f ->
                Query.Pair
                  ("ReplaceUnhealthyInstances", (Boolean.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.valid_from
             (fun f -> Query.Pair ("ValidFrom", (DateTime.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (FleetType.to_query f)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                Query.Pair
                  ("TerminateInstancesWithExpiration", (Boolean.to_query f)));
           Util.option_map v.target_capacity_specification
             (fun f ->
                Query.Pair
                  ("TargetCapacitySpecification",
                    (TargetCapacitySpecification.to_query f)));
           Some
             (Query.Pair
                ("LaunchTemplateConfigs",
                  (FleetLaunchTemplateConfigList.to_query
                     v.launch_template_configs)));
           Util.option_map v.fulfilled_on_demand_capacity
             (fun f ->
                Query.Pair ("FulfilledOnDemandCapacity", (Double.to_query f)));
           Util.option_map v.fulfilled_capacity
             (fun f -> Query.Pair ("FulfilledCapacity", (Double.to_query f)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                Query.Pair
                  ("ExcessCapacityTerminationPolicy",
                    (FleetExcessCapacityTerminationPolicy.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.fleet_state
             (fun f -> Query.Pair ("FleetState", (FleetStateCode.to_query f)));
           Util.option_map v.fleet_id
             (fun f -> Query.Pair ("FleetId", (String.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.activity_status
             (fun f ->
                Query.Pair
                  ("ActivityStatus", (FleetActivityStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((((([] @
                              [Util.option_map v.activity_status
                                 (fun f ->
                                    Ezxmlm.make_tag "activityStatus"
                                      ([], (FleetActivityStatus.to_xml f)))])
                             @
                             [Util.option_map v.create_time
                                (fun f ->
                                   Ezxmlm.make_tag "createTime"
                                     ([], (DateTime.to_xml f)))])
                            @
                            [Util.option_map v.fleet_id
                               (fun f ->
                                  Ezxmlm.make_tag "fleetId"
                                    ([], (String.to_xml f)))])
                           @
                           [Util.option_map v.fleet_state
                              (fun f ->
                                 Ezxmlm.make_tag "fleetState"
                                   ([], (FleetStateCode.to_xml f)))])
                          @
                          [Util.option_map v.client_token
                             (fun f ->
                                Ezxmlm.make_tag "clientToken"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map
                            v.excess_capacity_termination_policy
                            (fun f ->
                               Ezxmlm.make_tag
                                 "excessCapacityTerminationPolicy"
                                 ([],
                                   (FleetExcessCapacityTerminationPolicy.to_xml
                                      f)))])
                        @
                        [Util.option_map v.fulfilled_capacity
                           (fun f ->
                              Ezxmlm.make_tag "fulfilledCapacity"
                                ([], (Double.to_xml f)))])
                       @
                       [Util.option_map v.fulfilled_on_demand_capacity
                          (fun f ->
                             Ezxmlm.make_tag "fulfilledOnDemandCapacity"
                               ([], (Double.to_xml f)))])
                      @
                      (List.map
                         (fun x ->
                            Some
                              (Ezxmlm.make_tag "launchTemplateConfigs"
                                 ([],
                                   (FleetLaunchTemplateConfigList.to_xml [x]))))
                         v.launch_template_configs))
                     @
                     [Util.option_map v.target_capacity_specification
                        (fun f ->
                           Ezxmlm.make_tag "targetCapacitySpecification"
                             ([], (TargetCapacitySpecification.to_xml f)))])
                    @
                    [Util.option_map v.terminate_instances_with_expiration
                       (fun f ->
                          Ezxmlm.make_tag "terminateInstancesWithExpiration"
                            ([], (Boolean.to_xml f)))])
                   @
                   [Util.option_map v.type_
                      (fun f ->
                         Ezxmlm.make_tag "type" ([], (FleetType.to_xml f)))])
                  @
                  [Util.option_map v.valid_from
                     (fun f ->
                        Ezxmlm.make_tag "validFrom" ([], (DateTime.to_xml f)))])
                 @
                 [Util.option_map v.valid_until
                    (fun f ->
                       Ezxmlm.make_tag "validUntil" ([], (DateTime.to_xml f)))])
                @
                [Util.option_map v.replace_unhealthy_instances
                   (fun f ->
                      Ezxmlm.make_tag "replaceUnhealthyInstances"
                        ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.spot_options
                  (fun f ->
                     Ezxmlm.make_tag "spotOptions"
                       ([], (SpotOptions.to_xml f)))])
              @
              [Util.option_map v.on_demand_options
                 (fun f ->
                    Ezxmlm.make_tag "onDemandOptions"
                      ([], (OnDemandOptions.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
                v.tags))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "errorSet"
                       ([], (DescribeFleetsErrorSet.to_xml [x])))) v.errors))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "fleetInstanceSet"
                      ([], (DescribeFleetsInstancesSet.to_xml [x]))))
              v.instances))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instances", (DescribeFleetsInstancesSet.to_json v.instances));
           Some ("errors", (DescribeFleetsErrorSet.to_json v.errors));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.on_demand_options
             (fun f -> ("on_demand_options", (OnDemandOptions.to_json f)));
           Util.option_map v.spot_options
             (fun f -> ("spot_options", (SpotOptions.to_json f)));
           Util.option_map v.replace_unhealthy_instances
             (fun f -> ("replace_unhealthy_instances", (Boolean.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.valid_from
             (fun f -> ("valid_from", (DateTime.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (FleetType.to_json f)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                ("terminate_instances_with_expiration", (Boolean.to_json f)));
           Util.option_map v.target_capacity_specification
             (fun f ->
                ("target_capacity_specification",
                  (TargetCapacitySpecification.to_json f)));
           Some
             ("launch_template_configs",
               (FleetLaunchTemplateConfigList.to_json
                  v.launch_template_configs));
           Util.option_map v.fulfilled_on_demand_capacity
             (fun f -> ("fulfilled_on_demand_capacity", (Double.to_json f)));
           Util.option_map v.fulfilled_capacity
             (fun f -> ("fulfilled_capacity", (Double.to_json f)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                ("excess_capacity_termination_policy",
                  (FleetExcessCapacityTerminationPolicy.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.fleet_state
             (fun f -> ("fleet_state", (FleetStateCode.to_json f)));
           Util.option_map v.fleet_id
             (fun f -> ("fleet_id", (String.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.activity_status
             (fun f -> ("activity_status", (FleetActivityStatus.to_json f)))])
    let of_json j =
      {
        activity_status =
          (Util.option_map (Json.lookup j "activity_status")
             FleetActivityStatus.of_json);
        create_time =
          (Util.option_map (Json.lookup j "create_time") DateTime.of_json);
        fleet_id =
          (Util.option_map (Json.lookup j "fleet_id") String.of_json);
        fleet_state =
          (Util.option_map (Json.lookup j "fleet_state")
             FleetStateCode.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        excess_capacity_termination_policy =
          (Util.option_map
             (Json.lookup j "excess_capacity_termination_policy")
             FleetExcessCapacityTerminationPolicy.of_json);
        fulfilled_capacity =
          (Util.option_map (Json.lookup j "fulfilled_capacity")
             Double.of_json);
        fulfilled_on_demand_capacity =
          (Util.option_map (Json.lookup j "fulfilled_on_demand_capacity")
             Double.of_json);
        launch_template_configs =
          (FleetLaunchTemplateConfigList.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_configs")));
        target_capacity_specification =
          (Util.option_map (Json.lookup j "target_capacity_specification")
             TargetCapacitySpecification.of_json);
        terminate_instances_with_expiration =
          (Util.option_map
             (Json.lookup j "terminate_instances_with_expiration")
             Boolean.of_json);
        type_ = (Util.option_map (Json.lookup j "type_") FleetType.of_json);
        valid_from =
          (Util.option_map (Json.lookup j "valid_from") DateTime.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        replace_unhealthy_instances =
          (Util.option_map (Json.lookup j "replace_unhealthy_instances")
             Boolean.of_json);
        spot_options =
          (Util.option_map (Json.lookup j "spot_options") SpotOptions.of_json);
        on_demand_options =
          (Util.option_map (Json.lookup j "on_demand_options")
             OnDemandOptions.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        errors =
          (DescribeFleetsErrorSet.of_json
             (Util.of_option_exn (Json.lookup j "errors")));
        instances =
          (DescribeFleetsInstancesSet.of_json
             (Util.of_option_exn (Json.lookup j "instances")))
      }
  end
module SpotFleetRequestConfig =
  struct
    type t =
      {
      activity_status: ActivityStatus.t option ;
      create_time: DateTime.t option ;
      spot_fleet_request_config: SpotFleetRequestConfigData.t option ;
      spot_fleet_request_id: String.t option ;
      spot_fleet_request_state: BatchState.t option }
    let make ?activity_status  ?create_time  ?spot_fleet_request_config 
      ?spot_fleet_request_id  ?spot_fleet_request_state  () =
      {
        activity_status;
        create_time;
        spot_fleet_request_config;
        spot_fleet_request_id;
        spot_fleet_request_state
      }
    let parse xml =
      Some
        {
          activity_status =
            (Util.option_bind (Xml.member "activityStatus" xml)
               ActivityStatus.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          spot_fleet_request_config =
            (Util.option_bind (Xml.member "spotFleetRequestConfig" xml)
               SpotFleetRequestConfigData.parse);
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse);
          spot_fleet_request_state =
            (Util.option_bind (Xml.member "spotFleetRequestState" xml)
               BatchState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_state
              (fun f ->
                 Query.Pair
                   ("SpotFleetRequestState", (BatchState.to_query f)));
           Util.option_map v.spot_fleet_request_id
             (fun f -> Query.Pair ("SpotFleetRequestId", (String.to_query f)));
           Util.option_map v.spot_fleet_request_config
             (fun f ->
                Query.Pair
                  ("SpotFleetRequestConfig",
                    (SpotFleetRequestConfigData.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.activity_status
             (fun f ->
                Query.Pair ("ActivityStatus", (ActivityStatus.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.activity_status
                  (fun f ->
                     Ezxmlm.make_tag "activityStatus"
                       ([], (ActivityStatus.to_xml f)))])
              @
              [Util.option_map v.create_time
                 (fun f ->
                    Ezxmlm.make_tag "createTime" ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.spot_fleet_request_config
                (fun f ->
                   Ezxmlm.make_tag "spotFleetRequestConfig"
                     ([], (SpotFleetRequestConfigData.to_xml f)))])
            @
            [Util.option_map v.spot_fleet_request_id
               (fun f ->
                  Ezxmlm.make_tag "spotFleetRequestId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.spot_fleet_request_state
              (fun f ->
                 Ezxmlm.make_tag "spotFleetRequestState"
                   ([], (BatchState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_state
              (fun f -> ("spot_fleet_request_state", (BatchState.to_json f)));
           Util.option_map v.spot_fleet_request_id
             (fun f -> ("spot_fleet_request_id", (String.to_json f)));
           Util.option_map v.spot_fleet_request_config
             (fun f ->
                ("spot_fleet_request_config",
                  (SpotFleetRequestConfigData.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.activity_status
             (fun f -> ("activity_status", (ActivityStatus.to_json f)))])
    let of_json j =
      {
        activity_status =
          (Util.option_map (Json.lookup j "activity_status")
             ActivityStatus.of_json);
        create_time =
          (Util.option_map (Json.lookup j "create_time") DateTime.of_json);
        spot_fleet_request_config =
          (Util.option_map (Json.lookup j "spot_fleet_request_config")
             SpotFleetRequestConfigData.of_json);
        spot_fleet_request_id =
          (Util.option_map (Json.lookup j "spot_fleet_request_id")
             String.of_json);
        spot_fleet_request_state =
          (Util.option_map (Json.lookup j "spot_fleet_request_state")
             BatchState.of_json)
      }
  end
module PurchaseRequest =
  struct
    type t = {
      instance_count: Integer.t ;
      purchase_token: String.t }
    let make ~instance_count  ~purchase_token  () =
      { instance_count; purchase_token }
    let parse xml =
      Some
        {
          instance_count =
            (Xml.required "InstanceCount"
               (Util.option_bind (Xml.member "InstanceCount" xml)
                  Integer.parse));
          purchase_token =
            (Xml.required "PurchaseToken"
               (Util.option_bind (Xml.member "PurchaseToken" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PurchaseToken", (String.to_query v.purchase_token)));
           Some
             (Query.Pair
                ("InstanceCount", (Integer.to_query v.instance_count)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "InstanceCount"
                  ([], (Integer.to_xml v.instance_count)))])
           @
           [Some
              (Ezxmlm.make_tag "PurchaseToken"
                 ([], (String.to_xml v.purchase_token)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("purchase_token", (String.to_json v.purchase_token));
           Some ("instance_count", (Integer.to_json v.instance_count))])
    let of_json j =
      {
        instance_count =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "instance_count")));
        purchase_token =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "purchase_token")))
      }
  end
module AvailabilityZone =
  struct
    type t =
      {
      state: AvailabilityZoneState.t option ;
      opt_in_status: AvailabilityZoneOptInStatus.t option ;
      messages: AvailabilityZoneMessageList.t ;
      region_name: String.t option ;
      zone_name: String.t option ;
      zone_id: String.t option ;
      group_name: String.t option ;
      network_border_group: String.t option }
    let make ?state  ?opt_in_status  ?(messages= [])  ?region_name 
      ?zone_name  ?zone_id  ?group_name  ?network_border_group  () =
      {
        state;
        opt_in_status;
        messages;
        region_name;
        zone_name;
        zone_id;
        group_name;
        network_border_group
      }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "zoneState" xml)
               AvailabilityZoneState.parse);
          opt_in_status =
            (Util.option_bind (Xml.member "optInStatus" xml)
               AvailabilityZoneOptInStatus.parse);
          messages =
            (Util.of_option []
               (Util.option_bind (Xml.member "messageSet" xml)
                  AvailabilityZoneMessageList.parse));
          region_name =
            (Util.option_bind (Xml.member "regionName" xml) String.parse);
          zone_name =
            (Util.option_bind (Xml.member "zoneName" xml) String.parse);
          zone_id = (Util.option_bind (Xml.member "zoneId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          network_border_group =
            (Util.option_bind (Xml.member "networkBorderGroup" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_border_group
              (fun f ->
                 Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.zone_id
             (fun f -> Query.Pair ("ZoneId", (String.to_query f)));
           Util.option_map v.zone_name
             (fun f -> Query.Pair ("ZoneName", (String.to_query f)));
           Util.option_map v.region_name
             (fun f -> Query.Pair ("RegionName", (String.to_query f)));
           Some
             (Query.Pair
                ("MessageSet",
                  (AvailabilityZoneMessageList.to_query v.messages)));
           Util.option_map v.opt_in_status
             (fun f ->
                Query.Pair
                  ("OptInStatus", (AvailabilityZoneOptInStatus.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("ZoneState", (AvailabilityZoneState.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.state
                     (fun f ->
                        Ezxmlm.make_tag "zoneState"
                          ([], (AvailabilityZoneState.to_xml f)))])
                 @
                 [Util.option_map v.opt_in_status
                    (fun f ->
                       Ezxmlm.make_tag "optInStatus"
                         ([], (AvailabilityZoneOptInStatus.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "messageSet"
                           ([], (AvailabilityZoneMessageList.to_xml [x]))))
                   v.messages))
               @
               [Util.option_map v.region_name
                  (fun f ->
                     Ezxmlm.make_tag "regionName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.zone_name
                 (fun f -> Ezxmlm.make_tag "zoneName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.zone_id
                (fun f -> Ezxmlm.make_tag "zoneId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.group_name
               (fun f -> Ezxmlm.make_tag "groupName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.network_border_group
              (fun f ->
                 Ezxmlm.make_tag "networkBorderGroup" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_border_group
              (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.zone_id
             (fun f -> ("zone_id", (String.to_json f)));
           Util.option_map v.zone_name
             (fun f -> ("zone_name", (String.to_json f)));
           Util.option_map v.region_name
             (fun f -> ("region_name", (String.to_json f)));
           Some
             ("messages", (AvailabilityZoneMessageList.to_json v.messages));
           Util.option_map v.opt_in_status
             (fun f ->
                ("opt_in_status", (AvailabilityZoneOptInStatus.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (AvailabilityZoneState.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state")
             AvailabilityZoneState.of_json);
        opt_in_status =
          (Util.option_map (Json.lookup j "opt_in_status")
             AvailabilityZoneOptInStatus.of_json);
        messages =
          (AvailabilityZoneMessageList.of_json
             (Util.of_option_exn (Json.lookup j "messages")));
        region_name =
          (Util.option_map (Json.lookup j "region_name") String.of_json);
        zone_name =
          (Util.option_map (Json.lookup j "zone_name") String.of_json);
        zone_id = (Util.option_map (Json.lookup j "zone_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        network_border_group =
          (Util.option_map (Json.lookup j "network_border_group")
             String.of_json)
      }
  end
module CustomerGateway =
  struct
    type t =
      {
      bgp_asn: String.t ;
      customer_gateway_id: String.t ;
      ip_address: String.t ;
      certificate_arn: String.t option ;
      state: String.t ;
      type_: String.t ;
      device_name: String.t option ;
      tags: TagList.t }
    let make ~bgp_asn  ~customer_gateway_id  ~ip_address  ?certificate_arn 
      ~state  ~type_  ?device_name  ?(tags= [])  () =
      {
        bgp_asn;
        customer_gateway_id;
        ip_address;
        certificate_arn;
        state;
        type_;
        device_name;
        tags
      }
    let parse xml =
      Some
        {
          bgp_asn =
            (Xml.required "bgpAsn"
               (Util.option_bind (Xml.member "bgpAsn" xml) String.parse));
          customer_gateway_id =
            (Xml.required "customerGatewayId"
               (Util.option_bind (Xml.member "customerGatewayId" xml)
                  String.parse));
          ip_address =
            (Xml.required "ipAddress"
               (Util.option_bind (Xml.member "ipAddress" xml) String.parse));
          certificate_arn =
            (Util.option_bind (Xml.member "certificateArn" xml) String.parse);
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml) String.parse));
          type_ =
            (Xml.required "type"
               (Util.option_bind (Xml.member "type" xml) String.parse));
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)));
           Some (Query.Pair ("Type", (String.to_query v.type_)));
           Some (Query.Pair ("State", (String.to_query v.state)));
           Util.option_map v.certificate_arn
             (fun f -> Query.Pair ("CertificateArn", (String.to_query f)));
           Some (Query.Pair ("IpAddress", (String.to_query v.ip_address)));
           Some
             (Query.Pair
                ("CustomerGatewayId",
                  (String.to_query v.customer_gateway_id)));
           Some (Query.Pair ("BgpAsn", (String.to_query v.bgp_asn)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Some
                     (Ezxmlm.make_tag "bgpAsn"
                        ([], (String.to_xml v.bgp_asn)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "customerGatewayId"
                       ([], (String.to_xml v.customer_gateway_id)))])
                @
                [Some
                   (Ezxmlm.make_tag "ipAddress"
                      ([], (String.to_xml v.ip_address)))])
               @
               [Util.option_map v.certificate_arn
                  (fun f ->
                     Ezxmlm.make_tag "certificateArn" ([], (String.to_xml f)))])
              @
              [Some (Ezxmlm.make_tag "state" ([], (String.to_xml v.state)))])
             @ [Some (Ezxmlm.make_tag "type" ([], (String.to_xml v.type_)))])
            @
            [Util.option_map v.device_name
               (fun f -> Ezxmlm.make_tag "deviceName" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)));
           Some ("type_", (String.to_json v.type_));
           Some ("state", (String.to_json v.state));
           Util.option_map v.certificate_arn
             (fun f -> ("certificate_arn", (String.to_json f)));
           Some ("ip_address", (String.to_json v.ip_address));
           Some
             ("customer_gateway_id", (String.to_json v.customer_gateway_id));
           Some ("bgp_asn", (String.to_json v.bgp_asn))])
    let of_json j =
      {
        bgp_asn =
          (String.of_json (Util.of_option_exn (Json.lookup j "bgp_asn")));
        customer_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateway_id")));
        ip_address =
          (String.of_json (Util.of_option_exn (Json.lookup j "ip_address")));
        certificate_arn =
          (Util.option_map (Json.lookup j "certificate_arn") String.of_json);
        state = (String.of_json (Util.of_option_exn (Json.lookup j "state")));
        type_ = (String.of_json (Util.of_option_exn (Json.lookup j "type_")));
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module VolumeStatusItem =
  struct
    type t =
      {
      actions: VolumeStatusActionsList.t ;
      availability_zone: String.t option ;
      outpost_arn: String.t option ;
      events: VolumeStatusEventsList.t ;
      volume_id: String.t option ;
      volume_status: VolumeStatusInfo.t option }
    let make ?(actions= [])  ?availability_zone  ?outpost_arn  ?(events= []) 
      ?volume_id  ?volume_status  () =
      {
        actions;
        availability_zone;
        outpost_arn;
        events;
        volume_id;
        volume_status
      }
    let parse xml =
      Some
        {
          actions =
            (Util.of_option []
               (Util.option_bind (Xml.member "actionsSet" xml)
                  VolumeStatusActionsList.parse));
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          events =
            (Util.of_option []
               (Util.option_bind (Xml.member "eventsSet" xml)
                  VolumeStatusEventsList.parse));
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          volume_status =
            (Util.option_bind (Xml.member "volumeStatus" xml)
               VolumeStatusInfo.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_status
              (fun f ->
                 Query.Pair ("VolumeStatus", (VolumeStatusInfo.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Some
             (Query.Pair
                ("EventsSet", (VolumeStatusEventsList.to_query v.events)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Some
             (Query.Pair
                ("ActionsSet", (VolumeStatusActionsList.to_query v.actions)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "actionsSet"
                           ([], (VolumeStatusActionsList.to_xml [x]))))
                   v.actions))
               @
               [Util.option_map v.availability_zone
                  (fun f ->
                     Ezxmlm.make_tag "availabilityZone"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.outpost_arn
                 (fun f ->
                    Ezxmlm.make_tag "outpostArn" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "eventsSet"
                        ([], (VolumeStatusEventsList.to_xml [x])))) v.events))
            @
            [Util.option_map v.volume_id
               (fun f -> Ezxmlm.make_tag "volumeId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.volume_status
              (fun f ->
                 Ezxmlm.make_tag "volumeStatus"
                   ([], (VolumeStatusInfo.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_status
              (fun f -> ("volume_status", (VolumeStatusInfo.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)));
           Some ("events", (VolumeStatusEventsList.to_json v.events));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Some ("actions", (VolumeStatusActionsList.to_json v.actions))])
    let of_json j =
      {
        actions =
          (VolumeStatusActionsList.of_json
             (Util.of_option_exn (Json.lookup j "actions")));
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        events =
          (VolumeStatusEventsList.of_json
             (Util.of_option_exn (Json.lookup j "events")));
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json);
        volume_status =
          (Util.option_map (Json.lookup j "volume_status")
             VolumeStatusInfo.of_json)
      }
  end
module TransitGatewayRouteTableAssociation =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option ;
      resource_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      state: TransitGatewayAssociationState.t option }
    let make ?transit_gateway_attachment_id  ?resource_id  ?resource_type 
      ?state  () =
      { transit_gateway_attachment_id; resource_id; resource_type; state }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAssociationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayAssociationState.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.transit_gateway_attachment_id
                 (fun f ->
                    Ezxmlm.make_tag "transitGatewayAttachmentId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.resource_id
                (fun f ->
                   Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "resourceType"
                    ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (TransitGatewayAssociationState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayAssociationState.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayAssociationState.of_json)
      }
  end
module HostOffering =
  struct
    type t =
      {
      currency_code: CurrencyCodeValues.t option ;
      duration: Integer.t option ;
      hourly_price: String.t option ;
      instance_family: String.t option ;
      offering_id: String.t option ;
      payment_option: PaymentOption.t option ;
      upfront_price: String.t option }
    let make ?currency_code  ?duration  ?hourly_price  ?instance_family 
      ?offering_id  ?payment_option  ?upfront_price  () =
      {
        currency_code;
        duration;
        hourly_price;
        instance_family;
        offering_id;
        payment_option;
        upfront_price
      }
    let parse xml =
      Some
        {
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Integer.parse);
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          instance_family =
            (Util.option_bind (Xml.member "instanceFamily" xml) String.parse);
          offering_id =
            (Util.option_bind (Xml.member "offeringId" xml) String.parse);
          payment_option =
            (Util.option_bind (Xml.member "paymentOption" xml)
               PaymentOption.parse);
          upfront_price =
            (Util.option_bind (Xml.member "upfrontPrice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.upfront_price
              (fun f -> Query.Pair ("UpfrontPrice", (String.to_query f)));
           Util.option_map v.payment_option
             (fun f ->
                Query.Pair ("PaymentOption", (PaymentOption.to_query f)));
           Util.option_map v.offering_id
             (fun f -> Query.Pair ("OfferingId", (String.to_query f)));
           Util.option_map v.instance_family
             (fun f -> Query.Pair ("InstanceFamily", (String.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Integer.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.currency_code
                    (fun f ->
                       Ezxmlm.make_tag "currencyCode"
                         ([], (CurrencyCodeValues.to_xml f)))])
                @
                [Util.option_map v.duration
                   (fun f ->
                      Ezxmlm.make_tag "duration" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.hourly_price
                  (fun f ->
                     Ezxmlm.make_tag "hourlyPrice" ([], (String.to_xml f)))])
              @
              [Util.option_map v.instance_family
                 (fun f ->
                    Ezxmlm.make_tag "instanceFamily" ([], (String.to_xml f)))])
             @
             [Util.option_map v.offering_id
                (fun f ->
                   Ezxmlm.make_tag "offeringId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.payment_option
               (fun f ->
                  Ezxmlm.make_tag "paymentOption"
                    ([], (PaymentOption.to_xml f)))])
           @
           [Util.option_map v.upfront_price
              (fun f ->
                 Ezxmlm.make_tag "upfrontPrice" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.upfront_price
              (fun f -> ("upfront_price", (String.to_json f)));
           Util.option_map v.payment_option
             (fun f -> ("payment_option", (PaymentOption.to_json f)));
           Util.option_map v.offering_id
             (fun f -> ("offering_id", (String.to_json f)));
           Util.option_map v.instance_family
             (fun f -> ("instance_family", (String.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Integer.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)))])
    let of_json j =
      {
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        duration =
          (Util.option_map (Json.lookup j "duration") Integer.of_json);
        hourly_price =
          (Util.option_map (Json.lookup j "hourly_price") String.of_json);
        instance_family =
          (Util.option_map (Json.lookup j "instance_family") String.of_json);
        offering_id =
          (Util.option_map (Json.lookup j "offering_id") String.of_json);
        payment_option =
          (Util.option_map (Json.lookup j "payment_option")
             PaymentOption.of_json);
        upfront_price =
          (Util.option_map (Json.lookup j "upfront_price") String.of_json)
      }
  end
module TransitGatewayRouteTable =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t option ;
      transit_gateway_id: String.t option ;
      state: TransitGatewayRouteTableState.t option ;
      default_association_route_table: Boolean.t option ;
      default_propagation_route_table: Boolean.t option ;
      creation_time: DateTime.t option ;
      tags: TagList.t }
    let make ?transit_gateway_route_table_id  ?transit_gateway_id  ?state 
      ?default_association_route_table  ?default_propagation_route_table 
      ?creation_time  ?(tags= [])  () =
      {
        transit_gateway_route_table_id;
        transit_gateway_id;
        state;
        default_association_route_table;
        default_propagation_route_table;
        creation_time;
        tags
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Util.option_bind (Xml.member "transitGatewayRouteTableId" xml)
               String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayRouteTableState.parse);
          default_association_route_table =
            (Util.option_bind (Xml.member "defaultAssociationRouteTable" xml)
               Boolean.parse);
          default_propagation_route_table =
            (Util.option_bind (Xml.member "defaultPropagationRouteTable" xml)
               Boolean.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Util.option_map v.default_propagation_route_table
             (fun f ->
                Query.Pair
                  ("DefaultPropagationRouteTable", (Boolean.to_query f)));
           Util.option_map v.default_association_route_table
             (fun f ->
                Query.Pair
                  ("DefaultAssociationRouteTable", (Boolean.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (TransitGatewayRouteTableState.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayRouteTableId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.transit_gateway_route_table_id
                    (fun f ->
                       Ezxmlm.make_tag "transitGatewayRouteTableId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.transit_gateway_id
                   (fun f ->
                      Ezxmlm.make_tag "transitGatewayId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.state
                  (fun f ->
                     Ezxmlm.make_tag "state"
                       ([], (TransitGatewayRouteTableState.to_xml f)))])
              @
              [Util.option_map v.default_association_route_table
                 (fun f ->
                    Ezxmlm.make_tag "defaultAssociationRouteTable"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.default_propagation_route_table
                (fun f ->
                   Ezxmlm.make_tag "defaultPropagationRouteTable"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.creation_time
               (fun f ->
                  Ezxmlm.make_tag "creationTime" ([], (DateTime.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Util.option_map v.default_propagation_route_table
             (fun f ->
                ("default_propagation_route_table", (Boolean.to_json f)));
           Util.option_map v.default_association_route_table
             (fun f ->
                ("default_association_route_table", (Boolean.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (TransitGatewayRouteTableState.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f -> ("transit_gateway_route_table_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (Util.option_map (Json.lookup j "transit_gateway_route_table_id")
             String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayRouteTableState.of_json);
        default_association_route_table =
          (Util.option_map (Json.lookup j "default_association_route_table")
             Boolean.of_json);
        default_propagation_route_table =
          (Util.option_map (Json.lookup j "default_propagation_route_table")
             Boolean.of_json);
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") DateTime.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module AuthorizationRule =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option ;
      description: String.t option ;
      group_id: String.t option ;
      access_all: Boolean.t option ;
      destination_cidr: String.t option ;
      status: ClientVpnAuthorizationRuleStatus.t option }
    let make ?client_vpn_endpoint_id  ?description  ?group_id  ?access_all 
      ?destination_cidr  ?status  () =
      {
        client_vpn_endpoint_id;
        description;
        group_id;
        access_all;
        destination_cidr;
        status
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          access_all =
            (Util.option_bind (Xml.member "accessAll" xml) Boolean.parse);
          destination_cidr =
            (Util.option_bind (Xml.member "destinationCidr" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnAuthorizationRuleStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair
                   ("Status", (ClientVpnAuthorizationRuleStatus.to_query f)));
           Util.option_map v.destination_cidr
             (fun f -> Query.Pair ("DestinationCidr", (String.to_query f)));
           Util.option_map v.access_all
             (fun f -> Query.Pair ("AccessAll", (Boolean.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.client_vpn_endpoint_id
                   (fun f ->
                      Ezxmlm.make_tag "clientVpnEndpointId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.description
                  (fun f ->
                     Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
              @
              [Util.option_map v.group_id
                 (fun f -> Ezxmlm.make_tag "groupId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.access_all
                (fun f ->
                   Ezxmlm.make_tag "accessAll" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.destination_cidr
               (fun f ->
                  Ezxmlm.make_tag "destinationCidr" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "status"
                   ([], (ClientVpnAuthorizationRuleStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 ("status", (ClientVpnAuthorizationRuleStatus.to_json f)));
           Util.option_map v.destination_cidr
             (fun f -> ("destination_cidr", (String.to_json f)));
           Util.option_map v.access_all
             (fun f -> ("access_all", (Boolean.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (Util.option_map (Json.lookup j "client_vpn_endpoint_id")
             String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        access_all =
          (Util.option_map (Json.lookup j "access_all") Boolean.of_json);
        destination_cidr =
          (Util.option_map (Json.lookup j "destination_cidr") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnAuthorizationRuleStatus.of_json)
      }
  end
module TransitGatewayMulticastDomainAssociation =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option ;
      resource_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      subnet: SubnetAssociation.t option }
    let make ?transit_gateway_attachment_id  ?resource_id  ?resource_type 
      ?subnet  () =
      { transit_gateway_attachment_id; resource_id; resource_type; subnet }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          subnet =
            (Util.option_bind (Xml.member "subnet" xml)
               SubnetAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> Query.Pair ("Subnet", (SubnetAssociation.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.transit_gateway_attachment_id
                 (fun f ->
                    Ezxmlm.make_tag "transitGatewayAttachmentId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.resource_id
                (fun f ->
                   Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "resourceType"
                    ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
           @
           [Util.option_map v.subnet
              (fun f ->
                 Ezxmlm.make_tag "subnet" ([], (SubnetAssociation.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> ("subnet", (SubnetAssociation.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        subnet =
          (Util.option_map (Json.lookup j "subnet") SubnetAssociation.of_json)
      }
  end
module TrafficMirrorSessionField =
  struct
    type t =
      | Packet_length 
      | Description 
      | Virtual_network_id 
    let str_to_t =
      [("virtual-network-id", Virtual_network_id);
      ("description", Description);
      ("packet-length", Packet_length)]
    let t_to_str =
      [(Virtual_network_id, "virtual-network-id");
      (Description, "description");
      (Packet_length, "packet-length")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SuccessfulInstanceCreditSpecificationItem =
  struct
    type t = {
      instance_id: String.t option }
    let make ?instance_id  () = { instance_id }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.instance_id
              (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json)
      }
  end
module UnsuccessfulInstanceCreditSpecificationItem =
  struct
    type t =
      {
      instance_id: String.t option ;
      error: UnsuccessfulInstanceCreditSpecificationItemError.t option }
    let make ?instance_id  ?error  () = { instance_id; error }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          error =
            (Util.option_bind (Xml.member "error" xml)
               UnsuccessfulInstanceCreditSpecificationItemError.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 Query.Pair
                   ("Error",
                     (UnsuccessfulInstanceCreditSpecificationItemError.to_query
                        f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.error
              (fun f ->
                 Ezxmlm.make_tag "error"
                   ([],
                     (UnsuccessfulInstanceCreditSpecificationItemError.to_xml
                        f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 ("error",
                   (UnsuccessfulInstanceCreditSpecificationItemError.to_json
                      f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        error =
          (Util.option_map (Json.lookup j "error")
             UnsuccessfulInstanceCreditSpecificationItemError.of_json)
      }
  end
module ReservedInstancesOffering =
  struct
    type t =
      {
      availability_zone: String.t option ;
      duration: Long.t option ;
      fixed_price: Float.t option ;
      instance_type: InstanceType.t option ;
      product_description: RIProductDescription.t option ;
      reserved_instances_offering_id: String.t option ;
      usage_price: Float.t option ;
      currency_code: CurrencyCodeValues.t option ;
      instance_tenancy: Tenancy.t option ;
      marketplace: Boolean.t option ;
      offering_class: OfferingClassType.t option ;
      offering_type: OfferingTypeValues.t option ;
      pricing_details: PricingDetailsList.t ;
      recurring_charges: RecurringChargesList.t ;
      scope: Scope.t option }
    let make ?availability_zone  ?duration  ?fixed_price  ?instance_type 
      ?product_description  ?reserved_instances_offering_id  ?usage_price 
      ?currency_code  ?instance_tenancy  ?marketplace  ?offering_class 
      ?offering_type  ?(pricing_details= [])  ?(recurring_charges= []) 
      ?scope  () =
      {
        availability_zone;
        duration;
        fixed_price;
        instance_type;
        product_description;
        reserved_instances_offering_id;
        usage_price;
        currency_code;
        instance_tenancy;
        marketplace;
        offering_class;
        offering_type;
        pricing_details;
        recurring_charges;
        scope
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Long.parse);
          fixed_price =
            (Util.option_bind (Xml.member "fixedPrice" xml) Float.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          product_description =
            (Util.option_bind (Xml.member "productDescription" xml)
               RIProductDescription.parse);
          reserved_instances_offering_id =
            (Util.option_bind (Xml.member "reservedInstancesOfferingId" xml)
               String.parse);
          usage_price =
            (Util.option_bind (Xml.member "usagePrice" xml) Float.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          instance_tenancy =
            (Util.option_bind (Xml.member "instanceTenancy" xml)
               Tenancy.parse);
          marketplace =
            (Util.option_bind (Xml.member "marketplace" xml) Boolean.parse);
          offering_class =
            (Util.option_bind (Xml.member "offeringClass" xml)
               OfferingClassType.parse);
          offering_type =
            (Util.option_bind (Xml.member "offeringType" xml)
               OfferingTypeValues.parse);
          pricing_details =
            (Util.of_option []
               (Util.option_bind (Xml.member "pricingDetailsSet" xml)
                  PricingDetailsList.parse));
          recurring_charges =
            (Util.of_option []
               (Util.option_bind (Xml.member "recurringCharges" xml)
                  RecurringChargesList.parse));
          scope = (Util.option_bind (Xml.member "scope" xml) Scope.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.scope
              (fun f -> Query.Pair ("Scope", (Scope.to_query f)));
           Some
             (Query.Pair
                ("RecurringCharges",
                  (RecurringChargesList.to_query v.recurring_charges)));
           Some
             (Query.Pair
                ("PricingDetailsSet",
                  (PricingDetailsList.to_query v.pricing_details)));
           Util.option_map v.offering_type
             (fun f ->
                Query.Pair ("OfferingType", (OfferingTypeValues.to_query f)));
           Util.option_map v.offering_class
             (fun f ->
                Query.Pair ("OfferingClass", (OfferingClassType.to_query f)));
           Util.option_map v.marketplace
             (fun f -> Query.Pair ("Marketplace", (Boolean.to_query f)));
           Util.option_map v.instance_tenancy
             (fun f -> Query.Pair ("InstanceTenancy", (Tenancy.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.usage_price
             (fun f -> Query.Pair ("UsagePrice", (Float.to_query f)));
           Util.option_map v.reserved_instances_offering_id
             (fun f ->
                Query.Pair
                  ("ReservedInstancesOfferingId", (String.to_query f)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.fixed_price
             (fun f -> Query.Pair ("FixedPrice", (Float.to_query f)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Long.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Util.option_map v.availability_zone
                            (fun f ->
                               Ezxmlm.make_tag "availabilityZone"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.duration
                           (fun f ->
                              Ezxmlm.make_tag "duration"
                                ([], (Long.to_xml f)))])
                       @
                       [Util.option_map v.fixed_price
                          (fun f ->
                             Ezxmlm.make_tag "fixedPrice"
                               ([], (Float.to_xml f)))])
                      @
                      [Util.option_map v.instance_type
                         (fun f ->
                            Ezxmlm.make_tag "instanceType"
                              ([], (InstanceType.to_xml f)))])
                     @
                     [Util.option_map v.product_description
                        (fun f ->
                           Ezxmlm.make_tag "productDescription"
                             ([], (RIProductDescription.to_xml f)))])
                    @
                    [Util.option_map v.reserved_instances_offering_id
                       (fun f ->
                          Ezxmlm.make_tag "reservedInstancesOfferingId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.usage_price
                      (fun f ->
                         Ezxmlm.make_tag "usagePrice" ([], (Float.to_xml f)))])
                  @
                  [Util.option_map v.currency_code
                     (fun f ->
                        Ezxmlm.make_tag "currencyCode"
                          ([], (CurrencyCodeValues.to_xml f)))])
                 @
                 [Util.option_map v.instance_tenancy
                    (fun f ->
                       Ezxmlm.make_tag "instanceTenancy"
                         ([], (Tenancy.to_xml f)))])
                @
                [Util.option_map v.marketplace
                   (fun f ->
                      Ezxmlm.make_tag "marketplace" ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.offering_class
                  (fun f ->
                     Ezxmlm.make_tag "offeringClass"
                       ([], (OfferingClassType.to_xml f)))])
              @
              [Util.option_map v.offering_type
                 (fun f ->
                    Ezxmlm.make_tag "offeringType"
                      ([], (OfferingTypeValues.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "pricingDetailsSet"
                        ([], (PricingDetailsList.to_xml [x]))))
                v.pricing_details))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "recurringCharges"
                       ([], (RecurringChargesList.to_xml [x]))))
               v.recurring_charges))
           @
           [Util.option_map v.scope
              (fun f -> Ezxmlm.make_tag "scope" ([], (Scope.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.scope (fun f -> ("scope", (Scope.to_json f)));
           Some
             ("recurring_charges",
               (RecurringChargesList.to_json v.recurring_charges));
           Some
             ("pricing_details",
               (PricingDetailsList.to_json v.pricing_details));
           Util.option_map v.offering_type
             (fun f -> ("offering_type", (OfferingTypeValues.to_json f)));
           Util.option_map v.offering_class
             (fun f -> ("offering_class", (OfferingClassType.to_json f)));
           Util.option_map v.marketplace
             (fun f -> ("marketplace", (Boolean.to_json f)));
           Util.option_map v.instance_tenancy
             (fun f -> ("instance_tenancy", (Tenancy.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.usage_price
             (fun f -> ("usage_price", (Float.to_json f)));
           Util.option_map v.reserved_instances_offering_id
             (fun f -> ("reserved_instances_offering_id", (String.to_json f)));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.fixed_price
             (fun f -> ("fixed_price", (Float.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Long.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        duration = (Util.option_map (Json.lookup j "duration") Long.of_json);
        fixed_price =
          (Util.option_map (Json.lookup j "fixed_price") Float.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        product_description =
          (Util.option_map (Json.lookup j "product_description")
             RIProductDescription.of_json);
        reserved_instances_offering_id =
          (Util.option_map (Json.lookup j "reserved_instances_offering_id")
             String.of_json);
        usage_price =
          (Util.option_map (Json.lookup j "usage_price") Float.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        instance_tenancy =
          (Util.option_map (Json.lookup j "instance_tenancy") Tenancy.of_json);
        marketplace =
          (Util.option_map (Json.lookup j "marketplace") Boolean.of_json);
        offering_class =
          (Util.option_map (Json.lookup j "offering_class")
             OfferingClassType.of_json);
        offering_type =
          (Util.option_map (Json.lookup j "offering_type")
             OfferingTypeValues.of_json);
        pricing_details =
          (PricingDetailsList.of_json
             (Util.of_option_exn (Json.lookup j "pricing_details")));
        recurring_charges =
          (RecurringChargesList.of_json
             (Util.of_option_exn (Json.lookup j "recurring_charges")));
        scope = (Util.option_map (Json.lookup j "scope") Scope.of_json)
      }
  end
module ScheduledInstanceAvailability =
  struct
    type t =
      {
      availability_zone: String.t option ;
      available_instance_count: Integer.t option ;
      first_slot_start_time: DateTime.t option ;
      hourly_price: String.t option ;
      instance_type: String.t option ;
      max_term_duration_in_days: Integer.t option ;
      min_term_duration_in_days: Integer.t option ;
      network_platform: String.t option ;
      platform: String.t option ;
      purchase_token: String.t option ;
      recurrence: ScheduledInstanceRecurrence.t option ;
      slot_duration_in_hours: Integer.t option ;
      total_scheduled_instance_hours: Integer.t option }
    let make ?availability_zone  ?available_instance_count 
      ?first_slot_start_time  ?hourly_price  ?instance_type 
      ?max_term_duration_in_days  ?min_term_duration_in_days 
      ?network_platform  ?platform  ?purchase_token  ?recurrence 
      ?slot_duration_in_hours  ?total_scheduled_instance_hours  () =
      {
        availability_zone;
        available_instance_count;
        first_slot_start_time;
        hourly_price;
        instance_type;
        max_term_duration_in_days;
        min_term_duration_in_days;
        network_platform;
        platform;
        purchase_token;
        recurrence;
        slot_duration_in_hours;
        total_scheduled_instance_hours
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          available_instance_count =
            (Util.option_bind (Xml.member "availableInstanceCount" xml)
               Integer.parse);
          first_slot_start_time =
            (Util.option_bind (Xml.member "firstSlotStartTime" xml)
               DateTime.parse);
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          max_term_duration_in_days =
            (Util.option_bind (Xml.member "maxTermDurationInDays" xml)
               Integer.parse);
          min_term_duration_in_days =
            (Util.option_bind (Xml.member "minTermDurationInDays" xml)
               Integer.parse);
          network_platform =
            (Util.option_bind (Xml.member "networkPlatform" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          purchase_token =
            (Util.option_bind (Xml.member "purchaseToken" xml) String.parse);
          recurrence =
            (Util.option_bind (Xml.member "recurrence" xml)
               ScheduledInstanceRecurrence.parse);
          slot_duration_in_hours =
            (Util.option_bind (Xml.member "slotDurationInHours" xml)
               Integer.parse);
          total_scheduled_instance_hours =
            (Util.option_bind (Xml.member "totalScheduledInstanceHours" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_scheduled_instance_hours
              (fun f ->
                 Query.Pair
                   ("TotalScheduledInstanceHours", (Integer.to_query f)));
           Util.option_map v.slot_duration_in_hours
             (fun f ->
                Query.Pair ("SlotDurationInHours", (Integer.to_query f)));
           Util.option_map v.recurrence
             (fun f ->
                Query.Pair
                  ("Recurrence", (ScheduledInstanceRecurrence.to_query f)));
           Util.option_map v.purchase_token
             (fun f -> Query.Pair ("PurchaseToken", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.network_platform
             (fun f -> Query.Pair ("NetworkPlatform", (String.to_query f)));
           Util.option_map v.min_term_duration_in_days
             (fun f ->
                Query.Pair ("MinTermDurationInDays", (Integer.to_query f)));
           Util.option_map v.max_term_duration_in_days
             (fun f ->
                Query.Pair ("MaxTermDurationInDays", (Integer.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)));
           Util.option_map v.first_slot_start_time
             (fun f ->
                Query.Pair ("FirstSlotStartTime", (DateTime.to_query f)));
           Util.option_map v.available_instance_count
             (fun f ->
                Query.Pair ("AvailableInstanceCount", (Integer.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.availability_zone
                          (fun f ->
                             Ezxmlm.make_tag "availabilityZone"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.available_instance_count
                         (fun f ->
                            Ezxmlm.make_tag "availableInstanceCount"
                              ([], (Integer.to_xml f)))])
                     @
                     [Util.option_map v.first_slot_start_time
                        (fun f ->
                           Ezxmlm.make_tag "firstSlotStartTime"
                             ([], (DateTime.to_xml f)))])
                    @
                    [Util.option_map v.hourly_price
                       (fun f ->
                          Ezxmlm.make_tag "hourlyPrice"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.instance_type
                      (fun f ->
                         Ezxmlm.make_tag "instanceType"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.max_term_duration_in_days
                     (fun f ->
                        Ezxmlm.make_tag "maxTermDurationInDays"
                          ([], (Integer.to_xml f)))])
                 @
                 [Util.option_map v.min_term_duration_in_days
                    (fun f ->
                       Ezxmlm.make_tag "minTermDurationInDays"
                         ([], (Integer.to_xml f)))])
                @
                [Util.option_map v.network_platform
                   (fun f ->
                      Ezxmlm.make_tag "networkPlatform"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.platform
                  (fun f ->
                     Ezxmlm.make_tag "platform" ([], (String.to_xml f)))])
              @
              [Util.option_map v.purchase_token
                 (fun f ->
                    Ezxmlm.make_tag "purchaseToken" ([], (String.to_xml f)))])
             @
             [Util.option_map v.recurrence
                (fun f ->
                   Ezxmlm.make_tag "recurrence"
                     ([], (ScheduledInstanceRecurrence.to_xml f)))])
            @
            [Util.option_map v.slot_duration_in_hours
               (fun f ->
                  Ezxmlm.make_tag "slotDurationInHours"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.total_scheduled_instance_hours
              (fun f ->
                 Ezxmlm.make_tag "totalScheduledInstanceHours"
                   ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_scheduled_instance_hours
              (fun f ->
                 ("total_scheduled_instance_hours", (Integer.to_json f)));
           Util.option_map v.slot_duration_in_hours
             (fun f -> ("slot_duration_in_hours", (Integer.to_json f)));
           Util.option_map v.recurrence
             (fun f ->
                ("recurrence", (ScheduledInstanceRecurrence.to_json f)));
           Util.option_map v.purchase_token
             (fun f -> ("purchase_token", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.network_platform
             (fun f -> ("network_platform", (String.to_json f)));
           Util.option_map v.min_term_duration_in_days
             (fun f -> ("min_term_duration_in_days", (Integer.to_json f)));
           Util.option_map v.max_term_duration_in_days
             (fun f -> ("max_term_duration_in_days", (Integer.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)));
           Util.option_map v.first_slot_start_time
             (fun f -> ("first_slot_start_time", (DateTime.to_json f)));
           Util.option_map v.available_instance_count
             (fun f -> ("available_instance_count", (Integer.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        available_instance_count =
          (Util.option_map (Json.lookup j "available_instance_count")
             Integer.of_json);
        first_slot_start_time =
          (Util.option_map (Json.lookup j "first_slot_start_time")
             DateTime.of_json);
        hourly_price =
          (Util.option_map (Json.lookup j "hourly_price") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        max_term_duration_in_days =
          (Util.option_map (Json.lookup j "max_term_duration_in_days")
             Integer.of_json);
        min_term_duration_in_days =
          (Util.option_map (Json.lookup j "min_term_duration_in_days")
             Integer.of_json);
        network_platform =
          (Util.option_map (Json.lookup j "network_platform") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") String.of_json);
        purchase_token =
          (Util.option_map (Json.lookup j "purchase_token") String.of_json);
        recurrence =
          (Util.option_map (Json.lookup j "recurrence")
             ScheduledInstanceRecurrence.of_json);
        slot_duration_in_hours =
          (Util.option_map (Json.lookup j "slot_duration_in_hours")
             Integer.of_json);
        total_scheduled_instance_hours =
          (Util.option_map (Json.lookup j "total_scheduled_instance_hours")
             Integer.of_json)
      }
  end
module Reservation =
  struct
    type t =
      {
      groups: GroupIdentifierList.t ;
      instances: InstanceList.t ;
      owner_id: String.t ;
      requester_id: String.t option ;
      reservation_id: String.t }
    let make ?(groups= [])  ?(instances= [])  ~owner_id  ?requester_id 
      ~reservation_id  () =
      { groups; instances; owner_id; requester_id; reservation_id }
    let parse xml =
      Some
        {
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceList.parse));
          owner_id =
            (Xml.required "ownerId"
               (Util.option_bind (Xml.member "ownerId" xml) String.parse));
          requester_id =
            (Util.option_bind (Xml.member "requesterId" xml) String.parse);
          reservation_id =
            (Xml.required "reservationId"
               (Util.option_bind (Xml.member "reservationId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservationId", (String.to_query v.reservation_id)));
           Util.option_map v.requester_id
             (fun f -> Query.Pair ("RequesterId", (String.to_query f)));
           Some (Query.Pair ("OwnerId", (String.to_query v.owner_id)));
           Some
             (Query.Pair
                ("InstancesSet", (InstanceList.to_query v.instances)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "groupSet"
                          ([], (GroupIdentifierList.to_xml [x])))) v.groups))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "instancesSet"
                         ([], (InstanceList.to_xml [x])))) v.instances))
             @
             [Some
                (Ezxmlm.make_tag "ownerId" ([], (String.to_xml v.owner_id)))])
            @
            [Util.option_map v.requester_id
               (fun f ->
                  Ezxmlm.make_tag "requesterId" ([], (String.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "reservationId"
                 ([], (String.to_xml v.reservation_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("reservation_id", (String.to_json v.reservation_id));
           Util.option_map v.requester_id
             (fun f -> ("requester_id", (String.to_json f)));
           Some ("owner_id", (String.to_json v.owner_id));
           Some ("instances", (InstanceList.to_json v.instances));
           Some ("groups", (GroupIdentifierList.to_json v.groups))])
    let of_json j =
      {
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        instances =
          (InstanceList.of_json
             (Util.of_option_exn (Json.lookup j "instances")));
        owner_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "owner_id")));
        requester_id =
          (Util.option_map (Json.lookup j "requester_id") String.of_json);
        reservation_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "reservation_id")))
      }
  end
module PublicIpv4Pool =
  struct
    type t =
      {
      pool_id: String.t option ;
      description: String.t option ;
      pool_address_ranges: PublicIpv4PoolRangeSet.t ;
      total_address_count: Integer.t option ;
      total_available_address_count: Integer.t option }
    let make ?pool_id  ?description  ?(pool_address_ranges= []) 
      ?total_address_count  ?total_available_address_count  () =
      {
        pool_id;
        description;
        pool_address_ranges;
        total_address_count;
        total_available_address_count
      }
    let parse xml =
      Some
        {
          pool_id = (Util.option_bind (Xml.member "poolId" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          pool_address_ranges =
            (Util.of_option []
               (Util.option_bind (Xml.member "poolAddressRangeSet" xml)
                  PublicIpv4PoolRangeSet.parse));
          total_address_count =
            (Util.option_bind (Xml.member "totalAddressCount" xml)
               Integer.parse);
          total_available_address_count =
            (Util.option_bind (Xml.member "totalAvailableAddressCount" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_available_address_count
              (fun f ->
                 Query.Pair
                   ("TotalAvailableAddressCount", (Integer.to_query f)));
           Util.option_map v.total_address_count
             (fun f -> Query.Pair ("TotalAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PoolAddressRangeSet",
                  (PublicIpv4PoolRangeSet.to_query v.pool_address_ranges)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.pool_id
             (fun f -> Query.Pair ("PoolId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.pool_id
                  (fun f -> Ezxmlm.make_tag "poolId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "poolAddressRangeSet"
                        ([], (PublicIpv4PoolRangeSet.to_xml [x]))))
                v.pool_address_ranges))
            @
            [Util.option_map v.total_address_count
               (fun f ->
                  Ezxmlm.make_tag "totalAddressCount"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.total_available_address_count
              (fun f ->
                 Ezxmlm.make_tag "totalAvailableAddressCount"
                   ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_available_address_count
              (fun f ->
                 ("total_available_address_count", (Integer.to_json f)));
           Util.option_map v.total_address_count
             (fun f -> ("total_address_count", (Integer.to_json f)));
           Some
             ("pool_address_ranges",
               (PublicIpv4PoolRangeSet.to_json v.pool_address_ranges));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.pool_id
             (fun f -> ("pool_id", (String.to_json f)))])
    let of_json j =
      {
        pool_id = (Util.option_map (Json.lookup j "pool_id") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        pool_address_ranges =
          (PublicIpv4PoolRangeSet.of_json
             (Util.of_option_exn (Json.lookup j "pool_address_ranges")));
        total_address_count =
          (Util.option_map (Json.lookup j "total_address_count")
             Integer.of_json);
        total_available_address_count =
          (Util.option_map (Json.lookup j "total_available_address_count")
             Integer.of_json)
      }
  end
module Vpc =
  struct
    type t =
      {
      cidr_block: String.t ;
      dhcp_options_id: String.t ;
      state: VpcState.t ;
      vpc_id: String.t ;
      owner_id: String.t option ;
      instance_tenancy: Tenancy.t ;
      ipv6_cidr_block_association_set: VpcIpv6CidrBlockAssociationSet.t ;
      cidr_block_association_set: VpcCidrBlockAssociationSet.t ;
      is_default: Boolean.t ;
      tags: TagList.t }
    let make ~cidr_block  ~dhcp_options_id  ~state  ~vpc_id  ?owner_id 
      ~instance_tenancy  ?(ipv6_cidr_block_association_set= []) 
      ?(cidr_block_association_set= [])  ~is_default  ?(tags= [])  () =
      {
        cidr_block;
        dhcp_options_id;
        state;
        vpc_id;
        owner_id;
        instance_tenancy;
        ipv6_cidr_block_association_set;
        cidr_block_association_set;
        is_default;
        tags
      }
    let parse xml =
      Some
        {
          cidr_block =
            (Xml.required "cidrBlock"
               (Util.option_bind (Xml.member "cidrBlock" xml) String.parse));
          dhcp_options_id =
            (Xml.required "dhcpOptionsId"
               (Util.option_bind (Xml.member "dhcpOptionsId" xml)
                  String.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml) VpcState.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse));
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          instance_tenancy =
            (Xml.required "instanceTenancy"
               (Util.option_bind (Xml.member "instanceTenancy" xml)
                  Tenancy.parse));
          ipv6_cidr_block_association_set =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ipv6CidrBlockAssociationSet" xml)
                  VpcIpv6CidrBlockAssociationSet.parse));
          cidr_block_association_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "cidrBlockAssociationSet" xml)
                  VpcCidrBlockAssociationSet.parse));
          is_default =
            (Xml.required "isDefault"
               (Util.option_bind (Xml.member "isDefault" xml) Boolean.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some (Query.Pair ("IsDefault", (Boolean.to_query v.is_default)));
           Some
             (Query.Pair
                ("CidrBlockAssociationSet",
                  (VpcCidrBlockAssociationSet.to_query
                     v.cidr_block_association_set)));
           Some
             (Query.Pair
                ("Ipv6CidrBlockAssociationSet",
                  (VpcIpv6CidrBlockAssociationSet.to_query
                     v.ipv6_cidr_block_association_set)));
           Some
             (Query.Pair
                ("InstanceTenancy", (Tenancy.to_query v.instance_tenancy)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some (Query.Pair ("State", (VpcState.to_query v.state)));
           Some
             (Query.Pair
                ("DhcpOptionsId", (String.to_query v.dhcp_options_id)));
           Some (Query.Pair ("CidrBlock", (String.to_query v.cidr_block)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Some
                       (Ezxmlm.make_tag "cidrBlock"
                          ([], (String.to_xml v.cidr_block)))])
                   @
                   [Some
                      (Ezxmlm.make_tag "dhcpOptionsId"
                         ([], (String.to_xml v.dhcp_options_id)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "state" ([], (VpcState.to_xml v.state)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "vpcId" ([], (String.to_xml v.vpc_id)))])
                @
                [Util.option_map v.owner_id
                   (fun f ->
                      Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
               @
               [Some
                  (Ezxmlm.make_tag "instanceTenancy"
                     ([], (Tenancy.to_xml v.instance_tenancy)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "ipv6CidrBlockAssociationSet"
                         ([], (VpcIpv6CidrBlockAssociationSet.to_xml [x]))))
                 v.ipv6_cidr_block_association_set))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "cidrBlockAssociationSet"
                        ([], (VpcCidrBlockAssociationSet.to_xml [x]))))
                v.cidr_block_association_set))
            @
            [Some
               (Ezxmlm.make_tag "isDefault"
                  ([], (Boolean.to_xml v.is_default)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some ("is_default", (Boolean.to_json v.is_default));
           Some
             ("cidr_block_association_set",
               (VpcCidrBlockAssociationSet.to_json
                  v.cidr_block_association_set));
           Some
             ("ipv6_cidr_block_association_set",
               (VpcIpv6CidrBlockAssociationSet.to_json
                  v.ipv6_cidr_block_association_set));
           Some ("instance_tenancy", (Tenancy.to_json v.instance_tenancy));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("state", (VpcState.to_json v.state));
           Some ("dhcp_options_id", (String.to_json v.dhcp_options_id));
           Some ("cidr_block", (String.to_json v.cidr_block))])
    let of_json j =
      {
        cidr_block =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_block")));
        dhcp_options_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_options_id")));
        state =
          (VpcState.of_json (Util.of_option_exn (Json.lookup j "state")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        instance_tenancy =
          (Tenancy.of_json
             (Util.of_option_exn (Json.lookup j "instance_tenancy")));
        ipv6_cidr_block_association_set =
          (VpcIpv6CidrBlockAssociationSet.of_json
             (Util.of_option_exn
                (Json.lookup j "ipv6_cidr_block_association_set")));
        cidr_block_association_set =
          (VpcCidrBlockAssociationSet.of_json
             (Util.of_option_exn (Json.lookup j "cidr_block_association_set")));
        is_default =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "is_default")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module LocalGateway =
  struct
    type t =
      {
      local_gateway_id: String.t option ;
      outpost_arn: String.t option ;
      owner_id: String.t option ;
      state: String.t option }
    let make ?local_gateway_id  ?outpost_arn  ?owner_id  ?state  () =
      { local_gateway_id; outpost_arn; owner_id; state }
    let parse xml =
      Some
        {
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.local_gateway_id
                 (fun f ->
                    Ezxmlm.make_tag "localGatewayId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.outpost_arn
                (fun f ->
                   Ezxmlm.make_tag "outpostArn" ([], (String.to_xml f)))])
            @
            [Util.option_map v.owner_id
               (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f -> Ezxmlm.make_tag "state" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)))])
    let of_json j =
      {
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        state = (Util.option_map (Json.lookup j "state") String.of_json)
      }
  end
module Subnet =
  struct
    type t =
      {
      availability_zone: String.t ;
      availability_zone_id: String.t option ;
      available_ip_address_count: Integer.t ;
      cidr_block: String.t ;
      default_for_az: Boolean.t ;
      map_public_ip_on_launch: Boolean.t ;
      state: SubnetState.t ;
      subnet_id: String.t ;
      vpc_id: String.t ;
      owner_id: String.t option ;
      assign_ipv6_address_on_creation: Boolean.t option ;
      ipv6_cidr_block_association_set: SubnetIpv6CidrBlockAssociationSet.t ;
      tags: TagList.t ;
      subnet_arn: String.t option ;
      outpost_arn: String.t option }
    let make ~availability_zone  ?availability_zone_id 
      ~available_ip_address_count  ~cidr_block  ~default_for_az 
      ~map_public_ip_on_launch  ~state  ~subnet_id  ~vpc_id  ?owner_id 
      ?assign_ipv6_address_on_creation  ?(ipv6_cidr_block_association_set=
      [])  ?(tags= [])  ?subnet_arn  ?outpost_arn  () =
      {
        availability_zone;
        availability_zone_id;
        available_ip_address_count;
        cidr_block;
        default_for_az;
        map_public_ip_on_launch;
        state;
        subnet_id;
        vpc_id;
        owner_id;
        assign_ipv6_address_on_creation;
        ipv6_cidr_block_association_set;
        tags;
        subnet_arn;
        outpost_arn
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Xml.required "availabilityZone"
               (Util.option_bind (Xml.member "availabilityZone" xml)
                  String.parse));
          availability_zone_id =
            (Util.option_bind (Xml.member "availabilityZoneId" xml)
               String.parse);
          available_ip_address_count =
            (Xml.required "availableIpAddressCount"
               (Util.option_bind (Xml.member "availableIpAddressCount" xml)
                  Integer.parse));
          cidr_block =
            (Xml.required "cidrBlock"
               (Util.option_bind (Xml.member "cidrBlock" xml) String.parse));
          default_for_az =
            (Xml.required "defaultForAz"
               (Util.option_bind (Xml.member "defaultForAz" xml)
                  Boolean.parse));
          map_public_ip_on_launch =
            (Xml.required "mapPublicIpOnLaunch"
               (Util.option_bind (Xml.member "mapPublicIpOnLaunch" xml)
                  Boolean.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml) SubnetState.parse));
          subnet_id =
            (Xml.required "subnetId"
               (Util.option_bind (Xml.member "subnetId" xml) String.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse));
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          assign_ipv6_address_on_creation =
            (Util.option_bind (Xml.member "assignIpv6AddressOnCreation" xml)
               Boolean.parse);
          ipv6_cidr_block_association_set =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ipv6CidrBlockAssociationSet" xml)
                  SubnetIpv6CidrBlockAssociationSet.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          subnet_arn =
            (Util.option_bind (Xml.member "subnetArn" xml) String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.outpost_arn
              (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.subnet_arn
             (fun f -> Query.Pair ("SubnetArn", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("Ipv6CidrBlockAssociationSet",
                  (SubnetIpv6CidrBlockAssociationSet.to_query
                     v.ipv6_cidr_block_association_set)));
           Util.option_map v.assign_ipv6_address_on_creation
             (fun f ->
                Query.Pair
                  ("AssignIpv6AddressOnCreation", (Boolean.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)));
           Some (Query.Pair ("State", (SubnetState.to_query v.state)));
           Some
             (Query.Pair
                ("MapPublicIpOnLaunch",
                  (Boolean.to_query v.map_public_ip_on_launch)));
           Some
             (Query.Pair
                ("DefaultForAz", (Boolean.to_query v.default_for_az)));
           Some (Query.Pair ("CidrBlock", (String.to_query v.cidr_block)));
           Some
             (Query.Pair
                ("AvailableIpAddressCount",
                  (Integer.to_query v.available_ip_address_count)));
           Util.option_map v.availability_zone_id
             (fun f -> Query.Pair ("AvailabilityZoneId", (String.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Some
                            (Ezxmlm.make_tag "availabilityZone"
                               ([], (String.to_xml v.availability_zone)))])
                        @
                        [Util.option_map v.availability_zone_id
                           (fun f ->
                              Ezxmlm.make_tag "availabilityZoneId"
                                ([], (String.to_xml f)))])
                       @
                       [Some
                          (Ezxmlm.make_tag "availableIpAddressCount"
                             ([],
                               (Integer.to_xml v.available_ip_address_count)))])
                      @
                      [Some
                         (Ezxmlm.make_tag "cidrBlock"
                            ([], (String.to_xml v.cidr_block)))])
                     @
                     [Some
                        (Ezxmlm.make_tag "defaultForAz"
                           ([], (Boolean.to_xml v.default_for_az)))])
                    @
                    [Some
                       (Ezxmlm.make_tag "mapPublicIpOnLaunch"
                          ([], (Boolean.to_xml v.map_public_ip_on_launch)))])
                   @
                   [Some
                      (Ezxmlm.make_tag "state"
                         ([], (SubnetState.to_xml v.state)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "subnetId"
                        ([], (String.to_xml v.subnet_id)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "vpcId" ([], (String.to_xml v.vpc_id)))])
                @
                [Util.option_map v.owner_id
                   (fun f ->
                      Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.assign_ipv6_address_on_creation
                  (fun f ->
                     Ezxmlm.make_tag "assignIpv6AddressOnCreation"
                       ([], (Boolean.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "ipv6CidrBlockAssociationSet"
                         ([], (SubnetIpv6CidrBlockAssociationSet.to_xml [x]))))
                 v.ipv6_cidr_block_association_set))
             @
             (List.map
                (fun x ->
                   Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
                v.tags))
            @
            [Util.option_map v.subnet_arn
               (fun f -> Ezxmlm.make_tag "subnetArn" ([], (String.to_xml f)))])
           @
           [Util.option_map v.outpost_arn
              (fun f -> Ezxmlm.make_tag "outpostArn" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.outpost_arn
              (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.subnet_arn
             (fun f -> ("subnet_arn", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Some
             ("ipv6_cidr_block_association_set",
               (SubnetIpv6CidrBlockAssociationSet.to_json
                  v.ipv6_cidr_block_association_set));
           Util.option_map v.assign_ipv6_address_on_creation
             (fun f ->
                ("assign_ipv6_address_on_creation", (Boolean.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("subnet_id", (String.to_json v.subnet_id));
           Some ("state", (SubnetState.to_json v.state));
           Some
             ("map_public_ip_on_launch",
               (Boolean.to_json v.map_public_ip_on_launch));
           Some ("default_for_az", (Boolean.to_json v.default_for_az));
           Some ("cidr_block", (String.to_json v.cidr_block));
           Some
             ("available_ip_address_count",
               (Integer.to_json v.available_ip_address_count));
           Util.option_map v.availability_zone_id
             (fun f -> ("availability_zone_id", (String.to_json f)));
           Some ("availability_zone", (String.to_json v.availability_zone))])
    let of_json j =
      {
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        availability_zone_id =
          (Util.option_map (Json.lookup j "availability_zone_id")
             String.of_json);
        available_ip_address_count =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "available_ip_address_count")));
        cidr_block =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_block")));
        default_for_az =
          (Boolean.of_json
             (Util.of_option_exn (Json.lookup j "default_for_az")));
        map_public_ip_on_launch =
          (Boolean.of_json
             (Util.of_option_exn (Json.lookup j "map_public_ip_on_launch")));
        state =
          (SubnetState.of_json (Util.of_option_exn (Json.lookup j "state")));
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        assign_ipv6_address_on_creation =
          (Util.option_map (Json.lookup j "assign_ipv6_address_on_creation")
             Boolean.of_json);
        ipv6_cidr_block_association_set =
          (SubnetIpv6CidrBlockAssociationSet.of_json
             (Util.of_option_exn
                (Json.lookup j "ipv6_cidr_block_association_set")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        subnet_arn =
          (Util.option_map (Json.lookup j "subnet_arn") String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json)
      }
  end
module ElasticGpus =
  struct
    type t =
      {
      elastic_gpu_id: String.t option ;
      availability_zone: String.t option ;
      elastic_gpu_type: String.t option ;
      elastic_gpu_health: ElasticGpuHealth.t option ;
      elastic_gpu_state: ElasticGpuState.t option ;
      instance_id: String.t option ;
      tags: TagList.t }
    let make ?elastic_gpu_id  ?availability_zone  ?elastic_gpu_type 
      ?elastic_gpu_health  ?elastic_gpu_state  ?instance_id  ?(tags= [])  ()
      =
      {
        elastic_gpu_id;
        availability_zone;
        elastic_gpu_type;
        elastic_gpu_health;
        elastic_gpu_state;
        instance_id;
        tags
      }
    let parse xml =
      Some
        {
          elastic_gpu_id =
            (Util.option_bind (Xml.member "elasticGpuId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          elastic_gpu_type =
            (Util.option_bind (Xml.member "elasticGpuType" xml) String.parse);
          elastic_gpu_health =
            (Util.option_bind (Xml.member "elasticGpuHealth" xml)
               ElasticGpuHealth.parse);
          elastic_gpu_state =
            (Util.option_bind (Xml.member "elasticGpuState" xml)
               ElasticGpuState.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.elastic_gpu_state
             (fun f ->
                Query.Pair ("ElasticGpuState", (ElasticGpuState.to_query f)));
           Util.option_map v.elastic_gpu_health
             (fun f ->
                Query.Pair
                  ("ElasticGpuHealth", (ElasticGpuHealth.to_query f)));
           Util.option_map v.elastic_gpu_type
             (fun f -> Query.Pair ("ElasticGpuType", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.elastic_gpu_id
             (fun f -> Query.Pair ("ElasticGpuId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.elastic_gpu_id
                    (fun f ->
                       Ezxmlm.make_tag "elasticGpuId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.availability_zone
                   (fun f ->
                      Ezxmlm.make_tag "availabilityZone"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.elastic_gpu_type
                  (fun f ->
                     Ezxmlm.make_tag "elasticGpuType" ([], (String.to_xml f)))])
              @
              [Util.option_map v.elastic_gpu_health
                 (fun f ->
                    Ezxmlm.make_tag "elasticGpuHealth"
                      ([], (ElasticGpuHealth.to_xml f)))])
             @
             [Util.option_map v.elastic_gpu_state
                (fun f ->
                   Ezxmlm.make_tag "elasticGpuState"
                     ([], (ElasticGpuState.to_xml f)))])
            @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "instanceId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.elastic_gpu_state
             (fun f -> ("elastic_gpu_state", (ElasticGpuState.to_json f)));
           Util.option_map v.elastic_gpu_health
             (fun f -> ("elastic_gpu_health", (ElasticGpuHealth.to_json f)));
           Util.option_map v.elastic_gpu_type
             (fun f -> ("elastic_gpu_type", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.elastic_gpu_id
             (fun f -> ("elastic_gpu_id", (String.to_json f)))])
    let of_json j =
      {
        elastic_gpu_id =
          (Util.option_map (Json.lookup j "elastic_gpu_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        elastic_gpu_type =
          (Util.option_map (Json.lookup j "elastic_gpu_type") String.of_json);
        elastic_gpu_health =
          (Util.option_map (Json.lookup j "elastic_gpu_health")
             ElasticGpuHealth.of_json);
        elastic_gpu_state =
          (Util.option_map (Json.lookup j "elastic_gpu_state")
             ElasticGpuState.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module VpcClassicLink =
  struct
    type t =
      {
      classic_link_enabled: Boolean.t option ;
      tags: TagList.t ;
      vpc_id: String.t option }
    let make ?classic_link_enabled  ?(tags= [])  ?vpc_id  () =
      { classic_link_enabled; tags; vpc_id }
    let parse xml =
      Some
        {
          classic_link_enabled =
            (Util.option_bind (Xml.member "classicLinkEnabled" xml)
               Boolean.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.classic_link_enabled
             (fun f ->
                Query.Pair ("ClassicLinkEnabled", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.classic_link_enabled
                (fun f ->
                   Ezxmlm.make_tag "classicLinkEnabled"
                     ([], (Boolean.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           [Util.option_map v.vpc_id
              (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.classic_link_enabled
             (fun f -> ("classic_link_enabled", (Boolean.to_json f)))])
    let of_json j =
      {
        classic_link_enabled =
          (Util.option_map (Json.lookup j "classic_link_enabled")
             Boolean.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module ImportImageTask =
  struct
    type t =
      {
      architecture: String.t option ;
      description: String.t option ;
      encrypted: Boolean.t option ;
      hypervisor: String.t option ;
      image_id: String.t option ;
      import_task_id: String.t option ;
      kms_key_id: String.t option ;
      license_type: String.t option ;
      platform: String.t option ;
      progress: String.t option ;
      snapshot_details: SnapshotDetailList.t ;
      status: String.t option ;
      status_message: String.t option ;
      tags: TagList.t ;
      license_specifications: ImportImageLicenseSpecificationListResponse.t }
    let make ?architecture  ?description  ?encrypted  ?hypervisor  ?image_id 
      ?import_task_id  ?kms_key_id  ?license_type  ?platform  ?progress 
      ?(snapshot_details= [])  ?status  ?status_message  ?(tags= []) 
      ?(license_specifications= [])  () =
      {
        architecture;
        description;
        encrypted;
        hypervisor;
        image_id;
        import_task_id;
        kms_key_id;
        license_type;
        platform;
        progress;
        snapshot_details;
        status;
        status_message;
        tags;
        license_specifications
      }
    let parse xml =
      Some
        {
          architecture =
            (Util.option_bind (Xml.member "architecture" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          hypervisor =
            (Util.option_bind (Xml.member "hypervisor" xml) String.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          license_type =
            (Util.option_bind (Xml.member "licenseType" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          snapshot_details =
            (Util.of_option []
               (Util.option_bind (Xml.member "snapshotDetailSet" xml)
                  SnapshotDetailList.parse));
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          license_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "licenseSpecifications" xml)
                  ImportImageLicenseSpecificationListResponse.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("LicenseSpecifications",
                   (ImportImageLicenseSpecificationListResponse.to_query
                      v.license_specifications)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Some
             (Query.Pair
                ("SnapshotDetailSet",
                  (SnapshotDetailList.to_query v.snapshot_details)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.license_type
             (fun f -> Query.Pair ("LicenseType", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.hypervisor
             (fun f -> Query.Pair ("Hypervisor", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.architecture
             (fun f -> Query.Pair ("Architecture", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Util.option_map v.architecture
                            (fun f ->
                               Ezxmlm.make_tag "architecture"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.description
                           (fun f ->
                              Ezxmlm.make_tag "description"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.encrypted
                          (fun f ->
                             Ezxmlm.make_tag "encrypted"
                               ([], (Boolean.to_xml f)))])
                      @
                      [Util.option_map v.hypervisor
                         (fun f ->
                            Ezxmlm.make_tag "hypervisor"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.image_id
                        (fun f ->
                           Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.import_task_id
                       (fun f ->
                          Ezxmlm.make_tag "importTaskId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.kms_key_id
                      (fun f ->
                         Ezxmlm.make_tag "kmsKeyId" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.license_type
                     (fun f ->
                        Ezxmlm.make_tag "licenseType" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.platform
                    (fun f ->
                       Ezxmlm.make_tag "platform" ([], (String.to_xml f)))])
                @
                [Util.option_map v.progress
                   (fun f ->
                      Ezxmlm.make_tag "progress" ([], (String.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "snapshotDetailSet"
                          ([], (SnapshotDetailList.to_xml [x]))))
                  v.snapshot_details))
              @
              [Util.option_map v.status
                 (fun f -> Ezxmlm.make_tag "status" ([], (String.to_xml f)))])
             @
             [Util.option_map v.status_message
                (fun f ->
                   Ezxmlm.make_tag "statusMessage" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "licenseSpecifications"
                      ([],
                        (ImportImageLicenseSpecificationListResponse.to_xml
                           [x])))) v.license_specifications))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("license_specifications",
                (ImportImageLicenseSpecificationListResponse.to_json
                   v.license_specifications));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Some
             ("snapshot_details",
               (SnapshotDetailList.to_json v.snapshot_details));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.license_type
             (fun f -> ("license_type", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.hypervisor
             (fun f -> ("hypervisor", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.architecture
             (fun f -> ("architecture", (String.to_json f)))])
    let of_json j =
      {
        architecture =
          (Util.option_map (Json.lookup j "architecture") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        hypervisor =
          (Util.option_map (Json.lookup j "hypervisor") String.of_json);
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        license_type =
          (Util.option_map (Json.lookup j "license_type") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") String.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        snapshot_details =
          (SnapshotDetailList.of_json
             (Util.of_option_exn (Json.lookup j "snapshot_details")));
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        license_specifications =
          (ImportImageLicenseSpecificationListResponse.of_json
             (Util.of_option_exn (Json.lookup j "license_specifications")))
      }
  end
module SpotPrice =
  struct
    type t =
      {
      availability_zone: String.t option ;
      instance_type: InstanceType.t option ;
      product_description: RIProductDescription.t option ;
      spot_price: String.t option ;
      timestamp: DateTime.t option }
    let make ?availability_zone  ?instance_type  ?product_description 
      ?spot_price  ?timestamp  () =
      {
        availability_zone;
        instance_type;
        product_description;
        spot_price;
        timestamp
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          product_description =
            (Util.option_bind (Xml.member "productDescription" xml)
               RIProductDescription.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.availability_zone
                  (fun f ->
                     Ezxmlm.make_tag "availabilityZone"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.instance_type
                 (fun f ->
                    Ezxmlm.make_tag "instanceType"
                      ([], (InstanceType.to_xml f)))])
             @
             [Util.option_map v.product_description
                (fun f ->
                   Ezxmlm.make_tag "productDescription"
                     ([], (RIProductDescription.to_xml f)))])
            @
            [Util.option_map v.spot_price
               (fun f -> Ezxmlm.make_tag "spotPrice" ([], (String.to_xml f)))])
           @
           [Util.option_map v.timestamp
              (fun f -> Ezxmlm.make_tag "timestamp" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        product_description =
          (Util.option_map (Json.lookup j "product_description")
             RIProductDescription.of_json);
        spot_price =
          (Util.option_map (Json.lookup j "spot_price") String.of_json);
        timestamp =
          (Util.option_map (Json.lookup j "timestamp") DateTime.of_json)
      }
  end
module ReportInstanceReasonCodes =
  struct
    type t =
      | Instance_stuck_in_state 
      | Unresponsive 
      | Not_accepting_credentials 
      | Password_not_available 
      | Performance_network 
      | Performance_instance_store 
      | Performance_ebs_volume 
      | Performance_other 
      | Other 
    let str_to_t =
      [("other", Other);
      ("performance-other", Performance_other);
      ("performance-ebs-volume", Performance_ebs_volume);
      ("performance-instance-store", Performance_instance_store);
      ("performance-network", Performance_network);
      ("password-not-available", Password_not_available);
      ("not-accepting-credentials", Not_accepting_credentials);
      ("unresponsive", Unresponsive);
      ("instance-stuck-in-state", Instance_stuck_in_state)]
    let t_to_str =
      [(Other, "other");
      (Performance_other, "performance-other");
      (Performance_ebs_volume, "performance-ebs-volume");
      (Performance_instance_store, "performance-instance-store");
      (Performance_network, "performance-network");
      (Password_not_available, "password-not-available");
      (Not_accepting_credentials, "not-accepting-credentials");
      (Unresponsive, "unresponsive");
      (Instance_stuck_in_state, "instance-stuck-in-state")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceCreditSpecificationRequest =
  struct
    type t = {
      instance_id: String.t option ;
      cpu_credits: String.t option }
    let make ?instance_id  ?cpu_credits  () = { instance_id; cpu_credits }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          cpu_credits =
            (Util.option_bind (Xml.member "CpuCredits" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> Query.Pair ("CpuCredits", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "InstanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.cpu_credits
              (fun f -> Ezxmlm.make_tag "CpuCredits" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> ("cpu_credits", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        cpu_credits =
          (Util.option_map (Json.lookup j "cpu_credits") String.of_json)
      }
  end
module OccurrenceDayRequestSet =
  struct
    type t = Integer.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Integer.parse (Xml.members "OccurenceDay" xml))
    let to_query v = Query.to_query_list Integer.to_query v
    let to_headers v = Headers.to_headers_list Integer.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Integer.to_xml x))) v
    let to_json v = `List (List.map Integer.to_json v)
    let of_json j = Json.to_list Integer.of_json j
  end
module ImageDiskContainer =
  struct
    type t =
      {
      description: String.t option ;
      device_name: String.t option ;
      format: String.t option ;
      snapshot_id: String.t option ;
      url: String.t option ;
      user_bucket: UserBucket.t option }
    let make ?description  ?device_name  ?format  ?snapshot_id  ?url 
      ?user_bucket  () =
      { description; device_name; format; snapshot_id; url; user_bucket }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          device_name =
            (Util.option_bind (Xml.member "DeviceName" xml) String.parse);
          format = (Util.option_bind (Xml.member "Format" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "SnapshotId" xml) String.parse);
          url = (Util.option_bind (Xml.member "Url" xml) String.parse);
          user_bucket =
            (Util.option_bind (Xml.member "UserBucket" xml) UserBucket.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> Query.Pair ("UserBucket", (UserBucket.to_query f)));
           Util.option_map v.url
             (fun f -> Query.Pair ("Url", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (String.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.description
                   (fun f ->
                      Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
               @
               [Util.option_map v.device_name
                  (fun f ->
                     Ezxmlm.make_tag "DeviceName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.format
                 (fun f -> Ezxmlm.make_tag "Format" ([], (String.to_xml f)))])
             @
             [Util.option_map v.snapshot_id
                (fun f ->
                   Ezxmlm.make_tag "SnapshotId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.url
               (fun f -> Ezxmlm.make_tag "Url" ([], (String.to_xml f)))])
           @
           [Util.option_map v.user_bucket
              (fun f ->
                 Ezxmlm.make_tag "UserBucket" ([], (UserBucket.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> ("user_bucket", (UserBucket.to_json f)));
           Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.format (fun f -> ("format", (String.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        format = (Util.option_map (Json.lookup j "format") String.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        url = (Util.option_map (Json.lookup j "url") String.of_json);
        user_bucket =
          (Util.option_map (Json.lookup j "user_bucket") UserBucket.of_json)
      }
  end
module ImportImageLicenseConfigurationRequest =
  struct
    type t = {
      license_configuration_arn: String.t option }
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "LicenseConfigurationArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Ezxmlm.make_tag "LicenseConfigurationArn"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let of_json j =
      {
        license_configuration_arn =
          (Util.option_map (Json.lookup j "license_configuration_arn")
             String.of_json)
      }
  end
module LocalGatewayRoute =
  struct
    type t =
      {
      destination_cidr_block: String.t option ;
      local_gateway_virtual_interface_group_id: String.t option ;
      type_: LocalGatewayRouteType.t option ;
      state: LocalGatewayRouteState.t option ;
      local_gateway_route_table_id: String.t option }
    let make ?destination_cidr_block 
      ?local_gateway_virtual_interface_group_id  ?type_  ?state 
      ?local_gateway_route_table_id  () =
      {
        destination_cidr_block;
        local_gateway_virtual_interface_group_id;
        type_;
        state;
        local_gateway_route_table_id
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          local_gateway_virtual_interface_group_id =
            (Util.option_bind
               (Xml.member "localGatewayVirtualInterfaceGroupId" xml)
               String.parse);
          type_ =
            (Util.option_bind (Xml.member "type" xml)
               LocalGatewayRouteType.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               LocalGatewayRouteState.parse);
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_id
              (fun f ->
                 Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (LocalGatewayRouteState.to_query f)));
           Util.option_map v.type_
             (fun f ->
                Query.Pair ("Type", (LocalGatewayRouteType.to_query f)));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayVirtualInterfaceGroupId",
                    (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.destination_cidr_block
                  (fun f ->
                     Ezxmlm.make_tag "destinationCidrBlock"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.local_gateway_virtual_interface_group_id
                 (fun f ->
                    Ezxmlm.make_tag "localGatewayVirtualInterfaceGroupId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.type_
                (fun f ->
                   Ezxmlm.make_tag "type"
                     ([], (LocalGatewayRouteType.to_xml f)))])
            @
            [Util.option_map v.state
               (fun f ->
                  Ezxmlm.make_tag "state"
                    ([], (LocalGatewayRouteState.to_xml f)))])
           @
           [Util.option_map v.local_gateway_route_table_id
              (fun f ->
                 Ezxmlm.make_tag "localGatewayRouteTableId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_id
              (fun f -> ("local_gateway_route_table_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (LocalGatewayRouteState.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (LocalGatewayRouteType.to_json f)));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                ("local_gateway_virtual_interface_group_id",
                  (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        local_gateway_virtual_interface_group_id =
          (Util.option_map
             (Json.lookup j "local_gateway_virtual_interface_group_id")
             String.of_json);
        type_ =
          (Util.option_map (Json.lookup j "type_")
             LocalGatewayRouteType.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             LocalGatewayRouteState.of_json);
        local_gateway_route_table_id =
          (Util.option_map (Json.lookup j "local_gateway_route_table_id")
             String.of_json)
      }
  end
module ScheduledInstancesBlockDeviceMappingSet =
  struct
    type t = ScheduledInstancesBlockDeviceMapping.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ScheduledInstancesBlockDeviceMapping.parse
           (Xml.members "BlockDeviceMapping" xml))
    let to_query v =
      Query.to_query_list ScheduledInstancesBlockDeviceMapping.to_query v
    let to_headers v =
      Headers.to_headers_list ScheduledInstancesBlockDeviceMapping.to_headers
        v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ScheduledInstancesBlockDeviceMapping.to_xml x))) v
    let to_json v =
      `List (List.map ScheduledInstancesBlockDeviceMapping.to_json v)
    let of_json j =
      Json.to_list ScheduledInstancesBlockDeviceMapping.of_json j
  end
module ScheduledInstancesIamInstanceProfile =
  struct
    type t = {
      arn: String.t option ;
      name: String.t option }
    let make ?arn  ?name  () = { arn; name }
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "Arn" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.arn
               (fun f -> Ezxmlm.make_tag "Arn" ([], (String.to_xml f)))])
           @
           [Util.option_map v.name
              (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      {
        arn = (Util.option_map (Json.lookup j "arn") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json)
      }
  end
module ScheduledInstancesMonitoring =
  struct
    type t = {
      enabled: Boolean.t option }
    let make ?enabled  () = { enabled }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.enabled
              (fun f -> Ezxmlm.make_tag "Enabled" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      { enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json)
      }
  end
module ScheduledInstancesNetworkInterfaceSet =
  struct
    type t = ScheduledInstancesNetworkInterface.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ScheduledInstancesNetworkInterface.parse
           (Xml.members "NetworkInterface" xml))
    let to_query v =
      Query.to_query_list ScheduledInstancesNetworkInterface.to_query v
    let to_headers v =
      Headers.to_headers_list ScheduledInstancesNetworkInterface.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ScheduledInstancesNetworkInterface.to_xml x))) v
    let to_json v =
      `List (List.map ScheduledInstancesNetworkInterface.to_json v)
    let of_json j = Json.to_list ScheduledInstancesNetworkInterface.of_json j
  end
module ScheduledInstancesPlacement =
  struct
    type t =
      {
      availability_zone: String.t option ;
      group_name: String.t option }
    let make ?availability_zone  ?group_name  () =
      { availability_zone; group_name }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.availability_zone
               (fun f ->
                  Ezxmlm.make_tag "AvailabilityZone" ([], (String.to_xml f)))])
           @
           [Util.option_map v.group_name
              (fun f -> Ezxmlm.make_tag "GroupName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json)
      }
  end
module NatGateway =
  struct
    type t =
      {
      create_time: DateTime.t option ;
      delete_time: DateTime.t option ;
      failure_code: String.t option ;
      failure_message: String.t option ;
      nat_gateway_addresses: NatGatewayAddressList.t ;
      nat_gateway_id: String.t option ;
      provisioned_bandwidth: ProvisionedBandwidth.t option ;
      state: NatGatewayState.t option ;
      subnet_id: String.t option ;
      vpc_id: String.t option ;
      tags: TagList.t }
    let make ?create_time  ?delete_time  ?failure_code  ?failure_message 
      ?(nat_gateway_addresses= [])  ?nat_gateway_id  ?provisioned_bandwidth 
      ?state  ?subnet_id  ?vpc_id  ?(tags= [])  () =
      {
        create_time;
        delete_time;
        failure_code;
        failure_message;
        nat_gateway_addresses;
        nat_gateway_id;
        provisioned_bandwidth;
        state;
        subnet_id;
        vpc_id;
        tags
      }
    let parse xml =
      Some
        {
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          delete_time =
            (Util.option_bind (Xml.member "deleteTime" xml) DateTime.parse);
          failure_code =
            (Util.option_bind (Xml.member "failureCode" xml) String.parse);
          failure_message =
            (Util.option_bind (Xml.member "failureMessage" xml) String.parse);
          nat_gateway_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "natGatewayAddressSet" xml)
                  NatGatewayAddressList.parse));
          nat_gateway_id =
            (Util.option_bind (Xml.member "natGatewayId" xml) String.parse);
          provisioned_bandwidth =
            (Util.option_bind (Xml.member "provisionedBandwidth" xml)
               ProvisionedBandwidth.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) NatGatewayState.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (NatGatewayState.to_query f)));
           Util.option_map v.provisioned_bandwidth
             (fun f ->
                Query.Pair
                  ("ProvisionedBandwidth", (ProvisionedBandwidth.to_query f)));
           Util.option_map v.nat_gateway_id
             (fun f -> Query.Pair ("NatGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("NatGatewayAddressSet",
                  (NatGatewayAddressList.to_query v.nat_gateway_addresses)));
           Util.option_map v.failure_message
             (fun f -> Query.Pair ("FailureMessage", (String.to_query f)));
           Util.option_map v.failure_code
             (fun f -> Query.Pair ("FailureCode", (String.to_query f)));
           Util.option_map v.delete_time
             (fun f -> Query.Pair ("DeleteTime", (DateTime.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.create_time
                        (fun f ->
                           Ezxmlm.make_tag "createTime"
                             ([], (DateTime.to_xml f)))])
                    @
                    [Util.option_map v.delete_time
                       (fun f ->
                          Ezxmlm.make_tag "deleteTime"
                            ([], (DateTime.to_xml f)))])
                   @
                   [Util.option_map v.failure_code
                      (fun f ->
                         Ezxmlm.make_tag "failureCode"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.failure_message
                     (fun f ->
                        Ezxmlm.make_tag "failureMessage"
                          ([], (String.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "natGatewayAddressSet"
                            ([], (NatGatewayAddressList.to_xml [x]))))
                    v.nat_gateway_addresses))
                @
                [Util.option_map v.nat_gateway_id
                   (fun f ->
                      Ezxmlm.make_tag "natGatewayId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.provisioned_bandwidth
                  (fun f ->
                     Ezxmlm.make_tag "provisionedBandwidth"
                       ([], (ProvisionedBandwidth.to_xml f)))])
              @
              [Util.option_map v.state
                 (fun f ->
                    Ezxmlm.make_tag "state" ([], (NatGatewayState.to_xml f)))])
             @
             [Util.option_map v.subnet_id
                (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.vpc_id
               (fun f -> Ezxmlm.make_tag "vpcId" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "tagSet" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (NatGatewayState.to_json f)));
           Util.option_map v.provisioned_bandwidth
             (fun f ->
                ("provisioned_bandwidth", (ProvisionedBandwidth.to_json f)));
           Util.option_map v.nat_gateway_id
             (fun f -> ("nat_gateway_id", (String.to_json f)));
           Some
             ("nat_gateway_addresses",
               (NatGatewayAddressList.to_json v.nat_gateway_addresses));
           Util.option_map v.failure_message
             (fun f -> ("failure_message", (String.to_json f)));
           Util.option_map v.failure_code
             (fun f -> ("failure_code", (String.to_json f)));
           Util.option_map v.delete_time
             (fun f -> ("delete_time", (DateTime.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)))])
    let of_json j =
      {
        create_time =
          (Util.option_map (Json.lookup j "create_time") DateTime.of_json);
        delete_time =
          (Util.option_map (Json.lookup j "delete_time") DateTime.of_json);
        failure_code =
          (Util.option_map (Json.lookup j "failure_code") String.of_json);
        failure_message =
          (Util.option_map (Json.lookup j "failure_message") String.of_json);
        nat_gateway_addresses =
          (NatGatewayAddressList.of_json
             (Util.of_option_exn (Json.lookup j "nat_gateway_addresses")));
        nat_gateway_id =
          (Util.option_map (Json.lookup j "nat_gateway_id") String.of_json);
        provisioned_bandwidth =
          (Util.option_map (Json.lookup j "provisioned_bandwidth")
             ProvisionedBandwidth.of_json);
        state =
          (Util.option_map (Json.lookup j "state") NatGatewayState.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module InstanceUsage =
  struct
    type t =
      {
      account_id: String.t option ;
      used_instance_count: Integer.t option }
    let make ?account_id  ?used_instance_count  () =
      { account_id; used_instance_count }
    let parse xml =
      Some
        {
          account_id =
            (Util.option_bind (Xml.member "accountId" xml) String.parse);
          used_instance_count =
            (Util.option_bind (Xml.member "usedInstanceCount" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.used_instance_count
              (fun f ->
                 Query.Pair ("UsedInstanceCount", (Integer.to_query f)));
           Util.option_map v.account_id
             (fun f -> Query.Pair ("AccountId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.account_id
               (fun f -> Ezxmlm.make_tag "accountId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.used_instance_count
              (fun f ->
                 Ezxmlm.make_tag "usedInstanceCount" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.used_instance_count
              (fun f -> ("used_instance_count", (Integer.to_json f)));
           Util.option_map v.account_id
             (fun f -> ("account_id", (String.to_json f)))])
    let of_json j =
      {
        account_id =
          (Util.option_map (Json.lookup j "account_id") String.of_json);
        used_instance_count =
          (Util.option_map (Json.lookup j "used_instance_count")
             Integer.of_json)
      }
  end
module DescribeFastSnapshotRestoreSuccessItem =
  struct
    type t =
      {
      snapshot_id: String.t option ;
      availability_zone: String.t option ;
      state: FastSnapshotRestoreStateCode.t option ;
      state_transition_reason: String.t option ;
      owner_id: String.t option ;
      owner_alias: String.t option ;
      enabling_time: DateTime.t option ;
      optimizing_time: DateTime.t option ;
      enabled_time: DateTime.t option ;
      disabling_time: DateTime.t option ;
      disabled_time: DateTime.t option }
    let make ?snapshot_id  ?availability_zone  ?state 
      ?state_transition_reason  ?owner_id  ?owner_alias  ?enabling_time 
      ?optimizing_time  ?enabled_time  ?disabling_time  ?disabled_time  () =
      {
        snapshot_id;
        availability_zone;
        state;
        state_transition_reason;
        owner_id;
        owner_alias;
        enabling_time;
        optimizing_time;
        enabled_time;
        disabling_time;
        disabled_time
      }
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               FastSnapshotRestoreStateCode.parse);
          state_transition_reason =
            (Util.option_bind (Xml.member "stateTransitionReason" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          owner_alias =
            (Util.option_bind (Xml.member "ownerAlias" xml) String.parse);
          enabling_time =
            (Util.option_bind (Xml.member "enablingTime" xml) DateTime.parse);
          optimizing_time =
            (Util.option_bind (Xml.member "optimizingTime" xml)
               DateTime.parse);
          enabled_time =
            (Util.option_bind (Xml.member "enabledTime" xml) DateTime.parse);
          disabling_time =
            (Util.option_bind (Xml.member "disablingTime" xml) DateTime.parse);
          disabled_time =
            (Util.option_bind (Xml.member "disabledTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> Query.Pair ("DisabledTime", (DateTime.to_query f)));
           Util.option_map v.disabling_time
             (fun f -> Query.Pair ("DisablingTime", (DateTime.to_query f)));
           Util.option_map v.enabled_time
             (fun f -> Query.Pair ("EnabledTime", (DateTime.to_query f)));
           Util.option_map v.optimizing_time
             (fun f -> Query.Pair ("OptimizingTime", (DateTime.to_query f)));
           Util.option_map v.enabling_time
             (fun f -> Query.Pair ("EnablingTime", (DateTime.to_query f)));
           Util.option_map v.owner_alias
             (fun f -> Query.Pair ("OwnerAlias", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.state_transition_reason
             (fun f ->
                Query.Pair ("StateTransitionReason", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (FastSnapshotRestoreStateCode.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.snapshot_id
                        (fun f ->
                           Ezxmlm.make_tag "snapshotId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.availability_zone
                       (fun f ->
                          Ezxmlm.make_tag "availabilityZone"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.state
                      (fun f ->
                         Ezxmlm.make_tag "state"
                           ([], (FastSnapshotRestoreStateCode.to_xml f)))])
                  @
                  [Util.option_map v.state_transition_reason
                     (fun f ->
                        Ezxmlm.make_tag "stateTransitionReason"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.owner_id
                    (fun f ->
                       Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.owner_alias
                   (fun f ->
                      Ezxmlm.make_tag "ownerAlias" ([], (String.to_xml f)))])
               @
               [Util.option_map v.enabling_time
                  (fun f ->
                     Ezxmlm.make_tag "enablingTime" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.optimizing_time
                 (fun f ->
                    Ezxmlm.make_tag "optimizingTime"
                      ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.enabled_time
                (fun f ->
                   Ezxmlm.make_tag "enabledTime" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.disabling_time
               (fun f ->
                  Ezxmlm.make_tag "disablingTime" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.disabled_time
              (fun f ->
                 Ezxmlm.make_tag "disabledTime" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> ("disabled_time", (DateTime.to_json f)));
           Util.option_map v.disabling_time
             (fun f -> ("disabling_time", (DateTime.to_json f)));
           Util.option_map v.enabled_time
             (fun f -> ("enabled_time", (DateTime.to_json f)));
           Util.option_map v.optimizing_time
             (fun f -> ("optimizing_time", (DateTime.to_json f)));
           Util.option_map v.enabling_time
             (fun f -> ("enabling_time", (DateTime.to_json f)));
           Util.option_map v.owner_alias
             (fun f -> ("owner_alias", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.state_transition_reason
             (fun f -> ("state_transition_reason", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (FastSnapshotRestoreStateCode.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let of_json j =
      {
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             FastSnapshotRestoreStateCode.of_json);
        state_transition_reason =
          (Util.option_map (Json.lookup j "state_transition_reason")
             String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        owner_alias =
          (Util.option_map (Json.lookup j "owner_alias") String.of_json);
        enabling_time =
          (Util.option_map (Json.lookup j "enabling_time") DateTime.of_json);
        optimizing_time =
          (Util.option_map (Json.lookup j "optimizing_time") DateTime.of_json);
        enabled_time =
          (Util.option_map (Json.lookup j "enabled_time") DateTime.of_json);
        disabling_time =
          (Util.option_map (Json.lookup j "disabling_time") DateTime.of_json);
        disabled_time =
          (Util.option_map (Json.lookup j "disabled_time") DateTime.of_json)
      }
  end
module EgressOnlyInternetGateway =
  struct
    type t =
      {
      attachments: InternetGatewayAttachmentList.t ;
      egress_only_internet_gateway_id: String.t option }
    let make ?(attachments= [])  ?egress_only_internet_gateway_id  () =
      { attachments; egress_only_internet_gateway_id }
    let parse xml =
      Some
        {
          attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "attachmentSet" xml)
                  InternetGatewayAttachmentList.parse));
          egress_only_internet_gateway_id =
            (Util.option_bind (Xml.member "egressOnlyInternetGatewayId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.egress_only_internet_gateway_id
              (fun f ->
                 Query.Pair
                   ("EgressOnlyInternetGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("AttachmentSet",
                  (InternetGatewayAttachmentList.to_query v.attachments)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "attachmentSet"
                       ([], (InternetGatewayAttachmentList.to_xml [x]))))
               v.attachments))
           @
           [Util.option_map v.egress_only_internet_gateway_id
              (fun f ->
                 Ezxmlm.make_tag "egressOnlyInternetGatewayId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.egress_only_internet_gateway_id
              (fun f ->
                 ("egress_only_internet_gateway_id", (String.to_json f)));
           Some
             ("attachments",
               (InternetGatewayAttachmentList.to_json v.attachments))])
    let of_json j =
      {
        attachments =
          (InternetGatewayAttachmentList.of_json
             (Util.of_option_exn (Json.lookup j "attachments")));
        egress_only_internet_gateway_id =
          (Util.option_map (Json.lookup j "egress_only_internet_gateway_id")
             String.of_json)
      }
  end
module LoadPermissionListRequest =
  struct
    type t = LoadPermissionRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LoadPermissionRequest.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LoadPermissionRequest.to_query v
    let to_headers v =
      Headers.to_headers_list LoadPermissionRequest.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (LoadPermissionRequest.to_xml x))) v
    let to_json v = `List (List.map LoadPermissionRequest.to_json v)
    let of_json j = Json.to_list LoadPermissionRequest.of_json j
  end
module CapacityReservationIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module FilterList =
  struct
    type t = Filter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Filter.parse (Xml.members "Filter" xml))
    let to_query v = Query.to_query_list Filter.to_query v
    let to_headers v = Headers.to_headers_list Filter.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Filter.to_xml x))) v
    let to_json v = `List (List.map Filter.to_json v)
    let of_json j = Json.to_list Filter.of_json j
  end
module BlockDeviceMappingRequestList =
  struct
    type t = BlockDeviceMapping.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map BlockDeviceMapping.parse
           (Xml.members "BlockDeviceMapping" xml))
    let to_query v = Query.to_query_list BlockDeviceMapping.to_query v
    let to_headers v =
      Headers.to_headers_list BlockDeviceMapping.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (BlockDeviceMapping.to_xml x))) v
    let to_json v = `List (List.map BlockDeviceMapping.to_json v)
    let of_json j = Json.to_list BlockDeviceMapping.of_json j
  end
module TagSpecificationList =
  struct
    type t = TagSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TagSpecification.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TagSpecification.to_query v
    let to_headers v = Headers.to_headers_list TagSpecification.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (TagSpecification.to_xml x)))
        v
    let to_json v = `List (List.map TagSpecification.to_json v)
    let of_json j = Json.to_list TagSpecification.of_json j
  end
module TagDescriptionList =
  struct
    type t = TagDescription.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TagDescription.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TagDescription.to_query v
    let to_headers v = Headers.to_headers_list TagDescription.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (TagDescription.to_xml x))) v
    let to_json v = `List (List.map TagDescription.to_json v)
    let of_json j = Json.to_list TagDescription.of_json j
  end
module DhcpOptionsList =
  struct
    type t = DhcpOptions.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map DhcpOptions.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DhcpOptions.to_query v
    let to_headers v = Headers.to_headers_list DhcpOptions.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (DhcpOptions.to_xml x))) v
    let to_json v = `List (List.map DhcpOptions.to_json v)
    let of_json j = Json.to_list DhcpOptions.of_json j
  end
module VpnGatewayList =
  struct
    type t = VpnGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map VpnGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpnGateway.to_query v
    let to_headers v = Headers.to_headers_list VpnGateway.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VpnGateway.to_xml x))) v
    let to_json v = `List (List.map VpnGateway.to_json v)
    let of_json j = Json.to_list VpnGateway.of_json j
  end
module TransitGatewayAttachmentPropagationList =
  struct
    type t = TransitGatewayAttachmentPropagation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayAttachmentPropagation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayAttachmentPropagation.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayAttachmentPropagation.to_headers
        v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayAttachmentPropagation.to_xml x))) v
    let to_json v =
      `List (List.map TransitGatewayAttachmentPropagation.to_json v)
    let of_json j =
      Json.to_list TransitGatewayAttachmentPropagation.of_json j
  end
module CapacityReservationSet =
  struct
    type t = CapacityReservation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CapacityReservation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CapacityReservation.to_query v
    let to_headers v =
      Headers.to_headers_list CapacityReservation.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (CapacityReservation.to_xml x))) v
    let to_json v = `List (List.map CapacityReservation.to_json v)
    let of_json j = Json.to_list CapacityReservation.of_json j
  end
module ElasticGpuIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ReservedInstancesModificationList =
  struct
    type t = ReservedInstancesModification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesModification.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ReservedInstancesModification.to_query v
    let to_headers v =
      Headers.to_headers_list ReservedInstancesModification.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ReservedInstancesModification.to_xml x))) v
    let to_json v = `List (List.map ReservedInstancesModification.to_json v)
    let of_json j = Json.to_list ReservedInstancesModification.of_json j
  end
module PlacementGroupList =
  struct
    type t = PlacementGroup.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PlacementGroup.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PlacementGroup.to_query v
    let to_headers v = Headers.to_headers_list PlacementGroup.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PlacementGroup.to_xml x))) v
    let to_json v = `List (List.map PlacementGroup.to_json v)
    let of_json j = Json.to_list PlacementGroup.of_json j
  end
module TransitGatewayRouteTablePropagationList =
  struct
    type t = TransitGatewayRouteTablePropagation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayRouteTablePropagation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayRouteTablePropagation.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayRouteTablePropagation.to_headers
        v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayRouteTablePropagation.to_xml x))) v
    let to_json v =
      `List (List.map TransitGatewayRouteTablePropagation.to_json v)
    let of_json j =
      Json.to_list TransitGatewayRouteTablePropagation.of_json j
  end
module KeyPairList =
  struct
    type t = KeyPairInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map KeyPairInfo.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list KeyPairInfo.to_query v
    let to_headers v = Headers.to_headers_list KeyPairInfo.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (KeyPairInfo.to_xml x))) v
    let to_json v = `List (List.map KeyPairInfo.to_json v)
    let of_json j = Json.to_list KeyPairInfo.of_json j
  end
module HistoryRecordSet =
  struct
    type t = HistoryRecordEntry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map HistoryRecordEntry.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list HistoryRecordEntry.to_query v
    let to_headers v =
      Headers.to_headers_list HistoryRecordEntry.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (HistoryRecordEntry.to_xml x))) v
    let to_json v = `List (List.map HistoryRecordEntry.to_json v)
    let of_json j = Json.to_list HistoryRecordEntry.of_json j
  end
module HostReservationSet =
  struct
    type t = HostReservation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map HostReservation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list HostReservation.to_query v
    let to_headers v = Headers.to_headers_list HostReservation.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (HostReservation.to_xml x)))
        v
    let to_json v = `List (List.map HostReservation.to_json v)
    let of_json j = Json.to_list HostReservation.of_json j
  end
module LaunchPermissionModifications =
  struct
    type t = {
      add: LaunchPermissionList.t ;
      remove: LaunchPermissionList.t }
    let make ?(add= [])  ?(remove= [])  () = { add; remove }
    let parse xml =
      Some
        {
          add =
            (Util.of_option []
               (Util.option_bind (Xml.member "Add" xml)
                  LaunchPermissionList.parse));
          remove =
            (Util.of_option []
               (Util.option_bind (Xml.member "Remove" xml)
                  LaunchPermissionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Remove", (LaunchPermissionList.to_query v.remove)));
           Some (Query.Pair ("Add", (LaunchPermissionList.to_query v.add)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Add"
                       ([], (LaunchPermissionList.to_xml [x])))) v.add))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Remove"
                      ([], (LaunchPermissionList.to_xml [x])))) v.remove))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("remove", (LaunchPermissionList.to_json v.remove));
           Some ("add", (LaunchPermissionList.to_json v.add))])
    let of_json j =
      {
        add =
          (LaunchPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "add")));
        remove =
          (LaunchPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "remove")))
      }
  end
module OperationType =
  struct
    type t =
      | Add 
      | Remove 
    let str_to_t = [("remove", Remove); ("add", Add)]
    let t_to_str = [(Remove, "remove"); (Add, "add")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ProductCodeStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "ProductCode" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module UserGroupStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "UserGroup" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module UserIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "UserId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InstanceAttributeName =
  struct
    type t =
      | InstanceType 
      | Kernel 
      | Ramdisk 
      | UserData 
      | DisableApiTermination 
      | InstanceInitiatedShutdownBehavior 
      | RootDeviceName 
      | BlockDeviceMapping 
      | ProductCodes 
      | SourceDestCheck 
      | GroupSet 
      | EbsOptimized 
      | SriovNetSupport 
      | EnaSupport 
    let str_to_t =
      [("enaSupport", EnaSupport);
      ("sriovNetSupport", SriovNetSupport);
      ("ebsOptimized", EbsOptimized);
      ("groupSet", GroupSet);
      ("sourceDestCheck", SourceDestCheck);
      ("productCodes", ProductCodes);
      ("blockDeviceMapping", BlockDeviceMapping);
      ("rootDeviceName", RootDeviceName);
      ("instanceInitiatedShutdownBehavior",
        InstanceInitiatedShutdownBehavior);
      ("disableApiTermination", DisableApiTermination);
      ("userData", UserData);
      ("ramdisk", Ramdisk);
      ("kernel", Kernel);
      ("instanceType", InstanceType)]
    let t_to_str =
      [(EnaSupport, "enaSupport");
      (SriovNetSupport, "sriovNetSupport");
      (EbsOptimized, "ebsOptimized");
      (GroupSet, "groupSet");
      (SourceDestCheck, "sourceDestCheck");
      (ProductCodes, "productCodes");
      (BlockDeviceMapping, "blockDeviceMapping");
      (RootDeviceName, "rootDeviceName");
      (InstanceInitiatedShutdownBehavior,
        "instanceInitiatedShutdownBehavior");
      (DisableApiTermination, "disableApiTermination");
      (UserData, "userData");
      (Ramdisk, "ramdisk");
      (Kernel, "kernel");
      (InstanceType, "instanceType")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RequestHostIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module CreateTransitGatewayVpcAttachmentRequestOptions =
  struct
    type t =
      {
      dns_support: DnsSupportValue.t option ;
      ipv6_support: Ipv6SupportValue.t option }
    let make ?dns_support  ?ipv6_support  () = { dns_support; ipv6_support }
    let parse xml =
      Some
        {
          dns_support =
            (Util.option_bind (Xml.member "DnsSupport" xml)
               DnsSupportValue.parse);
          ipv6_support =
            (Util.option_bind (Xml.member "Ipv6Support" xml)
               Ipv6SupportValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_support
              (fun f ->
                 Query.Pair ("Ipv6Support", (Ipv6SupportValue.to_query f)));
           Util.option_map v.dns_support
             (fun f ->
                Query.Pair ("DnsSupport", (DnsSupportValue.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dns_support
               (fun f ->
                  Ezxmlm.make_tag "DnsSupport"
                    ([], (DnsSupportValue.to_xml f)))])
           @
           [Util.option_map v.ipv6_support
              (fun f ->
                 Ezxmlm.make_tag "Ipv6Support"
                   ([], (Ipv6SupportValue.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_support
              (fun f -> ("ipv6_support", (Ipv6SupportValue.to_json f)));
           Util.option_map v.dns_support
             (fun f -> ("dns_support", (DnsSupportValue.to_json f)))])
    let of_json j =
      {
        dns_support =
          (Util.option_map (Json.lookup j "dns_support")
             DnsSupportValue.of_json);
        ipv6_support =
          (Util.option_map (Json.lookup j "ipv6_support")
             Ipv6SupportValue.of_json)
      }
  end
module LocalGatewayIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ReservedInstancesConfigurationList =
  struct
    type t = ReservedInstancesConfiguration.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesConfiguration.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ReservedInstancesConfiguration.to_query v
    let to_headers v =
      Headers.to_headers_list ReservedInstancesConfiguration.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ReservedInstancesConfiguration.to_xml x))) v
    let to_json v = `List (List.map ReservedInstancesConfiguration.to_json v)
    let of_json j = Json.to_list ReservedInstancesConfiguration.of_json j
  end
module ReservedInstancesIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ReservedInstancesId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module VpcEndpointConnectionSet =
  struct
    type t = VpcEndpointConnection.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpcEndpointConnection.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpcEndpointConnection.to_query v
    let to_headers v =
      Headers.to_headers_list VpcEndpointConnection.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (VpcEndpointConnection.to_xml x))) v
    let to_json v = `List (List.map VpcEndpointConnection.to_json v)
    let of_json j = Json.to_list VpcEndpointConnection.of_json j
  end
module GroupNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "GroupName" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ExportImageTaskList =
  struct
    type t = ExportImageTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ExportImageTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ExportImageTask.to_query v
    let to_headers v = Headers.to_headers_list ExportImageTask.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ExportImageTask.to_xml x)))
        v
    let to_json v = `List (List.map ExportImageTask.to_json v)
    let of_json j = Json.to_list ExportImageTask.of_json j
  end
module ExportTaskS3LocationRequest =
  struct
    type t = {
      s3_bucket: String.t ;
      s3_prefix: String.t option }
    let make ~s3_bucket  ?s3_prefix  () = { s3_bucket; s3_prefix }
    let parse xml =
      Some
        {
          s3_bucket =
            (Xml.required "S3Bucket"
               (Util.option_bind (Xml.member "S3Bucket" xml) String.parse));
          s3_prefix =
            (Util.option_bind (Xml.member "S3Prefix" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> Query.Pair ("S3Prefix", (String.to_query f)));
           Some (Query.Pair ("S3Bucket", (String.to_query v.s3_bucket)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "S3Bucket" ([], (String.to_xml v.s3_bucket)))])
           @
           [Util.option_map v.s3_prefix
              (fun f -> Ezxmlm.make_tag "S3Prefix" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> ("s3_prefix", (String.to_json f)));
           Some ("s3_bucket", (String.to_json v.s3_bucket))])
    let of_json j =
      {
        s3_bucket =
          (String.of_json (Util.of_option_exn (Json.lookup j "s3_bucket")));
        s3_prefix =
          (Util.option_map (Json.lookup j "s3_prefix") String.of_json)
      }
  end
module RequestSpotLaunchSpecification =
  struct
    type t =
      {
      security_group_ids: ValueStringList.t ;
      security_groups: ValueStringList.t ;
      addressing_type: String.t option ;
      block_device_mappings: BlockDeviceMappingList.t ;
      ebs_optimized: Boolean.t option ;
      iam_instance_profile: IamInstanceProfileSpecification.t option ;
      image_id: String.t option ;
      instance_type: InstanceType.t option ;
      kernel_id: String.t option ;
      key_name: String.t option ;
      monitoring: RunInstancesMonitoringEnabled.t option ;
      network_interfaces: InstanceNetworkInterfaceSpecificationList.t ;
      placement: SpotPlacement.t option ;
      ramdisk_id: String.t option ;
      subnet_id: String.t option ;
      user_data: String.t option }
    let make ?(security_group_ids= [])  ?(security_groups= []) 
      ?addressing_type  ?(block_device_mappings= [])  ?ebs_optimized 
      ?iam_instance_profile  ?image_id  ?instance_type  ?kernel_id  ?key_name
       ?monitoring  ?(network_interfaces= [])  ?placement  ?ramdisk_id 
      ?subnet_id  ?user_data  () =
      {
        security_group_ids;
        security_groups;
        addressing_type;
        block_device_mappings;
        ebs_optimized;
        iam_instance_profile;
        image_id;
        instance_type;
        kernel_id;
        key_name;
        monitoring;
        network_interfaces;
        placement;
        ramdisk_id;
        subnet_id;
        user_data
      }
    let parse xml =
      Some
        {
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  ValueStringList.parse));
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroup" xml)
                  ValueStringList.parse));
          addressing_type =
            (Util.option_bind (Xml.member "addressingType" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml)
               RunInstancesMonitoringEnabled.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterface" xml)
                  InstanceNetworkInterfaceSpecificationList.parse));
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               SpotPlacement.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (SpotPlacement.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterface",
                  (InstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair
                  ("Monitoring", (RunInstancesMonitoringEnabled.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (IamInstanceProfileSpecification.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Util.option_map v.addressing_type
             (fun f -> Query.Pair ("AddressingType", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroup",
                  (ValueStringList.to_query v.security_groups)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (ValueStringList.to_query v.security_group_ids)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((([] @
                          (List.map
                             (fun x ->
                                Some
                                  (Ezxmlm.make_tag "SecurityGroupId"
                                     ([], (ValueStringList.to_xml [x]))))
                             v.security_group_ids))
                         @
                         (List.map
                            (fun x ->
                               Some
                                 (Ezxmlm.make_tag "SecurityGroup"
                                    ([], (ValueStringList.to_xml [x]))))
                            v.security_groups))
                        @
                        [Util.option_map v.addressing_type
                           (fun f ->
                              Ezxmlm.make_tag "addressingType"
                                ([], (String.to_xml f)))])
                       @
                       (List.map
                          (fun x ->
                             Some
                               (Ezxmlm.make_tag "blockDeviceMapping"
                                  ([], (BlockDeviceMappingList.to_xml [x]))))
                          v.block_device_mappings))
                      @
                      [Util.option_map v.ebs_optimized
                         (fun f ->
                            Ezxmlm.make_tag "ebsOptimized"
                              ([], (Boolean.to_xml f)))])
                     @
                     [Util.option_map v.iam_instance_profile
                        (fun f ->
                           Ezxmlm.make_tag "iamInstanceProfile"
                             ([], (IamInstanceProfileSpecification.to_xml f)))])
                    @
                    [Util.option_map v.image_id
                       (fun f ->
                          Ezxmlm.make_tag "imageId" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.instance_type
                      (fun f ->
                         Ezxmlm.make_tag "instanceType"
                           ([], (InstanceType.to_xml f)))])
                  @
                  [Util.option_map v.kernel_id
                     (fun f ->
                        Ezxmlm.make_tag "kernelId" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.key_name
                    (fun f ->
                       Ezxmlm.make_tag "keyName" ([], (String.to_xml f)))])
                @
                [Util.option_map v.monitoring
                   (fun f ->
                      Ezxmlm.make_tag "monitoring"
                        ([], (RunInstancesMonitoringEnabled.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "NetworkInterface"
                          ([],
                            (InstanceNetworkInterfaceSpecificationList.to_xml
                               [x])))) v.network_interfaces))
              @
              [Util.option_map v.placement
                 (fun f ->
                    Ezxmlm.make_tag "placement"
                      ([], (SpotPlacement.to_xml f)))])
             @
             [Util.option_map v.ramdisk_id
                (fun f -> Ezxmlm.make_tag "ramdiskId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.subnet_id
               (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.user_data
              (fun f -> Ezxmlm.make_tag "userData" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (SpotPlacement.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Util.option_map v.monitoring
             (fun f ->
                ("monitoring", (RunInstancesMonitoringEnabled.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (IamInstanceProfileSpecification.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings));
           Util.option_map v.addressing_type
             (fun f -> ("addressing_type", (String.to_json f)));
           Some
             ("security_groups", (ValueStringList.to_json v.security_groups));
           Some
             ("security_group_ids",
               (ValueStringList.to_json v.security_group_ids))])
    let of_json j =
      {
        security_group_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        security_groups =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        addressing_type =
          (Util.option_map (Json.lookup j "addressing_type") String.of_json);
        block_device_mappings =
          (BlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfileSpecification.of_json);
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             RunInstancesMonitoringEnabled.of_json);
        network_interfaces =
          (InstanceNetworkInterfaceSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        placement =
          (Util.option_map (Json.lookup j "placement") SpotPlacement.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json)
      }
  end
module UnsuccessfulItemSet =
  struct
    type t = UnsuccessfulItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map UnsuccessfulItem.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list UnsuccessfulItem.to_query v
    let to_headers v = Headers.to_headers_list UnsuccessfulItem.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (UnsuccessfulItem.to_xml x)))
        v
    let to_json v = `List (List.map UnsuccessfulItem.to_json v)
    let of_json j = Json.to_list UnsuccessfulItem.of_json j
  end
module Status =
  struct
    type t =
      | MoveInProgress 
      | InVpc 
      | InClassic 
    let str_to_t =
      [("InClassic", InClassic);
      ("InVpc", InVpc);
      ("MoveInProgress", MoveInProgress)]
    let t_to_str =
      [(InClassic, "InClassic");
      (InVpc, "InVpc");
      (MoveInProgress, "MoveInProgress")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TransitGatewayRouteTableIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TrafficMirrorFilterSet =
  struct
    type t = TrafficMirrorFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorFilter.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TrafficMirrorFilter.to_query v
    let to_headers v =
      Headers.to_headers_list TrafficMirrorFilter.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (TrafficMirrorFilter.to_xml x))) v
    let to_json v = `List (List.map TrafficMirrorFilter.to_json v)
    let of_json j = Json.to_list TrafficMirrorFilter.of_json j
  end
module PrivateIpAddressStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "PrivateIpAddress" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayList =
  struct
    type t = TransitGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TransitGateway.to_query v
    let to_headers v = Headers.to_headers_list TransitGateway.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (TransitGateway.to_xml x))) v
    let to_json v = `List (List.map TransitGateway.to_json v)
    let of_json j = Json.to_list TransitGateway.of_json j
  end
module ClientVpnAuthenticationRequestList =
  struct
    type t = ClientVpnAuthenticationRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClientVpnAuthenticationRequest.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list ClientVpnAuthenticationRequest.to_query v
    let to_headers v =
      Headers.to_headers_list ClientVpnAuthenticationRequest.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ClientVpnAuthenticationRequest.to_xml x))) v
    let to_json v = `List (List.map ClientVpnAuthenticationRequest.to_json v)
    let of_json j = Json.to_list ClientVpnAuthenticationRequest.of_json j
  end
module ConnectionLogOptions =
  struct
    type t =
      {
      enabled: Boolean.t option ;
      cloudwatch_log_group: String.t option ;
      cloudwatch_log_stream: String.t option }
    let make ?enabled  ?cloudwatch_log_group  ?cloudwatch_log_stream  () =
      { enabled; cloudwatch_log_group; cloudwatch_log_stream }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse);
          cloudwatch_log_group =
            (Util.option_bind (Xml.member "CloudwatchLogGroup" xml)
               String.parse);
          cloudwatch_log_stream =
            (Util.option_bind (Xml.member "CloudwatchLogStream" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cloudwatch_log_stream
              (fun f ->
                 Query.Pair ("CloudwatchLogStream", (String.to_query f)));
           Util.option_map v.cloudwatch_log_group
             (fun f -> Query.Pair ("CloudwatchLogGroup", (String.to_query f)));
           Util.option_map v.enabled
             (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.enabled
                (fun f -> Ezxmlm.make_tag "Enabled" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.cloudwatch_log_group
               (fun f ->
                  Ezxmlm.make_tag "CloudwatchLogGroup"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.cloudwatch_log_stream
              (fun f ->
                 Ezxmlm.make_tag "CloudwatchLogStream"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cloudwatch_log_stream
              (fun f -> ("cloudwatch_log_stream", (String.to_json f)));
           Util.option_map v.cloudwatch_log_group
             (fun f -> ("cloudwatch_log_group", (String.to_json f)));
           Util.option_map v.enabled
             (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      {
        enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json);
        cloudwatch_log_group =
          (Util.option_map (Json.lookup j "cloudwatch_log_group")
             String.of_json);
        cloudwatch_log_stream =
          (Util.option_map (Json.lookup j "cloudwatch_log_stream")
             String.of_json)
      }
  end
module TransitGatewayPropagation =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option ;
      resource_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      transit_gateway_route_table_id: String.t option ;
      state: TransitGatewayPropagationState.t option }
    let make ?transit_gateway_attachment_id  ?resource_id  ?resource_type 
      ?transit_gateway_route_table_id  ?state  () =
      {
        transit_gateway_attachment_id;
        resource_id;
        resource_type;
        transit_gateway_route_table_id;
        state
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          transit_gateway_route_table_id =
            (Util.option_bind (Xml.member "transitGatewayRouteTableId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayPropagationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayPropagationState.to_query f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayRouteTableId", (String.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.transit_gateway_attachment_id
                  (fun f ->
                     Ezxmlm.make_tag "transitGatewayAttachmentId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.resource_id
                 (fun f ->
                    Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.resource_type
                (fun f ->
                   Ezxmlm.make_tag "resourceType"
                     ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
            @
            [Util.option_map v.transit_gateway_route_table_id
               (fun f ->
                  Ezxmlm.make_tag "transitGatewayRouteTableId"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (TransitGatewayPropagationState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayPropagationState.to_json f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f -> ("transit_gateway_route_table_id", (String.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        transit_gateway_route_table_id =
          (Util.option_map (Json.lookup j "transit_gateway_route_table_id")
             String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayPropagationState.of_json)
      }
  end
module ClassicLinkDnsSupportList =
  struct
    type t = ClassicLinkDnsSupport.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClassicLinkDnsSupport.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ClassicLinkDnsSupport.to_query v
    let to_headers v =
      Headers.to_headers_list ClassicLinkDnsSupport.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ClassicLinkDnsSupport.to_xml x))) v
    let to_json v = `List (List.map ClassicLinkDnsSupport.to_json v)
    let of_json j = Json.to_list ClassicLinkDnsSupport.of_json j
  end
module ImportTaskIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ImportTaskId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ReservedInstancesListingList =
  struct
    type t = ReservedInstancesListing.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesListing.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ReservedInstancesListing.to_query v
    let to_headers v =
      Headers.to_headers_list ReservedInstancesListing.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ReservedInstancesListing.to_xml x)))
        v
    let to_json v = `List (List.map ReservedInstancesListing.to_json v)
    let of_json j = Json.to_list ReservedInstancesListing.of_json j
  end
module InstanceStateChangeList =
  struct
    type t = InstanceStateChange.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceStateChange.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceStateChange.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceStateChange.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstanceStateChange.to_xml x))) v
    let to_json v = `List (List.map InstanceStateChange.to_json v)
    let of_json j = Json.to_list InstanceStateChange.of_json j
  end
module ClientCertificateRevocationListStatus =
  struct
    type t =
      {
      code: ClientCertificateRevocationListStatusCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               ClientCertificateRevocationListStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code",
                    (ClientCertificateRevocationListStatusCode.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.code
               (fun f ->
                  Ezxmlm.make_tag "code"
                    ([],
                      (ClientCertificateRevocationListStatusCode.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code",
                  (ClientCertificateRevocationListStatusCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             ClientCertificateRevocationListStatusCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module TerminateConnectionStatusSet =
  struct
    type t = TerminateConnectionStatus.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TerminateConnectionStatus.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TerminateConnectionStatus.to_query v
    let to_headers v =
      Headers.to_headers_list TerminateConnectionStatus.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TerminateConnectionStatus.to_xml x))) v
    let to_json v = `List (List.map TerminateConnectionStatus.to_json v)
    let of_json j = Json.to_list TerminateConnectionStatus.of_json j
  end
module InstanceTypeOfferingsList =
  struct
    type t = InstanceTypeOffering.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceTypeOffering.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceTypeOffering.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceTypeOffering.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstanceTypeOffering.to_xml x))) v
    let to_json v = `List (List.map InstanceTypeOffering.to_json v)
    let of_json j = Json.to_list InstanceTypeOffering.of_json j
  end
module InstanceStatusList =
  struct
    type t = InstanceStatus.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceStatus.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceStatus.to_query v
    let to_headers v = Headers.to_headers_list InstanceStatus.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InstanceStatus.to_xml x))) v
    let to_json v = `List (List.map InstanceStatus.to_json v)
    let of_json j = Json.to_list InstanceStatus.of_json j
  end
module ImageList =
  struct
    type t = Image.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Image.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Image.to_query v
    let to_headers v = Headers.to_headers_list Image.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Image.to_xml x))) v
    let to_json v = `List (List.map Image.to_json v)
    let of_json j = Json.to_list Image.of_json j
  end
module PriceScheduleSpecificationList =
  struct
    type t = PriceScheduleSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PriceScheduleSpecification.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list PriceScheduleSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list PriceScheduleSpecification.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (PriceScheduleSpecification.to_xml x))) v
    let to_json v = `List (List.map PriceScheduleSpecification.to_json v)
    let of_json j = Json.to_list PriceScheduleSpecification.of_json j
  end
module ImportSnapshotTaskList =
  struct
    type t = ImportSnapshotTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ImportSnapshotTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ImportSnapshotTask.to_query v
    let to_headers v =
      Headers.to_headers_list ImportSnapshotTask.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ImportSnapshotTask.to_xml x))) v
    let to_json v = `List (List.map ImportSnapshotTask.to_json v)
    let of_json j = Json.to_list ImportSnapshotTask.of_json j
  end
module NetworkInterfacePermissionList =
  struct
    type t = NetworkInterfacePermission.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkInterfacePermission.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list NetworkInterfacePermission.to_query v
    let to_headers v =
      Headers.to_headers_list NetworkInterfacePermission.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (NetworkInterfacePermission.to_xml x))) v
    let to_json v = `List (List.map NetworkInterfacePermission.to_json v)
    let of_json j = Json.to_list NetworkInterfacePermission.of_json j
  end
module SpotInstanceRequestIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "SpotInstanceRequestId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayAssociation =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t option ;
      transit_gateway_attachment_id: String.t option ;
      resource_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      state: TransitGatewayAssociationState.t option }
    let make ?transit_gateway_route_table_id  ?transit_gateway_attachment_id 
      ?resource_id  ?resource_type  ?state  () =
      {
        transit_gateway_route_table_id;
        transit_gateway_attachment_id;
        resource_id;
        resource_type;
        state
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Util.option_bind (Xml.member "transitGatewayRouteTableId" xml)
               String.parse);
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAssociationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayAssociationState.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayRouteTableId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.transit_gateway_route_table_id
                  (fun f ->
                     Ezxmlm.make_tag "transitGatewayRouteTableId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.transit_gateway_attachment_id
                 (fun f ->
                    Ezxmlm.make_tag "transitGatewayAttachmentId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.resource_id
                (fun f ->
                   Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "resourceType"
                    ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (TransitGatewayAssociationState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayAssociationState.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f -> ("transit_gateway_route_table_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (Util.option_map (Json.lookup j "transit_gateway_route_table_id")
             String.of_json);
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayAssociationState.of_json)
      }
  end
module InstanceTypeList =
  struct
    type t = InstanceType.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceType.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InstanceType.to_query v
    let to_headers v = Headers.to_headers_list InstanceType.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InstanceType.to_xml x))) v
    let to_json v = `List (List.map InstanceType.to_json v)
    let of_json j = Json.to_list InstanceType.of_json j
  end
module ProductDescriptionList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ResponseHostIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module HostList =
  struct
    type t = Host.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Host.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Host.to_query v
    let to_headers v = Headers.to_headers_list Host.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Host.to_xml x))) v
    let to_json v = `List (List.map Host.to_json v)
    let of_json j = Json.to_list Host.of_json j
  end
module CustomerGatewayIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "CustomerGatewayId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayMulticastDomainAssociations =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      transit_gateway_attachment_id: String.t option ;
      resource_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      subnets: SubnetAssociationList.t }
    let make ?transit_gateway_multicast_domain_id 
      ?transit_gateway_attachment_id  ?resource_id  ?resource_type 
      ?(subnets= [])  () =
      {
        transit_gateway_multicast_domain_id;
        transit_gateway_attachment_id;
        resource_id;
        resource_type;
        subnets
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          subnets =
            (Util.of_option []
               (Util.option_bind (Xml.member "subnets" xml)
                  SubnetAssociationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Subnets", (SubnetAssociationList.to_query v.subnets)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.transit_gateway_multicast_domain_id
                  (fun f ->
                     Ezxmlm.make_tag "transitGatewayMulticastDomainId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.transit_gateway_attachment_id
                 (fun f ->
                    Ezxmlm.make_tag "transitGatewayAttachmentId"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.resource_id
                (fun f ->
                   Ezxmlm.make_tag "resourceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.resource_type
               (fun f ->
                  Ezxmlm.make_tag "resourceType"
                    ([], (TransitGatewayAttachmentResourceType.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "subnets"
                      ([], (SubnetAssociationList.to_xml [x])))) v.subnets))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("subnets", (SubnetAssociationList.to_json v.subnets));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        subnets =
          (SubnetAssociationList.of_json
             (Util.of_option_exn (Json.lookup j "subnets")))
      }
  end
module LaunchTemplateSet =
  struct
    type t = LaunchTemplate.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplate.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LaunchTemplate.to_query v
    let to_headers v = Headers.to_headers_list LaunchTemplate.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (LaunchTemplate.to_xml x))) v
    let to_json v = `List (List.map LaunchTemplate.to_json v)
    let of_json j = Json.to_list LaunchTemplate.of_json j
  end
module PrefixListSet =
  struct
    type t = PrefixList.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map PrefixList.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PrefixList.to_query v
    let to_headers v = Headers.to_headers_list PrefixList.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PrefixList.to_xml x))) v
    let to_json v = `List (List.map PrefixList.to_json v)
    let of_json j = Json.to_list PrefixList.of_json j
  end
module VpnConnectionIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "VpnConnectionId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InstanceFamilyCreditSpecification =
  struct
    type t =
      {
      instance_family: UnlimitedSupportedInstanceFamily.t option ;
      cpu_credits: String.t option }
    let make ?instance_family  ?cpu_credits  () =
      { instance_family; cpu_credits }
    let parse xml =
      Some
        {
          instance_family =
            (Util.option_bind (Xml.member "instanceFamily" xml)
               UnlimitedSupportedInstanceFamily.parse);
          cpu_credits =
            (Util.option_bind (Xml.member "cpuCredits" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> Query.Pair ("CpuCredits", (String.to_query f)));
           Util.option_map v.instance_family
             (fun f ->
                Query.Pair
                  ("InstanceFamily",
                    (UnlimitedSupportedInstanceFamily.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_family
               (fun f ->
                  Ezxmlm.make_tag "instanceFamily"
                    ([], (UnlimitedSupportedInstanceFamily.to_xml f)))])
           @
           [Util.option_map v.cpu_credits
              (fun f -> Ezxmlm.make_tag "cpuCredits" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> ("cpu_credits", (String.to_json f)));
           Util.option_map v.instance_family
             (fun f ->
                ("instance_family",
                  (UnlimitedSupportedInstanceFamily.to_json f)))])
    let of_json j =
      {
        instance_family =
          (Util.option_map (Json.lookup j "instance_family")
             UnlimitedSupportedInstanceFamily.of_json);
        cpu_credits =
          (Util.option_map (Json.lookup j "cpu_credits") String.of_json)
      }
  end
module ActiveInstanceSet =
  struct
    type t = ActiveInstance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ActiveInstance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ActiveInstance.to_query v
    let to_headers v = Headers.to_headers_list ActiveInstance.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ActiveInstance.to_xml x))) v
    let to_json v = `List (List.map ActiveInstance.to_json v)
    let of_json j = Json.to_list ActiveInstance.of_json j
  end
module SnapshotAttributeName =
  struct
    type t =
      | ProductCodes 
      | CreateVolumePermission 
    let str_to_t =
      [("createVolumePermission", CreateVolumePermission);
      ("productCodes", ProductCodes)]
    let t_to_str =
      [(CreateVolumePermission, "createVolumePermission");
      (ProductCodes, "productCodes")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AttributeBooleanValue =
  struct
    type t = {
      value: Boolean.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) Boolean.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Boolean.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") Boolean.of_json) }
  end
module BlobAttributeValue =
  struct
    type t = {
      value: Blob.t option }
    let make ?value  () = { value }
    let parse xml =
      Some { value = (Util.option_bind (Xml.member "value" xml) Blob.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Blob.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.value
              (fun f -> Ezxmlm.make_tag "value" ([], (Blob.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Blob.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") Blob.of_json) }
  end
module InstanceBlockDeviceMappingSpecificationList =
  struct
    type t = InstanceBlockDeviceMappingSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceBlockDeviceMappingSpecification.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list InstanceBlockDeviceMappingSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list
        InstanceBlockDeviceMappingSpecification.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InstanceBlockDeviceMappingSpecification.to_xml x))) v
    let to_json v =
      `List (List.map InstanceBlockDeviceMappingSpecification.to_json v)
    let of_json j =
      Json.to_list InstanceBlockDeviceMappingSpecification.of_json j
  end
module FpgaImageAttribute =
  struct
    type t =
      {
      fpga_image_id: String.t option ;
      name: String.t option ;
      description: String.t option ;
      load_permissions: LoadPermissionList.t ;
      product_codes: ProductCodeList.t }
    let make ?fpga_image_id  ?name  ?description  ?(load_permissions= []) 
      ?(product_codes= [])  () =
      { fpga_image_id; name; description; load_permissions; product_codes }
    let parse xml =
      Some
        {
          fpga_image_id =
            (Util.option_bind (Xml.member "fpgaImageId" xml) String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          load_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "loadPermissions" xml)
                  LoadPermissionList.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Some
             (Query.Pair
                ("LoadPermissions",
                  (LoadPermissionList.to_query v.load_permissions)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.fpga_image_id
             (fun f -> Query.Pair ("FpgaImageId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.fpga_image_id
                  (fun f ->
                     Ezxmlm.make_tag "fpgaImageId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.name
                 (fun f -> Ezxmlm.make_tag "name" ([], (String.to_xml f)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "description" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "loadPermissions"
                       ([], (LoadPermissionList.to_xml [x]))))
               v.load_permissions))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "productCodes"
                      ([], (ProductCodeList.to_xml [x])))) v.product_codes))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Some
             ("load_permissions",
               (LoadPermissionList.to_json v.load_permissions));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.fpga_image_id
             (fun f -> ("fpga_image_id", (String.to_json f)))])
    let of_json j =
      {
        fpga_image_id =
          (Util.option_map (Json.lookup j "fpga_image_id") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        load_permissions =
          (LoadPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "load_permissions")));
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")))
      }
  end
module CopyTagsFromSource =
  struct
    type t =
      | Volume 
    let str_to_t = [("volume", Volume)]
    let t_to_str = [(Volume, "volume")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceSpecification =
  struct
    type t =
      {
      instance_id: String.t option ;
      exclude_boot_volume: Boolean.t option }
    let make ?instance_id  ?exclude_boot_volume  () =
      { instance_id; exclude_boot_volume }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          exclude_boot_volume =
            (Util.option_bind (Xml.member "ExcludeBootVolume" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.exclude_boot_volume
              (fun f ->
                 Query.Pair ("ExcludeBootVolume", (Boolean.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "InstanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.exclude_boot_volume
              (fun f ->
                 Ezxmlm.make_tag "ExcludeBootVolume" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.exclude_boot_volume
              (fun f -> ("exclude_boot_volume", (Boolean.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        exclude_boot_volume =
          (Util.option_map (Json.lookup j "exclude_boot_volume")
             Boolean.of_json)
      }
  end
module ZoneIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "ZoneId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ZoneNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "ZoneName" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InstanceIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "InstanceId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayMulticastDomainList =
  struct
    type t = TransitGatewayMulticastDomain.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayMulticastDomain.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayMulticastDomain.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayMulticastDomain.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TransitGatewayMulticastDomain.to_xml x))) v
    let to_json v = `List (List.map TransitGatewayMulticastDomain.to_json v)
    let of_json j = Json.to_list TransitGatewayMulticastDomain.of_json j
  end
module PrincipalIdFormatList =
  struct
    type t = PrincipalIdFormat.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PrincipalIdFormat.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PrincipalIdFormat.to_query v
    let to_headers v = Headers.to_headers_list PrincipalIdFormat.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PrincipalIdFormat.to_xml x)))
        v
    let to_json v = `List (List.map PrincipalIdFormat.to_json v)
    let of_json j = Json.to_list PrincipalIdFormat.of_json j
  end
module VpnGatewayIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "VpnGatewayId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AllowedPrincipalSet =
  struct
    type t = AllowedPrincipal.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AllowedPrincipal.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AllowedPrincipal.to_query v
    let to_headers v = Headers.to_headers_list AllowedPrincipal.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (AllowedPrincipal.to_xml x)))
        v
    let to_json v = `List (List.map AllowedPrincipal.to_json v)
    let of_json j = Json.to_list AllowedPrincipal.of_json j
  end
module ByoipCidrSet =
  struct
    type t = ByoipCidr.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map ByoipCidr.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ByoipCidr.to_query v
    let to_headers v = Headers.to_headers_list ByoipCidr.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (ByoipCidr.to_xml x)))
        v
    let to_json v = `List (List.map ByoipCidr.to_json v)
    let of_json j = Json.to_list ByoipCidr.of_json j
  end
module CoipPoolSet =
  struct
    type t = CoipPool.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map CoipPool.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CoipPool.to_query v
    let to_headers v = Headers.to_headers_list CoipPool.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (CoipPool.to_xml x)))
        v
    let to_json v = `List (List.map CoipPool.to_json v)
    let of_json j = Json.to_list CoipPool.of_json j
  end
module SpotDatafeedSubscription =
  struct
    type t =
      {
      bucket: String.t option ;
      fault: SpotInstanceStateFault.t option ;
      owner_id: String.t option ;
      prefix: String.t option ;
      state: DatafeedSubscriptionState.t option }
    let make ?bucket  ?fault  ?owner_id  ?prefix  ?state  () =
      { bucket; fault; owner_id; prefix; state }
    let parse xml =
      Some
        {
          bucket = (Util.option_bind (Xml.member "bucket" xml) String.parse);
          fault =
            (Util.option_bind (Xml.member "fault" xml)
               SpotInstanceStateFault.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          prefix = (Util.option_bind (Xml.member "prefix" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               DatafeedSubscriptionState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair ("State", (DatafeedSubscriptionState.to_query f)));
           Util.option_map v.prefix
             (fun f -> Query.Pair ("Prefix", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.fault
             (fun f ->
                Query.Pair ("Fault", (SpotInstanceStateFault.to_query f)));
           Util.option_map v.bucket
             (fun f -> Query.Pair ("Bucket", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.bucket
                  (fun f -> Ezxmlm.make_tag "bucket" ([], (String.to_xml f)))])
              @
              [Util.option_map v.fault
                 (fun f ->
                    Ezxmlm.make_tag "fault"
                      ([], (SpotInstanceStateFault.to_xml f)))])
             @
             [Util.option_map v.owner_id
                (fun f -> Ezxmlm.make_tag "ownerId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.prefix
               (fun f -> Ezxmlm.make_tag "prefix" ([], (String.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f ->
                 Ezxmlm.make_tag "state"
                   ([], (DatafeedSubscriptionState.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (DatafeedSubscriptionState.to_json f)));
           Util.option_map v.prefix (fun f -> ("prefix", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.fault
             (fun f -> ("fault", (SpotInstanceStateFault.to_json f)));
           Util.option_map v.bucket (fun f -> ("bucket", (String.to_json f)))])
    let of_json j =
      {
        bucket = (Util.option_map (Json.lookup j "bucket") String.of_json);
        fault =
          (Util.option_map (Json.lookup j "fault")
             SpotInstanceStateFault.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        prefix = (Util.option_map (Json.lookup j "prefix") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             DatafeedSubscriptionState.of_json)
      }
  end
module DeleteFleetErrorSet =
  struct
    type t = DeleteFleetErrorItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DeleteFleetErrorItem.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DeleteFleetErrorItem.to_query v
    let to_headers v =
      Headers.to_headers_list DeleteFleetErrorItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (DeleteFleetErrorItem.to_xml x))) v
    let to_json v = `List (List.map DeleteFleetErrorItem.to_json v)
    let of_json j = Json.to_list DeleteFleetErrorItem.of_json j
  end
module DeleteFleetSuccessSet =
  struct
    type t = DeleteFleetSuccessItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DeleteFleetSuccessItem.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DeleteFleetSuccessItem.to_query v
    let to_headers v =
      Headers.to_headers_list DeleteFleetSuccessItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (DeleteFleetSuccessItem.to_xml x)))
        v
    let to_json v = `List (List.map DeleteFleetSuccessItem.to_json v)
    let of_json j = Json.to_list DeleteFleetSuccessItem.of_json j
  end
module DisableFastSnapshotRestoreErrorSet =
  struct
    type t = DisableFastSnapshotRestoreErrorItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DisableFastSnapshotRestoreErrorItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list DisableFastSnapshotRestoreErrorItem.to_query v
    let to_headers v =
      Headers.to_headers_list DisableFastSnapshotRestoreErrorItem.to_headers
        v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (DisableFastSnapshotRestoreErrorItem.to_xml x))) v
    let to_json v =
      `List (List.map DisableFastSnapshotRestoreErrorItem.to_json v)
    let of_json j =
      Json.to_list DisableFastSnapshotRestoreErrorItem.of_json j
  end
module DisableFastSnapshotRestoreSuccessSet =
  struct
    type t = DisableFastSnapshotRestoreSuccessItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DisableFastSnapshotRestoreSuccessItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list DisableFastSnapshotRestoreSuccessItem.to_query v
    let to_headers v =
      Headers.to_headers_list
        DisableFastSnapshotRestoreSuccessItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (DisableFastSnapshotRestoreSuccessItem.to_xml x))) v
    let to_json v =
      `List (List.map DisableFastSnapshotRestoreSuccessItem.to_json v)
    let of_json j =
      Json.to_list DisableFastSnapshotRestoreSuccessItem.of_json j
  end
module ReservedInstancesModificationIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse
           (Xml.members "ReservedInstancesModificationId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module RequestInstanceTypeList =
  struct
    type t = InstanceType.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceType.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InstanceType.to_query v
    let to_headers v = Headers.to_headers_list InstanceType.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InstanceType.to_xml x))) v
    let to_json v = `List (List.map InstanceType.to_json v)
    let of_json j = Json.to_list InstanceType.of_json j
  end
module PlacementGroupIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "GroupId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PlacementGroupStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module Ipv6AddressList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ScheduledInstanceSet =
  struct
    type t = ScheduledInstance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ScheduledInstance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ScheduledInstance.to_query v
    let to_headers v = Headers.to_headers_list ScheduledInstance.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ScheduledInstance.to_xml x)))
        v
    let to_json v = `List (List.map ScheduledInstance.to_json v)
    let of_json j = Json.to_list ScheduledInstance.of_json j
  end
module FlowLogSet =
  struct
    type t = FlowLog.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map FlowLog.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list FlowLog.to_query v
    let to_headers v = Headers.to_headers_list FlowLog.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (FlowLog.to_xml x))) v
    let to_json v = `List (List.map FlowLog.to_json v)
    let of_json j = Json.to_list FlowLog.of_json j
  end
module BundleTaskList =
  struct
    type t = BundleTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map BundleTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list BundleTask.to_query v
    let to_headers v = Headers.to_headers_list BundleTask.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (BundleTask.to_xml x))) v
    let to_json v = `List (List.map BundleTask.to_json v)
    let of_json j = Json.to_list BundleTask.of_json j
  end
module InstanceCreditSpecificationList =
  struct
    type t = InstanceCreditSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceCreditSpecification.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list InstanceCreditSpecification.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceCreditSpecification.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InstanceCreditSpecification.to_xml x))) v
    let to_json v = `List (List.map InstanceCreditSpecification.to_json v)
    let of_json j = Json.to_list InstanceCreditSpecification.of_json j
  end
module SubnetIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "SubnetId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module CoipAddressUsageSet =
  struct
    type t = CoipAddressUsage.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CoipAddressUsage.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CoipAddressUsage.to_query v
    let to_headers v = Headers.to_headers_list CoipAddressUsage.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (CoipAddressUsage.to_xml x)))
        v
    let to_json v = `List (List.map CoipAddressUsage.to_json v)
    let of_json j = Json.to_list CoipAddressUsage.of_json j
  end
module ReservedInstanceIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ReservedInstanceId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TargetConfigurationRequestSet =
  struct
    type t = TargetConfigurationRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TargetConfigurationRequest.parse
           (Xml.members "TargetConfigurationRequest" xml))
    let to_query v =
      Query.to_query_list TargetConfigurationRequest.to_query v
    let to_headers v =
      Headers.to_headers_list TargetConfigurationRequest.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (TargetConfigurationRequest.to_xml x))) v
    let to_json v = `List (List.map TargetConfigurationRequest.to_json v)
    let of_json j = Json.to_list TargetConfigurationRequest.of_json j
  end
module LocalGatewayRouteTableVpcAssociationIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module StaleSecurityGroupSet =
  struct
    type t = StaleSecurityGroup.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map StaleSecurityGroup.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list StaleSecurityGroup.to_query v
    let to_headers v =
      Headers.to_headers_list StaleSecurityGroup.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (StaleSecurityGroup.to_xml x))) v
    let to_json v = `List (List.map StaleSecurityGroup.to_json v)
    let of_json j = Json.to_list StaleSecurityGroup.of_json j
  end
module SecurityGroupReferences =
  struct
    type t = SecurityGroupReference.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SecurityGroupReference.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SecurityGroupReference.to_query v
    let to_headers v =
      Headers.to_headers_list SecurityGroupReference.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (SecurityGroupReference.to_xml x)))
        v
    let to_json v = `List (List.map SecurityGroupReference.to_json v)
    let of_json j = Json.to_list SecurityGroupReference.of_json j
  end
module AssignedPrivateIpAddressList =
  struct
    type t = AssignedPrivateIpAddress.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AssignedPrivateIpAddress.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AssignedPrivateIpAddress.to_query v
    let to_headers v =
      Headers.to_headers_list AssignedPrivateIpAddress.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (AssignedPrivateIpAddress.to_xml x)))
        v
    let to_json v = `List (List.map AssignedPrivateIpAddress.to_json v)
    let of_json j = Json.to_list AssignedPrivateIpAddress.of_json j
  end
module TransitGatewayMulticastRegisteredGroupMembers =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      registered_network_interface_ids: ValueStringList.t ;
      group_ip_address: String.t option }
    let make ?transit_gateway_multicast_domain_id 
      ?(registered_network_interface_ids= [])  ?group_ip_address  () =
      {
        transit_gateway_multicast_domain_id;
        registered_network_interface_ids;
        group_ip_address
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          registered_network_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "registeredNetworkInterfaceIds" xml)
                  ValueStringList.parse));
          group_ip_address =
            (Util.option_bind (Xml.member "groupIpAddress" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("RegisteredNetworkInterfaceIds",
                  (ValueStringList.to_query
                     v.registered_network_interface_ids)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.transit_gateway_multicast_domain_id
                (fun f ->
                   Ezxmlm.make_tag "transitGatewayMulticastDomainId"
                     ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "registeredNetworkInterfaceIds"
                       ([], (ValueStringList.to_xml [x]))))
               v.registered_network_interface_ids))
           @
           [Util.option_map v.group_ip_address
              (fun f ->
                 Ezxmlm.make_tag "groupIpAddress" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> ("group_ip_address", (String.to_json f)));
           Some
             ("registered_network_interface_ids",
               (ValueStringList.to_json v.registered_network_interface_ids));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        registered_network_interface_ids =
          (ValueStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "registered_network_interface_ids")));
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json)
      }
  end
module LocalGatewayRouteTableVpcAssociationSet =
  struct
    type t = LocalGatewayRouteTableVpcAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LocalGatewayRouteTableVpcAssociation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LocalGatewayRouteTableVpcAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list LocalGatewayRouteTableVpcAssociation.to_headers
        v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (LocalGatewayRouteTableVpcAssociation.to_xml x))) v
    let to_json v =
      `List (List.map LocalGatewayRouteTableVpcAssociation.to_json v)
    let of_json j =
      Json.to_list LocalGatewayRouteTableVpcAssociation.of_json j
  end
module AssociationIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "AssociationId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module CreateVolumePermissionModifications =
  struct
    type t =
      {
      add: CreateVolumePermissionList.t ;
      remove: CreateVolumePermissionList.t }
    let make ?(add= [])  ?(remove= [])  () = { add; remove }
    let parse xml =
      Some
        {
          add =
            (Util.of_option []
               (Util.option_bind (Xml.member "Add" xml)
                  CreateVolumePermissionList.parse));
          remove =
            (Util.of_option []
               (Util.option_bind (Xml.member "Remove" xml)
                  CreateVolumePermissionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Remove", (CreateVolumePermissionList.to_query v.remove)));
           Some
             (Query.Pair ("Add", (CreateVolumePermissionList.to_query v.add)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Add"
                       ([], (CreateVolumePermissionList.to_xml [x])))) v.add))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Remove"
                      ([], (CreateVolumePermissionList.to_xml [x]))))
              v.remove))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("remove", (CreateVolumePermissionList.to_json v.remove));
           Some ("add", (CreateVolumePermissionList.to_json v.add))])
    let of_json j =
      {
        add =
          (CreateVolumePermissionList.of_json
             (Util.of_option_exn (Json.lookup j "add")));
        remove =
          (CreateVolumePermissionList.of_json
             (Util.of_option_exn (Json.lookup j "remove")))
      }
  end
module VolumeList =
  struct
    type t = Volume.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Volume.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Volume.to_query v
    let to_headers v = Headers.to_headers_list Volume.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Volume.to_xml x))) v
    let to_json v = `List (List.map Volume.to_json v)
    let of_json j = Json.to_list Volume.of_json j
  end
module AvailabilityZoneStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "AvailabilityZone" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module SnapshotIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "SnapshotId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ClientVpnConnectionSet =
  struct
    type t = ClientVpnConnection.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClientVpnConnection.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ClientVpnConnection.to_query v
    let to_headers v =
      Headers.to_headers_list ClientVpnConnection.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ClientVpnConnection.to_xml x))) v
    let to_json v = `List (List.map ClientVpnConnection.to_json v)
    let of_json j = Json.to_list ClientVpnConnection.of_json j
  end
module TrafficMirrorPortRangeRequest =
  struct
    type t = {
      from_port: Integer.t option ;
      to_port: Integer.t option }
    let make ?from_port  ?to_port  () = { from_port; to_port }
    let parse xml =
      Some
        {
          from_port =
            (Util.option_bind (Xml.member "FromPort" xml) Integer.parse);
          to_port =
            (Util.option_bind (Xml.member "ToPort" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.to_port
              (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.from_port
               (fun f -> Ezxmlm.make_tag "FromPort" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.to_port
              (fun f -> Ezxmlm.make_tag "ToPort" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.to_port
              (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)))])
    let of_json j =
      {
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json)
      }
  end
module VolumeIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "VolumeId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module LocalGatewayRouteTableSet =
  struct
    type t = LocalGatewayRouteTable.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LocalGatewayRouteTable.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LocalGatewayRouteTable.to_query v
    let to_headers v =
      Headers.to_headers_list LocalGatewayRouteTable.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (LocalGatewayRouteTable.to_xml x)))
        v
    let to_json v = `List (List.map LocalGatewayRouteTable.to_json v)
    let of_json j = Json.to_list LocalGatewayRouteTable.of_json j
  end
module VpcClassicLinkIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "VpcId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module RegionList =
  struct
    type t = Region.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Region.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Region.to_query v
    let to_headers v = Headers.to_headers_list Region.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Region.to_xml x))) v
    let to_json v = `List (List.map Region.to_json v)
    let of_json j = Json.to_list Region.of_json j
  end
module VpnConnectionOptionsSpecification =
  struct
    type t =
      {
      enable_acceleration: Boolean.t option ;
      static_routes_only: Boolean.t option ;
      tunnel_options: VpnTunnelOptionsSpecificationsList.t }
    let make ?enable_acceleration  ?static_routes_only  ?(tunnel_options= [])
       () = { enable_acceleration; static_routes_only; tunnel_options }
    let parse xml =
      Some
        {
          enable_acceleration =
            (Util.option_bind (Xml.member "EnableAcceleration" xml)
               Boolean.parse);
          static_routes_only =
            (Util.option_bind (Xml.member "staticRoutesOnly" xml)
               Boolean.parse);
          tunnel_options =
            (Util.of_option []
               (Util.option_bind (Xml.member "TunnelOptions" xml)
                  VpnTunnelOptionsSpecificationsList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TunnelOptions",
                   (VpnTunnelOptionsSpecificationsList.to_query
                      v.tunnel_options)));
           Util.option_map v.static_routes_only
             (fun f -> Query.Pair ("StaticRoutesOnly", (Boolean.to_query f)));
           Util.option_map v.enable_acceleration
             (fun f ->
                Query.Pair ("EnableAcceleration", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.enable_acceleration
                (fun f ->
                   Ezxmlm.make_tag "EnableAcceleration"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.static_routes_only
               (fun f ->
                  Ezxmlm.make_tag "staticRoutesOnly" ([], (Boolean.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "TunnelOptions"
                      ([], (VpnTunnelOptionsSpecificationsList.to_xml [x]))))
              v.tunnel_options))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tunnel_options",
                (VpnTunnelOptionsSpecificationsList.to_json v.tunnel_options));
           Util.option_map v.static_routes_only
             (fun f -> ("static_routes_only", (Boolean.to_json f)));
           Util.option_map v.enable_acceleration
             (fun f -> ("enable_acceleration", (Boolean.to_json f)))])
    let of_json j =
      {
        enable_acceleration =
          (Util.option_map (Json.lookup j "enable_acceleration")
             Boolean.of_json);
        static_routes_only =
          (Util.option_map (Json.lookup j "static_routes_only")
             Boolean.of_json);
        tunnel_options =
          (VpnTunnelOptionsSpecificationsList.of_json
             (Util.of_option_exn (Json.lookup j "tunnel_options")))
      }
  end
module CidrAuthorizationContext =
  struct
    type t = {
      message: String.t ;
      signature: String.t }
    let make ~message  ~signature  () = { message; signature }
    let parse xml =
      Some
        {
          message =
            (Xml.required "Message"
               (Util.option_bind (Xml.member "Message" xml) String.parse));
          signature =
            (Xml.required "Signature"
               (Util.option_bind (Xml.member "Signature" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Signature", (String.to_query v.signature)));
           Some (Query.Pair ("Message", (String.to_query v.message)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some (Ezxmlm.make_tag "Message" ([], (String.to_xml v.message)))])
           @
           [Some
              (Ezxmlm.make_tag "Signature" ([], (String.to_xml v.signature)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("signature", (String.to_json v.signature));
           Some ("message", (String.to_json v.message))])
    let of_json j =
      {
        message =
          (String.of_json (Util.of_option_exn (Json.lookup j "message")));
        signature =
          (String.of_json (Util.of_option_exn (Json.lookup j "signature")))
      }
  end
module ModifyTransitGatewayVpcAttachmentRequestOptions =
  struct
    type t =
      {
      dns_support: DnsSupportValue.t option ;
      ipv6_support: Ipv6SupportValue.t option }
    let make ?dns_support  ?ipv6_support  () = { dns_support; ipv6_support }
    let parse xml =
      Some
        {
          dns_support =
            (Util.option_bind (Xml.member "DnsSupport" xml)
               DnsSupportValue.parse);
          ipv6_support =
            (Util.option_bind (Xml.member "Ipv6Support" xml)
               Ipv6SupportValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_support
              (fun f ->
                 Query.Pair ("Ipv6Support", (Ipv6SupportValue.to_query f)));
           Util.option_map v.dns_support
             (fun f ->
                Query.Pair ("DnsSupport", (DnsSupportValue.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.dns_support
               (fun f ->
                  Ezxmlm.make_tag "DnsSupport"
                    ([], (DnsSupportValue.to_xml f)))])
           @
           [Util.option_map v.ipv6_support
              (fun f ->
                 Ezxmlm.make_tag "Ipv6Support"
                   ([], (Ipv6SupportValue.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_support
              (fun f -> ("ipv6_support", (Ipv6SupportValue.to_json f)));
           Util.option_map v.dns_support
             (fun f -> ("dns_support", (DnsSupportValue.to_json f)))])
    let of_json j =
      {
        dns_support =
          (Util.option_map (Json.lookup j "dns_support")
             DnsSupportValue.of_json);
        ipv6_support =
          (Util.option_map (Json.lookup j "ipv6_support")
             Ipv6SupportValue.of_json)
      }
  end
module AllocationIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "AllocationId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PublicIpStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "PublicIp" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PeeringConnectionOptionsRequest =
  struct
    type t =
      {
      allow_dns_resolution_from_remote_vpc: Boolean.t option ;
      allow_egress_from_local_classic_link_to_remote_vpc: Boolean.t option ;
      allow_egress_from_local_vpc_to_remote_classic_link: Boolean.t option }
    let make ?allow_dns_resolution_from_remote_vpc 
      ?allow_egress_from_local_classic_link_to_remote_vpc 
      ?allow_egress_from_local_vpc_to_remote_classic_link  () =
      {
        allow_dns_resolution_from_remote_vpc;
        allow_egress_from_local_classic_link_to_remote_vpc;
        allow_egress_from_local_vpc_to_remote_classic_link
      }
    let parse xml =
      Some
        {
          allow_dns_resolution_from_remote_vpc =
            (Util.option_bind
               (Xml.member "AllowDnsResolutionFromRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_classic_link_to_remote_vpc =
            (Util.option_bind
               (Xml.member "AllowEgressFromLocalClassicLinkToRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_vpc_to_remote_classic_link =
            (Util.option_bind
               (Xml.member "AllowEgressFromLocalVpcToRemoteClassicLink" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 Query.Pair
                   ("AllowEgressFromLocalVpcToRemoteClassicLink",
                     (Boolean.to_query f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowEgressFromLocalClassicLinkToRemoteVpc",
                    (Boolean.to_query f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowDnsResolutionFromRemoteVpc", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.allow_dns_resolution_from_remote_vpc
                (fun f ->
                   Ezxmlm.make_tag "AllowDnsResolutionFromRemoteVpc"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map
               v.allow_egress_from_local_classic_link_to_remote_vpc
               (fun f ->
                  Ezxmlm.make_tag
                    "AllowEgressFromLocalClassicLinkToRemoteVpc"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 Ezxmlm.make_tag "AllowEgressFromLocalVpcToRemoteClassicLink"
                   ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 ("allow_egress_from_local_vpc_to_remote_classic_link",
                   (Boolean.to_json f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                ("allow_egress_from_local_classic_link_to_remote_vpc",
                  (Boolean.to_json f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                ("allow_dns_resolution_from_remote_vpc", (Boolean.to_json f)))])
    let of_json j =
      {
        allow_dns_resolution_from_remote_vpc =
          (Util.option_map
             (Json.lookup j "allow_dns_resolution_from_remote_vpc")
             Boolean.of_json);
        allow_egress_from_local_classic_link_to_remote_vpc =
          (Util.option_map
             (Json.lookup j
                "allow_egress_from_local_classic_link_to_remote_vpc")
             Boolean.of_json);
        allow_egress_from_local_vpc_to_remote_classic_link =
          (Util.option_map
             (Json.lookup j
                "allow_egress_from_local_vpc_to_remote_classic_link")
             Boolean.of_json)
      }
  end
module AddressList =
  struct
    type t = Address.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Address.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Address.to_query v
    let to_headers v = Headers.to_headers_list Address.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Address.to_xml x))) v
    let to_json v = `List (List.map Address.to_json v)
    let of_json j = Json.to_list Address.of_json j
  end
module InstanceTypeInfoList =
  struct
    type t = InstanceTypeInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceTypeInfo.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceTypeInfo.to_query v
    let to_headers v = Headers.to_headers_list InstanceTypeInfo.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InstanceTypeInfo.to_xml x)))
        v
    let to_json v = `List (List.map InstanceTypeInfo.to_json v)
    let of_json j = Json.to_list InstanceTypeInfo.of_json j
  end
module ClientVpnRouteSet =
  struct
    type t = ClientVpnRoute.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClientVpnRoute.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ClientVpnRoute.to_query v
    let to_headers v = Headers.to_headers_list ClientVpnRoute.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ClientVpnRoute.to_xml x))) v
    let to_json v = `List (List.map ClientVpnRoute.to_json v)
    let of_json j = Json.to_list ClientVpnRoute.of_json j
  end
module CapacityReservationSpecification =
  struct
    type t =
      {
      capacity_reservation_preference: CapacityReservationPreference.t option ;
      capacity_reservation_target: CapacityReservationTarget.t option }
    let make ?capacity_reservation_preference  ?capacity_reservation_target 
      () = { capacity_reservation_preference; capacity_reservation_target }
    let parse xml =
      Some
        {
          capacity_reservation_preference =
            (Util.option_bind
               (Xml.member "CapacityReservationPreference" xml)
               CapacityReservationPreference.parse);
          capacity_reservation_target =
            (Util.option_bind (Xml.member "CapacityReservationTarget" xml)
               CapacityReservationTarget.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Query.Pair
                   ("CapacityReservationTarget",
                     (CapacityReservationTarget.to_query f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                Query.Pair
                  ("CapacityReservationPreference",
                    (CapacityReservationPreference.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.capacity_reservation_preference
               (fun f ->
                  Ezxmlm.make_tag "CapacityReservationPreference"
                    ([], (CapacityReservationPreference.to_xml f)))])
           @
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Ezxmlm.make_tag "CapacityReservationTarget"
                   ([], (CapacityReservationTarget.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 ("capacity_reservation_target",
                   (CapacityReservationTarget.to_json f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                ("capacity_reservation_preference",
                  (CapacityReservationPreference.to_json f)))])
    let of_json j =
      {
        capacity_reservation_preference =
          (Util.option_map (Json.lookup j "capacity_reservation_preference")
             CapacityReservationPreference.of_json);
        capacity_reservation_target =
          (Util.option_map (Json.lookup j "capacity_reservation_target")
             CapacityReservationTarget.of_json)
      }
  end
module ClientVpnSecurityGroupIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module VpnConnectionList =
  struct
    type t = VpnConnection.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map VpnConnection.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpnConnection.to_query v
    let to_headers v = Headers.to_headers_list VpnConnection.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VpnConnection.to_xml x))) v
    let to_json v = `List (List.map VpnConnection.to_json v)
    let of_json j = Json.to_list VpnConnection.of_json j
  end
module RequestHostIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module DnsServersOptionsModifyStructure =
  struct
    type t =
      {
      custom_dns_servers: ValueStringList.t ;
      enabled: Boolean.t option }
    let make ?(custom_dns_servers= [])  ?enabled  () =
      { custom_dns_servers; enabled }
    let parse xml =
      Some
        {
          custom_dns_servers =
            (Util.of_option []
               (Util.option_bind (Xml.member "CustomDnsServers" xml)
                  ValueStringList.parse));
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("CustomDnsServers",
                  (ValueStringList.to_query v.custom_dns_servers)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "CustomDnsServers"
                       ([], (ValueStringList.to_xml [x]))))
               v.custom_dns_servers))
           @
           [Util.option_map v.enabled
              (fun f -> Ezxmlm.make_tag "Enabled" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)));
           Some
             ("custom_dns_servers",
               (ValueStringList.to_json v.custom_dns_servers))])
    let of_json j =
      {
        custom_dns_servers =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "custom_dns_servers")));
        enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json)
      }
  end
module TargetNetworkSet =
  struct
    type t = TargetNetwork.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map TargetNetwork.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TargetNetwork.to_query v
    let to_headers v = Headers.to_headers_list TargetNetwork.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (TargetNetwork.to_xml x))) v
    let to_json v = `List (List.map TargetNetwork.to_json v)
    let of_json j = Json.to_list TargetNetwork.of_json j
  end
module RegionNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "RegionName" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module BillingProductList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module VpcPeeringConnectionList =
  struct
    type t = VpcPeeringConnection.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpcPeeringConnection.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpcPeeringConnection.to_query v
    let to_headers v =
      Headers.to_headers_list VpcPeeringConnection.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (VpcPeeringConnection.to_xml x))) v
    let to_json v = `List (List.map VpcPeeringConnection.to_json v)
    let of_json j = Json.to_list VpcPeeringConnection.of_json j
  end
module NetworkAclList =
  struct
    type t = NetworkAcl.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map NetworkAcl.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NetworkAcl.to_query v
    let to_headers v = Headers.to_headers_list NetworkAcl.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (NetworkAcl.to_xml x))) v
    let to_json v = `List (List.map NetworkAcl.to_json v)
    let of_json j = Json.to_list NetworkAcl.of_json j
  end
module LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet =
  struct
    type t = LocalGatewayRouteTableVirtualInterfaceGroupAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map
           LocalGatewayRouteTableVirtualInterfaceGroupAssociation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list
        LocalGatewayRouteTableVirtualInterfaceGroupAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list
        LocalGatewayRouteTableVirtualInterfaceGroupAssociation.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([],
               (LocalGatewayRouteTableVirtualInterfaceGroupAssociation.to_xml
                  x))) v
    let to_json v =
      `List
        (List.map
           LocalGatewayRouteTableVirtualInterfaceGroupAssociation.to_json v)
    let of_json j =
      Json.to_list
        LocalGatewayRouteTableVirtualInterfaceGroupAssociation.of_json j
  end
module FleetIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module LaunchTemplateNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module CancelSpotFleetRequestsErrorSet =
  struct
    type t = CancelSpotFleetRequestsErrorItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CancelSpotFleetRequestsErrorItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list CancelSpotFleetRequestsErrorItem.to_query v
    let to_headers v =
      Headers.to_headers_list CancelSpotFleetRequestsErrorItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (CancelSpotFleetRequestsErrorItem.to_xml x))) v
    let to_json v =
      `List (List.map CancelSpotFleetRequestsErrorItem.to_json v)
    let of_json j = Json.to_list CancelSpotFleetRequestsErrorItem.of_json j
  end
module CancelSpotFleetRequestsSuccessSet =
  struct
    type t = CancelSpotFleetRequestsSuccessItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CancelSpotFleetRequestsSuccessItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list CancelSpotFleetRequestsSuccessItem.to_query v
    let to_headers v =
      Headers.to_headers_list CancelSpotFleetRequestsSuccessItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (CancelSpotFleetRequestsSuccessItem.to_xml x))) v
    let to_json v =
      `List (List.map CancelSpotFleetRequestsSuccessItem.to_json v)
    let of_json j = Json.to_list CancelSpotFleetRequestsSuccessItem.of_json j
  end
module AccountAttributeList =
  struct
    type t = AccountAttribute.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AccountAttribute.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AccountAttribute.to_query v
    let to_headers v = Headers.to_headers_list AccountAttribute.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (AccountAttribute.to_xml x)))
        v
    let to_json v = `List (List.map AccountAttribute.to_json v)
    let of_json j = Json.to_list AccountAttribute.of_json j
  end
module ResourceIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PeeringConnectionOptions =
  struct
    type t =
      {
      allow_dns_resolution_from_remote_vpc: Boolean.t option ;
      allow_egress_from_local_classic_link_to_remote_vpc: Boolean.t option ;
      allow_egress_from_local_vpc_to_remote_classic_link: Boolean.t option }
    let make ?allow_dns_resolution_from_remote_vpc 
      ?allow_egress_from_local_classic_link_to_remote_vpc 
      ?allow_egress_from_local_vpc_to_remote_classic_link  () =
      {
        allow_dns_resolution_from_remote_vpc;
        allow_egress_from_local_classic_link_to_remote_vpc;
        allow_egress_from_local_vpc_to_remote_classic_link
      }
    let parse xml =
      Some
        {
          allow_dns_resolution_from_remote_vpc =
            (Util.option_bind
               (Xml.member "allowDnsResolutionFromRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_classic_link_to_remote_vpc =
            (Util.option_bind
               (Xml.member "allowEgressFromLocalClassicLinkToRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_vpc_to_remote_classic_link =
            (Util.option_bind
               (Xml.member "allowEgressFromLocalVpcToRemoteClassicLink" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 Query.Pair
                   ("AllowEgressFromLocalVpcToRemoteClassicLink",
                     (Boolean.to_query f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowEgressFromLocalClassicLinkToRemoteVpc",
                    (Boolean.to_query f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowDnsResolutionFromRemoteVpc", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.allow_dns_resolution_from_remote_vpc
                (fun f ->
                   Ezxmlm.make_tag "allowDnsResolutionFromRemoteVpc"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map
               v.allow_egress_from_local_classic_link_to_remote_vpc
               (fun f ->
                  Ezxmlm.make_tag
                    "allowEgressFromLocalClassicLinkToRemoteVpc"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 Ezxmlm.make_tag "allowEgressFromLocalVpcToRemoteClassicLink"
                   ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 ("allow_egress_from_local_vpc_to_remote_classic_link",
                   (Boolean.to_json f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                ("allow_egress_from_local_classic_link_to_remote_vpc",
                  (Boolean.to_json f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                ("allow_dns_resolution_from_remote_vpc", (Boolean.to_json f)))])
    let of_json j =
      {
        allow_dns_resolution_from_remote_vpc =
          (Util.option_map
             (Json.lookup j "allow_dns_resolution_from_remote_vpc")
             Boolean.of_json);
        allow_egress_from_local_classic_link_to_remote_vpc =
          (Util.option_map
             (Json.lookup j
                "allow_egress_from_local_classic_link_to_remote_vpc")
             Boolean.of_json);
        allow_egress_from_local_vpc_to_remote_classic_link =
          (Util.option_map
             (Json.lookup j
                "allow_egress_from_local_vpc_to_remote_classic_link")
             Boolean.of_json)
      }
  end
module VpcIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "VpcId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module DiskImageList =
  struct
    type t = DiskImage.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map DiskImage.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list DiskImage.to_query v
    let to_headers v = Headers.to_headers_list DiskImage.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (DiskImage.to_xml x)))
        v
    let to_json v = `List (List.map DiskImage.to_json v)
    let of_json j = Json.to_list DiskImage.of_json j
  end
module ImportInstanceLaunchSpecification =
  struct
    type t =
      {
      additional_info: String.t option ;
      architecture: ArchitectureValues.t option ;
      group_ids: SecurityGroupIdStringList.t ;
      group_names: SecurityGroupStringList.t ;
      instance_initiated_shutdown_behavior: ShutdownBehavior.t option ;
      instance_type: InstanceType.t option ;
      monitoring: Boolean.t option ;
      placement: Placement.t option ;
      private_ip_address: String.t option ;
      subnet_id: String.t option ;
      user_data: UserData.t option }
    let make ?additional_info  ?architecture  ?(group_ids= []) 
      ?(group_names= [])  ?instance_initiated_shutdown_behavior 
      ?instance_type  ?monitoring  ?placement  ?private_ip_address 
      ?subnet_id  ?user_data  () =
      {
        additional_info;
        architecture;
        group_ids;
        group_names;
        instance_initiated_shutdown_behavior;
        instance_type;
        monitoring;
        placement;
        private_ip_address;
        subnet_id;
        user_data
      }
    let parse xml =
      Some
        {
          additional_info =
            (Util.option_bind (Xml.member "additionalInfo" xml) String.parse);
          architecture =
            (Util.option_bind (Xml.member "architecture" xml)
               ArchitectureValues.parse);
          group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupId" xml)
                  SecurityGroupIdStringList.parse));
          group_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupName" xml)
                  SecurityGroupStringList.parse));
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               ShutdownBehavior.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml) Boolean.parse);
          placement =
            (Util.option_bind (Xml.member "placement" xml) Placement.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml) UserData.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> Query.Pair ("UserData", (UserData.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (Placement.to_query f)));
           Util.option_map v.monitoring
             (fun f -> Query.Pair ("Monitoring", (Boolean.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (ShutdownBehavior.to_query f)));
           Some
             (Query.Pair
                ("GroupName",
                  (SecurityGroupStringList.to_query v.group_names)));
           Some
             (Query.Pair
                ("GroupId", (SecurityGroupIdStringList.to_query v.group_ids)));
           Util.option_map v.architecture
             (fun f ->
                Query.Pair ("Architecture", (ArchitectureValues.to_query f)));
           Util.option_map v.additional_info
             (fun f -> Query.Pair ("AdditionalInfo", (String.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.additional_info
                        (fun f ->
                           Ezxmlm.make_tag "additionalInfo"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.architecture
                       (fun f ->
                          Ezxmlm.make_tag "architecture"
                            ([], (ArchitectureValues.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "GroupId"
                              ([], (SecurityGroupIdStringList.to_xml [x]))))
                      v.group_ids))
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "GroupName"
                             ([], (SecurityGroupStringList.to_xml [x]))))
                     v.group_names))
                 @
                 [Util.option_map v.instance_initiated_shutdown_behavior
                    (fun f ->
                       Ezxmlm.make_tag "instanceInitiatedShutdownBehavior"
                         ([], (ShutdownBehavior.to_xml f)))])
                @
                [Util.option_map v.instance_type
                   (fun f ->
                      Ezxmlm.make_tag "instanceType"
                        ([], (InstanceType.to_xml f)))])
               @
               [Util.option_map v.monitoring
                  (fun f ->
                     Ezxmlm.make_tag "monitoring" ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.placement
                 (fun f ->
                    Ezxmlm.make_tag "placement" ([], (Placement.to_xml f)))])
             @
             [Util.option_map v.private_ip_address
                (fun f ->
                   Ezxmlm.make_tag "privateIpAddress" ([], (String.to_xml f)))])
            @
            [Util.option_map v.subnet_id
               (fun f -> Ezxmlm.make_tag "subnetId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.user_data
              (fun f -> Ezxmlm.make_tag "userData" ([], (UserData.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> ("user_data", (UserData.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (Placement.to_json f)));
           Util.option_map v.monitoring
             (fun f -> ("monitoring", (Boolean.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (ShutdownBehavior.to_json f)));
           Some
             ("group_names", (SecurityGroupStringList.to_json v.group_names));
           Some
             ("group_ids", (SecurityGroupIdStringList.to_json v.group_ids));
           Util.option_map v.architecture
             (fun f -> ("architecture", (ArchitectureValues.to_json f)));
           Util.option_map v.additional_info
             (fun f -> ("additional_info", (String.to_json f)))])
    let of_json j =
      {
        additional_info =
          (Util.option_map (Json.lookup j "additional_info") String.of_json);
        architecture =
          (Util.option_map (Json.lookup j "architecture")
             ArchitectureValues.of_json);
        group_ids =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_ids")));
        group_names =
          (SecurityGroupStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_names")));
        instance_initiated_shutdown_behavior =
          (Util.option_map
             (Json.lookup j "instance_initiated_shutdown_behavior")
             ShutdownBehavior.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring") Boolean.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement") Placement.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") UserData.of_json)
      }
  end
module VpcEndpointSet =
  struct
    type t = VpcEndpoint.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map VpcEndpoint.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpcEndpoint.to_query v
    let to_headers v = Headers.to_headers_list VpcEndpoint.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (VpcEndpoint.to_xml x))) v
    let to_json v = `List (List.map VpcEndpoint.to_json v)
    let of_json j = Json.to_list VpcEndpoint.of_json j
  end
module ClassicLinkInstanceList =
  struct
    type t = ClassicLinkInstance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClassicLinkInstance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ClassicLinkInstance.to_query v
    let to_headers v =
      Headers.to_headers_list ClassicLinkInstance.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ClassicLinkInstance.to_xml x))) v
    let to_json v = `List (List.map ClassicLinkInstance.to_json v)
    let of_json j = Json.to_list ClassicLinkInstance.of_json j
  end
module PurchaseSet =
  struct
    type t = Purchase.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Purchase.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Purchase.to_query v
    let to_headers v = Headers.to_headers_list Purchase.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Purchase.to_xml x)))
        v
    let to_json v = `List (List.map Purchase.to_json v)
    let of_json j = Json.to_list Purchase.of_json j
  end
module TransitGatewayAttachmentList =
  struct
    type t = TransitGatewayAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayAttachment.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TransitGatewayAttachment.to_query v
    let to_headers v =
      Headers.to_headers_list TransitGatewayAttachment.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (TransitGatewayAttachment.to_xml x)))
        v
    let to_json v = `List (List.map TransitGatewayAttachment.to_json v)
    let of_json j = Json.to_list TransitGatewayAttachment.of_json j
  end