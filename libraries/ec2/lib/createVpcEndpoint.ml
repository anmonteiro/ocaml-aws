open Types[@@ocaml.warning "-33"]
open Aws.BaseTypes[@@ocaml.warning "-33"]
open Aws
module CreateVpcEndpointRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option
        [@ocaml.doc
          "<p>Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is <code>DryRunOperation</code>. Otherwise, it is <code>UnauthorizedOperation</code>.</p>"];
      vpc_endpoint_type: VpcEndpointType.t option
        [@ocaml.doc "<p>The type of endpoint.</p> <p>Default: Gateway</p>"];
      vpc_id: String.t
        [@ocaml.doc
          "<p>The ID of the VPC in which the endpoint will be used.</p>"];
      service_name: String.t
        [@ocaml.doc
          "<p>The service name. To get a list of available services, use the <a>DescribeVpcEndpointServices</a> request, or get the name from the service provider.</p>"];
      policy_document: String.t option
        [@ocaml.doc
          "<p>A policy to attach to the endpoint that controls access to the service. The policy must be in valid JSON format. If this parameter is not specified, we attach a default policy that allows full access to the service.</p>"];
      route_table_ids: ValueStringList.t
        [@ocaml.doc "<p>(Gateway endpoint) One or more route table IDs.</p>"];
      subnet_ids: ValueStringList.t
        [@ocaml.doc
          "<p>(Interface endpoint) The ID of one or more subnets in which to create an endpoint network interface.</p>"];
      security_group_ids: ValueStringList.t
        [@ocaml.doc
          "<p>(Interface endpoint) The ID of one or more security groups to associate with the endpoint network interface.</p>"];
      client_token: String.t option
        [@ocaml.doc
          "<p>Unique, case-sensitive identifier you provide to ensure the idempotency of the request. For more information, see <a href=\"https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html\">How to Ensure Idempotency</a>.</p>"];
      private_dns_enabled: Boolean.t option
        [@ocaml.doc
          "<p>(Interface endpoint) Indicate whether to associate a private hosted zone with the specified VPC. The private hosted zone contains a record set for the default public DNS name for the service for the Region (for example, <code>kinesis.us-east-1.amazonaws.com</code>) which resolves to the private IP addresses of the endpoint network interfaces in the VPC. This enables you to make requests to the default public DNS name for the service instead of the public DNS names that are automatically generated by the VPC endpoint service.</p> <p>To use a private hosted zone, you must set the following VPC attributes to <code>true</code>: <code>enableDnsHostnames</code> and <code>enableDnsSupport</code>. Use <a>ModifyVpcAttribute</a> to set the VPC attributes.</p> <p>Default: <code>true</code> </p>"]}
    [@@ocaml.doc "<p>Contains the parameters for CreateVpcEndpoint.</p>"]
    let make ?dry_run  ?vpc_endpoint_type  ~vpc_id  ~service_name 
      ?policy_document  ?(route_table_ids= [])  ?(subnet_ids= []) 
      ?(security_group_ids= [])  ?client_token  ?private_dns_enabled  () =
      {
        dry_run;
        vpc_endpoint_type;
        vpc_id;
        service_name;
        policy_document;
        route_table_ids;
        subnet_ids;
        security_group_ids;
        client_token;
        private_dns_enabled
      }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_dns_enabled
              (fun f ->
                 Query.Pair ("PrivateDnsEnabled", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (ValueStringList.to_query v.security_group_ids)));
           Some
             (Query.Pair
                ("SubnetId", (ValueStringList.to_query v.subnet_ids)));
           Some
             (Query.Pair
                ("RouteTableId",
                  (ValueStringList.to_query v.route_table_ids)));
           Util.option_map v.policy_document
             (fun f -> Query.Pair ("PolicyDocument", (String.to_query f)));
           Some
             (Query.Pair ("ServiceName", (String.to_query v.service_name)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.vpc_endpoint_type
             (fun f ->
                Query.Pair ("VpcEndpointType", (VpcEndpointType.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_dns_enabled
              (fun f -> ("private_dns_enabled", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some
             ("security_group_ids",
               (ValueStringList.to_json v.security_group_ids));
           Some ("subnet_ids", (ValueStringList.to_json v.subnet_ids));
           Some
             ("route_table_ids", (ValueStringList.to_json v.route_table_ids));
           Util.option_map v.policy_document
             (fun f -> ("policy_document", (String.to_json f)));
           Some ("service_name", (String.to_json v.service_name));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.vpc_endpoint_type
             (fun f -> ("vpc_endpoint_type", (VpcEndpointType.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          vpc_endpoint_type =
            (Util.option_bind (Xml.member "VpcEndpointType" xml)
               VpcEndpointType.parse);
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          service_name =
            (Xml.required "ServiceName"
               (Util.option_bind (Xml.member "ServiceName" xml) String.parse));
          policy_document =
            (Util.option_bind (Xml.member "PolicyDocument" xml) String.parse);
          route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RouteTableId" xml)
                  ValueStringList.parse));
          subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SubnetId" xml)
                  ValueStringList.parse));
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  ValueStringList.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          private_dns_enabled =
            (Util.option_bind (Xml.member "PrivateDnsEnabled" xml)
               Boolean.parse)
        }
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.dry_run
                       (fun f ->
                          Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
                   @
                   [Util.option_map v.vpc_endpoint_type
                      (fun f ->
                         Ezxmlm.make_tag "VpcEndpointType"
                           ([], (VpcEndpointType.to_xml f)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "VpcId" ([], (String.to_xml v.vpc_id)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "ServiceName"
                       ([], (String.to_xml v.service_name)))])
                @
                [Util.option_map v.policy_document
                   (fun f ->
                      Ezxmlm.make_tag "PolicyDocument"
                        ([], (String.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "RouteTableId"
                          ([], (ValueStringList.to_xml [x]))))
                  v.route_table_ids))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "SubnetId"
                         ([], (ValueStringList.to_xml [x])))) v.subnet_ids))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "SecurityGroupId"
                        ([], (ValueStringList.to_xml [x]))))
                v.security_group_ids))
            @
            [Util.option_map v.client_token
               (fun f ->
                  Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.private_dns_enabled
              (fun f ->
                 Ezxmlm.make_tag "PrivateDnsEnabled" ([], (Boolean.to_xml f)))])
  end[@@ocaml.doc "<p>Contains the parameters for CreateVpcEndpoint.</p>"]
module CreateVpcEndpointResult = CreateVpcEndpointResult
type input = CreateVpcEndpointRequest.t
type output = CreateVpcEndpointResult.t
type error = Errors_internal.t
let streaming = false
let service = "ec2"
let to_http service region req =
  let uri =
    Uri.add_query_params
      (Uri.of_string
         ((Aws.Util.of_option_exn (Endpoints.url_of service region)) ^ "/"))
      (List.append
         [("Version", ["2016-11-15"]); ("Action", ["CreateVpcEndpoint"])]
         (Util.drop_empty
            (Uri.query_of_encoded
               (Query.render (CreateVpcEndpointRequest.to_query req))))) in
  (`POST, uri, (Headers.render (CreateVpcEndpointRequest.to_headers req)),
    "")
let of_http headers
  (body : [ `String of string  | `Streaming of Piaf.Body.t ]) =
  let ((`String body) : [ `String of string  | `Streaming of Piaf.Body.t ]) =
    body[@@ocaml.warning "-8"] in
  try
    let xml = Ezxmlm.from_string body in
    let resp = Xml.member "CreateVpcEndpointResponse" (snd xml) in
    try
      let open Error in
        Util.or_error (Util.option_bind resp CreateVpcEndpointResult.parse)
          (BadResponse
             {
               body;
               message =
                 "Could not find well formed CreateVpcEndpointResult."
             })
    with
    | Xml.RequiredFieldMissing msg ->
        let open Error in
          `Error
            (BadResponse
               {
                 body;
                 message =
                   ("Error parsing CreateVpcEndpointResult - missing field in body or children: "
                      ^ msg)
               })
  with
  | Failure msg ->
      let open Error in
        `Error
          (BadResponse { body; message = ("Error parsing xml: " ^ msg) })
let parse_error code err =
  let errors = [] @ Errors_internal.common in
  match Errors_internal.of_string err with
  | Some v ->
      if
        (List.mem v errors) &&
          ((match Errors_internal.to_http_code v with
            | Some x -> x = code
            | None -> true))
      then Some v
      else None
  | None -> None