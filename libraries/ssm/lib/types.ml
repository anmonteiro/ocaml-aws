open Aws
open Aws.BaseTypes
open CalendarLib
type calendar = Calendar.t
module PatchFilterKey =
  struct
    type t =
      | PATCH_SET 
      | PRODUCT 
      | PRODUCT_FAMILY 
      | CLASSIFICATION 
      | MSRC_SEVERITY 
      | PATCH_ID 
      | SECTION 
      | PRIORITY 
      | SEVERITY 
    let str_to_t =
      [("SEVERITY", SEVERITY);
      ("PRIORITY", PRIORITY);
      ("SECTION", SECTION);
      ("PATCH_ID", PATCH_ID);
      ("MSRC_SEVERITY", MSRC_SEVERITY);
      ("CLASSIFICATION", CLASSIFICATION);
      ("PRODUCT_FAMILY", PRODUCT_FAMILY);
      ("PRODUCT", PRODUCT);
      ("PATCH_SET", PATCH_SET)]
    let t_to_str =
      [(SEVERITY, "SEVERITY");
      (PRIORITY, "PRIORITY");
      (SECTION, "SECTION");
      (PATCH_ID, "PATCH_ID");
      (MSRC_SEVERITY, "MSRC_SEVERITY");
      (CLASSIFICATION, "CLASSIFICATION");
      (PRODUCT_FAMILY, "PRODUCT_FAMILY");
      (PRODUCT, "PRODUCT");
      (PATCH_SET, "PATCH_SET")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PatchFilterValueList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InventoryFilterValueList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InventoryQueryOperatorType =
  struct
    type t =
      | Equal 
      | NotEqual 
      | BeginWith 
      | LessThan 
      | GreaterThan 
      | Exists 
    let str_to_t =
      [("Exists", Exists);
      ("GreaterThan", GreaterThan);
      ("LessThan", LessThan);
      ("BeginWith", BeginWith);
      ("NotEqual", NotEqual);
      ("Equal", Equal)]
    let t_to_str =
      [(Exists, "Exists");
      (GreaterThan, "GreaterThan");
      (LessThan, "LessThan");
      (BeginWith, "BeginWith");
      (NotEqual, "NotEqual");
      (Equal, "Equal")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AutomationParameterValueList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TargetValues =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module OpsEntityItemEntry =
  struct
    type t = (String.t, String.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string String.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc -> ((String.to_string k), (String.to_json v)) :: acc)
           v [])
    let of_json j = Json.to_hashtbl String.of_string String.of_json j
  end
module PatchFilter =
  struct
    type t = {
      key: PatchFilterKey.t ;
      values: PatchFilterValueList.t }
    let make ~key  ~values  () = { key; values }
    let parse xml =
      Some
        {
          key =
            (Xml.required "Key"
               (Util.option_bind (Xml.member "Key" xml) PatchFilterKey.parse));
          values =
            (Xml.required "Values"
               (Util.option_bind (Xml.member "Values" xml)
                  PatchFilterValueList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some (Ezxmlm.make_tag "Key" ([], (PatchFilterKey.to_xml v.key)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Values"
                      ([], (PatchFilterValueList.to_xml [x])))) v.values))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (PatchFilterValueList.to_json v.values));
           Some ("key", (PatchFilterKey.to_json v.key))])
    let of_json j =
      {
        key =
          (PatchFilterKey.of_json (Util.of_option_exn (Json.lookup j "key")));
        values =
          (PatchFilterValueList.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module InventoryItemEntry =
  struct
    type t = (String.t, String.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string String.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc -> ((String.to_string k), (String.to_json v)) :: acc)
           v [])
    let of_json j = Json.to_hashtbl String.of_string String.of_json j
  end
module ResourceDataSyncOrganizationalUnit =
  struct
    type t = {
      organizational_unit_id: String.t option }
    let make ?organizational_unit_id  () = { organizational_unit_id }
    let parse xml =
      Some
        {
          organizational_unit_id =
            (Util.option_bind (Xml.member "OrganizationalUnitId" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.organizational_unit_id
              (fun f ->
                 Ezxmlm.make_tag "OrganizationalUnitId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.organizational_unit_id
              (fun f -> ("organizational_unit_id", (String.to_json f)))])
    let of_json j =
      {
        organizational_unit_id =
          (Util.option_map (Json.lookup j "organizational_unit_id")
             String.of_json)
      }
  end
module NotificationEvent =
  struct
    type t =
      | All 
      | InProgress 
      | Success 
      | TimedOut 
      | Cancelled 
      | Failed 
    let str_to_t =
      [("Failed", Failed);
      ("Cancelled", Cancelled);
      ("TimedOut", TimedOut);
      ("Success", Success);
      ("InProgress", InProgress);
      ("All", All)]
    let t_to_str =
      [(Failed, "Failed");
      (Cancelled, "Cancelled");
      (TimedOut, "TimedOut");
      (Success, "Success");
      (InProgress, "InProgress");
      (All, "All")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TargetMapValueList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InventoryFilter =
  struct
    type t =
      {
      key: String.t ;
      values: InventoryFilterValueList.t ;
      type_: InventoryQueryOperatorType.t option }
    let make ~key  ~values  ?type_  () = { key; values; type_ }
    let parse xml =
      Some
        {
          key =
            (Xml.required "Key"
               (Util.option_bind (Xml.member "Key" xml) String.parse));
          values =
            (Xml.required "Values"
               (Util.option_bind (Xml.member "Values" xml)
                  InventoryFilterValueList.parse));
          type_ =
            (Util.option_bind (Xml.member "Type" xml)
               InventoryQueryOperatorType.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @ [Some (Ezxmlm.make_tag "Key" ([], (String.to_xml v.key)))]) @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Values"
                       ([], (InventoryFilterValueList.to_xml [x])))) v.values))
           @
           [Util.option_map v.type_
              (fun f ->
                 Ezxmlm.make_tag "Type"
                   ([], (InventoryQueryOperatorType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> ("type_", (InventoryQueryOperatorType.to_json f)));
           Some ("values", (InventoryFilterValueList.to_json v.values));
           Some ("key", (String.to_json v.key))])
    let of_json j =
      {
        key = (String.of_json (Util.of_option_exn (Json.lookup j "key")));
        values =
          (InventoryFilterValueList.of_json
             (Util.of_option_exn (Json.lookup j "values")));
        type_ =
          (Util.option_map (Json.lookup j "type_")
             InventoryQueryOperatorType.of_json)
      }
  end
module AutomationParameterMap =
  struct
    type t = (String.t, AutomationParameterValueList.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string
        AutomationParameterValueList.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc ->
                  ((String.to_string k),
                    (AutomationParameterValueList.to_json v))
                  :: acc) v [])
    let of_json j =
      Json.to_hashtbl String.of_string AutomationParameterValueList.of_json j
  end
module Accounts =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module Regions =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module Target =
  struct
    type t = {
      key: String.t option ;
      values: TargetValues.t }
    let make ?key  ?(values= [])  () = { key; values }
    let parse xml =
      Some
        {
          key = (Util.option_bind (Xml.member "Key" xml) String.parse);
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "Values" xml) TargetValues.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.key
               (fun f -> Ezxmlm.make_tag "Key" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Values" ([], (TargetValues.to_xml [x]))))
              v.values))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (TargetValues.to_json v.values));
           Util.option_map v.key (fun f -> ("key", (String.to_json f)))])
    let of_json j =
      {
        key = (Util.option_map (Json.lookup j "key") String.of_json);
        values =
          (TargetValues.of_json (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module OpsEntityItemEntryList =
  struct
    type t = OpsEntityItemEntry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map OpsEntityItemEntry.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list OpsEntityItemEntry.to_query v
    let to_headers v =
      Headers.to_headers_list OpsEntityItemEntry.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (OpsEntityItemEntry.to_xml x))) v
    let to_json v = `List (List.map OpsEntityItemEntry.to_json v)
    let of_json j = Json.to_list OpsEntityItemEntry.of_json j
  end
module PatchFilterList =
  struct
    type t = PatchFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map PatchFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list PatchFilter.to_query v
    let to_headers v = Headers.to_headers_list PatchFilter.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PatchFilter.to_xml x))) v
    let to_json v = `List (List.map PatchFilter.to_json v)
    let of_json j = Json.to_list PatchFilter.of_json j
  end
module MaintenanceWindowTaskParameterValueList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InventoryItemEntryList =
  struct
    type t = InventoryItemEntry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InventoryItemEntry.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InventoryItemEntry.to_query v
    let to_headers v =
      Headers.to_headers_list InventoryItemEntry.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InventoryItemEntry.to_xml x))) v
    let to_json v = `List (List.map InventoryItemEntry.to_json v)
    let of_json j = Json.to_list InventoryItemEntry.of_json j
  end
module OpsItemDataType =
  struct
    type t =
      | SearchableString 
      | String 
    let str_to_t =
      [("String", String); ("SearchableString", SearchableString)]
    let t_to_str =
      [(String, "String"); (SearchableString, "SearchableString")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module S3OutputLocation =
  struct
    type t =
      {
      output_s3_region: String.t option ;
      output_s3_bucket_name: String.t option ;
      output_s3_key_prefix: String.t option }
    let make ?output_s3_region  ?output_s3_bucket_name  ?output_s3_key_prefix
       () = { output_s3_region; output_s3_bucket_name; output_s3_key_prefix }
    let parse xml =
      Some
        {
          output_s3_region =
            (Util.option_bind (Xml.member "OutputS3Region" xml) String.parse);
          output_s3_bucket_name =
            (Util.option_bind (Xml.member "OutputS3BucketName" xml)
               String.parse);
          output_s3_key_prefix =
            (Util.option_bind (Xml.member "OutputS3KeyPrefix" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.output_s3_region
                (fun f ->
                   Ezxmlm.make_tag "OutputS3Region" ([], (String.to_xml f)))])
            @
            [Util.option_map v.output_s3_bucket_name
               (fun f ->
                  Ezxmlm.make_tag "OutputS3BucketName"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.output_s3_key_prefix
              (fun f ->
                 Ezxmlm.make_tag "OutputS3KeyPrefix" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.output_s3_key_prefix
              (fun f -> ("output_s3_key_prefix", (String.to_json f)));
           Util.option_map v.output_s3_bucket_name
             (fun f -> ("output_s3_bucket_name", (String.to_json f)));
           Util.option_map v.output_s3_region
             (fun f -> ("output_s3_region", (String.to_json f)))])
    let of_json j =
      {
        output_s3_region =
          (Util.option_map (Json.lookup j "output_s3_region") String.of_json);
        output_s3_bucket_name =
          (Util.option_map (Json.lookup j "output_s3_bucket_name")
             String.of_json);
        output_s3_key_prefix =
          (Util.option_map (Json.lookup j "output_s3_key_prefix")
             String.of_json)
      }
  end
module ParameterValueList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InventoryDeletionSummaryItem =
  struct
    type t =
      {
      version: String.t option ;
      count: Integer.t option ;
      remaining_count: Integer.t option }
    let make ?version  ?count  ?remaining_count  () =
      { version; count; remaining_count }
    let parse xml =
      Some
        {
          version =
            (Util.option_bind (Xml.member "Version" xml) String.parse);
          count = (Util.option_bind (Xml.member "Count" xml) Integer.parse);
          remaining_count =
            (Util.option_bind (Xml.member "RemainingCount" xml) Integer.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.version
                (fun f -> Ezxmlm.make_tag "Version" ([], (String.to_xml f)))])
            @
            [Util.option_map v.count
               (fun f -> Ezxmlm.make_tag "Count" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.remaining_count
              (fun f ->
                 Ezxmlm.make_tag "RemainingCount" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.remaining_count
              (fun f -> ("remaining_count", (Integer.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Util.option_map v.version
             (fun f -> ("version", (String.to_json f)))])
    let of_json j =
      {
        version = (Util.option_map (Json.lookup j "version") String.of_json);
        count = (Util.option_map (Json.lookup j "count") Integer.of_json);
        remaining_count =
          (Util.option_map (Json.lookup j "remaining_count") Integer.of_json)
      }
  end
module InventoryAttributeDataType =
  struct
    type t =
      | String 
      | Number 
    let str_to_t = [("number", Number); ("string", String)]
    let t_to_str = [(Number, "number"); (String, "string")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CommandPluginStatus =
  struct
    type t =
      | Pending 
      | InProgress 
      | Success 
      | TimedOut 
      | Cancelled 
      | Failed 
    let str_to_t =
      [("Failed", Failed);
      ("Cancelled", Cancelled);
      ("TimedOut", TimedOut);
      ("Success", Success);
      ("InProgress", InProgress);
      ("Pending", Pending)]
    let t_to_str =
      [(Failed, "Failed");
      (Cancelled, "Cancelled");
      (TimedOut, "TimedOut");
      (Success, "Success");
      (InProgress, "InProgress");
      (Pending, "Pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ResourceDataSyncOrganizationalUnitList =
  struct
    type t = ResourceDataSyncOrganizationalUnit.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ResourceDataSyncOrganizationalUnit.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list ResourceDataSyncOrganizationalUnit.to_query v
    let to_headers v =
      Headers.to_headers_list ResourceDataSyncOrganizationalUnit.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ResourceDataSyncOrganizationalUnit.to_xml x))) v
    let to_json v =
      `List (List.map ResourceDataSyncOrganizationalUnit.to_json v)
    let of_json j = Json.to_list ResourceDataSyncOrganizationalUnit.of_json j
  end
module ParameterInlinePolicy =
  struct
    type t =
      {
      policy_text: String.t option ;
      policy_type: String.t option ;
      policy_status: String.t option }
    let make ?policy_text  ?policy_type  ?policy_status  () =
      { policy_text; policy_type; policy_status }
    let parse xml =
      Some
        {
          policy_text =
            (Util.option_bind (Xml.member "PolicyText" xml) String.parse);
          policy_type =
            (Util.option_bind (Xml.member "PolicyType" xml) String.parse);
          policy_status =
            (Util.option_bind (Xml.member "PolicyStatus" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.policy_text
                (fun f ->
                   Ezxmlm.make_tag "PolicyText" ([], (String.to_xml f)))])
            @
            [Util.option_map v.policy_type
               (fun f -> Ezxmlm.make_tag "PolicyType" ([], (String.to_xml f)))])
           @
           [Util.option_map v.policy_status
              (fun f ->
                 Ezxmlm.make_tag "PolicyStatus" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.policy_status
              (fun f -> ("policy_status", (String.to_json f)));
           Util.option_map v.policy_type
             (fun f -> ("policy_type", (String.to_json f)));
           Util.option_map v.policy_text
             (fun f -> ("policy_text", (String.to_json f)))])
    let of_json j =
      {
        policy_text =
          (Util.option_map (Json.lookup j "policy_text") String.of_json);
        policy_type =
          (Util.option_map (Json.lookup j "policy_type") String.of_json);
        policy_status =
          (Util.option_map (Json.lookup j "policy_status") String.of_json)
      }
  end
module NotificationEventList =
  struct
    type t = NotificationEvent.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NotificationEvent.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list NotificationEvent.to_query v
    let to_headers v = Headers.to_headers_list NotificationEvent.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (NotificationEvent.to_xml x)))
        v
    let to_json v = `List (List.map NotificationEvent.to_json v)
    let of_json j = Json.to_list NotificationEvent.of_json j
  end
module NotificationType =
  struct
    type t =
      | Command 
      | Invocation 
    let str_to_t = [("Invocation", Invocation); ("Command", Command)]
    let t_to_str = [(Invocation, "Invocation"); (Command, "Command")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceAssociationStatusAggregatedCount =
  struct
    type t = (String.t, Integer.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string Integer.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc -> ((String.to_string k), (Integer.to_json v)) :: acc)
           v [])
    let of_json j = Json.to_hashtbl String.of_string Integer.of_json j
  end
module TargetParameterList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TargetMap =
  struct
    type t = (String.t, TargetMapValueList.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string TargetMapValueList.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc ->
                  ((String.to_string k), (TargetMapValueList.to_json v)) ::
                  acc) v [])
    let of_json j =
      Json.to_hashtbl String.of_string TargetMapValueList.of_json j
  end
module DocumentRequires =
  struct
    type t = {
      name: String.t ;
      version: String.t option }
    let make ~name  ?version  () = { name; version }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          version =
            (Util.option_bind (Xml.member "Version" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
           @
           [Util.option_map v.version
              (fun f -> Ezxmlm.make_tag "Version" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> ("version", (String.to_json f)));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        version = (Util.option_map (Json.lookup j "version") String.of_json)
      }
  end
module PlatformType =
  struct
    type t =
      | Windows 
      | Linux 
    let str_to_t = [("Linux", Linux); ("Windows", Windows)]
    let t_to_str = [(Linux, "Linux"); (Windows, "Windows")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module Tag =
  struct
    type t = {
      key: String.t ;
      value: String.t }
    let make ~key  ~value  () = { key; value }
    let parse xml =
      Some
        {
          key =
            (Xml.required "Key"
               (Util.option_bind (Xml.member "Key" xml) String.parse));
          value =
            (Xml.required "Value"
               (Util.option_bind (Xml.member "Value" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Key" ([], (String.to_xml v.key)))]) @
           [Some (Ezxmlm.make_tag "Value" ([], (String.to_xml v.value)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("value", (String.to_json v.value));
           Some ("key", (String.to_json v.key))])
    let of_json j =
      {
        key = (String.of_json (Util.of_option_exn (Json.lookup j "key")));
        value = (String.of_json (Util.of_option_exn (Json.lookup j "value")))
      }
  end
module DocumentParameterType =
  struct
    type t =
      | String 
      | StringList 
    let str_to_t = [("StringList", StringList); ("String", String)]
    let t_to_str = [(StringList, "StringList"); (String, "String")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InventoryFilterList =
  struct
    type t = InventoryFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InventoryFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InventoryFilter.to_query v
    let to_headers v = Headers.to_headers_list InventoryFilter.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InventoryFilter.to_xml x)))
        v
    let to_json v = `List (List.map InventoryFilter.to_json v)
    let of_json j = Json.to_list InventoryFilter.of_json j
  end
module AutomationExecutionStatus =
  struct
    type t =
      | Pending 
      | InProgress 
      | Waiting 
      | Success 
      | TimedOut 
      | Cancelling 
      | Cancelled 
      | Failed 
    let str_to_t =
      [("Failed", Failed);
      ("Cancelled", Cancelled);
      ("Cancelling", Cancelling);
      ("TimedOut", TimedOut);
      ("Success", Success);
      ("Waiting", Waiting);
      ("InProgress", InProgress);
      ("Pending", Pending)]
    let t_to_str =
      [(Failed, "Failed");
      (Cancelled, "Cancelled");
      (Cancelling, "Cancelling");
      (TimedOut, "TimedOut");
      (Success, "Success");
      (Waiting, "Waiting");
      (InProgress, "InProgress");
      (Pending, "Pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FailureDetails =
  struct
    type t =
      {
      failure_stage: String.t option ;
      failure_type: String.t option ;
      details: AutomationParameterMap.t option }
    let make ?failure_stage  ?failure_type  ?details  () =
      { failure_stage; failure_type; details }
    let parse xml =
      Some
        {
          failure_stage =
            (Util.option_bind (Xml.member "FailureStage" xml) String.parse);
          failure_type =
            (Util.option_bind (Xml.member "FailureType" xml) String.parse);
          details =
            (Util.option_bind (Xml.member "Details" xml)
               AutomationParameterMap.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.failure_stage
                (fun f ->
                   Ezxmlm.make_tag "FailureStage" ([], (String.to_xml f)))])
            @
            [Util.option_map v.failure_type
               (fun f ->
                  Ezxmlm.make_tag "FailureType" ([], (String.to_xml f)))])
           @
           [Util.option_map v.details
              (fun f ->
                 Ezxmlm.make_tag "Details"
                   ([], (AutomationParameterMap.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.details
              (fun f -> ("details", (AutomationParameterMap.to_json f)));
           Util.option_map v.failure_type
             (fun f -> ("failure_type", (String.to_json f)));
           Util.option_map v.failure_stage
             (fun f -> ("failure_stage", (String.to_json f)))])
    let of_json j =
      {
        failure_stage =
          (Util.option_map (Json.lookup j "failure_stage") String.of_json);
        failure_type =
          (Util.option_map (Json.lookup j "failure_type") String.of_json);
        details =
          (Util.option_map (Json.lookup j "details")
             AutomationParameterMap.of_json)
      }
  end
module NormalStringMap =
  struct
    type t = (String.t, String.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string String.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc -> ((String.to_string k), (String.to_json v)) :: acc)
           v [])
    let of_json j = Json.to_hashtbl String.of_string String.of_json j
  end
module TargetLocation =
  struct
    type t =
      {
      accounts: Accounts.t ;
      regions: Regions.t ;
      target_location_max_concurrency: String.t option ;
      target_location_max_errors: String.t option ;
      execution_role_name: String.t option }
    let make ?(accounts= [])  ?(regions= []) 
      ?target_location_max_concurrency  ?target_location_max_errors 
      ?execution_role_name  () =
      {
        accounts;
        regions;
        target_location_max_concurrency;
        target_location_max_errors;
        execution_role_name
      }
    let parse xml =
      Some
        {
          accounts =
            (Util.of_option []
               (Util.option_bind (Xml.member "Accounts" xml) Accounts.parse));
          regions =
            (Util.of_option []
               (Util.option_bind (Xml.member "Regions" xml) Regions.parse));
          target_location_max_concurrency =
            (Util.option_bind (Xml.member "TargetLocationMaxConcurrency" xml)
               String.parse);
          target_location_max_errors =
            (Util.option_bind (Xml.member "TargetLocationMaxErrors" xml)
               String.parse);
          execution_role_name =
            (Util.option_bind (Xml.member "ExecutionRoleName" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Accounts"
                          ([], (Accounts.to_xml [x])))) v.accounts))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Regions" ([], (Regions.to_xml [x]))))
                 v.regions))
             @
             [Util.option_map v.target_location_max_concurrency
                (fun f ->
                   Ezxmlm.make_tag "TargetLocationMaxConcurrency"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.target_location_max_errors
               (fun f ->
                  Ezxmlm.make_tag "TargetLocationMaxErrors"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.execution_role_name
              (fun f ->
                 Ezxmlm.make_tag "ExecutionRoleName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.execution_role_name
              (fun f -> ("execution_role_name", (String.to_json f)));
           Util.option_map v.target_location_max_errors
             (fun f -> ("target_location_max_errors", (String.to_json f)));
           Util.option_map v.target_location_max_concurrency
             (fun f ->
                ("target_location_max_concurrency", (String.to_json f)));
           Some ("regions", (Regions.to_json v.regions));
           Some ("accounts", (Accounts.to_json v.accounts))])
    let of_json j =
      {
        accounts =
          (Accounts.of_json (Util.of_option_exn (Json.lookup j "accounts")));
        regions =
          (Regions.of_json (Util.of_option_exn (Json.lookup j "regions")));
        target_location_max_concurrency =
          (Util.option_map (Json.lookup j "target_location_max_concurrency")
             String.of_json);
        target_location_max_errors =
          (Util.option_map (Json.lookup j "target_location_max_errors")
             String.of_json);
        execution_role_name =
          (Util.option_map (Json.lookup j "execution_role_name")
             String.of_json)
      }
  end
module Targets =
  struct
    type t = Target.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Target.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list Target.to_query v
    let to_headers v = Headers.to_headers_list Target.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Target.to_xml x))) v
    let to_json v = `List (List.map Target.to_json v)
    let of_json j = Json.to_list Target.of_json j
  end
module ValidNextStepList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module OpsEntityItem =
  struct
    type t =
      {
      capture_time: String.t option ;
      content: OpsEntityItemEntryList.t }
    let make ?capture_time  ?(content= [])  () = { capture_time; content }
    let parse xml =
      Some
        {
          capture_time =
            (Util.option_bind (Xml.member "CaptureTime" xml) String.parse);
          content =
            (Util.of_option []
               (Util.option_bind (Xml.member "Content" xml)
                  OpsEntityItemEntryList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.capture_time
               (fun f ->
                  Ezxmlm.make_tag "CaptureTime" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Content"
                      ([], (OpsEntityItemEntryList.to_xml [x])))) v.content))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("content", (OpsEntityItemEntryList.to_json v.content));
           Util.option_map v.capture_time
             (fun f -> ("capture_time", (String.to_json f)))])
    let of_json j =
      {
        capture_time =
          (Util.option_map (Json.lookup j "capture_time") String.of_json);
        content =
          (OpsEntityItemEntryList.of_json
             (Util.of_option_exn (Json.lookup j "content")))
      }
  end
module PatchComplianceLevel =
  struct
    type t =
      | CRITICAL 
      | HIGH 
      | MEDIUM 
      | LOW 
      | INFORMATIONAL 
      | UNSPECIFIED 
    let str_to_t =
      [("UNSPECIFIED", UNSPECIFIED);
      ("INFORMATIONAL", INFORMATIONAL);
      ("LOW", LOW);
      ("MEDIUM", MEDIUM);
      ("HIGH", HIGH);
      ("CRITICAL", CRITICAL)]
    let t_to_str =
      [(UNSPECIFIED, "UNSPECIFIED");
      (INFORMATIONAL, "INFORMATIONAL");
      (LOW, "LOW");
      (MEDIUM, "MEDIUM");
      (HIGH, "HIGH");
      (CRITICAL, "CRITICAL")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PatchFilterGroup =
  struct
    type t = {
      patch_filters: PatchFilterList.t }
    let make ~patch_filters  () = { patch_filters }
    let parse xml =
      Some
        {
          patch_filters =
            (Xml.required "PatchFilters"
               (Util.option_bind (Xml.member "PatchFilters" xml)
                  PatchFilterList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "PatchFilters"
                      ([], (PatchFilterList.to_xml [x])))) v.patch_filters))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("patch_filters", (PatchFilterList.to_json v.patch_filters))])
    let of_json j =
      {
        patch_filters =
          (PatchFilterList.of_json
             (Util.of_option_exn (Json.lookup j "patch_filters")))
      }
  end
module AssociationStatusAggregatedCount =
  struct
    type t = (String.t, Integer.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string Integer.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc -> ((String.to_string k), (Integer.to_json v)) :: acc)
           v [])
    let of_json j = Json.to_hashtbl String.of_string Integer.of_json j
  end
module MaintenanceWindowTaskParameterValueExpression =
  struct
    type t = {
      values: MaintenanceWindowTaskParameterValueList.t }
    let make ?(values= [])  () = { values }
    let parse xml =
      Some
        {
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "Values" xml)
                  MaintenanceWindowTaskParameterValueList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Values"
                      ([],
                        (MaintenanceWindowTaskParameterValueList.to_xml [x]))))
              v.values))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("values",
                (MaintenanceWindowTaskParameterValueList.to_json v.values))])
    let of_json j =
      {
        values =
          (MaintenanceWindowTaskParameterValueList.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module InventoryResultItem =
  struct
    type t =
      {
      type_name: String.t ;
      schema_version: String.t ;
      capture_time: String.t option ;
      content_hash: String.t option ;
      content: InventoryItemEntryList.t }
    let make ~type_name  ~schema_version  ?capture_time  ?content_hash 
      ~content  () =
      { type_name; schema_version; capture_time; content_hash; content }
    let parse xml =
      Some
        {
          type_name =
            (Xml.required "TypeName"
               (Util.option_bind (Xml.member "TypeName" xml) String.parse));
          schema_version =
            (Xml.required "SchemaVersion"
               (Util.option_bind (Xml.member "SchemaVersion" xml)
                  String.parse));
          capture_time =
            (Util.option_bind (Xml.member "CaptureTime" xml) String.parse);
          content_hash =
            (Util.option_bind (Xml.member "ContentHash" xml) String.parse);
          content =
            (Xml.required "Content"
               (Util.option_bind (Xml.member "Content" xml)
                  InventoryItemEntryList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "TypeName"
                     ([], (String.to_xml v.type_name)))])
              @
              [Some
                 (Ezxmlm.make_tag "SchemaVersion"
                    ([], (String.to_xml v.schema_version)))])
             @
             [Util.option_map v.capture_time
                (fun f ->
                   Ezxmlm.make_tag "CaptureTime" ([], (String.to_xml f)))])
            @
            [Util.option_map v.content_hash
               (fun f ->
                  Ezxmlm.make_tag "ContentHash" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Content"
                      ([], (InventoryItemEntryList.to_xml [x])))) v.content))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("content", (InventoryItemEntryList.to_json v.content));
           Util.option_map v.content_hash
             (fun f -> ("content_hash", (String.to_json f)));
           Util.option_map v.capture_time
             (fun f -> ("capture_time", (String.to_json f)));
           Some ("schema_version", (String.to_json v.schema_version));
           Some ("type_name", (String.to_json v.type_name))])
    let of_json j =
      {
        type_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "type_name")));
        schema_version =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "schema_version")));
        capture_time =
          (Util.option_map (Json.lookup j "capture_time") String.of_json);
        content_hash =
          (Util.option_map (Json.lookup j "content_hash") String.of_json);
        content =
          (InventoryItemEntryList.of_json
             (Util.of_option_exn (Json.lookup j "content")))
      }
  end
module SeveritySummary =
  struct
    type t =
      {
      critical_count: Integer.t option ;
      high_count: Integer.t option ;
      medium_count: Integer.t option ;
      low_count: Integer.t option ;
      informational_count: Integer.t option ;
      unspecified_count: Integer.t option }
    let make ?critical_count  ?high_count  ?medium_count  ?low_count 
      ?informational_count  ?unspecified_count  () =
      {
        critical_count;
        high_count;
        medium_count;
        low_count;
        informational_count;
        unspecified_count
      }
    let parse xml =
      Some
        {
          critical_count =
            (Util.option_bind (Xml.member "CriticalCount" xml) Integer.parse);
          high_count =
            (Util.option_bind (Xml.member "HighCount" xml) Integer.parse);
          medium_count =
            (Util.option_bind (Xml.member "MediumCount" xml) Integer.parse);
          low_count =
            (Util.option_bind (Xml.member "LowCount" xml) Integer.parse);
          informational_count =
            (Util.option_bind (Xml.member "InformationalCount" xml)
               Integer.parse);
          unspecified_count =
            (Util.option_bind (Xml.member "UnspecifiedCount" xml)
               Integer.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.critical_count
                   (fun f ->
                      Ezxmlm.make_tag "CriticalCount"
                        ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.high_count
                  (fun f ->
                     Ezxmlm.make_tag "HighCount" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.medium_count
                 (fun f ->
                    Ezxmlm.make_tag "MediumCount" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.low_count
                (fun f -> Ezxmlm.make_tag "LowCount" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.informational_count
               (fun f ->
                  Ezxmlm.make_tag "InformationalCount"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.unspecified_count
              (fun f ->
                 Ezxmlm.make_tag "UnspecifiedCount" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.unspecified_count
              (fun f -> ("unspecified_count", (Integer.to_json f)));
           Util.option_map v.informational_count
             (fun f -> ("informational_count", (Integer.to_json f)));
           Util.option_map v.low_count
             (fun f -> ("low_count", (Integer.to_json f)));
           Util.option_map v.medium_count
             (fun f -> ("medium_count", (Integer.to_json f)));
           Util.option_map v.high_count
             (fun f -> ("high_count", (Integer.to_json f)));
           Util.option_map v.critical_count
             (fun f -> ("critical_count", (Integer.to_json f)))])
    let of_json j =
      {
        critical_count =
          (Util.option_map (Json.lookup j "critical_count") Integer.of_json);
        high_count =
          (Util.option_map (Json.lookup j "high_count") Integer.of_json);
        medium_count =
          (Util.option_map (Json.lookup j "medium_count") Integer.of_json);
        low_count =
          (Util.option_map (Json.lookup j "low_count") Integer.of_json);
        informational_count =
          (Util.option_map (Json.lookup j "informational_count")
             Integer.of_json);
        unspecified_count =
          (Util.option_map (Json.lookup j "unspecified_count")
             Integer.of_json)
      }
  end
module OpsItemDataValue =
  struct
    type t = {
      value: String.t option ;
      type_: OpsItemDataType.t option }
    let make ?value  ?type_  () = { value; type_ }
    let parse xml =
      Some
        {
          value = (Util.option_bind (Xml.member "Value" xml) String.parse);
          type_ =
            (Util.option_bind (Xml.member "Type" xml) OpsItemDataType.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.value
               (fun f -> Ezxmlm.make_tag "Value" ([], (String.to_xml f)))])
           @
           [Util.option_map v.type_
              (fun f ->
                 Ezxmlm.make_tag "Type" ([], (OpsItemDataType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> ("type_", (OpsItemDataType.to_json f)));
           Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      {
        value = (Util.option_map (Json.lookup j "value") String.of_json);
        type_ =
          (Util.option_map (Json.lookup j "type_") OpsItemDataType.of_json)
      }
  end
module OpsFilterOperatorType =
  struct
    type t =
      | Equal 
      | NotEqual 
      | BeginWith 
      | LessThan 
      | GreaterThan 
      | Exists 
    let str_to_t =
      [("Exists", Exists);
      ("GreaterThan", GreaterThan);
      ("LessThan", LessThan);
      ("BeginWith", BeginWith);
      ("NotEqual", NotEqual);
      ("Equal", Equal)]
    let t_to_str =
      [(Exists, "Exists");
      (GreaterThan, "GreaterThan");
      (LessThan, "LessThan");
      (BeginWith, "BeginWith");
      (NotEqual, "NotEqual");
      (Equal, "Equal")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module OpsFilterValueList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PatchDeploymentStatus =
  struct
    type t =
      | APPROVED 
      | PENDING_APPROVAL 
      | EXPLICIT_APPROVED 
      | EXPLICIT_REJECTED 
    let str_to_t =
      [("EXPLICIT_REJECTED", EXPLICIT_REJECTED);
      ("EXPLICIT_APPROVED", EXPLICIT_APPROVED);
      ("PENDING_APPROVAL", PENDING_APPROVAL);
      ("APPROVED", APPROVED)]
    let t_to_str =
      [(EXPLICIT_REJECTED, "EXPLICIT_REJECTED");
      (EXPLICIT_APPROVED, "EXPLICIT_APPROVED");
      (PENDING_APPROVAL, "PENDING_APPROVAL");
      (APPROVED, "APPROVED")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AssociationStatusName =
  struct
    type t =
      | Pending 
      | Success 
      | Failed 
    let str_to_t =
      [("Failed", Failed); ("Success", Success); ("Pending", Pending)]
    let t_to_str =
      [(Failed, "Failed"); (Success, "Success"); (Pending, "Pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AssociationComplianceSeverity =
  struct
    type t =
      | CRITICAL 
      | HIGH 
      | MEDIUM 
      | LOW 
      | UNSPECIFIED 
    let str_to_t =
      [("UNSPECIFIED", UNSPECIFIED);
      ("LOW", LOW);
      ("MEDIUM", MEDIUM);
      ("HIGH", HIGH);
      ("CRITICAL", CRITICAL)]
    let t_to_str =
      [(UNSPECIFIED, "UNSPECIFIED");
      (LOW, "LOW");
      (MEDIUM, "MEDIUM");
      (HIGH, "HIGH");
      (CRITICAL, "CRITICAL")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceAssociationOutputLocation =
  struct
    type t = {
      s3_location: S3OutputLocation.t option }
    let make ?s3_location  () = { s3_location }
    let parse xml =
      Some
        {
          s3_location =
            (Util.option_bind (Xml.member "S3Location" xml)
               S3OutputLocation.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.s3_location
              (fun f ->
                 Ezxmlm.make_tag "S3Location"
                   ([], (S3OutputLocation.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_location
              (fun f -> ("s3_location", (S3OutputLocation.to_json f)))])
    let of_json j =
      {
        s3_location =
          (Util.option_map (Json.lookup j "s3_location")
             S3OutputLocation.of_json)
      }
  end
module Parameters =
  struct
    type t = (String.t, ParameterValueList.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string ParameterValueList.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc ->
                  ((String.to_string k), (ParameterValueList.to_json v)) ::
                  acc) v [])
    let of_json j =
      Json.to_hashtbl String.of_string ParameterValueList.of_json j
  end
module InventoryDeletionSummaryItems =
  struct
    type t = InventoryDeletionSummaryItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InventoryDeletionSummaryItem.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list InventoryDeletionSummaryItem.to_query v
    let to_headers v =
      Headers.to_headers_list InventoryDeletionSummaryItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InventoryDeletionSummaryItem.to_xml x))) v
    let to_json v = `List (List.map InventoryDeletionSummaryItem.to_json v)
    let of_json j = Json.to_list InventoryDeletionSummaryItem.of_json j
  end
module S3OutputUrl =
  struct
    type t = {
      output_url: String.t option }
    let make ?output_url  () = { output_url }
    let parse xml =
      Some
        {
          output_url =
            (Util.option_bind (Xml.member "OutputUrl" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.output_url
              (fun f -> Ezxmlm.make_tag "OutputUrl" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.output_url
              (fun f -> ("output_url", (String.to_json f)))])
    let of_json j =
      {
        output_url =
          (Util.option_map (Json.lookup j "output_url") String.of_json)
      }
  end
module InventoryItemAttribute =
  struct
    type t = {
      name: String.t ;
      data_type: InventoryAttributeDataType.t }
    let make ~name  ~data_type  () = { name; data_type }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          data_type =
            (Xml.required "DataType"
               (Util.option_bind (Xml.member "DataType" xml)
                  InventoryAttributeDataType.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
           @
           [Some
              (Ezxmlm.make_tag "DataType"
                 ([], (InventoryAttributeDataType.to_xml v.data_type)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("data_type", (InventoryAttributeDataType.to_json v.data_type));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        data_type =
          (InventoryAttributeDataType.of_json
             (Util.of_option_exn (Json.lookup j "data_type")))
      }
  end
module CommandPlugin =
  struct
    type t =
      {
      name: String.t option ;
      status: CommandPluginStatus.t option ;
      status_details: String.t option ;
      response_code: Integer.t option ;
      response_start_date_time: DateTime.t option ;
      response_finish_date_time: DateTime.t option ;
      output: String.t option ;
      standard_output_url: String.t option ;
      standard_error_url: String.t option ;
      output_s3_region: String.t option ;
      output_s3_bucket_name: String.t option ;
      output_s3_key_prefix: String.t option }
    let make ?name  ?status  ?status_details  ?response_code 
      ?response_start_date_time  ?response_finish_date_time  ?output 
      ?standard_output_url  ?standard_error_url  ?output_s3_region 
      ?output_s3_bucket_name  ?output_s3_key_prefix  () =
      {
        name;
        status;
        status_details;
        response_code;
        response_start_date_time;
        response_finish_date_time;
        output;
        standard_output_url;
        standard_error_url;
        output_s3_region;
        output_s3_bucket_name;
        output_s3_key_prefix
      }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml)
               CommandPluginStatus.parse);
          status_details =
            (Util.option_bind (Xml.member "StatusDetails" xml) String.parse);
          response_code =
            (Util.option_bind (Xml.member "ResponseCode" xml) Integer.parse);
          response_start_date_time =
            (Util.option_bind (Xml.member "ResponseStartDateTime" xml)
               DateTime.parse);
          response_finish_date_time =
            (Util.option_bind (Xml.member "ResponseFinishDateTime" xml)
               DateTime.parse);
          output = (Util.option_bind (Xml.member "Output" xml) String.parse);
          standard_output_url =
            (Util.option_bind (Xml.member "StandardOutputUrl" xml)
               String.parse);
          standard_error_url =
            (Util.option_bind (Xml.member "StandardErrorUrl" xml)
               String.parse);
          output_s3_region =
            (Util.option_bind (Xml.member "OutputS3Region" xml) String.parse);
          output_s3_bucket_name =
            (Util.option_bind (Xml.member "OutputS3BucketName" xml)
               String.parse);
          output_s3_key_prefix =
            (Util.option_bind (Xml.member "OutputS3KeyPrefix" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Util.option_map v.name
                         (fun f ->
                            Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.status
                        (fun f ->
                           Ezxmlm.make_tag "Status"
                             ([], (CommandPluginStatus.to_xml f)))])
                    @
                    [Util.option_map v.status_details
                       (fun f ->
                          Ezxmlm.make_tag "StatusDetails"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.response_code
                      (fun f ->
                         Ezxmlm.make_tag "ResponseCode"
                           ([], (Integer.to_xml f)))])
                  @
                  [Util.option_map v.response_start_date_time
                     (fun f ->
                        Ezxmlm.make_tag "ResponseStartDateTime"
                          ([], (DateTime.to_xml f)))])
                 @
                 [Util.option_map v.response_finish_date_time
                    (fun f ->
                       Ezxmlm.make_tag "ResponseFinishDateTime"
                         ([], (DateTime.to_xml f)))])
                @
                [Util.option_map v.output
                   (fun f -> Ezxmlm.make_tag "Output" ([], (String.to_xml f)))])
               @
               [Util.option_map v.standard_output_url
                  (fun f ->
                     Ezxmlm.make_tag "StandardOutputUrl"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.standard_error_url
                 (fun f ->
                    Ezxmlm.make_tag "StandardErrorUrl"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.output_s3_region
                (fun f ->
                   Ezxmlm.make_tag "OutputS3Region" ([], (String.to_xml f)))])
            @
            [Util.option_map v.output_s3_bucket_name
               (fun f ->
                  Ezxmlm.make_tag "OutputS3BucketName"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.output_s3_key_prefix
              (fun f ->
                 Ezxmlm.make_tag "OutputS3KeyPrefix" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.output_s3_key_prefix
              (fun f -> ("output_s3_key_prefix", (String.to_json f)));
           Util.option_map v.output_s3_bucket_name
             (fun f -> ("output_s3_bucket_name", (String.to_json f)));
           Util.option_map v.output_s3_region
             (fun f -> ("output_s3_region", (String.to_json f)));
           Util.option_map v.standard_error_url
             (fun f -> ("standard_error_url", (String.to_json f)));
           Util.option_map v.standard_output_url
             (fun f -> ("standard_output_url", (String.to_json f)));
           Util.option_map v.output (fun f -> ("output", (String.to_json f)));
           Util.option_map v.response_finish_date_time
             (fun f -> ("response_finish_date_time", (DateTime.to_json f)));
           Util.option_map v.response_start_date_time
             (fun f -> ("response_start_date_time", (DateTime.to_json f)));
           Util.option_map v.response_code
             (fun f -> ("response_code", (Integer.to_json f)));
           Util.option_map v.status_details
             (fun f -> ("status_details", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (CommandPluginStatus.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             CommandPluginStatus.of_json);
        status_details =
          (Util.option_map (Json.lookup j "status_details") String.of_json);
        response_code =
          (Util.option_map (Json.lookup j "response_code") Integer.of_json);
        response_start_date_time =
          (Util.option_map (Json.lookup j "response_start_date_time")
             DateTime.of_json);
        response_finish_date_time =
          (Util.option_map (Json.lookup j "response_finish_date_time")
             DateTime.of_json);
        output = (Util.option_map (Json.lookup j "output") String.of_json);
        standard_output_url =
          (Util.option_map (Json.lookup j "standard_output_url")
             String.of_json);
        standard_error_url =
          (Util.option_map (Json.lookup j "standard_error_url")
             String.of_json);
        output_s3_region =
          (Util.option_map (Json.lookup j "output_s3_region") String.of_json);
        output_s3_bucket_name =
          (Util.option_map (Json.lookup j "output_s3_bucket_name")
             String.of_json);
        output_s3_key_prefix =
          (Util.option_map (Json.lookup j "output_s3_key_prefix")
             String.of_json)
      }
  end
module ResourceDataSyncS3Format =
  struct
    type t =
      | JsonSerDe 
    let str_to_t = [("JsonSerDe", JsonSerDe)]
    let t_to_str = [(JsonSerDe, "JsonSerDe")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ResourceDataSyncAwsOrganizationsSource =
  struct
    type t =
      {
      organization_source_type: String.t ;
      organizational_units: ResourceDataSyncOrganizationalUnitList.t }
    let make ~organization_source_type  ?(organizational_units= [])  () =
      { organization_source_type; organizational_units }
    let parse xml =
      Some
        {
          organization_source_type =
            (Xml.required "OrganizationSourceType"
               (Util.option_bind (Xml.member "OrganizationSourceType" xml)
                  String.parse));
          organizational_units =
            (Util.of_option []
               (Util.option_bind (Xml.member "OrganizationalUnits" xml)
                  ResourceDataSyncOrganizationalUnitList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "OrganizationSourceType"
                  ([], (String.to_xml v.organization_source_type)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "OrganizationalUnits"
                      ([],
                        (ResourceDataSyncOrganizationalUnitList.to_xml [x]))))
              v.organizational_units))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("organizational_units",
                (ResourceDataSyncOrganizationalUnitList.to_json
                   v.organizational_units));
           Some
             ("organization_source_type",
               (String.to_json v.organization_source_type))])
    let of_json j =
      {
        organization_source_type =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "organization_source_type")));
        organizational_units =
          (ResourceDataSyncOrganizationalUnitList.of_json
             (Util.of_option_exn (Json.lookup j "organizational_units")))
      }
  end
module ResourceDataSyncSourceRegionList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module OperatingSystem =
  struct
    type t =
      | WINDOWS 
      | AMAZON_LINUX 
      | AMAZON_LINUX_2 
      | UBUNTU 
      | REDHAT_ENTERPRISE_LINUX 
      | SUSE 
      | CENTOS 
    let str_to_t =
      [("CENTOS", CENTOS);
      ("SUSE", SUSE);
      ("REDHAT_ENTERPRISE_LINUX", REDHAT_ENTERPRISE_LINUX);
      ("UBUNTU", UBUNTU);
      ("AMAZON_LINUX_2", AMAZON_LINUX_2);
      ("AMAZON_LINUX", AMAZON_LINUX);
      ("WINDOWS", WINDOWS)]
    let t_to_str =
      [(CENTOS, "CENTOS");
      (SUSE, "SUSE");
      (REDHAT_ENTERPRISE_LINUX, "REDHAT_ENTERPRISE_LINUX");
      (UBUNTU, "UBUNTU");
      (AMAZON_LINUX_2, "AMAZON_LINUX_2");
      (AMAZON_LINUX, "AMAZON_LINUX");
      (WINDOWS, "WINDOWS")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ComplianceQueryOperatorType =
  struct
    type t =
      | EQUAL 
      | NOT_EQUAL 
      | BEGIN_WITH 
      | LESS_THAN 
      | GREATER_THAN 
    let str_to_t =
      [("GREATER_THAN", GREATER_THAN);
      ("LESS_THAN", LESS_THAN);
      ("BEGIN_WITH", BEGIN_WITH);
      ("NOT_EQUAL", NOT_EQUAL);
      ("EQUAL", EQUAL)]
    let t_to_str =
      [(GREATER_THAN, "GREATER_THAN");
      (LESS_THAN, "LESS_THAN");
      (BEGIN_WITH, "BEGIN_WITH");
      (NOT_EQUAL, "NOT_EQUAL");
      (EQUAL, "EQUAL")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ComplianceStringFilterValueList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ParameterPolicyList =
  struct
    type t = ParameterInlinePolicy.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ParameterInlinePolicy.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list ParameterInlinePolicy.to_query v
    let to_headers v =
      Headers.to_headers_list ParameterInlinePolicy.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ParameterInlinePolicy.to_xml x))) v
    let to_json v = `List (List.map ParameterInlinePolicy.to_json v)
    let of_json j = Json.to_list ParameterInlinePolicy.of_json j
  end
module ParameterTier =
  struct
    type t =
      | Standard 
      | Advanced 
      | Intelligent_Tiering 
    let str_to_t =
      [("Intelligent-Tiering", Intelligent_Tiering);
      ("Advanced", Advanced);
      ("Standard", Standard)]
    let t_to_str =
      [(Intelligent_Tiering, "Intelligent-Tiering");
      (Advanced, "Advanced");
      (Standard, "Standard")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ParameterType =
  struct
    type t =
      | String 
      | StringList 
      | SecureString 
    let str_to_t =
      [("SecureString", SecureString);
      ("StringList", StringList);
      ("String", String)]
    let t_to_str =
      [(SecureString, "SecureString");
      (StringList, "StringList");
      (String, "String")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CloudWatchOutputConfig =
  struct
    type t =
      {
      cloud_watch_log_group_name: String.t option ;
      cloud_watch_output_enabled: Boolean.t option }
    let make ?cloud_watch_log_group_name  ?cloud_watch_output_enabled  () =
      { cloud_watch_log_group_name; cloud_watch_output_enabled }
    let parse xml =
      Some
        {
          cloud_watch_log_group_name =
            (Util.option_bind (Xml.member "CloudWatchLogGroupName" xml)
               String.parse);
          cloud_watch_output_enabled =
            (Util.option_bind (Xml.member "CloudWatchOutputEnabled" xml)
               Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.cloud_watch_log_group_name
               (fun f ->
                  Ezxmlm.make_tag "CloudWatchLogGroupName"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.cloud_watch_output_enabled
              (fun f ->
                 Ezxmlm.make_tag "CloudWatchOutputEnabled"
                   ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cloud_watch_output_enabled
              (fun f -> ("cloud_watch_output_enabled", (Boolean.to_json f)));
           Util.option_map v.cloud_watch_log_group_name
             (fun f -> ("cloud_watch_log_group_name", (String.to_json f)))])
    let of_json j =
      {
        cloud_watch_log_group_name =
          (Util.option_map (Json.lookup j "cloud_watch_log_group_name")
             String.of_json);
        cloud_watch_output_enabled =
          (Util.option_map (Json.lookup j "cloud_watch_output_enabled")
             Boolean.of_json)
      }
  end
module DocumentHashType =
  struct
    type t =
      | Sha256 
      | Sha1 
    let str_to_t = [("Sha1", Sha1); ("Sha256", Sha256)]
    let t_to_str = [(Sha1, "Sha1"); (Sha256, "Sha256")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NotificationConfig =
  struct
    type t =
      {
      notification_arn: String.t option ;
      notification_events: NotificationEventList.t ;
      notification_type: NotificationType.t option }
    let make ?notification_arn  ?(notification_events= []) 
      ?notification_type  () =
      { notification_arn; notification_events; notification_type }
    let parse xml =
      Some
        {
          notification_arn =
            (Util.option_bind (Xml.member "NotificationArn" xml) String.parse);
          notification_events =
            (Util.of_option []
               (Util.option_bind (Xml.member "NotificationEvents" xml)
                  NotificationEventList.parse));
          notification_type =
            (Util.option_bind (Xml.member "NotificationType" xml)
               NotificationType.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.notification_arn
                (fun f ->
                   Ezxmlm.make_tag "NotificationArn" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "NotificationEvents"
                       ([], (NotificationEventList.to_xml [x]))))
               v.notification_events))
           @
           [Util.option_map v.notification_type
              (fun f ->
                 Ezxmlm.make_tag "NotificationType"
                   ([], (NotificationType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.notification_type
              (fun f -> ("notification_type", (NotificationType.to_json f)));
           Some
             ("notification_events",
               (NotificationEventList.to_json v.notification_events));
           Util.option_map v.notification_arn
             (fun f -> ("notification_arn", (String.to_json f)))])
    let of_json j =
      {
        notification_arn =
          (Util.option_map (Json.lookup j "notification_arn") String.of_json);
        notification_events =
          (NotificationEventList.of_json
             (Util.of_option_exn (Json.lookup j "notification_events")));
        notification_type =
          (Util.option_map (Json.lookup j "notification_type")
             NotificationType.of_json)
      }
  end
module AssociationFilterKey =
  struct
    type t =
      | InstanceId 
      | Name 
      | AssociationId 
      | AssociationStatusName 
      | LastExecutedBefore 
      | LastExecutedAfter 
      | AssociationName 
    let str_to_t =
      [("AssociationName", AssociationName);
      ("LastExecutedAfter", LastExecutedAfter);
      ("LastExecutedBefore", LastExecutedBefore);
      ("AssociationStatusName", AssociationStatusName);
      ("AssociationId", AssociationId);
      ("Name", Name);
      ("InstanceId", InstanceId)]
    let t_to_str =
      [(AssociationName, "AssociationName");
      (LastExecutedAfter, "LastExecutedAfter");
      (LastExecutedBefore, "LastExecutedBefore");
      (AssociationStatusName, "AssociationStatusName");
      (AssociationId, "AssociationId");
      (Name, "Name");
      (InstanceId, "InstanceId")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ParameterLabelList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InstanceAggregatedAssociationOverview =
  struct
    type t =
      {
      detailed_status: String.t option ;
      instance_association_status_aggregated_count:
        InstanceAssociationStatusAggregatedCount.t option }
    let make ?detailed_status  ?instance_association_status_aggregated_count 
      () = { detailed_status; instance_association_status_aggregated_count }
    let parse xml =
      Some
        {
          detailed_status =
            (Util.option_bind (Xml.member "DetailedStatus" xml) String.parse);
          instance_association_status_aggregated_count =
            (Util.option_bind
               (Xml.member "InstanceAssociationStatusAggregatedCount" xml)
               InstanceAssociationStatusAggregatedCount.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.detailed_status
               (fun f ->
                  Ezxmlm.make_tag "DetailedStatus" ([], (String.to_xml f)))])
           @
           [Util.option_map v.instance_association_status_aggregated_count
              (fun f ->
                 Ezxmlm.make_tag "InstanceAssociationStatusAggregatedCount"
                   ([], (InstanceAssociationStatusAggregatedCount.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_association_status_aggregated_count
              (fun f ->
                 ("instance_association_status_aggregated_count",
                   (InstanceAssociationStatusAggregatedCount.to_json f)));
           Util.option_map v.detailed_status
             (fun f -> ("detailed_status", (String.to_json f)))])
    let of_json j =
      {
        detailed_status =
          (Util.option_map (Json.lookup j "detailed_status") String.of_json);
        instance_association_status_aggregated_count =
          (Util.option_map
             (Json.lookup j "instance_association_status_aggregated_count")
             InstanceAssociationStatusAggregatedCount.of_json)
      }
  end
module PingStatus =
  struct
    type t =
      | Online 
      | ConnectionLost 
      | Inactive 
    let str_to_t =
      [("Inactive", Inactive);
      ("ConnectionLost", ConnectionLost);
      ("Online", Online)]
    let t_to_str =
      [(Inactive, "Inactive");
      (ConnectionLost, "ConnectionLost");
      (Online, "Online")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ResourceType =
  struct
    type t =
      | ManagedInstance 
      | Document 
      | EC2Instance 
    let str_to_t =
      [("EC2Instance", EC2Instance);
      ("Document", Document);
      ("ManagedInstance", ManagedInstance)]
    let t_to_str =
      [(EC2Instance, "EC2Instance");
      (Document, "Document");
      (ManagedInstance, "ManagedInstance")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DocumentFormat =
  struct
    type t =
      | YAML 
      | JSON 
      | TEXT 
    let str_to_t = [("TEXT", TEXT); ("JSON", JSON); ("YAML", YAML)]
    let t_to_str = [(TEXT, "TEXT"); (JSON, "JSON"); (YAML, "YAML")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DocumentStatus =
  struct
    type t =
      | Creating 
      | Active 
      | Updating 
      | Deleting 
      | Failed 
    let str_to_t =
      [("Failed", Failed);
      ("Deleting", Deleting);
      ("Updating", Updating);
      ("Active", Active);
      ("Creating", Creating)]
    let t_to_str =
      [(Failed, "Failed");
      (Deleting, "Deleting");
      (Updating, "Updating");
      (Active, "Active");
      (Creating, "Creating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AssociationExecutionTargetsFilterKey =
  struct
    type t =
      | Status 
      | ResourceId 
      | ResourceType 
    let str_to_t =
      [("ResourceType", ResourceType);
      ("ResourceId", ResourceId);
      ("Status", Status)]
    let t_to_str =
      [(ResourceType, "ResourceType");
      (ResourceId, "ResourceId");
      (Status, "Status")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module StepExecutionFilterKey =
  struct
    type t =
      | StartTimeBefore 
      | StartTimeAfter 
      | StepExecutionStatus 
      | StepExecutionId 
      | StepName 
      | Action 
    let str_to_t =
      [("Action", Action);
      ("StepName", StepName);
      ("StepExecutionId", StepExecutionId);
      ("StepExecutionStatus", StepExecutionStatus);
      ("StartTimeAfter", StartTimeAfter);
      ("StartTimeBefore", StartTimeBefore)]
    let t_to_str =
      [(Action, "Action");
      (StepName, "StepName");
      (StepExecutionId, "StepExecutionId");
      (StepExecutionStatus, "StepExecutionStatus");
      (StartTimeAfter, "StartTimeAfter");
      (StartTimeBefore, "StartTimeBefore")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module StepExecutionFilterValueList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AutomationType =
  struct
    type t =
      | CrossAccount 
      | Local 
    let str_to_t = [("Local", Local); ("CrossAccount", CrossAccount)]
    let t_to_str = [(Local, "Local"); (CrossAccount, "CrossAccount")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ExecutionMode =
  struct
    type t =
      | Auto 
      | Interactive 
    let str_to_t = [("Interactive", Interactive); ("Auto", Auto)]
    let t_to_str = [(Interactive, "Interactive"); (Auto, "Auto")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ResolvedTargets =
  struct
    type t =
      {
      parameter_values: TargetParameterList.t ;
      truncated: Boolean.t option }
    let make ?(parameter_values= [])  ?truncated  () =
      { parameter_values; truncated }
    let parse xml =
      Some
        {
          parameter_values =
            (Util.of_option []
               (Util.option_bind (Xml.member "ParameterValues" xml)
                  TargetParameterList.parse));
          truncated =
            (Util.option_bind (Xml.member "Truncated" xml) Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ParameterValues"
                       ([], (TargetParameterList.to_xml [x]))))
               v.parameter_values))
           @
           [Util.option_map v.truncated
              (fun f -> Ezxmlm.make_tag "Truncated" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.truncated
              (fun f -> ("truncated", (Boolean.to_json f)));
           Some
             ("parameter_values",
               (TargetParameterList.to_json v.parameter_values))])
    let of_json j =
      {
        parameter_values =
          (TargetParameterList.of_json
             (Util.of_option_exn (Json.lookup j "parameter_values")));
        truncated =
          (Util.option_map (Json.lookup j "truncated") Boolean.of_json)
      }
  end
module TargetMaps =
  struct
    type t = TargetMap.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map TargetMap.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list TargetMap.to_query v
    let to_headers v = Headers.to_headers_list TargetMap.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (TargetMap.to_xml x)))
        v
    let to_json v = `List (List.map TargetMap.to_json v)
    let of_json j = Json.to_list TargetMap.of_json j
  end
module DocumentRequiresList =
  struct
    type t = DocumentRequires.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DocumentRequires.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list DocumentRequires.to_query v
    let to_headers v = Headers.to_headers_list DocumentRequires.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (DocumentRequires.to_xml x)))
        v
    let to_json v = `List (List.map DocumentRequires.to_json v)
    let of_json j = Json.to_list DocumentRequires.of_json j
  end
module DocumentType =
  struct
    type t =
      | Command 
      | Policy 
      | Automation 
      | Session 
      | Package 
      | ApplicationConfiguration 
      | ApplicationConfigurationSchema 
      | DeploymentStrategy 
      | ChangeCalendar 
    let str_to_t =
      [("ChangeCalendar", ChangeCalendar);
      ("DeploymentStrategy", DeploymentStrategy);
      ("ApplicationConfigurationSchema", ApplicationConfigurationSchema);
      ("ApplicationConfiguration", ApplicationConfiguration);
      ("Package", Package);
      ("Session", Session);
      ("Automation", Automation);
      ("Policy", Policy);
      ("Command", Command)]
    let t_to_str =
      [(ChangeCalendar, "ChangeCalendar");
      (DeploymentStrategy, "DeploymentStrategy");
      (ApplicationConfigurationSchema, "ApplicationConfigurationSchema");
      (ApplicationConfiguration, "ApplicationConfiguration");
      (Package, "Package");
      (Session, "Session");
      (Automation, "Automation");
      (Policy, "Policy");
      (Command, "Command")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PlatformTypeList =
  struct
    type t = PlatformType.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PlatformType.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list PlatformType.to_query v
    let to_headers v = Headers.to_headers_list PlatformType.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PlatformType.to_xml x))) v
    let to_json v = `List (List.map PlatformType.to_json v)
    let of_json j = Json.to_list PlatformType.of_json j
  end
module TagList =
  struct
    type t = Tag.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Tag.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list Tag.to_query v
    let to_headers v = Headers.to_headers_list Tag.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Tag.to_xml x))) v
    let to_json v = `List (List.map Tag.to_json v)
    let of_json j = Json.to_list Tag.of_json j
  end
module InstanceInformationFilterKey =
  struct
    type t =
      | InstanceIds 
      | AgentVersion 
      | PingStatus 
      | PlatformTypes 
      | ActivationIds 
      | IamRole 
      | ResourceType 
      | AssociationStatus 
    let str_to_t =
      [("AssociationStatus", AssociationStatus);
      ("ResourceType", ResourceType);
      ("IamRole", IamRole);
      ("ActivationIds", ActivationIds);
      ("PlatformTypes", PlatformTypes);
      ("PingStatus", PingStatus);
      ("AgentVersion", AgentVersion);
      ("InstanceIds", InstanceIds)]
    let t_to_str =
      [(AssociationStatus, "AssociationStatus");
      (ResourceType, "ResourceType");
      (IamRole, "IamRole");
      (ActivationIds, "ActivationIds");
      (PlatformTypes, "PlatformTypes");
      (PingStatus, "PingStatus");
      (AgentVersion, "AgentVersion");
      (InstanceIds, "InstanceIds")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceInformationFilterValueSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AttachmentInformation =
  struct
    type t = {
      name: String.t option }
    let make ?name  () = { name }
    let parse xml =
      Some { name = (Util.option_bind (Xml.member "Name" xml) String.parse) }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.name
              (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      { name = (Util.option_map (Json.lookup j "name") String.of_json) }
  end
module DocumentParameter =
  struct
    type t =
      {
      name: String.t option ;
      type_: DocumentParameterType.t option ;
      description: String.t option ;
      default_value: String.t option }
    let make ?name  ?type_  ?description  ?default_value  () =
      { name; type_; description; default_value }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          type_ =
            (Util.option_bind (Xml.member "Type" xml)
               DocumentParameterType.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          default_value =
            (Util.option_bind (Xml.member "DefaultValue" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.name
                 (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
             @
             [Util.option_map v.type_
                (fun f ->
                   Ezxmlm.make_tag "Type"
                     ([], (DocumentParameterType.to_xml f)))])
            @
            [Util.option_map v.description
               (fun f ->
                  Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
           @
           [Util.option_map v.default_value
              (fun f ->
                 Ezxmlm.make_tag "DefaultValue" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.default_value
              (fun f -> ("default_value", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (DocumentParameterType.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        type_ =
          (Util.option_map (Json.lookup j "type_")
             DocumentParameterType.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        default_value =
          (Util.option_map (Json.lookup j "default_value") String.of_json)
      }
  end
module InventoryGroup =
  struct
    type t = {
      name: String.t ;
      filters: InventoryFilterList.t }
    let make ~name  ~filters  () = { name; filters }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          filters =
            (Xml.required "Filters"
               (Util.option_bind (Xml.member "Filters" xml)
                  InventoryFilterList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Filters"
                      ([], (InventoryFilterList.to_xml [x])))) v.filters))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (InventoryFilterList.to_json v.filters));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        filters =
          (InventoryFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module StepExecution =
  struct
    type t =
      {
      step_name: String.t option ;
      action: String.t option ;
      timeout_seconds: Long.t option ;
      on_failure: String.t option ;
      max_attempts: Integer.t option ;
      execution_start_time: DateTime.t option ;
      execution_end_time: DateTime.t option ;
      step_status: AutomationExecutionStatus.t option ;
      response_code: String.t option ;
      inputs: NormalStringMap.t option ;
      outputs: AutomationParameterMap.t option ;
      response: String.t option ;
      failure_message: String.t option ;
      failure_details: FailureDetails.t option ;
      step_execution_id: String.t option ;
      overridden_parameters: AutomationParameterMap.t option ;
      is_end: Boolean.t option ;
      next_step: String.t option ;
      is_critical: Boolean.t option ;
      valid_next_steps: ValidNextStepList.t ;
      targets: Targets.t ;
      target_location: TargetLocation.t option }
    let make ?step_name  ?action  ?timeout_seconds  ?on_failure 
      ?max_attempts  ?execution_start_time  ?execution_end_time  ?step_status
       ?response_code  ?inputs  ?outputs  ?response  ?failure_message 
      ?failure_details  ?step_execution_id  ?overridden_parameters  ?is_end 
      ?next_step  ?is_critical  ?(valid_next_steps= [])  ?(targets= []) 
      ?target_location  () =
      {
        step_name;
        action;
        timeout_seconds;
        on_failure;
        max_attempts;
        execution_start_time;
        execution_end_time;
        step_status;
        response_code;
        inputs;
        outputs;
        response;
        failure_message;
        failure_details;
        step_execution_id;
        overridden_parameters;
        is_end;
        next_step;
        is_critical;
        valid_next_steps;
        targets;
        target_location
      }
    let parse xml =
      Some
        {
          step_name =
            (Util.option_bind (Xml.member "StepName" xml) String.parse);
          action = (Util.option_bind (Xml.member "Action" xml) String.parse);
          timeout_seconds =
            (Util.option_bind (Xml.member "TimeoutSeconds" xml) Long.parse);
          on_failure =
            (Util.option_bind (Xml.member "OnFailure" xml) String.parse);
          max_attempts =
            (Util.option_bind (Xml.member "MaxAttempts" xml) Integer.parse);
          execution_start_time =
            (Util.option_bind (Xml.member "ExecutionStartTime" xml)
               DateTime.parse);
          execution_end_time =
            (Util.option_bind (Xml.member "ExecutionEndTime" xml)
               DateTime.parse);
          step_status =
            (Util.option_bind (Xml.member "StepStatus" xml)
               AutomationExecutionStatus.parse);
          response_code =
            (Util.option_bind (Xml.member "ResponseCode" xml) String.parse);
          inputs =
            (Util.option_bind (Xml.member "Inputs" xml) NormalStringMap.parse);
          outputs =
            (Util.option_bind (Xml.member "Outputs" xml)
               AutomationParameterMap.parse);
          response =
            (Util.option_bind (Xml.member "Response" xml) String.parse);
          failure_message =
            (Util.option_bind (Xml.member "FailureMessage" xml) String.parse);
          failure_details =
            (Util.option_bind (Xml.member "FailureDetails" xml)
               FailureDetails.parse);
          step_execution_id =
            (Util.option_bind (Xml.member "StepExecutionId" xml) String.parse);
          overridden_parameters =
            (Util.option_bind (Xml.member "OverriddenParameters" xml)
               AutomationParameterMap.parse);
          is_end = (Util.option_bind (Xml.member "IsEnd" xml) Boolean.parse);
          next_step =
            (Util.option_bind (Xml.member "NextStep" xml) String.parse);
          is_critical =
            (Util.option_bind (Xml.member "IsCritical" xml) Boolean.parse);
          valid_next_steps =
            (Util.of_option []
               (Util.option_bind (Xml.member "ValidNextSteps" xml)
                  ValidNextStepList.parse));
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          target_location =
            (Util.option_bind (Xml.member "TargetLocation" xml)
               TargetLocation.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((((((([] @
                                [Util.option_map v.step_name
                                   (fun f ->
                                      Ezxmlm.make_tag "StepName"
                                        ([], (String.to_xml f)))])
                               @
                               [Util.option_map v.action
                                  (fun f ->
                                     Ezxmlm.make_tag "Action"
                                       ([], (String.to_xml f)))])
                              @
                              [Util.option_map v.timeout_seconds
                                 (fun f ->
                                    Ezxmlm.make_tag "TimeoutSeconds"
                                      ([], (Long.to_xml f)))])
                             @
                             [Util.option_map v.on_failure
                                (fun f ->
                                   Ezxmlm.make_tag "OnFailure"
                                     ([], (String.to_xml f)))])
                            @
                            [Util.option_map v.max_attempts
                               (fun f ->
                                  Ezxmlm.make_tag "MaxAttempts"
                                    ([], (Integer.to_xml f)))])
                           @
                           [Util.option_map v.execution_start_time
                              (fun f ->
                                 Ezxmlm.make_tag "ExecutionStartTime"
                                   ([], (DateTime.to_xml f)))])
                          @
                          [Util.option_map v.execution_end_time
                             (fun f ->
                                Ezxmlm.make_tag "ExecutionEndTime"
                                  ([], (DateTime.to_xml f)))])
                         @
                         [Util.option_map v.step_status
                            (fun f ->
                               Ezxmlm.make_tag "StepStatus"
                                 ([], (AutomationExecutionStatus.to_xml f)))])
                        @
                        [Util.option_map v.response_code
                           (fun f ->
                              Ezxmlm.make_tag "ResponseCode"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.inputs
                          (fun f ->
                             Ezxmlm.make_tag "Inputs"
                               ([], (NormalStringMap.to_xml f)))])
                      @
                      [Util.option_map v.outputs
                         (fun f ->
                            Ezxmlm.make_tag "Outputs"
                              ([], (AutomationParameterMap.to_xml f)))])
                     @
                     [Util.option_map v.response
                        (fun f ->
                           Ezxmlm.make_tag "Response" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.failure_message
                       (fun f ->
                          Ezxmlm.make_tag "FailureMessage"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.failure_details
                      (fun f ->
                         Ezxmlm.make_tag "FailureDetails"
                           ([], (FailureDetails.to_xml f)))])
                  @
                  [Util.option_map v.step_execution_id
                     (fun f ->
                        Ezxmlm.make_tag "StepExecutionId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.overridden_parameters
                    (fun f ->
                       Ezxmlm.make_tag "OverriddenParameters"
                         ([], (AutomationParameterMap.to_xml f)))])
                @
                [Util.option_map v.is_end
                   (fun f -> Ezxmlm.make_tag "IsEnd" ([], (Boolean.to_xml f)))])
               @
               [Util.option_map v.next_step
                  (fun f ->
                     Ezxmlm.make_tag "NextStep" ([], (String.to_xml f)))])
              @
              [Util.option_map v.is_critical
                 (fun f ->
                    Ezxmlm.make_tag "IsCritical" ([], (Boolean.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "ValidNextSteps"
                        ([], (ValidNextStepList.to_xml [x]))))
                v.valid_next_steps))
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "Targets" ([], (Targets.to_xml [x]))))
               v.targets))
           @
           [Util.option_map v.target_location
              (fun f ->
                 Ezxmlm.make_tag "TargetLocation"
                   ([], (TargetLocation.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_location
              (fun f -> ("target_location", (TargetLocation.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Some
             ("valid_next_steps",
               (ValidNextStepList.to_json v.valid_next_steps));
           Util.option_map v.is_critical
             (fun f -> ("is_critical", (Boolean.to_json f)));
           Util.option_map v.next_step
             (fun f -> ("next_step", (String.to_json f)));
           Util.option_map v.is_end
             (fun f -> ("is_end", (Boolean.to_json f)));
           Util.option_map v.overridden_parameters
             (fun f ->
                ("overridden_parameters", (AutomationParameterMap.to_json f)));
           Util.option_map v.step_execution_id
             (fun f -> ("step_execution_id", (String.to_json f)));
           Util.option_map v.failure_details
             (fun f -> ("failure_details", (FailureDetails.to_json f)));
           Util.option_map v.failure_message
             (fun f -> ("failure_message", (String.to_json f)));
           Util.option_map v.response
             (fun f -> ("response", (String.to_json f)));
           Util.option_map v.outputs
             (fun f -> ("outputs", (AutomationParameterMap.to_json f)));
           Util.option_map v.inputs
             (fun f -> ("inputs", (NormalStringMap.to_json f)));
           Util.option_map v.response_code
             (fun f -> ("response_code", (String.to_json f)));
           Util.option_map v.step_status
             (fun f -> ("step_status", (AutomationExecutionStatus.to_json f)));
           Util.option_map v.execution_end_time
             (fun f -> ("execution_end_time", (DateTime.to_json f)));
           Util.option_map v.execution_start_time
             (fun f -> ("execution_start_time", (DateTime.to_json f)));
           Util.option_map v.max_attempts
             (fun f -> ("max_attempts", (Integer.to_json f)));
           Util.option_map v.on_failure
             (fun f -> ("on_failure", (String.to_json f)));
           Util.option_map v.timeout_seconds
             (fun f -> ("timeout_seconds", (Long.to_json f)));
           Util.option_map v.action (fun f -> ("action", (String.to_json f)));
           Util.option_map v.step_name
             (fun f -> ("step_name", (String.to_json f)))])
    let of_json j =
      {
        step_name =
          (Util.option_map (Json.lookup j "step_name") String.of_json);
        action = (Util.option_map (Json.lookup j "action") String.of_json);
        timeout_seconds =
          (Util.option_map (Json.lookup j "timeout_seconds") Long.of_json);
        on_failure =
          (Util.option_map (Json.lookup j "on_failure") String.of_json);
        max_attempts =
          (Util.option_map (Json.lookup j "max_attempts") Integer.of_json);
        execution_start_time =
          (Util.option_map (Json.lookup j "execution_start_time")
             DateTime.of_json);
        execution_end_time =
          (Util.option_map (Json.lookup j "execution_end_time")
             DateTime.of_json);
        step_status =
          (Util.option_map (Json.lookup j "step_status")
             AutomationExecutionStatus.of_json);
        response_code =
          (Util.option_map (Json.lookup j "response_code") String.of_json);
        inputs =
          (Util.option_map (Json.lookup j "inputs") NormalStringMap.of_json);
        outputs =
          (Util.option_map (Json.lookup j "outputs")
             AutomationParameterMap.of_json);
        response =
          (Util.option_map (Json.lookup j "response") String.of_json);
        failure_message =
          (Util.option_map (Json.lookup j "failure_message") String.of_json);
        failure_details =
          (Util.option_map (Json.lookup j "failure_details")
             FailureDetails.of_json);
        step_execution_id =
          (Util.option_map (Json.lookup j "step_execution_id") String.of_json);
        overridden_parameters =
          (Util.option_map (Json.lookup j "overridden_parameters")
             AutomationParameterMap.of_json);
        is_end = (Util.option_map (Json.lookup j "is_end") Boolean.of_json);
        next_step =
          (Util.option_map (Json.lookup j "next_step") String.of_json);
        is_critical =
          (Util.option_map (Json.lookup j "is_critical") Boolean.of_json);
        valid_next_steps =
          (ValidNextStepList.of_json
             (Util.of_option_exn (Json.lookup j "valid_next_steps")));
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        target_location =
          (Util.option_map (Json.lookup j "target_location")
             TargetLocation.of_json)
      }
  end
module AssociationExecutionFilterKey =
  struct
    type t =
      | ExecutionId 
      | Status 
      | CreatedTime 
    let str_to_t =
      [("CreatedTime", CreatedTime);
      ("Status", Status);
      ("ExecutionId", ExecutionId)]
    let t_to_str =
      [(CreatedTime, "CreatedTime");
      (Status, "Status");
      (ExecutionId, "ExecutionId")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AssociationFilterOperatorType =
  struct
    type t =
      | EQUAL 
      | LESS_THAN 
      | GREATER_THAN 
    let str_to_t =
      [("GREATER_THAN", GREATER_THAN);
      ("LESS_THAN", LESS_THAN);
      ("EQUAL", EQUAL)]
    let t_to_str =
      [(GREATER_THAN, "GREATER_THAN");
      (LESS_THAN, "LESS_THAN");
      (EQUAL, "EQUAL")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module OpsEntityItemMap =
  struct
    type t = (String.t, OpsEntityItem.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string OpsEntityItem.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc -> ((String.to_string k), (OpsEntityItem.to_json v))
                  :: acc) v [])
    let of_json j = Json.to_hashtbl String.of_string OpsEntityItem.of_json j
  end
module PatchOrchestratorFilterValues =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PatchRule =
  struct
    type t =
      {
      patch_filter_group: PatchFilterGroup.t ;
      compliance_level: PatchComplianceLevel.t option ;
      approve_after_days: Integer.t ;
      enable_non_security: Boolean.t option }
    let make ~patch_filter_group  ?compliance_level  ~approve_after_days 
      ?enable_non_security  () =
      {
        patch_filter_group;
        compliance_level;
        approve_after_days;
        enable_non_security
      }
    let parse xml =
      Some
        {
          patch_filter_group =
            (Xml.required "PatchFilterGroup"
               (Util.option_bind (Xml.member "PatchFilterGroup" xml)
                  PatchFilterGroup.parse));
          compliance_level =
            (Util.option_bind (Xml.member "ComplianceLevel" xml)
               PatchComplianceLevel.parse);
          approve_after_days =
            (Xml.required "ApproveAfterDays"
               (Util.option_bind (Xml.member "ApproveAfterDays" xml)
                  Integer.parse));
          enable_non_security =
            (Util.option_bind (Xml.member "EnableNonSecurity" xml)
               Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "PatchFilterGroup"
                    ([], (PatchFilterGroup.to_xml v.patch_filter_group)))])
             @
             [Util.option_map v.compliance_level
                (fun f ->
                   Ezxmlm.make_tag "ComplianceLevel"
                     ([], (PatchComplianceLevel.to_xml f)))])
            @
            [Some
               (Ezxmlm.make_tag "ApproveAfterDays"
                  ([], (Integer.to_xml v.approve_after_days)))])
           @
           [Util.option_map v.enable_non_security
              (fun f ->
                 Ezxmlm.make_tag "EnableNonSecurity" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enable_non_security
              (fun f -> ("enable_non_security", (Boolean.to_json f)));
           Some
             ("approve_after_days", (Integer.to_json v.approve_after_days));
           Util.option_map v.compliance_level
             (fun f -> ("compliance_level", (PatchComplianceLevel.to_json f)));
           Some
             ("patch_filter_group",
               (PatchFilterGroup.to_json v.patch_filter_group))])
    let of_json j =
      {
        patch_filter_group =
          (PatchFilterGroup.of_json
             (Util.of_option_exn (Json.lookup j "patch_filter_group")));
        compliance_level =
          (Util.option_map (Json.lookup j "compliance_level")
             PatchComplianceLevel.of_json);
        approve_after_days =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "approve_after_days")));
        enable_non_security =
          (Util.option_map (Json.lookup j "enable_non_security")
             Boolean.of_json)
      }
  end
module PatchSourceProductList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AssociationOverview =
  struct
    type t =
      {
      status: String.t option ;
      detailed_status: String.t option ;
      association_status_aggregated_count:
        AssociationStatusAggregatedCount.t option }
    let make ?status  ?detailed_status  ?association_status_aggregated_count 
      () = { status; detailed_status; association_status_aggregated_count }
    let parse xml =
      Some
        {
          status = (Util.option_bind (Xml.member "Status" xml) String.parse);
          detailed_status =
            (Util.option_bind (Xml.member "DetailedStatus" xml) String.parse);
          association_status_aggregated_count =
            (Util.option_bind
               (Xml.member "AssociationStatusAggregatedCount" xml)
               AssociationStatusAggregatedCount.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.status
                (fun f -> Ezxmlm.make_tag "Status" ([], (String.to_xml f)))])
            @
            [Util.option_map v.detailed_status
               (fun f ->
                  Ezxmlm.make_tag "DetailedStatus" ([], (String.to_xml f)))])
           @
           [Util.option_map v.association_status_aggregated_count
              (fun f ->
                 Ezxmlm.make_tag "AssociationStatusAggregatedCount"
                   ([], (AssociationStatusAggregatedCount.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_status_aggregated_count
              (fun f ->
                 ("association_status_aggregated_count",
                   (AssociationStatusAggregatedCount.to_json f)));
           Util.option_map v.detailed_status
             (fun f -> ("detailed_status", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)))])
    let of_json j =
      {
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        detailed_status =
          (Util.option_map (Json.lookup j "detailed_status") String.of_json);
        association_status_aggregated_count =
          (Util.option_map
             (Json.lookup j "association_status_aggregated_count")
             AssociationStatusAggregatedCount.of_json)
      }
  end
module SessionManagerOutputUrl =
  struct
    type t =
      {
      s3_output_url: String.t option ;
      cloud_watch_output_url: String.t option }
    let make ?s3_output_url  ?cloud_watch_output_url  () =
      { s3_output_url; cloud_watch_output_url }
    let parse xml =
      Some
        {
          s3_output_url =
            (Util.option_bind (Xml.member "S3OutputUrl" xml) String.parse);
          cloud_watch_output_url =
            (Util.option_bind (Xml.member "CloudWatchOutputUrl" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.s3_output_url
               (fun f ->
                  Ezxmlm.make_tag "S3OutputUrl" ([], (String.to_xml f)))])
           @
           [Util.option_map v.cloud_watch_output_url
              (fun f ->
                 Ezxmlm.make_tag "CloudWatchOutputUrl"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cloud_watch_output_url
              (fun f -> ("cloud_watch_output_url", (String.to_json f)));
           Util.option_map v.s3_output_url
             (fun f -> ("s3_output_url", (String.to_json f)))])
    let of_json j =
      {
        s3_output_url =
          (Util.option_map (Json.lookup j "s3_output_url") String.of_json);
        cloud_watch_output_url =
          (Util.option_map (Json.lookup j "cloud_watch_output_url")
             String.of_json)
      }
  end
module SessionStatus =
  struct
    type t =
      | Connected 
      | Connecting 
      | Disconnected 
      | Terminated 
      | Terminating 
      | Failed 
    let str_to_t =
      [("Failed", Failed);
      ("Terminating", Terminating);
      ("Terminated", Terminated);
      ("Disconnected", Disconnected);
      ("Connecting", Connecting);
      ("Connected", Connected)]
    let t_to_str =
      [(Failed, "Failed");
      (Terminating, "Terminating");
      (Terminated, "Terminated");
      (Disconnected, "Disconnected");
      (Connecting, "Connecting");
      (Connected, "Connected")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ComplianceExecutionSummary =
  struct
    type t =
      {
      execution_time: DateTime.t ;
      execution_id: String.t option ;
      execution_type: String.t option }
    let make ~execution_time  ?execution_id  ?execution_type  () =
      { execution_time; execution_id; execution_type }
    let parse xml =
      Some
        {
          execution_time =
            (Xml.required "ExecutionTime"
               (Util.option_bind (Xml.member "ExecutionTime" xml)
                  DateTime.parse));
          execution_id =
            (Util.option_bind (Xml.member "ExecutionId" xml) String.parse);
          execution_type =
            (Util.option_bind (Xml.member "ExecutionType" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "ExecutionTime"
                   ([], (DateTime.to_xml v.execution_time)))])
            @
            [Util.option_map v.execution_id
               (fun f ->
                  Ezxmlm.make_tag "ExecutionId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.execution_type
              (fun f ->
                 Ezxmlm.make_tag "ExecutionType" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.execution_type
              (fun f -> ("execution_type", (String.to_json f)));
           Util.option_map v.execution_id
             (fun f -> ("execution_id", (String.to_json f)));
           Some ("execution_time", (DateTime.to_json v.execution_time))])
    let of_json j =
      {
        execution_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "execution_time")));
        execution_id =
          (Util.option_map (Json.lookup j "execution_id") String.of_json);
        execution_type =
          (Util.option_map (Json.lookup j "execution_type") String.of_json)
      }
  end
module ComplianceItemDetails =
  struct
    type t = (String.t, String.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string String.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc -> ((String.to_string k), (String.to_json v)) :: acc)
           v [])
    let of_json j = Json.to_hashtbl String.of_string String.of_json j
  end
module ComplianceSeverity =
  struct
    type t =
      | CRITICAL 
      | HIGH 
      | MEDIUM 
      | LOW 
      | INFORMATIONAL 
      | UNSPECIFIED 
    let str_to_t =
      [("UNSPECIFIED", UNSPECIFIED);
      ("INFORMATIONAL", INFORMATIONAL);
      ("LOW", LOW);
      ("MEDIUM", MEDIUM);
      ("HIGH", HIGH);
      ("CRITICAL", CRITICAL)]
    let t_to_str =
      [(UNSPECIFIED, "UNSPECIFIED");
      (INFORMATIONAL, "INFORMATIONAL");
      (LOW, "LOW");
      (MEDIUM, "MEDIUM");
      (HIGH, "HIGH");
      (CRITICAL, "CRITICAL")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ComplianceStatus =
  struct
    type t =
      | COMPLIANT 
      | NON_COMPLIANT 
    let str_to_t =
      [("NON_COMPLIANT", NON_COMPLIANT); ("COMPLIANT", COMPLIANT)]
    let t_to_str =
      [(NON_COMPLIANT, "NON_COMPLIANT"); (COMPLIANT, "COMPLIANT")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LoggingInfo =
  struct
    type t =
      {
      s3_bucket_name: String.t ;
      s3_key_prefix: String.t option ;
      s3_region: String.t }
    let make ~s3_bucket_name  ?s3_key_prefix  ~s3_region  () =
      { s3_bucket_name; s3_key_prefix; s3_region }
    let parse xml =
      Some
        {
          s3_bucket_name =
            (Xml.required "S3BucketName"
               (Util.option_bind (Xml.member "S3BucketName" xml) String.parse));
          s3_key_prefix =
            (Util.option_bind (Xml.member "S3KeyPrefix" xml) String.parse);
          s3_region =
            (Xml.required "S3Region"
               (Util.option_bind (Xml.member "S3Region" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "S3BucketName"
                   ([], (String.to_xml v.s3_bucket_name)))])
            @
            [Util.option_map v.s3_key_prefix
               (fun f ->
                  Ezxmlm.make_tag "S3KeyPrefix" ([], (String.to_xml f)))])
           @
           [Some
              (Ezxmlm.make_tag "S3Region" ([], (String.to_xml v.s3_region)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("s3_region", (String.to_json v.s3_region));
           Util.option_map v.s3_key_prefix
             (fun f -> ("s3_key_prefix", (String.to_json f)));
           Some ("s3_bucket_name", (String.to_json v.s3_bucket_name))])
    let of_json j =
      {
        s3_bucket_name =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "s3_bucket_name")));
        s3_key_prefix =
          (Util.option_map (Json.lookup j "s3_key_prefix") String.of_json);
        s3_region =
          (String.of_json (Util.of_option_exn (Json.lookup j "s3_region")))
      }
  end
module MaintenanceWindowTaskParameters =
  struct
    type t =
      (String.t, MaintenanceWindowTaskParameterValueExpression.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string
        MaintenanceWindowTaskParameterValueExpression.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc ->
                  ((String.to_string k),
                    (MaintenanceWindowTaskParameterValueExpression.to_json v))
                  :: acc) v [])
    let of_json j =
      Json.to_hashtbl String.of_string
        MaintenanceWindowTaskParameterValueExpression.of_json j
  end
module MaintenanceWindowTaskType =
  struct
    type t =
      | RUN_COMMAND 
      | AUTOMATION 
      | STEP_FUNCTIONS 
      | LAMBDA 
    let str_to_t =
      [("LAMBDA", LAMBDA);
      ("STEP_FUNCTIONS", STEP_FUNCTIONS);
      ("AUTOMATION", AUTOMATION);
      ("RUN_COMMAND", RUN_COMMAND)]
    let t_to_str =
      [(LAMBDA, "LAMBDA");
      (STEP_FUNCTIONS, "STEP_FUNCTIONS");
      (AUTOMATION, "AUTOMATION");
      (RUN_COMMAND, "RUN_COMMAND")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CommandFilterKey =
  struct
    type t =
      | InvokedAfter 
      | InvokedBefore 
      | Status 
      | ExecutionStage 
      | DocumentName 
    let str_to_t =
      [("DocumentName", DocumentName);
      ("ExecutionStage", ExecutionStage);
      ("Status", Status);
      ("InvokedBefore", InvokedBefore);
      ("InvokedAfter", InvokedAfter)]
    let t_to_str =
      [(DocumentName, "DocumentName");
      (ExecutionStage, "ExecutionStage");
      (Status, "Status");
      (InvokedBefore, "InvokedBefore");
      (InvokedAfter, "InvokedAfter")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InventoryResultItemMap =
  struct
    type t = (String.t, InventoryResultItem.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string InventoryResultItem.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc ->
                  ((String.to_string k), (InventoryResultItem.to_json v)) ::
                  acc) v [])
    let of_json j =
      Json.to_hashtbl String.of_string InventoryResultItem.of_json j
  end
module MaintenanceWindowFilterValues =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module CompliantSummary =
  struct
    type t =
      {
      compliant_count: Integer.t option ;
      severity_summary: SeveritySummary.t option }
    let make ?compliant_count  ?severity_summary  () =
      { compliant_count; severity_summary }
    let parse xml =
      Some
        {
          compliant_count =
            (Util.option_bind (Xml.member "CompliantCount" xml) Integer.parse);
          severity_summary =
            (Util.option_bind (Xml.member "SeveritySummary" xml)
               SeveritySummary.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.compliant_count
               (fun f ->
                  Ezxmlm.make_tag "CompliantCount" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.severity_summary
              (fun f ->
                 Ezxmlm.make_tag "SeveritySummary"
                   ([], (SeveritySummary.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.severity_summary
              (fun f -> ("severity_summary", (SeveritySummary.to_json f)));
           Util.option_map v.compliant_count
             (fun f -> ("compliant_count", (Integer.to_json f)))])
    let of_json j =
      {
        compliant_count =
          (Util.option_map (Json.lookup j "compliant_count") Integer.of_json);
        severity_summary =
          (Util.option_map (Json.lookup j "severity_summary")
             SeveritySummary.of_json)
      }
  end
module NonCompliantSummary =
  struct
    type t =
      {
      non_compliant_count: Integer.t option ;
      severity_summary: SeveritySummary.t option }
    let make ?non_compliant_count  ?severity_summary  () =
      { non_compliant_count; severity_summary }
    let parse xml =
      Some
        {
          non_compliant_count =
            (Util.option_bind (Xml.member "NonCompliantCount" xml)
               Integer.parse);
          severity_summary =
            (Util.option_bind (Xml.member "SeveritySummary" xml)
               SeveritySummary.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.non_compliant_count
               (fun f ->
                  Ezxmlm.make_tag "NonCompliantCount"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.severity_summary
              (fun f ->
                 Ezxmlm.make_tag "SeveritySummary"
                   ([], (SeveritySummary.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.severity_summary
              (fun f -> ("severity_summary", (SeveritySummary.to_json f)));
           Util.option_map v.non_compliant_count
             (fun f -> ("non_compliant_count", (Integer.to_json f)))])
    let of_json j =
      {
        non_compliant_count =
          (Util.option_map (Json.lookup j "non_compliant_count")
             Integer.of_json);
        severity_summary =
          (Util.option_map (Json.lookup j "severity_summary")
             SeveritySummary.of_json)
      }
  end
module InstancePatchStateFilterValues =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InstancePatchStateOperatorType =
  struct
    type t =
      | Equal 
      | NotEqual 
      | LessThan 
      | GreaterThan 
    let str_to_t =
      [("GreaterThan", GreaterThan);
      ("LessThan", LessThan);
      ("NotEqual", NotEqual);
      ("Equal", Equal)]
    let t_to_str =
      [(GreaterThan, "GreaterThan");
      (LessThan, "LessThan");
      (NotEqual, "NotEqual");
      (Equal, "Equal")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module OutputSource =
  struct
    type t =
      {
      output_source_id: String.t option ;
      output_source_type: String.t option }
    let make ?output_source_id  ?output_source_type  () =
      { output_source_id; output_source_type }
    let parse xml =
      Some
        {
          output_source_id =
            (Util.option_bind (Xml.member "OutputSourceId" xml) String.parse);
          output_source_type =
            (Util.option_bind (Xml.member "OutputSourceType" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.output_source_id
               (fun f ->
                  Ezxmlm.make_tag "OutputSourceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.output_source_type
              (fun f ->
                 Ezxmlm.make_tag "OutputSourceType" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.output_source_type
              (fun f -> ("output_source_type", (String.to_json f)));
           Util.option_map v.output_source_id
             (fun f -> ("output_source_id", (String.to_json f)))])
    let of_json j =
      {
        output_source_id =
          (Util.option_map (Json.lookup j "output_source_id") String.of_json);
        output_source_type =
          (Util.option_map (Json.lookup j "output_source_type")
             String.of_json)
      }
  end
module PatchOperationType =
  struct
    type t =
      | Scan 
      | Install 
    let str_to_t = [("Install", Install); ("Scan", Scan)]
    let t_to_str = [(Install, "Install"); (Scan, "Scan")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RebootOption =
  struct
    type t =
      | RebootIfNeeded 
      | NoReboot 
    let str_to_t =
      [("NoReboot", NoReboot); ("RebootIfNeeded", RebootIfNeeded)]
    let t_to_str =
      [(NoReboot, "NoReboot"); (RebootIfNeeded, "RebootIfNeeded")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AutomationExecutionFilterKey =
  struct
    type t =
      | DocumentNamePrefix 
      | ExecutionStatus 
      | ExecutionId 
      | ParentExecutionId 
      | CurrentAction 
      | StartTimeBefore 
      | StartTimeAfter 
      | AutomationType 
      | TagKey 
    let str_to_t =
      [("TagKey", TagKey);
      ("AutomationType", AutomationType);
      ("StartTimeAfter", StartTimeAfter);
      ("StartTimeBefore", StartTimeBefore);
      ("CurrentAction", CurrentAction);
      ("ParentExecutionId", ParentExecutionId);
      ("ExecutionId", ExecutionId);
      ("ExecutionStatus", ExecutionStatus);
      ("DocumentNamePrefix", DocumentNamePrefix)]
    let t_to_str =
      [(TagKey, "TagKey");
      (AutomationType, "AutomationType");
      (StartTimeAfter, "StartTimeAfter");
      (StartTimeBefore, "StartTimeBefore");
      (CurrentAction, "CurrentAction");
      (ParentExecutionId, "ParentExecutionId");
      (ExecutionId, "ExecutionId");
      (ExecutionStatus, "ExecutionStatus");
      (DocumentNamePrefix, "DocumentNamePrefix")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AutomationExecutionFilterValueList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module CommandStatus =
  struct
    type t =
      | Pending 
      | InProgress 
      | Success 
      | Cancelled 
      | Failed 
      | TimedOut 
      | Cancelling 
    let str_to_t =
      [("Cancelling", Cancelling);
      ("TimedOut", TimedOut);
      ("Failed", Failed);
      ("Cancelled", Cancelled);
      ("Success", Success);
      ("InProgress", InProgress);
      ("Pending", Pending)]
    let t_to_str =
      [(Cancelling, "Cancelling");
      (TimedOut, "TimedOut");
      (Failed, "Failed");
      (Cancelled, "Cancelled");
      (Success, "Success");
      (InProgress, "InProgress");
      (Pending, "Pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module MaintenanceWindowResourceType =
  struct
    type t =
      | INSTANCE 
      | RESOURCE_GROUP 
    let str_to_t =
      [("RESOURCE_GROUP", RESOURCE_GROUP); ("INSTANCE", INSTANCE)]
    let t_to_str =
      [(RESOURCE_GROUP, "RESOURCE_GROUP"); (INSTANCE, "INSTANCE")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module OpsItemOperationalData =
  struct
    type t = (String.t, OpsItemDataValue.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string OpsItemDataValue.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc ->
                  ((String.to_string k), (OpsItemDataValue.to_json v)) :: acc)
           v [])
    let of_json j =
      Json.to_hashtbl String.of_string OpsItemDataValue.of_json j
  end
module OpsItemStatus =
  struct
    type t =
      | Open 
      | InProgress 
      | Resolved 
    let str_to_t =
      [("Resolved", Resolved); ("InProgress", InProgress); ("Open", Open)]
    let t_to_str =
      [(Resolved, "Resolved"); (InProgress, "InProgress"); (Open, "Open")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module OpsFilter =
  struct
    type t =
      {
      key: String.t ;
      values: OpsFilterValueList.t ;
      type_: OpsFilterOperatorType.t option }
    let make ~key  ~values  ?type_  () = { key; values; type_ }
    let parse xml =
      Some
        {
          key =
            (Xml.required "Key"
               (Util.option_bind (Xml.member "Key" xml) String.parse));
          values =
            (Xml.required "Values"
               (Util.option_bind (Xml.member "Values" xml)
                  OpsFilterValueList.parse));
          type_ =
            (Util.option_bind (Xml.member "Type" xml)
               OpsFilterOperatorType.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @ [Some (Ezxmlm.make_tag "Key" ([], (String.to_xml v.key)))]) @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Values"
                       ([], (OpsFilterValueList.to_xml [x])))) v.values))
           @
           [Util.option_map v.type_
              (fun f ->
                 Ezxmlm.make_tag "Type"
                   ([], (OpsFilterOperatorType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> ("type_", (OpsFilterOperatorType.to_json f)));
           Some ("values", (OpsFilterValueList.to_json v.values));
           Some ("key", (String.to_json v.key))])
    let of_json j =
      {
        key = (String.of_json (Util.of_option_exn (Json.lookup j "key")));
        values =
          (OpsFilterValueList.of_json
             (Util.of_option_exn (Json.lookup j "values")));
        type_ =
          (Util.option_map (Json.lookup j "type_")
             OpsFilterOperatorType.of_json)
      }
  end
module PatchComplianceDataState =
  struct
    type t =
      | INSTALLED 
      | INSTALLED_OTHER 
      | INSTALLED_PENDING_REBOOT 
      | INSTALLED_REJECTED 
      | MISSING 
      | NOT_APPLICABLE 
      | FAILED 
    let str_to_t =
      [("FAILED", FAILED);
      ("NOT_APPLICABLE", NOT_APPLICABLE);
      ("MISSING", MISSING);
      ("INSTALLED_REJECTED", INSTALLED_REJECTED);
      ("INSTALLED_PENDING_REBOOT", INSTALLED_PENDING_REBOOT);
      ("INSTALLED_OTHER", INSTALLED_OTHER);
      ("INSTALLED", INSTALLED)]
    let t_to_str =
      [(FAILED, "FAILED");
      (NOT_APPLICABLE, "NOT_APPLICABLE");
      (MISSING, "MISSING");
      (INSTALLED_REJECTED, "INSTALLED_REJECTED");
      (INSTALLED_PENDING_REBOOT, "INSTALLED_PENDING_REBOOT");
      (INSTALLED_OTHER, "INSTALLED_OTHER");
      (INSTALLED, "INSTALLED")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DocumentFilterKey =
  struct
    type t =
      | Name 
      | Owner 
      | PlatformTypes 
      | DocumentType 
    let str_to_t =
      [("DocumentType", DocumentType);
      ("PlatformTypes", PlatformTypes);
      ("Owner", Owner);
      ("Name", Name)]
    let t_to_str =
      [(DocumentType, "DocumentType");
      (PlatformTypes, "PlatformTypes");
      (Owner, "Owner");
      (Name, "Name")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DocumentKeyValuesFilterValues =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module Patch =
  struct
    type t =
      {
      id: String.t option ;
      release_date: DateTime.t option ;
      title: String.t option ;
      description: String.t option ;
      content_url: String.t option ;
      vendor: String.t option ;
      product_family: String.t option ;
      product: String.t option ;
      classification: String.t option ;
      msrc_severity: String.t option ;
      kb_number: String.t option ;
      msrc_number: String.t option ;
      language: String.t option }
    let make ?id  ?release_date  ?title  ?description  ?content_url  ?vendor 
      ?product_family  ?product  ?classification  ?msrc_severity  ?kb_number 
      ?msrc_number  ?language  () =
      {
        id;
        release_date;
        title;
        description;
        content_url;
        vendor;
        product_family;
        product;
        classification;
        msrc_severity;
        kb_number;
        msrc_number;
        language
      }
    let parse xml =
      Some
        {
          id = (Util.option_bind (Xml.member "Id" xml) String.parse);
          release_date =
            (Util.option_bind (Xml.member "ReleaseDate" xml) DateTime.parse);
          title = (Util.option_bind (Xml.member "Title" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          content_url =
            (Util.option_bind (Xml.member "ContentUrl" xml) String.parse);
          vendor = (Util.option_bind (Xml.member "Vendor" xml) String.parse);
          product_family =
            (Util.option_bind (Xml.member "ProductFamily" xml) String.parse);
          product =
            (Util.option_bind (Xml.member "Product" xml) String.parse);
          classification =
            (Util.option_bind (Xml.member "Classification" xml) String.parse);
          msrc_severity =
            (Util.option_bind (Xml.member "MsrcSeverity" xml) String.parse);
          kb_number =
            (Util.option_bind (Xml.member "KbNumber" xml) String.parse);
          msrc_number =
            (Util.option_bind (Xml.member "MsrcNumber" xml) String.parse);
          language =
            (Util.option_bind (Xml.member "Language" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.id
                          (fun f ->
                             Ezxmlm.make_tag "Id" ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.release_date
                         (fun f ->
                            Ezxmlm.make_tag "ReleaseDate"
                              ([], (DateTime.to_xml f)))])
                     @
                     [Util.option_map v.title
                        (fun f ->
                           Ezxmlm.make_tag "Title" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.description
                       (fun f ->
                          Ezxmlm.make_tag "Description"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.content_url
                      (fun f ->
                         Ezxmlm.make_tag "ContentUrl" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.vendor
                     (fun f ->
                        Ezxmlm.make_tag "Vendor" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.product_family
                    (fun f ->
                       Ezxmlm.make_tag "ProductFamily"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.product
                   (fun f ->
                      Ezxmlm.make_tag "Product" ([], (String.to_xml f)))])
               @
               [Util.option_map v.classification
                  (fun f ->
                     Ezxmlm.make_tag "Classification" ([], (String.to_xml f)))])
              @
              [Util.option_map v.msrc_severity
                 (fun f ->
                    Ezxmlm.make_tag "MsrcSeverity" ([], (String.to_xml f)))])
             @
             [Util.option_map v.kb_number
                (fun f -> Ezxmlm.make_tag "KbNumber" ([], (String.to_xml f)))])
            @
            [Util.option_map v.msrc_number
               (fun f -> Ezxmlm.make_tag "MsrcNumber" ([], (String.to_xml f)))])
           @
           [Util.option_map v.language
              (fun f -> Ezxmlm.make_tag "Language" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.language
              (fun f -> ("language", (String.to_json f)));
           Util.option_map v.msrc_number
             (fun f -> ("msrc_number", (String.to_json f)));
           Util.option_map v.kb_number
             (fun f -> ("kb_number", (String.to_json f)));
           Util.option_map v.msrc_severity
             (fun f -> ("msrc_severity", (String.to_json f)));
           Util.option_map v.classification
             (fun f -> ("classification", (String.to_json f)));
           Util.option_map v.product
             (fun f -> ("product", (String.to_json f)));
           Util.option_map v.product_family
             (fun f -> ("product_family", (String.to_json f)));
           Util.option_map v.vendor (fun f -> ("vendor", (String.to_json f)));
           Util.option_map v.content_url
             (fun f -> ("content_url", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.title (fun f -> ("title", (String.to_json f)));
           Util.option_map v.release_date
             (fun f -> ("release_date", (DateTime.to_json f)));
           Util.option_map v.id (fun f -> ("id", (String.to_json f)))])
    let of_json j =
      {
        id = (Util.option_map (Json.lookup j "id") String.of_json);
        release_date =
          (Util.option_map (Json.lookup j "release_date") DateTime.of_json);
        title = (Util.option_map (Json.lookup j "title") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        content_url =
          (Util.option_map (Json.lookup j "content_url") String.of_json);
        vendor = (Util.option_map (Json.lookup j "vendor") String.of_json);
        product_family =
          (Util.option_map (Json.lookup j "product_family") String.of_json);
        product = (Util.option_map (Json.lookup j "product") String.of_json);
        classification =
          (Util.option_map (Json.lookup j "classification") String.of_json);
        msrc_severity =
          (Util.option_map (Json.lookup j "msrc_severity") String.of_json);
        kb_number =
          (Util.option_map (Json.lookup j "kb_number") String.of_json);
        msrc_number =
          (Util.option_map (Json.lookup j "msrc_number") String.of_json);
        language =
          (Util.option_map (Json.lookup j "language") String.of_json)
      }
  end
module PatchStatus =
  struct
    type t =
      {
      deployment_status: PatchDeploymentStatus.t option ;
      compliance_level: PatchComplianceLevel.t option ;
      approval_date: DateTime.t option }
    let make ?deployment_status  ?compliance_level  ?approval_date  () =
      { deployment_status; compliance_level; approval_date }
    let parse xml =
      Some
        {
          deployment_status =
            (Util.option_bind (Xml.member "DeploymentStatus" xml)
               PatchDeploymentStatus.parse);
          compliance_level =
            (Util.option_bind (Xml.member "ComplianceLevel" xml)
               PatchComplianceLevel.parse);
          approval_date =
            (Util.option_bind (Xml.member "ApprovalDate" xml) DateTime.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.deployment_status
                (fun f ->
                   Ezxmlm.make_tag "DeploymentStatus"
                     ([], (PatchDeploymentStatus.to_xml f)))])
            @
            [Util.option_map v.compliance_level
               (fun f ->
                  Ezxmlm.make_tag "ComplianceLevel"
                    ([], (PatchComplianceLevel.to_xml f)))])
           @
           [Util.option_map v.approval_date
              (fun f ->
                 Ezxmlm.make_tag "ApprovalDate" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.approval_date
              (fun f -> ("approval_date", (DateTime.to_json f)));
           Util.option_map v.compliance_level
             (fun f -> ("compliance_level", (PatchComplianceLevel.to_json f)));
           Util.option_map v.deployment_status
             (fun f ->
                ("deployment_status", (PatchDeploymentStatus.to_json f)))])
    let of_json j =
      {
        deployment_status =
          (Util.option_map (Json.lookup j "deployment_status")
             PatchDeploymentStatus.of_json);
        compliance_level =
          (Util.option_map (Json.lookup j "compliance_level")
             PatchComplianceLevel.of_json);
        approval_date =
          (Util.option_map (Json.lookup j "approval_date") DateTime.of_json)
      }
  end
module AssociationStatus =
  struct
    type t =
      {
      date: DateTime.t ;
      name: AssociationStatusName.t ;
      message: String.t ;
      additional_info: String.t option }
    let make ~date  ~name  ~message  ?additional_info  () =
      { date; name; message; additional_info }
    let parse xml =
      Some
        {
          date =
            (Xml.required "Date"
               (Util.option_bind (Xml.member "Date" xml) DateTime.parse));
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml)
                  AssociationStatusName.parse));
          message =
            (Xml.required "Message"
               (Util.option_bind (Xml.member "Message" xml) String.parse));
          additional_info =
            (Util.option_bind (Xml.member "AdditionalInfo" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some (Ezxmlm.make_tag "Date" ([], (DateTime.to_xml v.date)))])
             @
             [Some
                (Ezxmlm.make_tag "Name"
                   ([], (AssociationStatusName.to_xml v.name)))])
            @
            [Some (Ezxmlm.make_tag "Message" ([], (String.to_xml v.message)))])
           @
           [Util.option_map v.additional_info
              (fun f ->
                 Ezxmlm.make_tag "AdditionalInfo" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.additional_info
              (fun f -> ("additional_info", (String.to_json f)));
           Some ("message", (String.to_json v.message));
           Some ("name", (AssociationStatusName.to_json v.name));
           Some ("date", (DateTime.to_json v.date))])
    let of_json j =
      {
        date = (DateTime.of_json (Util.of_option_exn (Json.lookup j "date")));
        name =
          (AssociationStatusName.of_json
             (Util.of_option_exn (Json.lookup j "name")));
        message =
          (String.of_json (Util.of_option_exn (Json.lookup j "message")));
        additional_info =
          (Util.option_map (Json.lookup j "additional_info") String.of_json)
      }
  end
module CreateAssociationBatchRequestEntry =
  struct
    type t =
      {
      name: String.t ;
      instance_id: String.t option ;
      parameters: Parameters.t option ;
      automation_target_parameter_name: String.t option ;
      document_version: String.t option ;
      targets: Targets.t ;
      schedule_expression: String.t option ;
      output_location: InstanceAssociationOutputLocation.t option ;
      association_name: String.t option ;
      max_errors: String.t option ;
      max_concurrency: String.t option ;
      compliance_severity: AssociationComplianceSeverity.t option }
    let make ~name  ?instance_id  ?parameters 
      ?automation_target_parameter_name  ?document_version  ?(targets= []) 
      ?schedule_expression  ?output_location  ?association_name  ?max_errors 
      ?max_concurrency  ?compliance_severity  () =
      {
        name;
        instance_id;
        parameters;
        automation_target_parameter_name;
        document_version;
        targets;
        schedule_expression;
        output_location;
        association_name;
        max_errors;
        max_concurrency;
        compliance_severity
      }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          parameters =
            (Util.option_bind (Xml.member "Parameters" xml) Parameters.parse);
          automation_target_parameter_name =
            (Util.option_bind
               (Xml.member "AutomationTargetParameterName" xml) String.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          schedule_expression =
            (Util.option_bind (Xml.member "ScheduleExpression" xml)
               String.parse);
          output_location =
            (Util.option_bind (Xml.member "OutputLocation" xml)
               InstanceAssociationOutputLocation.parse);
          association_name =
            (Util.option_bind (Xml.member "AssociationName" xml) String.parse);
          max_errors =
            (Util.option_bind (Xml.member "MaxErrors" xml) String.parse);
          max_concurrency =
            (Util.option_bind (Xml.member "MaxConcurrency" xml) String.parse);
          compliance_severity =
            (Util.option_bind (Xml.member "ComplianceSeverity" xml)
               AssociationComplianceSeverity.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Some
                         (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
                     @
                     [Util.option_map v.instance_id
                        (fun f ->
                           Ezxmlm.make_tag "InstanceId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.parameters
                       (fun f ->
                          Ezxmlm.make_tag "Parameters"
                            ([], (Parameters.to_xml f)))])
                   @
                   [Util.option_map v.automation_target_parameter_name
                      (fun f ->
                         Ezxmlm.make_tag "AutomationTargetParameterName"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.document_version
                     (fun f ->
                        Ezxmlm.make_tag "DocumentVersion"
                          ([], (String.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "Targets"
                            ([], (Targets.to_xml [x])))) v.targets))
                @
                [Util.option_map v.schedule_expression
                   (fun f ->
                      Ezxmlm.make_tag "ScheduleExpression"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.output_location
                  (fun f ->
                     Ezxmlm.make_tag "OutputLocation"
                       ([], (InstanceAssociationOutputLocation.to_xml f)))])
              @
              [Util.option_map v.association_name
                 (fun f ->
                    Ezxmlm.make_tag "AssociationName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.max_errors
                (fun f -> Ezxmlm.make_tag "MaxErrors" ([], (String.to_xml f)))])
            @
            [Util.option_map v.max_concurrency
               (fun f ->
                  Ezxmlm.make_tag "MaxConcurrency" ([], (String.to_xml f)))])
           @
           [Util.option_map v.compliance_severity
              (fun f ->
                 Ezxmlm.make_tag "ComplianceSeverity"
                   ([], (AssociationComplianceSeverity.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.compliance_severity
              (fun f ->
                 ("compliance_severity",
                   (AssociationComplianceSeverity.to_json f)));
           Util.option_map v.max_concurrency
             (fun f -> ("max_concurrency", (String.to_json f)));
           Util.option_map v.max_errors
             (fun f -> ("max_errors", (String.to_json f)));
           Util.option_map v.association_name
             (fun f -> ("association_name", (String.to_json f)));
           Util.option_map v.output_location
             (fun f ->
                ("output_location",
                  (InstanceAssociationOutputLocation.to_json f)));
           Util.option_map v.schedule_expression
             (fun f -> ("schedule_expression", (String.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.automation_target_parameter_name
             (fun f ->
                ("automation_target_parameter_name", (String.to_json f)));
           Util.option_map v.parameters
             (fun f -> ("parameters", (Parameters.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        parameters =
          (Util.option_map (Json.lookup j "parameters") Parameters.of_json);
        automation_target_parameter_name =
          (Util.option_map (Json.lookup j "automation_target_parameter_name")
             String.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        schedule_expression =
          (Util.option_map (Json.lookup j "schedule_expression")
             String.of_json);
        output_location =
          (Util.option_map (Json.lookup j "output_location")
             InstanceAssociationOutputLocation.of_json);
        association_name =
          (Util.option_map (Json.lookup j "association_name") String.of_json);
        max_errors =
          (Util.option_map (Json.lookup j "max_errors") String.of_json);
        max_concurrency =
          (Util.option_map (Json.lookup j "max_concurrency") String.of_json);
        compliance_severity =
          (Util.option_map (Json.lookup j "compliance_severity")
             AssociationComplianceSeverity.of_json)
      }
  end
module Fault =
  struct
    type t =
      | Client 
      | Server 
      | Unknown 
    let str_to_t =
      [("Unknown", Unknown); ("Server", Server); ("Client", Client)]
    let t_to_str =
      [(Unknown, "Unknown"); (Server, "Server"); (Client, "Client")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module OpsItemNotification =
  struct
    type t = {
      arn: String.t option }
    let make ?arn  () = { arn }
    let parse xml =
      Some { arn = (Util.option_bind (Xml.member "Arn" xml) String.parse) }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.arn
              (fun f -> Ezxmlm.make_tag "Arn" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      { arn = (Util.option_map (Json.lookup j "arn") String.of_json) }
  end
module RelatedOpsItem =
  struct
    type t = {
      ops_item_id: String.t }
    let make ~ops_item_id  () = { ops_item_id }
    let parse xml =
      Some
        {
          ops_item_id =
            (Xml.required "OpsItemId"
               (Util.option_bind (Xml.member "OpsItemId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "OpsItemId"
                 ([], (String.to_xml v.ops_item_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("ops_item_id", (String.to_json v.ops_item_id))])
    let of_json j =
      {
        ops_item_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "ops_item_id")))
      }
  end
module InventoryDeletionStatus =
  struct
    type t =
      | InProgress 
      | Complete 
    let str_to_t = [("Complete", Complete); ("InProgress", InProgress)]
    let t_to_str = [(Complete, "Complete"); (InProgress, "InProgress")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InventoryDeletionSummary =
  struct
    type t =
      {
      total_count: Integer.t option ;
      remaining_count: Integer.t option ;
      summary_items: InventoryDeletionSummaryItems.t }
    let make ?total_count  ?remaining_count  ?(summary_items= [])  () =
      { total_count; remaining_count; summary_items }
    let parse xml =
      Some
        {
          total_count =
            (Util.option_bind (Xml.member "TotalCount" xml) Integer.parse);
          remaining_count =
            (Util.option_bind (Xml.member "RemainingCount" xml) Integer.parse);
          summary_items =
            (Util.of_option []
               (Util.option_bind (Xml.member "SummaryItems" xml)
                  InventoryDeletionSummaryItems.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.total_count
                (fun f ->
                   Ezxmlm.make_tag "TotalCount" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.remaining_count
               (fun f ->
                  Ezxmlm.make_tag "RemainingCount" ([], (Integer.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "SummaryItems"
                      ([], (InventoryDeletionSummaryItems.to_xml [x]))))
              v.summary_items))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("summary_items",
                (InventoryDeletionSummaryItems.to_json v.summary_items));
           Util.option_map v.remaining_count
             (fun f -> ("remaining_count", (Integer.to_json f)));
           Util.option_map v.total_count
             (fun f -> ("total_count", (Integer.to_json f)))])
    let of_json j =
      {
        total_count =
          (Util.option_map (Json.lookup j "total_count") Integer.of_json);
        remaining_count =
          (Util.option_map (Json.lookup j "remaining_count") Integer.of_json);
        summary_items =
          (InventoryDeletionSummaryItems.of_json
             (Util.of_option_exn (Json.lookup j "summary_items")))
      }
  end
module SessionFilterKey =
  struct
    type t =
      | InvokedAfter 
      | InvokedBefore 
      | Target 
      | Owner 
      | Status 
    let str_to_t =
      [("Status", Status);
      ("Owner", Owner);
      ("Target", Target);
      ("InvokedBefore", InvokedBefore);
      ("InvokedAfter", InvokedAfter)]
    let t_to_str =
      [(Status, "Status");
      (Owner, "Owner");
      (Target, "Target");
      (InvokedBefore, "InvokedBefore");
      (InvokedAfter, "InvokedAfter")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceAssociationOutputUrl =
  struct
    type t = {
      s3_output_url: S3OutputUrl.t option }
    let make ?s3_output_url  () = { s3_output_url }
    let parse xml =
      Some
        {
          s3_output_url =
            (Util.option_bind (Xml.member "S3OutputUrl" xml)
               S3OutputUrl.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.s3_output_url
              (fun f ->
                 Ezxmlm.make_tag "S3OutputUrl" ([], (S3OutputUrl.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_output_url
              (fun f -> ("s3_output_url", (S3OutputUrl.to_json f)))])
    let of_json j =
      {
        s3_output_url =
          (Util.option_map (Json.lookup j "s3_output_url")
             S3OutputUrl.of_json)
      }
  end
module InventoryItemAttributeList =
  struct
    type t = InventoryItemAttribute.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InventoryItemAttribute.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InventoryItemAttribute.to_query v
    let to_headers v =
      Headers.to_headers_list InventoryItemAttribute.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InventoryItemAttribute.to_xml x)))
        v
    let to_json v = `List (List.map InventoryItemAttribute.to_json v)
    let of_json j = Json.to_list InventoryItemAttribute.of_json j
  end
module MaintenanceWindowExecutionStatus =
  struct
    type t =
      | PENDING 
      | IN_PROGRESS 
      | SUCCESS 
      | FAILED 
      | TIMED_OUT 
      | CANCELLING 
      | CANCELLED 
      | SKIPPED_OVERLAPPING 
    let str_to_t =
      [("SKIPPED_OVERLAPPING", SKIPPED_OVERLAPPING);
      ("CANCELLED", CANCELLED);
      ("CANCELLING", CANCELLING);
      ("TIMED_OUT", TIMED_OUT);
      ("FAILED", FAILED);
      ("SUCCESS", SUCCESS);
      ("IN_PROGRESS", IN_PROGRESS);
      ("PENDING", PENDING)]
    let t_to_str =
      [(SKIPPED_OVERLAPPING, "SKIPPED_OVERLAPPING");
      (CANCELLED, "CANCELLED");
      (CANCELLING, "CANCELLING");
      (TIMED_OUT, "TIMED_OUT");
      (FAILED, "FAILED");
      (SUCCESS, "SUCCESS");
      (IN_PROGRESS, "IN_PROGRESS");
      (PENDING, "PENDING")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ParameterStringFilterValueList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AttachmentsSourceKey =
  struct
    type t =
      | SourceUrl 
      | S3FileUrl 
      | AttachmentReference 
    let str_to_t =
      [("AttachmentReference", AttachmentReference);
      ("S3FileUrl", S3FileUrl);
      ("SourceUrl", SourceUrl)]
    let t_to_str =
      [(AttachmentReference, "AttachmentReference");
      (S3FileUrl, "S3FileUrl");
      (SourceUrl, "SourceUrl")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AttachmentsSourceValues =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module DescribeActivationsFilterKeys =
  struct
    type t =
      | ActivationIds 
      | DefaultInstanceName 
      | IamRole 
    let str_to_t =
      [("IamRole", IamRole);
      ("DefaultInstanceName", DefaultInstanceName);
      ("ActivationIds", ActivationIds)]
    let t_to_str =
      [(IamRole, "IamRole");
      (DefaultInstanceName, "DefaultInstanceName");
      (ActivationIds, "ActivationIds")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module StringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module CommandInvocationStatus =
  struct
    type t =
      | Pending 
      | InProgress 
      | Delayed 
      | Success 
      | Cancelled 
      | TimedOut 
      | Failed 
      | Cancelling 
    let str_to_t =
      [("Cancelling", Cancelling);
      ("Failed", Failed);
      ("TimedOut", TimedOut);
      ("Cancelled", Cancelled);
      ("Success", Success);
      ("Delayed", Delayed);
      ("InProgress", InProgress);
      ("Pending", Pending)]
    let t_to_str =
      [(Cancelling, "Cancelling");
      (Failed, "Failed");
      (TimedOut, "TimedOut");
      (Cancelled, "Cancelled");
      (Success, "Success");
      (Delayed, "Delayed");
      (InProgress, "InProgress");
      (Pending, "Pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CommandPluginList =
  struct
    type t = CommandPlugin.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CommandPlugin.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list CommandPlugin.to_query v
    let to_headers v = Headers.to_headers_list CommandPlugin.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (CommandPlugin.to_xml x))) v
    let to_json v = `List (List.map CommandPlugin.to_json v)
    let of_json j = Json.to_list CommandPlugin.of_json j
  end
module InventoryItemContentContext =
  struct
    type t = (String.t, String.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string String.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc -> ((String.to_string k), (String.to_json v)) :: acc)
           v [])
    let of_json j = Json.to_hashtbl String.of_string String.of_json j
  end
module OpsItemFilterKey =
  struct
    type t =
      | Status 
      | CreatedBy 
      | Source 
      | Priority 
      | Title 
      | OpsItemId 
      | CreatedTime 
      | LastModifiedTime 
      | OperationalData 
      | OperationalDataKey 
      | OperationalDataValue 
      | ResourceId 
      | AutomationId 
      | Category 
      | Severity 
    let str_to_t =
      [("Severity", Severity);
      ("Category", Category);
      ("AutomationId", AutomationId);
      ("ResourceId", ResourceId);
      ("OperationalDataValue", OperationalDataValue);
      ("OperationalDataKey", OperationalDataKey);
      ("OperationalData", OperationalData);
      ("LastModifiedTime", LastModifiedTime);
      ("CreatedTime", CreatedTime);
      ("OpsItemId", OpsItemId);
      ("Title", Title);
      ("Priority", Priority);
      ("Source", Source);
      ("CreatedBy", CreatedBy);
      ("Status", Status)]
    let t_to_str =
      [(Severity, "Severity");
      (Category, "Category");
      (AutomationId, "AutomationId");
      (ResourceId, "ResourceId");
      (OperationalDataValue, "OperationalDataValue");
      (OperationalDataKey, "OperationalDataKey");
      (OperationalData, "OperationalData");
      (LastModifiedTime, "LastModifiedTime");
      (CreatedTime, "CreatedTime");
      (OpsItemId, "OpsItemId");
      (Title, "Title");
      (Priority, "Priority");
      (Source, "Source");
      (CreatedBy, "CreatedBy");
      (Status, "Status")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module OpsItemFilterOperator =
  struct
    type t =
      | Equal 
      | Contains 
      | GreaterThan 
      | LessThan 
    let str_to_t =
      [("LessThan", LessThan);
      ("GreaterThan", GreaterThan);
      ("Contains", Contains);
      ("Equal", Equal)]
    let t_to_str =
      [(LessThan, "LessThan");
      (GreaterThan, "GreaterThan");
      (Contains, "Contains");
      (Equal, "Equal")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module OpsItemFilterValues =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AttachmentHashType =
  struct
    type t =
      | Sha256 
    let str_to_t = [("Sha256", Sha256)]
    let t_to_str = [(Sha256, "Sha256")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LastResourceDataSyncStatus =
  struct
    type t =
      | Successful 
      | Failed 
      | InProgress 
    let str_to_t =
      [("InProgress", InProgress);
      ("Failed", Failed);
      ("Successful", Successful)]
    let t_to_str =
      [(InProgress, "InProgress");
      (Failed, "Failed");
      (Successful, "Successful")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ResourceDataSyncS3Destination =
  struct
    type t =
      {
      bucket_name: String.t ;
      prefix: String.t option ;
      sync_format: ResourceDataSyncS3Format.t ;
      region: String.t ;
      a_w_s_k_m_s_key_a_r_n: String.t option }
    let make ~bucket_name  ?prefix  ~sync_format  ~region 
      ?a_w_s_k_m_s_key_a_r_n  () =
      { bucket_name; prefix; sync_format; region; a_w_s_k_m_s_key_a_r_n }
    let parse xml =
      Some
        {
          bucket_name =
            (Xml.required "BucketName"
               (Util.option_bind (Xml.member "BucketName" xml) String.parse));
          prefix = (Util.option_bind (Xml.member "Prefix" xml) String.parse);
          sync_format =
            (Xml.required "SyncFormat"
               (Util.option_bind (Xml.member "SyncFormat" xml)
                  ResourceDataSyncS3Format.parse));
          region =
            (Xml.required "Region"
               (Util.option_bind (Xml.member "Region" xml) String.parse));
          a_w_s_k_m_s_key_a_r_n =
            (Util.option_bind (Xml.member "AWSKMSKeyARN" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "BucketName"
                     ([], (String.to_xml v.bucket_name)))])
              @
              [Util.option_map v.prefix
                 (fun f -> Ezxmlm.make_tag "Prefix" ([], (String.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "SyncFormat"
                   ([], (ResourceDataSyncS3Format.to_xml v.sync_format)))])
            @
            [Some (Ezxmlm.make_tag "Region" ([], (String.to_xml v.region)))])
           @
           [Util.option_map v.a_w_s_k_m_s_key_a_r_n
              (fun f ->
                 Ezxmlm.make_tag "AWSKMSKeyARN" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.a_w_s_k_m_s_key_a_r_n
              (fun f -> ("a_w_s_k_m_s_key_a_r_n", (String.to_json f)));
           Some ("region", (String.to_json v.region));
           Some
             ("sync_format",
               (ResourceDataSyncS3Format.to_json v.sync_format));
           Util.option_map v.prefix (fun f -> ("prefix", (String.to_json f)));
           Some ("bucket_name", (String.to_json v.bucket_name))])
    let of_json j =
      {
        bucket_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "bucket_name")));
        prefix = (Util.option_map (Json.lookup j "prefix") String.of_json);
        sync_format =
          (ResourceDataSyncS3Format.of_json
             (Util.of_option_exn (Json.lookup j "sync_format")));
        region =
          (String.of_json (Util.of_option_exn (Json.lookup j "region")));
        a_w_s_k_m_s_key_a_r_n =
          (Util.option_map (Json.lookup j "a_w_s_k_m_s_key_a_r_n")
             String.of_json)
      }
  end
module ResourceDataSyncSourceWithState =
  struct
    type t =
      {
      source_type: String.t option ;
      aws_organizations_source:
        ResourceDataSyncAwsOrganizationsSource.t option ;
      source_regions: ResourceDataSyncSourceRegionList.t ;
      include_future_regions: Boolean.t option ;
      state: String.t option }
    let make ?source_type  ?aws_organizations_source  ?(source_regions= []) 
      ?include_future_regions  ?state  () =
      {
        source_type;
        aws_organizations_source;
        source_regions;
        include_future_regions;
        state
      }
    let parse xml =
      Some
        {
          source_type =
            (Util.option_bind (Xml.member "SourceType" xml) String.parse);
          aws_organizations_source =
            (Util.option_bind (Xml.member "AwsOrganizationsSource" xml)
               ResourceDataSyncAwsOrganizationsSource.parse);
          source_regions =
            (Util.of_option []
               (Util.option_bind (Xml.member "SourceRegions" xml)
                  ResourceDataSyncSourceRegionList.parse));
          include_future_regions =
            (Util.option_bind (Xml.member "IncludeFutureRegions" xml)
               Boolean.parse);
          state = (Util.option_bind (Xml.member "State" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.source_type
                  (fun f ->
                     Ezxmlm.make_tag "SourceType" ([], (String.to_xml f)))])
              @
              [Util.option_map v.aws_organizations_source
                 (fun f ->
                    Ezxmlm.make_tag "AwsOrganizationsSource"
                      ([], (ResourceDataSyncAwsOrganizationsSource.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "SourceRegions"
                        ([], (ResourceDataSyncSourceRegionList.to_xml [x]))))
                v.source_regions))
            @
            [Util.option_map v.include_future_regions
               (fun f ->
                  Ezxmlm.make_tag "IncludeFutureRegions"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.state
              (fun f -> Ezxmlm.make_tag "State" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.include_future_regions
             (fun f -> ("include_future_regions", (Boolean.to_json f)));
           Some
             ("source_regions",
               (ResourceDataSyncSourceRegionList.to_json v.source_regions));
           Util.option_map v.aws_organizations_source
             (fun f ->
                ("aws_organizations_source",
                  (ResourceDataSyncAwsOrganizationsSource.to_json f)));
           Util.option_map v.source_type
             (fun f -> ("source_type", (String.to_json f)))])
    let of_json j =
      {
        source_type =
          (Util.option_map (Json.lookup j "source_type") String.of_json);
        aws_organizations_source =
          (Util.option_map (Json.lookup j "aws_organizations_source")
             ResourceDataSyncAwsOrganizationsSource.of_json);
        source_regions =
          (ResourceDataSyncSourceRegionList.of_json
             (Util.of_option_exn (Json.lookup j "source_regions")));
        include_future_regions =
          (Util.option_map (Json.lookup j "include_future_regions")
             Boolean.of_json);
        state = (Util.option_map (Json.lookup j "state") String.of_json)
      }
  end
module ParametersFilterKey =
  struct
    type t =
      | Name 
      | Type 
      | KeyId 
    let str_to_t = [("KeyId", KeyId); ("Type", Type); ("Name", Name)]
    let t_to_str = [(KeyId, "KeyId"); (Type, "Type"); (Name, "Name")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ParametersFilterValueList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PatchBaselineIdentity =
  struct
    type t =
      {
      baseline_id: String.t option ;
      baseline_name: String.t option ;
      operating_system: OperatingSystem.t option ;
      baseline_description: String.t option ;
      default_baseline: Boolean.t option }
    let make ?baseline_id  ?baseline_name  ?operating_system 
      ?baseline_description  ?default_baseline  () =
      {
        baseline_id;
        baseline_name;
        operating_system;
        baseline_description;
        default_baseline
      }
    let parse xml =
      Some
        {
          baseline_id =
            (Util.option_bind (Xml.member "BaselineId" xml) String.parse);
          baseline_name =
            (Util.option_bind (Xml.member "BaselineName" xml) String.parse);
          operating_system =
            (Util.option_bind (Xml.member "OperatingSystem" xml)
               OperatingSystem.parse);
          baseline_description =
            (Util.option_bind (Xml.member "BaselineDescription" xml)
               String.parse);
          default_baseline =
            (Util.option_bind (Xml.member "DefaultBaseline" xml)
               Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.baseline_id
                  (fun f ->
                     Ezxmlm.make_tag "BaselineId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.baseline_name
                 (fun f ->
                    Ezxmlm.make_tag "BaselineName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.operating_system
                (fun f ->
                   Ezxmlm.make_tag "OperatingSystem"
                     ([], (OperatingSystem.to_xml f)))])
            @
            [Util.option_map v.baseline_description
               (fun f ->
                  Ezxmlm.make_tag "BaselineDescription"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.default_baseline
              (fun f ->
                 Ezxmlm.make_tag "DefaultBaseline" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.default_baseline
              (fun f -> ("default_baseline", (Boolean.to_json f)));
           Util.option_map v.baseline_description
             (fun f -> ("baseline_description", (String.to_json f)));
           Util.option_map v.operating_system
             (fun f -> ("operating_system", (OperatingSystem.to_json f)));
           Util.option_map v.baseline_name
             (fun f -> ("baseline_name", (String.to_json f)));
           Util.option_map v.baseline_id
             (fun f -> ("baseline_id", (String.to_json f)))])
    let of_json j =
      {
        baseline_id =
          (Util.option_map (Json.lookup j "baseline_id") String.of_json);
        baseline_name =
          (Util.option_map (Json.lookup j "baseline_name") String.of_json);
        operating_system =
          (Util.option_map (Json.lookup j "operating_system")
             OperatingSystem.of_json);
        baseline_description =
          (Util.option_map (Json.lookup j "baseline_description")
             String.of_json);
        default_baseline =
          (Util.option_map (Json.lookup j "default_baseline") Boolean.of_json)
      }
  end
module ComplianceStringFilter =
  struct
    type t =
      {
      key: String.t option ;
      values: ComplianceStringFilterValueList.t ;
      type_: ComplianceQueryOperatorType.t option }
    let make ?key  ?(values= [])  ?type_  () = { key; values; type_ }
    let parse xml =
      Some
        {
          key = (Util.option_bind (Xml.member "Key" xml) String.parse);
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "Values" xml)
                  ComplianceStringFilterValueList.parse));
          type_ =
            (Util.option_bind (Xml.member "Type" xml)
               ComplianceQueryOperatorType.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.key
                (fun f -> Ezxmlm.make_tag "Key" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Values"
                       ([], (ComplianceStringFilterValueList.to_xml [x]))))
               v.values))
           @
           [Util.option_map v.type_
              (fun f ->
                 Ezxmlm.make_tag "Type"
                   ([], (ComplianceQueryOperatorType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> ("type_", (ComplianceQueryOperatorType.to_json f)));
           Some
             ("values", (ComplianceStringFilterValueList.to_json v.values));
           Util.option_map v.key (fun f -> ("key", (String.to_json f)))])
    let of_json j =
      {
        key = (Util.option_map (Json.lookup j "key") String.of_json);
        values =
          (ComplianceStringFilterValueList.of_json
             (Util.of_option_exn (Json.lookup j "values")));
        type_ =
          (Util.option_map (Json.lookup j "type_")
             ComplianceQueryOperatorType.of_json)
      }
  end
module ParameterMetadata =
  struct
    type t =
      {
      name: String.t option ;
      type_: ParameterType.t option ;
      key_id: String.t option ;
      last_modified_date: DateTime.t option ;
      last_modified_user: String.t option ;
      description: String.t option ;
      allowed_pattern: String.t option ;
      version: Long.t option ;
      tier: ParameterTier.t option ;
      policies: ParameterPolicyList.t }
    let make ?name  ?type_  ?key_id  ?last_modified_date  ?last_modified_user
       ?description  ?allowed_pattern  ?version  ?tier  ?(policies= [])  () =
      {
        name;
        type_;
        key_id;
        last_modified_date;
        last_modified_user;
        description;
        allowed_pattern;
        version;
        tier;
        policies
      }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          type_ =
            (Util.option_bind (Xml.member "Type" xml) ParameterType.parse);
          key_id = (Util.option_bind (Xml.member "KeyId" xml) String.parse);
          last_modified_date =
            (Util.option_bind (Xml.member "LastModifiedDate" xml)
               DateTime.parse);
          last_modified_user =
            (Util.option_bind (Xml.member "LastModifiedUser" xml)
               String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          allowed_pattern =
            (Util.option_bind (Xml.member "AllowedPattern" xml) String.parse);
          version = (Util.option_bind (Xml.member "Version" xml) Long.parse);
          tier =
            (Util.option_bind (Xml.member "Tier" xml) ParameterTier.parse);
          policies =
            (Util.of_option []
               (Util.option_bind (Xml.member "Policies" xml)
                  ParameterPolicyList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.name
                       (fun f ->
                          Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.type_
                      (fun f ->
                         Ezxmlm.make_tag "Type"
                           ([], (ParameterType.to_xml f)))])
                  @
                  [Util.option_map v.key_id
                     (fun f ->
                        Ezxmlm.make_tag "KeyId" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.last_modified_date
                    (fun f ->
                       Ezxmlm.make_tag "LastModifiedDate"
                         ([], (DateTime.to_xml f)))])
                @
                [Util.option_map v.last_modified_user
                   (fun f ->
                      Ezxmlm.make_tag "LastModifiedUser"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.description
                  (fun f ->
                     Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
              @
              [Util.option_map v.allowed_pattern
                 (fun f ->
                    Ezxmlm.make_tag "AllowedPattern" ([], (String.to_xml f)))])
             @
             [Util.option_map v.version
                (fun f -> Ezxmlm.make_tag "Version" ([], (Long.to_xml f)))])
            @
            [Util.option_map v.tier
               (fun f ->
                  Ezxmlm.make_tag "Tier" ([], (ParameterTier.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Policies"
                      ([], (ParameterPolicyList.to_xml [x])))) v.policies))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("policies", (ParameterPolicyList.to_json v.policies));
           Util.option_map v.tier
             (fun f -> ("tier", (ParameterTier.to_json f)));
           Util.option_map v.version (fun f -> ("version", (Long.to_json f)));
           Util.option_map v.allowed_pattern
             (fun f -> ("allowed_pattern", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.last_modified_user
             (fun f -> ("last_modified_user", (String.to_json f)));
           Util.option_map v.last_modified_date
             (fun f -> ("last_modified_date", (DateTime.to_json f)));
           Util.option_map v.key_id (fun f -> ("key_id", (String.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (ParameterType.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        type_ =
          (Util.option_map (Json.lookup j "type_") ParameterType.of_json);
        key_id = (Util.option_map (Json.lookup j "key_id") String.of_json);
        last_modified_date =
          (Util.option_map (Json.lookup j "last_modified_date")
             DateTime.of_json);
        last_modified_user =
          (Util.option_map (Json.lookup j "last_modified_user")
             String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        allowed_pattern =
          (Util.option_map (Json.lookup j "allowed_pattern") String.of_json);
        version = (Util.option_map (Json.lookup j "version") Long.of_json);
        tier = (Util.option_map (Json.lookup j "tier") ParameterTier.of_json);
        policies =
          (ParameterPolicyList.of_json
             (Util.of_option_exn (Json.lookup j "policies")))
      }
  end
module MaintenanceWindowAutomationParameters =
  struct
    type t =
      {
      document_version: String.t option ;
      parameters: AutomationParameterMap.t option }
    let make ?document_version  ?parameters  () =
      { document_version; parameters }
    let parse xml =
      Some
        {
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          parameters =
            (Util.option_bind (Xml.member "Parameters" xml)
               AutomationParameterMap.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.document_version
               (fun f ->
                  Ezxmlm.make_tag "DocumentVersion" ([], (String.to_xml f)))])
           @
           [Util.option_map v.parameters
              (fun f ->
                 Ezxmlm.make_tag "Parameters"
                   ([], (AutomationParameterMap.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.parameters
              (fun f -> ("parameters", (AutomationParameterMap.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)))])
    let of_json j =
      {
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        parameters =
          (Util.option_map (Json.lookup j "parameters")
             AutomationParameterMap.of_json)
      }
  end
module MaintenanceWindowLambdaParameters =
  struct
    type t =
      {
      client_context: String.t option ;
      qualifier: String.t option ;
      payload: Blob.t option }
    let make ?client_context  ?qualifier  ?payload  () =
      { client_context; qualifier; payload }
    let parse xml =
      Some
        {
          client_context =
            (Util.option_bind (Xml.member "ClientContext" xml) String.parse);
          qualifier =
            (Util.option_bind (Xml.member "Qualifier" xml) String.parse);
          payload = (Util.option_bind (Xml.member "Payload" xml) Blob.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.client_context
                (fun f ->
                   Ezxmlm.make_tag "ClientContext" ([], (String.to_xml f)))])
            @
            [Util.option_map v.qualifier
               (fun f -> Ezxmlm.make_tag "Qualifier" ([], (String.to_xml f)))])
           @
           [Util.option_map v.payload
              (fun f -> Ezxmlm.make_tag "Payload" ([], (Blob.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.payload
              (fun f -> ("payload", (Blob.to_json f)));
           Util.option_map v.qualifier
             (fun f -> ("qualifier", (String.to_json f)));
           Util.option_map v.client_context
             (fun f -> ("client_context", (String.to_json f)))])
    let of_json j =
      {
        client_context =
          (Util.option_map (Json.lookup j "client_context") String.of_json);
        qualifier =
          (Util.option_map (Json.lookup j "qualifier") String.of_json);
        payload = (Util.option_map (Json.lookup j "payload") Blob.of_json)
      }
  end
module MaintenanceWindowRunCommandParameters =
  struct
    type t =
      {
      comment: String.t option ;
      cloud_watch_output_config: CloudWatchOutputConfig.t option ;
      document_hash: String.t option ;
      document_hash_type: DocumentHashType.t option ;
      document_version: String.t option ;
      notification_config: NotificationConfig.t option ;
      output_s3_bucket_name: String.t option ;
      output_s3_key_prefix: String.t option ;
      parameters: Parameters.t option ;
      service_role_arn: String.t option ;
      timeout_seconds: Integer.t option }
    let make ?comment  ?cloud_watch_output_config  ?document_hash 
      ?document_hash_type  ?document_version  ?notification_config 
      ?output_s3_bucket_name  ?output_s3_key_prefix  ?parameters 
      ?service_role_arn  ?timeout_seconds  () =
      {
        comment;
        cloud_watch_output_config;
        document_hash;
        document_hash_type;
        document_version;
        notification_config;
        output_s3_bucket_name;
        output_s3_key_prefix;
        parameters;
        service_role_arn;
        timeout_seconds
      }
    let parse xml =
      Some
        {
          comment =
            (Util.option_bind (Xml.member "Comment" xml) String.parse);
          cloud_watch_output_config =
            (Util.option_bind (Xml.member "CloudWatchOutputConfig" xml)
               CloudWatchOutputConfig.parse);
          document_hash =
            (Util.option_bind (Xml.member "DocumentHash" xml) String.parse);
          document_hash_type =
            (Util.option_bind (Xml.member "DocumentHashType" xml)
               DocumentHashType.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          notification_config =
            (Util.option_bind (Xml.member "NotificationConfig" xml)
               NotificationConfig.parse);
          output_s3_bucket_name =
            (Util.option_bind (Xml.member "OutputS3BucketName" xml)
               String.parse);
          output_s3_key_prefix =
            (Util.option_bind (Xml.member "OutputS3KeyPrefix" xml)
               String.parse);
          parameters =
            (Util.option_bind (Xml.member "Parameters" xml) Parameters.parse);
          service_role_arn =
            (Util.option_bind (Xml.member "ServiceRoleArn" xml) String.parse);
          timeout_seconds =
            (Util.option_bind (Xml.member "TimeoutSeconds" xml) Integer.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.comment
                        (fun f ->
                           Ezxmlm.make_tag "Comment" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.cloud_watch_output_config
                       (fun f ->
                          Ezxmlm.make_tag "CloudWatchOutputConfig"
                            ([], (CloudWatchOutputConfig.to_xml f)))])
                   @
                   [Util.option_map v.document_hash
                      (fun f ->
                         Ezxmlm.make_tag "DocumentHash"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.document_hash_type
                     (fun f ->
                        Ezxmlm.make_tag "DocumentHashType"
                          ([], (DocumentHashType.to_xml f)))])
                 @
                 [Util.option_map v.document_version
                    (fun f ->
                       Ezxmlm.make_tag "DocumentVersion"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.notification_config
                   (fun f ->
                      Ezxmlm.make_tag "NotificationConfig"
                        ([], (NotificationConfig.to_xml f)))])
               @
               [Util.option_map v.output_s3_bucket_name
                  (fun f ->
                     Ezxmlm.make_tag "OutputS3BucketName"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.output_s3_key_prefix
                 (fun f ->
                    Ezxmlm.make_tag "OutputS3KeyPrefix"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.parameters
                (fun f ->
                   Ezxmlm.make_tag "Parameters" ([], (Parameters.to_xml f)))])
            @
            [Util.option_map v.service_role_arn
               (fun f ->
                  Ezxmlm.make_tag "ServiceRoleArn" ([], (String.to_xml f)))])
           @
           [Util.option_map v.timeout_seconds
              (fun f ->
                 Ezxmlm.make_tag "TimeoutSeconds" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timeout_seconds
              (fun f -> ("timeout_seconds", (Integer.to_json f)));
           Util.option_map v.service_role_arn
             (fun f -> ("service_role_arn", (String.to_json f)));
           Util.option_map v.parameters
             (fun f -> ("parameters", (Parameters.to_json f)));
           Util.option_map v.output_s3_key_prefix
             (fun f -> ("output_s3_key_prefix", (String.to_json f)));
           Util.option_map v.output_s3_bucket_name
             (fun f -> ("output_s3_bucket_name", (String.to_json f)));
           Util.option_map v.notification_config
             (fun f ->
                ("notification_config", (NotificationConfig.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.document_hash_type
             (fun f -> ("document_hash_type", (DocumentHashType.to_json f)));
           Util.option_map v.document_hash
             (fun f -> ("document_hash", (String.to_json f)));
           Util.option_map v.cloud_watch_output_config
             (fun f ->
                ("cloud_watch_output_config",
                  (CloudWatchOutputConfig.to_json f)));
           Util.option_map v.comment
             (fun f -> ("comment", (String.to_json f)))])
    let of_json j =
      {
        comment = (Util.option_map (Json.lookup j "comment") String.of_json);
        cloud_watch_output_config =
          (Util.option_map (Json.lookup j "cloud_watch_output_config")
             CloudWatchOutputConfig.of_json);
        document_hash =
          (Util.option_map (Json.lookup j "document_hash") String.of_json);
        document_hash_type =
          (Util.option_map (Json.lookup j "document_hash_type")
             DocumentHashType.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        notification_config =
          (Util.option_map (Json.lookup j "notification_config")
             NotificationConfig.of_json);
        output_s3_bucket_name =
          (Util.option_map (Json.lookup j "output_s3_bucket_name")
             String.of_json);
        output_s3_key_prefix =
          (Util.option_map (Json.lookup j "output_s3_key_prefix")
             String.of_json);
        parameters =
          (Util.option_map (Json.lookup j "parameters") Parameters.of_json);
        service_role_arn =
          (Util.option_map (Json.lookup j "service_role_arn") String.of_json);
        timeout_seconds =
          (Util.option_map (Json.lookup j "timeout_seconds") Integer.of_json)
      }
  end
module MaintenanceWindowStepFunctionsParameters =
  struct
    type t = {
      input: String.t option ;
      name: String.t option }
    let make ?input  ?name  () = { input; name }
    let parse xml =
      Some
        {
          input = (Util.option_bind (Xml.member "Input" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.input
               (fun f -> Ezxmlm.make_tag "Input" ([], (String.to_xml f)))])
           @
           [Util.option_map v.name
              (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.input (fun f -> ("input", (String.to_json f)))])
    let of_json j =
      {
        input = (Util.option_map (Json.lookup j "input") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json)
      }
  end
module ScheduledWindowExecution =
  struct
    type t =
      {
      window_id: String.t option ;
      name: String.t option ;
      execution_time: String.t option }
    let make ?window_id  ?name  ?execution_time  () =
      { window_id; name; execution_time }
    let parse xml =
      Some
        {
          window_id =
            (Util.option_bind (Xml.member "WindowId" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          execution_time =
            (Util.option_bind (Xml.member "ExecutionTime" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.window_id
                (fun f -> Ezxmlm.make_tag "WindowId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.name
               (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
           @
           [Util.option_map v.execution_time
              (fun f ->
                 Ezxmlm.make_tag "ExecutionTime" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.execution_time
              (fun f -> ("execution_time", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.window_id
             (fun f -> ("window_id", (String.to_json f)))])
    let of_json j =
      {
        window_id =
          (Util.option_map (Json.lookup j "window_id") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        execution_time =
          (Util.option_map (Json.lookup j "execution_time") String.of_json)
      }
  end
module AssociationFilter =
  struct
    type t = {
      key: AssociationFilterKey.t ;
      value: String.t }
    let make ~key  ~value  () = { key; value }
    let parse xml =
      Some
        {
          key =
            (Xml.required "key"
               (Util.option_bind (Xml.member "key" xml)
                  AssociationFilterKey.parse));
          value =
            (Xml.required "value"
               (Util.option_bind (Xml.member "value" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "key"
                  ([], (AssociationFilterKey.to_xml v.key)))])
           @ [Some (Ezxmlm.make_tag "value" ([], (String.to_xml v.value)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("value", (String.to_json v.value));
           Some ("key", (AssociationFilterKey.to_json v.key))])
    let of_json j =
      {
        key =
          (AssociationFilterKey.of_json
             (Util.of_option_exn (Json.lookup j "key")));
        value = (String.of_json (Util.of_option_exn (Json.lookup j "value")))
      }
  end
module ParameterHistory =
  struct
    type t =
      {
      name: String.t option ;
      type_: ParameterType.t option ;
      key_id: String.t option ;
      last_modified_date: DateTime.t option ;
      last_modified_user: String.t option ;
      description: String.t option ;
      value: String.t option ;
      allowed_pattern: String.t option ;
      version: Long.t option ;
      labels: ParameterLabelList.t ;
      tier: ParameterTier.t option ;
      policies: ParameterPolicyList.t }
    let make ?name  ?type_  ?key_id  ?last_modified_date  ?last_modified_user
       ?description  ?value  ?allowed_pattern  ?version  ?(labels= [])  ?tier
       ?(policies= [])  () =
      {
        name;
        type_;
        key_id;
        last_modified_date;
        last_modified_user;
        description;
        value;
        allowed_pattern;
        version;
        labels;
        tier;
        policies
      }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          type_ =
            (Util.option_bind (Xml.member "Type" xml) ParameterType.parse);
          key_id = (Util.option_bind (Xml.member "KeyId" xml) String.parse);
          last_modified_date =
            (Util.option_bind (Xml.member "LastModifiedDate" xml)
               DateTime.parse);
          last_modified_user =
            (Util.option_bind (Xml.member "LastModifiedUser" xml)
               String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          value = (Util.option_bind (Xml.member "Value" xml) String.parse);
          allowed_pattern =
            (Util.option_bind (Xml.member "AllowedPattern" xml) String.parse);
          version = (Util.option_bind (Xml.member "Version" xml) Long.parse);
          labels =
            (Util.of_option []
               (Util.option_bind (Xml.member "Labels" xml)
                  ParameterLabelList.parse));
          tier =
            (Util.option_bind (Xml.member "Tier" xml) ParameterTier.parse);
          policies =
            (Util.of_option []
               (Util.option_bind (Xml.member "Policies" xml)
                  ParameterPolicyList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Util.option_map v.name
                         (fun f ->
                            Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.type_
                        (fun f ->
                           Ezxmlm.make_tag "Type"
                             ([], (ParameterType.to_xml f)))])
                    @
                    [Util.option_map v.key_id
                       (fun f ->
                          Ezxmlm.make_tag "KeyId" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.last_modified_date
                      (fun f ->
                         Ezxmlm.make_tag "LastModifiedDate"
                           ([], (DateTime.to_xml f)))])
                  @
                  [Util.option_map v.last_modified_user
                     (fun f ->
                        Ezxmlm.make_tag "LastModifiedUser"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.description
                    (fun f ->
                       Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
                @
                [Util.option_map v.value
                   (fun f -> Ezxmlm.make_tag "Value" ([], (String.to_xml f)))])
               @
               [Util.option_map v.allowed_pattern
                  (fun f ->
                     Ezxmlm.make_tag "AllowedPattern" ([], (String.to_xml f)))])
              @
              [Util.option_map v.version
                 (fun f -> Ezxmlm.make_tag "Version" ([], (Long.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Labels"
                        ([], (ParameterLabelList.to_xml [x])))) v.labels))
            @
            [Util.option_map v.tier
               (fun f ->
                  Ezxmlm.make_tag "Tier" ([], (ParameterTier.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Policies"
                      ([], (ParameterPolicyList.to_xml [x])))) v.policies))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("policies", (ParameterPolicyList.to_json v.policies));
           Util.option_map v.tier
             (fun f -> ("tier", (ParameterTier.to_json f)));
           Some ("labels", (ParameterLabelList.to_json v.labels));
           Util.option_map v.version (fun f -> ("version", (Long.to_json f)));
           Util.option_map v.allowed_pattern
             (fun f -> ("allowed_pattern", (String.to_json f)));
           Util.option_map v.value (fun f -> ("value", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.last_modified_user
             (fun f -> ("last_modified_user", (String.to_json f)));
           Util.option_map v.last_modified_date
             (fun f -> ("last_modified_date", (DateTime.to_json f)));
           Util.option_map v.key_id (fun f -> ("key_id", (String.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (ParameterType.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        type_ =
          (Util.option_map (Json.lookup j "type_") ParameterType.of_json);
        key_id = (Util.option_map (Json.lookup j "key_id") String.of_json);
        last_modified_date =
          (Util.option_map (Json.lookup j "last_modified_date")
             DateTime.of_json);
        last_modified_user =
          (Util.option_map (Json.lookup j "last_modified_user")
             String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        value = (Util.option_map (Json.lookup j "value") String.of_json);
        allowed_pattern =
          (Util.option_map (Json.lookup j "allowed_pattern") String.of_json);
        version = (Util.option_map (Json.lookup j "version") Long.of_json);
        labels =
          (ParameterLabelList.of_json
             (Util.of_option_exn (Json.lookup j "labels")));
        tier = (Util.option_map (Json.lookup j "tier") ParameterTier.of_json);
        policies =
          (ParameterPolicyList.of_json
             (Util.of_option_exn (Json.lookup j "policies")))
      }
  end
module InstanceInformation =
  struct
    type t =
      {
      instance_id: String.t option ;
      ping_status: PingStatus.t option ;
      last_ping_date_time: DateTime.t option ;
      agent_version: String.t option ;
      is_latest_version: Boolean.t option ;
      platform_type: PlatformType.t option ;
      platform_name: String.t option ;
      platform_version: String.t option ;
      activation_id: String.t option ;
      iam_role: String.t option ;
      registration_date: DateTime.t option ;
      resource_type: ResourceType.t option ;
      name: String.t option ;
      i_p_address: String.t option ;
      computer_name: String.t option ;
      association_status: String.t option ;
      last_association_execution_date: DateTime.t option ;
      last_successful_association_execution_date: DateTime.t option ;
      association_overview: InstanceAggregatedAssociationOverview.t option }
    let make ?instance_id  ?ping_status  ?last_ping_date_time  ?agent_version
       ?is_latest_version  ?platform_type  ?platform_name  ?platform_version 
      ?activation_id  ?iam_role  ?registration_date  ?resource_type  ?name 
      ?i_p_address  ?computer_name  ?association_status 
      ?last_association_execution_date 
      ?last_successful_association_execution_date  ?association_overview  ()
      =
      {
        instance_id;
        ping_status;
        last_ping_date_time;
        agent_version;
        is_latest_version;
        platform_type;
        platform_name;
        platform_version;
        activation_id;
        iam_role;
        registration_date;
        resource_type;
        name;
        i_p_address;
        computer_name;
        association_status;
        last_association_execution_date;
        last_successful_association_execution_date;
        association_overview
      }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          ping_status =
            (Util.option_bind (Xml.member "PingStatus" xml) PingStatus.parse);
          last_ping_date_time =
            (Util.option_bind (Xml.member "LastPingDateTime" xml)
               DateTime.parse);
          agent_version =
            (Util.option_bind (Xml.member "AgentVersion" xml) String.parse);
          is_latest_version =
            (Util.option_bind (Xml.member "IsLatestVersion" xml)
               Boolean.parse);
          platform_type =
            (Util.option_bind (Xml.member "PlatformType" xml)
               PlatformType.parse);
          platform_name =
            (Util.option_bind (Xml.member "PlatformName" xml) String.parse);
          platform_version =
            (Util.option_bind (Xml.member "PlatformVersion" xml) String.parse);
          activation_id =
            (Util.option_bind (Xml.member "ActivationId" xml) String.parse);
          iam_role =
            (Util.option_bind (Xml.member "IamRole" xml) String.parse);
          registration_date =
            (Util.option_bind (Xml.member "RegistrationDate" xml)
               DateTime.parse);
          resource_type =
            (Util.option_bind (Xml.member "ResourceType" xml)
               ResourceType.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          i_p_address =
            (Util.option_bind (Xml.member "IPAddress" xml) String.parse);
          computer_name =
            (Util.option_bind (Xml.member "ComputerName" xml) String.parse);
          association_status =
            (Util.option_bind (Xml.member "AssociationStatus" xml)
               String.parse);
          last_association_execution_date =
            (Util.option_bind (Xml.member "LastAssociationExecutionDate" xml)
               DateTime.parse);
          last_successful_association_execution_date =
            (Util.option_bind
               (Xml.member "LastSuccessfulAssociationExecutionDate" xml)
               DateTime.parse);
          association_overview =
            (Util.option_bind (Xml.member "AssociationOverview" xml)
               InstanceAggregatedAssociationOverview.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((((([] @
                             [Util.option_map v.instance_id
                                (fun f ->
                                   Ezxmlm.make_tag "InstanceId"
                                     ([], (String.to_xml f)))])
                            @
                            [Util.option_map v.ping_status
                               (fun f ->
                                  Ezxmlm.make_tag "PingStatus"
                                    ([], (PingStatus.to_xml f)))])
                           @
                           [Util.option_map v.last_ping_date_time
                              (fun f ->
                                 Ezxmlm.make_tag "LastPingDateTime"
                                   ([], (DateTime.to_xml f)))])
                          @
                          [Util.option_map v.agent_version
                             (fun f ->
                                Ezxmlm.make_tag "AgentVersion"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.is_latest_version
                            (fun f ->
                               Ezxmlm.make_tag "IsLatestVersion"
                                 ([], (Boolean.to_xml f)))])
                        @
                        [Util.option_map v.platform_type
                           (fun f ->
                              Ezxmlm.make_tag "PlatformType"
                                ([], (PlatformType.to_xml f)))])
                       @
                       [Util.option_map v.platform_name
                          (fun f ->
                             Ezxmlm.make_tag "PlatformName"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.platform_version
                         (fun f ->
                            Ezxmlm.make_tag "PlatformVersion"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.activation_id
                        (fun f ->
                           Ezxmlm.make_tag "ActivationId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.iam_role
                       (fun f ->
                          Ezxmlm.make_tag "IamRole" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.registration_date
                      (fun f ->
                         Ezxmlm.make_tag "RegistrationDate"
                           ([], (DateTime.to_xml f)))])
                  @
                  [Util.option_map v.resource_type
                     (fun f ->
                        Ezxmlm.make_tag "ResourceType"
                          ([], (ResourceType.to_xml f)))])
                 @
                 [Util.option_map v.name
                    (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                @
                [Util.option_map v.i_p_address
                   (fun f ->
                      Ezxmlm.make_tag "IPAddress" ([], (String.to_xml f)))])
               @
               [Util.option_map v.computer_name
                  (fun f ->
                     Ezxmlm.make_tag "ComputerName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.association_status
                 (fun f ->
                    Ezxmlm.make_tag "AssociationStatus"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.last_association_execution_date
                (fun f ->
                   Ezxmlm.make_tag "LastAssociationExecutionDate"
                     ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.last_successful_association_execution_date
               (fun f ->
                  Ezxmlm.make_tag "LastSuccessfulAssociationExecutionDate"
                    ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.association_overview
              (fun f ->
                 Ezxmlm.make_tag "AssociationOverview"
                   ([], (InstanceAggregatedAssociationOverview.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_overview
              (fun f ->
                 ("association_overview",
                   (InstanceAggregatedAssociationOverview.to_json f)));
           Util.option_map v.last_successful_association_execution_date
             (fun f ->
                ("last_successful_association_execution_date",
                  (DateTime.to_json f)));
           Util.option_map v.last_association_execution_date
             (fun f ->
                ("last_association_execution_date", (DateTime.to_json f)));
           Util.option_map v.association_status
             (fun f -> ("association_status", (String.to_json f)));
           Util.option_map v.computer_name
             (fun f -> ("computer_name", (String.to_json f)));
           Util.option_map v.i_p_address
             (fun f -> ("i_p_address", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.resource_type
             (fun f -> ("resource_type", (ResourceType.to_json f)));
           Util.option_map v.registration_date
             (fun f -> ("registration_date", (DateTime.to_json f)));
           Util.option_map v.iam_role
             (fun f -> ("iam_role", (String.to_json f)));
           Util.option_map v.activation_id
             (fun f -> ("activation_id", (String.to_json f)));
           Util.option_map v.platform_version
             (fun f -> ("platform_version", (String.to_json f)));
           Util.option_map v.platform_name
             (fun f -> ("platform_name", (String.to_json f)));
           Util.option_map v.platform_type
             (fun f -> ("platform_type", (PlatformType.to_json f)));
           Util.option_map v.is_latest_version
             (fun f -> ("is_latest_version", (Boolean.to_json f)));
           Util.option_map v.agent_version
             (fun f -> ("agent_version", (String.to_json f)));
           Util.option_map v.last_ping_date_time
             (fun f -> ("last_ping_date_time", (DateTime.to_json f)));
           Util.option_map v.ping_status
             (fun f -> ("ping_status", (PingStatus.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        ping_status =
          (Util.option_map (Json.lookup j "ping_status") PingStatus.of_json);
        last_ping_date_time =
          (Util.option_map (Json.lookup j "last_ping_date_time")
             DateTime.of_json);
        agent_version =
          (Util.option_map (Json.lookup j "agent_version") String.of_json);
        is_latest_version =
          (Util.option_map (Json.lookup j "is_latest_version")
             Boolean.of_json);
        platform_type =
          (Util.option_map (Json.lookup j "platform_type")
             PlatformType.of_json);
        platform_name =
          (Util.option_map (Json.lookup j "platform_name") String.of_json);
        platform_version =
          (Util.option_map (Json.lookup j "platform_version") String.of_json);
        activation_id =
          (Util.option_map (Json.lookup j "activation_id") String.of_json);
        iam_role =
          (Util.option_map (Json.lookup j "iam_role") String.of_json);
        registration_date =
          (Util.option_map (Json.lookup j "registration_date")
             DateTime.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             ResourceType.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        i_p_address =
          (Util.option_map (Json.lookup j "i_p_address") String.of_json);
        computer_name =
          (Util.option_map (Json.lookup j "computer_name") String.of_json);
        association_status =
          (Util.option_map (Json.lookup j "association_status")
             String.of_json);
        last_association_execution_date =
          (Util.option_map (Json.lookup j "last_association_execution_date")
             DateTime.of_json);
        last_successful_association_execution_date =
          (Util.option_map
             (Json.lookup j "last_successful_association_execution_date")
             DateTime.of_json);
        association_overview =
          (Util.option_map (Json.lookup j "association_overview")
             InstanceAggregatedAssociationOverview.of_json)
      }
  end
module DocumentVersionInfo =
  struct
    type t =
      {
      name: String.t option ;
      document_version: String.t option ;
      version_name: String.t option ;
      created_date: DateTime.t option ;
      is_default_version: Boolean.t option ;
      document_format: DocumentFormat.t option ;
      status: DocumentStatus.t option ;
      status_information: String.t option }
    let make ?name  ?document_version  ?version_name  ?created_date 
      ?is_default_version  ?document_format  ?status  ?status_information  ()
      =
      {
        name;
        document_version;
        version_name;
        created_date;
        is_default_version;
        document_format;
        status;
        status_information
      }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          version_name =
            (Util.option_bind (Xml.member "VersionName" xml) String.parse);
          created_date =
            (Util.option_bind (Xml.member "CreatedDate" xml) DateTime.parse);
          is_default_version =
            (Util.option_bind (Xml.member "IsDefaultVersion" xml)
               Boolean.parse);
          document_format =
            (Util.option_bind (Xml.member "DocumentFormat" xml)
               DocumentFormat.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml) DocumentStatus.parse);
          status_information =
            (Util.option_bind (Xml.member "StatusInformation" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.name
                     (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.document_version
                    (fun f ->
                       Ezxmlm.make_tag "DocumentVersion"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.version_name
                   (fun f ->
                      Ezxmlm.make_tag "VersionName" ([], (String.to_xml f)))])
               @
               [Util.option_map v.created_date
                  (fun f ->
                     Ezxmlm.make_tag "CreatedDate" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.is_default_version
                 (fun f ->
                    Ezxmlm.make_tag "IsDefaultVersion"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.document_format
                (fun f ->
                   Ezxmlm.make_tag "DocumentFormat"
                     ([], (DocumentFormat.to_xml f)))])
            @
            [Util.option_map v.status
               (fun f ->
                  Ezxmlm.make_tag "Status" ([], (DocumentStatus.to_xml f)))])
           @
           [Util.option_map v.status_information
              (fun f ->
                 Ezxmlm.make_tag "StatusInformation" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_information
              (fun f -> ("status_information", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (DocumentStatus.to_json f)));
           Util.option_map v.document_format
             (fun f -> ("document_format", (DocumentFormat.to_json f)));
           Util.option_map v.is_default_version
             (fun f -> ("is_default_version", (Boolean.to_json f)));
           Util.option_map v.created_date
             (fun f -> ("created_date", (DateTime.to_json f)));
           Util.option_map v.version_name
             (fun f -> ("version_name", (String.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        version_name =
          (Util.option_map (Json.lookup j "version_name") String.of_json);
        created_date =
          (Util.option_map (Json.lookup j "created_date") DateTime.of_json);
        is_default_version =
          (Util.option_map (Json.lookup j "is_default_version")
             Boolean.of_json);
        document_format =
          (Util.option_map (Json.lookup j "document_format")
             DocumentFormat.of_json);
        status =
          (Util.option_map (Json.lookup j "status") DocumentStatus.of_json);
        status_information =
          (Util.option_map (Json.lookup j "status_information")
             String.of_json)
      }
  end
module AssociationExecutionTargetsFilter =
  struct
    type t = {
      key: AssociationExecutionTargetsFilterKey.t ;
      value: String.t }
    let make ~key  ~value  () = { key; value }
    let parse xml =
      Some
        {
          key =
            (Xml.required "Key"
               (Util.option_bind (Xml.member "Key" xml)
                  AssociationExecutionTargetsFilterKey.parse));
          value =
            (Xml.required "Value"
               (Util.option_bind (Xml.member "Value" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "Key"
                  ([], (AssociationExecutionTargetsFilterKey.to_xml v.key)))])
           @ [Some (Ezxmlm.make_tag "Value" ([], (String.to_xml v.value)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("value", (String.to_json v.value));
           Some ("key", (AssociationExecutionTargetsFilterKey.to_json v.key))])
    let of_json j =
      {
        key =
          (AssociationExecutionTargetsFilterKey.of_json
             (Util.of_option_exn (Json.lookup j "key")));
        value = (String.of_json (Util.of_option_exn (Json.lookup j "value")))
      }
  end
module StepExecutionFilter =
  struct
    type t =
      {
      key: StepExecutionFilterKey.t ;
      values: StepExecutionFilterValueList.t }
    let make ~key  ~values  () = { key; values }
    let parse xml =
      Some
        {
          key =
            (Xml.required "Key"
               (Util.option_bind (Xml.member "Key" xml)
                  StepExecutionFilterKey.parse));
          values =
            (Xml.required "Values"
               (Util.option_bind (Xml.member "Values" xml)
                  StepExecutionFilterValueList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "Key"
                  ([], (StepExecutionFilterKey.to_xml v.key)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Values"
                      ([], (StepExecutionFilterValueList.to_xml [x]))))
              v.values))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (StepExecutionFilterValueList.to_json v.values));
           Some ("key", (StepExecutionFilterKey.to_json v.key))])
    let of_json j =
      {
        key =
          (StepExecutionFilterKey.of_json
             (Util.of_option_exn (Json.lookup j "key")));
        values =
          (StepExecutionFilterValueList.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module AutomationExecutionMetadata =
  struct
    type t =
      {
      automation_execution_id: String.t option ;
      document_name: String.t option ;
      document_version: String.t option ;
      automation_execution_status: AutomationExecutionStatus.t option ;
      execution_start_time: DateTime.t option ;
      execution_end_time: DateTime.t option ;
      executed_by: String.t option ;
      log_file: String.t option ;
      outputs: AutomationParameterMap.t option ;
      mode: ExecutionMode.t option ;
      parent_automation_execution_id: String.t option ;
      current_step_name: String.t option ;
      current_action: String.t option ;
      failure_message: String.t option ;
      target_parameter_name: String.t option ;
      targets: Targets.t ;
      target_maps: TargetMaps.t ;
      resolved_targets: ResolvedTargets.t option ;
      max_concurrency: String.t option ;
      max_errors: String.t option ;
      target: String.t option ;
      automation_type: AutomationType.t option }
    let make ?automation_execution_id  ?document_name  ?document_version 
      ?automation_execution_status  ?execution_start_time 
      ?execution_end_time  ?executed_by  ?log_file  ?outputs  ?mode 
      ?parent_automation_execution_id  ?current_step_name  ?current_action 
      ?failure_message  ?target_parameter_name  ?(targets= []) 
      ?(target_maps= [])  ?resolved_targets  ?max_concurrency  ?max_errors 
      ?target  ?automation_type  () =
      {
        automation_execution_id;
        document_name;
        document_version;
        automation_execution_status;
        execution_start_time;
        execution_end_time;
        executed_by;
        log_file;
        outputs;
        mode;
        parent_automation_execution_id;
        current_step_name;
        current_action;
        failure_message;
        target_parameter_name;
        targets;
        target_maps;
        resolved_targets;
        max_concurrency;
        max_errors;
        target;
        automation_type
      }
    let parse xml =
      Some
        {
          automation_execution_id =
            (Util.option_bind (Xml.member "AutomationExecutionId" xml)
               String.parse);
          document_name =
            (Util.option_bind (Xml.member "DocumentName" xml) String.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          automation_execution_status =
            (Util.option_bind (Xml.member "AutomationExecutionStatus" xml)
               AutomationExecutionStatus.parse);
          execution_start_time =
            (Util.option_bind (Xml.member "ExecutionStartTime" xml)
               DateTime.parse);
          execution_end_time =
            (Util.option_bind (Xml.member "ExecutionEndTime" xml)
               DateTime.parse);
          executed_by =
            (Util.option_bind (Xml.member "ExecutedBy" xml) String.parse);
          log_file =
            (Util.option_bind (Xml.member "LogFile" xml) String.parse);
          outputs =
            (Util.option_bind (Xml.member "Outputs" xml)
               AutomationParameterMap.parse);
          mode =
            (Util.option_bind (Xml.member "Mode" xml) ExecutionMode.parse);
          parent_automation_execution_id =
            (Util.option_bind (Xml.member "ParentAutomationExecutionId" xml)
               String.parse);
          current_step_name =
            (Util.option_bind (Xml.member "CurrentStepName" xml) String.parse);
          current_action =
            (Util.option_bind (Xml.member "CurrentAction" xml) String.parse);
          failure_message =
            (Util.option_bind (Xml.member "FailureMessage" xml) String.parse);
          target_parameter_name =
            (Util.option_bind (Xml.member "TargetParameterName" xml)
               String.parse);
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          target_maps =
            (Util.of_option []
               (Util.option_bind (Xml.member "TargetMaps" xml)
                  TargetMaps.parse));
          resolved_targets =
            (Util.option_bind (Xml.member "ResolvedTargets" xml)
               ResolvedTargets.parse);
          max_concurrency =
            (Util.option_bind (Xml.member "MaxConcurrency" xml) String.parse);
          max_errors =
            (Util.option_bind (Xml.member "MaxErrors" xml) String.parse);
          target = (Util.option_bind (Xml.member "Target" xml) String.parse);
          automation_type =
            (Util.option_bind (Xml.member "AutomationType" xml)
               AutomationType.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((((((([] @
                                [Util.option_map v.automation_execution_id
                                   (fun f ->
                                      Ezxmlm.make_tag "AutomationExecutionId"
                                        ([], (String.to_xml f)))])
                               @
                               [Util.option_map v.document_name
                                  (fun f ->
                                     Ezxmlm.make_tag "DocumentName"
                                       ([], (String.to_xml f)))])
                              @
                              [Util.option_map v.document_version
                                 (fun f ->
                                    Ezxmlm.make_tag "DocumentVersion"
                                      ([], (String.to_xml f)))])
                             @
                             [Util.option_map v.automation_execution_status
                                (fun f ->
                                   Ezxmlm.make_tag
                                     "AutomationExecutionStatus"
                                     ([],
                                       (AutomationExecutionStatus.to_xml f)))])
                            @
                            [Util.option_map v.execution_start_time
                               (fun f ->
                                  Ezxmlm.make_tag "ExecutionStartTime"
                                    ([], (DateTime.to_xml f)))])
                           @
                           [Util.option_map v.execution_end_time
                              (fun f ->
                                 Ezxmlm.make_tag "ExecutionEndTime"
                                   ([], (DateTime.to_xml f)))])
                          @
                          [Util.option_map v.executed_by
                             (fun f ->
                                Ezxmlm.make_tag "ExecutedBy"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.log_file
                            (fun f ->
                               Ezxmlm.make_tag "LogFile"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.outputs
                           (fun f ->
                              Ezxmlm.make_tag "Outputs"
                                ([], (AutomationParameterMap.to_xml f)))])
                       @
                       [Util.option_map v.mode
                          (fun f ->
                             Ezxmlm.make_tag "Mode"
                               ([], (ExecutionMode.to_xml f)))])
                      @
                      [Util.option_map v.parent_automation_execution_id
                         (fun f ->
                            Ezxmlm.make_tag "ParentAutomationExecutionId"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.current_step_name
                        (fun f ->
                           Ezxmlm.make_tag "CurrentStepName"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.current_action
                       (fun f ->
                          Ezxmlm.make_tag "CurrentAction"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.failure_message
                      (fun f ->
                         Ezxmlm.make_tag "FailureMessage"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.target_parameter_name
                     (fun f ->
                        Ezxmlm.make_tag "TargetParameterName"
                          ([], (String.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "Targets"
                            ([], (Targets.to_xml [x])))) v.targets))
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "TargetMaps"
                           ([], (TargetMaps.to_xml [x])))) v.target_maps))
               @
               [Util.option_map v.resolved_targets
                  (fun f ->
                     Ezxmlm.make_tag "ResolvedTargets"
                       ([], (ResolvedTargets.to_xml f)))])
              @
              [Util.option_map v.max_concurrency
                 (fun f ->
                    Ezxmlm.make_tag "MaxConcurrency" ([], (String.to_xml f)))])
             @
             [Util.option_map v.max_errors
                (fun f -> Ezxmlm.make_tag "MaxErrors" ([], (String.to_xml f)))])
            @
            [Util.option_map v.target
               (fun f -> Ezxmlm.make_tag "Target" ([], (String.to_xml f)))])
           @
           [Util.option_map v.automation_type
              (fun f ->
                 Ezxmlm.make_tag "AutomationType"
                   ([], (AutomationType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.automation_type
              (fun f -> ("automation_type", (AutomationType.to_json f)));
           Util.option_map v.target (fun f -> ("target", (String.to_json f)));
           Util.option_map v.max_errors
             (fun f -> ("max_errors", (String.to_json f)));
           Util.option_map v.max_concurrency
             (fun f -> ("max_concurrency", (String.to_json f)));
           Util.option_map v.resolved_targets
             (fun f -> ("resolved_targets", (ResolvedTargets.to_json f)));
           Some ("target_maps", (TargetMaps.to_json v.target_maps));
           Some ("targets", (Targets.to_json v.targets));
           Util.option_map v.target_parameter_name
             (fun f -> ("target_parameter_name", (String.to_json f)));
           Util.option_map v.failure_message
             (fun f -> ("failure_message", (String.to_json f)));
           Util.option_map v.current_action
             (fun f -> ("current_action", (String.to_json f)));
           Util.option_map v.current_step_name
             (fun f -> ("current_step_name", (String.to_json f)));
           Util.option_map v.parent_automation_execution_id
             (fun f -> ("parent_automation_execution_id", (String.to_json f)));
           Util.option_map v.mode
             (fun f -> ("mode", (ExecutionMode.to_json f)));
           Util.option_map v.outputs
             (fun f -> ("outputs", (AutomationParameterMap.to_json f)));
           Util.option_map v.log_file
             (fun f -> ("log_file", (String.to_json f)));
           Util.option_map v.executed_by
             (fun f -> ("executed_by", (String.to_json f)));
           Util.option_map v.execution_end_time
             (fun f -> ("execution_end_time", (DateTime.to_json f)));
           Util.option_map v.execution_start_time
             (fun f -> ("execution_start_time", (DateTime.to_json f)));
           Util.option_map v.automation_execution_status
             (fun f ->
                ("automation_execution_status",
                  (AutomationExecutionStatus.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.document_name
             (fun f -> ("document_name", (String.to_json f)));
           Util.option_map v.automation_execution_id
             (fun f -> ("automation_execution_id", (String.to_json f)))])
    let of_json j =
      {
        automation_execution_id =
          (Util.option_map (Json.lookup j "automation_execution_id")
             String.of_json);
        document_name =
          (Util.option_map (Json.lookup j "document_name") String.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        automation_execution_status =
          (Util.option_map (Json.lookup j "automation_execution_status")
             AutomationExecutionStatus.of_json);
        execution_start_time =
          (Util.option_map (Json.lookup j "execution_start_time")
             DateTime.of_json);
        execution_end_time =
          (Util.option_map (Json.lookup j "execution_end_time")
             DateTime.of_json);
        executed_by =
          (Util.option_map (Json.lookup j "executed_by") String.of_json);
        log_file =
          (Util.option_map (Json.lookup j "log_file") String.of_json);
        outputs =
          (Util.option_map (Json.lookup j "outputs")
             AutomationParameterMap.of_json);
        mode = (Util.option_map (Json.lookup j "mode") ExecutionMode.of_json);
        parent_automation_execution_id =
          (Util.option_map (Json.lookup j "parent_automation_execution_id")
             String.of_json);
        current_step_name =
          (Util.option_map (Json.lookup j "current_step_name") String.of_json);
        current_action =
          (Util.option_map (Json.lookup j "current_action") String.of_json);
        failure_message =
          (Util.option_map (Json.lookup j "failure_message") String.of_json);
        target_parameter_name =
          (Util.option_map (Json.lookup j "target_parameter_name")
             String.of_json);
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        target_maps =
          (TargetMaps.of_json
             (Util.of_option_exn (Json.lookup j "target_maps")));
        resolved_targets =
          (Util.option_map (Json.lookup j "resolved_targets")
             ResolvedTargets.of_json);
        max_concurrency =
          (Util.option_map (Json.lookup j "max_concurrency") String.of_json);
        max_errors =
          (Util.option_map (Json.lookup j "max_errors") String.of_json);
        target = (Util.option_map (Json.lookup j "target") String.of_json);
        automation_type =
          (Util.option_map (Json.lookup j "automation_type")
             AutomationType.of_json)
      }
  end
module DocumentIdentifier =
  struct
    type t =
      {
      name: String.t option ;
      owner: String.t option ;
      version_name: String.t option ;
      platform_types: PlatformTypeList.t ;
      document_version: String.t option ;
      document_type: DocumentType.t option ;
      schema_version: String.t option ;
      document_format: DocumentFormat.t option ;
      target_type: String.t option ;
      tags: TagList.t ;
      requires: DocumentRequiresList.t }
    let make ?name  ?owner  ?version_name  ?(platform_types= []) 
      ?document_version  ?document_type  ?schema_version  ?document_format 
      ?target_type  ?(tags= [])  ?(requires= [])  () =
      {
        name;
        owner;
        version_name;
        platform_types;
        document_version;
        document_type;
        schema_version;
        document_format;
        target_type;
        tags;
        requires
      }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          owner = (Util.option_bind (Xml.member "Owner" xml) String.parse);
          version_name =
            (Util.option_bind (Xml.member "VersionName" xml) String.parse);
          platform_types =
            (Util.of_option []
               (Util.option_bind (Xml.member "PlatformTypes" xml)
                  PlatformTypeList.parse));
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          document_type =
            (Util.option_bind (Xml.member "DocumentType" xml)
               DocumentType.parse);
          schema_version =
            (Util.option_bind (Xml.member "SchemaVersion" xml) String.parse);
          document_format =
            (Util.option_bind (Xml.member "DocumentFormat" xml)
               DocumentFormat.parse);
          target_type =
            (Util.option_bind (Xml.member "TargetType" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tags" xml) TagList.parse));
          requires =
            (Util.of_option []
               (Util.option_bind (Xml.member "Requires" xml)
                  DocumentRequiresList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.name
                        (fun f ->
                           Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.owner
                       (fun f ->
                          Ezxmlm.make_tag "Owner" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.version_name
                      (fun f ->
                         Ezxmlm.make_tag "VersionName"
                           ([], (String.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "PlatformTypes"
                             ([], (PlatformTypeList.to_xml [x]))))
                     v.platform_types))
                 @
                 [Util.option_map v.document_version
                    (fun f ->
                       Ezxmlm.make_tag "DocumentVersion"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.document_type
                   (fun f ->
                      Ezxmlm.make_tag "DocumentType"
                        ([], (DocumentType.to_xml f)))])
               @
               [Util.option_map v.schema_version
                  (fun f ->
                     Ezxmlm.make_tag "SchemaVersion" ([], (String.to_xml f)))])
              @
              [Util.option_map v.document_format
                 (fun f ->
                    Ezxmlm.make_tag "DocumentFormat"
                      ([], (DocumentFormat.to_xml f)))])
             @
             [Util.option_map v.target_type
                (fun f ->
                   Ezxmlm.make_tag "TargetType" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some (Ezxmlm.make_tag "Tags" ([], (TagList.to_xml [x]))))
               v.tags))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Requires"
                      ([], (DocumentRequiresList.to_xml [x])))) v.requires))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("requires", (DocumentRequiresList.to_json v.requires));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.target_type
             (fun f -> ("target_type", (String.to_json f)));
           Util.option_map v.document_format
             (fun f -> ("document_format", (DocumentFormat.to_json f)));
           Util.option_map v.schema_version
             (fun f -> ("schema_version", (String.to_json f)));
           Util.option_map v.document_type
             (fun f -> ("document_type", (DocumentType.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Some
             ("platform_types", (PlatformTypeList.to_json v.platform_types));
           Util.option_map v.version_name
             (fun f -> ("version_name", (String.to_json f)));
           Util.option_map v.owner (fun f -> ("owner", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        owner = (Util.option_map (Json.lookup j "owner") String.of_json);
        version_name =
          (Util.option_map (Json.lookup j "version_name") String.of_json);
        platform_types =
          (PlatformTypeList.of_json
             (Util.of_option_exn (Json.lookup j "platform_types")));
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        document_type =
          (Util.option_map (Json.lookup j "document_type")
             DocumentType.of_json);
        schema_version =
          (Util.option_map (Json.lookup j "schema_version") String.of_json);
        document_format =
          (Util.option_map (Json.lookup j "document_format")
             DocumentFormat.of_json);
        target_type =
          (Util.option_map (Json.lookup j "target_type") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        requires =
          (DocumentRequiresList.of_json
             (Util.of_option_exn (Json.lookup j "requires")))
      }
  end
module InstanceInformationFilter =
  struct
    type t =
      {
      key: InstanceInformationFilterKey.t ;
      value_set: InstanceInformationFilterValueSet.t }
    let make ~key  ~value_set  () = { key; value_set }
    let parse xml =
      Some
        {
          key =
            (Xml.required "key"
               (Util.option_bind (Xml.member "key" xml)
                  InstanceInformationFilterKey.parse));
          value_set =
            (Xml.required "valueSet"
               (Util.option_bind (Xml.member "valueSet" xml)
                  InstanceInformationFilterValueSet.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "key"
                  ([], (InstanceInformationFilterKey.to_xml v.key)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "valueSet"
                      ([], (InstanceInformationFilterValueSet.to_xml [x]))))
              v.value_set))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("value_set",
                (InstanceInformationFilterValueSet.to_json v.value_set));
           Some ("key", (InstanceInformationFilterKey.to_json v.key))])
    let of_json j =
      {
        key =
          (InstanceInformationFilterKey.of_json
             (Util.of_option_exn (Json.lookup j "key")));
        value_set =
          (InstanceInformationFilterValueSet.of_json
             (Util.of_option_exn (Json.lookup j "value_set")))
      }
  end
module InstanceInformationStringFilter =
  struct
    type t = {
      key: String.t ;
      values: InstanceInformationFilterValueSet.t }
    let make ~key  ~values  () = { key; values }
    let parse xml =
      Some
        {
          key =
            (Xml.required "Key"
               (Util.option_bind (Xml.member "Key" xml) String.parse));
          values =
            (Xml.required "Values"
               (Util.option_bind (Xml.member "Values" xml)
                  InstanceInformationFilterValueSet.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Key" ([], (String.to_xml v.key)))]) @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Values"
                      ([], (InstanceInformationFilterValueSet.to_xml [x]))))
              v.values))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("values",
                (InstanceInformationFilterValueSet.to_json v.values));
           Some ("key", (String.to_json v.key))])
    let of_json j =
      {
        key = (String.of_json (Util.of_option_exn (Json.lookup j "key")));
        values =
          (InstanceInformationFilterValueSet.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module AttachmentInformationList =
  struct
    type t = AttachmentInformation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AttachmentInformation.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list AttachmentInformation.to_query v
    let to_headers v =
      Headers.to_headers_list AttachmentInformation.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (AttachmentInformation.to_xml x))) v
    let to_json v = `List (List.map AttachmentInformation.to_json v)
    let of_json j = Json.to_list AttachmentInformation.of_json j
  end
module DocumentParameterList =
  struct
    type t = DocumentParameter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DocumentParameter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list DocumentParameter.to_query v
    let to_headers v = Headers.to_headers_list DocumentParameter.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (DocumentParameter.to_xml x)))
        v
    let to_json v = `List (List.map DocumentParameter.to_json v)
    let of_json j = Json.to_list DocumentParameter.of_json j
  end
module InventoryGroupList =
  struct
    type t = InventoryGroup.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InventoryGroup.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InventoryGroup.to_query v
    let to_headers v = Headers.to_headers_list InventoryGroup.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InventoryGroup.to_xml x))) v
    let to_json v = `List (List.map InventoryGroup.to_json v)
    let of_json j = Json.to_list InventoryGroup.of_json j
  end
module ResultAttribute =
  struct
    type t = {
      type_name: String.t }
    let make ~type_name  () = { type_name }
    let parse xml =
      Some
        {
          type_name =
            (Xml.required "TypeName"
               (Util.option_bind (Xml.member "TypeName" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "TypeName" ([], (String.to_xml v.type_name)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("type_name", (String.to_json v.type_name))])
    let of_json j =
      {
        type_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "type_name")))
      }
  end
module ProgressCounters =
  struct
    type t =
      {
      total_steps: Integer.t option ;
      success_steps: Integer.t option ;
      failed_steps: Integer.t option ;
      cancelled_steps: Integer.t option ;
      timed_out_steps: Integer.t option }
    let make ?total_steps  ?success_steps  ?failed_steps  ?cancelled_steps 
      ?timed_out_steps  () =
      {
        total_steps;
        success_steps;
        failed_steps;
        cancelled_steps;
        timed_out_steps
      }
    let parse xml =
      Some
        {
          total_steps =
            (Util.option_bind (Xml.member "TotalSteps" xml) Integer.parse);
          success_steps =
            (Util.option_bind (Xml.member "SuccessSteps" xml) Integer.parse);
          failed_steps =
            (Util.option_bind (Xml.member "FailedSteps" xml) Integer.parse);
          cancelled_steps =
            (Util.option_bind (Xml.member "CancelledSteps" xml) Integer.parse);
          timed_out_steps =
            (Util.option_bind (Xml.member "TimedOutSteps" xml) Integer.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.total_steps
                  (fun f ->
                     Ezxmlm.make_tag "TotalSteps" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.success_steps
                 (fun f ->
                    Ezxmlm.make_tag "SuccessSteps" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.failed_steps
                (fun f ->
                   Ezxmlm.make_tag "FailedSteps" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.cancelled_steps
               (fun f ->
                  Ezxmlm.make_tag "CancelledSteps" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.timed_out_steps
              (fun f ->
                 Ezxmlm.make_tag "TimedOutSteps" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timed_out_steps
              (fun f -> ("timed_out_steps", (Integer.to_json f)));
           Util.option_map v.cancelled_steps
             (fun f -> ("cancelled_steps", (Integer.to_json f)));
           Util.option_map v.failed_steps
             (fun f -> ("failed_steps", (Integer.to_json f)));
           Util.option_map v.success_steps
             (fun f -> ("success_steps", (Integer.to_json f)));
           Util.option_map v.total_steps
             (fun f -> ("total_steps", (Integer.to_json f)))])
    let of_json j =
      {
        total_steps =
          (Util.option_map (Json.lookup j "total_steps") Integer.of_json);
        success_steps =
          (Util.option_map (Json.lookup j "success_steps") Integer.of_json);
        failed_steps =
          (Util.option_map (Json.lookup j "failed_steps") Integer.of_json);
        cancelled_steps =
          (Util.option_map (Json.lookup j "cancelled_steps") Integer.of_json);
        timed_out_steps =
          (Util.option_map (Json.lookup j "timed_out_steps") Integer.of_json)
      }
  end
module StepExecutionList =
  struct
    type t = StepExecution.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map StepExecution.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list StepExecution.to_query v
    let to_headers v = Headers.to_headers_list StepExecution.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (StepExecution.to_xml x))) v
    let to_json v = `List (List.map StepExecution.to_json v)
    let of_json j = Json.to_list StepExecution.of_json j
  end
module TargetLocations =
  struct
    type t = TargetLocation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TargetLocation.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list TargetLocation.to_query v
    let to_headers v = Headers.to_headers_list TargetLocation.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (TargetLocation.to_xml x))) v
    let to_json v = `List (List.map TargetLocation.to_json v)
    let of_json j = Json.to_list TargetLocation.of_json j
  end
module AssociationExecutionFilter =
  struct
    type t =
      {
      key: AssociationExecutionFilterKey.t ;
      value: String.t ;
      type_: AssociationFilterOperatorType.t }
    let make ~key  ~value  ~type_  () = { key; value; type_ }
    let parse xml =
      Some
        {
          key =
            (Xml.required "Key"
               (Util.option_bind (Xml.member "Key" xml)
                  AssociationExecutionFilterKey.parse));
          value =
            (Xml.required "Value"
               (Util.option_bind (Xml.member "Value" xml) String.parse));
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml)
                  AssociationFilterOperatorType.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "Key"
                   ([], (AssociationExecutionFilterKey.to_xml v.key)))])
            @ [Some (Ezxmlm.make_tag "Value" ([], (String.to_xml v.value)))])
           @
           [Some
              (Ezxmlm.make_tag "Type"
                 ([], (AssociationFilterOperatorType.to_xml v.type_)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("type_", (AssociationFilterOperatorType.to_json v.type_));
           Some ("value", (String.to_json v.value));
           Some ("key", (AssociationExecutionFilterKey.to_json v.key))])
    let of_json j =
      {
        key =
          (AssociationExecutionFilterKey.of_json
             (Util.of_option_exn (Json.lookup j "key")));
        value = (String.of_json (Util.of_option_exn (Json.lookup j "value")));
        type_ =
          (AssociationFilterOperatorType.of_json
             (Util.of_option_exn (Json.lookup j "type_")))
      }
  end
module OpsEntity =
  struct
    type t = {
      id: String.t option ;
      data: OpsEntityItemMap.t option }
    let make ?id  ?data  () = { id; data }
    let parse xml =
      Some
        {
          id = (Util.option_bind (Xml.member "Id" xml) String.parse);
          data =
            (Util.option_bind (Xml.member "Data" xml) OpsEntityItemMap.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.id
               (fun f -> Ezxmlm.make_tag "Id" ([], (String.to_xml f)))])
           @
           [Util.option_map v.data
              (fun f ->
                 Ezxmlm.make_tag "Data" ([], (OpsEntityItemMap.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.data
              (fun f -> ("data", (OpsEntityItemMap.to_json f)));
           Util.option_map v.id (fun f -> ("id", (String.to_json f)))])
    let of_json j =
      {
        id = (Util.option_map (Json.lookup j "id") String.of_json);
        data =
          (Util.option_map (Json.lookup j "data") OpsEntityItemMap.of_json)
      }
  end
module PatchOrchestratorFilter =
  struct
    type t = {
      key: String.t option ;
      values: PatchOrchestratorFilterValues.t }
    let make ?key  ?(values= [])  () = { key; values }
    let parse xml =
      Some
        {
          key = (Util.option_bind (Xml.member "Key" xml) String.parse);
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "Values" xml)
                  PatchOrchestratorFilterValues.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.key
               (fun f -> Ezxmlm.make_tag "Key" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Values"
                      ([], (PatchOrchestratorFilterValues.to_xml [x]))))
              v.values))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (PatchOrchestratorFilterValues.to_json v.values));
           Util.option_map v.key (fun f -> ("key", (String.to_json f)))])
    let of_json j =
      {
        key = (Util.option_map (Json.lookup j "key") String.of_json);
        values =
          (PatchOrchestratorFilterValues.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module PatchRuleList =
  struct
    type t = PatchRule.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map PatchRule.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list PatchRule.to_query v
    let to_headers v = Headers.to_headers_list PatchRule.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (PatchRule.to_xml x)))
        v
    let to_json v = `List (List.map PatchRule.to_json v)
    let of_json j = Json.to_list PatchRule.of_json j
  end
module PatchSource =
  struct
    type t =
      {
      name: String.t ;
      products: PatchSourceProductList.t ;
      configuration: String.t }
    let make ~name  ~products  ~configuration  () =
      { name; products; configuration }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          products =
            (Xml.required "Products"
               (Util.option_bind (Xml.member "Products" xml)
                  PatchSourceProductList.parse));
          configuration =
            (Xml.required "Configuration"
               (Util.option_bind (Xml.member "Configuration" xml)
                  String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Products"
                       ([], (PatchSourceProductList.to_xml [x])))) v.products))
           @
           [Some
              (Ezxmlm.make_tag "Configuration"
                 ([], (String.to_xml v.configuration)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("configuration", (String.to_json v.configuration));
           Some ("products", (PatchSourceProductList.to_json v.products));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        products =
          (PatchSourceProductList.of_json
             (Util.of_option_exn (Json.lookup j "products")));
        configuration =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "configuration")))
      }
  end
module Association =
  struct
    type t =
      {
      name: String.t option ;
      instance_id: String.t option ;
      association_id: String.t option ;
      association_version: String.t option ;
      document_version: String.t option ;
      targets: Targets.t ;
      last_execution_date: DateTime.t option ;
      overview: AssociationOverview.t option ;
      schedule_expression: String.t option ;
      association_name: String.t option }
    let make ?name  ?instance_id  ?association_id  ?association_version 
      ?document_version  ?(targets= [])  ?last_execution_date  ?overview 
      ?schedule_expression  ?association_name  () =
      {
        name;
        instance_id;
        association_id;
        association_version;
        document_version;
        targets;
        last_execution_date;
        overview;
        schedule_expression;
        association_name
      }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          association_id =
            (Util.option_bind (Xml.member "AssociationId" xml) String.parse);
          association_version =
            (Util.option_bind (Xml.member "AssociationVersion" xml)
               String.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          last_execution_date =
            (Util.option_bind (Xml.member "LastExecutionDate" xml)
               DateTime.parse);
          overview =
            (Util.option_bind (Xml.member "Overview" xml)
               AssociationOverview.parse);
          schedule_expression =
            (Util.option_bind (Xml.member "ScheduleExpression" xml)
               String.parse);
          association_name =
            (Util.option_bind (Xml.member "AssociationName" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.name
                       (fun f ->
                          Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.instance_id
                      (fun f ->
                         Ezxmlm.make_tag "InstanceId" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.association_id
                     (fun f ->
                        Ezxmlm.make_tag "AssociationId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.association_version
                    (fun f ->
                       Ezxmlm.make_tag "AssociationVersion"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.document_version
                   (fun f ->
                      Ezxmlm.make_tag "DocumentVersion"
                        ([], (String.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Targets" ([], (Targets.to_xml [x]))))
                  v.targets))
              @
              [Util.option_map v.last_execution_date
                 (fun f ->
                    Ezxmlm.make_tag "LastExecutionDate"
                      ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.overview
                (fun f ->
                   Ezxmlm.make_tag "Overview"
                     ([], (AssociationOverview.to_xml f)))])
            @
            [Util.option_map v.schedule_expression
               (fun f ->
                  Ezxmlm.make_tag "ScheduleExpression"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.association_name
              (fun f ->
                 Ezxmlm.make_tag "AssociationName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_name
              (fun f -> ("association_name", (String.to_json f)));
           Util.option_map v.schedule_expression
             (fun f -> ("schedule_expression", (String.to_json f)));
           Util.option_map v.overview
             (fun f -> ("overview", (AssociationOverview.to_json f)));
           Util.option_map v.last_execution_date
             (fun f -> ("last_execution_date", (DateTime.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.association_version
             (fun f -> ("association_version", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        association_version =
          (Util.option_map (Json.lookup j "association_version")
             String.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        last_execution_date =
          (Util.option_map (Json.lookup j "last_execution_date")
             DateTime.of_json);
        overview =
          (Util.option_map (Json.lookup j "overview")
             AssociationOverview.of_json);
        schedule_expression =
          (Util.option_map (Json.lookup j "schedule_expression")
             String.of_json);
        association_name =
          (Util.option_map (Json.lookup j "association_name") String.of_json)
      }
  end
module Session =
  struct
    type t =
      {
      session_id: String.t option ;
      target: String.t option ;
      status: SessionStatus.t option ;
      start_date: DateTime.t option ;
      end_date: DateTime.t option ;
      document_name: String.t option ;
      owner: String.t option ;
      details: String.t option ;
      output_url: SessionManagerOutputUrl.t option }
    let make ?session_id  ?target  ?status  ?start_date  ?end_date 
      ?document_name  ?owner  ?details  ?output_url  () =
      {
        session_id;
        target;
        status;
        start_date;
        end_date;
        document_name;
        owner;
        details;
        output_url
      }
    let parse xml =
      Some
        {
          session_id =
            (Util.option_bind (Xml.member "SessionId" xml) String.parse);
          target = (Util.option_bind (Xml.member "Target" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml) SessionStatus.parse);
          start_date =
            (Util.option_bind (Xml.member "StartDate" xml) DateTime.parse);
          end_date =
            (Util.option_bind (Xml.member "EndDate" xml) DateTime.parse);
          document_name =
            (Util.option_bind (Xml.member "DocumentName" xml) String.parse);
          owner = (Util.option_bind (Xml.member "Owner" xml) String.parse);
          details =
            (Util.option_bind (Xml.member "Details" xml) String.parse);
          output_url =
            (Util.option_bind (Xml.member "OutputUrl" xml)
               SessionManagerOutputUrl.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.session_id
                      (fun f ->
                         Ezxmlm.make_tag "SessionId" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.target
                     (fun f ->
                        Ezxmlm.make_tag "Target" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.status
                    (fun f ->
                       Ezxmlm.make_tag "Status"
                         ([], (SessionStatus.to_xml f)))])
                @
                [Util.option_map v.start_date
                   (fun f ->
                      Ezxmlm.make_tag "StartDate" ([], (DateTime.to_xml f)))])
               @
               [Util.option_map v.end_date
                  (fun f ->
                     Ezxmlm.make_tag "EndDate" ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.document_name
                 (fun f ->
                    Ezxmlm.make_tag "DocumentName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.owner
                (fun f -> Ezxmlm.make_tag "Owner" ([], (String.to_xml f)))])
            @
            [Util.option_map v.details
               (fun f -> Ezxmlm.make_tag "Details" ([], (String.to_xml f)))])
           @
           [Util.option_map v.output_url
              (fun f ->
                 Ezxmlm.make_tag "OutputUrl"
                   ([], (SessionManagerOutputUrl.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.output_url
              (fun f -> ("output_url", (SessionManagerOutputUrl.to_json f)));
           Util.option_map v.details
             (fun f -> ("details", (String.to_json f)));
           Util.option_map v.owner (fun f -> ("owner", (String.to_json f)));
           Util.option_map v.document_name
             (fun f -> ("document_name", (String.to_json f)));
           Util.option_map v.end_date
             (fun f -> ("end_date", (DateTime.to_json f)));
           Util.option_map v.start_date
             (fun f -> ("start_date", (DateTime.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (SessionStatus.to_json f)));
           Util.option_map v.target (fun f -> ("target", (String.to_json f)));
           Util.option_map v.session_id
             (fun f -> ("session_id", (String.to_json f)))])
    let of_json j =
      {
        session_id =
          (Util.option_map (Json.lookup j "session_id") String.of_json);
        target = (Util.option_map (Json.lookup j "target") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") SessionStatus.of_json);
        start_date =
          (Util.option_map (Json.lookup j "start_date") DateTime.of_json);
        end_date =
          (Util.option_map (Json.lookup j "end_date") DateTime.of_json);
        document_name =
          (Util.option_map (Json.lookup j "document_name") String.of_json);
        owner = (Util.option_map (Json.lookup j "owner") String.of_json);
        details = (Util.option_map (Json.lookup j "details") String.of_json);
        output_url =
          (Util.option_map (Json.lookup j "output_url")
             SessionManagerOutputUrl.of_json)
      }
  end
module Activation =
  struct
    type t =
      {
      activation_id: String.t option ;
      description: String.t option ;
      default_instance_name: String.t option ;
      iam_role: String.t option ;
      registration_limit: Integer.t option ;
      registrations_count: Integer.t option ;
      expiration_date: DateTime.t option ;
      expired: Boolean.t option ;
      created_date: DateTime.t option ;
      tags: TagList.t }
    let make ?activation_id  ?description  ?default_instance_name  ?iam_role 
      ?registration_limit  ?registrations_count  ?expiration_date  ?expired 
      ?created_date  ?(tags= [])  () =
      {
        activation_id;
        description;
        default_instance_name;
        iam_role;
        registration_limit;
        registrations_count;
        expiration_date;
        expired;
        created_date;
        tags
      }
    let parse xml =
      Some
        {
          activation_id =
            (Util.option_bind (Xml.member "ActivationId" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          default_instance_name =
            (Util.option_bind (Xml.member "DefaultInstanceName" xml)
               String.parse);
          iam_role =
            (Util.option_bind (Xml.member "IamRole" xml) String.parse);
          registration_limit =
            (Util.option_bind (Xml.member "RegistrationLimit" xml)
               Integer.parse);
          registrations_count =
            (Util.option_bind (Xml.member "RegistrationsCount" xml)
               Integer.parse);
          expiration_date =
            (Util.option_bind (Xml.member "ExpirationDate" xml)
               DateTime.parse);
          expired =
            (Util.option_bind (Xml.member "Expired" xml) Boolean.parse);
          created_date =
            (Util.option_bind (Xml.member "CreatedDate" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tags" xml) TagList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.activation_id
                       (fun f ->
                          Ezxmlm.make_tag "ActivationId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.description
                      (fun f ->
                         Ezxmlm.make_tag "Description"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.default_instance_name
                     (fun f ->
                        Ezxmlm.make_tag "DefaultInstanceName"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.iam_role
                    (fun f ->
                       Ezxmlm.make_tag "IamRole" ([], (String.to_xml f)))])
                @
                [Util.option_map v.registration_limit
                   (fun f ->
                      Ezxmlm.make_tag "RegistrationLimit"
                        ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.registrations_count
                  (fun f ->
                     Ezxmlm.make_tag "RegistrationsCount"
                       ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.expiration_date
                 (fun f ->
                    Ezxmlm.make_tag "ExpirationDate"
                      ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.expired
                (fun f -> Ezxmlm.make_tag "Expired" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.created_date
               (fun f ->
                  Ezxmlm.make_tag "CreatedDate" ([], (DateTime.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "Tags" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.created_date
             (fun f -> ("created_date", (DateTime.to_json f)));
           Util.option_map v.expired
             (fun f -> ("expired", (Boolean.to_json f)));
           Util.option_map v.expiration_date
             (fun f -> ("expiration_date", (DateTime.to_json f)));
           Util.option_map v.registrations_count
             (fun f -> ("registrations_count", (Integer.to_json f)));
           Util.option_map v.registration_limit
             (fun f -> ("registration_limit", (Integer.to_json f)));
           Util.option_map v.iam_role
             (fun f -> ("iam_role", (String.to_json f)));
           Util.option_map v.default_instance_name
             (fun f -> ("default_instance_name", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.activation_id
             (fun f -> ("activation_id", (String.to_json f)))])
    let of_json j =
      {
        activation_id =
          (Util.option_map (Json.lookup j "activation_id") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        default_instance_name =
          (Util.option_map (Json.lookup j "default_instance_name")
             String.of_json);
        iam_role =
          (Util.option_map (Json.lookup j "iam_role") String.of_json);
        registration_limit =
          (Util.option_map (Json.lookup j "registration_limit")
             Integer.of_json);
        registrations_count =
          (Util.option_map (Json.lookup j "registrations_count")
             Integer.of_json);
        expiration_date =
          (Util.option_map (Json.lookup j "expiration_date") DateTime.of_json);
        expired = (Util.option_map (Json.lookup j "expired") Boolean.of_json);
        created_date =
          (Util.option_map (Json.lookup j "created_date") DateTime.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ComplianceItem =
  struct
    type t =
      {
      compliance_type: String.t option ;
      resource_type: String.t option ;
      resource_id: String.t option ;
      id: String.t option ;
      title: String.t option ;
      status: ComplianceStatus.t option ;
      severity: ComplianceSeverity.t option ;
      execution_summary: ComplianceExecutionSummary.t option ;
      details: ComplianceItemDetails.t option }
    let make ?compliance_type  ?resource_type  ?resource_id  ?id  ?title 
      ?status  ?severity  ?execution_summary  ?details  () =
      {
        compliance_type;
        resource_type;
        resource_id;
        id;
        title;
        status;
        severity;
        execution_summary;
        details
      }
    let parse xml =
      Some
        {
          compliance_type =
            (Util.option_bind (Xml.member "ComplianceType" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "ResourceType" xml) String.parse);
          resource_id =
            (Util.option_bind (Xml.member "ResourceId" xml) String.parse);
          id = (Util.option_bind (Xml.member "Id" xml) String.parse);
          title = (Util.option_bind (Xml.member "Title" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml)
               ComplianceStatus.parse);
          severity =
            (Util.option_bind (Xml.member "Severity" xml)
               ComplianceSeverity.parse);
          execution_summary =
            (Util.option_bind (Xml.member "ExecutionSummary" xml)
               ComplianceExecutionSummary.parse);
          details =
            (Util.option_bind (Xml.member "Details" xml)
               ComplianceItemDetails.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.compliance_type
                      (fun f ->
                         Ezxmlm.make_tag "ComplianceType"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.resource_type
                     (fun f ->
                        Ezxmlm.make_tag "ResourceType"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.resource_id
                    (fun f ->
                       Ezxmlm.make_tag "ResourceId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.id
                   (fun f -> Ezxmlm.make_tag "Id" ([], (String.to_xml f)))])
               @
               [Util.option_map v.title
                  (fun f -> Ezxmlm.make_tag "Title" ([], (String.to_xml f)))])
              @
              [Util.option_map v.status
                 (fun f ->
                    Ezxmlm.make_tag "Status"
                      ([], (ComplianceStatus.to_xml f)))])
             @
             [Util.option_map v.severity
                (fun f ->
                   Ezxmlm.make_tag "Severity"
                     ([], (ComplianceSeverity.to_xml f)))])
            @
            [Util.option_map v.execution_summary
               (fun f ->
                  Ezxmlm.make_tag "ExecutionSummary"
                    ([], (ComplianceExecutionSummary.to_xml f)))])
           @
           [Util.option_map v.details
              (fun f ->
                 Ezxmlm.make_tag "Details"
                   ([], (ComplianceItemDetails.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.details
              (fun f -> ("details", (ComplianceItemDetails.to_json f)));
           Util.option_map v.execution_summary
             (fun f ->
                ("execution_summary", (ComplianceExecutionSummary.to_json f)));
           Util.option_map v.severity
             (fun f -> ("severity", (ComplianceSeverity.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ComplianceStatus.to_json f)));
           Util.option_map v.title (fun f -> ("title", (String.to_json f)));
           Util.option_map v.id (fun f -> ("id", (String.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.resource_type
             (fun f -> ("resource_type", (String.to_json f)));
           Util.option_map v.compliance_type
             (fun f -> ("compliance_type", (String.to_json f)))])
    let of_json j =
      {
        compliance_type =
          (Util.option_map (Json.lookup j "compliance_type") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type") String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        id = (Util.option_map (Json.lookup j "id") String.of_json);
        title = (Util.option_map (Json.lookup j "title") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") ComplianceStatus.of_json);
        severity =
          (Util.option_map (Json.lookup j "severity")
             ComplianceSeverity.of_json);
        execution_summary =
          (Util.option_map (Json.lookup j "execution_summary")
             ComplianceExecutionSummary.of_json);
        details =
          (Util.option_map (Json.lookup j "details")
             ComplianceItemDetails.of_json)
      }
  end
module MaintenanceWindowTask =
  struct
    type t =
      {
      window_id: String.t option ;
      window_task_id: String.t option ;
      task_arn: String.t option ;
      type_: MaintenanceWindowTaskType.t option ;
      targets: Targets.t ;
      task_parameters: MaintenanceWindowTaskParameters.t option ;
      priority: Integer.t option ;
      logging_info: LoggingInfo.t option ;
      service_role_arn: String.t option ;
      max_concurrency: String.t option ;
      max_errors: String.t option ;
      name: String.t option ;
      description: String.t option }
    let make ?window_id  ?window_task_id  ?task_arn  ?type_  ?(targets= []) 
      ?task_parameters  ?priority  ?logging_info  ?service_role_arn 
      ?max_concurrency  ?max_errors  ?name  ?description  () =
      {
        window_id;
        window_task_id;
        task_arn;
        type_;
        targets;
        task_parameters;
        priority;
        logging_info;
        service_role_arn;
        max_concurrency;
        max_errors;
        name;
        description
      }
    let parse xml =
      Some
        {
          window_id =
            (Util.option_bind (Xml.member "WindowId" xml) String.parse);
          window_task_id =
            (Util.option_bind (Xml.member "WindowTaskId" xml) String.parse);
          task_arn =
            (Util.option_bind (Xml.member "TaskArn" xml) String.parse);
          type_ =
            (Util.option_bind (Xml.member "Type" xml)
               MaintenanceWindowTaskType.parse);
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          task_parameters =
            (Util.option_bind (Xml.member "TaskParameters" xml)
               MaintenanceWindowTaskParameters.parse);
          priority =
            (Util.option_bind (Xml.member "Priority" xml) Integer.parse);
          logging_info =
            (Util.option_bind (Xml.member "LoggingInfo" xml)
               LoggingInfo.parse);
          service_role_arn =
            (Util.option_bind (Xml.member "ServiceRoleArn" xml) String.parse);
          max_concurrency =
            (Util.option_bind (Xml.member "MaxConcurrency" xml) String.parse);
          max_errors =
            (Util.option_bind (Xml.member "MaxErrors" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.window_id
                          (fun f ->
                             Ezxmlm.make_tag "WindowId"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.window_task_id
                         (fun f ->
                            Ezxmlm.make_tag "WindowTaskId"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.task_arn
                        (fun f ->
                           Ezxmlm.make_tag "TaskArn" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.type_
                       (fun f ->
                          Ezxmlm.make_tag "Type"
                            ([], (MaintenanceWindowTaskType.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "Targets"
                              ([], (Targets.to_xml [x])))) v.targets))
                  @
                  [Util.option_map v.task_parameters
                     (fun f ->
                        Ezxmlm.make_tag "TaskParameters"
                          ([], (MaintenanceWindowTaskParameters.to_xml f)))])
                 @
                 [Util.option_map v.priority
                    (fun f ->
                       Ezxmlm.make_tag "Priority" ([], (Integer.to_xml f)))])
                @
                [Util.option_map v.logging_info
                   (fun f ->
                      Ezxmlm.make_tag "LoggingInfo"
                        ([], (LoggingInfo.to_xml f)))])
               @
               [Util.option_map v.service_role_arn
                  (fun f ->
                     Ezxmlm.make_tag "ServiceRoleArn" ([], (String.to_xml f)))])
              @
              [Util.option_map v.max_concurrency
                 (fun f ->
                    Ezxmlm.make_tag "MaxConcurrency" ([], (String.to_xml f)))])
             @
             [Util.option_map v.max_errors
                (fun f -> Ezxmlm.make_tag "MaxErrors" ([], (String.to_xml f)))])
            @
            [Util.option_map v.name
               (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
           @
           [Util.option_map v.description
              (fun f -> Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.max_errors
             (fun f -> ("max_errors", (String.to_json f)));
           Util.option_map v.max_concurrency
             (fun f -> ("max_concurrency", (String.to_json f)));
           Util.option_map v.service_role_arn
             (fun f -> ("service_role_arn", (String.to_json f)));
           Util.option_map v.logging_info
             (fun f -> ("logging_info", (LoggingInfo.to_json f)));
           Util.option_map v.priority
             (fun f -> ("priority", (Integer.to_json f)));
           Util.option_map v.task_parameters
             (fun f ->
                ("task_parameters",
                  (MaintenanceWindowTaskParameters.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Util.option_map v.type_
             (fun f -> ("type_", (MaintenanceWindowTaskType.to_json f)));
           Util.option_map v.task_arn
             (fun f -> ("task_arn", (String.to_json f)));
           Util.option_map v.window_task_id
             (fun f -> ("window_task_id", (String.to_json f)));
           Util.option_map v.window_id
             (fun f -> ("window_id", (String.to_json f)))])
    let of_json j =
      {
        window_id =
          (Util.option_map (Json.lookup j "window_id") String.of_json);
        window_task_id =
          (Util.option_map (Json.lookup j "window_task_id") String.of_json);
        task_arn =
          (Util.option_map (Json.lookup j "task_arn") String.of_json);
        type_ =
          (Util.option_map (Json.lookup j "type_")
             MaintenanceWindowTaskType.of_json);
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        task_parameters =
          (Util.option_map (Json.lookup j "task_parameters")
             MaintenanceWindowTaskParameters.of_json);
        priority =
          (Util.option_map (Json.lookup j "priority") Integer.of_json);
        logging_info =
          (Util.option_map (Json.lookup j "logging_info") LoggingInfo.of_json);
        service_role_arn =
          (Util.option_map (Json.lookup j "service_role_arn") String.of_json);
        max_concurrency =
          (Util.option_map (Json.lookup j "max_concurrency") String.of_json);
        max_errors =
          (Util.option_map (Json.lookup j "max_errors") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module CommandFilter =
  struct
    type t = {
      key: CommandFilterKey.t ;
      value: String.t }
    let make ~key  ~value  () = { key; value }
    let parse xml =
      Some
        {
          key =
            (Xml.required "key"
               (Util.option_bind (Xml.member "key" xml)
                  CommandFilterKey.parse));
          value =
            (Xml.required "value"
               (Util.option_bind (Xml.member "value" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "key" ([], (CommandFilterKey.to_xml v.key)))])
           @ [Some (Ezxmlm.make_tag "value" ([], (String.to_xml v.value)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("value", (String.to_json v.value));
           Some ("key", (CommandFilterKey.to_json v.key))])
    let of_json j =
      {
        key =
          (CommandFilterKey.of_json
             (Util.of_option_exn (Json.lookup j "key")));
        value = (String.of_json (Util.of_option_exn (Json.lookup j "value")))
      }
  end
module InventoryResultEntity =
  struct
    type t = {
      id: String.t option ;
      data: InventoryResultItemMap.t option }
    let make ?id  ?data  () = { id; data }
    let parse xml =
      Some
        {
          id = (Util.option_bind (Xml.member "Id" xml) String.parse);
          data =
            (Util.option_bind (Xml.member "Data" xml)
               InventoryResultItemMap.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.id
               (fun f -> Ezxmlm.make_tag "Id" ([], (String.to_xml f)))])
           @
           [Util.option_map v.data
              (fun f ->
                 Ezxmlm.make_tag "Data"
                   ([], (InventoryResultItemMap.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.data
              (fun f -> ("data", (InventoryResultItemMap.to_json f)));
           Util.option_map v.id (fun f -> ("id", (String.to_json f)))])
    let of_json j =
      {
        id = (Util.option_map (Json.lookup j "id") String.of_json);
        data =
          (Util.option_map (Json.lookup j "data")
             InventoryResultItemMap.of_json)
      }
  end
module InstanceAssociation =
  struct
    type t =
      {
      association_id: String.t option ;
      instance_id: String.t option ;
      content: String.t option ;
      association_version: String.t option }
    let make ?association_id  ?instance_id  ?content  ?association_version 
      () = { association_id; instance_id; content; association_version }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "AssociationId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          content =
            (Util.option_bind (Xml.member "Content" xml) String.parse);
          association_version =
            (Util.option_bind (Xml.member "AssociationVersion" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.association_id
                 (fun f ->
                    Ezxmlm.make_tag "AssociationId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.instance_id
                (fun f ->
                   Ezxmlm.make_tag "InstanceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.content
               (fun f -> Ezxmlm.make_tag "Content" ([], (String.to_xml f)))])
           @
           [Util.option_map v.association_version
              (fun f ->
                 Ezxmlm.make_tag "AssociationVersion" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_version
              (fun f -> ("association_version", (String.to_json f)));
           Util.option_map v.content
             (fun f -> ("content", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        content = (Util.option_map (Json.lookup j "content") String.of_json);
        association_version =
          (Util.option_map (Json.lookup j "association_version")
             String.of_json)
      }
  end
module PatchPropertyEntry =
  struct
    type t = (String.t, String.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string String.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc -> ((String.to_string k), (String.to_json v)) :: acc)
           v [])
    let of_json j = Json.to_hashtbl String.of_string String.of_json j
  end
module MaintenanceWindowFilter =
  struct
    type t = {
      key: String.t option ;
      values: MaintenanceWindowFilterValues.t }
    let make ?key  ?(values= [])  () = { key; values }
    let parse xml =
      Some
        {
          key = (Util.option_bind (Xml.member "Key" xml) String.parse);
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "Values" xml)
                  MaintenanceWindowFilterValues.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.key
               (fun f -> Ezxmlm.make_tag "Key" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Values"
                      ([], (MaintenanceWindowFilterValues.to_xml [x]))))
              v.values))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (MaintenanceWindowFilterValues.to_json v.values));
           Util.option_map v.key (fun f -> ("key", (String.to_json f)))])
    let of_json j =
      {
        key = (Util.option_map (Json.lookup j "key") String.of_json);
        values =
          (MaintenanceWindowFilterValues.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module ResourceComplianceSummaryItem =
  struct
    type t =
      {
      compliance_type: String.t option ;
      resource_type: String.t option ;
      resource_id: String.t option ;
      status: ComplianceStatus.t option ;
      overall_severity: ComplianceSeverity.t option ;
      execution_summary: ComplianceExecutionSummary.t option ;
      compliant_summary: CompliantSummary.t option ;
      non_compliant_summary: NonCompliantSummary.t option }
    let make ?compliance_type  ?resource_type  ?resource_id  ?status 
      ?overall_severity  ?execution_summary  ?compliant_summary 
      ?non_compliant_summary  () =
      {
        compliance_type;
        resource_type;
        resource_id;
        status;
        overall_severity;
        execution_summary;
        compliant_summary;
        non_compliant_summary
      }
    let parse xml =
      Some
        {
          compliance_type =
            (Util.option_bind (Xml.member "ComplianceType" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "ResourceType" xml) String.parse);
          resource_id =
            (Util.option_bind (Xml.member "ResourceId" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml)
               ComplianceStatus.parse);
          overall_severity =
            (Util.option_bind (Xml.member "OverallSeverity" xml)
               ComplianceSeverity.parse);
          execution_summary =
            (Util.option_bind (Xml.member "ExecutionSummary" xml)
               ComplianceExecutionSummary.parse);
          compliant_summary =
            (Util.option_bind (Xml.member "CompliantSummary" xml)
               CompliantSummary.parse);
          non_compliant_summary =
            (Util.option_bind (Xml.member "NonCompliantSummary" xml)
               NonCompliantSummary.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.compliance_type
                     (fun f ->
                        Ezxmlm.make_tag "ComplianceType"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.resource_type
                    (fun f ->
                       Ezxmlm.make_tag "ResourceType" ([], (String.to_xml f)))])
                @
                [Util.option_map v.resource_id
                   (fun f ->
                      Ezxmlm.make_tag "ResourceId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.status
                  (fun f ->
                     Ezxmlm.make_tag "Status"
                       ([], (ComplianceStatus.to_xml f)))])
              @
              [Util.option_map v.overall_severity
                 (fun f ->
                    Ezxmlm.make_tag "OverallSeverity"
                      ([], (ComplianceSeverity.to_xml f)))])
             @
             [Util.option_map v.execution_summary
                (fun f ->
                   Ezxmlm.make_tag "ExecutionSummary"
                     ([], (ComplianceExecutionSummary.to_xml f)))])
            @
            [Util.option_map v.compliant_summary
               (fun f ->
                  Ezxmlm.make_tag "CompliantSummary"
                    ([], (CompliantSummary.to_xml f)))])
           @
           [Util.option_map v.non_compliant_summary
              (fun f ->
                 Ezxmlm.make_tag "NonCompliantSummary"
                   ([], (NonCompliantSummary.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.non_compliant_summary
              (fun f ->
                 ("non_compliant_summary", (NonCompliantSummary.to_json f)));
           Util.option_map v.compliant_summary
             (fun f -> ("compliant_summary", (CompliantSummary.to_json f)));
           Util.option_map v.execution_summary
             (fun f ->
                ("execution_summary", (ComplianceExecutionSummary.to_json f)));
           Util.option_map v.overall_severity
             (fun f -> ("overall_severity", (ComplianceSeverity.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ComplianceStatus.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.resource_type
             (fun f -> ("resource_type", (String.to_json f)));
           Util.option_map v.compliance_type
             (fun f -> ("compliance_type", (String.to_json f)))])
    let of_json j =
      {
        compliance_type =
          (Util.option_map (Json.lookup j "compliance_type") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type") String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") ComplianceStatus.of_json);
        overall_severity =
          (Util.option_map (Json.lookup j "overall_severity")
             ComplianceSeverity.of_json);
        execution_summary =
          (Util.option_map (Json.lookup j "execution_summary")
             ComplianceExecutionSummary.of_json);
        compliant_summary =
          (Util.option_map (Json.lookup j "compliant_summary")
             CompliantSummary.of_json);
        non_compliant_summary =
          (Util.option_map (Json.lookup j "non_compliant_summary")
             NonCompliantSummary.of_json)
      }
  end
module InstancePatchStateFilter =
  struct
    type t =
      {
      key: String.t ;
      values: InstancePatchStateFilterValues.t ;
      type_: InstancePatchStateOperatorType.t }
    let make ~key  ~values  ~type_  () = { key; values; type_ }
    let parse xml =
      Some
        {
          key =
            (Xml.required "Key"
               (Util.option_bind (Xml.member "Key" xml) String.parse));
          values =
            (Xml.required "Values"
               (Util.option_bind (Xml.member "Values" xml)
                  InstancePatchStateFilterValues.parse));
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml)
                  InstancePatchStateOperatorType.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @ [Some (Ezxmlm.make_tag "Key" ([], (String.to_xml v.key)))]) @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Values"
                       ([], (InstancePatchStateFilterValues.to_xml [x]))))
               v.values))
           @
           [Some
              (Ezxmlm.make_tag "Type"
                 ([], (InstancePatchStateOperatorType.to_xml v.type_)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("type_", (InstancePatchStateOperatorType.to_json v.type_));
           Some ("values", (InstancePatchStateFilterValues.to_json v.values));
           Some ("key", (String.to_json v.key))])
    let of_json j =
      {
        key = (String.of_json (Util.of_option_exn (Json.lookup j "key")));
        values =
          (InstancePatchStateFilterValues.of_json
             (Util.of_option_exn (Json.lookup j "values")));
        type_ =
          (InstancePatchStateOperatorType.of_json
             (Util.of_option_exn (Json.lookup j "type_")))
      }
  end
module AssociationExecutionTarget =
  struct
    type t =
      {
      association_id: String.t option ;
      association_version: String.t option ;
      execution_id: String.t option ;
      resource_id: String.t option ;
      resource_type: String.t option ;
      status: String.t option ;
      detailed_status: String.t option ;
      last_execution_date: DateTime.t option ;
      output_source: OutputSource.t option }
    let make ?association_id  ?association_version  ?execution_id 
      ?resource_id  ?resource_type  ?status  ?detailed_status 
      ?last_execution_date  ?output_source  () =
      {
        association_id;
        association_version;
        execution_id;
        resource_id;
        resource_type;
        status;
        detailed_status;
        last_execution_date;
        output_source
      }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "AssociationId" xml) String.parse);
          association_version =
            (Util.option_bind (Xml.member "AssociationVersion" xml)
               String.parse);
          execution_id =
            (Util.option_bind (Xml.member "ExecutionId" xml) String.parse);
          resource_id =
            (Util.option_bind (Xml.member "ResourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "ResourceType" xml) String.parse);
          status = (Util.option_bind (Xml.member "Status" xml) String.parse);
          detailed_status =
            (Util.option_bind (Xml.member "DetailedStatus" xml) String.parse);
          last_execution_date =
            (Util.option_bind (Xml.member "LastExecutionDate" xml)
               DateTime.parse);
          output_source =
            (Util.option_bind (Xml.member "OutputSource" xml)
               OutputSource.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.association_id
                      (fun f ->
                         Ezxmlm.make_tag "AssociationId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.association_version
                     (fun f ->
                        Ezxmlm.make_tag "AssociationVersion"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.execution_id
                    (fun f ->
                       Ezxmlm.make_tag "ExecutionId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.resource_id
                   (fun f ->
                      Ezxmlm.make_tag "ResourceId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.resource_type
                  (fun f ->
                     Ezxmlm.make_tag "ResourceType" ([], (String.to_xml f)))])
              @
              [Util.option_map v.status
                 (fun f -> Ezxmlm.make_tag "Status" ([], (String.to_xml f)))])
             @
             [Util.option_map v.detailed_status
                (fun f ->
                   Ezxmlm.make_tag "DetailedStatus" ([], (String.to_xml f)))])
            @
            [Util.option_map v.last_execution_date
               (fun f ->
                  Ezxmlm.make_tag "LastExecutionDate"
                    ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.output_source
              (fun f ->
                 Ezxmlm.make_tag "OutputSource" ([], (OutputSource.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.output_source
              (fun f -> ("output_source", (OutputSource.to_json f)));
           Util.option_map v.last_execution_date
             (fun f -> ("last_execution_date", (DateTime.to_json f)));
           Util.option_map v.detailed_status
             (fun f -> ("detailed_status", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.resource_type
             (fun f -> ("resource_type", (String.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.execution_id
             (fun f -> ("execution_id", (String.to_json f)));
           Util.option_map v.association_version
             (fun f -> ("association_version", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        association_version =
          (Util.option_map (Json.lookup j "association_version")
             String.of_json);
        execution_id =
          (Util.option_map (Json.lookup j "execution_id") String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type") String.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        detailed_status =
          (Util.option_map (Json.lookup j "detailed_status") String.of_json);
        last_execution_date =
          (Util.option_map (Json.lookup j "last_execution_date")
             DateTime.of_json);
        output_source =
          (Util.option_map (Json.lookup j "output_source")
             OutputSource.of_json)
      }
  end
module AssociationExecution =
  struct
    type t =
      {
      association_id: String.t option ;
      association_version: String.t option ;
      execution_id: String.t option ;
      status: String.t option ;
      detailed_status: String.t option ;
      created_time: DateTime.t option ;
      last_execution_date: DateTime.t option ;
      resource_count_by_status: String.t option }
    let make ?association_id  ?association_version  ?execution_id  ?status 
      ?detailed_status  ?created_time  ?last_execution_date 
      ?resource_count_by_status  () =
      {
        association_id;
        association_version;
        execution_id;
        status;
        detailed_status;
        created_time;
        last_execution_date;
        resource_count_by_status
      }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "AssociationId" xml) String.parse);
          association_version =
            (Util.option_bind (Xml.member "AssociationVersion" xml)
               String.parse);
          execution_id =
            (Util.option_bind (Xml.member "ExecutionId" xml) String.parse);
          status = (Util.option_bind (Xml.member "Status" xml) String.parse);
          detailed_status =
            (Util.option_bind (Xml.member "DetailedStatus" xml) String.parse);
          created_time =
            (Util.option_bind (Xml.member "CreatedTime" xml) DateTime.parse);
          last_execution_date =
            (Util.option_bind (Xml.member "LastExecutionDate" xml)
               DateTime.parse);
          resource_count_by_status =
            (Util.option_bind (Xml.member "ResourceCountByStatus" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.association_id
                     (fun f ->
                        Ezxmlm.make_tag "AssociationId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.association_version
                    (fun f ->
                       Ezxmlm.make_tag "AssociationVersion"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.execution_id
                   (fun f ->
                      Ezxmlm.make_tag "ExecutionId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.status
                  (fun f -> Ezxmlm.make_tag "Status" ([], (String.to_xml f)))])
              @
              [Util.option_map v.detailed_status
                 (fun f ->
                    Ezxmlm.make_tag "DetailedStatus" ([], (String.to_xml f)))])
             @
             [Util.option_map v.created_time
                (fun f ->
                   Ezxmlm.make_tag "CreatedTime" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.last_execution_date
               (fun f ->
                  Ezxmlm.make_tag "LastExecutionDate"
                    ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.resource_count_by_status
              (fun f ->
                 Ezxmlm.make_tag "ResourceCountByStatus"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.resource_count_by_status
              (fun f -> ("resource_count_by_status", (String.to_json f)));
           Util.option_map v.last_execution_date
             (fun f -> ("last_execution_date", (DateTime.to_json f)));
           Util.option_map v.created_time
             (fun f -> ("created_time", (DateTime.to_json f)));
           Util.option_map v.detailed_status
             (fun f -> ("detailed_status", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.execution_id
             (fun f -> ("execution_id", (String.to_json f)));
           Util.option_map v.association_version
             (fun f -> ("association_version", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        association_version =
          (Util.option_map (Json.lookup j "association_version")
             String.of_json);
        execution_id =
          (Util.option_map (Json.lookup j "execution_id") String.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        detailed_status =
          (Util.option_map (Json.lookup j "detailed_status") String.of_json);
        created_time =
          (Util.option_map (Json.lookup j "created_time") DateTime.of_json);
        last_execution_date =
          (Util.option_map (Json.lookup j "last_execution_date")
             DateTime.of_json);
        resource_count_by_status =
          (Util.option_map (Json.lookup j "resource_count_by_status")
             String.of_json)
      }
  end
module Parameter =
  struct
    type t =
      {
      name: String.t option ;
      type_: ParameterType.t option ;
      value: String.t option ;
      version: Long.t option ;
      selector: String.t option ;
      source_result: String.t option ;
      last_modified_date: DateTime.t option ;
      a_r_n: String.t option }
    let make ?name  ?type_  ?value  ?version  ?selector  ?source_result 
      ?last_modified_date  ?a_r_n  () =
      {
        name;
        type_;
        value;
        version;
        selector;
        source_result;
        last_modified_date;
        a_r_n
      }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          type_ =
            (Util.option_bind (Xml.member "Type" xml) ParameterType.parse);
          value = (Util.option_bind (Xml.member "Value" xml) String.parse);
          version = (Util.option_bind (Xml.member "Version" xml) Long.parse);
          selector =
            (Util.option_bind (Xml.member "Selector" xml) String.parse);
          source_result =
            (Util.option_bind (Xml.member "SourceResult" xml) String.parse);
          last_modified_date =
            (Util.option_bind (Xml.member "LastModifiedDate" xml)
               DateTime.parse);
          a_r_n = (Util.option_bind (Xml.member "ARN" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.name
                     (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.type_
                    (fun f ->
                       Ezxmlm.make_tag "Type" ([], (ParameterType.to_xml f)))])
                @
                [Util.option_map v.value
                   (fun f -> Ezxmlm.make_tag "Value" ([], (String.to_xml f)))])
               @
               [Util.option_map v.version
                  (fun f -> Ezxmlm.make_tag "Version" ([], (Long.to_xml f)))])
              @
              [Util.option_map v.selector
                 (fun f -> Ezxmlm.make_tag "Selector" ([], (String.to_xml f)))])
             @
             [Util.option_map v.source_result
                (fun f ->
                   Ezxmlm.make_tag "SourceResult" ([], (String.to_xml f)))])
            @
            [Util.option_map v.last_modified_date
               (fun f ->
                  Ezxmlm.make_tag "LastModifiedDate"
                    ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.a_r_n
              (fun f -> Ezxmlm.make_tag "ARN" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.a_r_n (fun f -> ("a_r_n", (String.to_json f)));
           Util.option_map v.last_modified_date
             (fun f -> ("last_modified_date", (DateTime.to_json f)));
           Util.option_map v.source_result
             (fun f -> ("source_result", (String.to_json f)));
           Util.option_map v.selector
             (fun f -> ("selector", (String.to_json f)));
           Util.option_map v.version (fun f -> ("version", (Long.to_json f)));
           Util.option_map v.value (fun f -> ("value", (String.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (ParameterType.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        type_ =
          (Util.option_map (Json.lookup j "type_") ParameterType.of_json);
        value = (Util.option_map (Json.lookup j "value") String.of_json);
        version = (Util.option_map (Json.lookup j "version") Long.of_json);
        selector =
          (Util.option_map (Json.lookup j "selector") String.of_json);
        source_result =
          (Util.option_map (Json.lookup j "source_result") String.of_json);
        last_modified_date =
          (Util.option_map (Json.lookup j "last_modified_date")
             DateTime.of_json);
        a_r_n = (Util.option_map (Json.lookup j "a_r_n") String.of_json)
      }
  end
module InstancePatchState =
  struct
    type t =
      {
      instance_id: String.t ;
      patch_group: String.t ;
      baseline_id: String.t ;
      snapshot_id: String.t option ;
      install_override_list: String.t option ;
      owner_information: String.t option ;
      installed_count: Integer.t option ;
      installed_other_count: Integer.t option ;
      installed_pending_reboot_count: Integer.t option ;
      installed_rejected_count: Integer.t option ;
      missing_count: Integer.t option ;
      failed_count: Integer.t option ;
      unreported_not_applicable_count: Integer.t option ;
      not_applicable_count: Integer.t option ;
      operation_start_time: DateTime.t ;
      operation_end_time: DateTime.t ;
      operation: PatchOperationType.t ;
      last_no_reboot_install_operation_time: DateTime.t option ;
      reboot_option: RebootOption.t option }
    let make ~instance_id  ~patch_group  ~baseline_id  ?snapshot_id 
      ?install_override_list  ?owner_information  ?installed_count 
      ?installed_other_count  ?installed_pending_reboot_count 
      ?installed_rejected_count  ?missing_count  ?failed_count 
      ?unreported_not_applicable_count  ?not_applicable_count 
      ~operation_start_time  ~operation_end_time  ~operation 
      ?last_no_reboot_install_operation_time  ?reboot_option  () =
      {
        instance_id;
        patch_group;
        baseline_id;
        snapshot_id;
        install_override_list;
        owner_information;
        installed_count;
        installed_other_count;
        installed_pending_reboot_count;
        installed_rejected_count;
        missing_count;
        failed_count;
        unreported_not_applicable_count;
        not_applicable_count;
        operation_start_time;
        operation_end_time;
        operation;
        last_no_reboot_install_operation_time;
        reboot_option
      }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          patch_group =
            (Xml.required "PatchGroup"
               (Util.option_bind (Xml.member "PatchGroup" xml) String.parse));
          baseline_id =
            (Xml.required "BaselineId"
               (Util.option_bind (Xml.member "BaselineId" xml) String.parse));
          snapshot_id =
            (Util.option_bind (Xml.member "SnapshotId" xml) String.parse);
          install_override_list =
            (Util.option_bind (Xml.member "InstallOverrideList" xml)
               String.parse);
          owner_information =
            (Util.option_bind (Xml.member "OwnerInformation" xml)
               String.parse);
          installed_count =
            (Util.option_bind (Xml.member "InstalledCount" xml) Integer.parse);
          installed_other_count =
            (Util.option_bind (Xml.member "InstalledOtherCount" xml)
               Integer.parse);
          installed_pending_reboot_count =
            (Util.option_bind (Xml.member "InstalledPendingRebootCount" xml)
               Integer.parse);
          installed_rejected_count =
            (Util.option_bind (Xml.member "InstalledRejectedCount" xml)
               Integer.parse);
          missing_count =
            (Util.option_bind (Xml.member "MissingCount" xml) Integer.parse);
          failed_count =
            (Util.option_bind (Xml.member "FailedCount" xml) Integer.parse);
          unreported_not_applicable_count =
            (Util.option_bind (Xml.member "UnreportedNotApplicableCount" xml)
               Integer.parse);
          not_applicable_count =
            (Util.option_bind (Xml.member "NotApplicableCount" xml)
               Integer.parse);
          operation_start_time =
            (Xml.required "OperationStartTime"
               (Util.option_bind (Xml.member "OperationStartTime" xml)
                  DateTime.parse));
          operation_end_time =
            (Xml.required "OperationEndTime"
               (Util.option_bind (Xml.member "OperationEndTime" xml)
                  DateTime.parse));
          operation =
            (Xml.required "Operation"
               (Util.option_bind (Xml.member "Operation" xml)
                  PatchOperationType.parse));
          last_no_reboot_install_operation_time =
            (Util.option_bind
               (Xml.member "LastNoRebootInstallOperationTime" xml)
               DateTime.parse);
          reboot_option =
            (Util.option_bind (Xml.member "RebootOption" xml)
               RebootOption.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((((([] @
                             [Some
                                (Ezxmlm.make_tag "InstanceId"
                                   ([], (String.to_xml v.instance_id)))])
                            @
                            [Some
                               (Ezxmlm.make_tag "PatchGroup"
                                  ([], (String.to_xml v.patch_group)))])
                           @
                           [Some
                              (Ezxmlm.make_tag "BaselineId"
                                 ([], (String.to_xml v.baseline_id)))])
                          @
                          [Util.option_map v.snapshot_id
                             (fun f ->
                                Ezxmlm.make_tag "SnapshotId"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.install_override_list
                            (fun f ->
                               Ezxmlm.make_tag "InstallOverrideList"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.owner_information
                           (fun f ->
                              Ezxmlm.make_tag "OwnerInformation"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.installed_count
                          (fun f ->
                             Ezxmlm.make_tag "InstalledCount"
                               ([], (Integer.to_xml f)))])
                      @
                      [Util.option_map v.installed_other_count
                         (fun f ->
                            Ezxmlm.make_tag "InstalledOtherCount"
                              ([], (Integer.to_xml f)))])
                     @
                     [Util.option_map v.installed_pending_reboot_count
                        (fun f ->
                           Ezxmlm.make_tag "InstalledPendingRebootCount"
                             ([], (Integer.to_xml f)))])
                    @
                    [Util.option_map v.installed_rejected_count
                       (fun f ->
                          Ezxmlm.make_tag "InstalledRejectedCount"
                            ([], (Integer.to_xml f)))])
                   @
                   [Util.option_map v.missing_count
                      (fun f ->
                         Ezxmlm.make_tag "MissingCount"
                           ([], (Integer.to_xml f)))])
                  @
                  [Util.option_map v.failed_count
                     (fun f ->
                        Ezxmlm.make_tag "FailedCount"
                          ([], (Integer.to_xml f)))])
                 @
                 [Util.option_map v.unreported_not_applicable_count
                    (fun f ->
                       Ezxmlm.make_tag "UnreportedNotApplicableCount"
                         ([], (Integer.to_xml f)))])
                @
                [Util.option_map v.not_applicable_count
                   (fun f ->
                      Ezxmlm.make_tag "NotApplicableCount"
                        ([], (Integer.to_xml f)))])
               @
               [Some
                  (Ezxmlm.make_tag "OperationStartTime"
                     ([], (DateTime.to_xml v.operation_start_time)))])
              @
              [Some
                 (Ezxmlm.make_tag "OperationEndTime"
                    ([], (DateTime.to_xml v.operation_end_time)))])
             @
             [Some
                (Ezxmlm.make_tag "Operation"
                   ([], (PatchOperationType.to_xml v.operation)))])
            @
            [Util.option_map v.last_no_reboot_install_operation_time
               (fun f ->
                  Ezxmlm.make_tag "LastNoRebootInstallOperationTime"
                    ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.reboot_option
              (fun f ->
                 Ezxmlm.make_tag "RebootOption" ([], (RebootOption.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reboot_option
              (fun f -> ("reboot_option", (RebootOption.to_json f)));
           Util.option_map v.last_no_reboot_install_operation_time
             (fun f ->
                ("last_no_reboot_install_operation_time",
                  (DateTime.to_json f)));
           Some ("operation", (PatchOperationType.to_json v.operation));
           Some
             ("operation_end_time", (DateTime.to_json v.operation_end_time));
           Some
             ("operation_start_time",
               (DateTime.to_json v.operation_start_time));
           Util.option_map v.not_applicable_count
             (fun f -> ("not_applicable_count", (Integer.to_json f)));
           Util.option_map v.unreported_not_applicable_count
             (fun f ->
                ("unreported_not_applicable_count", (Integer.to_json f)));
           Util.option_map v.failed_count
             (fun f -> ("failed_count", (Integer.to_json f)));
           Util.option_map v.missing_count
             (fun f -> ("missing_count", (Integer.to_json f)));
           Util.option_map v.installed_rejected_count
             (fun f -> ("installed_rejected_count", (Integer.to_json f)));
           Util.option_map v.installed_pending_reboot_count
             (fun f ->
                ("installed_pending_reboot_count", (Integer.to_json f)));
           Util.option_map v.installed_other_count
             (fun f -> ("installed_other_count", (Integer.to_json f)));
           Util.option_map v.installed_count
             (fun f -> ("installed_count", (Integer.to_json f)));
           Util.option_map v.owner_information
             (fun f -> ("owner_information", (String.to_json f)));
           Util.option_map v.install_override_list
             (fun f -> ("install_override_list", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Some ("baseline_id", (String.to_json v.baseline_id));
           Some ("patch_group", (String.to_json v.patch_group));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        patch_group =
          (String.of_json (Util.of_option_exn (Json.lookup j "patch_group")));
        baseline_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "baseline_id")));
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        install_override_list =
          (Util.option_map (Json.lookup j "install_override_list")
             String.of_json);
        owner_information =
          (Util.option_map (Json.lookup j "owner_information") String.of_json);
        installed_count =
          (Util.option_map (Json.lookup j "installed_count") Integer.of_json);
        installed_other_count =
          (Util.option_map (Json.lookup j "installed_other_count")
             Integer.of_json);
        installed_pending_reboot_count =
          (Util.option_map (Json.lookup j "installed_pending_reboot_count")
             Integer.of_json);
        installed_rejected_count =
          (Util.option_map (Json.lookup j "installed_rejected_count")
             Integer.of_json);
        missing_count =
          (Util.option_map (Json.lookup j "missing_count") Integer.of_json);
        failed_count =
          (Util.option_map (Json.lookup j "failed_count") Integer.of_json);
        unreported_not_applicable_count =
          (Util.option_map (Json.lookup j "unreported_not_applicable_count")
             Integer.of_json);
        not_applicable_count =
          (Util.option_map (Json.lookup j "not_applicable_count")
             Integer.of_json);
        operation_start_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "operation_start_time")));
        operation_end_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "operation_end_time")));
        operation =
          (PatchOperationType.of_json
             (Util.of_option_exn (Json.lookup j "operation")));
        last_no_reboot_install_operation_time =
          (Util.option_map
             (Json.lookup j "last_no_reboot_install_operation_time")
             DateTime.of_json);
        reboot_option =
          (Util.option_map (Json.lookup j "reboot_option")
             RebootOption.of_json)
      }
  end
module AutomationExecutionFilter =
  struct
    type t =
      {
      key: AutomationExecutionFilterKey.t ;
      values: AutomationExecutionFilterValueList.t }
    let make ~key  ~values  () = { key; values }
    let parse xml =
      Some
        {
          key =
            (Xml.required "Key"
               (Util.option_bind (Xml.member "Key" xml)
                  AutomationExecutionFilterKey.parse));
          values =
            (Xml.required "Values"
               (Util.option_bind (Xml.member "Values" xml)
                  AutomationExecutionFilterValueList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "Key"
                  ([], (AutomationExecutionFilterKey.to_xml v.key)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Values"
                      ([], (AutomationExecutionFilterValueList.to_xml [x]))))
              v.values))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("values",
                (AutomationExecutionFilterValueList.to_json v.values));
           Some ("key", (AutomationExecutionFilterKey.to_json v.key))])
    let of_json j =
      {
        key =
          (AutomationExecutionFilterKey.of_json
             (Util.of_option_exn (Json.lookup j "key")));
        values =
          (AutomationExecutionFilterValueList.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module Command =
  struct
    type t =
      {
      command_id: String.t option ;
      document_name: String.t option ;
      document_version: String.t option ;
      comment: String.t option ;
      expires_after: DateTime.t option ;
      parameters: Parameters.t option ;
      instance_ids: InstanceIdList.t ;
      targets: Targets.t ;
      requested_date_time: DateTime.t option ;
      status: CommandStatus.t option ;
      status_details: String.t option ;
      output_s3_region: String.t option ;
      output_s3_bucket_name: String.t option ;
      output_s3_key_prefix: String.t option ;
      max_concurrency: String.t option ;
      max_errors: String.t option ;
      target_count: Integer.t option ;
      completed_count: Integer.t option ;
      error_count: Integer.t option ;
      delivery_timed_out_count: Integer.t option ;
      service_role: String.t option ;
      notification_config: NotificationConfig.t option ;
      cloud_watch_output_config: CloudWatchOutputConfig.t option }
    let make ?command_id  ?document_name  ?document_version  ?comment 
      ?expires_after  ?parameters  ?(instance_ids= [])  ?(targets= []) 
      ?requested_date_time  ?status  ?status_details  ?output_s3_region 
      ?output_s3_bucket_name  ?output_s3_key_prefix  ?max_concurrency 
      ?max_errors  ?target_count  ?completed_count  ?error_count 
      ?delivery_timed_out_count  ?service_role  ?notification_config 
      ?cloud_watch_output_config  () =
      {
        command_id;
        document_name;
        document_version;
        comment;
        expires_after;
        parameters;
        instance_ids;
        targets;
        requested_date_time;
        status;
        status_details;
        output_s3_region;
        output_s3_bucket_name;
        output_s3_key_prefix;
        max_concurrency;
        max_errors;
        target_count;
        completed_count;
        error_count;
        delivery_timed_out_count;
        service_role;
        notification_config;
        cloud_watch_output_config
      }
    let parse xml =
      Some
        {
          command_id =
            (Util.option_bind (Xml.member "CommandId" xml) String.parse);
          document_name =
            (Util.option_bind (Xml.member "DocumentName" xml) String.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          comment =
            (Util.option_bind (Xml.member "Comment" xml) String.parse);
          expires_after =
            (Util.option_bind (Xml.member "ExpiresAfter" xml) DateTime.parse);
          parameters =
            (Util.option_bind (Xml.member "Parameters" xml) Parameters.parse);
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceIds" xml)
                  InstanceIdList.parse));
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          requested_date_time =
            (Util.option_bind (Xml.member "RequestedDateTime" xml)
               DateTime.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml) CommandStatus.parse);
          status_details =
            (Util.option_bind (Xml.member "StatusDetails" xml) String.parse);
          output_s3_region =
            (Util.option_bind (Xml.member "OutputS3Region" xml) String.parse);
          output_s3_bucket_name =
            (Util.option_bind (Xml.member "OutputS3BucketName" xml)
               String.parse);
          output_s3_key_prefix =
            (Util.option_bind (Xml.member "OutputS3KeyPrefix" xml)
               String.parse);
          max_concurrency =
            (Util.option_bind (Xml.member "MaxConcurrency" xml) String.parse);
          max_errors =
            (Util.option_bind (Xml.member "MaxErrors" xml) String.parse);
          target_count =
            (Util.option_bind (Xml.member "TargetCount" xml) Integer.parse);
          completed_count =
            (Util.option_bind (Xml.member "CompletedCount" xml) Integer.parse);
          error_count =
            (Util.option_bind (Xml.member "ErrorCount" xml) Integer.parse);
          delivery_timed_out_count =
            (Util.option_bind (Xml.member "DeliveryTimedOutCount" xml)
               Integer.parse);
          service_role =
            (Util.option_bind (Xml.member "ServiceRole" xml) String.parse);
          notification_config =
            (Util.option_bind (Xml.member "NotificationConfig" xml)
               NotificationConfig.parse);
          cloud_watch_output_config =
            (Util.option_bind (Xml.member "CloudWatchOutputConfig" xml)
               CloudWatchOutputConfig.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((((((((([] @
                                 [Util.option_map v.command_id
                                    (fun f ->
                                       Ezxmlm.make_tag "CommandId"
                                         ([], (String.to_xml f)))])
                                @
                                [Util.option_map v.document_name
                                   (fun f ->
                                      Ezxmlm.make_tag "DocumentName"
                                        ([], (String.to_xml f)))])
                               @
                               [Util.option_map v.document_version
                                  (fun f ->
                                     Ezxmlm.make_tag "DocumentVersion"
                                       ([], (String.to_xml f)))])
                              @
                              [Util.option_map v.comment
                                 (fun f ->
                                    Ezxmlm.make_tag "Comment"
                                      ([], (String.to_xml f)))])
                             @
                             [Util.option_map v.expires_after
                                (fun f ->
                                   Ezxmlm.make_tag "ExpiresAfter"
                                     ([], (DateTime.to_xml f)))])
                            @
                            [Util.option_map v.parameters
                               (fun f ->
                                  Ezxmlm.make_tag "Parameters"
                                    ([], (Parameters.to_xml f)))])
                           @
                           (List.map
                              (fun x ->
                                 Some
                                   (Ezxmlm.make_tag "InstanceIds"
                                      ([], (InstanceIdList.to_xml [x]))))
                              v.instance_ids))
                          @
                          (List.map
                             (fun x ->
                                Some
                                  (Ezxmlm.make_tag "Targets"
                                     ([], (Targets.to_xml [x])))) v.targets))
                         @
                         [Util.option_map v.requested_date_time
                            (fun f ->
                               Ezxmlm.make_tag "RequestedDateTime"
                                 ([], (DateTime.to_xml f)))])
                        @
                        [Util.option_map v.status
                           (fun f ->
                              Ezxmlm.make_tag "Status"
                                ([], (CommandStatus.to_xml f)))])
                       @
                       [Util.option_map v.status_details
                          (fun f ->
                             Ezxmlm.make_tag "StatusDetails"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.output_s3_region
                         (fun f ->
                            Ezxmlm.make_tag "OutputS3Region"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.output_s3_bucket_name
                        (fun f ->
                           Ezxmlm.make_tag "OutputS3BucketName"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.output_s3_key_prefix
                       (fun f ->
                          Ezxmlm.make_tag "OutputS3KeyPrefix"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.max_concurrency
                      (fun f ->
                         Ezxmlm.make_tag "MaxConcurrency"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.max_errors
                     (fun f ->
                        Ezxmlm.make_tag "MaxErrors" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.target_count
                    (fun f ->
                       Ezxmlm.make_tag "TargetCount" ([], (Integer.to_xml f)))])
                @
                [Util.option_map v.completed_count
                   (fun f ->
                      Ezxmlm.make_tag "CompletedCount"
                        ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.error_count
                  (fun f ->
                     Ezxmlm.make_tag "ErrorCount" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.delivery_timed_out_count
                 (fun f ->
                    Ezxmlm.make_tag "DeliveryTimedOutCount"
                      ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.service_role
                (fun f ->
                   Ezxmlm.make_tag "ServiceRole" ([], (String.to_xml f)))])
            @
            [Util.option_map v.notification_config
               (fun f ->
                  Ezxmlm.make_tag "NotificationConfig"
                    ([], (NotificationConfig.to_xml f)))])
           @
           [Util.option_map v.cloud_watch_output_config
              (fun f ->
                 Ezxmlm.make_tag "CloudWatchOutputConfig"
                   ([], (CloudWatchOutputConfig.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cloud_watch_output_config
              (fun f ->
                 ("cloud_watch_output_config",
                   (CloudWatchOutputConfig.to_json f)));
           Util.option_map v.notification_config
             (fun f ->
                ("notification_config", (NotificationConfig.to_json f)));
           Util.option_map v.service_role
             (fun f -> ("service_role", (String.to_json f)));
           Util.option_map v.delivery_timed_out_count
             (fun f -> ("delivery_timed_out_count", (Integer.to_json f)));
           Util.option_map v.error_count
             (fun f -> ("error_count", (Integer.to_json f)));
           Util.option_map v.completed_count
             (fun f -> ("completed_count", (Integer.to_json f)));
           Util.option_map v.target_count
             (fun f -> ("target_count", (Integer.to_json f)));
           Util.option_map v.max_errors
             (fun f -> ("max_errors", (String.to_json f)));
           Util.option_map v.max_concurrency
             (fun f -> ("max_concurrency", (String.to_json f)));
           Util.option_map v.output_s3_key_prefix
             (fun f -> ("output_s3_key_prefix", (String.to_json f)));
           Util.option_map v.output_s3_bucket_name
             (fun f -> ("output_s3_bucket_name", (String.to_json f)));
           Util.option_map v.output_s3_region
             (fun f -> ("output_s3_region", (String.to_json f)));
           Util.option_map v.status_details
             (fun f -> ("status_details", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (CommandStatus.to_json f)));
           Util.option_map v.requested_date_time
             (fun f -> ("requested_date_time", (DateTime.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Some ("instance_ids", (InstanceIdList.to_json v.instance_ids));
           Util.option_map v.parameters
             (fun f -> ("parameters", (Parameters.to_json f)));
           Util.option_map v.expires_after
             (fun f -> ("expires_after", (DateTime.to_json f)));
           Util.option_map v.comment
             (fun f -> ("comment", (String.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.document_name
             (fun f -> ("document_name", (String.to_json f)));
           Util.option_map v.command_id
             (fun f -> ("command_id", (String.to_json f)))])
    let of_json j =
      {
        command_id =
          (Util.option_map (Json.lookup j "command_id") String.of_json);
        document_name =
          (Util.option_map (Json.lookup j "document_name") String.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        comment = (Util.option_map (Json.lookup j "comment") String.of_json);
        expires_after =
          (Util.option_map (Json.lookup j "expires_after") DateTime.of_json);
        parameters =
          (Util.option_map (Json.lookup j "parameters") Parameters.of_json);
        instance_ids =
          (InstanceIdList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        requested_date_time =
          (Util.option_map (Json.lookup j "requested_date_time")
             DateTime.of_json);
        status =
          (Util.option_map (Json.lookup j "status") CommandStatus.of_json);
        status_details =
          (Util.option_map (Json.lookup j "status_details") String.of_json);
        output_s3_region =
          (Util.option_map (Json.lookup j "output_s3_region") String.of_json);
        output_s3_bucket_name =
          (Util.option_map (Json.lookup j "output_s3_bucket_name")
             String.of_json);
        output_s3_key_prefix =
          (Util.option_map (Json.lookup j "output_s3_key_prefix")
             String.of_json);
        max_concurrency =
          (Util.option_map (Json.lookup j "max_concurrency") String.of_json);
        max_errors =
          (Util.option_map (Json.lookup j "max_errors") String.of_json);
        target_count =
          (Util.option_map (Json.lookup j "target_count") Integer.of_json);
        completed_count =
          (Util.option_map (Json.lookup j "completed_count") Integer.of_json);
        error_count =
          (Util.option_map (Json.lookup j "error_count") Integer.of_json);
        delivery_timed_out_count =
          (Util.option_map (Json.lookup j "delivery_timed_out_count")
             Integer.of_json);
        service_role =
          (Util.option_map (Json.lookup j "service_role") String.of_json);
        notification_config =
          (Util.option_map (Json.lookup j "notification_config")
             NotificationConfig.of_json);
        cloud_watch_output_config =
          (Util.option_map (Json.lookup j "cloud_watch_output_config")
             CloudWatchOutputConfig.of_json)
      }
  end
module MaintenanceWindowTarget =
  struct
    type t =
      {
      window_id: String.t option ;
      window_target_id: String.t option ;
      resource_type: MaintenanceWindowResourceType.t option ;
      targets: Targets.t ;
      owner_information: String.t option ;
      name: String.t option ;
      description: String.t option }
    let make ?window_id  ?window_target_id  ?resource_type  ?(targets= []) 
      ?owner_information  ?name  ?description  () =
      {
        window_id;
        window_target_id;
        resource_type;
        targets;
        owner_information;
        name;
        description
      }
    let parse xml =
      Some
        {
          window_id =
            (Util.option_bind (Xml.member "WindowId" xml) String.parse);
          window_target_id =
            (Util.option_bind (Xml.member "WindowTargetId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "ResourceType" xml)
               MaintenanceWindowResourceType.parse);
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          owner_information =
            (Util.option_bind (Xml.member "OwnerInformation" xml)
               String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.window_id
                    (fun f ->
                       Ezxmlm.make_tag "WindowId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.window_target_id
                   (fun f ->
                      Ezxmlm.make_tag "WindowTargetId"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.resource_type
                  (fun f ->
                     Ezxmlm.make_tag "ResourceType"
                       ([], (MaintenanceWindowResourceType.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Targets" ([], (Targets.to_xml [x]))))
                 v.targets))
             @
             [Util.option_map v.owner_information
                (fun f ->
                   Ezxmlm.make_tag "OwnerInformation" ([], (String.to_xml f)))])
            @
            [Util.option_map v.name
               (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
           @
           [Util.option_map v.description
              (fun f -> Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.owner_information
             (fun f -> ("owner_information", (String.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type", (MaintenanceWindowResourceType.to_json f)));
           Util.option_map v.window_target_id
             (fun f -> ("window_target_id", (String.to_json f)));
           Util.option_map v.window_id
             (fun f -> ("window_id", (String.to_json f)))])
    let of_json j =
      {
        window_id =
          (Util.option_map (Json.lookup j "window_id") String.of_json);
        window_target_id =
          (Util.option_map (Json.lookup j "window_target_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             MaintenanceWindowResourceType.of_json);
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        owner_information =
          (Util.option_map (Json.lookup j "owner_information") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module OpsItemSummary =
  struct
    type t =
      {
      created_by: String.t option ;
      created_time: DateTime.t option ;
      last_modified_by: String.t option ;
      last_modified_time: DateTime.t option ;
      priority: Integer.t option ;
      source: String.t option ;
      status: OpsItemStatus.t option ;
      ops_item_id: String.t option ;
      title: String.t option ;
      operational_data: OpsItemOperationalData.t option ;
      category: String.t option ;
      severity: String.t option }
    let make ?created_by  ?created_time  ?last_modified_by 
      ?last_modified_time  ?priority  ?source  ?status  ?ops_item_id  ?title 
      ?operational_data  ?category  ?severity  () =
      {
        created_by;
        created_time;
        last_modified_by;
        last_modified_time;
        priority;
        source;
        status;
        ops_item_id;
        title;
        operational_data;
        category;
        severity
      }
    let parse xml =
      Some
        {
          created_by =
            (Util.option_bind (Xml.member "CreatedBy" xml) String.parse);
          created_time =
            (Util.option_bind (Xml.member "CreatedTime" xml) DateTime.parse);
          last_modified_by =
            (Util.option_bind (Xml.member "LastModifiedBy" xml) String.parse);
          last_modified_time =
            (Util.option_bind (Xml.member "LastModifiedTime" xml)
               DateTime.parse);
          priority =
            (Util.option_bind (Xml.member "Priority" xml) Integer.parse);
          source = (Util.option_bind (Xml.member "Source" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml) OpsItemStatus.parse);
          ops_item_id =
            (Util.option_bind (Xml.member "OpsItemId" xml) String.parse);
          title = (Util.option_bind (Xml.member "Title" xml) String.parse);
          operational_data =
            (Util.option_bind (Xml.member "OperationalData" xml)
               OpsItemOperationalData.parse);
          category =
            (Util.option_bind (Xml.member "Category" xml) String.parse);
          severity =
            (Util.option_bind (Xml.member "Severity" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Util.option_map v.created_by
                         (fun f ->
                            Ezxmlm.make_tag "CreatedBy"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.created_time
                        (fun f ->
                           Ezxmlm.make_tag "CreatedTime"
                             ([], (DateTime.to_xml f)))])
                    @
                    [Util.option_map v.last_modified_by
                       (fun f ->
                          Ezxmlm.make_tag "LastModifiedBy"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.last_modified_time
                      (fun f ->
                         Ezxmlm.make_tag "LastModifiedTime"
                           ([], (DateTime.to_xml f)))])
                  @
                  [Util.option_map v.priority
                     (fun f ->
                        Ezxmlm.make_tag "Priority" ([], (Integer.to_xml f)))])
                 @
                 [Util.option_map v.source
                    (fun f ->
                       Ezxmlm.make_tag "Source" ([], (String.to_xml f)))])
                @
                [Util.option_map v.status
                   (fun f ->
                      Ezxmlm.make_tag "Status" ([], (OpsItemStatus.to_xml f)))])
               @
               [Util.option_map v.ops_item_id
                  (fun f ->
                     Ezxmlm.make_tag "OpsItemId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.title
                 (fun f -> Ezxmlm.make_tag "Title" ([], (String.to_xml f)))])
             @
             [Util.option_map v.operational_data
                (fun f ->
                   Ezxmlm.make_tag "OperationalData"
                     ([], (OpsItemOperationalData.to_xml f)))])
            @
            [Util.option_map v.category
               (fun f -> Ezxmlm.make_tag "Category" ([], (String.to_xml f)))])
           @
           [Util.option_map v.severity
              (fun f -> Ezxmlm.make_tag "Severity" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.severity
              (fun f -> ("severity", (String.to_json f)));
           Util.option_map v.category
             (fun f -> ("category", (String.to_json f)));
           Util.option_map v.operational_data
             (fun f ->
                ("operational_data", (OpsItemOperationalData.to_json f)));
           Util.option_map v.title (fun f -> ("title", (String.to_json f)));
           Util.option_map v.ops_item_id
             (fun f -> ("ops_item_id", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (OpsItemStatus.to_json f)));
           Util.option_map v.source (fun f -> ("source", (String.to_json f)));
           Util.option_map v.priority
             (fun f -> ("priority", (Integer.to_json f)));
           Util.option_map v.last_modified_time
             (fun f -> ("last_modified_time", (DateTime.to_json f)));
           Util.option_map v.last_modified_by
             (fun f -> ("last_modified_by", (String.to_json f)));
           Util.option_map v.created_time
             (fun f -> ("created_time", (DateTime.to_json f)));
           Util.option_map v.created_by
             (fun f -> ("created_by", (String.to_json f)))])
    let of_json j =
      {
        created_by =
          (Util.option_map (Json.lookup j "created_by") String.of_json);
        created_time =
          (Util.option_map (Json.lookup j "created_time") DateTime.of_json);
        last_modified_by =
          (Util.option_map (Json.lookup j "last_modified_by") String.of_json);
        last_modified_time =
          (Util.option_map (Json.lookup j "last_modified_time")
             DateTime.of_json);
        priority =
          (Util.option_map (Json.lookup j "priority") Integer.of_json);
        source = (Util.option_map (Json.lookup j "source") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") OpsItemStatus.of_json);
        ops_item_id =
          (Util.option_map (Json.lookup j "ops_item_id") String.of_json);
        title = (Util.option_map (Json.lookup j "title") String.of_json);
        operational_data =
          (Util.option_map (Json.lookup j "operational_data")
             OpsItemOperationalData.of_json);
        category =
          (Util.option_map (Json.lookup j "category") String.of_json);
        severity =
          (Util.option_map (Json.lookup j "severity") String.of_json)
      }
  end
module OpsAggregatorValueMap =
  struct
    type t = (String.t, String.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string String.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc -> ((String.to_string k), (String.to_json v)) :: acc)
           v [])
    let of_json j = Json.to_hashtbl String.of_string String.of_json j
  end
module OpsFilterList =
  struct
    type t = OpsFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map OpsFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list OpsFilter.to_query v
    let to_headers v = Headers.to_headers_list OpsFilter.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (OpsFilter.to_xml x)))
        v
    let to_json v = `List (List.map OpsFilter.to_json v)
    let of_json j = Json.to_list OpsFilter.of_json j
  end
module OpsResultAttribute =
  struct
    type t = {
      type_name: String.t }
    let make ~type_name  () = { type_name }
    let parse xml =
      Some
        {
          type_name =
            (Xml.required "TypeName"
               (Util.option_bind (Xml.member "TypeName" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "TypeName" ([], (String.to_xml v.type_name)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("type_name", (String.to_json v.type_name))])
    let of_json j =
      {
        type_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "type_name")))
      }
  end
module PatchComplianceData =
  struct
    type t =
      {
      title: String.t ;
      k_b_id: String.t ;
      classification: String.t ;
      severity: String.t ;
      state: PatchComplianceDataState.t ;
      installed_time: DateTime.t }
    let make ~title  ~k_b_id  ~classification  ~severity  ~state 
      ~installed_time  () =
      { title; k_b_id; classification; severity; state; installed_time }
    let parse xml =
      Some
        {
          title =
            (Xml.required "Title"
               (Util.option_bind (Xml.member "Title" xml) String.parse));
          k_b_id =
            (Xml.required "KBId"
               (Util.option_bind (Xml.member "KBId" xml) String.parse));
          classification =
            (Xml.required "Classification"
               (Util.option_bind (Xml.member "Classification" xml)
                  String.parse));
          severity =
            (Xml.required "Severity"
               (Util.option_bind (Xml.member "Severity" xml) String.parse));
          state =
            (Xml.required "State"
               (Util.option_bind (Xml.member "State" xml)
                  PatchComplianceDataState.parse));
          installed_time =
            (Xml.required "InstalledTime"
               (Util.option_bind (Xml.member "InstalledTime" xml)
                  DateTime.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Some (Ezxmlm.make_tag "Title" ([], (String.to_xml v.title)))])
               @
               [Some (Ezxmlm.make_tag "KBId" ([], (String.to_xml v.k_b_id)))])
              @
              [Some
                 (Ezxmlm.make_tag "Classification"
                    ([], (String.to_xml v.classification)))])
             @
             [Some
                (Ezxmlm.make_tag "Severity" ([], (String.to_xml v.severity)))])
            @
            [Some
               (Ezxmlm.make_tag "State"
                  ([], (PatchComplianceDataState.to_xml v.state)))])
           @
           [Some
              (Ezxmlm.make_tag "InstalledTime"
                 ([], (DateTime.to_xml v.installed_time)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("installed_time", (DateTime.to_json v.installed_time));
           Some ("state", (PatchComplianceDataState.to_json v.state));
           Some ("severity", (String.to_json v.severity));
           Some ("classification", (String.to_json v.classification));
           Some ("k_b_id", (String.to_json v.k_b_id));
           Some ("title", (String.to_json v.title))])
    let of_json j =
      {
        title = (String.of_json (Util.of_option_exn (Json.lookup j "title")));
        k_b_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "k_b_id")));
        classification =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "classification")));
        severity =
          (String.of_json (Util.of_option_exn (Json.lookup j "severity")));
        state =
          (PatchComplianceDataState.of_json
             (Util.of_option_exn (Json.lookup j "state")));
        installed_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "installed_time")))
      }
  end
module DocumentFilter =
  struct
    type t = {
      key: DocumentFilterKey.t ;
      value: String.t }
    let make ~key  ~value  () = { key; value }
    let parse xml =
      Some
        {
          key =
            (Xml.required "key"
               (Util.option_bind (Xml.member "key" xml)
                  DocumentFilterKey.parse));
          value =
            (Xml.required "value"
               (Util.option_bind (Xml.member "value" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "key" ([], (DocumentFilterKey.to_xml v.key)))])
           @ [Some (Ezxmlm.make_tag "value" ([], (String.to_xml v.value)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("value", (String.to_json v.value));
           Some ("key", (DocumentFilterKey.to_json v.key))])
    let of_json j =
      {
        key =
          (DocumentFilterKey.of_json
             (Util.of_option_exn (Json.lookup j "key")));
        value = (String.of_json (Util.of_option_exn (Json.lookup j "value")))
      }
  end
module DocumentKeyValuesFilter =
  struct
    type t = {
      key: String.t option ;
      values: DocumentKeyValuesFilterValues.t }
    let make ?key  ?(values= [])  () = { key; values }
    let parse xml =
      Some
        {
          key = (Util.option_bind (Xml.member "Key" xml) String.parse);
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "Values" xml)
                  DocumentKeyValuesFilterValues.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.key
               (fun f -> Ezxmlm.make_tag "Key" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Values"
                      ([], (DocumentKeyValuesFilterValues.to_xml [x]))))
              v.values))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (DocumentKeyValuesFilterValues.to_json v.values));
           Util.option_map v.key (fun f -> ("key", (String.to_json f)))])
    let of_json j =
      {
        key = (Util.option_map (Json.lookup j "key") String.of_json);
        values =
          (DocumentKeyValuesFilterValues.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module AssociationVersionInfo =
  struct
    type t =
      {
      association_id: String.t option ;
      association_version: String.t option ;
      created_date: DateTime.t option ;
      name: String.t option ;
      document_version: String.t option ;
      parameters: Parameters.t option ;
      targets: Targets.t ;
      schedule_expression: String.t option ;
      output_location: InstanceAssociationOutputLocation.t option ;
      association_name: String.t option ;
      max_errors: String.t option ;
      max_concurrency: String.t option ;
      compliance_severity: AssociationComplianceSeverity.t option }
    let make ?association_id  ?association_version  ?created_date  ?name 
      ?document_version  ?parameters  ?(targets= [])  ?schedule_expression 
      ?output_location  ?association_name  ?max_errors  ?max_concurrency 
      ?compliance_severity  () =
      {
        association_id;
        association_version;
        created_date;
        name;
        document_version;
        parameters;
        targets;
        schedule_expression;
        output_location;
        association_name;
        max_errors;
        max_concurrency;
        compliance_severity
      }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "AssociationId" xml) String.parse);
          association_version =
            (Util.option_bind (Xml.member "AssociationVersion" xml)
               String.parse);
          created_date =
            (Util.option_bind (Xml.member "CreatedDate" xml) DateTime.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          parameters =
            (Util.option_bind (Xml.member "Parameters" xml) Parameters.parse);
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          schedule_expression =
            (Util.option_bind (Xml.member "ScheduleExpression" xml)
               String.parse);
          output_location =
            (Util.option_bind (Xml.member "OutputLocation" xml)
               InstanceAssociationOutputLocation.parse);
          association_name =
            (Util.option_bind (Xml.member "AssociationName" xml) String.parse);
          max_errors =
            (Util.option_bind (Xml.member "MaxErrors" xml) String.parse);
          max_concurrency =
            (Util.option_bind (Xml.member "MaxConcurrency" xml) String.parse);
          compliance_severity =
            (Util.option_bind (Xml.member "ComplianceSeverity" xml)
               AssociationComplianceSeverity.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.association_id
                          (fun f ->
                             Ezxmlm.make_tag "AssociationId"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.association_version
                         (fun f ->
                            Ezxmlm.make_tag "AssociationVersion"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.created_date
                        (fun f ->
                           Ezxmlm.make_tag "CreatedDate"
                             ([], (DateTime.to_xml f)))])
                    @
                    [Util.option_map v.name
                       (fun f ->
                          Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.document_version
                      (fun f ->
                         Ezxmlm.make_tag "DocumentVersion"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.parameters
                     (fun f ->
                        Ezxmlm.make_tag "Parameters"
                          ([], (Parameters.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "Targets"
                            ([], (Targets.to_xml [x])))) v.targets))
                @
                [Util.option_map v.schedule_expression
                   (fun f ->
                      Ezxmlm.make_tag "ScheduleExpression"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.output_location
                  (fun f ->
                     Ezxmlm.make_tag "OutputLocation"
                       ([], (InstanceAssociationOutputLocation.to_xml f)))])
              @
              [Util.option_map v.association_name
                 (fun f ->
                    Ezxmlm.make_tag "AssociationName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.max_errors
                (fun f -> Ezxmlm.make_tag "MaxErrors" ([], (String.to_xml f)))])
            @
            [Util.option_map v.max_concurrency
               (fun f ->
                  Ezxmlm.make_tag "MaxConcurrency" ([], (String.to_xml f)))])
           @
           [Util.option_map v.compliance_severity
              (fun f ->
                 Ezxmlm.make_tag "ComplianceSeverity"
                   ([], (AssociationComplianceSeverity.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.compliance_severity
              (fun f ->
                 ("compliance_severity",
                   (AssociationComplianceSeverity.to_json f)));
           Util.option_map v.max_concurrency
             (fun f -> ("max_concurrency", (String.to_json f)));
           Util.option_map v.max_errors
             (fun f -> ("max_errors", (String.to_json f)));
           Util.option_map v.association_name
             (fun f -> ("association_name", (String.to_json f)));
           Util.option_map v.output_location
             (fun f ->
                ("output_location",
                  (InstanceAssociationOutputLocation.to_json f)));
           Util.option_map v.schedule_expression
             (fun f -> ("schedule_expression", (String.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Util.option_map v.parameters
             (fun f -> ("parameters", (Parameters.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.created_date
             (fun f -> ("created_date", (DateTime.to_json f)));
           Util.option_map v.association_version
             (fun f -> ("association_version", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        association_version =
          (Util.option_map (Json.lookup j "association_version")
             String.of_json);
        created_date =
          (Util.option_map (Json.lookup j "created_date") DateTime.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        parameters =
          (Util.option_map (Json.lookup j "parameters") Parameters.of_json);
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        schedule_expression =
          (Util.option_map (Json.lookup j "schedule_expression")
             String.of_json);
        output_location =
          (Util.option_map (Json.lookup j "output_location")
             InstanceAssociationOutputLocation.of_json);
        association_name =
          (Util.option_map (Json.lookup j "association_name") String.of_json);
        max_errors =
          (Util.option_map (Json.lookup j "max_errors") String.of_json);
        max_concurrency =
          (Util.option_map (Json.lookup j "max_concurrency") String.of_json);
        compliance_severity =
          (Util.option_map (Json.lookup j "compliance_severity")
             AssociationComplianceSeverity.of_json)
      }
  end
module ComplianceSummaryItem =
  struct
    type t =
      {
      compliance_type: String.t option ;
      compliant_summary: CompliantSummary.t option ;
      non_compliant_summary: NonCompliantSummary.t option }
    let make ?compliance_type  ?compliant_summary  ?non_compliant_summary  ()
      = { compliance_type; compliant_summary; non_compliant_summary }
    let parse xml =
      Some
        {
          compliance_type =
            (Util.option_bind (Xml.member "ComplianceType" xml) String.parse);
          compliant_summary =
            (Util.option_bind (Xml.member "CompliantSummary" xml)
               CompliantSummary.parse);
          non_compliant_summary =
            (Util.option_bind (Xml.member "NonCompliantSummary" xml)
               NonCompliantSummary.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.compliance_type
                (fun f ->
                   Ezxmlm.make_tag "ComplianceType" ([], (String.to_xml f)))])
            @
            [Util.option_map v.compliant_summary
               (fun f ->
                  Ezxmlm.make_tag "CompliantSummary"
                    ([], (CompliantSummary.to_xml f)))])
           @
           [Util.option_map v.non_compliant_summary
              (fun f ->
                 Ezxmlm.make_tag "NonCompliantSummary"
                   ([], (NonCompliantSummary.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.non_compliant_summary
              (fun f ->
                 ("non_compliant_summary", (NonCompliantSummary.to_json f)));
           Util.option_map v.compliant_summary
             (fun f -> ("compliant_summary", (CompliantSummary.to_json f)));
           Util.option_map v.compliance_type
             (fun f -> ("compliance_type", (String.to_json f)))])
    let of_json j =
      {
        compliance_type =
          (Util.option_map (Json.lookup j "compliance_type") String.of_json);
        compliant_summary =
          (Util.option_map (Json.lookup j "compliant_summary")
             CompliantSummary.of_json);
        non_compliant_summary =
          (Util.option_map (Json.lookup j "non_compliant_summary")
             NonCompliantSummary.of_json)
      }
  end
module SessionManagerParameterValueList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module EffectivePatch =
  struct
    type t = {
      patch: Patch.t option ;
      patch_status: PatchStatus.t option }
    let make ?patch  ?patch_status  () = { patch; patch_status }
    let parse xml =
      Some
        {
          patch = (Util.option_bind (Xml.member "Patch" xml) Patch.parse);
          patch_status =
            (Util.option_bind (Xml.member "PatchStatus" xml)
               PatchStatus.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.patch
               (fun f -> Ezxmlm.make_tag "Patch" ([], (Patch.to_xml f)))])
           @
           [Util.option_map v.patch_status
              (fun f ->
                 Ezxmlm.make_tag "PatchStatus" ([], (PatchStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.patch_status
              (fun f -> ("patch_status", (PatchStatus.to_json f)));
           Util.option_map v.patch (fun f -> ("patch", (Patch.to_json f)))])
    let of_json j =
      {
        patch = (Util.option_map (Json.lookup j "patch") Patch.of_json);
        patch_status =
          (Util.option_map (Json.lookup j "patch_status") PatchStatus.of_json)
      }
  end
module AssociationDescription =
  struct
    type t =
      {
      name: String.t option ;
      instance_id: String.t option ;
      association_version: String.t option ;
      date: DateTime.t option ;
      last_update_association_date: DateTime.t option ;
      status: AssociationStatus.t option ;
      overview: AssociationOverview.t option ;
      document_version: String.t option ;
      automation_target_parameter_name: String.t option ;
      parameters: Parameters.t option ;
      association_id: String.t option ;
      targets: Targets.t ;
      schedule_expression: String.t option ;
      output_location: InstanceAssociationOutputLocation.t option ;
      last_execution_date: DateTime.t option ;
      last_successful_execution_date: DateTime.t option ;
      association_name: String.t option ;
      max_errors: String.t option ;
      max_concurrency: String.t option ;
      compliance_severity: AssociationComplianceSeverity.t option }
    let make ?name  ?instance_id  ?association_version  ?date 
      ?last_update_association_date  ?status  ?overview  ?document_version 
      ?automation_target_parameter_name  ?parameters  ?association_id 
      ?(targets= [])  ?schedule_expression  ?output_location 
      ?last_execution_date  ?last_successful_execution_date 
      ?association_name  ?max_errors  ?max_concurrency  ?compliance_severity 
      () =
      {
        name;
        instance_id;
        association_version;
        date;
        last_update_association_date;
        status;
        overview;
        document_version;
        automation_target_parameter_name;
        parameters;
        association_id;
        targets;
        schedule_expression;
        output_location;
        last_execution_date;
        last_successful_execution_date;
        association_name;
        max_errors;
        max_concurrency;
        compliance_severity
      }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          association_version =
            (Util.option_bind (Xml.member "AssociationVersion" xml)
               String.parse);
          date = (Util.option_bind (Xml.member "Date" xml) DateTime.parse);
          last_update_association_date =
            (Util.option_bind (Xml.member "LastUpdateAssociationDate" xml)
               DateTime.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml)
               AssociationStatus.parse);
          overview =
            (Util.option_bind (Xml.member "Overview" xml)
               AssociationOverview.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          automation_target_parameter_name =
            (Util.option_bind
               (Xml.member "AutomationTargetParameterName" xml) String.parse);
          parameters =
            (Util.option_bind (Xml.member "Parameters" xml) Parameters.parse);
          association_id =
            (Util.option_bind (Xml.member "AssociationId" xml) String.parse);
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          schedule_expression =
            (Util.option_bind (Xml.member "ScheduleExpression" xml)
               String.parse);
          output_location =
            (Util.option_bind (Xml.member "OutputLocation" xml)
               InstanceAssociationOutputLocation.parse);
          last_execution_date =
            (Util.option_bind (Xml.member "LastExecutionDate" xml)
               DateTime.parse);
          last_successful_execution_date =
            (Util.option_bind (Xml.member "LastSuccessfulExecutionDate" xml)
               DateTime.parse);
          association_name =
            (Util.option_bind (Xml.member "AssociationName" xml) String.parse);
          max_errors =
            (Util.option_bind (Xml.member "MaxErrors" xml) String.parse);
          max_concurrency =
            (Util.option_bind (Xml.member "MaxConcurrency" xml) String.parse);
          compliance_severity =
            (Util.option_bind (Xml.member "ComplianceSeverity" xml)
               AssociationComplianceSeverity.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((((([] @
                              [Util.option_map v.name
                                 (fun f ->
                                    Ezxmlm.make_tag "Name"
                                      ([], (String.to_xml f)))])
                             @
                             [Util.option_map v.instance_id
                                (fun f ->
                                   Ezxmlm.make_tag "InstanceId"
                                     ([], (String.to_xml f)))])
                            @
                            [Util.option_map v.association_version
                               (fun f ->
                                  Ezxmlm.make_tag "AssociationVersion"
                                    ([], (String.to_xml f)))])
                           @
                           [Util.option_map v.date
                              (fun f ->
                                 Ezxmlm.make_tag "Date"
                                   ([], (DateTime.to_xml f)))])
                          @
                          [Util.option_map v.last_update_association_date
                             (fun f ->
                                Ezxmlm.make_tag "LastUpdateAssociationDate"
                                  ([], (DateTime.to_xml f)))])
                         @
                         [Util.option_map v.status
                            (fun f ->
                               Ezxmlm.make_tag "Status"
                                 ([], (AssociationStatus.to_xml f)))])
                        @
                        [Util.option_map v.overview
                           (fun f ->
                              Ezxmlm.make_tag "Overview"
                                ([], (AssociationOverview.to_xml f)))])
                       @
                       [Util.option_map v.document_version
                          (fun f ->
                             Ezxmlm.make_tag "DocumentVersion"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.automation_target_parameter_name
                         (fun f ->
                            Ezxmlm.make_tag "AutomationTargetParameterName"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.parameters
                        (fun f ->
                           Ezxmlm.make_tag "Parameters"
                             ([], (Parameters.to_xml f)))])
                    @
                    [Util.option_map v.association_id
                       (fun f ->
                          Ezxmlm.make_tag "AssociationId"
                            ([], (String.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "Targets"
                              ([], (Targets.to_xml [x])))) v.targets))
                  @
                  [Util.option_map v.schedule_expression
                     (fun f ->
                        Ezxmlm.make_tag "ScheduleExpression"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.output_location
                    (fun f ->
                       Ezxmlm.make_tag "OutputLocation"
                         ([], (InstanceAssociationOutputLocation.to_xml f)))])
                @
                [Util.option_map v.last_execution_date
                   (fun f ->
                      Ezxmlm.make_tag "LastExecutionDate"
                        ([], (DateTime.to_xml f)))])
               @
               [Util.option_map v.last_successful_execution_date
                  (fun f ->
                     Ezxmlm.make_tag "LastSuccessfulExecutionDate"
                       ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.association_name
                 (fun f ->
                    Ezxmlm.make_tag "AssociationName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.max_errors
                (fun f -> Ezxmlm.make_tag "MaxErrors" ([], (String.to_xml f)))])
            @
            [Util.option_map v.max_concurrency
               (fun f ->
                  Ezxmlm.make_tag "MaxConcurrency" ([], (String.to_xml f)))])
           @
           [Util.option_map v.compliance_severity
              (fun f ->
                 Ezxmlm.make_tag "ComplianceSeverity"
                   ([], (AssociationComplianceSeverity.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.compliance_severity
              (fun f ->
                 ("compliance_severity",
                   (AssociationComplianceSeverity.to_json f)));
           Util.option_map v.max_concurrency
             (fun f -> ("max_concurrency", (String.to_json f)));
           Util.option_map v.max_errors
             (fun f -> ("max_errors", (String.to_json f)));
           Util.option_map v.association_name
             (fun f -> ("association_name", (String.to_json f)));
           Util.option_map v.last_successful_execution_date
             (fun f ->
                ("last_successful_execution_date", (DateTime.to_json f)));
           Util.option_map v.last_execution_date
             (fun f -> ("last_execution_date", (DateTime.to_json f)));
           Util.option_map v.output_location
             (fun f ->
                ("output_location",
                  (InstanceAssociationOutputLocation.to_json f)));
           Util.option_map v.schedule_expression
             (fun f -> ("schedule_expression", (String.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)));
           Util.option_map v.parameters
             (fun f -> ("parameters", (Parameters.to_json f)));
           Util.option_map v.automation_target_parameter_name
             (fun f ->
                ("automation_target_parameter_name", (String.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.overview
             (fun f -> ("overview", (AssociationOverview.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (AssociationStatus.to_json f)));
           Util.option_map v.last_update_association_date
             (fun f -> ("last_update_association_date", (DateTime.to_json f)));
           Util.option_map v.date (fun f -> ("date", (DateTime.to_json f)));
           Util.option_map v.association_version
             (fun f -> ("association_version", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        association_version =
          (Util.option_map (Json.lookup j "association_version")
             String.of_json);
        date = (Util.option_map (Json.lookup j "date") DateTime.of_json);
        last_update_association_date =
          (Util.option_map (Json.lookup j "last_update_association_date")
             DateTime.of_json);
        status =
          (Util.option_map (Json.lookup j "status") AssociationStatus.of_json);
        overview =
          (Util.option_map (Json.lookup j "overview")
             AssociationOverview.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        automation_target_parameter_name =
          (Util.option_map (Json.lookup j "automation_target_parameter_name")
             String.of_json);
        parameters =
          (Util.option_map (Json.lookup j "parameters") Parameters.of_json);
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        schedule_expression =
          (Util.option_map (Json.lookup j "schedule_expression")
             String.of_json);
        output_location =
          (Util.option_map (Json.lookup j "output_location")
             InstanceAssociationOutputLocation.of_json);
        last_execution_date =
          (Util.option_map (Json.lookup j "last_execution_date")
             DateTime.of_json);
        last_successful_execution_date =
          (Util.option_map (Json.lookup j "last_successful_execution_date")
             DateTime.of_json);
        association_name =
          (Util.option_map (Json.lookup j "association_name") String.of_json);
        max_errors =
          (Util.option_map (Json.lookup j "max_errors") String.of_json);
        max_concurrency =
          (Util.option_map (Json.lookup j "max_concurrency") String.of_json);
        compliance_severity =
          (Util.option_map (Json.lookup j "compliance_severity")
             AssociationComplianceSeverity.of_json)
      }
  end
module FailedCreateAssociation =
  struct
    type t =
      {
      entry: CreateAssociationBatchRequestEntry.t option ;
      message: String.t option ;
      fault: Fault.t option }
    let make ?entry  ?message  ?fault  () = { entry; message; fault }
    let parse xml =
      Some
        {
          entry =
            (Util.option_bind (Xml.member "Entry" xml)
               CreateAssociationBatchRequestEntry.parse);
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse);
          fault = (Util.option_bind (Xml.member "Fault" xml) Fault.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.entry
                (fun f ->
                   Ezxmlm.make_tag "Entry"
                     ([], (CreateAssociationBatchRequestEntry.to_xml f)))])
            @
            [Util.option_map v.message
               (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
           @
           [Util.option_map v.fault
              (fun f -> Ezxmlm.make_tag "Fault" ([], (Fault.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fault (fun f -> ("fault", (Fault.to_json f)));
           Util.option_map v.message
             (fun f -> ("message", (String.to_json f)));
           Util.option_map v.entry
             (fun f ->
                ("entry", (CreateAssociationBatchRequestEntry.to_json f)))])
    let of_json j =
      {
        entry =
          (Util.option_map (Json.lookup j "entry")
             CreateAssociationBatchRequestEntry.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json);
        fault = (Util.option_map (Json.lookup j "fault") Fault.of_json)
      }
  end
module ComplianceItemEntry =
  struct
    type t =
      {
      id: String.t option ;
      title: String.t option ;
      severity: ComplianceSeverity.t ;
      status: ComplianceStatus.t ;
      details: ComplianceItemDetails.t option }
    let make ?id  ?title  ~severity  ~status  ?details  () =
      { id; title; severity; status; details }
    let parse xml =
      Some
        {
          id = (Util.option_bind (Xml.member "Id" xml) String.parse);
          title = (Util.option_bind (Xml.member "Title" xml) String.parse);
          severity =
            (Xml.required "Severity"
               (Util.option_bind (Xml.member "Severity" xml)
                  ComplianceSeverity.parse));
          status =
            (Xml.required "Status"
               (Util.option_bind (Xml.member "Status" xml)
                  ComplianceStatus.parse));
          details =
            (Util.option_bind (Xml.member "Details" xml)
               ComplianceItemDetails.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.id
                  (fun f -> Ezxmlm.make_tag "Id" ([], (String.to_xml f)))])
              @
              [Util.option_map v.title
                 (fun f -> Ezxmlm.make_tag "Title" ([], (String.to_xml f)))])
             @
             [Some
                (Ezxmlm.make_tag "Severity"
                   ([], (ComplianceSeverity.to_xml v.severity)))])
            @
            [Some
               (Ezxmlm.make_tag "Status"
                  ([], (ComplianceStatus.to_xml v.status)))])
           @
           [Util.option_map v.details
              (fun f ->
                 Ezxmlm.make_tag "Details"
                   ([], (ComplianceItemDetails.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.details
              (fun f -> ("details", (ComplianceItemDetails.to_json f)));
           Some ("status", (ComplianceStatus.to_json v.status));
           Some ("severity", (ComplianceSeverity.to_json v.severity));
           Util.option_map v.title (fun f -> ("title", (String.to_json f)));
           Util.option_map v.id (fun f -> ("id", (String.to_json f)))])
    let of_json j =
      {
        id = (Util.option_map (Json.lookup j "id") String.of_json);
        title = (Util.option_map (Json.lookup j "title") String.of_json);
        severity =
          (ComplianceSeverity.of_json
             (Util.of_option_exn (Json.lookup j "severity")));
        status =
          (ComplianceStatus.of_json
             (Util.of_option_exn (Json.lookup j "status")));
        details =
          (Util.option_map (Json.lookup j "details")
             ComplianceItemDetails.of_json)
      }
  end
module OpsItemNotifications =
  struct
    type t = OpsItemNotification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map OpsItemNotification.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list OpsItemNotification.to_query v
    let to_headers v =
      Headers.to_headers_list OpsItemNotification.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (OpsItemNotification.to_xml x))) v
    let to_json v = `List (List.map OpsItemNotification.to_json v)
    let of_json j = Json.to_list OpsItemNotification.of_json j
  end
module RelatedOpsItems =
  struct
    type t = RelatedOpsItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map RelatedOpsItem.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list RelatedOpsItem.to_query v
    let to_headers v = Headers.to_headers_list RelatedOpsItem.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (RelatedOpsItem.to_xml x))) v
    let to_json v = `List (List.map RelatedOpsItem.to_json v)
    let of_json j = Json.to_list RelatedOpsItem.of_json j
  end
module InventoryDeletionStatusItem =
  struct
    type t =
      {
      deletion_id: String.t option ;
      type_name: String.t option ;
      deletion_start_time: DateTime.t option ;
      last_status: InventoryDeletionStatus.t option ;
      last_status_message: String.t option ;
      deletion_summary: InventoryDeletionSummary.t option ;
      last_status_update_time: DateTime.t option }
    let make ?deletion_id  ?type_name  ?deletion_start_time  ?last_status 
      ?last_status_message  ?deletion_summary  ?last_status_update_time  () =
      {
        deletion_id;
        type_name;
        deletion_start_time;
        last_status;
        last_status_message;
        deletion_summary;
        last_status_update_time
      }
    let parse xml =
      Some
        {
          deletion_id =
            (Util.option_bind (Xml.member "DeletionId" xml) String.parse);
          type_name =
            (Util.option_bind (Xml.member "TypeName" xml) String.parse);
          deletion_start_time =
            (Util.option_bind (Xml.member "DeletionStartTime" xml)
               DateTime.parse);
          last_status =
            (Util.option_bind (Xml.member "LastStatus" xml)
               InventoryDeletionStatus.parse);
          last_status_message =
            (Util.option_bind (Xml.member "LastStatusMessage" xml)
               String.parse);
          deletion_summary =
            (Util.option_bind (Xml.member "DeletionSummary" xml)
               InventoryDeletionSummary.parse);
          last_status_update_time =
            (Util.option_bind (Xml.member "LastStatusUpdateTime" xml)
               DateTime.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Util.option_map v.deletion_id
                    (fun f ->
                       Ezxmlm.make_tag "DeletionId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.type_name
                   (fun f ->
                      Ezxmlm.make_tag "TypeName" ([], (String.to_xml f)))])
               @
               [Util.option_map v.deletion_start_time
                  (fun f ->
                     Ezxmlm.make_tag "DeletionStartTime"
                       ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.last_status
                 (fun f ->
                    Ezxmlm.make_tag "LastStatus"
                      ([], (InventoryDeletionStatus.to_xml f)))])
             @
             [Util.option_map v.last_status_message
                (fun f ->
                   Ezxmlm.make_tag "LastStatusMessage"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.deletion_summary
               (fun f ->
                  Ezxmlm.make_tag "DeletionSummary"
                    ([], (InventoryDeletionSummary.to_xml f)))])
           @
           [Util.option_map v.last_status_update_time
              (fun f ->
                 Ezxmlm.make_tag "LastStatusUpdateTime"
                   ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.last_status_update_time
              (fun f -> ("last_status_update_time", (DateTime.to_json f)));
           Util.option_map v.deletion_summary
             (fun f ->
                ("deletion_summary", (InventoryDeletionSummary.to_json f)));
           Util.option_map v.last_status_message
             (fun f -> ("last_status_message", (String.to_json f)));
           Util.option_map v.last_status
             (fun f -> ("last_status", (InventoryDeletionStatus.to_json f)));
           Util.option_map v.deletion_start_time
             (fun f -> ("deletion_start_time", (DateTime.to_json f)));
           Util.option_map v.type_name
             (fun f -> ("type_name", (String.to_json f)));
           Util.option_map v.deletion_id
             (fun f -> ("deletion_id", (String.to_json f)))])
    let of_json j =
      {
        deletion_id =
          (Util.option_map (Json.lookup j "deletion_id") String.of_json);
        type_name =
          (Util.option_map (Json.lookup j "type_name") String.of_json);
        deletion_start_time =
          (Util.option_map (Json.lookup j "deletion_start_time")
             DateTime.of_json);
        last_status =
          (Util.option_map (Json.lookup j "last_status")
             InventoryDeletionStatus.of_json);
        last_status_message =
          (Util.option_map (Json.lookup j "last_status_message")
             String.of_json);
        deletion_summary =
          (Util.option_map (Json.lookup j "deletion_summary")
             InventoryDeletionSummary.of_json);
        last_status_update_time =
          (Util.option_map (Json.lookup j "last_status_update_time")
             DateTime.of_json)
      }
  end
module SessionFilter =
  struct
    type t = {
      key: SessionFilterKey.t ;
      value: String.t }
    let make ~key  ~value  () = { key; value }
    let parse xml =
      Some
        {
          key =
            (Xml.required "key"
               (Util.option_bind (Xml.member "key" xml)
                  SessionFilterKey.parse));
          value =
            (Xml.required "value"
               (Util.option_bind (Xml.member "value" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "key" ([], (SessionFilterKey.to_xml v.key)))])
           @ [Some (Ezxmlm.make_tag "value" ([], (String.to_xml v.value)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("value", (String.to_json v.value));
           Some ("key", (SessionFilterKey.to_json v.key))])
    let of_json j =
      {
        key =
          (SessionFilterKey.of_json
             (Util.of_option_exn (Json.lookup j "key")));
        value = (String.of_json (Util.of_option_exn (Json.lookup j "value")))
      }
  end
module InstanceAssociationStatusInfo =
  struct
    type t =
      {
      association_id: String.t option ;
      name: String.t option ;
      document_version: String.t option ;
      association_version: String.t option ;
      instance_id: String.t option ;
      execution_date: DateTime.t option ;
      status: String.t option ;
      detailed_status: String.t option ;
      execution_summary: String.t option ;
      error_code: String.t option ;
      output_url: InstanceAssociationOutputUrl.t option ;
      association_name: String.t option }
    let make ?association_id  ?name  ?document_version  ?association_version 
      ?instance_id  ?execution_date  ?status  ?detailed_status 
      ?execution_summary  ?error_code  ?output_url  ?association_name  () =
      {
        association_id;
        name;
        document_version;
        association_version;
        instance_id;
        execution_date;
        status;
        detailed_status;
        execution_summary;
        error_code;
        output_url;
        association_name
      }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "AssociationId" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          association_version =
            (Util.option_bind (Xml.member "AssociationVersion" xml)
               String.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          execution_date =
            (Util.option_bind (Xml.member "ExecutionDate" xml) DateTime.parse);
          status = (Util.option_bind (Xml.member "Status" xml) String.parse);
          detailed_status =
            (Util.option_bind (Xml.member "DetailedStatus" xml) String.parse);
          execution_summary =
            (Util.option_bind (Xml.member "ExecutionSummary" xml)
               String.parse);
          error_code =
            (Util.option_bind (Xml.member "ErrorCode" xml) String.parse);
          output_url =
            (Util.option_bind (Xml.member "OutputUrl" xml)
               InstanceAssociationOutputUrl.parse);
          association_name =
            (Util.option_bind (Xml.member "AssociationName" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Util.option_map v.association_id
                         (fun f ->
                            Ezxmlm.make_tag "AssociationId"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.name
                        (fun f ->
                           Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.document_version
                       (fun f ->
                          Ezxmlm.make_tag "DocumentVersion"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.association_version
                      (fun f ->
                         Ezxmlm.make_tag "AssociationVersion"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.instance_id
                     (fun f ->
                        Ezxmlm.make_tag "InstanceId" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.execution_date
                    (fun f ->
                       Ezxmlm.make_tag "ExecutionDate"
                         ([], (DateTime.to_xml f)))])
                @
                [Util.option_map v.status
                   (fun f -> Ezxmlm.make_tag "Status" ([], (String.to_xml f)))])
               @
               [Util.option_map v.detailed_status
                  (fun f ->
                     Ezxmlm.make_tag "DetailedStatus" ([], (String.to_xml f)))])
              @
              [Util.option_map v.execution_summary
                 (fun f ->
                    Ezxmlm.make_tag "ExecutionSummary"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.error_code
                (fun f -> Ezxmlm.make_tag "ErrorCode" ([], (String.to_xml f)))])
            @
            [Util.option_map v.output_url
               (fun f ->
                  Ezxmlm.make_tag "OutputUrl"
                    ([], (InstanceAssociationOutputUrl.to_xml f)))])
           @
           [Util.option_map v.association_name
              (fun f ->
                 Ezxmlm.make_tag "AssociationName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_name
              (fun f -> ("association_name", (String.to_json f)));
           Util.option_map v.output_url
             (fun f ->
                ("output_url", (InstanceAssociationOutputUrl.to_json f)));
           Util.option_map v.error_code
             (fun f -> ("error_code", (String.to_json f)));
           Util.option_map v.execution_summary
             (fun f -> ("execution_summary", (String.to_json f)));
           Util.option_map v.detailed_status
             (fun f -> ("detailed_status", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.execution_date
             (fun f -> ("execution_date", (DateTime.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.association_version
             (fun f -> ("association_version", (String.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        association_version =
          (Util.option_map (Json.lookup j "association_version")
             String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        execution_date =
          (Util.option_map (Json.lookup j "execution_date") DateTime.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        detailed_status =
          (Util.option_map (Json.lookup j "detailed_status") String.of_json);
        execution_summary =
          (Util.option_map (Json.lookup j "execution_summary") String.of_json);
        error_code =
          (Util.option_map (Json.lookup j "error_code") String.of_json);
        output_url =
          (Util.option_map (Json.lookup j "output_url")
             InstanceAssociationOutputUrl.of_json);
        association_name =
          (Util.option_map (Json.lookup j "association_name") String.of_json)
      }
  end
module InventoryItemSchema =
  struct
    type t =
      {
      type_name: String.t ;
      version: String.t option ;
      attributes: InventoryItemAttributeList.t ;
      display_name: String.t option }
    let make ~type_name  ?version  ~attributes  ?display_name  () =
      { type_name; version; attributes; display_name }
    let parse xml =
      Some
        {
          type_name =
            (Xml.required "TypeName"
               (Util.option_bind (Xml.member "TypeName" xml) String.parse));
          version =
            (Util.option_bind (Xml.member "Version" xml) String.parse);
          attributes =
            (Xml.required "Attributes"
               (Util.option_bind (Xml.member "Attributes" xml)
                  InventoryItemAttributeList.parse));
          display_name =
            (Util.option_bind (Xml.member "DisplayName" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "TypeName"
                    ([], (String.to_xml v.type_name)))])
             @
             [Util.option_map v.version
                (fun f -> Ezxmlm.make_tag "Version" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Attributes"
                       ([], (InventoryItemAttributeList.to_xml [x]))))
               v.attributes))
           @
           [Util.option_map v.display_name
              (fun f -> Ezxmlm.make_tag "DisplayName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.display_name
              (fun f -> ("display_name", (String.to_json f)));
           Some
             ("attributes",
               (InventoryItemAttributeList.to_json v.attributes));
           Util.option_map v.version
             (fun f -> ("version", (String.to_json f)));
           Some ("type_name", (String.to_json v.type_name))])
    let of_json j =
      {
        type_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "type_name")));
        version = (Util.option_map (Json.lookup j "version") String.of_json);
        attributes =
          (InventoryItemAttributeList.of_json
             (Util.of_option_exn (Json.lookup j "attributes")));
        display_name =
          (Util.option_map (Json.lookup j "display_name") String.of_json)
      }
  end
module MaintenanceWindowExecutionTaskIdentity =
  struct
    type t =
      {
      window_execution_id: String.t option ;
      task_execution_id: String.t option ;
      status: MaintenanceWindowExecutionStatus.t option ;
      status_details: String.t option ;
      start_time: DateTime.t option ;
      end_time: DateTime.t option ;
      task_arn: String.t option ;
      task_type: MaintenanceWindowTaskType.t option }
    let make ?window_execution_id  ?task_execution_id  ?status 
      ?status_details  ?start_time  ?end_time  ?task_arn  ?task_type  () =
      {
        window_execution_id;
        task_execution_id;
        status;
        status_details;
        start_time;
        end_time;
        task_arn;
        task_type
      }
    let parse xml =
      Some
        {
          window_execution_id =
            (Util.option_bind (Xml.member "WindowExecutionId" xml)
               String.parse);
          task_execution_id =
            (Util.option_bind (Xml.member "TaskExecutionId" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml)
               MaintenanceWindowExecutionStatus.parse);
          status_details =
            (Util.option_bind (Xml.member "StatusDetails" xml) String.parse);
          start_time =
            (Util.option_bind (Xml.member "StartTime" xml) DateTime.parse);
          end_time =
            (Util.option_bind (Xml.member "EndTime" xml) DateTime.parse);
          task_arn =
            (Util.option_bind (Xml.member "TaskArn" xml) String.parse);
          task_type =
            (Util.option_bind (Xml.member "TaskType" xml)
               MaintenanceWindowTaskType.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((([] @
                  [Util.option_map v.window_execution_id
                     (fun f ->
                        Ezxmlm.make_tag "WindowExecutionId"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.task_execution_id
                    (fun f ->
                       Ezxmlm.make_tag "TaskExecutionId"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.status
                   (fun f ->
                      Ezxmlm.make_tag "Status"
                        ([], (MaintenanceWindowExecutionStatus.to_xml f)))])
               @
               [Util.option_map v.status_details
                  (fun f ->
                     Ezxmlm.make_tag "StatusDetails" ([], (String.to_xml f)))])
              @
              [Util.option_map v.start_time
                 (fun f ->
                    Ezxmlm.make_tag "StartTime" ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.end_time
                (fun f -> Ezxmlm.make_tag "EndTime" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.task_arn
               (fun f -> Ezxmlm.make_tag "TaskArn" ([], (String.to_xml f)))])
           @
           [Util.option_map v.task_type
              (fun f ->
                 Ezxmlm.make_tag "TaskType"
                   ([], (MaintenanceWindowTaskType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.task_type
              (fun f -> ("task_type", (MaintenanceWindowTaskType.to_json f)));
           Util.option_map v.task_arn
             (fun f -> ("task_arn", (String.to_json f)));
           Util.option_map v.end_time
             (fun f -> ("end_time", (DateTime.to_json f)));
           Util.option_map v.start_time
             (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.status_details
             (fun f -> ("status_details", (String.to_json f)));
           Util.option_map v.status
             (fun f ->
                ("status", (MaintenanceWindowExecutionStatus.to_json f)));
           Util.option_map v.task_execution_id
             (fun f -> ("task_execution_id", (String.to_json f)));
           Util.option_map v.window_execution_id
             (fun f -> ("window_execution_id", (String.to_json f)))])
    let of_json j =
      {
        window_execution_id =
          (Util.option_map (Json.lookup j "window_execution_id")
             String.of_json);
        task_execution_id =
          (Util.option_map (Json.lookup j "task_execution_id") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             MaintenanceWindowExecutionStatus.of_json);
        status_details =
          (Util.option_map (Json.lookup j "status_details") String.of_json);
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json);
        end_time =
          (Util.option_map (Json.lookup j "end_time") DateTime.of_json);
        task_arn =
          (Util.option_map (Json.lookup j "task_arn") String.of_json);
        task_type =
          (Util.option_map (Json.lookup j "task_type")
             MaintenanceWindowTaskType.of_json)
      }
  end
module MaintenanceWindowIdentity =
  struct
    type t =
      {
      window_id: String.t option ;
      name: String.t option ;
      description: String.t option ;
      enabled: Boolean.t option ;
      duration: Integer.t option ;
      cutoff: Integer.t option ;
      schedule: String.t option ;
      schedule_timezone: String.t option ;
      end_date: String.t option ;
      start_date: String.t option ;
      next_execution_time: String.t option }
    let make ?window_id  ?name  ?description  ?enabled  ?duration  ?cutoff 
      ?schedule  ?schedule_timezone  ?end_date  ?start_date 
      ?next_execution_time  () =
      {
        window_id;
        name;
        description;
        enabled;
        duration;
        cutoff;
        schedule;
        schedule_timezone;
        end_date;
        start_date;
        next_execution_time
      }
    let parse xml =
      Some
        {
          window_id =
            (Util.option_bind (Xml.member "WindowId" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse);
          duration =
            (Util.option_bind (Xml.member "Duration" xml) Integer.parse);
          cutoff = (Util.option_bind (Xml.member "Cutoff" xml) Integer.parse);
          schedule =
            (Util.option_bind (Xml.member "Schedule" xml) String.parse);
          schedule_timezone =
            (Util.option_bind (Xml.member "ScheduleTimezone" xml)
               String.parse);
          end_date =
            (Util.option_bind (Xml.member "EndDate" xml) String.parse);
          start_date =
            (Util.option_bind (Xml.member "StartDate" xml) String.parse);
          next_execution_time =
            (Util.option_bind (Xml.member "NextExecutionTime" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.window_id
                        (fun f ->
                           Ezxmlm.make_tag "WindowId" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.name
                       (fun f ->
                          Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.description
                      (fun f ->
                         Ezxmlm.make_tag "Description"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.enabled
                     (fun f ->
                        Ezxmlm.make_tag "Enabled" ([], (Boolean.to_xml f)))])
                 @
                 [Util.option_map v.duration
                    (fun f ->
                       Ezxmlm.make_tag "Duration" ([], (Integer.to_xml f)))])
                @
                [Util.option_map v.cutoff
                   (fun f ->
                      Ezxmlm.make_tag "Cutoff" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.schedule
                  (fun f ->
                     Ezxmlm.make_tag "Schedule" ([], (String.to_xml f)))])
              @
              [Util.option_map v.schedule_timezone
                 (fun f ->
                    Ezxmlm.make_tag "ScheduleTimezone"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.end_date
                (fun f -> Ezxmlm.make_tag "EndDate" ([], (String.to_xml f)))])
            @
            [Util.option_map v.start_date
               (fun f -> Ezxmlm.make_tag "StartDate" ([], (String.to_xml f)))])
           @
           [Util.option_map v.next_execution_time
              (fun f ->
                 Ezxmlm.make_tag "NextExecutionTime" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_execution_time
              (fun f -> ("next_execution_time", (String.to_json f)));
           Util.option_map v.start_date
             (fun f -> ("start_date", (String.to_json f)));
           Util.option_map v.end_date
             (fun f -> ("end_date", (String.to_json f)));
           Util.option_map v.schedule_timezone
             (fun f -> ("schedule_timezone", (String.to_json f)));
           Util.option_map v.schedule
             (fun f -> ("schedule", (String.to_json f)));
           Util.option_map v.cutoff
             (fun f -> ("cutoff", (Integer.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Integer.to_json f)));
           Util.option_map v.enabled
             (fun f -> ("enabled", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.window_id
             (fun f -> ("window_id", (String.to_json f)))])
    let of_json j =
      {
        window_id =
          (Util.option_map (Json.lookup j "window_id") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json);
        duration =
          (Util.option_map (Json.lookup j "duration") Integer.of_json);
        cutoff = (Util.option_map (Json.lookup j "cutoff") Integer.of_json);
        schedule =
          (Util.option_map (Json.lookup j "schedule") String.of_json);
        schedule_timezone =
          (Util.option_map (Json.lookup j "schedule_timezone") String.of_json);
        end_date =
          (Util.option_map (Json.lookup j "end_date") String.of_json);
        start_date =
          (Util.option_map (Json.lookup j "start_date") String.of_json);
        next_execution_time =
          (Util.option_map (Json.lookup j "next_execution_time")
             String.of_json)
      }
  end
module ParameterStringFilter =
  struct
    type t =
      {
      key: String.t ;
      option: String.t option ;
      values: ParameterStringFilterValueList.t }
    let make ~key  ?option  ?(values= [])  () = { key; option; values }
    let parse xml =
      Some
        {
          key =
            (Xml.required "Key"
               (Util.option_bind (Xml.member "Key" xml) String.parse));
          option = (Util.option_bind (Xml.member "Option" xml) String.parse);
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "Values" xml)
                  ParameterStringFilterValueList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @ [Some (Ezxmlm.make_tag "Key" ([], (String.to_xml v.key)))]) @
            [Util.option_map v.option
               (fun f -> Ezxmlm.make_tag "Option" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Values"
                      ([], (ParameterStringFilterValueList.to_xml [x]))))
              v.values))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("values", (ParameterStringFilterValueList.to_json v.values));
           Util.option_map v.option (fun f -> ("option", (String.to_json f)));
           Some ("key", (String.to_json v.key))])
    let of_json j =
      {
        key = (String.of_json (Util.of_option_exn (Json.lookup j "key")));
        option = (Util.option_map (Json.lookup j "option") String.of_json);
        values =
          (ParameterStringFilterValueList.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module AttachmentsSource =
  struct
    type t =
      {
      key: AttachmentsSourceKey.t option ;
      values: AttachmentsSourceValues.t ;
      name: String.t option }
    let make ?key  ?(values= [])  ?name  () = { key; values; name }
    let parse xml =
      Some
        {
          key =
            (Util.option_bind (Xml.member "Key" xml)
               AttachmentsSourceKey.parse);
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "Values" xml)
                  AttachmentsSourceValues.parse));
          name = (Util.option_bind (Xml.member "Name" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.key
                (fun f ->
                   Ezxmlm.make_tag "Key"
                     ([], (AttachmentsSourceKey.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Values"
                       ([], (AttachmentsSourceValues.to_xml [x])))) v.values))
           @
           [Util.option_map v.name
              (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Some ("values", (AttachmentsSourceValues.to_json v.values));
           Util.option_map v.key
             (fun f -> ("key", (AttachmentsSourceKey.to_json f)))])
    let of_json j =
      {
        key =
          (Util.option_map (Json.lookup j "key") AttachmentsSourceKey.of_json);
        values =
          (AttachmentsSourceValues.of_json
             (Util.of_option_exn (Json.lookup j "values")));
        name = (Util.option_map (Json.lookup j "name") String.of_json)
      }
  end
module AccountSharingInfo =
  struct
    type t =
      {
      account_id: String.t option ;
      shared_document_version: String.t option }
    let make ?account_id  ?shared_document_version  () =
      { account_id; shared_document_version }
    let parse xml =
      Some
        {
          account_id =
            (Util.option_bind (Xml.member "AccountId" xml) String.parse);
          shared_document_version =
            (Util.option_bind (Xml.member "SharedDocumentVersion" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.account_id
               (fun f -> Ezxmlm.make_tag "AccountId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.shared_document_version
              (fun f ->
                 Ezxmlm.make_tag "SharedDocumentVersion"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.shared_document_version
              (fun f -> ("shared_document_version", (String.to_json f)));
           Util.option_map v.account_id
             (fun f -> ("account_id", (String.to_json f)))])
    let of_json j =
      {
        account_id =
          (Util.option_map (Json.lookup j "account_id") String.of_json);
        shared_document_version =
          (Util.option_map (Json.lookup j "shared_document_version")
             String.of_json)
      }
  end
module MaintenanceWindowExecutionTaskInvocationIdentity =
  struct
    type t =
      {
      window_execution_id: String.t option ;
      task_execution_id: String.t option ;
      invocation_id: String.t option ;
      execution_id: String.t option ;
      task_type: MaintenanceWindowTaskType.t option ;
      parameters: String.t option ;
      status: MaintenanceWindowExecutionStatus.t option ;
      status_details: String.t option ;
      start_time: DateTime.t option ;
      end_time: DateTime.t option ;
      owner_information: String.t option ;
      window_target_id: String.t option }
    let make ?window_execution_id  ?task_execution_id  ?invocation_id 
      ?execution_id  ?task_type  ?parameters  ?status  ?status_details 
      ?start_time  ?end_time  ?owner_information  ?window_target_id  () =
      {
        window_execution_id;
        task_execution_id;
        invocation_id;
        execution_id;
        task_type;
        parameters;
        status;
        status_details;
        start_time;
        end_time;
        owner_information;
        window_target_id
      }
    let parse xml =
      Some
        {
          window_execution_id =
            (Util.option_bind (Xml.member "WindowExecutionId" xml)
               String.parse);
          task_execution_id =
            (Util.option_bind (Xml.member "TaskExecutionId" xml) String.parse);
          invocation_id =
            (Util.option_bind (Xml.member "InvocationId" xml) String.parse);
          execution_id =
            (Util.option_bind (Xml.member "ExecutionId" xml) String.parse);
          task_type =
            (Util.option_bind (Xml.member "TaskType" xml)
               MaintenanceWindowTaskType.parse);
          parameters =
            (Util.option_bind (Xml.member "Parameters" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml)
               MaintenanceWindowExecutionStatus.parse);
          status_details =
            (Util.option_bind (Xml.member "StatusDetails" xml) String.parse);
          start_time =
            (Util.option_bind (Xml.member "StartTime" xml) DateTime.parse);
          end_time =
            (Util.option_bind (Xml.member "EndTime" xml) DateTime.parse);
          owner_information =
            (Util.option_bind (Xml.member "OwnerInformation" xml)
               String.parse);
          window_target_id =
            (Util.option_bind (Xml.member "WindowTargetId" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Util.option_map v.window_execution_id
                         (fun f ->
                            Ezxmlm.make_tag "WindowExecutionId"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.task_execution_id
                        (fun f ->
                           Ezxmlm.make_tag "TaskExecutionId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.invocation_id
                       (fun f ->
                          Ezxmlm.make_tag "InvocationId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.execution_id
                      (fun f ->
                         Ezxmlm.make_tag "ExecutionId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.task_type
                     (fun f ->
                        Ezxmlm.make_tag "TaskType"
                          ([], (MaintenanceWindowTaskType.to_xml f)))])
                 @
                 [Util.option_map v.parameters
                    (fun f ->
                       Ezxmlm.make_tag "Parameters" ([], (String.to_xml f)))])
                @
                [Util.option_map v.status
                   (fun f ->
                      Ezxmlm.make_tag "Status"
                        ([], (MaintenanceWindowExecutionStatus.to_xml f)))])
               @
               [Util.option_map v.status_details
                  (fun f ->
                     Ezxmlm.make_tag "StatusDetails" ([], (String.to_xml f)))])
              @
              [Util.option_map v.start_time
                 (fun f ->
                    Ezxmlm.make_tag "StartTime" ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.end_time
                (fun f -> Ezxmlm.make_tag "EndTime" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.owner_information
               (fun f ->
                  Ezxmlm.make_tag "OwnerInformation" ([], (String.to_xml f)))])
           @
           [Util.option_map v.window_target_id
              (fun f ->
                 Ezxmlm.make_tag "WindowTargetId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.window_target_id
              (fun f -> ("window_target_id", (String.to_json f)));
           Util.option_map v.owner_information
             (fun f -> ("owner_information", (String.to_json f)));
           Util.option_map v.end_time
             (fun f -> ("end_time", (DateTime.to_json f)));
           Util.option_map v.start_time
             (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.status_details
             (fun f -> ("status_details", (String.to_json f)));
           Util.option_map v.status
             (fun f ->
                ("status", (MaintenanceWindowExecutionStatus.to_json f)));
           Util.option_map v.parameters
             (fun f -> ("parameters", (String.to_json f)));
           Util.option_map v.task_type
             (fun f -> ("task_type", (MaintenanceWindowTaskType.to_json f)));
           Util.option_map v.execution_id
             (fun f -> ("execution_id", (String.to_json f)));
           Util.option_map v.invocation_id
             (fun f -> ("invocation_id", (String.to_json f)));
           Util.option_map v.task_execution_id
             (fun f -> ("task_execution_id", (String.to_json f)));
           Util.option_map v.window_execution_id
             (fun f -> ("window_execution_id", (String.to_json f)))])
    let of_json j =
      {
        window_execution_id =
          (Util.option_map (Json.lookup j "window_execution_id")
             String.of_json);
        task_execution_id =
          (Util.option_map (Json.lookup j "task_execution_id") String.of_json);
        invocation_id =
          (Util.option_map (Json.lookup j "invocation_id") String.of_json);
        execution_id =
          (Util.option_map (Json.lookup j "execution_id") String.of_json);
        task_type =
          (Util.option_map (Json.lookup j "task_type")
             MaintenanceWindowTaskType.of_json);
        parameters =
          (Util.option_map (Json.lookup j "parameters") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             MaintenanceWindowExecutionStatus.of_json);
        status_details =
          (Util.option_map (Json.lookup j "status_details") String.of_json);
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json);
        end_time =
          (Util.option_map (Json.lookup j "end_time") DateTime.of_json);
        owner_information =
          (Util.option_map (Json.lookup j "owner_information") String.of_json);
        window_target_id =
          (Util.option_map (Json.lookup j "window_target_id") String.of_json)
      }
  end
module MaintenanceWindowIdentityForTarget =
  struct
    type t = {
      window_id: String.t option ;
      name: String.t option }
    let make ?window_id  ?name  () = { window_id; name }
    let parse xml =
      Some
        {
          window_id =
            (Util.option_bind (Xml.member "WindowId" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.window_id
               (fun f -> Ezxmlm.make_tag "WindowId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.name
              (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.window_id
             (fun f -> ("window_id", (String.to_json f)))])
    let of_json j =
      {
        window_id =
          (Util.option_map (Json.lookup j "window_id") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json)
      }
  end
module DescribeActivationsFilter =
  struct
    type t =
      {
      filter_key: DescribeActivationsFilterKeys.t option ;
      filter_values: StringList.t }
    let make ?filter_key  ?(filter_values= [])  () =
      { filter_key; filter_values }
    let parse xml =
      Some
        {
          filter_key =
            (Util.option_bind (Xml.member "FilterKey" xml)
               DescribeActivationsFilterKeys.parse);
          filter_values =
            (Util.of_option []
               (Util.option_bind (Xml.member "FilterValues" xml)
                  StringList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.filter_key
               (fun f ->
                  Ezxmlm.make_tag "FilterKey"
                    ([], (DescribeActivationsFilterKeys.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "FilterValues"
                      ([], (StringList.to_xml [x])))) v.filter_values))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filter_values", (StringList.to_json v.filter_values));
           Util.option_map v.filter_key
             (fun f ->
                ("filter_key", (DescribeActivationsFilterKeys.to_json f)))])
    let of_json j =
      {
        filter_key =
          (Util.option_map (Json.lookup j "filter_key")
             DescribeActivationsFilterKeys.of_json);
        filter_values =
          (StringList.of_json
             (Util.of_option_exn (Json.lookup j "filter_values")))
      }
  end
module CommandInvocation =
  struct
    type t =
      {
      command_id: String.t option ;
      instance_id: String.t option ;
      instance_name: String.t option ;
      comment: String.t option ;
      document_name: String.t option ;
      document_version: String.t option ;
      requested_date_time: DateTime.t option ;
      status: CommandInvocationStatus.t option ;
      status_details: String.t option ;
      trace_output: String.t option ;
      standard_output_url: String.t option ;
      standard_error_url: String.t option ;
      command_plugins: CommandPluginList.t ;
      service_role: String.t option ;
      notification_config: NotificationConfig.t option ;
      cloud_watch_output_config: CloudWatchOutputConfig.t option }
    let make ?command_id  ?instance_id  ?instance_name  ?comment 
      ?document_name  ?document_version  ?requested_date_time  ?status 
      ?status_details  ?trace_output  ?standard_output_url 
      ?standard_error_url  ?(command_plugins= [])  ?service_role 
      ?notification_config  ?cloud_watch_output_config  () =
      {
        command_id;
        instance_id;
        instance_name;
        comment;
        document_name;
        document_version;
        requested_date_time;
        status;
        status_details;
        trace_output;
        standard_output_url;
        standard_error_url;
        command_plugins;
        service_role;
        notification_config;
        cloud_watch_output_config
      }
    let parse xml =
      Some
        {
          command_id =
            (Util.option_bind (Xml.member "CommandId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          instance_name =
            (Util.option_bind (Xml.member "InstanceName" xml) String.parse);
          comment =
            (Util.option_bind (Xml.member "Comment" xml) String.parse);
          document_name =
            (Util.option_bind (Xml.member "DocumentName" xml) String.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          requested_date_time =
            (Util.option_bind (Xml.member "RequestedDateTime" xml)
               DateTime.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml)
               CommandInvocationStatus.parse);
          status_details =
            (Util.option_bind (Xml.member "StatusDetails" xml) String.parse);
          trace_output =
            (Util.option_bind (Xml.member "TraceOutput" xml) String.parse);
          standard_output_url =
            (Util.option_bind (Xml.member "StandardOutputUrl" xml)
               String.parse);
          standard_error_url =
            (Util.option_bind (Xml.member "StandardErrorUrl" xml)
               String.parse);
          command_plugins =
            (Util.of_option []
               (Util.option_bind (Xml.member "CommandPlugins" xml)
                  CommandPluginList.parse));
          service_role =
            (Util.option_bind (Xml.member "ServiceRole" xml) String.parse);
          notification_config =
            (Util.option_bind (Xml.member "NotificationConfig" xml)
               NotificationConfig.parse);
          cloud_watch_output_config =
            (Util.option_bind (Xml.member "CloudWatchOutputConfig" xml)
               CloudWatchOutputConfig.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((([] @
                          [Util.option_map v.command_id
                             (fun f ->
                                Ezxmlm.make_tag "CommandId"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.instance_id
                            (fun f ->
                               Ezxmlm.make_tag "InstanceId"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.instance_name
                           (fun f ->
                              Ezxmlm.make_tag "InstanceName"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.comment
                          (fun f ->
                             Ezxmlm.make_tag "Comment"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.document_name
                         (fun f ->
                            Ezxmlm.make_tag "DocumentName"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.document_version
                        (fun f ->
                           Ezxmlm.make_tag "DocumentVersion"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.requested_date_time
                       (fun f ->
                          Ezxmlm.make_tag "RequestedDateTime"
                            ([], (DateTime.to_xml f)))])
                   @
                   [Util.option_map v.status
                      (fun f ->
                         Ezxmlm.make_tag "Status"
                           ([], (CommandInvocationStatus.to_xml f)))])
                  @
                  [Util.option_map v.status_details
                     (fun f ->
                        Ezxmlm.make_tag "StatusDetails"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.trace_output
                    (fun f ->
                       Ezxmlm.make_tag "TraceOutput" ([], (String.to_xml f)))])
                @
                [Util.option_map v.standard_output_url
                   (fun f ->
                      Ezxmlm.make_tag "StandardOutputUrl"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.standard_error_url
                  (fun f ->
                     Ezxmlm.make_tag "StandardErrorUrl"
                       ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "CommandPlugins"
                         ([], (CommandPluginList.to_xml [x]))))
                 v.command_plugins))
             @
             [Util.option_map v.service_role
                (fun f ->
                   Ezxmlm.make_tag "ServiceRole" ([], (String.to_xml f)))])
            @
            [Util.option_map v.notification_config
               (fun f ->
                  Ezxmlm.make_tag "NotificationConfig"
                    ([], (NotificationConfig.to_xml f)))])
           @
           [Util.option_map v.cloud_watch_output_config
              (fun f ->
                 Ezxmlm.make_tag "CloudWatchOutputConfig"
                   ([], (CloudWatchOutputConfig.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cloud_watch_output_config
              (fun f ->
                 ("cloud_watch_output_config",
                   (CloudWatchOutputConfig.to_json f)));
           Util.option_map v.notification_config
             (fun f ->
                ("notification_config", (NotificationConfig.to_json f)));
           Util.option_map v.service_role
             (fun f -> ("service_role", (String.to_json f)));
           Some
             ("command_plugins",
               (CommandPluginList.to_json v.command_plugins));
           Util.option_map v.standard_error_url
             (fun f -> ("standard_error_url", (String.to_json f)));
           Util.option_map v.standard_output_url
             (fun f -> ("standard_output_url", (String.to_json f)));
           Util.option_map v.trace_output
             (fun f -> ("trace_output", (String.to_json f)));
           Util.option_map v.status_details
             (fun f -> ("status_details", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (CommandInvocationStatus.to_json f)));
           Util.option_map v.requested_date_time
             (fun f -> ("requested_date_time", (DateTime.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.document_name
             (fun f -> ("document_name", (String.to_json f)));
           Util.option_map v.comment
             (fun f -> ("comment", (String.to_json f)));
           Util.option_map v.instance_name
             (fun f -> ("instance_name", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.command_id
             (fun f -> ("command_id", (String.to_json f)))])
    let of_json j =
      {
        command_id =
          (Util.option_map (Json.lookup j "command_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_name =
          (Util.option_map (Json.lookup j "instance_name") String.of_json);
        comment = (Util.option_map (Json.lookup j "comment") String.of_json);
        document_name =
          (Util.option_map (Json.lookup j "document_name") String.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        requested_date_time =
          (Util.option_map (Json.lookup j "requested_date_time")
             DateTime.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             CommandInvocationStatus.of_json);
        status_details =
          (Util.option_map (Json.lookup j "status_details") String.of_json);
        trace_output =
          (Util.option_map (Json.lookup j "trace_output") String.of_json);
        standard_output_url =
          (Util.option_map (Json.lookup j "standard_output_url")
             String.of_json);
        standard_error_url =
          (Util.option_map (Json.lookup j "standard_error_url")
             String.of_json);
        command_plugins =
          (CommandPluginList.of_json
             (Util.of_option_exn (Json.lookup j "command_plugins")));
        service_role =
          (Util.option_map (Json.lookup j "service_role") String.of_json);
        notification_config =
          (Util.option_map (Json.lookup j "notification_config")
             NotificationConfig.of_json);
        cloud_watch_output_config =
          (Util.option_map (Json.lookup j "cloud_watch_output_config")
             CloudWatchOutputConfig.of_json)
      }
  end
module InventoryItem =
  struct
    type t =
      {
      type_name: String.t ;
      schema_version: String.t ;
      capture_time: String.t ;
      content_hash: String.t option ;
      content: InventoryItemEntryList.t ;
      context: InventoryItemContentContext.t option }
    let make ~type_name  ~schema_version  ~capture_time  ?content_hash 
      ?(content= [])  ?context  () =
      {
        type_name;
        schema_version;
        capture_time;
        content_hash;
        content;
        context
      }
    let parse xml =
      Some
        {
          type_name =
            (Xml.required "TypeName"
               (Util.option_bind (Xml.member "TypeName" xml) String.parse));
          schema_version =
            (Xml.required "SchemaVersion"
               (Util.option_bind (Xml.member "SchemaVersion" xml)
                  String.parse));
          capture_time =
            (Xml.required "CaptureTime"
               (Util.option_bind (Xml.member "CaptureTime" xml) String.parse));
          content_hash =
            (Util.option_bind (Xml.member "ContentHash" xml) String.parse);
          content =
            (Util.of_option []
               (Util.option_bind (Xml.member "Content" xml)
                  InventoryItemEntryList.parse));
          context =
            (Util.option_bind (Xml.member "Context" xml)
               InventoryItemContentContext.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Some
                   (Ezxmlm.make_tag "TypeName"
                      ([], (String.to_xml v.type_name)))])
               @
               [Some
                  (Ezxmlm.make_tag "SchemaVersion"
                     ([], (String.to_xml v.schema_version)))])
              @
              [Some
                 (Ezxmlm.make_tag "CaptureTime"
                    ([], (String.to_xml v.capture_time)))])
             @
             [Util.option_map v.content_hash
                (fun f ->
                   Ezxmlm.make_tag "ContentHash" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Content"
                       ([], (InventoryItemEntryList.to_xml [x])))) v.content))
           @
           [Util.option_map v.context
              (fun f ->
                 Ezxmlm.make_tag "Context"
                   ([], (InventoryItemContentContext.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.context
              (fun f -> ("context", (InventoryItemContentContext.to_json f)));
           Some ("content", (InventoryItemEntryList.to_json v.content));
           Util.option_map v.content_hash
             (fun f -> ("content_hash", (String.to_json f)));
           Some ("capture_time", (String.to_json v.capture_time));
           Some ("schema_version", (String.to_json v.schema_version));
           Some ("type_name", (String.to_json v.type_name))])
    let of_json j =
      {
        type_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "type_name")));
        schema_version =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "schema_version")));
        capture_time =
          (String.of_json (Util.of_option_exn (Json.lookup j "capture_time")));
        content_hash =
          (Util.option_map (Json.lookup j "content_hash") String.of_json);
        content =
          (InventoryItemEntryList.of_json
             (Util.of_option_exn (Json.lookup j "content")));
        context =
          (Util.option_map (Json.lookup j "context")
             InventoryItemContentContext.of_json)
      }
  end
module OpsItemFilter =
  struct
    type t =
      {
      key: OpsItemFilterKey.t ;
      values: OpsItemFilterValues.t ;
      operator: OpsItemFilterOperator.t }
    let make ~key  ~values  ~operator  () = { key; values; operator }
    let parse xml =
      Some
        {
          key =
            (Xml.required "Key"
               (Util.option_bind (Xml.member "Key" xml)
                  OpsItemFilterKey.parse));
          values =
            (Xml.required "Values"
               (Util.option_bind (Xml.member "Values" xml)
                  OpsItemFilterValues.parse));
          operator =
            (Xml.required "Operator"
               (Util.option_bind (Xml.member "Operator" xml)
                  OpsItemFilterOperator.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "Key" ([], (OpsItemFilterKey.to_xml v.key)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Values"
                       ([], (OpsItemFilterValues.to_xml [x])))) v.values))
           @
           [Some
              (Ezxmlm.make_tag "Operator"
                 ([], (OpsItemFilterOperator.to_xml v.operator)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("operator", (OpsItemFilterOperator.to_json v.operator));
           Some ("values", (OpsItemFilterValues.to_json v.values));
           Some ("key", (OpsItemFilterKey.to_json v.key))])
    let of_json j =
      {
        key =
          (OpsItemFilterKey.of_json
             (Util.of_option_exn (Json.lookup j "key")));
        values =
          (OpsItemFilterValues.of_json
             (Util.of_option_exn (Json.lookup j "values")));
        operator =
          (OpsItemFilterOperator.of_json
             (Util.of_option_exn (Json.lookup j "operator")))
      }
  end
module AttachmentContent =
  struct
    type t =
      {
      name: String.t option ;
      size: Long.t option ;
      hash: String.t option ;
      hash_type: AttachmentHashType.t option ;
      url: String.t option }
    let make ?name  ?size  ?hash  ?hash_type  ?url  () =
      { name; size; hash; hash_type; url }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          size = (Util.option_bind (Xml.member "Size" xml) Long.parse);
          hash = (Util.option_bind (Xml.member "Hash" xml) String.parse);
          hash_type =
            (Util.option_bind (Xml.member "HashType" xml)
               AttachmentHashType.parse);
          url = (Util.option_bind (Xml.member "Url" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.name
                  (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
              @
              [Util.option_map v.size
                 (fun f -> Ezxmlm.make_tag "Size" ([], (Long.to_xml f)))])
             @
             [Util.option_map v.hash
                (fun f -> Ezxmlm.make_tag "Hash" ([], (String.to_xml f)))])
            @
            [Util.option_map v.hash_type
               (fun f ->
                  Ezxmlm.make_tag "HashType"
                    ([], (AttachmentHashType.to_xml f)))])
           @
           [Util.option_map v.url
              (fun f -> Ezxmlm.make_tag "Url" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.hash_type
             (fun f -> ("hash_type", (AttachmentHashType.to_json f)));
           Util.option_map v.hash (fun f -> ("hash", (String.to_json f)));
           Util.option_map v.size (fun f -> ("size", (Long.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        size = (Util.option_map (Json.lookup j "size") Long.of_json);
        hash = (Util.option_map (Json.lookup j "hash") String.of_json);
        hash_type =
          (Util.option_map (Json.lookup j "hash_type")
             AttachmentHashType.of_json);
        url = (Util.option_map (Json.lookup j "url") String.of_json)
      }
  end
module ResourceDataSyncItem =
  struct
    type t =
      {
      sync_name: String.t option ;
      sync_type: String.t option ;
      sync_source: ResourceDataSyncSourceWithState.t option ;
      s3_destination: ResourceDataSyncS3Destination.t option ;
      last_sync_time: DateTime.t option ;
      last_successful_sync_time: DateTime.t option ;
      sync_last_modified_time: DateTime.t option ;
      last_status: LastResourceDataSyncStatus.t option ;
      sync_created_time: DateTime.t option ;
      last_sync_status_message: String.t option }
    let make ?sync_name  ?sync_type  ?sync_source  ?s3_destination 
      ?last_sync_time  ?last_successful_sync_time  ?sync_last_modified_time 
      ?last_status  ?sync_created_time  ?last_sync_status_message  () =
      {
        sync_name;
        sync_type;
        sync_source;
        s3_destination;
        last_sync_time;
        last_successful_sync_time;
        sync_last_modified_time;
        last_status;
        sync_created_time;
        last_sync_status_message
      }
    let parse xml =
      Some
        {
          sync_name =
            (Util.option_bind (Xml.member "SyncName" xml) String.parse);
          sync_type =
            (Util.option_bind (Xml.member "SyncType" xml) String.parse);
          sync_source =
            (Util.option_bind (Xml.member "SyncSource" xml)
               ResourceDataSyncSourceWithState.parse);
          s3_destination =
            (Util.option_bind (Xml.member "S3Destination" xml)
               ResourceDataSyncS3Destination.parse);
          last_sync_time =
            (Util.option_bind (Xml.member "LastSyncTime" xml) DateTime.parse);
          last_successful_sync_time =
            (Util.option_bind (Xml.member "LastSuccessfulSyncTime" xml)
               DateTime.parse);
          sync_last_modified_time =
            (Util.option_bind (Xml.member "SyncLastModifiedTime" xml)
               DateTime.parse);
          last_status =
            (Util.option_bind (Xml.member "LastStatus" xml)
               LastResourceDataSyncStatus.parse);
          sync_created_time =
            (Util.option_bind (Xml.member "SyncCreatedTime" xml)
               DateTime.parse);
          last_sync_status_message =
            (Util.option_bind (Xml.member "LastSyncStatusMessage" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.sync_name
                       (fun f ->
                          Ezxmlm.make_tag "SyncName" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.sync_type
                      (fun f ->
                         Ezxmlm.make_tag "SyncType" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.sync_source
                     (fun f ->
                        Ezxmlm.make_tag "SyncSource"
                          ([], (ResourceDataSyncSourceWithState.to_xml f)))])
                 @
                 [Util.option_map v.s3_destination
                    (fun f ->
                       Ezxmlm.make_tag "S3Destination"
                         ([], (ResourceDataSyncS3Destination.to_xml f)))])
                @
                [Util.option_map v.last_sync_time
                   (fun f ->
                      Ezxmlm.make_tag "LastSyncTime"
                        ([], (DateTime.to_xml f)))])
               @
               [Util.option_map v.last_successful_sync_time
                  (fun f ->
                     Ezxmlm.make_tag "LastSuccessfulSyncTime"
                       ([], (DateTime.to_xml f)))])
              @
              [Util.option_map v.sync_last_modified_time
                 (fun f ->
                    Ezxmlm.make_tag "SyncLastModifiedTime"
                      ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.last_status
                (fun f ->
                   Ezxmlm.make_tag "LastStatus"
                     ([], (LastResourceDataSyncStatus.to_xml f)))])
            @
            [Util.option_map v.sync_created_time
               (fun f ->
                  Ezxmlm.make_tag "SyncCreatedTime" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.last_sync_status_message
              (fun f ->
                 Ezxmlm.make_tag "LastSyncStatusMessage"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.last_sync_status_message
              (fun f -> ("last_sync_status_message", (String.to_json f)));
           Util.option_map v.sync_created_time
             (fun f -> ("sync_created_time", (DateTime.to_json f)));
           Util.option_map v.last_status
             (fun f ->
                ("last_status", (LastResourceDataSyncStatus.to_json f)));
           Util.option_map v.sync_last_modified_time
             (fun f -> ("sync_last_modified_time", (DateTime.to_json f)));
           Util.option_map v.last_successful_sync_time
             (fun f -> ("last_successful_sync_time", (DateTime.to_json f)));
           Util.option_map v.last_sync_time
             (fun f -> ("last_sync_time", (DateTime.to_json f)));
           Util.option_map v.s3_destination
             (fun f ->
                ("s3_destination", (ResourceDataSyncS3Destination.to_json f)));
           Util.option_map v.sync_source
             (fun f ->
                ("sync_source", (ResourceDataSyncSourceWithState.to_json f)));
           Util.option_map v.sync_type
             (fun f -> ("sync_type", (String.to_json f)));
           Util.option_map v.sync_name
             (fun f -> ("sync_name", (String.to_json f)))])
    let of_json j =
      {
        sync_name =
          (Util.option_map (Json.lookup j "sync_name") String.of_json);
        sync_type =
          (Util.option_map (Json.lookup j "sync_type") String.of_json);
        sync_source =
          (Util.option_map (Json.lookup j "sync_source")
             ResourceDataSyncSourceWithState.of_json);
        s3_destination =
          (Util.option_map (Json.lookup j "s3_destination")
             ResourceDataSyncS3Destination.of_json);
        last_sync_time =
          (Util.option_map (Json.lookup j "last_sync_time") DateTime.of_json);
        last_successful_sync_time =
          (Util.option_map (Json.lookup j "last_successful_sync_time")
             DateTime.of_json);
        sync_last_modified_time =
          (Util.option_map (Json.lookup j "sync_last_modified_time")
             DateTime.of_json);
        last_status =
          (Util.option_map (Json.lookup j "last_status")
             LastResourceDataSyncStatus.of_json);
        sync_created_time =
          (Util.option_map (Json.lookup j "sync_created_time")
             DateTime.of_json);
        last_sync_status_message =
          (Util.option_map (Json.lookup j "last_sync_status_message")
             String.of_json)
      }
  end
module MaintenanceWindowExecution =
  struct
    type t =
      {
      window_id: String.t option ;
      window_execution_id: String.t option ;
      status: MaintenanceWindowExecutionStatus.t option ;
      status_details: String.t option ;
      start_time: DateTime.t option ;
      end_time: DateTime.t option }
    let make ?window_id  ?window_execution_id  ?status  ?status_details 
      ?start_time  ?end_time  () =
      {
        window_id;
        window_execution_id;
        status;
        status_details;
        start_time;
        end_time
      }
    let parse xml =
      Some
        {
          window_id =
            (Util.option_bind (Xml.member "WindowId" xml) String.parse);
          window_execution_id =
            (Util.option_bind (Xml.member "WindowExecutionId" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml)
               MaintenanceWindowExecutionStatus.parse);
          status_details =
            (Util.option_bind (Xml.member "StatusDetails" xml) String.parse);
          start_time =
            (Util.option_bind (Xml.member "StartTime" xml) DateTime.parse);
          end_time =
            (Util.option_bind (Xml.member "EndTime" xml) DateTime.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.window_id
                   (fun f ->
                      Ezxmlm.make_tag "WindowId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.window_execution_id
                  (fun f ->
                     Ezxmlm.make_tag "WindowExecutionId"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.status
                 (fun f ->
                    Ezxmlm.make_tag "Status"
                      ([], (MaintenanceWindowExecutionStatus.to_xml f)))])
             @
             [Util.option_map v.status_details
                (fun f ->
                   Ezxmlm.make_tag "StatusDetails" ([], (String.to_xml f)))])
            @
            [Util.option_map v.start_time
               (fun f ->
                  Ezxmlm.make_tag "StartTime" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.end_time
              (fun f -> Ezxmlm.make_tag "EndTime" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.end_time
              (fun f -> ("end_time", (DateTime.to_json f)));
           Util.option_map v.start_time
             (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.status_details
             (fun f -> ("status_details", (String.to_json f)));
           Util.option_map v.status
             (fun f ->
                ("status", (MaintenanceWindowExecutionStatus.to_json f)));
           Util.option_map v.window_execution_id
             (fun f -> ("window_execution_id", (String.to_json f)));
           Util.option_map v.window_id
             (fun f -> ("window_id", (String.to_json f)))])
    let of_json j =
      {
        window_id =
          (Util.option_map (Json.lookup j "window_id") String.of_json);
        window_execution_id =
          (Util.option_map (Json.lookup j "window_execution_id")
             String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             MaintenanceWindowExecutionStatus.of_json);
        status_details =
          (Util.option_map (Json.lookup j "status_details") String.of_json);
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json);
        end_time =
          (Util.option_map (Json.lookup j "end_time") DateTime.of_json)
      }
  end
module ParametersFilter =
  struct
    type t =
      {
      key: ParametersFilterKey.t ;
      values: ParametersFilterValueList.t }
    let make ~key  ~values  () = { key; values }
    let parse xml =
      Some
        {
          key =
            (Xml.required "Key"
               (Util.option_bind (Xml.member "Key" xml)
                  ParametersFilterKey.parse));
          values =
            (Xml.required "Values"
               (Util.option_bind (Xml.member "Values" xml)
                  ParametersFilterValueList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "Key"
                  ([], (ParametersFilterKey.to_xml v.key)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Values"
                      ([], (ParametersFilterValueList.to_xml [x])))) v.values))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (ParametersFilterValueList.to_json v.values));
           Some ("key", (ParametersFilterKey.to_json v.key))])
    let of_json j =
      {
        key =
          (ParametersFilterKey.of_json
             (Util.of_option_exn (Json.lookup j "key")));
        values =
          (ParametersFilterValueList.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module PatchGroupPatchBaselineMapping =
  struct
    type t =
      {
      patch_group: String.t option ;
      baseline_identity: PatchBaselineIdentity.t option }
    let make ?patch_group  ?baseline_identity  () =
      { patch_group; baseline_identity }
    let parse xml =
      Some
        {
          patch_group =
            (Util.option_bind (Xml.member "PatchGroup" xml) String.parse);
          baseline_identity =
            (Util.option_bind (Xml.member "BaselineIdentity" xml)
               PatchBaselineIdentity.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.patch_group
               (fun f -> Ezxmlm.make_tag "PatchGroup" ([], (String.to_xml f)))])
           @
           [Util.option_map v.baseline_identity
              (fun f ->
                 Ezxmlm.make_tag "BaselineIdentity"
                   ([], (PatchBaselineIdentity.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.baseline_identity
              (fun f ->
                 ("baseline_identity", (PatchBaselineIdentity.to_json f)));
           Util.option_map v.patch_group
             (fun f -> ("patch_group", (String.to_json f)))])
    let of_json j =
      {
        patch_group =
          (Util.option_map (Json.lookup j "patch_group") String.of_json);
        baseline_identity =
          (Util.option_map (Json.lookup j "baseline_identity")
             PatchBaselineIdentity.of_json)
      }
  end
module ComplianceStringFilterList =
  struct
    type t = ComplianceStringFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ComplianceStringFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list ComplianceStringFilter.to_query v
    let to_headers v =
      Headers.to_headers_list ComplianceStringFilter.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ComplianceStringFilter.to_xml x)))
        v
    let to_json v = `List (List.map ComplianceStringFilter.to_json v)
    let of_json j = Json.to_list ComplianceStringFilter.of_json j
  end
module ParameterMetadataList =
  struct
    type t = ParameterMetadata.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ParameterMetadata.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list ParameterMetadata.to_query v
    let to_headers v = Headers.to_headers_list ParameterMetadata.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ParameterMetadata.to_xml x)))
        v
    let to_json v = `List (List.map ParameterMetadata.to_json v)
    let of_json j = Json.to_list ParameterMetadata.of_json j
  end
module PatchBaselineIdentityList =
  struct
    type t = PatchBaselineIdentity.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PatchBaselineIdentity.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list PatchBaselineIdentity.to_query v
    let to_headers v =
      Headers.to_headers_list PatchBaselineIdentity.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (PatchBaselineIdentity.to_xml x))) v
    let to_json v = `List (List.map PatchBaselineIdentity.to_json v)
    let of_json j = Json.to_list PatchBaselineIdentity.of_json j
  end
module MaintenanceWindowTaskInvocationParameters =
  struct
    type t =
      {
      run_command: MaintenanceWindowRunCommandParameters.t option ;
      automation: MaintenanceWindowAutomationParameters.t option ;
      step_functions: MaintenanceWindowStepFunctionsParameters.t option ;
      lambda: MaintenanceWindowLambdaParameters.t option }
    let make ?run_command  ?automation  ?step_functions  ?lambda  () =
      { run_command; automation; step_functions; lambda }
    let parse xml =
      Some
        {
          run_command =
            (Util.option_bind (Xml.member "RunCommand" xml)
               MaintenanceWindowRunCommandParameters.parse);
          automation =
            (Util.option_bind (Xml.member "Automation" xml)
               MaintenanceWindowAutomationParameters.parse);
          step_functions =
            (Util.option_bind (Xml.member "StepFunctions" xml)
               MaintenanceWindowStepFunctionsParameters.parse);
          lambda =
            (Util.option_bind (Xml.member "Lambda" xml)
               MaintenanceWindowLambdaParameters.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.run_command
                 (fun f ->
                    Ezxmlm.make_tag "RunCommand"
                      ([], (MaintenanceWindowRunCommandParameters.to_xml f)))])
             @
             [Util.option_map v.automation
                (fun f ->
                   Ezxmlm.make_tag "Automation"
                     ([], (MaintenanceWindowAutomationParameters.to_xml f)))])
            @
            [Util.option_map v.step_functions
               (fun f ->
                  Ezxmlm.make_tag "StepFunctions"
                    ([], (MaintenanceWindowStepFunctionsParameters.to_xml f)))])
           @
           [Util.option_map v.lambda
              (fun f ->
                 Ezxmlm.make_tag "Lambda"
                   ([], (MaintenanceWindowLambdaParameters.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.lambda
              (fun f ->
                 ("lambda", (MaintenanceWindowLambdaParameters.to_json f)));
           Util.option_map v.step_functions
             (fun f ->
                ("step_functions",
                  (MaintenanceWindowStepFunctionsParameters.to_json f)));
           Util.option_map v.automation
             (fun f ->
                ("automation",
                  (MaintenanceWindowAutomationParameters.to_json f)));
           Util.option_map v.run_command
             (fun f ->
                ("run_command",
                  (MaintenanceWindowRunCommandParameters.to_json f)))])
    let of_json j =
      {
        run_command =
          (Util.option_map (Json.lookup j "run_command")
             MaintenanceWindowRunCommandParameters.of_json);
        automation =
          (Util.option_map (Json.lookup j "automation")
             MaintenanceWindowAutomationParameters.of_json);
        step_functions =
          (Util.option_map (Json.lookup j "step_functions")
             MaintenanceWindowStepFunctionsParameters.of_json);
        lambda =
          (Util.option_map (Json.lookup j "lambda")
             MaintenanceWindowLambdaParameters.of_json)
      }
  end
module ScheduledWindowExecutionList =
  struct
    type t = ScheduledWindowExecution.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ScheduledWindowExecution.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list ScheduledWindowExecution.to_query v
    let to_headers v =
      Headers.to_headers_list ScheduledWindowExecution.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ScheduledWindowExecution.to_xml x)))
        v
    let to_json v = `List (List.map ScheduledWindowExecution.to_json v)
    let of_json j = Json.to_list ScheduledWindowExecution.of_json j
  end
module AssociationFilterList =
  struct
    type t = AssociationFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AssociationFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list AssociationFilter.to_query v
    let to_headers v = Headers.to_headers_list AssociationFilter.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (AssociationFilter.to_xml x)))
        v
    let to_json v = `List (List.map AssociationFilter.to_json v)
    let of_json j = Json.to_list AssociationFilter.of_json j
  end
module MaintenanceWindowExecutionTaskIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ParameterHistoryList =
  struct
    type t = ParameterHistory.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ParameterHistory.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list ParameterHistory.to_query v
    let to_headers v = Headers.to_headers_list ParameterHistory.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ParameterHistory.to_xml x)))
        v
    let to_json v = `List (List.map ParameterHistory.to_json v)
    let of_json j = Json.to_list ParameterHistory.of_json j
  end
module InstanceInformationList =
  struct
    type t = InstanceInformation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceInformation.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InstanceInformation.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceInformation.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstanceInformation.to_xml x))) v
    let to_json v = `List (List.map InstanceInformation.to_json v)
    let of_json j = Json.to_list InstanceInformation.of_json j
  end
module DocumentVersionList =
  struct
    type t = DocumentVersionInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DocumentVersionInfo.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list DocumentVersionInfo.to_query v
    let to_headers v =
      Headers.to_headers_list DocumentVersionInfo.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (DocumentVersionInfo.to_xml x))) v
    let to_json v = `List (List.map DocumentVersionInfo.to_json v)
    let of_json j = Json.to_list DocumentVersionInfo.of_json j
  end
module AssociationExecutionTargetsFilterList =
  struct
    type t = AssociationExecutionTargetsFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AssociationExecutionTargetsFilter.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list AssociationExecutionTargetsFilter.to_query v
    let to_headers v =
      Headers.to_headers_list AssociationExecutionTargetsFilter.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (AssociationExecutionTargetsFilter.to_xml x))) v
    let to_json v =
      `List (List.map AssociationExecutionTargetsFilter.to_json v)
    let of_json j = Json.to_list AssociationExecutionTargetsFilter.of_json j
  end
module StepExecutionFilterList =
  struct
    type t = StepExecutionFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map StepExecutionFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list StepExecutionFilter.to_query v
    let to_headers v =
      Headers.to_headers_list StepExecutionFilter.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (StepExecutionFilter.to_xml x))) v
    let to_json v = `List (List.map StepExecutionFilter.to_json v)
    let of_json j = Json.to_list StepExecutionFilter.of_json j
  end
module ServiceSetting =
  struct
    type t =
      {
      setting_id: String.t option ;
      setting_value: String.t option ;
      last_modified_date: DateTime.t option ;
      last_modified_user: String.t option ;
      a_r_n: String.t option ;
      status: String.t option }
    let make ?setting_id  ?setting_value  ?last_modified_date 
      ?last_modified_user  ?a_r_n  ?status  () =
      {
        setting_id;
        setting_value;
        last_modified_date;
        last_modified_user;
        a_r_n;
        status
      }
    let parse xml =
      Some
        {
          setting_id =
            (Util.option_bind (Xml.member "SettingId" xml) String.parse);
          setting_value =
            (Util.option_bind (Xml.member "SettingValue" xml) String.parse);
          last_modified_date =
            (Util.option_bind (Xml.member "LastModifiedDate" xml)
               DateTime.parse);
          last_modified_user =
            (Util.option_bind (Xml.member "LastModifiedUser" xml)
               String.parse);
          a_r_n = (Util.option_bind (Xml.member "ARN" xml) String.parse);
          status = (Util.option_bind (Xml.member "Status" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.setting_id
                   (fun f ->
                      Ezxmlm.make_tag "SettingId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.setting_value
                  (fun f ->
                     Ezxmlm.make_tag "SettingValue" ([], (String.to_xml f)))])
              @
              [Util.option_map v.last_modified_date
                 (fun f ->
                    Ezxmlm.make_tag "LastModifiedDate"
                      ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.last_modified_user
                (fun f ->
                   Ezxmlm.make_tag "LastModifiedUser" ([], (String.to_xml f)))])
            @
            [Util.option_map v.a_r_n
               (fun f -> Ezxmlm.make_tag "ARN" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f -> Ezxmlm.make_tag "Status" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (String.to_json f)));
           Util.option_map v.a_r_n (fun f -> ("a_r_n", (String.to_json f)));
           Util.option_map v.last_modified_user
             (fun f -> ("last_modified_user", (String.to_json f)));
           Util.option_map v.last_modified_date
             (fun f -> ("last_modified_date", (DateTime.to_json f)));
           Util.option_map v.setting_value
             (fun f -> ("setting_value", (String.to_json f)));
           Util.option_map v.setting_id
             (fun f -> ("setting_id", (String.to_json f)))])
    let of_json j =
      {
        setting_id =
          (Util.option_map (Json.lookup j "setting_id") String.of_json);
        setting_value =
          (Util.option_map (Json.lookup j "setting_value") String.of_json);
        last_modified_date =
          (Util.option_map (Json.lookup j "last_modified_date")
             DateTime.of_json);
        last_modified_user =
          (Util.option_map (Json.lookup j "last_modified_user")
             String.of_json);
        a_r_n = (Util.option_map (Json.lookup j "a_r_n") String.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json)
      }
  end
module AutomationExecutionMetadataList =
  struct
    type t = AutomationExecutionMetadata.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AutomationExecutionMetadata.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list AutomationExecutionMetadata.to_query v
    let to_headers v =
      Headers.to_headers_list AutomationExecutionMetadata.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (AutomationExecutionMetadata.to_xml x))) v
    let to_json v = `List (List.map AutomationExecutionMetadata.to_json v)
    let of_json j = Json.to_list AutomationExecutionMetadata.of_json j
  end
module DocumentIdentifierList =
  struct
    type t = DocumentIdentifier.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DocumentIdentifier.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list DocumentIdentifier.to_query v
    let to_headers v =
      Headers.to_headers_list DocumentIdentifier.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (DocumentIdentifier.to_xml x))) v
    let to_json v = `List (List.map DocumentIdentifier.to_json v)
    let of_json j = Json.to_list DocumentIdentifier.of_json j
  end
module InventorySchemaDeleteOption =
  struct
    type t =
      | DisableSchema 
      | DeleteSchema 
    let str_to_t =
      [("DeleteSchema", DeleteSchema); ("DisableSchema", DisableSchema)]
    let t_to_str =
      [(DeleteSchema, "DeleteSchema"); (DisableSchema, "DisableSchema")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SignalType =
  struct
    type t =
      | Approve 
      | Reject 
      | StartStep 
      | StopStep 
      | Resume 
    let str_to_t =
      [("Resume", Resume);
      ("StopStep", StopStep);
      ("StartStep", StartStep);
      ("Reject", Reject);
      ("Approve", Approve)]
    let t_to_str =
      [(Resume, "Resume");
      (StopStep, "StopStep");
      (StartStep, "StartStep");
      (Reject, "Reject");
      (Approve, "Approve")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceInformationFilterList =
  struct
    type t = InstanceInformationFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceInformationFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InstanceInformationFilter.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceInformationFilter.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InstanceInformationFilter.to_xml x))) v
    let to_json v = `List (List.map InstanceInformationFilter.to_json v)
    let of_json j = Json.to_list InstanceInformationFilter.of_json j
  end
module InstanceInformationStringFilterList =
  struct
    type t = InstanceInformationStringFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceInformationStringFilter.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list InstanceInformationStringFilter.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceInformationStringFilter.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InstanceInformationStringFilter.to_xml x))) v
    let to_json v =
      `List (List.map InstanceInformationStringFilter.to_json v)
    let of_json j = Json.to_list InstanceInformationStringFilter.of_json j
  end
module DocumentDescription =
  struct
    type t =
      {
      sha1: String.t option ;
      hash: String.t option ;
      hash_type: DocumentHashType.t option ;
      name: String.t option ;
      version_name: String.t option ;
      owner: String.t option ;
      created_date: DateTime.t option ;
      status: DocumentStatus.t option ;
      status_information: String.t option ;
      document_version: String.t option ;
      description: String.t option ;
      parameters: DocumentParameterList.t ;
      platform_types: PlatformTypeList.t ;
      document_type: DocumentType.t option ;
      schema_version: String.t option ;
      latest_version: String.t option ;
      default_version: String.t option ;
      document_format: DocumentFormat.t option ;
      target_type: String.t option ;
      tags: TagList.t ;
      attachments_information: AttachmentInformationList.t ;
      requires: DocumentRequiresList.t }
    let make ?sha1  ?hash  ?hash_type  ?name  ?version_name  ?owner 
      ?created_date  ?status  ?status_information  ?document_version 
      ?description  ?(parameters= [])  ?(platform_types= [])  ?document_type 
      ?schema_version  ?latest_version  ?default_version  ?document_format 
      ?target_type  ?(tags= [])  ?(attachments_information= [])  ?(requires=
      [])  () =
      {
        sha1;
        hash;
        hash_type;
        name;
        version_name;
        owner;
        created_date;
        status;
        status_information;
        document_version;
        description;
        parameters;
        platform_types;
        document_type;
        schema_version;
        latest_version;
        default_version;
        document_format;
        target_type;
        tags;
        attachments_information;
        requires
      }
    let parse xml =
      Some
        {
          sha1 = (Util.option_bind (Xml.member "Sha1" xml) String.parse);
          hash = (Util.option_bind (Xml.member "Hash" xml) String.parse);
          hash_type =
            (Util.option_bind (Xml.member "HashType" xml)
               DocumentHashType.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          version_name =
            (Util.option_bind (Xml.member "VersionName" xml) String.parse);
          owner = (Util.option_bind (Xml.member "Owner" xml) String.parse);
          created_date =
            (Util.option_bind (Xml.member "CreatedDate" xml) DateTime.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml) DocumentStatus.parse);
          status_information =
            (Util.option_bind (Xml.member "StatusInformation" xml)
               String.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          parameters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Parameters" xml)
                  DocumentParameterList.parse));
          platform_types =
            (Util.of_option []
               (Util.option_bind (Xml.member "PlatformTypes" xml)
                  PlatformTypeList.parse));
          document_type =
            (Util.option_bind (Xml.member "DocumentType" xml)
               DocumentType.parse);
          schema_version =
            (Util.option_bind (Xml.member "SchemaVersion" xml) String.parse);
          latest_version =
            (Util.option_bind (Xml.member "LatestVersion" xml) String.parse);
          default_version =
            (Util.option_bind (Xml.member "DefaultVersion" xml) String.parse);
          document_format =
            (Util.option_bind (Xml.member "DocumentFormat" xml)
               DocumentFormat.parse);
          target_type =
            (Util.option_bind (Xml.member "TargetType" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tags" xml) TagList.parse));
          attachments_information =
            (Util.of_option []
               (Util.option_bind (Xml.member "AttachmentsInformation" xml)
                  AttachmentInformationList.parse));
          requires =
            (Util.of_option []
               (Util.option_bind (Xml.member "Requires" xml)
                  DocumentRequiresList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((((((((([] @
                                [Util.option_map v.sha1
                                   (fun f ->
                                      Ezxmlm.make_tag "Sha1"
                                        ([], (String.to_xml f)))])
                               @
                               [Util.option_map v.hash
                                  (fun f ->
                                     Ezxmlm.make_tag "Hash"
                                       ([], (String.to_xml f)))])
                              @
                              [Util.option_map v.hash_type
                                 (fun f ->
                                    Ezxmlm.make_tag "HashType"
                                      ([], (DocumentHashType.to_xml f)))])
                             @
                             [Util.option_map v.name
                                (fun f ->
                                   Ezxmlm.make_tag "Name"
                                     ([], (String.to_xml f)))])
                            @
                            [Util.option_map v.version_name
                               (fun f ->
                                  Ezxmlm.make_tag "VersionName"
                                    ([], (String.to_xml f)))])
                           @
                           [Util.option_map v.owner
                              (fun f ->
                                 Ezxmlm.make_tag "Owner"
                                   ([], (String.to_xml f)))])
                          @
                          [Util.option_map v.created_date
                             (fun f ->
                                Ezxmlm.make_tag "CreatedDate"
                                  ([], (DateTime.to_xml f)))])
                         @
                         [Util.option_map v.status
                            (fun f ->
                               Ezxmlm.make_tag "Status"
                                 ([], (DocumentStatus.to_xml f)))])
                        @
                        [Util.option_map v.status_information
                           (fun f ->
                              Ezxmlm.make_tag "StatusInformation"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.document_version
                          (fun f ->
                             Ezxmlm.make_tag "DocumentVersion"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.description
                         (fun f ->
                            Ezxmlm.make_tag "Description"
                              ([], (String.to_xml f)))])
                     @
                     (List.map
                        (fun x ->
                           Some
                             (Ezxmlm.make_tag "Parameters"
                                ([], (DocumentParameterList.to_xml [x]))))
                        v.parameters))
                    @
                    (List.map
                       (fun x ->
                          Some
                            (Ezxmlm.make_tag "PlatformTypes"
                               ([], (PlatformTypeList.to_xml [x]))))
                       v.platform_types))
                   @
                   [Util.option_map v.document_type
                      (fun f ->
                         Ezxmlm.make_tag "DocumentType"
                           ([], (DocumentType.to_xml f)))])
                  @
                  [Util.option_map v.schema_version
                     (fun f ->
                        Ezxmlm.make_tag "SchemaVersion"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.latest_version
                    (fun f ->
                       Ezxmlm.make_tag "LatestVersion"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.default_version
                   (fun f ->
                      Ezxmlm.make_tag "DefaultVersion"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.document_format
                  (fun f ->
                     Ezxmlm.make_tag "DocumentFormat"
                       ([], (DocumentFormat.to_xml f)))])
              @
              [Util.option_map v.target_type
                 (fun f ->
                    Ezxmlm.make_tag "TargetType" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some (Ezxmlm.make_tag "Tags" ([], (TagList.to_xml [x]))))
                v.tags))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "AttachmentsInformation"
                       ([], (AttachmentInformationList.to_xml [x]))))
               v.attachments_information))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Requires"
                      ([], (DocumentRequiresList.to_xml [x])))) v.requires))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("requires", (DocumentRequiresList.to_json v.requires));
           Some
             ("attachments_information",
               (AttachmentInformationList.to_json v.attachments_information));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.target_type
             (fun f -> ("target_type", (String.to_json f)));
           Util.option_map v.document_format
             (fun f -> ("document_format", (DocumentFormat.to_json f)));
           Util.option_map v.default_version
             (fun f -> ("default_version", (String.to_json f)));
           Util.option_map v.latest_version
             (fun f -> ("latest_version", (String.to_json f)));
           Util.option_map v.schema_version
             (fun f -> ("schema_version", (String.to_json f)));
           Util.option_map v.document_type
             (fun f -> ("document_type", (DocumentType.to_json f)));
           Some
             ("platform_types", (PlatformTypeList.to_json v.platform_types));
           Some ("parameters", (DocumentParameterList.to_json v.parameters));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.status_information
             (fun f -> ("status_information", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (DocumentStatus.to_json f)));
           Util.option_map v.created_date
             (fun f -> ("created_date", (DateTime.to_json f)));
           Util.option_map v.owner (fun f -> ("owner", (String.to_json f)));
           Util.option_map v.version_name
             (fun f -> ("version_name", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.hash_type
             (fun f -> ("hash_type", (DocumentHashType.to_json f)));
           Util.option_map v.hash (fun f -> ("hash", (String.to_json f)));
           Util.option_map v.sha1 (fun f -> ("sha1", (String.to_json f)))])
    let of_json j =
      {
        sha1 = (Util.option_map (Json.lookup j "sha1") String.of_json);
        hash = (Util.option_map (Json.lookup j "hash") String.of_json);
        hash_type =
          (Util.option_map (Json.lookup j "hash_type")
             DocumentHashType.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        version_name =
          (Util.option_map (Json.lookup j "version_name") String.of_json);
        owner = (Util.option_map (Json.lookup j "owner") String.of_json);
        created_date =
          (Util.option_map (Json.lookup j "created_date") DateTime.of_json);
        status =
          (Util.option_map (Json.lookup j "status") DocumentStatus.of_json);
        status_information =
          (Util.option_map (Json.lookup j "status_information")
             String.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        parameters =
          (DocumentParameterList.of_json
             (Util.of_option_exn (Json.lookup j "parameters")));
        platform_types =
          (PlatformTypeList.of_json
             (Util.of_option_exn (Json.lookup j "platform_types")));
        document_type =
          (Util.option_map (Json.lookup j "document_type")
             DocumentType.of_json);
        schema_version =
          (Util.option_map (Json.lookup j "schema_version") String.of_json);
        latest_version =
          (Util.option_map (Json.lookup j "latest_version") String.of_json);
        default_version =
          (Util.option_map (Json.lookup j "default_version") String.of_json);
        document_format =
          (Util.option_map (Json.lookup j "document_format")
             DocumentFormat.of_json);
        target_type =
          (Util.option_map (Json.lookup j "target_type") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        attachments_information =
          (AttachmentInformationList.of_json
             (Util.of_option_exn (Json.lookup j "attachments_information")));
        requires =
          (DocumentRequiresList.of_json
             (Util.of_option_exn (Json.lookup j "requires")))
      }
  end
module ResourceDataSyncSource =
  struct
    type t =
      {
      source_type: String.t ;
      aws_organizations_source:
        ResourceDataSyncAwsOrganizationsSource.t option ;
      source_regions: ResourceDataSyncSourceRegionList.t ;
      include_future_regions: Boolean.t option }
    let make ~source_type  ?aws_organizations_source  ~source_regions 
      ?include_future_regions  () =
      {
        source_type;
        aws_organizations_source;
        source_regions;
        include_future_regions
      }
    let parse xml =
      Some
        {
          source_type =
            (Xml.required "SourceType"
               (Util.option_bind (Xml.member "SourceType" xml) String.parse));
          aws_organizations_source =
            (Util.option_bind (Xml.member "AwsOrganizationsSource" xml)
               ResourceDataSyncAwsOrganizationsSource.parse);
          source_regions =
            (Xml.required "SourceRegions"
               (Util.option_bind (Xml.member "SourceRegions" xml)
                  ResourceDataSyncSourceRegionList.parse));
          include_future_regions =
            (Util.option_bind (Xml.member "IncludeFutureRegions" xml)
               Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "SourceType"
                    ([], (String.to_xml v.source_type)))])
             @
             [Util.option_map v.aws_organizations_source
                (fun f ->
                   Ezxmlm.make_tag "AwsOrganizationsSource"
                     ([], (ResourceDataSyncAwsOrganizationsSource.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "SourceRegions"
                       ([], (ResourceDataSyncSourceRegionList.to_xml [x]))))
               v.source_regions))
           @
           [Util.option_map v.include_future_regions
              (fun f ->
                 Ezxmlm.make_tag "IncludeFutureRegions"
                   ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.include_future_regions
              (fun f -> ("include_future_regions", (Boolean.to_json f)));
           Some
             ("source_regions",
               (ResourceDataSyncSourceRegionList.to_json v.source_regions));
           Util.option_map v.aws_organizations_source
             (fun f ->
                ("aws_organizations_source",
                  (ResourceDataSyncAwsOrganizationsSource.to_json f)));
           Some ("source_type", (String.to_json v.source_type))])
    let of_json j =
      {
        source_type =
          (String.of_json (Util.of_option_exn (Json.lookup j "source_type")));
        aws_organizations_source =
          (Util.option_map (Json.lookup j "aws_organizations_source")
             ResourceDataSyncAwsOrganizationsSource.of_json);
        source_regions =
          (ResourceDataSyncSourceRegionList.of_json
             (Util.of_option_exn (Json.lookup j "source_regions")));
        include_future_regions =
          (Util.option_map (Json.lookup j "include_future_regions")
             Boolean.of_json)
      }
  end
module rec
  InventoryAggregator:sig
                        type t =
                          {
                          expression: String.t option ;
                          aggregators: InventoryAggregatorList.t ;
                          groups: InventoryGroupList.t }
                        val make :
                          ?expression:String.t ->
                            ?aggregators:InventoryAggregatorList.t ->
                              ?groups:InventoryGroupList.t -> unit -> t
                        val parse : Ezxmlm.nodes -> t option
                        val to_query : t -> Aws.Query.t
                        val to_headers : t -> Aws.Headers.t
                        val to_xml : t -> Ezxmlm.nodes
                        val to_json : t -> Aws.Json.t
                        val of_json : Aws.Json.t -> t
                      end =
  struct
    type t =
      {
      expression: String.t option ;
      aggregators: InventoryAggregatorList.t ;
      groups: InventoryGroupList.t }
    let make ?expression  ?(aggregators= [])  ?(groups= [])  () =
      { expression; aggregators; groups }
    let parse xml =
      Some
        {
          expression =
            (Util.option_bind (Xml.member "Expression" xml) String.parse);
          aggregators =
            (Util.of_option []
               (Util.option_bind (Xml.member "Aggregators" xml)
                  InventoryAggregatorList.parse));
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "Groups" xml)
                  InventoryGroupList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.expression
                (fun f ->
                   Ezxmlm.make_tag "Expression" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Aggregators"
                       ([], (InventoryAggregatorList.to_xml [x]))))
               v.aggregators))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Groups"
                      ([], (InventoryGroupList.to_xml [x])))) v.groups))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("groups", (InventoryGroupList.to_json v.groups));
           Some
             ("aggregators", (InventoryAggregatorList.to_json v.aggregators));
           Util.option_map v.expression
             (fun f -> ("expression", (String.to_json f)))])
    let of_json j =
      {
        expression =
          (Util.option_map (Json.lookup j "expression") String.of_json);
        aggregators =
          (InventoryAggregatorList.of_json
             (Util.of_option_exn (Json.lookup j "aggregators")));
        groups =
          (InventoryGroupList.of_json
             (Util.of_option_exn (Json.lookup j "groups")))
      }
  end
 and
  InventoryAggregatorList:sig
                            type t = InventoryAggregator.t list
                            val make : t -> unit -> t
                            val parse : Ezxmlm.nodes -> t option
                            val to_query : t -> Aws.Query.t
                            val to_headers : t -> Aws.Headers.t
                            val to_xml : t -> Ezxmlm.nodes
                            val to_json : t -> Aws.Json.t
                            val of_json : Aws.Json.t -> t
                          end =
  struct
    type t = InventoryAggregator.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InventoryAggregator.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InventoryAggregator.to_query v
    let to_headers v =
      Headers.to_headers_list InventoryAggregator.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InventoryAggregator.to_xml x))) v
    let to_json v = `List (List.map InventoryAggregator.to_json v)
    let of_json j = Json.to_list InventoryAggregator.of_json j
  end
module ResultAttributeList =
  struct
    type t = ResultAttribute.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ResultAttribute.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list ResultAttribute.to_query v
    let to_headers v = Headers.to_headers_list ResultAttribute.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ResultAttribute.to_xml x)))
        v
    let to_json v = `List (List.map ResultAttribute.to_json v)
    let of_json j = Json.to_list ResultAttribute.of_json j
  end
module AutomationExecution =
  struct
    type t =
      {
      automation_execution_id: String.t option ;
      document_name: String.t option ;
      document_version: String.t option ;
      execution_start_time: DateTime.t option ;
      execution_end_time: DateTime.t option ;
      automation_execution_status: AutomationExecutionStatus.t option ;
      step_executions: StepExecutionList.t ;
      step_executions_truncated: Boolean.t option ;
      parameters: AutomationParameterMap.t option ;
      outputs: AutomationParameterMap.t option ;
      failure_message: String.t option ;
      mode: ExecutionMode.t option ;
      parent_automation_execution_id: String.t option ;
      executed_by: String.t option ;
      current_step_name: String.t option ;
      current_action: String.t option ;
      target_parameter_name: String.t option ;
      targets: Targets.t ;
      target_maps: TargetMaps.t ;
      resolved_targets: ResolvedTargets.t option ;
      max_concurrency: String.t option ;
      max_errors: String.t option ;
      target: String.t option ;
      target_locations: TargetLocations.t ;
      progress_counters: ProgressCounters.t option }
    let make ?automation_execution_id  ?document_name  ?document_version 
      ?execution_start_time  ?execution_end_time 
      ?automation_execution_status  ?(step_executions= []) 
      ?step_executions_truncated  ?parameters  ?outputs  ?failure_message 
      ?mode  ?parent_automation_execution_id  ?executed_by 
      ?current_step_name  ?current_action  ?target_parameter_name  ?(targets=
      [])  ?(target_maps= [])  ?resolved_targets  ?max_concurrency 
      ?max_errors  ?target  ?(target_locations= [])  ?progress_counters  () =
      {
        automation_execution_id;
        document_name;
        document_version;
        execution_start_time;
        execution_end_time;
        automation_execution_status;
        step_executions;
        step_executions_truncated;
        parameters;
        outputs;
        failure_message;
        mode;
        parent_automation_execution_id;
        executed_by;
        current_step_name;
        current_action;
        target_parameter_name;
        targets;
        target_maps;
        resolved_targets;
        max_concurrency;
        max_errors;
        target;
        target_locations;
        progress_counters
      }
    let parse xml =
      Some
        {
          automation_execution_id =
            (Util.option_bind (Xml.member "AutomationExecutionId" xml)
               String.parse);
          document_name =
            (Util.option_bind (Xml.member "DocumentName" xml) String.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          execution_start_time =
            (Util.option_bind (Xml.member "ExecutionStartTime" xml)
               DateTime.parse);
          execution_end_time =
            (Util.option_bind (Xml.member "ExecutionEndTime" xml)
               DateTime.parse);
          automation_execution_status =
            (Util.option_bind (Xml.member "AutomationExecutionStatus" xml)
               AutomationExecutionStatus.parse);
          step_executions =
            (Util.of_option []
               (Util.option_bind (Xml.member "StepExecutions" xml)
                  StepExecutionList.parse));
          step_executions_truncated =
            (Util.option_bind (Xml.member "StepExecutionsTruncated" xml)
               Boolean.parse);
          parameters =
            (Util.option_bind (Xml.member "Parameters" xml)
               AutomationParameterMap.parse);
          outputs =
            (Util.option_bind (Xml.member "Outputs" xml)
               AutomationParameterMap.parse);
          failure_message =
            (Util.option_bind (Xml.member "FailureMessage" xml) String.parse);
          mode =
            (Util.option_bind (Xml.member "Mode" xml) ExecutionMode.parse);
          parent_automation_execution_id =
            (Util.option_bind (Xml.member "ParentAutomationExecutionId" xml)
               String.parse);
          executed_by =
            (Util.option_bind (Xml.member "ExecutedBy" xml) String.parse);
          current_step_name =
            (Util.option_bind (Xml.member "CurrentStepName" xml) String.parse);
          current_action =
            (Util.option_bind (Xml.member "CurrentAction" xml) String.parse);
          target_parameter_name =
            (Util.option_bind (Xml.member "TargetParameterName" xml)
               String.parse);
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          target_maps =
            (Util.of_option []
               (Util.option_bind (Xml.member "TargetMaps" xml)
                  TargetMaps.parse));
          resolved_targets =
            (Util.option_bind (Xml.member "ResolvedTargets" xml)
               ResolvedTargets.parse);
          max_concurrency =
            (Util.option_bind (Xml.member "MaxConcurrency" xml) String.parse);
          max_errors =
            (Util.option_bind (Xml.member "MaxErrors" xml) String.parse);
          target = (Util.option_bind (Xml.member "Target" xml) String.parse);
          target_locations =
            (Util.of_option []
               (Util.option_bind (Xml.member "TargetLocations" xml)
                  TargetLocations.parse));
          progress_counters =
            (Util.option_bind (Xml.member "ProgressCounters" xml)
               ProgressCounters.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((((((((((([] @
                                   [Util.option_map v.automation_execution_id
                                      (fun f ->
                                         Ezxmlm.make_tag
                                           "AutomationExecutionId"
                                           ([], (String.to_xml f)))])
                                  @
                                  [Util.option_map v.document_name
                                     (fun f ->
                                        Ezxmlm.make_tag "DocumentName"
                                          ([], (String.to_xml f)))])
                                 @
                                 [Util.option_map v.document_version
                                    (fun f ->
                                       Ezxmlm.make_tag "DocumentVersion"
                                         ([], (String.to_xml f)))])
                                @
                                [Util.option_map v.execution_start_time
                                   (fun f ->
                                      Ezxmlm.make_tag "ExecutionStartTime"
                                        ([], (DateTime.to_xml f)))])
                               @
                               [Util.option_map v.execution_end_time
                                  (fun f ->
                                     Ezxmlm.make_tag "ExecutionEndTime"
                                       ([], (DateTime.to_xml f)))])
                              @
                              [Util.option_map v.automation_execution_status
                                 (fun f ->
                                    Ezxmlm.make_tag
                                      "AutomationExecutionStatus"
                                      ([],
                                        (AutomationExecutionStatus.to_xml f)))])
                             @
                             (List.map
                                (fun x ->
                                   Some
                                     (Ezxmlm.make_tag "StepExecutions"
                                        ([], (StepExecutionList.to_xml [x]))))
                                v.step_executions))
                            @
                            [Util.option_map v.step_executions_truncated
                               (fun f ->
                                  Ezxmlm.make_tag "StepExecutionsTruncated"
                                    ([], (Boolean.to_xml f)))])
                           @
                           [Util.option_map v.parameters
                              (fun f ->
                                 Ezxmlm.make_tag "Parameters"
                                   ([], (AutomationParameterMap.to_xml f)))])
                          @
                          [Util.option_map v.outputs
                             (fun f ->
                                Ezxmlm.make_tag "Outputs"
                                  ([], (AutomationParameterMap.to_xml f)))])
                         @
                         [Util.option_map v.failure_message
                            (fun f ->
                               Ezxmlm.make_tag "FailureMessage"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.mode
                           (fun f ->
                              Ezxmlm.make_tag "Mode"
                                ([], (ExecutionMode.to_xml f)))])
                       @
                       [Util.option_map v.parent_automation_execution_id
                          (fun f ->
                             Ezxmlm.make_tag "ParentAutomationExecutionId"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.executed_by
                         (fun f ->
                            Ezxmlm.make_tag "ExecutedBy"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.current_step_name
                        (fun f ->
                           Ezxmlm.make_tag "CurrentStepName"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.current_action
                       (fun f ->
                          Ezxmlm.make_tag "CurrentAction"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.target_parameter_name
                      (fun f ->
                         Ezxmlm.make_tag "TargetParameterName"
                           ([], (String.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "Targets"
                             ([], (Targets.to_xml [x])))) v.targets))
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "TargetMaps"
                            ([], (TargetMaps.to_xml [x])))) v.target_maps))
                @
                [Util.option_map v.resolved_targets
                   (fun f ->
                      Ezxmlm.make_tag "ResolvedTargets"
                        ([], (ResolvedTargets.to_xml f)))])
               @
               [Util.option_map v.max_concurrency
                  (fun f ->
                     Ezxmlm.make_tag "MaxConcurrency" ([], (String.to_xml f)))])
              @
              [Util.option_map v.max_errors
                 (fun f ->
                    Ezxmlm.make_tag "MaxErrors" ([], (String.to_xml f)))])
             @
             [Util.option_map v.target
                (fun f -> Ezxmlm.make_tag "Target" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "TargetLocations"
                       ([], (TargetLocations.to_xml [x]))))
               v.target_locations))
           @
           [Util.option_map v.progress_counters
              (fun f ->
                 Ezxmlm.make_tag "ProgressCounters"
                   ([], (ProgressCounters.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.progress_counters
              (fun f -> ("progress_counters", (ProgressCounters.to_json f)));
           Some
             ("target_locations",
               (TargetLocations.to_json v.target_locations));
           Util.option_map v.target (fun f -> ("target", (String.to_json f)));
           Util.option_map v.max_errors
             (fun f -> ("max_errors", (String.to_json f)));
           Util.option_map v.max_concurrency
             (fun f -> ("max_concurrency", (String.to_json f)));
           Util.option_map v.resolved_targets
             (fun f -> ("resolved_targets", (ResolvedTargets.to_json f)));
           Some ("target_maps", (TargetMaps.to_json v.target_maps));
           Some ("targets", (Targets.to_json v.targets));
           Util.option_map v.target_parameter_name
             (fun f -> ("target_parameter_name", (String.to_json f)));
           Util.option_map v.current_action
             (fun f -> ("current_action", (String.to_json f)));
           Util.option_map v.current_step_name
             (fun f -> ("current_step_name", (String.to_json f)));
           Util.option_map v.executed_by
             (fun f -> ("executed_by", (String.to_json f)));
           Util.option_map v.parent_automation_execution_id
             (fun f -> ("parent_automation_execution_id", (String.to_json f)));
           Util.option_map v.mode
             (fun f -> ("mode", (ExecutionMode.to_json f)));
           Util.option_map v.failure_message
             (fun f -> ("failure_message", (String.to_json f)));
           Util.option_map v.outputs
             (fun f -> ("outputs", (AutomationParameterMap.to_json f)));
           Util.option_map v.parameters
             (fun f -> ("parameters", (AutomationParameterMap.to_json f)));
           Util.option_map v.step_executions_truncated
             (fun f -> ("step_executions_truncated", (Boolean.to_json f)));
           Some
             ("step_executions",
               (StepExecutionList.to_json v.step_executions));
           Util.option_map v.automation_execution_status
             (fun f ->
                ("automation_execution_status",
                  (AutomationExecutionStatus.to_json f)));
           Util.option_map v.execution_end_time
             (fun f -> ("execution_end_time", (DateTime.to_json f)));
           Util.option_map v.execution_start_time
             (fun f -> ("execution_start_time", (DateTime.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.document_name
             (fun f -> ("document_name", (String.to_json f)));
           Util.option_map v.automation_execution_id
             (fun f -> ("automation_execution_id", (String.to_json f)))])
    let of_json j =
      {
        automation_execution_id =
          (Util.option_map (Json.lookup j "automation_execution_id")
             String.of_json);
        document_name =
          (Util.option_map (Json.lookup j "document_name") String.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        execution_start_time =
          (Util.option_map (Json.lookup j "execution_start_time")
             DateTime.of_json);
        execution_end_time =
          (Util.option_map (Json.lookup j "execution_end_time")
             DateTime.of_json);
        automation_execution_status =
          (Util.option_map (Json.lookup j "automation_execution_status")
             AutomationExecutionStatus.of_json);
        step_executions =
          (StepExecutionList.of_json
             (Util.of_option_exn (Json.lookup j "step_executions")));
        step_executions_truncated =
          (Util.option_map (Json.lookup j "step_executions_truncated")
             Boolean.of_json);
        parameters =
          (Util.option_map (Json.lookup j "parameters")
             AutomationParameterMap.of_json);
        outputs =
          (Util.option_map (Json.lookup j "outputs")
             AutomationParameterMap.of_json);
        failure_message =
          (Util.option_map (Json.lookup j "failure_message") String.of_json);
        mode = (Util.option_map (Json.lookup j "mode") ExecutionMode.of_json);
        parent_automation_execution_id =
          (Util.option_map (Json.lookup j "parent_automation_execution_id")
             String.of_json);
        executed_by =
          (Util.option_map (Json.lookup j "executed_by") String.of_json);
        current_step_name =
          (Util.option_map (Json.lookup j "current_step_name") String.of_json);
        current_action =
          (Util.option_map (Json.lookup j "current_action") String.of_json);
        target_parameter_name =
          (Util.option_map (Json.lookup j "target_parameter_name")
             String.of_json);
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        target_maps =
          (TargetMaps.of_json
             (Util.of_option_exn (Json.lookup j "target_maps")));
        resolved_targets =
          (Util.option_map (Json.lookup j "resolved_targets")
             ResolvedTargets.of_json);
        max_concurrency =
          (Util.option_map (Json.lookup j "max_concurrency") String.of_json);
        max_errors =
          (Util.option_map (Json.lookup j "max_errors") String.of_json);
        target = (Util.option_map (Json.lookup j "target") String.of_json);
        target_locations =
          (TargetLocations.of_json
             (Util.of_option_exn (Json.lookup j "target_locations")));
        progress_counters =
          (Util.option_map (Json.lookup j "progress_counters")
             ProgressCounters.of_json)
      }
  end
module DocumentDefaultVersionDescription =
  struct
    type t =
      {
      name: String.t option ;
      default_version: String.t option ;
      default_version_name: String.t option }
    let make ?name  ?default_version  ?default_version_name  () =
      { name; default_version; default_version_name }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          default_version =
            (Util.option_bind (Xml.member "DefaultVersion" xml) String.parse);
          default_version_name =
            (Util.option_bind (Xml.member "DefaultVersionName" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.name
                (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
            @
            [Util.option_map v.default_version
               (fun f ->
                  Ezxmlm.make_tag "DefaultVersion" ([], (String.to_xml f)))])
           @
           [Util.option_map v.default_version_name
              (fun f ->
                 Ezxmlm.make_tag "DefaultVersionName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.default_version_name
              (fun f -> ("default_version_name", (String.to_json f)));
           Util.option_map v.default_version
             (fun f -> ("default_version", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        default_version =
          (Util.option_map (Json.lookup j "default_version") String.of_json);
        default_version_name =
          (Util.option_map (Json.lookup j "default_version_name")
             String.of_json)
      }
  end
module PatchProperty =
  struct
    type t =
      | PRODUCT 
      | PRODUCT_FAMILY 
      | CLASSIFICATION 
      | MSRC_SEVERITY 
      | PRIORITY 
      | SEVERITY 
    let str_to_t =
      [("SEVERITY", SEVERITY);
      ("PRIORITY", PRIORITY);
      ("MSRC_SEVERITY", MSRC_SEVERITY);
      ("CLASSIFICATION", CLASSIFICATION);
      ("PRODUCT_FAMILY", PRODUCT_FAMILY);
      ("PRODUCT", PRODUCT)]
    let t_to_str =
      [(SEVERITY, "SEVERITY");
      (PRIORITY, "PRIORITY");
      (MSRC_SEVERITY, "MSRC_SEVERITY");
      (CLASSIFICATION, "CLASSIFICATION");
      (PRODUCT_FAMILY, "PRODUCT_FAMILY");
      (PRODUCT, "PRODUCT")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PatchSet =
  struct
    type t =
      | OS 
      | APPLICATION 
    let str_to_t = [("APPLICATION", APPLICATION); ("OS", OS)]
    let t_to_str = [(APPLICATION, "APPLICATION"); (OS, "OS")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AssociationExecutionFilterList =
  struct
    type t = AssociationExecutionFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AssociationExecutionFilter.parse (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list AssociationExecutionFilter.to_query v
    let to_headers v =
      Headers.to_headers_list AssociationExecutionFilter.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (AssociationExecutionFilter.to_xml x))) v
    let to_json v = `List (List.map AssociationExecutionFilter.to_json v)
    let of_json j = Json.to_list AssociationExecutionFilter.of_json j
  end
module KeyList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ResourceTypeForTagging =
  struct
    type t =
      | Document 
      | ManagedInstance 
      | MaintenanceWindow 
      | Parameter 
      | PatchBaseline 
      | OpsItem 
    let str_to_t =
      [("OpsItem", OpsItem);
      ("PatchBaseline", PatchBaseline);
      ("Parameter", Parameter);
      ("MaintenanceWindow", MaintenanceWindow);
      ("ManagedInstance", ManagedInstance);
      ("Document", Document)]
    let t_to_str =
      [(OpsItem, "OpsItem");
      (PatchBaseline, "PatchBaseline");
      (Parameter, "Parameter");
      (MaintenanceWindow, "MaintenanceWindow");
      (ManagedInstance, "ManagedInstance");
      (Document, "Document")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module OpsEntityList =
  struct
    type t = OpsEntity.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map OpsEntity.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list OpsEntity.to_query v
    let to_headers v = Headers.to_headers_list OpsEntity.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (OpsEntity.to_xml x)))
        v
    let to_json v = `List (List.map OpsEntity.to_json v)
    let of_json j = Json.to_list OpsEntity.of_json j
  end
module OpsItemOpsDataKeysList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PatchOrchestratorFilterList =
  struct
    type t = PatchOrchestratorFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PatchOrchestratorFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list PatchOrchestratorFilter.to_query v
    let to_headers v =
      Headers.to_headers_list PatchOrchestratorFilter.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (PatchOrchestratorFilter.to_xml x)))
        v
    let to_json v = `List (List.map PatchOrchestratorFilter.to_json v)
    let of_json j = Json.to_list PatchOrchestratorFilter.of_json j
  end
module PatchAction =
  struct
    type t =
      | ALLOW_AS_DEPENDENCY 
      | BLOCK 
    let str_to_t =
      [("BLOCK", BLOCK); ("ALLOW_AS_DEPENDENCY", ALLOW_AS_DEPENDENCY)]
    let t_to_str =
      [(BLOCK, "BLOCK"); (ALLOW_AS_DEPENDENCY, "ALLOW_AS_DEPENDENCY")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PatchIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PatchRuleGroup =
  struct
    type t = {
      patch_rules: PatchRuleList.t }
    let make ~patch_rules  () = { patch_rules }
    let parse xml =
      Some
        {
          patch_rules =
            (Xml.required "PatchRules"
               (Util.option_bind (Xml.member "PatchRules" xml)
                  PatchRuleList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "PatchRules"
                      ([], (PatchRuleList.to_xml [x])))) v.patch_rules))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("patch_rules", (PatchRuleList.to_json v.patch_rules))])
    let of_json j =
      {
        patch_rules =
          (PatchRuleList.of_json
             (Util.of_option_exn (Json.lookup j "patch_rules")))
      }
  end
module PatchSourceList =
  struct
    type t = PatchSource.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map PatchSource.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list PatchSource.to_query v
    let to_headers v = Headers.to_headers_list PatchSource.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (PatchSource.to_xml x))) v
    let to_json v = `List (List.map PatchSource.to_json v)
    let of_json j = Json.to_list PatchSource.of_json j
  end
module AssociationList =
  struct
    type t = Association.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Association.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list Association.to_query v
    let to_headers v = Headers.to_headers_list Association.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (Association.to_xml x))) v
    let to_json v = `List (List.map Association.to_json v)
    let of_json j = Json.to_list Association.of_json j
  end
module SessionList =
  struct
    type t = Session.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Session.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list Session.to_query v
    let to_headers v = Headers.to_headers_list Session.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Session.to_xml x))) v
    let to_json v = `List (List.map Session.to_json v)
    let of_json j = Json.to_list Session.of_json j
  end
module OpsItemParameterNamesList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ActivationList =
  struct
    type t = Activation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Activation.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list Activation.to_query v
    let to_headers v = Headers.to_headers_list Activation.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (Activation.to_xml x))) v
    let to_json v = `List (List.map Activation.to_json v)
    let of_json j = Json.to_list Activation.of_json j
  end
module ComplianceItemList =
  struct
    type t = ComplianceItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ComplianceItem.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list ComplianceItem.to_query v
    let to_headers v = Headers.to_headers_list ComplianceItem.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ComplianceItem.to_xml x))) v
    let to_json v = `List (List.map ComplianceItem.to_json v)
    let of_json j = Json.to_list ComplianceItem.of_json j
  end
module MaintenanceWindowTaskList =
  struct
    type t = MaintenanceWindowTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map MaintenanceWindowTask.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list MaintenanceWindowTask.to_query v
    let to_headers v =
      Headers.to_headers_list MaintenanceWindowTask.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (MaintenanceWindowTask.to_xml x))) v
    let to_json v = `List (List.map MaintenanceWindowTask.to_json v)
    let of_json j = Json.to_list MaintenanceWindowTask.of_json j
  end
module CommandFilterList =
  struct
    type t = CommandFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CommandFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list CommandFilter.to_query v
    let to_headers v = Headers.to_headers_list CommandFilter.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (CommandFilter.to_xml x))) v
    let to_json v = `List (List.map CommandFilter.to_json v)
    let of_json j = Json.to_list CommandFilter.of_json j
  end
module InventoryResultEntityList =
  struct
    type t = InventoryResultEntity.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InventoryResultEntity.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InventoryResultEntity.to_query v
    let to_headers v =
      Headers.to_headers_list InventoryResultEntity.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InventoryResultEntity.to_xml x))) v
    let to_json v = `List (List.map InventoryResultEntity.to_json v)
    let of_json j = Json.to_list InventoryResultEntity.of_json j
  end
module InstanceAssociationList =
  struct
    type t = InstanceAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceAssociation.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InstanceAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceAssociation.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstanceAssociation.to_xml x))) v
    let to_json v = `List (List.map InstanceAssociation.to_json v)
    let of_json j = Json.to_list InstanceAssociation.of_json j
  end
module PatchPropertiesList =
  struct
    type t = PatchPropertyEntry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PatchPropertyEntry.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list PatchPropertyEntry.to_query v
    let to_headers v =
      Headers.to_headers_list PatchPropertyEntry.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (PatchPropertyEntry.to_xml x))) v
    let to_json v = `List (List.map PatchPropertyEntry.to_json v)
    let of_json j = Json.to_list PatchPropertyEntry.of_json j
  end
module AssociationIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module MaintenanceWindowFilterList =
  struct
    type t = MaintenanceWindowFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map MaintenanceWindowFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list MaintenanceWindowFilter.to_query v
    let to_headers v =
      Headers.to_headers_list MaintenanceWindowFilter.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (MaintenanceWindowFilter.to_xml x)))
        v
    let to_json v = `List (List.map MaintenanceWindowFilter.to_json v)
    let of_json j = Json.to_list MaintenanceWindowFilter.of_json j
  end
module ResourceComplianceSummaryItemList =
  struct
    type t = ResourceComplianceSummaryItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ResourceComplianceSummaryItem.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list ResourceComplianceSummaryItem.to_query v
    let to_headers v =
      Headers.to_headers_list ResourceComplianceSummaryItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (ResourceComplianceSummaryItem.to_xml x))) v
    let to_json v = `List (List.map ResourceComplianceSummaryItem.to_json v)
    let of_json j = Json.to_list ResourceComplianceSummaryItem.of_json j
  end
module InstancePatchStateFilterList =
  struct
    type t = InstancePatchStateFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstancePatchStateFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InstancePatchStateFilter.to_query v
    let to_headers v =
      Headers.to_headers_list InstancePatchStateFilter.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstancePatchStateFilter.to_xml x)))
        v
    let to_json v = `List (List.map InstancePatchStateFilter.to_json v)
    let of_json j = Json.to_list InstancePatchStateFilter.of_json j
  end
module CreateAssociationBatchRequestEntries =
  struct
    type t = CreateAssociationBatchRequestEntry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CreateAssociationBatchRequestEntry.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list CreateAssociationBatchRequestEntry.to_query v
    let to_headers v =
      Headers.to_headers_list CreateAssociationBatchRequestEntry.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (CreateAssociationBatchRequestEntry.to_xml x))) v
    let to_json v =
      `List (List.map CreateAssociationBatchRequestEntry.to_json v)
    let of_json j = Json.to_list CreateAssociationBatchRequestEntry.of_json j
  end
module AssociationExecutionTargetsList =
  struct
    type t = AssociationExecutionTarget.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AssociationExecutionTarget.parse (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list AssociationExecutionTarget.to_query v
    let to_headers v =
      Headers.to_headers_list AssociationExecutionTarget.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (AssociationExecutionTarget.to_xml x))) v
    let to_json v = `List (List.map AssociationExecutionTarget.to_json v)
    let of_json j = Json.to_list AssociationExecutionTarget.of_json j
  end
module AssociationExecutionsList =
  struct
    type t = AssociationExecution.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AssociationExecution.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list AssociationExecution.to_query v
    let to_headers v =
      Headers.to_headers_list AssociationExecution.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (AssociationExecution.to_xml x))) v
    let to_json v = `List (List.map AssociationExecution.to_json v)
    let of_json j = Json.to_list AssociationExecution.of_json j
  end
module ParameterList =
  struct
    type t = Parameter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Parameter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list Parameter.to_query v
    let to_headers v = Headers.to_headers_list Parameter.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Parameter.to_xml x)))
        v
    let to_json v = `List (List.map Parameter.to_json v)
    let of_json j = Json.to_list Parameter.of_json j
  end
module InstancePatchStatesList =
  struct
    type t = InstancePatchState.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstancePatchState.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InstancePatchState.to_query v
    let to_headers v =
      Headers.to_headers_list InstancePatchState.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstancePatchState.to_xml x))) v
    let to_json v = `List (List.map InstancePatchState.to_json v)
    let of_json j = Json.to_list InstancePatchState.of_json j
  end
module AutomationExecutionFilterList =
  struct
    type t = AutomationExecutionFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AutomationExecutionFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list AutomationExecutionFilter.to_query v
    let to_headers v =
      Headers.to_headers_list AutomationExecutionFilter.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (AutomationExecutionFilter.to_xml x))) v
    let to_json v = `List (List.map AutomationExecutionFilter.to_json v)
    let of_json j = Json.to_list AutomationExecutionFilter.of_json j
  end
module CommandList =
  struct
    type t = Command.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Command.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list Command.to_query v
    let to_headers v = Headers.to_headers_list Command.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Command.to_xml x))) v
    let to_json v = `List (List.map Command.to_json v)
    let of_json j = Json.to_list Command.of_json j
  end
module MaintenanceWindowTargetList =
  struct
    type t = MaintenanceWindowTarget.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map MaintenanceWindowTarget.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list MaintenanceWindowTarget.to_query v
    let to_headers v =
      Headers.to_headers_list MaintenanceWindowTarget.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (MaintenanceWindowTarget.to_xml x)))
        v
    let to_json v = `List (List.map MaintenanceWindowTarget.to_json v)
    let of_json j = Json.to_list MaintenanceWindowTarget.of_json j
  end
module OpsItemSummaries =
  struct
    type t = OpsItemSummary.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map OpsItemSummary.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list OpsItemSummary.to_query v
    let to_headers v = Headers.to_headers_list OpsItemSummary.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (OpsItemSummary.to_xml x))) v
    let to_json v = `List (List.map OpsItemSummary.to_json v)
    let of_json j = Json.to_list OpsItemSummary.of_json j
  end
module rec
  OpsAggregator:sig
                  type t =
                    {
                    aggregator_type: String.t option ;
                    type_name: String.t option ;
                    attribute_name: String.t option ;
                    values: OpsAggregatorValueMap.t option ;
                    filters: OpsFilterList.t ;
                    aggregators: OpsAggregatorList.t }
                  val make :
                    ?aggregator_type:String.t ->
                      ?type_name:String.t ->
                        ?attribute_name:String.t ->
                          ?values:OpsAggregatorValueMap.t ->
                            ?filters:OpsFilterList.t ->
                              ?aggregators:OpsAggregatorList.t -> unit -> t
                  val parse : Ezxmlm.nodes -> t option
                  val to_query : t -> Aws.Query.t
                  val to_headers : t -> Aws.Headers.t
                  val to_xml : t -> Ezxmlm.nodes
                  val to_json : t -> Aws.Json.t
                  val of_json : Aws.Json.t -> t
                end =
  struct
    type t =
      {
      aggregator_type: String.t option ;
      type_name: String.t option ;
      attribute_name: String.t option ;
      values: OpsAggregatorValueMap.t option ;
      filters: OpsFilterList.t ;
      aggregators: OpsAggregatorList.t }
    let make ?aggregator_type  ?type_name  ?attribute_name  ?values 
      ?(filters= [])  ?(aggregators= [])  () =
      {
        aggregator_type;
        type_name;
        attribute_name;
        values;
        filters;
        aggregators
      }
    let parse xml =
      Some
        {
          aggregator_type =
            (Util.option_bind (Xml.member "AggregatorType" xml) String.parse);
          type_name =
            (Util.option_bind (Xml.member "TypeName" xml) String.parse);
          attribute_name =
            (Util.option_bind (Xml.member "AttributeName" xml) String.parse);
          values =
            (Util.option_bind (Xml.member "Values" xml)
               OpsAggregatorValueMap.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  OpsFilterList.parse));
          aggregators =
            (Util.of_option []
               (Util.option_bind (Xml.member "Aggregators" xml)
                  OpsAggregatorList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.aggregator_type
                   (fun f ->
                      Ezxmlm.make_tag "AggregatorType"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.type_name
                  (fun f ->
                     Ezxmlm.make_tag "TypeName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.attribute_name
                 (fun f ->
                    Ezxmlm.make_tag "AttributeName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.values
                (fun f ->
                   Ezxmlm.make_tag "Values"
                     ([], (OpsAggregatorValueMap.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Filters"
                       ([], (OpsFilterList.to_xml [x])))) v.filters))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Aggregators"
                      ([], (OpsAggregatorList.to_xml [x])))) v.aggregators))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("aggregators", (OpsAggregatorList.to_json v.aggregators));
           Some ("filters", (OpsFilterList.to_json v.filters));
           Util.option_map v.values
             (fun f -> ("values", (OpsAggregatorValueMap.to_json f)));
           Util.option_map v.attribute_name
             (fun f -> ("attribute_name", (String.to_json f)));
           Util.option_map v.type_name
             (fun f -> ("type_name", (String.to_json f)));
           Util.option_map v.aggregator_type
             (fun f -> ("aggregator_type", (String.to_json f)))])
    let of_json j =
      {
        aggregator_type =
          (Util.option_map (Json.lookup j "aggregator_type") String.of_json);
        type_name =
          (Util.option_map (Json.lookup j "type_name") String.of_json);
        attribute_name =
          (Util.option_map (Json.lookup j "attribute_name") String.of_json);
        values =
          (Util.option_map (Json.lookup j "values")
             OpsAggregatorValueMap.of_json);
        filters =
          (OpsFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        aggregators =
          (OpsAggregatorList.of_json
             (Util.of_option_exn (Json.lookup j "aggregators")))
      }
  end
 and
  OpsAggregatorList:sig
                      type t = OpsAggregator.t list
                      val make : t -> unit -> t
                      val parse : Ezxmlm.nodes -> t option
                      val to_query : t -> Aws.Query.t
                      val to_headers : t -> Aws.Headers.t
                      val to_xml : t -> Ezxmlm.nodes
                      val to_json : t -> Aws.Json.t
                      val of_json : Aws.Json.t -> t
                    end =
  struct
    type t = OpsAggregator.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map OpsAggregator.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list OpsAggregator.to_query v
    let to_headers v = Headers.to_headers_list OpsAggregator.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (OpsAggregator.to_xml x))) v
    let to_json v = `List (List.map OpsAggregator.to_json v)
    let of_json j = Json.to_list OpsAggregator.of_json j
  end
module OpsResultAttributeList =
  struct
    type t = OpsResultAttribute.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map OpsResultAttribute.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list OpsResultAttribute.to_query v
    let to_headers v =
      Headers.to_headers_list OpsResultAttribute.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (OpsResultAttribute.to_xml x))) v
    let to_json v = `List (List.map OpsResultAttribute.to_json v)
    let of_json j = Json.to_list OpsResultAttribute.of_json j
  end
module PatchComplianceDataList =
  struct
    type t = PatchComplianceData.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PatchComplianceData.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list PatchComplianceData.to_query v
    let to_headers v =
      Headers.to_headers_list PatchComplianceData.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (PatchComplianceData.to_xml x))) v
    let to_json v = `List (List.map PatchComplianceData.to_json v)
    let of_json j = Json.to_list PatchComplianceData.of_json j
  end
module PatchList =
  struct
    type t = Patch.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Patch.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list Patch.to_query v
    let to_headers v = Headers.to_headers_list Patch.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (Patch.to_xml x))) v
    let to_json v = `List (List.map Patch.to_json v)
    let of_json j = Json.to_list Patch.of_json j
  end
module CalendarState =
  struct
    type t =
      | OPEN 
      | CLOSED 
    let str_to_t = [("CLOSED", CLOSED); ("OPEN", OPEN)]
    let t_to_str = [(CLOSED, "CLOSED"); (OPEN, "OPEN")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DocumentFilterList =
  struct
    type t = DocumentFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DocumentFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list DocumentFilter.to_query v
    let to_headers v = Headers.to_headers_list DocumentFilter.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (DocumentFilter.to_xml x))) v
    let to_json v = `List (List.map DocumentFilter.to_json v)
    let of_json j = Json.to_list DocumentFilter.of_json j
  end
module DocumentKeyValuesFilterList =
  struct
    type t = DocumentKeyValuesFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DocumentKeyValuesFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list DocumentKeyValuesFilter.to_query v
    let to_headers v =
      Headers.to_headers_list DocumentKeyValuesFilter.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (DocumentKeyValuesFilter.to_xml x)))
        v
    let to_json v = `List (List.map DocumentKeyValuesFilter.to_json v)
    let of_json j = Json.to_list DocumentKeyValuesFilter.of_json j
  end
module AssociationVersionList =
  struct
    type t = AssociationVersionInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AssociationVersionInfo.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list AssociationVersionInfo.to_query v
    let to_headers v =
      Headers.to_headers_list AssociationVersionInfo.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (AssociationVersionInfo.to_xml x)))
        v
    let to_json v = `List (List.map AssociationVersionInfo.to_json v)
    let of_json j = Json.to_list AssociationVersionInfo.of_json j
  end
module ComplianceSummaryItemList =
  struct
    type t = ComplianceSummaryItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ComplianceSummaryItem.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list ComplianceSummaryItem.to_query v
    let to_headers v =
      Headers.to_headers_list ComplianceSummaryItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ComplianceSummaryItem.to_xml x))) v
    let to_json v = `List (List.map ComplianceSummaryItem.to_json v)
    let of_json j = Json.to_list ComplianceSummaryItem.of_json j
  end
module CalendarNameOrARNList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module SessionManagerParameters =
  struct
    type t = (String.t, SessionManagerParameterValueList.t) Hashtbl.t
    let make elems () = elems
    let parse xml = None
    let to_query v =
      Query.to_query_hashtbl String.to_string
        SessionManagerParameterValueList.to_query v
    let to_headers v = Headers.to_headers_hashtbl String.to_headers v
    let to_xml v = []
    let to_json v =
      `Assoc
        (Hashtbl.fold
           (fun k ->
              fun v ->
                fun acc ->
                  ((String.to_string k),
                    (SessionManagerParameterValueList.to_json v))
                  :: acc) v [])
    let of_json j =
      Json.to_hashtbl String.of_string
        SessionManagerParameterValueList.of_json j
  end
module EffectivePatchList =
  struct
    type t = EffectivePatch.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map EffectivePatch.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list EffectivePatch.to_query v
    let to_headers v = Headers.to_headers_list EffectivePatch.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (EffectivePatch.to_xml x))) v
    let to_json v = `List (List.map EffectivePatch.to_json v)
    let of_json j = Json.to_list EffectivePatch.of_json j
  end
module AssociationDescriptionList =
  struct
    type t = AssociationDescription.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AssociationDescription.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list AssociationDescription.to_query v
    let to_headers v =
      Headers.to_headers_list AssociationDescription.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (AssociationDescription.to_xml x)))
        v
    let to_json v = `List (List.map AssociationDescription.to_json v)
    let of_json j = Json.to_list AssociationDescription.of_json j
  end
module FailedCreateAssociationList =
  struct
    type t = FailedCreateAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map FailedCreateAssociation.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list FailedCreateAssociation.to_query v
    let to_headers v =
      Headers.to_headers_list FailedCreateAssociation.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (FailedCreateAssociation.to_xml x)))
        v
    let to_json v = `List (List.map FailedCreateAssociation.to_json v)
    let of_json j = Json.to_list FailedCreateAssociation.of_json j
  end
module ComplianceItemEntryList =
  struct
    type t = ComplianceItemEntry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ComplianceItemEntry.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list ComplianceItemEntry.to_query v
    let to_headers v =
      Headers.to_headers_list ComplianceItemEntry.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ComplianceItemEntry.to_xml x))) v
    let to_json v = `List (List.map ComplianceItemEntry.to_json v)
    let of_json j = Json.to_list ComplianceItemEntry.of_json j
  end
module MaintenanceWindowTaskParametersList =
  struct
    type t = MaintenanceWindowTaskParameters.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map MaintenanceWindowTaskParameters.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list MaintenanceWindowTaskParameters.to_query v
    let to_headers v =
      Headers.to_headers_list MaintenanceWindowTaskParameters.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (MaintenanceWindowTaskParameters.to_xml x))) v
    let to_json v =
      `List (List.map MaintenanceWindowTaskParameters.to_json v)
    let of_json j = Json.to_list MaintenanceWindowTaskParameters.of_json j
  end
module OpsItem =
  struct
    type t =
      {
      created_by: String.t option ;
      created_time: DateTime.t option ;
      description: String.t option ;
      last_modified_by: String.t option ;
      last_modified_time: DateTime.t option ;
      notifications: OpsItemNotifications.t ;
      priority: Integer.t option ;
      related_ops_items: RelatedOpsItems.t ;
      status: OpsItemStatus.t option ;
      ops_item_id: String.t option ;
      version: String.t option ;
      title: String.t option ;
      source: String.t option ;
      operational_data: OpsItemOperationalData.t option ;
      category: String.t option ;
      severity: String.t option }
    let make ?created_by  ?created_time  ?description  ?last_modified_by 
      ?last_modified_time  ?(notifications= [])  ?priority 
      ?(related_ops_items= [])  ?status  ?ops_item_id  ?version  ?title 
      ?source  ?operational_data  ?category  ?severity  () =
      {
        created_by;
        created_time;
        description;
        last_modified_by;
        last_modified_time;
        notifications;
        priority;
        related_ops_items;
        status;
        ops_item_id;
        version;
        title;
        source;
        operational_data;
        category;
        severity
      }
    let parse xml =
      Some
        {
          created_by =
            (Util.option_bind (Xml.member "CreatedBy" xml) String.parse);
          created_time =
            (Util.option_bind (Xml.member "CreatedTime" xml) DateTime.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          last_modified_by =
            (Util.option_bind (Xml.member "LastModifiedBy" xml) String.parse);
          last_modified_time =
            (Util.option_bind (Xml.member "LastModifiedTime" xml)
               DateTime.parse);
          notifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "Notifications" xml)
                  OpsItemNotifications.parse));
          priority =
            (Util.option_bind (Xml.member "Priority" xml) Integer.parse);
          related_ops_items =
            (Util.of_option []
               (Util.option_bind (Xml.member "RelatedOpsItems" xml)
                  RelatedOpsItems.parse));
          status =
            (Util.option_bind (Xml.member "Status" xml) OpsItemStatus.parse);
          ops_item_id =
            (Util.option_bind (Xml.member "OpsItemId" xml) String.parse);
          version =
            (Util.option_bind (Xml.member "Version" xml) String.parse);
          title = (Util.option_bind (Xml.member "Title" xml) String.parse);
          source = (Util.option_bind (Xml.member "Source" xml) String.parse);
          operational_data =
            (Util.option_bind (Xml.member "OperationalData" xml)
               OpsItemOperationalData.parse);
          category =
            (Util.option_bind (Xml.member "Category" xml) String.parse);
          severity =
            (Util.option_bind (Xml.member "Severity" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((((([] @
                          [Util.option_map v.created_by
                             (fun f ->
                                Ezxmlm.make_tag "CreatedBy"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.created_time
                            (fun f ->
                               Ezxmlm.make_tag "CreatedTime"
                                 ([], (DateTime.to_xml f)))])
                        @
                        [Util.option_map v.description
                           (fun f ->
                              Ezxmlm.make_tag "Description"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.last_modified_by
                          (fun f ->
                             Ezxmlm.make_tag "LastModifiedBy"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.last_modified_time
                         (fun f ->
                            Ezxmlm.make_tag "LastModifiedTime"
                              ([], (DateTime.to_xml f)))])
                     @
                     (List.map
                        (fun x ->
                           Some
                             (Ezxmlm.make_tag "Notifications"
                                ([], (OpsItemNotifications.to_xml [x]))))
                        v.notifications))
                    @
                    [Util.option_map v.priority
                       (fun f ->
                          Ezxmlm.make_tag "Priority" ([], (Integer.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "RelatedOpsItems"
                              ([], (RelatedOpsItems.to_xml [x]))))
                      v.related_ops_items))
                  @
                  [Util.option_map v.status
                     (fun f ->
                        Ezxmlm.make_tag "Status"
                          ([], (OpsItemStatus.to_xml f)))])
                 @
                 [Util.option_map v.ops_item_id
                    (fun f ->
                       Ezxmlm.make_tag "OpsItemId" ([], (String.to_xml f)))])
                @
                [Util.option_map v.version
                   (fun f ->
                      Ezxmlm.make_tag "Version" ([], (String.to_xml f)))])
               @
               [Util.option_map v.title
                  (fun f -> Ezxmlm.make_tag "Title" ([], (String.to_xml f)))])
              @
              [Util.option_map v.source
                 (fun f -> Ezxmlm.make_tag "Source" ([], (String.to_xml f)))])
             @
             [Util.option_map v.operational_data
                (fun f ->
                   Ezxmlm.make_tag "OperationalData"
                     ([], (OpsItemOperationalData.to_xml f)))])
            @
            [Util.option_map v.category
               (fun f -> Ezxmlm.make_tag "Category" ([], (String.to_xml f)))])
           @
           [Util.option_map v.severity
              (fun f -> Ezxmlm.make_tag "Severity" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.severity
              (fun f -> ("severity", (String.to_json f)));
           Util.option_map v.category
             (fun f -> ("category", (String.to_json f)));
           Util.option_map v.operational_data
             (fun f ->
                ("operational_data", (OpsItemOperationalData.to_json f)));
           Util.option_map v.source (fun f -> ("source", (String.to_json f)));
           Util.option_map v.title (fun f -> ("title", (String.to_json f)));
           Util.option_map v.version
             (fun f -> ("version", (String.to_json f)));
           Util.option_map v.ops_item_id
             (fun f -> ("ops_item_id", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (OpsItemStatus.to_json f)));
           Some
             ("related_ops_items",
               (RelatedOpsItems.to_json v.related_ops_items));
           Util.option_map v.priority
             (fun f -> ("priority", (Integer.to_json f)));
           Some
             ("notifications",
               (OpsItemNotifications.to_json v.notifications));
           Util.option_map v.last_modified_time
             (fun f -> ("last_modified_time", (DateTime.to_json f)));
           Util.option_map v.last_modified_by
             (fun f -> ("last_modified_by", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.created_time
             (fun f -> ("created_time", (DateTime.to_json f)));
           Util.option_map v.created_by
             (fun f -> ("created_by", (String.to_json f)))])
    let of_json j =
      {
        created_by =
          (Util.option_map (Json.lookup j "created_by") String.of_json);
        created_time =
          (Util.option_map (Json.lookup j "created_time") DateTime.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        last_modified_by =
          (Util.option_map (Json.lookup j "last_modified_by") String.of_json);
        last_modified_time =
          (Util.option_map (Json.lookup j "last_modified_time")
             DateTime.of_json);
        notifications =
          (OpsItemNotifications.of_json
             (Util.of_option_exn (Json.lookup j "notifications")));
        priority =
          (Util.option_map (Json.lookup j "priority") Integer.of_json);
        related_ops_items =
          (RelatedOpsItems.of_json
             (Util.of_option_exn (Json.lookup j "related_ops_items")));
        status =
          (Util.option_map (Json.lookup j "status") OpsItemStatus.of_json);
        ops_item_id =
          (Util.option_map (Json.lookup j "ops_item_id") String.of_json);
        version = (Util.option_map (Json.lookup j "version") String.of_json);
        title = (Util.option_map (Json.lookup j "title") String.of_json);
        source = (Util.option_map (Json.lookup j "source") String.of_json);
        operational_data =
          (Util.option_map (Json.lookup j "operational_data")
             OpsItemOperationalData.of_json);
        category =
          (Util.option_map (Json.lookup j "category") String.of_json);
        severity =
          (Util.option_map (Json.lookup j "severity") String.of_json)
      }
  end
module InventoryDeletionsList =
  struct
    type t = InventoryDeletionStatusItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InventoryDeletionStatusItem.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list InventoryDeletionStatusItem.to_query v
    let to_headers v =
      Headers.to_headers_list InventoryDeletionStatusItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InventoryDeletionStatusItem.to_xml x))) v
    let to_json v = `List (List.map InventoryDeletionStatusItem.to_json v)
    let of_json j = Json.to_list InventoryDeletionStatusItem.of_json j
  end
module DocumentPermissionType =
  struct
    type t =
      | Share 
    let str_to_t = [("Share", Share)]
    let t_to_str = [(Share, "Share")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SessionFilterList =
  struct
    type t = SessionFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SessionFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list SessionFilter.to_query v
    let to_headers v = Headers.to_headers_list SessionFilter.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (SessionFilter.to_xml x))) v
    let to_json v = `List (List.map SessionFilter.to_json v)
    let of_json j = Json.to_list SessionFilter.of_json j
  end
module SessionState =
  struct
    type t =
      | Active 
      | History 
    let str_to_t = [("History", History); ("Active", Active)]
    let t_to_str = [(History, "History"); (Active, "Active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceAssociationStatusInfos =
  struct
    type t = InstanceAssociationStatusInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceAssociationStatusInfo.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list InstanceAssociationStatusInfo.to_query v
    let to_headers v =
      Headers.to_headers_list InstanceAssociationStatusInfo.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (InstanceAssociationStatusInfo.to_xml x))) v
    let to_json v = `List (List.map InstanceAssociationStatusInfo.to_json v)
    let of_json j = Json.to_list InstanceAssociationStatusInfo.of_json j
  end
module InventoryItemSchemaResultList =
  struct
    type t = InventoryItemSchema.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InventoryItemSchema.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InventoryItemSchema.to_query v
    let to_headers v =
      Headers.to_headers_list InventoryItemSchema.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InventoryItemSchema.to_xml x))) v
    let to_json v = `List (List.map InventoryItemSchema.to_json v)
    let of_json j = Json.to_list InventoryItemSchema.of_json j
  end
module MaintenanceWindowExecutionTaskIdentityList =
  struct
    type t = MaintenanceWindowExecutionTaskIdentity.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map MaintenanceWindowExecutionTaskIdentity.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list MaintenanceWindowExecutionTaskIdentity.to_query v
    let to_headers v =
      Headers.to_headers_list
        MaintenanceWindowExecutionTaskIdentity.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (MaintenanceWindowExecutionTaskIdentity.to_xml x))) v
    let to_json v =
      `List (List.map MaintenanceWindowExecutionTaskIdentity.to_json v)
    let of_json j =
      Json.to_list MaintenanceWindowExecutionTaskIdentity.of_json j
  end
module MaintenanceWindowIdentityList =
  struct
    type t = MaintenanceWindowIdentity.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map MaintenanceWindowIdentity.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list MaintenanceWindowIdentity.to_query v
    let to_headers v =
      Headers.to_headers_list MaintenanceWindowIdentity.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (MaintenanceWindowIdentity.to_xml x))) v
    let to_json v = `List (List.map MaintenanceWindowIdentity.to_json v)
    let of_json j = Json.to_list MaintenanceWindowIdentity.of_json j
  end
module ParameterStringFilterList =
  struct
    type t = ParameterStringFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ParameterStringFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list ParameterStringFilter.to_query v
    let to_headers v =
      Headers.to_headers_list ParameterStringFilter.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ParameterStringFilter.to_xml x))) v
    let to_json v = `List (List.map ParameterStringFilter.to_json v)
    let of_json j = Json.to_list ParameterStringFilter.of_json j
  end
module ConnectionStatus =
  struct
    type t =
      | Connected 
      | NotConnected 
    let str_to_t = [("NotConnected", NotConnected); ("Connected", Connected)]
    let t_to_str = [(NotConnected, "NotConnected"); (Connected, "Connected")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AttachmentsSourceList =
  struct
    type t = AttachmentsSource.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AttachmentsSource.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list AttachmentsSource.to_query v
    let to_headers v = Headers.to_headers_list AttachmentsSource.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (AttachmentsSource.to_xml x)))
        v
    let to_json v = `List (List.map AttachmentsSource.to_json v)
    let of_json j = Json.to_list AttachmentsSource.of_json j
  end
module ParameterNameList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ComplianceResourceIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ComplianceResourceTypeList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AccountIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AccountSharingInfoList =
  struct
    type t = AccountSharingInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AccountSharingInfo.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list AccountSharingInfo.to_query v
    let to_headers v =
      Headers.to_headers_list AccountSharingInfo.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (AccountSharingInfo.to_xml x))) v
    let to_json v = `List (List.map AccountSharingInfo.to_json v)
    let of_json j = Json.to_list AccountSharingInfo.of_json j
  end
module MaintenanceWindowExecutionTaskInvocationIdentityList =
  struct
    type t = MaintenanceWindowExecutionTaskInvocationIdentity.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map MaintenanceWindowExecutionTaskInvocationIdentity.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list
        MaintenanceWindowExecutionTaskInvocationIdentity.to_query v
    let to_headers v =
      Headers.to_headers_list
        MaintenanceWindowExecutionTaskInvocationIdentity.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([],
               (MaintenanceWindowExecutionTaskInvocationIdentity.to_xml x)))
        v
    let to_json v =
      `List
        (List.map MaintenanceWindowExecutionTaskInvocationIdentity.to_json v)
    let of_json j =
      Json.to_list MaintenanceWindowExecutionTaskInvocationIdentity.of_json j
  end
module MaintenanceWindowsForTargetList =
  struct
    type t = MaintenanceWindowIdentityForTarget.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map MaintenanceWindowIdentityForTarget.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list MaintenanceWindowIdentityForTarget.to_query v
    let to_headers v =
      Headers.to_headers_list MaintenanceWindowIdentityForTarget.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (MaintenanceWindowIdentityForTarget.to_xml x))) v
    let to_json v =
      `List (List.map MaintenanceWindowIdentityForTarget.to_json v)
    let of_json j = Json.to_list MaintenanceWindowIdentityForTarget.of_json j
  end
module DescribeActivationsFilterList =
  struct
    type t = DescribeActivationsFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DescribeActivationsFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list DescribeActivationsFilter.to_query v
    let to_headers v =
      Headers.to_headers_list DescribeActivationsFilter.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (DescribeActivationsFilter.to_xml x))) v
    let to_json v = `List (List.map DescribeActivationsFilter.to_json v)
    let of_json j = Json.to_list DescribeActivationsFilter.of_json j
  end
module InstancePatchStateList =
  struct
    type t = InstancePatchState.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstancePatchState.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InstancePatchState.to_query v
    let to_headers v =
      Headers.to_headers_list InstancePatchState.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (InstancePatchState.to_xml x))) v
    let to_json v = `List (List.map InstancePatchState.to_json v)
    let of_json j = Json.to_list InstancePatchState.of_json j
  end
module CommandInvocationList =
  struct
    type t = CommandInvocation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CommandInvocation.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list CommandInvocation.to_query v
    let to_headers v = Headers.to_headers_list CommandInvocation.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (CommandInvocation.to_xml x)))
        v
    let to_json v = `List (List.map CommandInvocation.to_json v)
    let of_json j = Json.to_list CommandInvocation.of_json j
  end
module StopType =
  struct
    type t =
      | Complete 
      | Cancel 
    let str_to_t = [("Cancel", Cancel); ("Complete", Complete)]
    let t_to_str = [(Cancel, "Cancel"); (Complete, "Complete")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_headers v =
      Headers.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_xml v =
      String.to_xml (Util.of_option_exn (Util.list_find t_to_str v))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InventoryItemList =
  struct
    type t = InventoryItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InventoryItem.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InventoryItem.to_query v
    let to_headers v = Headers.to_headers_list InventoryItem.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (InventoryItem.to_xml x))) v
    let to_json v = `List (List.map InventoryItem.to_json v)
    let of_json j = Json.to_list InventoryItem.of_json j
  end
module OpsItemFilters =
  struct
    type t = OpsItemFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map OpsItemFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list OpsItemFilter.to_query v
    let to_headers v = Headers.to_headers_list OpsItemFilter.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (OpsItemFilter.to_xml x))) v
    let to_json v = `List (List.map OpsItemFilter.to_json v)
    let of_json j = Json.to_list OpsItemFilter.of_json j
  end
module PatchGroupList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_headers v = Headers.to_headers_list String.to_headers v
    let to_xml v =
      List.map (fun x -> Ezxmlm.make_tag "member" ([], (String.to_xml x))) v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AttachmentContentList =
  struct
    type t = AttachmentContent.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AttachmentContent.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list AttachmentContent.to_query v
    let to_headers v = Headers.to_headers_list AttachmentContent.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (AttachmentContent.to_xml x)))
        v
    let to_json v = `List (List.map AttachmentContent.to_json v)
    let of_json j = Json.to_list AttachmentContent.of_json j
  end
module ResourceDataSyncItemList =
  struct
    type t = ResourceDataSyncItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ResourceDataSyncItem.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list ResourceDataSyncItem.to_query v
    let to_headers v =
      Headers.to_headers_list ResourceDataSyncItem.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member" ([], (ResourceDataSyncItem.to_xml x))) v
    let to_json v = `List (List.map ResourceDataSyncItem.to_json v)
    let of_json j = Json.to_list ResourceDataSyncItem.of_json j
  end
module MaintenanceWindowExecutionList =
  struct
    type t = MaintenanceWindowExecution.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map MaintenanceWindowExecution.parse (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list MaintenanceWindowExecution.to_query v
    let to_headers v =
      Headers.to_headers_list MaintenanceWindowExecution.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (MaintenanceWindowExecution.to_xml x))) v
    let to_json v = `List (List.map MaintenanceWindowExecution.to_json v)
    let of_json j = Json.to_list MaintenanceWindowExecution.of_json j
  end
module ParametersFilterList =
  struct
    type t = ParametersFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ParametersFilter.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list ParametersFilter.to_query v
    let to_headers v = Headers.to_headers_list ParametersFilter.to_headers v
    let to_xml v =
      List.map
        (fun x -> Ezxmlm.make_tag "member" ([], (ParametersFilter.to_xml x)))
        v
    let to_json v = `List (List.map ParametersFilter.to_json v)
    let of_json j = Json.to_list ParametersFilter.of_json j
  end
module PatchGroupPatchBaselineMappingList =
  struct
    type t = PatchGroupPatchBaselineMapping.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PatchGroupPatchBaselineMapping.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list PatchGroupPatchBaselineMapping.to_query v
    let to_headers v =
      Headers.to_headers_list PatchGroupPatchBaselineMapping.to_headers v
    let to_xml v =
      List.map
        (fun x ->
           Ezxmlm.make_tag "member"
             ([], (PatchGroupPatchBaselineMapping.to_xml x))) v
    let to_json v = `List (List.map PatchGroupPatchBaselineMapping.to_json v)
    let of_json j = Json.to_list PatchGroupPatchBaselineMapping.of_json j
  end
module PutComplianceItemsResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module ListComplianceSummariesRequest =
  struct
    type t =
      {
      filters: ComplianceStringFilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?next_token  ?max_results  () =
      { filters; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  ComplianceStringFilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (ComplianceStringFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (ComplianceStringFilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (ComplianceStringFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module GetParameterResult =
  struct
    type t = {
      parameter: Parameter.t option }
    let make ?parameter  () = { parameter }
    let parse xml =
      Some
        {
          parameter =
            (Util.option_bind (Xml.member "Parameter" xml) Parameter.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.parameter
              (fun f ->
                 Ezxmlm.make_tag "Parameter" ([], (Parameter.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.parameter
              (fun f -> ("parameter", (Parameter.to_json f)))])
    let of_json j =
      {
        parameter =
          (Util.option_map (Json.lookup j "parameter") Parameter.of_json)
      }
  end
module DescribeParametersResult =
  struct
    type t =
      {
      parameters: ParameterMetadataList.t ;
      next_token: String.t option }
    let make ?(parameters= [])  ?next_token  () = { parameters; next_token }
    let parse xml =
      Some
        {
          parameters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Parameters" xml)
                  ParameterMetadataList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Parameters"
                       ([], (ParameterMetadataList.to_xml [x]))))
               v.parameters))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("parameters", (ParameterMetadataList.to_json v.parameters))])
    let of_json j =
      {
        parameters =
          (ParameterMetadataList.of_json
             (Util.of_option_exn (Json.lookup j "parameters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribePatchBaselinesResult =
  struct
    type t =
      {
      baseline_identities: PatchBaselineIdentityList.t ;
      next_token: String.t option }
    let make ?(baseline_identities= [])  ?next_token  () =
      { baseline_identities; next_token }
    let parse xml =
      Some
        {
          baseline_identities =
            (Util.of_option []
               (Util.option_bind (Xml.member "BaselineIdentities" xml)
                  PatchBaselineIdentityList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "BaselineIdentities"
                       ([], (PatchBaselineIdentityList.to_xml [x]))))
               v.baseline_identities))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("baseline_identities",
               (PatchBaselineIdentityList.to_json v.baseline_identities))])
    let of_json j =
      {
        baseline_identities =
          (PatchBaselineIdentityList.of_json
             (Util.of_option_exn (Json.lookup j "baseline_identities")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module InvalidDeletionIdException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module TargetInUseException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module UpdateMaintenanceWindowTaskResult =
  struct
    type t =
      {
      window_id: String.t option ;
      window_task_id: String.t option ;
      targets: Targets.t ;
      task_arn: String.t option ;
      service_role_arn: String.t option ;
      task_parameters: MaintenanceWindowTaskParameters.t option ;
      task_invocation_parameters:
        MaintenanceWindowTaskInvocationParameters.t option ;
      priority: Integer.t option ;
      max_concurrency: String.t option ;
      max_errors: String.t option ;
      logging_info: LoggingInfo.t option ;
      name: String.t option ;
      description: String.t option }
    let make ?window_id  ?window_task_id  ?(targets= [])  ?task_arn 
      ?service_role_arn  ?task_parameters  ?task_invocation_parameters 
      ?priority  ?max_concurrency  ?max_errors  ?logging_info  ?name 
      ?description  () =
      {
        window_id;
        window_task_id;
        targets;
        task_arn;
        service_role_arn;
        task_parameters;
        task_invocation_parameters;
        priority;
        max_concurrency;
        max_errors;
        logging_info;
        name;
        description
      }
    let parse xml =
      Some
        {
          window_id =
            (Util.option_bind (Xml.member "WindowId" xml) String.parse);
          window_task_id =
            (Util.option_bind (Xml.member "WindowTaskId" xml) String.parse);
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          task_arn =
            (Util.option_bind (Xml.member "TaskArn" xml) String.parse);
          service_role_arn =
            (Util.option_bind (Xml.member "ServiceRoleArn" xml) String.parse);
          task_parameters =
            (Util.option_bind (Xml.member "TaskParameters" xml)
               MaintenanceWindowTaskParameters.parse);
          task_invocation_parameters =
            (Util.option_bind (Xml.member "TaskInvocationParameters" xml)
               MaintenanceWindowTaskInvocationParameters.parse);
          priority =
            (Util.option_bind (Xml.member "Priority" xml) Integer.parse);
          max_concurrency =
            (Util.option_bind (Xml.member "MaxConcurrency" xml) String.parse);
          max_errors =
            (Util.option_bind (Xml.member "MaxErrors" xml) String.parse);
          logging_info =
            (Util.option_bind (Xml.member "LoggingInfo" xml)
               LoggingInfo.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.window_id
                          (fun f ->
                             Ezxmlm.make_tag "WindowId"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.window_task_id
                         (fun f ->
                            Ezxmlm.make_tag "WindowTaskId"
                              ([], (String.to_xml f)))])
                     @
                     (List.map
                        (fun x ->
                           Some
                             (Ezxmlm.make_tag "Targets"
                                ([], (Targets.to_xml [x])))) v.targets))
                    @
                    [Util.option_map v.task_arn
                       (fun f ->
                          Ezxmlm.make_tag "TaskArn" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.service_role_arn
                      (fun f ->
                         Ezxmlm.make_tag "ServiceRoleArn"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.task_parameters
                     (fun f ->
                        Ezxmlm.make_tag "TaskParameters"
                          ([], (MaintenanceWindowTaskParameters.to_xml f)))])
                 @
                 [Util.option_map v.task_invocation_parameters
                    (fun f ->
                       Ezxmlm.make_tag "TaskInvocationParameters"
                         ([],
                           (MaintenanceWindowTaskInvocationParameters.to_xml
                              f)))])
                @
                [Util.option_map v.priority
                   (fun f ->
                      Ezxmlm.make_tag "Priority" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.max_concurrency
                  (fun f ->
                     Ezxmlm.make_tag "MaxConcurrency" ([], (String.to_xml f)))])
              @
              [Util.option_map v.max_errors
                 (fun f ->
                    Ezxmlm.make_tag "MaxErrors" ([], (String.to_xml f)))])
             @
             [Util.option_map v.logging_info
                (fun f ->
                   Ezxmlm.make_tag "LoggingInfo" ([], (LoggingInfo.to_xml f)))])
            @
            [Util.option_map v.name
               (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
           @
           [Util.option_map v.description
              (fun f -> Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.logging_info
             (fun f -> ("logging_info", (LoggingInfo.to_json f)));
           Util.option_map v.max_errors
             (fun f -> ("max_errors", (String.to_json f)));
           Util.option_map v.max_concurrency
             (fun f -> ("max_concurrency", (String.to_json f)));
           Util.option_map v.priority
             (fun f -> ("priority", (Integer.to_json f)));
           Util.option_map v.task_invocation_parameters
             (fun f ->
                ("task_invocation_parameters",
                  (MaintenanceWindowTaskInvocationParameters.to_json f)));
           Util.option_map v.task_parameters
             (fun f ->
                ("task_parameters",
                  (MaintenanceWindowTaskParameters.to_json f)));
           Util.option_map v.service_role_arn
             (fun f -> ("service_role_arn", (String.to_json f)));
           Util.option_map v.task_arn
             (fun f -> ("task_arn", (String.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Util.option_map v.window_task_id
             (fun f -> ("window_task_id", (String.to_json f)));
           Util.option_map v.window_id
             (fun f -> ("window_id", (String.to_json f)))])
    let of_json j =
      {
        window_id =
          (Util.option_map (Json.lookup j "window_id") String.of_json);
        window_task_id =
          (Util.option_map (Json.lookup j "window_task_id") String.of_json);
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        task_arn =
          (Util.option_map (Json.lookup j "task_arn") String.of_json);
        service_role_arn =
          (Util.option_map (Json.lookup j "service_role_arn") String.of_json);
        task_parameters =
          (Util.option_map (Json.lookup j "task_parameters")
             MaintenanceWindowTaskParameters.of_json);
        task_invocation_parameters =
          (Util.option_map (Json.lookup j "task_invocation_parameters")
             MaintenanceWindowTaskInvocationParameters.of_json);
        priority =
          (Util.option_map (Json.lookup j "priority") Integer.of_json);
        max_concurrency =
          (Util.option_map (Json.lookup j "max_concurrency") String.of_json);
        max_errors =
          (Util.option_map (Json.lookup j "max_errors") String.of_json);
        logging_info =
          (Util.option_map (Json.lookup j "logging_info") LoggingInfo.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module InvalidAutomationExecutionParametersException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module InvalidOutputFolder =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module GetMaintenanceWindowExecutionTaskInvocationRequest =
  struct
    type t =
      {
      window_execution_id: String.t ;
      task_id: String.t ;
      invocation_id: String.t }
    let make ~window_execution_id  ~task_id  ~invocation_id  () =
      { window_execution_id; task_id; invocation_id }
    let parse xml =
      Some
        {
          window_execution_id =
            (Xml.required "WindowExecutionId"
               (Util.option_bind (Xml.member "WindowExecutionId" xml)
                  String.parse));
          task_id =
            (Xml.required "TaskId"
               (Util.option_bind (Xml.member "TaskId" xml) String.parse));
          invocation_id =
            (Xml.required "InvocationId"
               (Util.option_bind (Xml.member "InvocationId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "WindowExecutionId"
                   ([], (String.to_xml v.window_execution_id)))])
            @
            [Some (Ezxmlm.make_tag "TaskId" ([], (String.to_xml v.task_id)))])
           @
           [Some
              (Ezxmlm.make_tag "InvocationId"
                 ([], (String.to_xml v.invocation_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("invocation_id", (String.to_json v.invocation_id));
           Some ("task_id", (String.to_json v.task_id));
           Some
             ("window_execution_id", (String.to_json v.window_execution_id))])
    let of_json j =
      {
        window_execution_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "window_execution_id")));
        task_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "task_id")));
        invocation_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "invocation_id")))
      }
  end
module DescribeMaintenanceWindowScheduleResult =
  struct
    type t =
      {
      scheduled_window_executions: ScheduledWindowExecutionList.t ;
      next_token: String.t option }
    let make ?(scheduled_window_executions= [])  ?next_token  () =
      { scheduled_window_executions; next_token }
    let parse xml =
      Some
        {
          scheduled_window_executions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ScheduledWindowExecutions" xml)
                  ScheduledWindowExecutionList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ScheduledWindowExecutions"
                       ([], (ScheduledWindowExecutionList.to_xml [x]))))
               v.scheduled_window_executions))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("scheduled_window_executions",
               (ScheduledWindowExecutionList.to_json
                  v.scheduled_window_executions))])
    let of_json j =
      {
        scheduled_window_executions =
          (ScheduledWindowExecutionList.of_json
             (Util.of_option_exn
                (Json.lookup j "scheduled_window_executions")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ListAssociationsRequest =
  struct
    type t =
      {
      association_filter_list: AssociationFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(association_filter_list= [])  ?max_results  ?next_token  () =
      { association_filter_list; max_results; next_token }
    let parse xml =
      Some
        {
          association_filter_list =
            (Util.of_option []
               (Util.option_bind (Xml.member "AssociationFilterList" xml)
                  AssociationFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "AssociationFilterList"
                        ([], (AssociationFilterList.to_xml [x]))))
                v.association_filter_list))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("association_filter_list",
               (AssociationFilterList.to_json v.association_filter_list))])
    let of_json j =
      {
        association_filter_list =
          (AssociationFilterList.of_json
             (Util.of_option_exn (Json.lookup j "association_filter_list")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module MaxDocumentSizeExceeded =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module GetMaintenanceWindowExecutionResult =
  struct
    type t =
      {
      window_execution_id: String.t option ;
      task_ids: MaintenanceWindowExecutionTaskIdList.t ;
      status: MaintenanceWindowExecutionStatus.t option ;
      status_details: String.t option ;
      start_time: DateTime.t option ;
      end_time: DateTime.t option }
    let make ?window_execution_id  ?(task_ids= [])  ?status  ?status_details 
      ?start_time  ?end_time  () =
      {
        window_execution_id;
        task_ids;
        status;
        status_details;
        start_time;
        end_time
      }
    let parse xml =
      Some
        {
          window_execution_id =
            (Util.option_bind (Xml.member "WindowExecutionId" xml)
               String.parse);
          task_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "TaskIds" xml)
                  MaintenanceWindowExecutionTaskIdList.parse));
          status =
            (Util.option_bind (Xml.member "Status" xml)
               MaintenanceWindowExecutionStatus.parse);
          status_details =
            (Util.option_bind (Xml.member "StatusDetails" xml) String.parse);
          start_time =
            (Util.option_bind (Xml.member "StartTime" xml) DateTime.parse);
          end_time =
            (Util.option_bind (Xml.member "EndTime" xml) DateTime.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.window_execution_id
                   (fun f ->
                      Ezxmlm.make_tag "WindowExecutionId"
                        ([], (String.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "TaskIds"
                          ([],
                            (MaintenanceWindowExecutionTaskIdList.to_xml [x]))))
                  v.task_ids))
              @
              [Util.option_map v.status
                 (fun f ->
                    Ezxmlm.make_tag "Status"
                      ([], (MaintenanceWindowExecutionStatus.to_xml f)))])
             @
             [Util.option_map v.status_details
                (fun f ->
                   Ezxmlm.make_tag "StatusDetails" ([], (String.to_xml f)))])
            @
            [Util.option_map v.start_time
               (fun f ->
                  Ezxmlm.make_tag "StartTime" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.end_time
              (fun f -> Ezxmlm.make_tag "EndTime" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.end_time
              (fun f -> ("end_time", (DateTime.to_json f)));
           Util.option_map v.start_time
             (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.status_details
             (fun f -> ("status_details", (String.to_json f)));
           Util.option_map v.status
             (fun f ->
                ("status", (MaintenanceWindowExecutionStatus.to_json f)));
           Some
             ("task_ids",
               (MaintenanceWindowExecutionTaskIdList.to_json v.task_ids));
           Util.option_map v.window_execution_id
             (fun f -> ("window_execution_id", (String.to_json f)))])
    let of_json j =
      {
        window_execution_id =
          (Util.option_map (Json.lookup j "window_execution_id")
             String.of_json);
        task_ids =
          (MaintenanceWindowExecutionTaskIdList.of_json
             (Util.of_option_exn (Json.lookup j "task_ids")));
        status =
          (Util.option_map (Json.lookup j "status")
             MaintenanceWindowExecutionStatus.of_json);
        status_details =
          (Util.option_map (Json.lookup j "status_details") String.of_json);
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json);
        end_time =
          (Util.option_map (Json.lookup j "end_time") DateTime.of_json)
      }
  end
module GetParameterHistoryResult =
  struct
    type t =
      {
      parameters: ParameterHistoryList.t ;
      next_token: String.t option }
    let make ?(parameters= [])  ?next_token  () = { parameters; next_token }
    let parse xml =
      Some
        {
          parameters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Parameters" xml)
                  ParameterHistoryList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Parameters"
                       ([], (ParameterHistoryList.to_xml [x])))) v.parameters))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("parameters", (ParameterHistoryList.to_json v.parameters))])
    let of_json j =
      {
        parameters =
          (ParameterHistoryList.of_json
             (Util.of_option_exn (Json.lookup j "parameters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribePatchGroupStateResult =
  struct
    type t =
      {
      instances: Integer.t option ;
      instances_with_installed_patches: Integer.t option ;
      instances_with_installed_other_patches: Integer.t option ;
      instances_with_installed_pending_reboot_patches: Integer.t option ;
      instances_with_installed_rejected_patches: Integer.t option ;
      instances_with_missing_patches: Integer.t option ;
      instances_with_failed_patches: Integer.t option ;
      instances_with_not_applicable_patches: Integer.t option ;
      instances_with_unreported_not_applicable_patches: Integer.t option }
    let make ?instances  ?instances_with_installed_patches 
      ?instances_with_installed_other_patches 
      ?instances_with_installed_pending_reboot_patches 
      ?instances_with_installed_rejected_patches 
      ?instances_with_missing_patches  ?instances_with_failed_patches 
      ?instances_with_not_applicable_patches 
      ?instances_with_unreported_not_applicable_patches  () =
      {
        instances;
        instances_with_installed_patches;
        instances_with_installed_other_patches;
        instances_with_installed_pending_reboot_patches;
        instances_with_installed_rejected_patches;
        instances_with_missing_patches;
        instances_with_failed_patches;
        instances_with_not_applicable_patches;
        instances_with_unreported_not_applicable_patches
      }
    let parse xml =
      Some
        {
          instances =
            (Util.option_bind (Xml.member "Instances" xml) Integer.parse);
          instances_with_installed_patches =
            (Util.option_bind
               (Xml.member "InstancesWithInstalledPatches" xml) Integer.parse);
          instances_with_installed_other_patches =
            (Util.option_bind
               (Xml.member "InstancesWithInstalledOtherPatches" xml)
               Integer.parse);
          instances_with_installed_pending_reboot_patches =
            (Util.option_bind
               (Xml.member "InstancesWithInstalledPendingRebootPatches" xml)
               Integer.parse);
          instances_with_installed_rejected_patches =
            (Util.option_bind
               (Xml.member "InstancesWithInstalledRejectedPatches" xml)
               Integer.parse);
          instances_with_missing_patches =
            (Util.option_bind (Xml.member "InstancesWithMissingPatches" xml)
               Integer.parse);
          instances_with_failed_patches =
            (Util.option_bind (Xml.member "InstancesWithFailedPatches" xml)
               Integer.parse);
          instances_with_not_applicable_patches =
            (Util.option_bind
               (Xml.member "InstancesWithNotApplicablePatches" xml)
               Integer.parse);
          instances_with_unreported_not_applicable_patches =
            (Util.option_bind
               (Xml.member "InstancesWithUnreportedNotApplicablePatches" xml)
               Integer.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Util.option_map v.instances
                      (fun f ->
                         Ezxmlm.make_tag "Instances" ([], (Integer.to_xml f)))])
                  @
                  [Util.option_map v.instances_with_installed_patches
                     (fun f ->
                        Ezxmlm.make_tag "InstancesWithInstalledPatches"
                          ([], (Integer.to_xml f)))])
                 @
                 [Util.option_map v.instances_with_installed_other_patches
                    (fun f ->
                       Ezxmlm.make_tag "InstancesWithInstalledOtherPatches"
                         ([], (Integer.to_xml f)))])
                @
                [Util.option_map
                   v.instances_with_installed_pending_reboot_patches
                   (fun f ->
                      Ezxmlm.make_tag
                        "InstancesWithInstalledPendingRebootPatches"
                        ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.instances_with_installed_rejected_patches
                  (fun f ->
                     Ezxmlm.make_tag "InstancesWithInstalledRejectedPatches"
                       ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.instances_with_missing_patches
                 (fun f ->
                    Ezxmlm.make_tag "InstancesWithMissingPatches"
                      ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.instances_with_failed_patches
                (fun f ->
                   Ezxmlm.make_tag "InstancesWithFailedPatches"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.instances_with_not_applicable_patches
               (fun f ->
                  Ezxmlm.make_tag "InstancesWithNotApplicablePatches"
                    ([], (Integer.to_xml f)))])
           @
           [Util.option_map
              v.instances_with_unreported_not_applicable_patches
              (fun f ->
                 Ezxmlm.make_tag
                   "InstancesWithUnreportedNotApplicablePatches"
                   ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map
              v.instances_with_unreported_not_applicable_patches
              (fun f ->
                 ("instances_with_unreported_not_applicable_patches",
                   (Integer.to_json f)));
           Util.option_map v.instances_with_not_applicable_patches
             (fun f ->
                ("instances_with_not_applicable_patches",
                  (Integer.to_json f)));
           Util.option_map v.instances_with_failed_patches
             (fun f -> ("instances_with_failed_patches", (Integer.to_json f)));
           Util.option_map v.instances_with_missing_patches
             (fun f ->
                ("instances_with_missing_patches", (Integer.to_json f)));
           Util.option_map v.instances_with_installed_rejected_patches
             (fun f ->
                ("instances_with_installed_rejected_patches",
                  (Integer.to_json f)));
           Util.option_map v.instances_with_installed_pending_reboot_patches
             (fun f ->
                ("instances_with_installed_pending_reboot_patches",
                  (Integer.to_json f)));
           Util.option_map v.instances_with_installed_other_patches
             (fun f ->
                ("instances_with_installed_other_patches",
                  (Integer.to_json f)));
           Util.option_map v.instances_with_installed_patches
             (fun f ->
                ("instances_with_installed_patches", (Integer.to_json f)));
           Util.option_map v.instances
             (fun f -> ("instances", (Integer.to_json f)))])
    let of_json j =
      {
        instances =
          (Util.option_map (Json.lookup j "instances") Integer.of_json);
        instances_with_installed_patches =
          (Util.option_map (Json.lookup j "instances_with_installed_patches")
             Integer.of_json);
        instances_with_installed_other_patches =
          (Util.option_map
             (Json.lookup j "instances_with_installed_other_patches")
             Integer.of_json);
        instances_with_installed_pending_reboot_patches =
          (Util.option_map
             (Json.lookup j "instances_with_installed_pending_reboot_patches")
             Integer.of_json);
        instances_with_installed_rejected_patches =
          (Util.option_map
             (Json.lookup j "instances_with_installed_rejected_patches")
             Integer.of_json);
        instances_with_missing_patches =
          (Util.option_map (Json.lookup j "instances_with_missing_patches")
             Integer.of_json);
        instances_with_failed_patches =
          (Util.option_map (Json.lookup j "instances_with_failed_patches")
             Integer.of_json);
        instances_with_not_applicable_patches =
          (Util.option_map
             (Json.lookup j "instances_with_not_applicable_patches")
             Integer.of_json);
        instances_with_unreported_not_applicable_patches =
          (Util.option_map
             (Json.lookup j
                "instances_with_unreported_not_applicable_patches")
             Integer.of_json)
      }
  end
module DeregisterTaskFromMaintenanceWindowRequest =
  struct
    type t = {
      window_id: String.t ;
      window_task_id: String.t }
    let make ~window_id  ~window_task_id  () = { window_id; window_task_id }
    let parse xml =
      Some
        {
          window_id =
            (Xml.required "WindowId"
               (Util.option_bind (Xml.member "WindowId" xml) String.parse));
          window_task_id =
            (Xml.required "WindowTaskId"
               (Util.option_bind (Xml.member "WindowTaskId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "WindowId" ([], (String.to_xml v.window_id)))])
           @
           [Some
              (Ezxmlm.make_tag "WindowTaskId"
                 ([], (String.to_xml v.window_task_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("window_task_id", (String.to_json v.window_task_id));
           Some ("window_id", (String.to_json v.window_id))])
    let of_json j =
      {
        window_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "window_id")));
        window_task_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "window_task_id")))
      }
  end
module DescribeInstanceInformationResult =
  struct
    type t =
      {
      instance_information_list: InstanceInformationList.t ;
      next_token: String.t option }
    let make ?(instance_information_list= [])  ?next_token  () =
      { instance_information_list; next_token }
    let parse xml =
      Some
        {
          instance_information_list =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceInformationList" xml)
                  InstanceInformationList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "InstanceInformationList"
                       ([], (InstanceInformationList.to_xml [x]))))
               v.instance_information_list))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_information_list",
               (InstanceInformationList.to_json v.instance_information_list))])
    let of_json j =
      {
        instance_information_list =
          (InstanceInformationList.of_json
             (Util.of_option_exn (Json.lookup j "instance_information_list")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ListDocumentVersionsResult =
  struct
    type t =
      {
      document_versions: DocumentVersionList.t ;
      next_token: String.t option }
    let make ?(document_versions= [])  ?next_token  () =
      { document_versions; next_token }
    let parse xml =
      Some
        {
          document_versions =
            (Util.of_option []
               (Util.option_bind (Xml.member "DocumentVersions" xml)
                  DocumentVersionList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "DocumentVersions"
                       ([], (DocumentVersionList.to_xml [x]))))
               v.document_versions))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("document_versions",
               (DocumentVersionList.to_json v.document_versions))])
    let of_json j =
      {
        document_versions =
          (DocumentVersionList.of_json
             (Util.of_option_exn (Json.lookup j "document_versions")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ResourceDataSyncCountExceededException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module AutomationDefinitionNotFoundException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module GetMaintenanceWindowExecutionTaskInvocationResult =
  struct
    type t =
      {
      window_execution_id: String.t option ;
      task_execution_id: String.t option ;
      invocation_id: String.t option ;
      execution_id: String.t option ;
      task_type: MaintenanceWindowTaskType.t option ;
      parameters: String.t option ;
      status: MaintenanceWindowExecutionStatus.t option ;
      status_details: String.t option ;
      start_time: DateTime.t option ;
      end_time: DateTime.t option ;
      owner_information: String.t option ;
      window_target_id: String.t option }
    let make ?window_execution_id  ?task_execution_id  ?invocation_id 
      ?execution_id  ?task_type  ?parameters  ?status  ?status_details 
      ?start_time  ?end_time  ?owner_information  ?window_target_id  () =
      {
        window_execution_id;
        task_execution_id;
        invocation_id;
        execution_id;
        task_type;
        parameters;
        status;
        status_details;
        start_time;
        end_time;
        owner_information;
        window_target_id
      }
    let parse xml =
      Some
        {
          window_execution_id =
            (Util.option_bind (Xml.member "WindowExecutionId" xml)
               String.parse);
          task_execution_id =
            (Util.option_bind (Xml.member "TaskExecutionId" xml) String.parse);
          invocation_id =
            (Util.option_bind (Xml.member "InvocationId" xml) String.parse);
          execution_id =
            (Util.option_bind (Xml.member "ExecutionId" xml) String.parse);
          task_type =
            (Util.option_bind (Xml.member "TaskType" xml)
               MaintenanceWindowTaskType.parse);
          parameters =
            (Util.option_bind (Xml.member "Parameters" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml)
               MaintenanceWindowExecutionStatus.parse);
          status_details =
            (Util.option_bind (Xml.member "StatusDetails" xml) String.parse);
          start_time =
            (Util.option_bind (Xml.member "StartTime" xml) DateTime.parse);
          end_time =
            (Util.option_bind (Xml.member "EndTime" xml) DateTime.parse);
          owner_information =
            (Util.option_bind (Xml.member "OwnerInformation" xml)
               String.parse);
          window_target_id =
            (Util.option_bind (Xml.member "WindowTargetId" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Util.option_map v.window_execution_id
                         (fun f ->
                            Ezxmlm.make_tag "WindowExecutionId"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.task_execution_id
                        (fun f ->
                           Ezxmlm.make_tag "TaskExecutionId"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.invocation_id
                       (fun f ->
                          Ezxmlm.make_tag "InvocationId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.execution_id
                      (fun f ->
                         Ezxmlm.make_tag "ExecutionId"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.task_type
                     (fun f ->
                        Ezxmlm.make_tag "TaskType"
                          ([], (MaintenanceWindowTaskType.to_xml f)))])
                 @
                 [Util.option_map v.parameters
                    (fun f ->
                       Ezxmlm.make_tag "Parameters" ([], (String.to_xml f)))])
                @
                [Util.option_map v.status
                   (fun f ->
                      Ezxmlm.make_tag "Status"
                        ([], (MaintenanceWindowExecutionStatus.to_xml f)))])
               @
               [Util.option_map v.status_details
                  (fun f ->
                     Ezxmlm.make_tag "StatusDetails" ([], (String.to_xml f)))])
              @
              [Util.option_map v.start_time
                 (fun f ->
                    Ezxmlm.make_tag "StartTime" ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.end_time
                (fun f -> Ezxmlm.make_tag "EndTime" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.owner_information
               (fun f ->
                  Ezxmlm.make_tag "OwnerInformation" ([], (String.to_xml f)))])
           @
           [Util.option_map v.window_target_id
              (fun f ->
                 Ezxmlm.make_tag "WindowTargetId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.window_target_id
              (fun f -> ("window_target_id", (String.to_json f)));
           Util.option_map v.owner_information
             (fun f -> ("owner_information", (String.to_json f)));
           Util.option_map v.end_time
             (fun f -> ("end_time", (DateTime.to_json f)));
           Util.option_map v.start_time
             (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.status_details
             (fun f -> ("status_details", (String.to_json f)));
           Util.option_map v.status
             (fun f ->
                ("status", (MaintenanceWindowExecutionStatus.to_json f)));
           Util.option_map v.parameters
             (fun f -> ("parameters", (String.to_json f)));
           Util.option_map v.task_type
             (fun f -> ("task_type", (MaintenanceWindowTaskType.to_json f)));
           Util.option_map v.execution_id
             (fun f -> ("execution_id", (String.to_json f)));
           Util.option_map v.invocation_id
             (fun f -> ("invocation_id", (String.to_json f)));
           Util.option_map v.task_execution_id
             (fun f -> ("task_execution_id", (String.to_json f)));
           Util.option_map v.window_execution_id
             (fun f -> ("window_execution_id", (String.to_json f)))])
    let of_json j =
      {
        window_execution_id =
          (Util.option_map (Json.lookup j "window_execution_id")
             String.of_json);
        task_execution_id =
          (Util.option_map (Json.lookup j "task_execution_id") String.of_json);
        invocation_id =
          (Util.option_map (Json.lookup j "invocation_id") String.of_json);
        execution_id =
          (Util.option_map (Json.lookup j "execution_id") String.of_json);
        task_type =
          (Util.option_map (Json.lookup j "task_type")
             MaintenanceWindowTaskType.of_json);
        parameters =
          (Util.option_map (Json.lookup j "parameters") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             MaintenanceWindowExecutionStatus.of_json);
        status_details =
          (Util.option_map (Json.lookup j "status_details") String.of_json);
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json);
        end_time =
          (Util.option_map (Json.lookup j "end_time") DateTime.of_json);
        owner_information =
          (Util.option_map (Json.lookup j "owner_information") String.of_json);
        window_target_id =
          (Util.option_map (Json.lookup j "window_target_id") String.of_json)
      }
  end
module InvalidAutomationStatusUpdateException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeAssociationExecutionTargetsRequest =
  struct
    type t =
      {
      association_id: String.t ;
      execution_id: String.t ;
      filters: AssociationExecutionTargetsFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ~association_id  ~execution_id  ?(filters= [])  ?max_results 
      ?next_token  () =
      { association_id; execution_id; filters; max_results; next_token }
    let parse xml =
      Some
        {
          association_id =
            (Xml.required "AssociationId"
               (Util.option_bind (Xml.member "AssociationId" xml)
                  String.parse));
          execution_id =
            (Xml.required "ExecutionId"
               (Util.option_bind (Xml.member "ExecutionId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  AssociationExecutionTargetsFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "AssociationId"
                     ([], (String.to_xml v.association_id)))])
              @
              [Some
                 (Ezxmlm.make_tag "ExecutionId"
                    ([], (String.to_xml v.execution_id)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([],
                          (AssociationExecutionTargetsFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("filters",
               (AssociationExecutionTargetsFilterList.to_json v.filters));
           Some ("execution_id", (String.to_json v.execution_id));
           Some ("association_id", (String.to_json v.association_id))])
    let of_json j =
      {
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")));
        execution_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "execution_id")));
        filters =
          (AssociationExecutionTargetsFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module UpdateMaintenanceWindowTargetResult =
  struct
    type t =
      {
      window_id: String.t option ;
      window_target_id: String.t option ;
      targets: Targets.t ;
      owner_information: String.t option ;
      name: String.t option ;
      description: String.t option }
    let make ?window_id  ?window_target_id  ?(targets= []) 
      ?owner_information  ?name  ?description  () =
      {
        window_id;
        window_target_id;
        targets;
        owner_information;
        name;
        description
      }
    let parse xml =
      Some
        {
          window_id =
            (Util.option_bind (Xml.member "WindowId" xml) String.parse);
          window_target_id =
            (Util.option_bind (Xml.member "WindowTargetId" xml) String.parse);
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          owner_information =
            (Util.option_bind (Xml.member "OwnerInformation" xml)
               String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.window_id
                   (fun f ->
                      Ezxmlm.make_tag "WindowId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.window_target_id
                  (fun f ->
                     Ezxmlm.make_tag "WindowTargetId" ([], (String.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Targets" ([], (Targets.to_xml [x]))))
                 v.targets))
             @
             [Util.option_map v.owner_information
                (fun f ->
                   Ezxmlm.make_tag "OwnerInformation" ([], (String.to_xml f)))])
            @
            [Util.option_map v.name
               (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
           @
           [Util.option_map v.description
              (fun f -> Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.owner_information
             (fun f -> ("owner_information", (String.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Util.option_map v.window_target_id
             (fun f -> ("window_target_id", (String.to_json f)));
           Util.option_map v.window_id
             (fun f -> ("window_id", (String.to_json f)))])
    let of_json j =
      {
        window_id =
          (Util.option_map (Json.lookup j "window_id") String.of_json);
        window_target_id =
          (Util.option_map (Json.lookup j "window_target_id") String.of_json);
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        owner_information =
          (Util.option_map (Json.lookup j "owner_information") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module DescribeAutomationStepExecutionsRequest =
  struct
    type t =
      {
      automation_execution_id: String.t ;
      filters: StepExecutionFilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      reverse_order: Boolean.t option }
    let make ~automation_execution_id  ?(filters= [])  ?next_token 
      ?max_results  ?reverse_order  () =
      {
        automation_execution_id;
        filters;
        next_token;
        max_results;
        reverse_order
      }
    let parse xml =
      Some
        {
          automation_execution_id =
            (Xml.required "AutomationExecutionId"
               (Util.option_bind (Xml.member "AutomationExecutionId" xml)
                  String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  StepExecutionFilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          reverse_order =
            (Util.option_bind (Xml.member "ReverseOrder" xml) Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "AutomationExecutionId"
                     ([], (String.to_xml v.automation_execution_id)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filters"
                         ([], (StepExecutionFilterList.to_xml [x]))))
                 v.filters))
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.reverse_order
              (fun f ->
                 Ezxmlm.make_tag "ReverseOrder" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reverse_order
              (fun f -> ("reverse_order", (Boolean.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (StepExecutionFilterList.to_json v.filters));
           Some
             ("automation_execution_id",
               (String.to_json v.automation_execution_id))])
    let of_json j =
      {
        automation_execution_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "automation_execution_id")));
        filters =
          (StepExecutionFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        reverse_order =
          (Util.option_map (Json.lookup j "reverse_order") Boolean.of_json)
      }
  end
module InvalidActivationId =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DocumentPermissionLimit =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module GetInventorySchemaRequest =
  struct
    type t =
      {
      type_name: String.t option ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      aggregator: Boolean.t option ;
      sub_type: Boolean.t option }
    let make ?type_name  ?next_token  ?max_results  ?aggregator  ?sub_type 
      () = { type_name; next_token; max_results; aggregator; sub_type }
    let parse xml =
      Some
        {
          type_name =
            (Util.option_bind (Xml.member "TypeName" xml) String.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          aggregator =
            (Util.option_bind (Xml.member "Aggregator" xml) Boolean.parse);
          sub_type =
            (Util.option_bind (Xml.member "SubType" xml) Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.type_name
                  (fun f ->
                     Ezxmlm.make_tag "TypeName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.next_token
                 (fun f ->
                    Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.aggregator
               (fun f ->
                  Ezxmlm.make_tag "Aggregator" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.sub_type
              (fun f -> Ezxmlm.make_tag "SubType" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.sub_type
              (fun f -> ("sub_type", (Boolean.to_json f)));
           Util.option_map v.aggregator
             (fun f -> ("aggregator", (Boolean.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.type_name
             (fun f -> ("type_name", (String.to_json f)))])
    let of_json j =
      {
        type_name =
          (Util.option_map (Json.lookup j "type_name") String.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        aggregator =
          (Util.option_map (Json.lookup j "aggregator") Boolean.of_json);
        sub_type =
          (Util.option_map (Json.lookup j "sub_type") Boolean.of_json)
      }
  end
module DocumentAlreadyExists =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module GetServiceSettingResult =
  struct
    type t = {
      service_setting: ServiceSetting.t option }
    let make ?service_setting  () = { service_setting }
    let parse xml =
      Some
        {
          service_setting =
            (Util.option_bind (Xml.member "ServiceSetting" xml)
               ServiceSetting.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.service_setting
              (fun f ->
                 Ezxmlm.make_tag "ServiceSetting"
                   ([], (ServiceSetting.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.service_setting
              (fun f -> ("service_setting", (ServiceSetting.to_json f)))])
    let of_json j =
      {
        service_setting =
          (Util.option_map (Json.lookup j "service_setting")
             ServiceSetting.of_json)
      }
  end
module DeleteResourceDataSyncResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module DescribeAssociationResult =
  struct
    type t = {
      association_description: AssociationDescription.t option }
    let make ?association_description  () = { association_description }
    let parse xml =
      Some
        {
          association_description =
            (Util.option_bind (Xml.member "AssociationDescription" xml)
               AssociationDescription.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.association_description
              (fun f ->
                 Ezxmlm.make_tag "AssociationDescription"
                   ([], (AssociationDescription.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_description
              (fun f ->
                 ("association_description",
                   (AssociationDescription.to_json f)))])
    let of_json j =
      {
        association_description =
          (Util.option_map (Json.lookup j "association_description")
             AssociationDescription.of_json)
      }
  end
module DescribeAutomationExecutionsResult =
  struct
    type t =
      {
      automation_execution_metadata_list: AutomationExecutionMetadataList.t ;
      next_token: String.t option }
    let make ?(automation_execution_metadata_list= [])  ?next_token  () =
      { automation_execution_metadata_list; next_token }
    let parse xml =
      Some
        {
          automation_execution_metadata_list =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "AutomationExecutionMetadataList" xml)
                  AutomationExecutionMetadataList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "AutomationExecutionMetadataList"
                       ([], (AutomationExecutionMetadataList.to_xml [x]))))
               v.automation_execution_metadata_list))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("automation_execution_metadata_list",
               (AutomationExecutionMetadataList.to_json
                  v.automation_execution_metadata_list))])
    let of_json j =
      {
        automation_execution_metadata_list =
          (AutomationExecutionMetadataList.of_json
             (Util.of_option_exn
                (Json.lookup j "automation_execution_metadata_list")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ListAssociationVersionsRequest =
  struct
    type t =
      {
      association_id: String.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ~association_id  ?max_results  ?next_token  () =
      { association_id; max_results; next_token }
    let parse xml =
      Some
        {
          association_id =
            (Xml.required "AssociationId"
               (Util.option_bind (Xml.member "AssociationId" xml)
                  String.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "AssociationId"
                   ([], (String.to_xml v.association_id)))])
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("association_id", (String.to_json v.association_id))])
    let of_json j =
      {
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ListDocumentsResult =
  struct
    type t =
      {
      document_identifiers: DocumentIdentifierList.t ;
      next_token: String.t option }
    let make ?(document_identifiers= [])  ?next_token  () =
      { document_identifiers; next_token }
    let parse xml =
      Some
        {
          document_identifiers =
            (Util.of_option []
               (Util.option_bind (Xml.member "DocumentIdentifiers" xml)
                  DocumentIdentifierList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "DocumentIdentifiers"
                       ([], (DocumentIdentifierList.to_xml [x]))))
               v.document_identifiers))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("document_identifiers",
               (DocumentIdentifierList.to_json v.document_identifiers))])
    let of_json j =
      {
        document_identifiers =
          (DocumentIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "document_identifiers")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module InvalidDocumentSchemaVersion =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ListResourceComplianceSummariesRequest =
  struct
    type t =
      {
      filters: ComplianceStringFilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?next_token  ?max_results  () =
      { filters; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  ComplianceStringFilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (ComplianceStringFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (ComplianceStringFilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (ComplianceStringFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module AddTagsToResourceResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module DuplicateDocumentVersionName =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module AlreadyExistsException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module InvalidResultAttributeException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module InvalidDeleteInventoryParametersException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ResourceDataSyncAlreadyExistsException =
  struct
    type t = {
      sync_name: String.t option }
    let make ?sync_name  () = { sync_name }
    let parse xml =
      Some
        {
          sync_name =
            (Util.option_bind (Xml.member "SyncName" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.sync_name
              (fun f -> Ezxmlm.make_tag "SyncName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.sync_name
              (fun f -> ("sync_name", (String.to_json f)))])
    let of_json j =
      {
        sync_name =
          (Util.option_map (Json.lookup j "sync_name") String.of_json)
      }
  end
module DescribeDocumentRequest =
  struct
    type t =
      {
      name: String.t ;
      document_version: String.t option ;
      version_name: String.t option }
    let make ~name  ?document_version  ?version_name  () =
      { name; document_version; version_name }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          version_name =
            (Util.option_bind (Xml.member "VersionName" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
            @
            [Util.option_map v.document_version
               (fun f ->
                  Ezxmlm.make_tag "DocumentVersion" ([], (String.to_xml f)))])
           @
           [Util.option_map v.version_name
              (fun f -> Ezxmlm.make_tag "VersionName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.version_name
              (fun f -> ("version_name", (String.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        version_name =
          (Util.option_map (Json.lookup j "version_name") String.of_json)
      }
  end
module CreateAssociationRequest =
  struct
    type t =
      {
      name: String.t ;
      document_version: String.t option ;
      instance_id: String.t option ;
      parameters: Parameters.t option ;
      targets: Targets.t ;
      schedule_expression: String.t option ;
      output_location: InstanceAssociationOutputLocation.t option ;
      association_name: String.t option ;
      automation_target_parameter_name: String.t option ;
      max_errors: String.t option ;
      max_concurrency: String.t option ;
      compliance_severity: AssociationComplianceSeverity.t option }
    let make ~name  ?document_version  ?instance_id  ?parameters  ?(targets=
      [])  ?schedule_expression  ?output_location  ?association_name 
      ?automation_target_parameter_name  ?max_errors  ?max_concurrency 
      ?compliance_severity  () =
      {
        name;
        document_version;
        instance_id;
        parameters;
        targets;
        schedule_expression;
        output_location;
        association_name;
        automation_target_parameter_name;
        max_errors;
        max_concurrency;
        compliance_severity
      }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          parameters =
            (Util.option_bind (Xml.member "Parameters" xml) Parameters.parse);
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          schedule_expression =
            (Util.option_bind (Xml.member "ScheduleExpression" xml)
               String.parse);
          output_location =
            (Util.option_bind (Xml.member "OutputLocation" xml)
               InstanceAssociationOutputLocation.parse);
          association_name =
            (Util.option_bind (Xml.member "AssociationName" xml) String.parse);
          automation_target_parameter_name =
            (Util.option_bind
               (Xml.member "AutomationTargetParameterName" xml) String.parse);
          max_errors =
            (Util.option_bind (Xml.member "MaxErrors" xml) String.parse);
          max_concurrency =
            (Util.option_bind (Xml.member "MaxConcurrency" xml) String.parse);
          compliance_severity =
            (Util.option_bind (Xml.member "ComplianceSeverity" xml)
               AssociationComplianceSeverity.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Some
                         (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
                     @
                     [Util.option_map v.document_version
                        (fun f ->
                           Ezxmlm.make_tag "DocumentVersion"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.instance_id
                       (fun f ->
                          Ezxmlm.make_tag "InstanceId"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.parameters
                      (fun f ->
                         Ezxmlm.make_tag "Parameters"
                           ([], (Parameters.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "Targets"
                             ([], (Targets.to_xml [x])))) v.targets))
                 @
                 [Util.option_map v.schedule_expression
                    (fun f ->
                       Ezxmlm.make_tag "ScheduleExpression"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.output_location
                   (fun f ->
                      Ezxmlm.make_tag "OutputLocation"
                        ([], (InstanceAssociationOutputLocation.to_xml f)))])
               @
               [Util.option_map v.association_name
                  (fun f ->
                     Ezxmlm.make_tag "AssociationName"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.automation_target_parameter_name
                 (fun f ->
                    Ezxmlm.make_tag "AutomationTargetParameterName"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.max_errors
                (fun f -> Ezxmlm.make_tag "MaxErrors" ([], (String.to_xml f)))])
            @
            [Util.option_map v.max_concurrency
               (fun f ->
                  Ezxmlm.make_tag "MaxConcurrency" ([], (String.to_xml f)))])
           @
           [Util.option_map v.compliance_severity
              (fun f ->
                 Ezxmlm.make_tag "ComplianceSeverity"
                   ([], (AssociationComplianceSeverity.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.compliance_severity
              (fun f ->
                 ("compliance_severity",
                   (AssociationComplianceSeverity.to_json f)));
           Util.option_map v.max_concurrency
             (fun f -> ("max_concurrency", (String.to_json f)));
           Util.option_map v.max_errors
             (fun f -> ("max_errors", (String.to_json f)));
           Util.option_map v.automation_target_parameter_name
             (fun f ->
                ("automation_target_parameter_name", (String.to_json f)));
           Util.option_map v.association_name
             (fun f -> ("association_name", (String.to_json f)));
           Util.option_map v.output_location
             (fun f ->
                ("output_location",
                  (InstanceAssociationOutputLocation.to_json f)));
           Util.option_map v.schedule_expression
             (fun f -> ("schedule_expression", (String.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Util.option_map v.parameters
             (fun f -> ("parameters", (Parameters.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        parameters =
          (Util.option_map (Json.lookup j "parameters") Parameters.of_json);
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        schedule_expression =
          (Util.option_map (Json.lookup j "schedule_expression")
             String.of_json);
        output_location =
          (Util.option_map (Json.lookup j "output_location")
             InstanceAssociationOutputLocation.of_json);
        association_name =
          (Util.option_map (Json.lookup j "association_name") String.of_json);
        automation_target_parameter_name =
          (Util.option_map (Json.lookup j "automation_target_parameter_name")
             String.of_json);
        max_errors =
          (Util.option_map (Json.lookup j "max_errors") String.of_json);
        max_concurrency =
          (Util.option_map (Json.lookup j "max_concurrency") String.of_json);
        compliance_severity =
          (Util.option_map (Json.lookup j "compliance_severity")
             AssociationComplianceSeverity.of_json)
      }
  end
module InternalServerError =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DeleteInventoryRequest =
  struct
    type t =
      {
      type_name: String.t ;
      schema_delete_option: InventorySchemaDeleteOption.t option ;
      dry_run: Boolean.t option ;
      client_token: String.t option }
    let make ~type_name  ?schema_delete_option  ?dry_run  ?client_token  () =
      { type_name; schema_delete_option; dry_run; client_token }
    let parse xml =
      Some
        {
          type_name =
            (Xml.required "TypeName"
               (Util.option_bind (Xml.member "TypeName" xml) String.parse));
          schema_delete_option =
            (Util.option_bind (Xml.member "SchemaDeleteOption" xml)
               InventorySchemaDeleteOption.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "TypeName"
                    ([], (String.to_xml v.type_name)))])
             @
             [Util.option_map v.schema_delete_option
                (fun f ->
                   Ezxmlm.make_tag "SchemaDeleteOption"
                     ([], (InventorySchemaDeleteOption.to_xml f)))])
            @
            [Util.option_map v.dry_run
               (fun f -> Ezxmlm.make_tag "DryRun" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.schema_delete_option
             (fun f ->
                ("schema_delete_option",
                  (InventorySchemaDeleteOption.to_json f)));
           Some ("type_name", (String.to_json v.type_name))])
    let of_json j =
      {
        type_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "type_name")));
        schema_delete_option =
          (Util.option_map (Json.lookup j "schema_delete_option")
             InventorySchemaDeleteOption.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module InvalidInventoryRequestException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module SendAutomationSignalRequest =
  struct
    type t =
      {
      automation_execution_id: String.t ;
      signal_type: SignalType.t ;
      payload: AutomationParameterMap.t option }
    let make ~automation_execution_id  ~signal_type  ?payload  () =
      { automation_execution_id; signal_type; payload }
    let parse xml =
      Some
        {
          automation_execution_id =
            (Xml.required "AutomationExecutionId"
               (Util.option_bind (Xml.member "AutomationExecutionId" xml)
                  String.parse));
          signal_type =
            (Xml.required "SignalType"
               (Util.option_bind (Xml.member "SignalType" xml)
                  SignalType.parse));
          payload =
            (Util.option_bind (Xml.member "Payload" xml)
               AutomationParameterMap.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "AutomationExecutionId"
                   ([], (String.to_xml v.automation_execution_id)))])
            @
            [Some
               (Ezxmlm.make_tag "SignalType"
                  ([], (SignalType.to_xml v.signal_type)))])
           @
           [Util.option_map v.payload
              (fun f ->
                 Ezxmlm.make_tag "Payload"
                   ([], (AutomationParameterMap.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.payload
              (fun f -> ("payload", (AutomationParameterMap.to_json f)));
           Some ("signal_type", (SignalType.to_json v.signal_type));
           Some
             ("automation_execution_id",
               (String.to_json v.automation_execution_id))])
    let of_json j =
      {
        automation_execution_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "automation_execution_id")));
        signal_type =
          (SignalType.of_json
             (Util.of_option_exn (Json.lookup j "signal_type")));
        payload =
          (Util.option_map (Json.lookup j "payload")
             AutomationParameterMap.of_json)
      }
  end
module StartAssociationsOnceResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module DescribeInstanceInformationRequest =
  struct
    type t =
      {
      instance_information_filter_list: InstanceInformationFilterList.t ;
      filters: InstanceInformationStringFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(instance_information_filter_list= [])  ?(filters= []) 
      ?max_results  ?next_token  () =
      { instance_information_filter_list; filters; max_results; next_token }
    let parse xml =
      Some
        {
          instance_information_filter_list =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "InstanceInformationFilterList" xml)
                  InstanceInformationFilterList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  InstanceInformationStringFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "InstanceInformationFilterList"
                         ([], (InstanceInformationFilterList.to_xml [x]))))
                 v.instance_information_filter_list))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([],
                          (InstanceInformationStringFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("filters",
               (InstanceInformationStringFilterList.to_json v.filters));
           Some
             ("instance_information_filter_list",
               (InstanceInformationFilterList.to_json
                  v.instance_information_filter_list))])
    let of_json j =
      {
        instance_information_filter_list =
          (InstanceInformationFilterList.of_json
             (Util.of_option_exn
                (Json.lookup j "instance_information_filter_list")));
        filters =
          (InstanceInformationStringFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module UpdateMaintenanceWindowResult =
  struct
    type t =
      {
      window_id: String.t option ;
      name: String.t option ;
      description: String.t option ;
      start_date: String.t option ;
      end_date: String.t option ;
      schedule: String.t option ;
      schedule_timezone: String.t option ;
      duration: Integer.t option ;
      cutoff: Integer.t option ;
      allow_unassociated_targets: Boolean.t option ;
      enabled: Boolean.t option }
    let make ?window_id  ?name  ?description  ?start_date  ?end_date 
      ?schedule  ?schedule_timezone  ?duration  ?cutoff 
      ?allow_unassociated_targets  ?enabled  () =
      {
        window_id;
        name;
        description;
        start_date;
        end_date;
        schedule;
        schedule_timezone;
        duration;
        cutoff;
        allow_unassociated_targets;
        enabled
      }
    let parse xml =
      Some
        {
          window_id =
            (Util.option_bind (Xml.member "WindowId" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          start_date =
            (Util.option_bind (Xml.member "StartDate" xml) String.parse);
          end_date =
            (Util.option_bind (Xml.member "EndDate" xml) String.parse);
          schedule =
            (Util.option_bind (Xml.member "Schedule" xml) String.parse);
          schedule_timezone =
            (Util.option_bind (Xml.member "ScheduleTimezone" xml)
               String.parse);
          duration =
            (Util.option_bind (Xml.member "Duration" xml) Integer.parse);
          cutoff = (Util.option_bind (Xml.member "Cutoff" xml) Integer.parse);
          allow_unassociated_targets =
            (Util.option_bind (Xml.member "AllowUnassociatedTargets" xml)
               Boolean.parse);
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.window_id
                        (fun f ->
                           Ezxmlm.make_tag "WindowId" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.name
                       (fun f ->
                          Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.description
                      (fun f ->
                         Ezxmlm.make_tag "Description"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.start_date
                     (fun f ->
                        Ezxmlm.make_tag "StartDate" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.end_date
                    (fun f ->
                       Ezxmlm.make_tag "EndDate" ([], (String.to_xml f)))])
                @
                [Util.option_map v.schedule
                   (fun f ->
                      Ezxmlm.make_tag "Schedule" ([], (String.to_xml f)))])
               @
               [Util.option_map v.schedule_timezone
                  (fun f ->
                     Ezxmlm.make_tag "ScheduleTimezone"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.duration
                 (fun f ->
                    Ezxmlm.make_tag "Duration" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.cutoff
                (fun f -> Ezxmlm.make_tag "Cutoff" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.allow_unassociated_targets
               (fun f ->
                  Ezxmlm.make_tag "AllowUnassociatedTargets"
                    ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.enabled
              (fun f -> Ezxmlm.make_tag "Enabled" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)));
           Util.option_map v.allow_unassociated_targets
             (fun f -> ("allow_unassociated_targets", (Boolean.to_json f)));
           Util.option_map v.cutoff
             (fun f -> ("cutoff", (Integer.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Integer.to_json f)));
           Util.option_map v.schedule_timezone
             (fun f -> ("schedule_timezone", (String.to_json f)));
           Util.option_map v.schedule
             (fun f -> ("schedule", (String.to_json f)));
           Util.option_map v.end_date
             (fun f -> ("end_date", (String.to_json f)));
           Util.option_map v.start_date
             (fun f -> ("start_date", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.window_id
             (fun f -> ("window_id", (String.to_json f)))])
    let of_json j =
      {
        window_id =
          (Util.option_map (Json.lookup j "window_id") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        start_date =
          (Util.option_map (Json.lookup j "start_date") String.of_json);
        end_date =
          (Util.option_map (Json.lookup j "end_date") String.of_json);
        schedule =
          (Util.option_map (Json.lookup j "schedule") String.of_json);
        schedule_timezone =
          (Util.option_map (Json.lookup j "schedule_timezone") String.of_json);
        duration =
          (Util.option_map (Json.lookup j "duration") Integer.of_json);
        cutoff = (Util.option_map (Json.lookup j "cutoff") Integer.of_json);
        allow_unassociated_targets =
          (Util.option_map (Json.lookup j "allow_unassociated_targets")
             Boolean.of_json);
        enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json)
      }
  end
module DescribeInstancePatchStatesRequest =
  struct
    type t =
      {
      instance_ids: InstanceIdList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ~instance_ids  ?next_token  ?max_results  () =
      { instance_ids; next_token; max_results }
    let parse xml =
      Some
        {
          instance_ids =
            (Xml.required "InstanceIds"
               (Util.option_bind (Xml.member "InstanceIds" xml)
                  InstanceIdList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "InstanceIds"
                        ([], (InstanceIdList.to_xml [x])))) v.instance_ids))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("instance_ids", (InstanceIdList.to_json v.instance_ids))])
    let of_json j =
      {
        instance_ids =
          (InstanceIdList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module InvalidDocument =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module InvalidPolicyAttributeException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DeregisterManagedInstanceRequest =
  struct
    type t = {
      instance_id: String.t }
    let make ~instance_id  () = { instance_id }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "InstanceId"
                 ([], (String.to_xml v.instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")))
      }
  end
module TooManyUpdates =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ParameterAlreadyExists =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module UpdateManagedInstanceRoleRequest =
  struct
    type t = {
      instance_id: String.t ;
      iam_role: String.t }
    let make ~instance_id  ~iam_role  () = { instance_id; iam_role }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          iam_role =
            (Xml.required "IamRole"
               (Util.option_bind (Xml.member "IamRole" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "InstanceId"
                  ([], (String.to_xml v.instance_id)))])
           @
           [Some (Ezxmlm.make_tag "IamRole" ([], (String.to_xml v.iam_role)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("iam_role", (String.to_json v.iam_role));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        iam_role =
          (String.of_json (Util.of_option_exn (Json.lookup j "iam_role")))
      }
  end
module DeleteActivationResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module CreateDocumentResult =
  struct
    type t = {
      document_description: DocumentDescription.t option }
    let make ?document_description  () = { document_description }
    let parse xml =
      Some
        {
          document_description =
            (Util.option_bind (Xml.member "DocumentDescription" xml)
               DocumentDescription.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.document_description
              (fun f ->
                 Ezxmlm.make_tag "DocumentDescription"
                   ([], (DocumentDescription.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.document_description
              (fun f ->
                 ("document_description", (DocumentDescription.to_json f)))])
    let of_json j =
      {
        document_description =
          (Util.option_map (Json.lookup j "document_description")
             DocumentDescription.of_json)
      }
  end
module CreateResourceDataSyncRequest =
  struct
    type t =
      {
      sync_name: String.t ;
      s3_destination: ResourceDataSyncS3Destination.t option ;
      sync_type: String.t option ;
      sync_source: ResourceDataSyncSource.t option }
    let make ~sync_name  ?s3_destination  ?sync_type  ?sync_source  () =
      { sync_name; s3_destination; sync_type; sync_source }
    let parse xml =
      Some
        {
          sync_name =
            (Xml.required "SyncName"
               (Util.option_bind (Xml.member "SyncName" xml) String.parse));
          s3_destination =
            (Util.option_bind (Xml.member "S3Destination" xml)
               ResourceDataSyncS3Destination.parse);
          sync_type =
            (Util.option_bind (Xml.member "SyncType" xml) String.parse);
          sync_source =
            (Util.option_bind (Xml.member "SyncSource" xml)
               ResourceDataSyncSource.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "SyncName"
                    ([], (String.to_xml v.sync_name)))])
             @
             [Util.option_map v.s3_destination
                (fun f ->
                   Ezxmlm.make_tag "S3Destination"
                     ([], (ResourceDataSyncS3Destination.to_xml f)))])
            @
            [Util.option_map v.sync_type
               (fun f -> Ezxmlm.make_tag "SyncType" ([], (String.to_xml f)))])
           @
           [Util.option_map v.sync_source
              (fun f ->
                 Ezxmlm.make_tag "SyncSource"
                   ([], (ResourceDataSyncSource.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.sync_source
              (fun f -> ("sync_source", (ResourceDataSyncSource.to_json f)));
           Util.option_map v.sync_type
             (fun f -> ("sync_type", (String.to_json f)));
           Util.option_map v.s3_destination
             (fun f ->
                ("s3_destination", (ResourceDataSyncS3Destination.to_json f)));
           Some ("sync_name", (String.to_json v.sync_name))])
    let of_json j =
      {
        sync_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "sync_name")));
        s3_destination =
          (Util.option_map (Json.lookup j "s3_destination")
             ResourceDataSyncS3Destination.of_json);
        sync_type =
          (Util.option_map (Json.lookup j "sync_type") String.of_json);
        sync_source =
          (Util.option_map (Json.lookup j "sync_source")
             ResourceDataSyncSource.of_json)
      }
  end
module InvalidFilterValue =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module GetServiceSettingRequest =
  struct
    type t = {
      setting_id: String.t }
    let make ~setting_id  () = { setting_id }
    let parse xml =
      Some
        {
          setting_id =
            (Xml.required "SettingId"
               (Util.option_bind (Xml.member "SettingId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "SettingId" ([], (String.to_xml v.setting_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("setting_id", (String.to_json v.setting_id))])
    let of_json j =
      {
        setting_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "setting_id")))
      }
  end
module DeleteDocumentResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module InvalidInstanceInformationFilterValue =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ParameterLimitExceeded =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module CreateAssociationResult =
  struct
    type t = {
      association_description: AssociationDescription.t option }
    let make ?association_description  () = { association_description }
    let parse xml =
      Some
        {
          association_description =
            (Util.option_bind (Xml.member "AssociationDescription" xml)
               AssociationDescription.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.association_description
              (fun f ->
                 Ezxmlm.make_tag "AssociationDescription"
                   ([], (AssociationDescription.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_description
              (fun f ->
                 ("association_description",
                   (AssociationDescription.to_json f)))])
    let of_json j =
      {
        association_description =
          (Util.option_map (Json.lookup j "association_description")
             AssociationDescription.of_json)
      }
  end
module GetInventoryRequest =
  struct
    type t =
      {
      filters: InventoryFilterList.t ;
      aggregators: InventoryAggregatorList.t ;
      result_attributes: ResultAttributeList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?(aggregators= [])  ?(result_attributes= []) 
      ?next_token  ?max_results  () =
      { filters; aggregators; result_attributes; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  InventoryFilterList.parse));
          aggregators =
            (Util.of_option []
               (Util.option_bind (Xml.member "Aggregators" xml)
                  InventoryAggregatorList.parse));
          result_attributes =
            (Util.of_option []
               (Util.option_bind (Xml.member "ResultAttributes" xml)
                  ResultAttributeList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filters"
                          ([], (InventoryFilterList.to_xml [x])))) v.filters))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Aggregators"
                         ([], (InventoryAggregatorList.to_xml [x]))))
                 v.aggregators))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "ResultAttributes"
                        ([], (ResultAttributeList.to_xml [x]))))
                v.result_attributes))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("result_attributes",
               (ResultAttributeList.to_json v.result_attributes));
           Some
             ("aggregators", (InventoryAggregatorList.to_json v.aggregators));
           Some ("filters", (InventoryFilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (InventoryFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        aggregators =
          (InventoryAggregatorList.of_json
             (Util.of_option_exn (Json.lookup j "aggregators")));
        result_attributes =
          (ResultAttributeList.of_json
             (Util.of_option_exn (Json.lookup j "result_attributes")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DeregisterTaskFromMaintenanceWindowResult =
  struct
    type t = {
      window_id: String.t option ;
      window_task_id: String.t option }
    let make ?window_id  ?window_task_id  () = { window_id; window_task_id }
    let parse xml =
      Some
        {
          window_id =
            (Util.option_bind (Xml.member "WindowId" xml) String.parse);
          window_task_id =
            (Util.option_bind (Xml.member "WindowTaskId" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.window_id
               (fun f -> Ezxmlm.make_tag "WindowId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.window_task_id
              (fun f ->
                 Ezxmlm.make_tag "WindowTaskId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.window_task_id
              (fun f -> ("window_task_id", (String.to_json f)));
           Util.option_map v.window_id
             (fun f -> ("window_id", (String.to_json f)))])
    let of_json j =
      {
        window_id =
          (Util.option_map (Json.lookup j "window_id") String.of_json);
        window_task_id =
          (Util.option_map (Json.lookup j "window_task_id") String.of_json)
      }
  end
module GetAutomationExecutionResult =
  struct
    type t = {
      automation_execution: AutomationExecution.t option }
    let make ?automation_execution  () = { automation_execution }
    let parse xml =
      Some
        {
          automation_execution =
            (Util.option_bind (Xml.member "AutomationExecution" xml)
               AutomationExecution.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.automation_execution
              (fun f ->
                 Ezxmlm.make_tag "AutomationExecution"
                   ([], (AutomationExecution.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.automation_execution
              (fun f ->
                 ("automation_execution", (AutomationExecution.to_json f)))])
    let of_json j =
      {
        automation_execution =
          (Util.option_map (Json.lookup j "automation_execution")
             AutomationExecution.of_json)
      }
  end
module UpdateManagedInstanceRoleResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module UpdateDocumentDefaultVersionResult =
  struct
    type t = {
      description: DocumentDefaultVersionDescription.t option }
    let make ?description  () = { description }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml)
               DocumentDefaultVersionDescription.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.description
              (fun f ->
                 Ezxmlm.make_tag "Description"
                   ([], (DocumentDefaultVersionDescription.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f ->
                 ("description",
                   (DocumentDefaultVersionDescription.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description")
             DocumentDefaultVersionDescription.of_json)
      }
  end
module GetCommandInvocationRequest =
  struct
    type t =
      {
      command_id: String.t ;
      instance_id: String.t ;
      plugin_name: String.t option }
    let make ~command_id  ~instance_id  ?plugin_name  () =
      { command_id; instance_id; plugin_name }
    let parse xml =
      Some
        {
          command_id =
            (Xml.required "CommandId"
               (Util.option_bind (Xml.member "CommandId" xml) String.parse));
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          plugin_name =
            (Util.option_bind (Xml.member "PluginName" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "CommandId"
                   ([], (String.to_xml v.command_id)))])
            @
            [Some
               (Ezxmlm.make_tag "InstanceId"
                  ([], (String.to_xml v.instance_id)))])
           @
           [Util.option_map v.plugin_name
              (fun f -> Ezxmlm.make_tag "PluginName" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.plugin_name
              (fun f -> ("plugin_name", (String.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id));
           Some ("command_id", (String.to_json v.command_id))])
    let of_json j =
      {
        command_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "command_id")));
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        plugin_name =
          (Util.option_map (Json.lookup j "plugin_name") String.of_json)
      }
  end
module DescribePatchPropertiesRequest =
  struct
    type t =
      {
      operating_system: OperatingSystem.t ;
      property: PatchProperty.t ;
      patch_set: PatchSet.t option ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ~operating_system  ~property  ?patch_set  ?max_results 
      ?next_token  () =
      { operating_system; property; patch_set; max_results; next_token }
    let parse xml =
      Some
        {
          operating_system =
            (Xml.required "OperatingSystem"
               (Util.option_bind (Xml.member "OperatingSystem" xml)
                  OperatingSystem.parse));
          property =
            (Xml.required "Property"
               (Util.option_bind (Xml.member "Property" xml)
                  PatchProperty.parse));
          patch_set =
            (Util.option_bind (Xml.member "PatchSet" xml) PatchSet.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "OperatingSystem"
                     ([], (OperatingSystem.to_xml v.operating_system)))])
              @
              [Some
                 (Ezxmlm.make_tag "Property"
                    ([], (PatchProperty.to_xml v.property)))])
             @
             [Util.option_map v.patch_set
                (fun f ->
                   Ezxmlm.make_tag "PatchSet" ([], (PatchSet.to_xml f)))])
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.patch_set
             (fun f -> ("patch_set", (PatchSet.to_json f)));
           Some ("property", (PatchProperty.to_json v.property));
           Some
             ("operating_system",
               (OperatingSystem.to_json v.operating_system))])
    let of_json j =
      {
        operating_system =
          (OperatingSystem.of_json
             (Util.of_option_exn (Json.lookup j "operating_system")));
        property =
          (PatchProperty.of_json
             (Util.of_option_exn (Json.lookup j "property")));
        patch_set =
          (Util.option_map (Json.lookup j "patch_set") PatchSet.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ResourceDataSyncNotFoundException =
  struct
    type t =
      {
      sync_name: String.t option ;
      sync_type: String.t option ;
      message: String.t option }
    let make ?sync_name  ?sync_type  ?message  () =
      { sync_name; sync_type; message }
    let parse xml =
      Some
        {
          sync_name =
            (Util.option_bind (Xml.member "SyncName" xml) String.parse);
          sync_type =
            (Util.option_bind (Xml.member "SyncType" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.sync_name
                (fun f -> Ezxmlm.make_tag "SyncName" ([], (String.to_xml f)))])
            @
            [Util.option_map v.sync_type
               (fun f -> Ezxmlm.make_tag "SyncType" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.sync_type
             (fun f -> ("sync_type", (String.to_json f)));
           Util.option_map v.sync_name
             (fun f -> ("sync_name", (String.to_json f)))])
    let of_json j =
      {
        sync_name =
          (Util.option_map (Json.lookup j "sync_name") String.of_json);
        sync_type =
          (Util.option_map (Json.lookup j "sync_type") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module LabelParameterVersionRequest =
  struct
    type t =
      {
      name: String.t ;
      parameter_version: Long.t option ;
      labels: ParameterLabelList.t }
    let make ~name  ?parameter_version  ~labels  () =
      { name; parameter_version; labels }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          parameter_version =
            (Util.option_bind (Xml.member "ParameterVersion" xml) Long.parse);
          labels =
            (Xml.required "Labels"
               (Util.option_bind (Xml.member "Labels" xml)
                  ParameterLabelList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
            @
            [Util.option_map v.parameter_version
               (fun f ->
                  Ezxmlm.make_tag "ParameterVersion" ([], (Long.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Labels"
                      ([], (ParameterLabelList.to_xml [x])))) v.labels))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("labels", (ParameterLabelList.to_json v.labels));
           Util.option_map v.parameter_version
             (fun f -> ("parameter_version", (Long.to_json f)));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        parameter_version =
          (Util.option_map (Json.lookup j "parameter_version") Long.of_json);
        labels =
          (ParameterLabelList.of_json
             (Util.of_option_exn (Json.lookup j "labels")))
      }
  end
module DescribeAssociationExecutionsRequest =
  struct
    type t =
      {
      association_id: String.t ;
      filters: AssociationExecutionFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ~association_id  ?(filters= [])  ?max_results  ?next_token  () =
      { association_id; filters; max_results; next_token }
    let parse xml =
      Some
        {
          association_id =
            (Xml.required "AssociationId"
               (Util.option_bind (Xml.member "AssociationId" xml)
                  String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  AssociationExecutionFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "AssociationId"
                    ([], (String.to_xml v.association_id)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (AssociationExecutionFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("filters", (AssociationExecutionFilterList.to_json v.filters));
           Some ("association_id", (String.to_json v.association_id))])
    let of_json j =
      {
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")));
        filters =
          (AssociationExecutionFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ResumeSessionResponse =
  struct
    type t =
      {
      session_id: String.t option ;
      token_value: String.t option ;
      stream_url: String.t option }
    let make ?session_id  ?token_value  ?stream_url  () =
      { session_id; token_value; stream_url }
    let parse xml =
      Some
        {
          session_id =
            (Util.option_bind (Xml.member "SessionId" xml) String.parse);
          token_value =
            (Util.option_bind (Xml.member "TokenValue" xml) String.parse);
          stream_url =
            (Util.option_bind (Xml.member "StreamUrl" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.session_id
                (fun f -> Ezxmlm.make_tag "SessionId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.token_value
               (fun f -> Ezxmlm.make_tag "TokenValue" ([], (String.to_xml f)))])
           @
           [Util.option_map v.stream_url
              (fun f -> Ezxmlm.make_tag "StreamUrl" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.stream_url
              (fun f -> ("stream_url", (String.to_json f)));
           Util.option_map v.token_value
             (fun f -> ("token_value", (String.to_json f)));
           Util.option_map v.session_id
             (fun f -> ("session_id", (String.to_json f)))])
    let of_json j =
      {
        session_id =
          (Util.option_map (Json.lookup j "session_id") String.of_json);
        token_value =
          (Util.option_map (Json.lookup j "token_value") String.of_json);
        stream_url =
          (Util.option_map (Json.lookup j "stream_url") String.of_json)
      }
  end
module DeletePatchBaselineRequest =
  struct
    type t = {
      baseline_id: String.t }
    let make ~baseline_id  () = { baseline_id }
    let parse xml =
      Some
        {
          baseline_id =
            (Xml.required "BaselineId"
               (Util.option_bind (Xml.member "BaselineId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "BaselineId"
                 ([], (String.to_xml v.baseline_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("baseline_id", (String.to_json v.baseline_id))])
    let of_json j =
      {
        baseline_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "baseline_id")))
      }
  end
module RemoveTagsFromResourceRequest =
  struct
    type t =
      {
      resource_type: ResourceTypeForTagging.t ;
      resource_id: String.t ;
      tag_keys: KeyList.t }
    let make ~resource_type  ~resource_id  ~tag_keys  () =
      { resource_type; resource_id; tag_keys }
    let parse xml =
      Some
        {
          resource_type =
            (Xml.required "ResourceType"
               (Util.option_bind (Xml.member "ResourceType" xml)
                  ResourceTypeForTagging.parse));
          resource_id =
            (Xml.required "ResourceId"
               (Util.option_bind (Xml.member "ResourceId" xml) String.parse));
          tag_keys =
            (Xml.required "TagKeys"
               (Util.option_bind (Xml.member "TagKeys" xml) KeyList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "ResourceType"
                   ([], (ResourceTypeForTagging.to_xml v.resource_type)))])
            @
            [Some
               (Ezxmlm.make_tag "ResourceId"
                  ([], (String.to_xml v.resource_id)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "TagKeys" ([], (KeyList.to_xml [x]))))
              v.tag_keys))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tag_keys", (KeyList.to_json v.tag_keys));
           Some ("resource_id", (String.to_json v.resource_id));
           Some
             ("resource_type",
               (ResourceTypeForTagging.to_json v.resource_type))])
    let of_json j =
      {
        resource_type =
          (ResourceTypeForTagging.of_json
             (Util.of_option_exn (Json.lookup j "resource_type")));
        resource_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "resource_id")));
        tag_keys =
          (KeyList.of_json (Util.of_option_exn (Json.lookup j "tag_keys")))
      }
  end
module InvalidKeyId =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module GetMaintenanceWindowExecutionTaskRequest =
  struct
    type t = {
      window_execution_id: String.t ;
      task_id: String.t }
    let make ~window_execution_id  ~task_id  () =
      { window_execution_id; task_id }
    let parse xml =
      Some
        {
          window_execution_id =
            (Xml.required "WindowExecutionId"
               (Util.option_bind (Xml.member "WindowExecutionId" xml)
                  String.parse));
          task_id =
            (Xml.required "TaskId"
               (Util.option_bind (Xml.member "TaskId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "WindowExecutionId"
                  ([], (String.to_xml v.window_execution_id)))])
           @
           [Some (Ezxmlm.make_tag "TaskId" ([], (String.to_xml v.task_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("task_id", (String.to_json v.task_id));
           Some
             ("window_execution_id", (String.to_json v.window_execution_id))])
    let of_json j =
      {
        window_execution_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "window_execution_id")));
        task_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "task_id")))
      }
  end
module GetOpsSummaryResult =
  struct
    type t = {
      entities: OpsEntityList.t ;
      next_token: String.t option }
    let make ?(entities= [])  ?next_token  () = { entities; next_token }
    let parse xml =
      Some
        {
          entities =
            (Util.of_option []
               (Util.option_bind (Xml.member "Entities" xml)
                  OpsEntityList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Entities"
                       ([], (OpsEntityList.to_xml [x])))) v.entities))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("entities", (OpsEntityList.to_json v.entities))])
    let of_json j =
      {
        entities =
          (OpsEntityList.of_json
             (Util.of_option_exn (Json.lookup j "entities")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module HierarchyLevelLimitExceededException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ListResourceDataSyncRequest =
  struct
    type t =
      {
      sync_type: String.t option ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?sync_type  ?next_token  ?max_results  () =
      { sync_type; next_token; max_results }
    let parse xml =
      Some
        {
          sync_type =
            (Util.option_bind (Xml.member "SyncType" xml) String.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.sync_type
                (fun f -> Ezxmlm.make_tag "SyncType" ([], (String.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.sync_type
             (fun f -> ("sync_type", (String.to_json f)))])
    let of_json j =
      {
        sync_type =
          (Util.option_map (Json.lookup j "sync_type") String.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module CreateActivationResult =
  struct
    type t =
      {
      activation_id: String.t option ;
      activation_code: String.t option }
    let make ?activation_id  ?activation_code  () =
      { activation_id; activation_code }
    let parse xml =
      Some
        {
          activation_id =
            (Util.option_bind (Xml.member "ActivationId" xml) String.parse);
          activation_code =
            (Util.option_bind (Xml.member "ActivationCode" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.activation_id
               (fun f ->
                  Ezxmlm.make_tag "ActivationId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.activation_code
              (fun f ->
                 Ezxmlm.make_tag "ActivationCode" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.activation_code
              (fun f -> ("activation_code", (String.to_json f)));
           Util.option_map v.activation_id
             (fun f -> ("activation_id", (String.to_json f)))])
    let of_json j =
      {
        activation_id =
          (Util.option_map (Json.lookup j "activation_id") String.of_json);
        activation_code =
          (Util.option_map (Json.lookup j "activation_code") String.of_json)
      }
  end
module RegisterTaskWithMaintenanceWindowResult =
  struct
    type t = {
      window_task_id: String.t option }
    let make ?window_task_id  () = { window_task_id }
    let parse xml =
      Some
        {
          window_task_id =
            (Util.option_bind (Xml.member "WindowTaskId" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.window_task_id
              (fun f ->
                 Ezxmlm.make_tag "WindowTaskId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.window_task_id
              (fun f -> ("window_task_id", (String.to_json f)))])
    let of_json j =
      {
        window_task_id =
          (Util.option_map (Json.lookup j "window_task_id") String.of_json)
      }
  end
module UpdateOpsItemRequest =
  struct
    type t =
      {
      description: String.t option ;
      operational_data: OpsItemOperationalData.t option ;
      operational_data_to_delete: OpsItemOpsDataKeysList.t ;
      notifications: OpsItemNotifications.t ;
      priority: Integer.t option ;
      related_ops_items: RelatedOpsItems.t ;
      status: OpsItemStatus.t option ;
      ops_item_id: String.t ;
      title: String.t option ;
      category: String.t option ;
      severity: String.t option }
    let make ?description  ?operational_data  ?(operational_data_to_delete=
      [])  ?(notifications= [])  ?priority  ?(related_ops_items= [])  ?status
       ~ops_item_id  ?title  ?category  ?severity  () =
      {
        description;
        operational_data;
        operational_data_to_delete;
        notifications;
        priority;
        related_ops_items;
        status;
        ops_item_id;
        title;
        category;
        severity
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          operational_data =
            (Util.option_bind (Xml.member "OperationalData" xml)
               OpsItemOperationalData.parse);
          operational_data_to_delete =
            (Util.of_option []
               (Util.option_bind (Xml.member "OperationalDataToDelete" xml)
                  OpsItemOpsDataKeysList.parse));
          notifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "Notifications" xml)
                  OpsItemNotifications.parse));
          priority =
            (Util.option_bind (Xml.member "Priority" xml) Integer.parse);
          related_ops_items =
            (Util.of_option []
               (Util.option_bind (Xml.member "RelatedOpsItems" xml)
                  RelatedOpsItems.parse));
          status =
            (Util.option_bind (Xml.member "Status" xml) OpsItemStatus.parse);
          ops_item_id =
            (Xml.required "OpsItemId"
               (Util.option_bind (Xml.member "OpsItemId" xml) String.parse));
          title = (Util.option_bind (Xml.member "Title" xml) String.parse);
          category =
            (Util.option_bind (Xml.member "Category" xml) String.parse);
          severity =
            (Util.option_bind (Xml.member "Severity" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Util.option_map v.description
                        (fun f ->
                           Ezxmlm.make_tag "Description"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.operational_data
                       (fun f ->
                          Ezxmlm.make_tag "OperationalData"
                            ([], (OpsItemOperationalData.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "OperationalDataToDelete"
                              ([], (OpsItemOpsDataKeysList.to_xml [x]))))
                      v.operational_data_to_delete))
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "Notifications"
                             ([], (OpsItemNotifications.to_xml [x]))))
                     v.notifications))
                 @
                 [Util.option_map v.priority
                    (fun f ->
                       Ezxmlm.make_tag "Priority" ([], (Integer.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "RelatedOpsItems"
                           ([], (RelatedOpsItems.to_xml [x]))))
                   v.related_ops_items))
               @
               [Util.option_map v.status
                  (fun f ->
                     Ezxmlm.make_tag "Status" ([], (OpsItemStatus.to_xml f)))])
              @
              [Some
                 (Ezxmlm.make_tag "OpsItemId"
                    ([], (String.to_xml v.ops_item_id)))])
             @
             [Util.option_map v.title
                (fun f -> Ezxmlm.make_tag "Title" ([], (String.to_xml f)))])
            @
            [Util.option_map v.category
               (fun f -> Ezxmlm.make_tag "Category" ([], (String.to_xml f)))])
           @
           [Util.option_map v.severity
              (fun f -> Ezxmlm.make_tag "Severity" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.severity
              (fun f -> ("severity", (String.to_json f)));
           Util.option_map v.category
             (fun f -> ("category", (String.to_json f)));
           Util.option_map v.title (fun f -> ("title", (String.to_json f)));
           Some ("ops_item_id", (String.to_json v.ops_item_id));
           Util.option_map v.status
             (fun f -> ("status", (OpsItemStatus.to_json f)));
           Some
             ("related_ops_items",
               (RelatedOpsItems.to_json v.related_ops_items));
           Util.option_map v.priority
             (fun f -> ("priority", (Integer.to_json f)));
           Some
             ("notifications",
               (OpsItemNotifications.to_json v.notifications));
           Some
             ("operational_data_to_delete",
               (OpsItemOpsDataKeysList.to_json v.operational_data_to_delete));
           Util.option_map v.operational_data
             (fun f ->
                ("operational_data", (OpsItemOperationalData.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        operational_data =
          (Util.option_map (Json.lookup j "operational_data")
             OpsItemOperationalData.of_json);
        operational_data_to_delete =
          (OpsItemOpsDataKeysList.of_json
             (Util.of_option_exn (Json.lookup j "operational_data_to_delete")));
        notifications =
          (OpsItemNotifications.of_json
             (Util.of_option_exn (Json.lookup j "notifications")));
        priority =
          (Util.option_map (Json.lookup j "priority") Integer.of_json);
        related_ops_items =
          (RelatedOpsItems.of_json
             (Util.of_option_exn (Json.lookup j "related_ops_items")));
        status =
          (Util.option_map (Json.lookup j "status") OpsItemStatus.of_json);
        ops_item_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "ops_item_id")));
        title = (Util.option_map (Json.lookup j "title") String.of_json);
        category =
          (Util.option_map (Json.lookup j "category") String.of_json);
        severity =
          (Util.option_map (Json.lookup j "severity") String.of_json)
      }
  end
module DescribeEffectiveInstanceAssociationsRequest =
  struct
    type t =
      {
      instance_id: String.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ~instance_id  ?max_results  ?next_token  () =
      { instance_id; max_results; next_token }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "InstanceId"
                   ([], (String.to_xml v.instance_id)))])
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module RegisterPatchBaselineForPatchGroupRequest =
  struct
    type t = {
      baseline_id: String.t ;
      patch_group: String.t }
    let make ~baseline_id  ~patch_group  () = { baseline_id; patch_group }
    let parse xml =
      Some
        {
          baseline_id =
            (Xml.required "BaselineId"
               (Util.option_bind (Xml.member "BaselineId" xml) String.parse));
          patch_group =
            (Xml.required "PatchGroup"
               (Util.option_bind (Xml.member "PatchGroup" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "BaselineId"
                  ([], (String.to_xml v.baseline_id)))])
           @
           [Some
              (Ezxmlm.make_tag "PatchGroup"
                 ([], (String.to_xml v.patch_group)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("patch_group", (String.to_json v.patch_group));
           Some ("baseline_id", (String.to_json v.baseline_id))])
    let of_json j =
      {
        baseline_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "baseline_id")));
        patch_group =
          (String.of_json (Util.of_option_exn (Json.lookup j "patch_group")))
      }
  end
module TerminateSessionResponse =
  struct
    type t = {
      session_id: String.t option }
    let make ?session_id  () = { session_id }
    let parse xml =
      Some
        {
          session_id =
            (Util.option_bind (Xml.member "SessionId" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.session_id
              (fun f -> Ezxmlm.make_tag "SessionId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.session_id
              (fun f -> ("session_id", (String.to_json f)))])
    let of_json j =
      {
        session_id =
          (Util.option_map (Json.lookup j "session_id") String.of_json)
      }
  end
module CancelMaintenanceWindowExecutionResult =
  struct
    type t = {
      window_execution_id: String.t option }
    let make ?window_execution_id  () = { window_execution_id }
    let parse xml =
      Some
        {
          window_execution_id =
            (Util.option_bind (Xml.member "WindowExecutionId" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.window_execution_id
              (fun f ->
                 Ezxmlm.make_tag "WindowExecutionId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.window_execution_id
              (fun f -> ("window_execution_id", (String.to_json f)))])
    let of_json j =
      {
        window_execution_id =
          (Util.option_map (Json.lookup j "window_execution_id")
             String.of_json)
      }
  end
module DescribePatchBaselinesRequest =
  struct
    type t =
      {
      filters: PatchOrchestratorFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(filters= [])  ?max_results  ?next_token  () =
      { filters; max_results; next_token }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  PatchOrchestratorFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (PatchOrchestratorFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (PatchOrchestratorFilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (PatchOrchestratorFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module InvalidTarget =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module UpdatePatchBaselineRequest =
  struct
    type t =
      {
      baseline_id: String.t ;
      name: String.t option ;
      global_filters: PatchFilterGroup.t option ;
      approval_rules: PatchRuleGroup.t option ;
      approved_patches: PatchIdList.t ;
      approved_patches_compliance_level: PatchComplianceLevel.t option ;
      approved_patches_enable_non_security: Boolean.t option ;
      rejected_patches: PatchIdList.t ;
      rejected_patches_action: PatchAction.t option ;
      description: String.t option ;
      sources: PatchSourceList.t ;
      replace: Boolean.t option }
    let make ~baseline_id  ?name  ?global_filters  ?approval_rules 
      ?(approved_patches= [])  ?approved_patches_compliance_level 
      ?approved_patches_enable_non_security  ?(rejected_patches= []) 
      ?rejected_patches_action  ?description  ?(sources= [])  ?replace  () =
      {
        baseline_id;
        name;
        global_filters;
        approval_rules;
        approved_patches;
        approved_patches_compliance_level;
        approved_patches_enable_non_security;
        rejected_patches;
        rejected_patches_action;
        description;
        sources;
        replace
      }
    let parse xml =
      Some
        {
          baseline_id =
            (Xml.required "BaselineId"
               (Util.option_bind (Xml.member "BaselineId" xml) String.parse));
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          global_filters =
            (Util.option_bind (Xml.member "GlobalFilters" xml)
               PatchFilterGroup.parse);
          approval_rules =
            (Util.option_bind (Xml.member "ApprovalRules" xml)
               PatchRuleGroup.parse);
          approved_patches =
            (Util.of_option []
               (Util.option_bind (Xml.member "ApprovedPatches" xml)
                  PatchIdList.parse));
          approved_patches_compliance_level =
            (Util.option_bind
               (Xml.member "ApprovedPatchesComplianceLevel" xml)
               PatchComplianceLevel.parse);
          approved_patches_enable_non_security =
            (Util.option_bind
               (Xml.member "ApprovedPatchesEnableNonSecurity" xml)
               Boolean.parse);
          rejected_patches =
            (Util.of_option []
               (Util.option_bind (Xml.member "RejectedPatches" xml)
                  PatchIdList.parse));
          rejected_patches_action =
            (Util.option_bind (Xml.member "RejectedPatchesAction" xml)
               PatchAction.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          sources =
            (Util.of_option []
               (Util.option_bind (Xml.member "Sources" xml)
                  PatchSourceList.parse));
          replace =
            (Util.option_bind (Xml.member "Replace" xml) Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Some
                         (Ezxmlm.make_tag "BaselineId"
                            ([], (String.to_xml v.baseline_id)))])
                     @
                     [Util.option_map v.name
                        (fun f ->
                           Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.global_filters
                       (fun f ->
                          Ezxmlm.make_tag "GlobalFilters"
                            ([], (PatchFilterGroup.to_xml f)))])
                   @
                   [Util.option_map v.approval_rules
                      (fun f ->
                         Ezxmlm.make_tag "ApprovalRules"
                           ([], (PatchRuleGroup.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "ApprovedPatches"
                             ([], (PatchIdList.to_xml [x]))))
                     v.approved_patches))
                 @
                 [Util.option_map v.approved_patches_compliance_level
                    (fun f ->
                       Ezxmlm.make_tag "ApprovedPatchesComplianceLevel"
                         ([], (PatchComplianceLevel.to_xml f)))])
                @
                [Util.option_map v.approved_patches_enable_non_security
                   (fun f ->
                      Ezxmlm.make_tag "ApprovedPatchesEnableNonSecurity"
                        ([], (Boolean.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "RejectedPatches"
                          ([], (PatchIdList.to_xml [x])))) v.rejected_patches))
              @
              [Util.option_map v.rejected_patches_action
                 (fun f ->
                    Ezxmlm.make_tag "RejectedPatchesAction"
                      ([], (PatchAction.to_xml f)))])
             @
             [Util.option_map v.description
                (fun f ->
                   Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Sources"
                       ([], (PatchSourceList.to_xml [x])))) v.sources))
           @
           [Util.option_map v.replace
              (fun f -> Ezxmlm.make_tag "Replace" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.replace
              (fun f -> ("replace", (Boolean.to_json f)));
           Some ("sources", (PatchSourceList.to_json v.sources));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.rejected_patches_action
             (fun f -> ("rejected_patches_action", (PatchAction.to_json f)));
           Some
             ("rejected_patches", (PatchIdList.to_json v.rejected_patches));
           Util.option_map v.approved_patches_enable_non_security
             (fun f ->
                ("approved_patches_enable_non_security", (Boolean.to_json f)));
           Util.option_map v.approved_patches_compliance_level
             (fun f ->
                ("approved_patches_compliance_level",
                  (PatchComplianceLevel.to_json f)));
           Some
             ("approved_patches", (PatchIdList.to_json v.approved_patches));
           Util.option_map v.approval_rules
             (fun f -> ("approval_rules", (PatchRuleGroup.to_json f)));
           Util.option_map v.global_filters
             (fun f -> ("global_filters", (PatchFilterGroup.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Some ("baseline_id", (String.to_json v.baseline_id))])
    let of_json j =
      {
        baseline_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "baseline_id")));
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        global_filters =
          (Util.option_map (Json.lookup j "global_filters")
             PatchFilterGroup.of_json);
        approval_rules =
          (Util.option_map (Json.lookup j "approval_rules")
             PatchRuleGroup.of_json);
        approved_patches =
          (PatchIdList.of_json
             (Util.of_option_exn (Json.lookup j "approved_patches")));
        approved_patches_compliance_level =
          (Util.option_map
             (Json.lookup j "approved_patches_compliance_level")
             PatchComplianceLevel.of_json);
        approved_patches_enable_non_security =
          (Util.option_map
             (Json.lookup j "approved_patches_enable_non_security")
             Boolean.of_json);
        rejected_patches =
          (PatchIdList.of_json
             (Util.of_option_exn (Json.lookup j "rejected_patches")));
        rejected_patches_action =
          (Util.option_map (Json.lookup j "rejected_patches_action")
             PatchAction.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        sources =
          (PatchSourceList.of_json
             (Util.of_option_exn (Json.lookup j "sources")));
        replace = (Util.option_map (Json.lookup j "replace") Boolean.of_json)
      }
  end
module OpsItemAlreadyExistsException =
  struct
    type t = {
      message: String.t option ;
      ops_item_id: String.t option }
    let make ?message  ?ops_item_id  () = { message; ops_item_id }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse);
          ops_item_id =
            (Util.option_bind (Xml.member "OpsItemId" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.message
               (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
           @
           [Util.option_map v.ops_item_id
              (fun f -> Ezxmlm.make_tag "OpsItemId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ops_item_id
              (fun f -> ("ops_item_id", (String.to_json f)));
           Util.option_map v.message
             (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      {
        message = (Util.option_map (Json.lookup j "message") String.of_json);
        ops_item_id =
          (Util.option_map (Json.lookup j "ops_item_id") String.of_json)
      }
  end
module InvalidResourceId =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module UpdateAssociationResult =
  struct
    type t = {
      association_description: AssociationDescription.t option }
    let make ?association_description  () = { association_description }
    let parse xml =
      Some
        {
          association_description =
            (Util.option_bind (Xml.member "AssociationDescription" xml)
               AssociationDescription.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.association_description
              (fun f ->
                 Ezxmlm.make_tag "AssociationDescription"
                   ([], (AssociationDescription.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_description
              (fun f ->
                 ("association_description",
                   (AssociationDescription.to_json f)))])
    let of_json j =
      {
        association_description =
          (Util.option_map (Json.lookup j "association_description")
             AssociationDescription.of_json)
      }
  end
module ItemSizeLimitExceededException =
  struct
    type t = {
      type_name: String.t option ;
      message: String.t option }
    let make ?type_name  ?message  () = { type_name; message }
    let parse xml =
      Some
        {
          type_name =
            (Util.option_bind (Xml.member "TypeName" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.type_name
               (fun f -> Ezxmlm.make_tag "TypeName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.type_name
             (fun f -> ("type_name", (String.to_json f)))])
    let of_json j =
      {
        type_name =
          (Util.option_map (Json.lookup j "type_name") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module RegisterPatchBaselineForPatchGroupResult =
  struct
    type t = {
      baseline_id: String.t option ;
      patch_group: String.t option }
    let make ?baseline_id  ?patch_group  () = { baseline_id; patch_group }
    let parse xml =
      Some
        {
          baseline_id =
            (Util.option_bind (Xml.member "BaselineId" xml) String.parse);
          patch_group =
            (Util.option_bind (Xml.member "PatchGroup" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.baseline_id
               (fun f -> Ezxmlm.make_tag "BaselineId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.patch_group
              (fun f -> Ezxmlm.make_tag "PatchGroup" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.patch_group
              (fun f -> ("patch_group", (String.to_json f)));
           Util.option_map v.baseline_id
             (fun f -> ("baseline_id", (String.to_json f)))])
    let of_json j =
      {
        baseline_id =
          (Util.option_map (Json.lookup j "baseline_id") String.of_json);
        patch_group =
          (Util.option_map (Json.lookup j "patch_group") String.of_json)
      }
  end
module ListAssociationsResult =
  struct
    type t = {
      associations: AssociationList.t ;
      next_token: String.t option }
    let make ?(associations= [])  ?next_token  () =
      { associations; next_token }
    let parse xml =
      Some
        {
          associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "Associations" xml)
                  AssociationList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Associations"
                       ([], (AssociationList.to_xml [x])))) v.associations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("associations", (AssociationList.to_json v.associations))])
    let of_json j =
      {
        associations =
          (AssociationList.of_json
             (Util.of_option_exn (Json.lookup j "associations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module PutInventoryResult =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module AssociatedInstances =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module DescribeInstanceAssociationsStatusRequest =
  struct
    type t =
      {
      instance_id: String.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ~instance_id  ?max_results  ?next_token  () =
      { instance_id; max_results; next_token }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "InstanceId"
                   ([], (String.to_xml v.instance_id)))])
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeInstancePatchesRequest =
  struct
    type t =
      {
      instance_id: String.t ;
      filters: PatchOrchestratorFilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ~instance_id  ?(filters= [])  ?next_token  ?max_results  () =
      { instance_id; filters; next_token; max_results }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  PatchOrchestratorFilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "InstanceId"
                    ([], (String.to_xml v.instance_id)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (PatchOrchestratorFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (PatchOrchestratorFilterList.to_json v.filters));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        filters =
          (PatchOrchestratorFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DocumentVersionLimitExceeded =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module InvalidTypeNameException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module PoliciesLimitExceededException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module UpdateResourceDataSyncRequest =
  struct
    type t =
      {
      sync_name: String.t ;
      sync_type: String.t ;
      sync_source: ResourceDataSyncSource.t }
    let make ~sync_name  ~sync_type  ~sync_source  () =
      { sync_name; sync_type; sync_source }
    let parse xml =
      Some
        {
          sync_name =
            (Xml.required "SyncName"
               (Util.option_bind (Xml.member "SyncName" xml) String.parse));
          sync_type =
            (Xml.required "SyncType"
               (Util.option_bind (Xml.member "SyncType" xml) String.parse));
          sync_source =
            (Xml.required "SyncSource"
               (Util.option_bind (Xml.member "SyncSource" xml)
                  ResourceDataSyncSource.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "SyncName" ([], (String.to_xml v.sync_name)))])
            @
            [Some
               (Ezxmlm.make_tag "SyncType" ([], (String.to_xml v.sync_type)))])
           @
           [Some
              (Ezxmlm.make_tag "SyncSource"
                 ([], (ResourceDataSyncSource.to_xml v.sync_source)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("sync_source", (ResourceDataSyncSource.to_json v.sync_source));
           Some ("sync_type", (String.to_json v.sync_type));
           Some ("sync_name", (String.to_json v.sync_name))])
    let of_json j =
      {
        sync_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "sync_name")));
        sync_type =
          (String.of_json (Util.of_option_exn (Json.lookup j "sync_type")));
        sync_source =
          (ResourceDataSyncSource.of_json
             (Util.of_option_exn (Json.lookup j "sync_source")))
      }
  end
module CancelCommandResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module DeleteDocumentRequest =
  struct
    type t =
      {
      name: String.t ;
      document_version: String.t option ;
      version_name: String.t option ;
      force: Boolean.t option }
    let make ~name  ?document_version  ?version_name  ?force  () =
      { name; document_version; version_name; force }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          version_name =
            (Util.option_bind (Xml.member "VersionName" xml) String.parse);
          force = (Util.option_bind (Xml.member "Force" xml) Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
             @
             [Util.option_map v.document_version
                (fun f ->
                   Ezxmlm.make_tag "DocumentVersion" ([], (String.to_xml f)))])
            @
            [Util.option_map v.version_name
               (fun f ->
                  Ezxmlm.make_tag "VersionName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.force
              (fun f -> Ezxmlm.make_tag "Force" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.force (fun f -> ("force", (Boolean.to_json f)));
           Util.option_map v.version_name
             (fun f -> ("version_name", (String.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        version_name =
          (Util.option_map (Json.lookup j "version_name") String.of_json);
        force = (Util.option_map (Json.lookup j "force") Boolean.of_json)
      }
  end
module DescribeSessionsResponse =
  struct
    type t = {
      sessions: SessionList.t ;
      next_token: String.t option }
    let make ?(sessions= [])  ?next_token  () = { sessions; next_token }
    let parse xml =
      Some
        {
          sessions =
            (Util.of_option []
               (Util.option_bind (Xml.member "Sessions" xml)
                  SessionList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Sessions"
                       ([], (SessionList.to_xml [x])))) v.sessions))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("sessions", (SessionList.to_json v.sessions))])
    let of_json j =
      {
        sessions =
          (SessionList.of_json
             (Util.of_option_exn (Json.lookup j "sessions")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ResourceDataSyncInvalidConfigurationException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module UpdateDocumentResult =
  struct
    type t = {
      document_description: DocumentDescription.t option }
    let make ?document_description  () = { document_description }
    let parse xml =
      Some
        {
          document_description =
            (Util.option_bind (Xml.member "DocumentDescription" xml)
               DocumentDescription.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.document_description
              (fun f ->
                 Ezxmlm.make_tag "DocumentDescription"
                   ([], (DocumentDescription.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.document_description
              (fun f ->
                 ("document_description", (DocumentDescription.to_json f)))])
    let of_json j =
      {
        document_description =
          (Util.option_map (Json.lookup j "document_description")
             DocumentDescription.of_json)
      }
  end
module OpsItemLimitExceededException =
  struct
    type t =
      {
      resource_types: OpsItemParameterNamesList.t ;
      limit: Integer.t option ;
      limit_type: String.t option ;
      message: String.t option }
    let make ?(resource_types= [])  ?limit  ?limit_type  ?message  () =
      { resource_types; limit; limit_type; message }
    let parse xml =
      Some
        {
          resource_types =
            (Util.of_option []
               (Util.option_bind (Xml.member "ResourceTypes" xml)
                  OpsItemParameterNamesList.parse));
          limit = (Util.option_bind (Xml.member "Limit" xml) Integer.parse);
          limit_type =
            (Util.option_bind (Xml.member "LimitType" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "ResourceTypes"
                         ([], (OpsItemParameterNamesList.to_xml [x]))))
                 v.resource_types))
             @
             [Util.option_map v.limit
                (fun f -> Ezxmlm.make_tag "Limit" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.limit_type
               (fun f -> Ezxmlm.make_tag "LimitType" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.limit_type
             (fun f -> ("limit_type", (String.to_json f)));
           Util.option_map v.limit (fun f -> ("limit", (Integer.to_json f)));
           Some
             ("resource_types",
               (OpsItemParameterNamesList.to_json v.resource_types))])
    let of_json j =
      {
        resource_types =
          (OpsItemParameterNamesList.of_json
             (Util.of_option_exn (Json.lookup j "resource_types")));
        limit = (Util.option_map (Json.lookup j "limit") Integer.of_json);
        limit_type =
          (Util.option_map (Json.lookup j "limit_type") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeActivationsResult =
  struct
    type t =
      {
      activation_list: ActivationList.t ;
      next_token: String.t option }
    let make ?(activation_list= [])  ?next_token  () =
      { activation_list; next_token }
    let parse xml =
      Some
        {
          activation_list =
            (Util.of_option []
               (Util.option_bind (Xml.member "ActivationList" xml)
                  ActivationList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ActivationList"
                       ([], (ActivationList.to_xml [x])))) v.activation_list))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("activation_list", (ActivationList.to_json v.activation_list))])
    let of_json j =
      {
        activation_list =
          (ActivationList.of_json
             (Util.of_option_exn (Json.lookup j "activation_list")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeMaintenanceWindowScheduleRequest =
  struct
    type t =
      {
      window_id: String.t option ;
      targets: Targets.t ;
      resource_type: MaintenanceWindowResourceType.t option ;
      filters: PatchOrchestratorFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?window_id  ?(targets= [])  ?resource_type  ?(filters= []) 
      ?max_results  ?next_token  () =
      { window_id; targets; resource_type; filters; max_results; next_token }
    let parse xml =
      Some
        {
          window_id =
            (Util.option_bind (Xml.member "WindowId" xml) String.parse);
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          resource_type =
            (Util.option_bind (Xml.member "ResourceType" xml)
               MaintenanceWindowResourceType.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  PatchOrchestratorFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.window_id
                   (fun f ->
                      Ezxmlm.make_tag "WindowId" ([], (String.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Targets" ([], (Targets.to_xml [x]))))
                  v.targets))
              @
              [Util.option_map v.resource_type
                 (fun f ->
                    Ezxmlm.make_tag "ResourceType"
                      ([], (MaintenanceWindowResourceType.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (PatchOrchestratorFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (PatchOrchestratorFilterList.to_json v.filters));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type", (MaintenanceWindowResourceType.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Util.option_map v.window_id
             (fun f -> ("window_id", (String.to_json f)))])
    let of_json j =
      {
        window_id =
          (Util.option_map (Json.lookup j "window_id") String.of_json);
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             MaintenanceWindowResourceType.of_json);
        filters =
          (PatchOrchestratorFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ListComplianceItemsResult =
  struct
    type t =
      {
      compliance_items: ComplianceItemList.t ;
      next_token: String.t option }
    let make ?(compliance_items= [])  ?next_token  () =
      { compliance_items; next_token }
    let parse xml =
      Some
        {
          compliance_items =
            (Util.of_option []
               (Util.option_bind (Xml.member "ComplianceItems" xml)
                  ComplianceItemList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ComplianceItems"
                       ([], (ComplianceItemList.to_xml [x]))))
               v.compliance_items))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("compliance_items",
               (ComplianceItemList.to_json v.compliance_items))])
    let of_json j =
      {
        compliance_items =
          (ComplianceItemList.of_json
             (Util.of_option_exn (Json.lookup j "compliance_items")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeregisterPatchBaselineForPatchGroupRequest =
  struct
    type t = {
      baseline_id: String.t ;
      patch_group: String.t }
    let make ~baseline_id  ~patch_group  () = { baseline_id; patch_group }
    let parse xml =
      Some
        {
          baseline_id =
            (Xml.required "BaselineId"
               (Util.option_bind (Xml.member "BaselineId" xml) String.parse));
          patch_group =
            (Xml.required "PatchGroup"
               (Util.option_bind (Xml.member "PatchGroup" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "BaselineId"
                  ([], (String.to_xml v.baseline_id)))])
           @
           [Some
              (Ezxmlm.make_tag "PatchGroup"
                 ([], (String.to_xml v.patch_group)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("patch_group", (String.to_json v.patch_group));
           Some ("baseline_id", (String.to_json v.baseline_id))])
    let of_json j =
      {
        baseline_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "baseline_id")));
        patch_group =
          (String.of_json (Util.of_option_exn (Json.lookup j "patch_group")))
      }
  end
module DescribeMaintenanceWindowTasksResult =
  struct
    type t =
      {
      tasks: MaintenanceWindowTaskList.t ;
      next_token: String.t option }
    let make ?(tasks= [])  ?next_token  () = { tasks; next_token }
    let parse xml =
      Some
        {
          tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tasks" xml)
                  MaintenanceWindowTaskList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Tasks"
                       ([], (MaintenanceWindowTaskList.to_xml [x])))) v.tasks))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("tasks", (MaintenanceWindowTaskList.to_json v.tasks))])
    let of_json j =
      {
        tasks =
          (MaintenanceWindowTaskList.of_json
             (Util.of_option_exn (Json.lookup j "tasks")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module InvalidAggregatorException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module TerminateSessionRequest =
  struct
    type t = {
      session_id: String.t }
    let make ~session_id  () = { session_id }
    let parse xml =
      Some
        {
          session_id =
            (Xml.required "SessionId"
               (Util.option_bind (Xml.member "SessionId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "SessionId" ([], (String.to_xml v.session_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("session_id", (String.to_json v.session_id))])
    let of_json j =
      {
        session_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "session_id")))
      }
  end
module ListCommandsRequest =
  struct
    type t =
      {
      command_id: String.t option ;
      instance_id: String.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      filters: CommandFilterList.t }
    let make ?command_id  ?instance_id  ?max_results  ?next_token  ?(filters=
      [])  () = { command_id; instance_id; max_results; next_token; filters }
    let parse xml =
      Some
        {
          command_id =
            (Util.option_bind (Xml.member "CommandId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  CommandFilterList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Util.option_map v.command_id
                  (fun f ->
                     Ezxmlm.make_tag "CommandId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.instance_id
                 (fun f ->
                    Ezxmlm.make_tag "InstanceId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Filters"
                      ([], (CommandFilterList.to_xml [x])))) v.filters))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (CommandFilterList.to_json v.filters));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.command_id
             (fun f -> ("command_id", (String.to_json f)))])
    let of_json j =
      {
        command_id =
          (Util.option_map (Json.lookup j "command_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        filters =
          (CommandFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module TooManyTagsError =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module CreatePatchBaselineRequest =
  struct
    type t =
      {
      operating_system: OperatingSystem.t option ;
      name: String.t ;
      global_filters: PatchFilterGroup.t option ;
      approval_rules: PatchRuleGroup.t option ;
      approved_patches: PatchIdList.t ;
      approved_patches_compliance_level: PatchComplianceLevel.t option ;
      approved_patches_enable_non_security: Boolean.t option ;
      rejected_patches: PatchIdList.t ;
      rejected_patches_action: PatchAction.t option ;
      description: String.t option ;
      sources: PatchSourceList.t ;
      client_token: String.t option ;
      tags: TagList.t }
    let make ?operating_system  ~name  ?global_filters  ?approval_rules 
      ?(approved_patches= [])  ?approved_patches_compliance_level 
      ?approved_patches_enable_non_security  ?(rejected_patches= []) 
      ?rejected_patches_action  ?description  ?(sources= [])  ?client_token 
      ?(tags= [])  () =
      {
        operating_system;
        name;
        global_filters;
        approval_rules;
        approved_patches;
        approved_patches_compliance_level;
        approved_patches_enable_non_security;
        rejected_patches;
        rejected_patches_action;
        description;
        sources;
        client_token;
        tags
      }
    let parse xml =
      Some
        {
          operating_system =
            (Util.option_bind (Xml.member "OperatingSystem" xml)
               OperatingSystem.parse);
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          global_filters =
            (Util.option_bind (Xml.member "GlobalFilters" xml)
               PatchFilterGroup.parse);
          approval_rules =
            (Util.option_bind (Xml.member "ApprovalRules" xml)
               PatchRuleGroup.parse);
          approved_patches =
            (Util.of_option []
               (Util.option_bind (Xml.member "ApprovedPatches" xml)
                  PatchIdList.parse));
          approved_patches_compliance_level =
            (Util.option_bind
               (Xml.member "ApprovedPatchesComplianceLevel" xml)
               PatchComplianceLevel.parse);
          approved_patches_enable_non_security =
            (Util.option_bind
               (Xml.member "ApprovedPatchesEnableNonSecurity" xml)
               Boolean.parse);
          rejected_patches =
            (Util.of_option []
               (Util.option_bind (Xml.member "RejectedPatches" xml)
                  PatchIdList.parse));
          rejected_patches_action =
            (Util.option_bind (Xml.member "RejectedPatchesAction" xml)
               PatchAction.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          sources =
            (Util.of_option []
               (Util.option_bind (Xml.member "Sources" xml)
                  PatchSourceList.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tags" xml) TagList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.operating_system
                          (fun f ->
                             Ezxmlm.make_tag "OperatingSystem"
                               ([], (OperatingSystem.to_xml f)))])
                      @
                      [Some
                         (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
                     @
                     [Util.option_map v.global_filters
                        (fun f ->
                           Ezxmlm.make_tag "GlobalFilters"
                             ([], (PatchFilterGroup.to_xml f)))])
                    @
                    [Util.option_map v.approval_rules
                       (fun f ->
                          Ezxmlm.make_tag "ApprovalRules"
                            ([], (PatchRuleGroup.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "ApprovedPatches"
                              ([], (PatchIdList.to_xml [x]))))
                      v.approved_patches))
                  @
                  [Util.option_map v.approved_patches_compliance_level
                     (fun f ->
                        Ezxmlm.make_tag "ApprovedPatchesComplianceLevel"
                          ([], (PatchComplianceLevel.to_xml f)))])
                 @
                 [Util.option_map v.approved_patches_enable_non_security
                    (fun f ->
                       Ezxmlm.make_tag "ApprovedPatchesEnableNonSecurity"
                         ([], (Boolean.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "RejectedPatches"
                           ([], (PatchIdList.to_xml [x]))))
                   v.rejected_patches))
               @
               [Util.option_map v.rejected_patches_action
                  (fun f ->
                     Ezxmlm.make_tag "RejectedPatchesAction"
                       ([], (PatchAction.to_xml f)))])
              @
              [Util.option_map v.description
                 (fun f ->
                    Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Sources"
                        ([], (PatchSourceList.to_xml [x])))) v.sources))
            @
            [Util.option_map v.client_token
               (fun f ->
                  Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "Tags" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some ("sources", (PatchSourceList.to_json v.sources));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.rejected_patches_action
             (fun f -> ("rejected_patches_action", (PatchAction.to_json f)));
           Some
             ("rejected_patches", (PatchIdList.to_json v.rejected_patches));
           Util.option_map v.approved_patches_enable_non_security
             (fun f ->
                ("approved_patches_enable_non_security", (Boolean.to_json f)));
           Util.option_map v.approved_patches_compliance_level
             (fun f ->
                ("approved_patches_compliance_level",
                  (PatchComplianceLevel.to_json f)));
           Some
             ("approved_patches", (PatchIdList.to_json v.approved_patches));
           Util.option_map v.approval_rules
             (fun f -> ("approval_rules", (PatchRuleGroup.to_json f)));
           Util.option_map v.global_filters
             (fun f -> ("global_filters", (PatchFilterGroup.to_json f)));
           Some ("name", (String.to_json v.name));
           Util.option_map v.operating_system
             (fun f -> ("operating_system", (OperatingSystem.to_json f)))])
    let of_json j =
      {
        operating_system =
          (Util.option_map (Json.lookup j "operating_system")
             OperatingSystem.of_json);
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        global_filters =
          (Util.option_map (Json.lookup j "global_filters")
             PatchFilterGroup.of_json);
        approval_rules =
          (Util.option_map (Json.lookup j "approval_rules")
             PatchRuleGroup.of_json);
        approved_patches =
          (PatchIdList.of_json
             (Util.of_option_exn (Json.lookup j "approved_patches")));
        approved_patches_compliance_level =
          (Util.option_map
             (Json.lookup j "approved_patches_compliance_level")
             PatchComplianceLevel.of_json);
        approved_patches_enable_non_security =
          (Util.option_map
             (Json.lookup j "approved_patches_enable_non_security")
             Boolean.of_json);
        rejected_patches =
          (PatchIdList.of_json
             (Util.of_option_exn (Json.lookup j "rejected_patches")));
        rejected_patches_action =
          (Util.option_map (Json.lookup j "rejected_patches_action")
             PatchAction.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        sources =
          (PatchSourceList.of_json
             (Util.of_option_exn (Json.lookup j "sources")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module FeatureNotAvailableException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module AssociationDoesNotExist =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module GetInventoryResult =
  struct
    type t =
      {
      entities: InventoryResultEntityList.t ;
      next_token: String.t option }
    let make ?(entities= [])  ?next_token  () = { entities; next_token }
    let parse xml =
      Some
        {
          entities =
            (Util.of_option []
               (Util.option_bind (Xml.member "Entities" xml)
                  InventoryResultEntityList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Entities"
                       ([], (InventoryResultEntityList.to_xml [x]))))
               v.entities))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("entities", (InventoryResultEntityList.to_json v.entities))])
    let of_json j =
      {
        entities =
          (InventoryResultEntityList.of_json
             (Util.of_option_exn (Json.lookup j "entities")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module UpdateResourceDataSyncResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module RegisterTaskWithMaintenanceWindowRequest =
  struct
    type t =
      {
      window_id: String.t ;
      targets: Targets.t ;
      task_arn: String.t ;
      service_role_arn: String.t option ;
      task_type: MaintenanceWindowTaskType.t ;
      task_parameters: MaintenanceWindowTaskParameters.t option ;
      task_invocation_parameters:
        MaintenanceWindowTaskInvocationParameters.t option ;
      priority: Integer.t option ;
      max_concurrency: String.t ;
      max_errors: String.t ;
      logging_info: LoggingInfo.t option ;
      name: String.t option ;
      description: String.t option ;
      client_token: String.t option }
    let make ~window_id  ~targets  ~task_arn  ?service_role_arn  ~task_type 
      ?task_parameters  ?task_invocation_parameters  ?priority 
      ~max_concurrency  ~max_errors  ?logging_info  ?name  ?description 
      ?client_token  () =
      {
        window_id;
        targets;
        task_arn;
        service_role_arn;
        task_type;
        task_parameters;
        task_invocation_parameters;
        priority;
        max_concurrency;
        max_errors;
        logging_info;
        name;
        description;
        client_token
      }
    let parse xml =
      Some
        {
          window_id =
            (Xml.required "WindowId"
               (Util.option_bind (Xml.member "WindowId" xml) String.parse));
          targets =
            (Xml.required "Targets"
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          task_arn =
            (Xml.required "TaskArn"
               (Util.option_bind (Xml.member "TaskArn" xml) String.parse));
          service_role_arn =
            (Util.option_bind (Xml.member "ServiceRoleArn" xml) String.parse);
          task_type =
            (Xml.required "TaskType"
               (Util.option_bind (Xml.member "TaskType" xml)
                  MaintenanceWindowTaskType.parse));
          task_parameters =
            (Util.option_bind (Xml.member "TaskParameters" xml)
               MaintenanceWindowTaskParameters.parse);
          task_invocation_parameters =
            (Util.option_bind (Xml.member "TaskInvocationParameters" xml)
               MaintenanceWindowTaskInvocationParameters.parse);
          priority =
            (Util.option_bind (Xml.member "Priority" xml) Integer.parse);
          max_concurrency =
            (Xml.required "MaxConcurrency"
               (Util.option_bind (Xml.member "MaxConcurrency" xml)
                  String.parse));
          max_errors =
            (Xml.required "MaxErrors"
               (Util.option_bind (Xml.member "MaxErrors" xml) String.parse));
          logging_info =
            (Util.option_bind (Xml.member "LoggingInfo" xml)
               LoggingInfo.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        [Some
                           (Ezxmlm.make_tag "WindowId"
                              ([], (String.to_xml v.window_id)))])
                       @
                       (List.map
                          (fun x ->
                             Some
                               (Ezxmlm.make_tag "Targets"
                                  ([], (Targets.to_xml [x])))) v.targets))
                      @
                      [Some
                         (Ezxmlm.make_tag "TaskArn"
                            ([], (String.to_xml v.task_arn)))])
                     @
                     [Util.option_map v.service_role_arn
                        (fun f ->
                           Ezxmlm.make_tag "ServiceRoleArn"
                             ([], (String.to_xml f)))])
                    @
                    [Some
                       (Ezxmlm.make_tag "TaskType"
                          ([],
                            (MaintenanceWindowTaskType.to_xml v.task_type)))])
                   @
                   [Util.option_map v.task_parameters
                      (fun f ->
                         Ezxmlm.make_tag "TaskParameters"
                           ([], (MaintenanceWindowTaskParameters.to_xml f)))])
                  @
                  [Util.option_map v.task_invocation_parameters
                     (fun f ->
                        Ezxmlm.make_tag "TaskInvocationParameters"
                          ([],
                            (MaintenanceWindowTaskInvocationParameters.to_xml
                               f)))])
                 @
                 [Util.option_map v.priority
                    (fun f ->
                       Ezxmlm.make_tag "Priority" ([], (Integer.to_xml f)))])
                @
                [Some
                   (Ezxmlm.make_tag "MaxConcurrency"
                      ([], (String.to_xml v.max_concurrency)))])
               @
               [Some
                  (Ezxmlm.make_tag "MaxErrors"
                     ([], (String.to_xml v.max_errors)))])
              @
              [Util.option_map v.logging_info
                 (fun f ->
                    Ezxmlm.make_tag "LoggingInfo"
                      ([], (LoggingInfo.to_xml f)))])
             @
             [Util.option_map v.name
                (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
            @
            [Util.option_map v.description
               (fun f ->
                  Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.logging_info
             (fun f -> ("logging_info", (LoggingInfo.to_json f)));
           Some ("max_errors", (String.to_json v.max_errors));
           Some ("max_concurrency", (String.to_json v.max_concurrency));
           Util.option_map v.priority
             (fun f -> ("priority", (Integer.to_json f)));
           Util.option_map v.task_invocation_parameters
             (fun f ->
                ("task_invocation_parameters",
                  (MaintenanceWindowTaskInvocationParameters.to_json f)));
           Util.option_map v.task_parameters
             (fun f ->
                ("task_parameters",
                  (MaintenanceWindowTaskParameters.to_json f)));
           Some
             ("task_type", (MaintenanceWindowTaskType.to_json v.task_type));
           Util.option_map v.service_role_arn
             (fun f -> ("service_role_arn", (String.to_json f)));
           Some ("task_arn", (String.to_json v.task_arn));
           Some ("targets", (Targets.to_json v.targets));
           Some ("window_id", (String.to_json v.window_id))])
    let of_json j =
      {
        window_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "window_id")));
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        task_arn =
          (String.of_json (Util.of_option_exn (Json.lookup j "task_arn")));
        service_role_arn =
          (Util.option_map (Json.lookup j "service_role_arn") String.of_json);
        task_type =
          (MaintenanceWindowTaskType.of_json
             (Util.of_option_exn (Json.lookup j "task_type")));
        task_parameters =
          (Util.option_map (Json.lookup j "task_parameters")
             MaintenanceWindowTaskParameters.of_json);
        task_invocation_parameters =
          (Util.option_map (Json.lookup j "task_invocation_parameters")
             MaintenanceWindowTaskInvocationParameters.of_json);
        priority =
          (Util.option_map (Json.lookup j "priority") Integer.of_json);
        max_concurrency =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "max_concurrency")));
        max_errors =
          (String.of_json (Util.of_option_exn (Json.lookup j "max_errors")));
        logging_info =
          (Util.option_map (Json.lookup j "logging_info") LoggingInfo.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeEffectiveInstanceAssociationsResult =
  struct
    type t =
      {
      associations: InstanceAssociationList.t ;
      next_token: String.t option }
    let make ?(associations= [])  ?next_token  () =
      { associations; next_token }
    let parse xml =
      Some
        {
          associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "Associations" xml)
                  InstanceAssociationList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Associations"
                       ([], (InstanceAssociationList.to_xml [x]))))
               v.associations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("associations",
               (InstanceAssociationList.to_json v.associations))])
    let of_json j =
      {
        associations =
          (InstanceAssociationList.of_json
             (Util.of_option_exn (Json.lookup j "associations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module UnsupportedCalendarException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribePatchPropertiesResult =
  struct
    type t =
      {
      properties: PatchPropertiesList.t ;
      next_token: String.t option }
    let make ?(properties= [])  ?next_token  () = { properties; next_token }
    let parse xml =
      Some
        {
          properties =
            (Util.of_option []
               (Util.option_bind (Xml.member "Properties" xml)
                  PatchPropertiesList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Properties"
                       ([], (PatchPropertiesList.to_xml [x])))) v.properties))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("properties", (PatchPropertiesList.to_json v.properties))])
    let of_json j =
      {
        properties =
          (PatchPropertiesList.of_json
             (Util.of_option_exn (Json.lookup j "properties")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module StartAssociationsOnceRequest =
  struct
    type t = {
      association_ids: AssociationIdList.t }
    let make ~association_ids  () = { association_ids }
    let parse xml =
      Some
        {
          association_ids =
            (Xml.required "AssociationIds"
               (Util.option_bind (Xml.member "AssociationIds" xml)
                  AssociationIdList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "AssociationIds"
                      ([], (AssociationIdList.to_xml [x]))))
              v.association_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("association_ids",
                (AssociationIdList.to_json v.association_ids))])
    let of_json j =
      {
        association_ids =
          (AssociationIdList.of_json
             (Util.of_option_exn (Json.lookup j "association_ids")))
      }
  end
module AssociationLimitExceeded =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module DeleteParameterRequest =
  struct
    type t = {
      name: String.t }
    let make ~name  () = { name }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
    let to_json v =
      `Assoc (Util.list_filter_opt [Some ("name", (String.to_json v.name))])
    let of_json j =
      { name = (String.of_json (Util.of_option_exn (Json.lookup j "name"))) }
  end
module DescribeDocumentResult =
  struct
    type t = {
      document: DocumentDescription.t option }
    let make ?document  () = { document }
    let parse xml =
      Some
        {
          document =
            (Util.option_bind (Xml.member "Document" xml)
               DocumentDescription.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.document
              (fun f ->
                 Ezxmlm.make_tag "Document"
                   ([], (DocumentDescription.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.document
              (fun f -> ("document", (DocumentDescription.to_json f)))])
    let of_json j =
      {
        document =
          (Util.option_map (Json.lookup j "document")
             DocumentDescription.of_json)
      }
  end
module UpdateAssociationStatusRequest =
  struct
    type t =
      {
      name: String.t ;
      instance_id: String.t ;
      association_status: AssociationStatus.t }
    let make ~name  ~instance_id  ~association_status  () =
      { name; instance_id; association_status }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          association_status =
            (Xml.required "AssociationStatus"
               (Util.option_bind (Xml.member "AssociationStatus" xml)
                  AssociationStatus.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
            @
            [Some
               (Ezxmlm.make_tag "InstanceId"
                  ([], (String.to_xml v.instance_id)))])
           @
           [Some
              (Ezxmlm.make_tag "AssociationStatus"
                 ([], (AssociationStatus.to_xml v.association_status)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("association_status",
                (AssociationStatus.to_json v.association_status));
           Some ("instance_id", (String.to_json v.instance_id));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        association_status =
          (AssociationStatus.of_json
             (Util.of_option_exn (Json.lookup j "association_status")))
      }
  end
module CreateMaintenanceWindowResult =
  struct
    type t = {
      window_id: String.t option }
    let make ?window_id  () = { window_id }
    let parse xml =
      Some
        {
          window_id =
            (Util.option_bind (Xml.member "WindowId" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.window_id
              (fun f -> Ezxmlm.make_tag "WindowId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.window_id
              (fun f -> ("window_id", (String.to_json f)))])
    let of_json j =
      {
        window_id =
          (Util.option_map (Json.lookup j "window_id") String.of_json)
      }
  end
module OpsItemNotFoundException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module InvalidDocumentType =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribePatchGroupStateRequest =
  struct
    type t = {
      patch_group: String.t }
    let make ~patch_group  () = { patch_group }
    let parse xml =
      Some
        {
          patch_group =
            (Xml.required "PatchGroup"
               (Util.option_bind (Xml.member "PatchGroup" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "PatchGroup"
                 ([], (String.to_xml v.patch_group)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("patch_group", (String.to_json v.patch_group))])
    let of_json j =
      {
        patch_group =
          (String.of_json (Util.of_option_exn (Json.lookup j "patch_group")))
      }
  end
module InvalidNextToken =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeMaintenanceWindowExecutionsRequest =
  struct
    type t =
      {
      window_id: String.t ;
      filters: MaintenanceWindowFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ~window_id  ?(filters= [])  ?max_results  ?next_token  () =
      { window_id; filters; max_results; next_token }
    let parse xml =
      Some
        {
          window_id =
            (Xml.required "WindowId"
               (Util.option_bind (Xml.member "WindowId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  MaintenanceWindowFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "WindowId"
                    ([], (String.to_xml v.window_id)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (MaintenanceWindowFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (MaintenanceWindowFilterList.to_json v.filters));
           Some ("window_id", (String.to_json v.window_id))])
    let of_json j =
      {
        window_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "window_id")));
        filters =
          (MaintenanceWindowFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module AssociationAlreadyExists =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module ListResourceComplianceSummariesResult =
  struct
    type t =
      {
      resource_compliance_summary_items: ResourceComplianceSummaryItemList.t ;
      next_token: String.t option }
    let make ?(resource_compliance_summary_items= [])  ?next_token  () =
      { resource_compliance_summary_items; next_token }
    let parse xml =
      Some
        {
          resource_compliance_summary_items =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ResourceComplianceSummaryItems" xml)
                  ResourceComplianceSummaryItemList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ResourceComplianceSummaryItems"
                       ([], (ResourceComplianceSummaryItemList.to_xml [x]))))
               v.resource_compliance_summary_items))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("resource_compliance_summary_items",
               (ResourceComplianceSummaryItemList.to_json
                  v.resource_compliance_summary_items))])
    let of_json j =
      {
        resource_compliance_summary_items =
          (ResourceComplianceSummaryItemList.of_json
             (Util.of_option_exn
                (Json.lookup j "resource_compliance_summary_items")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module AutomationExecutionNotFoundException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeInstancePatchStatesForPatchGroupRequest =
  struct
    type t =
      {
      patch_group: String.t ;
      filters: InstancePatchStateFilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ~patch_group  ?(filters= [])  ?next_token  ?max_results  () =
      { patch_group; filters; next_token; max_results }
    let parse xml =
      Some
        {
          patch_group =
            (Xml.required "PatchGroup"
               (Util.option_bind (Xml.member "PatchGroup" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  InstancePatchStateFilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "PatchGroup"
                    ([], (String.to_xml v.patch_group)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (InstancePatchStateFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (InstancePatchStateFilterList.to_json v.filters));
           Some ("patch_group", (String.to_json v.patch_group))])
    let of_json j =
      {
        patch_group =
          (String.of_json (Util.of_option_exn (Json.lookup j "patch_group")));
        filters =
          (InstancePatchStateFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module GetDeployablePatchSnapshotForInstanceRequest =
  struct
    type t = {
      instance_id: String.t ;
      snapshot_id: String.t }
    let make ~instance_id  ~snapshot_id  () = { instance_id; snapshot_id }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          snapshot_id =
            (Xml.required "SnapshotId"
               (Util.option_bind (Xml.member "SnapshotId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "InstanceId"
                  ([], (String.to_xml v.instance_id)))])
           @
           [Some
              (Ezxmlm.make_tag "SnapshotId"
                 ([], (String.to_xml v.snapshot_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("snapshot_id", (String.to_json v.snapshot_id));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")))
      }
  end
module DeleteMaintenanceWindowResult =
  struct
    type t = {
      window_id: String.t option }
    let make ?window_id  () = { window_id }
    let parse xml =
      Some
        {
          window_id =
            (Util.option_bind (Xml.member "WindowId" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.window_id
              (fun f -> Ezxmlm.make_tag "WindowId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.window_id
              (fun f -> ("window_id", (String.to_json f)))])
    let of_json j =
      {
        window_id =
          (Util.option_map (Json.lookup j "window_id") String.of_json)
      }
  end
module InvalidAllowedPatternException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ListInventoryEntriesRequest =
  struct
    type t =
      {
      instance_id: String.t ;
      type_name: String.t ;
      filters: InventoryFilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ~instance_id  ~type_name  ?(filters= [])  ?next_token 
      ?max_results  () =
      { instance_id; type_name; filters; next_token; max_results }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          type_name =
            (Xml.required "TypeName"
               (Util.option_bind (Xml.member "TypeName" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  InventoryFilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "InstanceId"
                     ([], (String.to_xml v.instance_id)))])
              @
              [Some
                 (Ezxmlm.make_tag "TypeName"
                    ([], (String.to_xml v.type_name)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (InventoryFilterList.to_xml [x])))) v.filters))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (InventoryFilterList.to_json v.filters));
           Some ("type_name", (String.to_json v.type_name));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        type_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "type_name")));
        filters =
          (InventoryFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module InvalidAutomationSignalException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeAvailablePatchesRequest =
  struct
    type t =
      {
      filters: PatchOrchestratorFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(filters= [])  ?max_results  ?next_token  () =
      { filters; max_results; next_token }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  PatchOrchestratorFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (PatchOrchestratorFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (PatchOrchestratorFilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (PatchOrchestratorFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module InvalidPolicyTypeException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module CreateAssociationBatchRequest =
  struct
    type t = {
      entries: CreateAssociationBatchRequestEntries.t }
    let make ~entries  () = { entries }
    let parse xml =
      Some
        {
          entries =
            (Xml.required "Entries"
               (Util.option_bind (Xml.member "Entries" xml)
                  CreateAssociationBatchRequestEntries.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Entries"
                      ([], (CreateAssociationBatchRequestEntries.to_xml [x]))))
              v.entries))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("entries",
                (CreateAssociationBatchRequestEntries.to_json v.entries))])
    let of_json j =
      {
        entries =
          (CreateAssociationBatchRequestEntries.of_json
             (Util.of_option_exn (Json.lookup j "entries")))
      }
  end
module StatusUnchanged =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module UpdateServiceSettingRequest =
  struct
    type t = {
      setting_id: String.t ;
      setting_value: String.t }
    let make ~setting_id  ~setting_value  () = { setting_id; setting_value }
    let parse xml =
      Some
        {
          setting_id =
            (Xml.required "SettingId"
               (Util.option_bind (Xml.member "SettingId" xml) String.parse));
          setting_value =
            (Xml.required "SettingValue"
               (Util.option_bind (Xml.member "SettingValue" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "SettingId"
                  ([], (String.to_xml v.setting_id)))])
           @
           [Some
              (Ezxmlm.make_tag "SettingValue"
                 ([], (String.to_xml v.setting_value)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("setting_value", (String.to_json v.setting_value));
           Some ("setting_id", (String.to_json v.setting_id))])
    let of_json j =
      {
        setting_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "setting_id")));
        setting_value =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "setting_value")))
      }
  end
module DeregisterTargetFromMaintenanceWindowResult =
  struct
    type t = {
      window_id: String.t option ;
      window_target_id: String.t option }
    let make ?window_id  ?window_target_id  () =
      { window_id; window_target_id }
    let parse xml =
      Some
        {
          window_id =
            (Util.option_bind (Xml.member "WindowId" xml) String.parse);
          window_target_id =
            (Util.option_bind (Xml.member "WindowTargetId" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.window_id
               (fun f -> Ezxmlm.make_tag "WindowId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.window_target_id
              (fun f ->
                 Ezxmlm.make_tag "WindowTargetId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.window_target_id
              (fun f -> ("window_target_id", (String.to_json f)));
           Util.option_map v.window_id
             (fun f -> ("window_id", (String.to_json f)))])
    let of_json j =
      {
        window_id =
          (Util.option_map (Json.lookup j "window_id") String.of_json);
        window_target_id =
          (Util.option_map (Json.lookup j "window_target_id") String.of_json)
      }
  end
module DescribeAssociationExecutionTargetsResult =
  struct
    type t =
      {
      association_execution_targets: AssociationExecutionTargetsList.t ;
      next_token: String.t option }
    let make ?(association_execution_targets= [])  ?next_token  () =
      { association_execution_targets; next_token }
    let parse xml =
      Some
        {
          association_execution_targets =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "AssociationExecutionTargets" xml)
                  AssociationExecutionTargetsList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "AssociationExecutionTargets"
                       ([], (AssociationExecutionTargetsList.to_xml [x]))))
               v.association_execution_targets))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("association_execution_targets",
               (AssociationExecutionTargetsList.to_json
                  v.association_execution_targets))])
    let of_json j =
      {
        association_execution_targets =
          (AssociationExecutionTargetsList.of_json
             (Util.of_option_exn
                (Json.lookup j "association_execution_targets")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module InvalidDocumentOperation =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeAssociationExecutionsResult =
  struct
    type t =
      {
      association_executions: AssociationExecutionsList.t ;
      next_token: String.t option }
    let make ?(association_executions= [])  ?next_token  () =
      { association_executions; next_token }
    let parse xml =
      Some
        {
          association_executions =
            (Util.of_option []
               (Util.option_bind (Xml.member "AssociationExecutions" xml)
                  AssociationExecutionsList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "AssociationExecutions"
                       ([], (AssociationExecutionsList.to_xml [x]))))
               v.association_executions))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("association_executions",
               (AssociationExecutionsList.to_json v.association_executions))])
    let of_json j =
      {
        association_executions =
          (AssociationExecutionsList.of_json
             (Util.of_option_exn (Json.lookup j "association_executions")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module TargetNotConnected =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module UpdateServiceSettingResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module SendCommandRequest =
  struct
    type t =
      {
      instance_ids: InstanceIdList.t ;
      targets: Targets.t ;
      document_name: String.t ;
      document_version: String.t option ;
      document_hash: String.t option ;
      document_hash_type: DocumentHashType.t option ;
      timeout_seconds: Integer.t option ;
      comment: String.t option ;
      parameters: Parameters.t option ;
      output_s3_region: String.t option ;
      output_s3_bucket_name: String.t option ;
      output_s3_key_prefix: String.t option ;
      max_concurrency: String.t option ;
      max_errors: String.t option ;
      service_role_arn: String.t option ;
      notification_config: NotificationConfig.t option ;
      cloud_watch_output_config: CloudWatchOutputConfig.t option }
    let make ?(instance_ids= [])  ?(targets= [])  ~document_name 
      ?document_version  ?document_hash  ?document_hash_type 
      ?timeout_seconds  ?comment  ?parameters  ?output_s3_region 
      ?output_s3_bucket_name  ?output_s3_key_prefix  ?max_concurrency 
      ?max_errors  ?service_role_arn  ?notification_config 
      ?cloud_watch_output_config  () =
      {
        instance_ids;
        targets;
        document_name;
        document_version;
        document_hash;
        document_hash_type;
        timeout_seconds;
        comment;
        parameters;
        output_s3_region;
        output_s3_bucket_name;
        output_s3_key_prefix;
        max_concurrency;
        max_errors;
        service_role_arn;
        notification_config;
        cloud_watch_output_config
      }
    let parse xml =
      Some
        {
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceIds" xml)
                  InstanceIdList.parse));
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          document_name =
            (Xml.required "DocumentName"
               (Util.option_bind (Xml.member "DocumentName" xml) String.parse));
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          document_hash =
            (Util.option_bind (Xml.member "DocumentHash" xml) String.parse);
          document_hash_type =
            (Util.option_bind (Xml.member "DocumentHashType" xml)
               DocumentHashType.parse);
          timeout_seconds =
            (Util.option_bind (Xml.member "TimeoutSeconds" xml) Integer.parse);
          comment =
            (Util.option_bind (Xml.member "Comment" xml) String.parse);
          parameters =
            (Util.option_bind (Xml.member "Parameters" xml) Parameters.parse);
          output_s3_region =
            (Util.option_bind (Xml.member "OutputS3Region" xml) String.parse);
          output_s3_bucket_name =
            (Util.option_bind (Xml.member "OutputS3BucketName" xml)
               String.parse);
          output_s3_key_prefix =
            (Util.option_bind (Xml.member "OutputS3KeyPrefix" xml)
               String.parse);
          max_concurrency =
            (Util.option_bind (Xml.member "MaxConcurrency" xml) String.parse);
          max_errors =
            (Util.option_bind (Xml.member "MaxErrors" xml) String.parse);
          service_role_arn =
            (Util.option_bind (Xml.member "ServiceRoleArn" xml) String.parse);
          notification_config =
            (Util.option_bind (Xml.member "NotificationConfig" xml)
               NotificationConfig.parse);
          cloud_watch_output_config =
            (Util.option_bind (Xml.member "CloudWatchOutputConfig" xml)
               CloudWatchOutputConfig.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((([] @
                           (List.map
                              (fun x ->
                                 Some
                                   (Ezxmlm.make_tag "InstanceIds"
                                      ([], (InstanceIdList.to_xml [x]))))
                              v.instance_ids))
                          @
                          (List.map
                             (fun x ->
                                Some
                                  (Ezxmlm.make_tag "Targets"
                                     ([], (Targets.to_xml [x])))) v.targets))
                         @
                         [Some
                            (Ezxmlm.make_tag "DocumentName"
                               ([], (String.to_xml v.document_name)))])
                        @
                        [Util.option_map v.document_version
                           (fun f ->
                              Ezxmlm.make_tag "DocumentVersion"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.document_hash
                          (fun f ->
                             Ezxmlm.make_tag "DocumentHash"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.document_hash_type
                         (fun f ->
                            Ezxmlm.make_tag "DocumentHashType"
                              ([], (DocumentHashType.to_xml f)))])
                     @
                     [Util.option_map v.timeout_seconds
                        (fun f ->
                           Ezxmlm.make_tag "TimeoutSeconds"
                             ([], (Integer.to_xml f)))])
                    @
                    [Util.option_map v.comment
                       (fun f ->
                          Ezxmlm.make_tag "Comment" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.parameters
                      (fun f ->
                         Ezxmlm.make_tag "Parameters"
                           ([], (Parameters.to_xml f)))])
                  @
                  [Util.option_map v.output_s3_region
                     (fun f ->
                        Ezxmlm.make_tag "OutputS3Region"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.output_s3_bucket_name
                    (fun f ->
                       Ezxmlm.make_tag "OutputS3BucketName"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.output_s3_key_prefix
                   (fun f ->
                      Ezxmlm.make_tag "OutputS3KeyPrefix"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.max_concurrency
                  (fun f ->
                     Ezxmlm.make_tag "MaxConcurrency" ([], (String.to_xml f)))])
              @
              [Util.option_map v.max_errors
                 (fun f ->
                    Ezxmlm.make_tag "MaxErrors" ([], (String.to_xml f)))])
             @
             [Util.option_map v.service_role_arn
                (fun f ->
                   Ezxmlm.make_tag "ServiceRoleArn" ([], (String.to_xml f)))])
            @
            [Util.option_map v.notification_config
               (fun f ->
                  Ezxmlm.make_tag "NotificationConfig"
                    ([], (NotificationConfig.to_xml f)))])
           @
           [Util.option_map v.cloud_watch_output_config
              (fun f ->
                 Ezxmlm.make_tag "CloudWatchOutputConfig"
                   ([], (CloudWatchOutputConfig.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cloud_watch_output_config
              (fun f ->
                 ("cloud_watch_output_config",
                   (CloudWatchOutputConfig.to_json f)));
           Util.option_map v.notification_config
             (fun f ->
                ("notification_config", (NotificationConfig.to_json f)));
           Util.option_map v.service_role_arn
             (fun f -> ("service_role_arn", (String.to_json f)));
           Util.option_map v.max_errors
             (fun f -> ("max_errors", (String.to_json f)));
           Util.option_map v.max_concurrency
             (fun f -> ("max_concurrency", (String.to_json f)));
           Util.option_map v.output_s3_key_prefix
             (fun f -> ("output_s3_key_prefix", (String.to_json f)));
           Util.option_map v.output_s3_bucket_name
             (fun f -> ("output_s3_bucket_name", (String.to_json f)));
           Util.option_map v.output_s3_region
             (fun f -> ("output_s3_region", (String.to_json f)));
           Util.option_map v.parameters
             (fun f -> ("parameters", (Parameters.to_json f)));
           Util.option_map v.comment
             (fun f -> ("comment", (String.to_json f)));
           Util.option_map v.timeout_seconds
             (fun f -> ("timeout_seconds", (Integer.to_json f)));
           Util.option_map v.document_hash_type
             (fun f -> ("document_hash_type", (DocumentHashType.to_json f)));
           Util.option_map v.document_hash
             (fun f -> ("document_hash", (String.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Some ("document_name", (String.to_json v.document_name));
           Some ("targets", (Targets.to_json v.targets));
           Some ("instance_ids", (InstanceIdList.to_json v.instance_ids))])
    let of_json j =
      {
        instance_ids =
          (InstanceIdList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        document_name =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "document_name")));
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        document_hash =
          (Util.option_map (Json.lookup j "document_hash") String.of_json);
        document_hash_type =
          (Util.option_map (Json.lookup j "document_hash_type")
             DocumentHashType.of_json);
        timeout_seconds =
          (Util.option_map (Json.lookup j "timeout_seconds") Integer.of_json);
        comment = (Util.option_map (Json.lookup j "comment") String.of_json);
        parameters =
          (Util.option_map (Json.lookup j "parameters") Parameters.of_json);
        output_s3_region =
          (Util.option_map (Json.lookup j "output_s3_region") String.of_json);
        output_s3_bucket_name =
          (Util.option_map (Json.lookup j "output_s3_bucket_name")
             String.of_json);
        output_s3_key_prefix =
          (Util.option_map (Json.lookup j "output_s3_key_prefix")
             String.of_json);
        max_concurrency =
          (Util.option_map (Json.lookup j "max_concurrency") String.of_json);
        max_errors =
          (Util.option_map (Json.lookup j "max_errors") String.of_json);
        service_role_arn =
          (Util.option_map (Json.lookup j "service_role_arn") String.of_json);
        notification_config =
          (Util.option_map (Json.lookup j "notification_config")
             NotificationConfig.of_json);
        cloud_watch_output_config =
          (Util.option_map (Json.lookup j "cloud_watch_output_config")
             CloudWatchOutputConfig.of_json)
      }
  end
module DeregisterTargetFromMaintenanceWindowRequest =
  struct
    type t =
      {
      window_id: String.t ;
      window_target_id: String.t ;
      safe: Boolean.t option }
    let make ~window_id  ~window_target_id  ?safe  () =
      { window_id; window_target_id; safe }
    let parse xml =
      Some
        {
          window_id =
            (Xml.required "WindowId"
               (Util.option_bind (Xml.member "WindowId" xml) String.parse));
          window_target_id =
            (Xml.required "WindowTargetId"
               (Util.option_bind (Xml.member "WindowTargetId" xml)
                  String.parse));
          safe = (Util.option_bind (Xml.member "Safe" xml) Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "WindowId" ([], (String.to_xml v.window_id)))])
            @
            [Some
               (Ezxmlm.make_tag "WindowTargetId"
                  ([], (String.to_xml v.window_target_id)))])
           @
           [Util.option_map v.safe
              (fun f -> Ezxmlm.make_tag "Safe" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.safe (fun f -> ("safe", (Boolean.to_json f)));
           Some ("window_target_id", (String.to_json v.window_target_id));
           Some ("window_id", (String.to_json v.window_id))])
    let of_json j =
      {
        window_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "window_id")));
        window_target_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "window_target_id")));
        safe = (Util.option_map (Json.lookup j "safe") Boolean.of_json)
      }
  end
module GetParametersByPathResult =
  struct
    type t = {
      parameters: ParameterList.t ;
      next_token: String.t option }
    let make ?(parameters= [])  ?next_token  () = { parameters; next_token }
    let parse xml =
      Some
        {
          parameters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Parameters" xml)
                  ParameterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Parameters"
                       ([], (ParameterList.to_xml [x])))) v.parameters))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("parameters", (ParameterList.to_json v.parameters))])
    let of_json j =
      {
        parameters =
          (ParameterList.of_json
             (Util.of_option_exn (Json.lookup j "parameters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteResourceDataSyncRequest =
  struct
    type t = {
      sync_name: String.t ;
      sync_type: String.t option }
    let make ~sync_name  ?sync_type  () = { sync_name; sync_type }
    let parse xml =
      Some
        {
          sync_name =
            (Xml.required "SyncName"
               (Util.option_bind (Xml.member "SyncName" xml) String.parse));
          sync_type =
            (Util.option_bind (Xml.member "SyncType" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "SyncName" ([], (String.to_xml v.sync_name)))])
           @
           [Util.option_map v.sync_type
              (fun f -> Ezxmlm.make_tag "SyncType" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.sync_type
              (fun f -> ("sync_type", (String.to_json f)));
           Some ("sync_name", (String.to_json v.sync_name))])
    let of_json j =
      {
        sync_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "sync_name")));
        sync_type =
          (Util.option_map (Json.lookup j "sync_type") String.of_json)
      }
  end
module InvalidParameters =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module AssociationVersionLimitExceeded =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeInstancePatchStatesForPatchGroupResult =
  struct
    type t =
      {
      instance_patch_states: InstancePatchStatesList.t ;
      next_token: String.t option }
    let make ?(instance_patch_states= [])  ?next_token  () =
      { instance_patch_states; next_token }
    let parse xml =
      Some
        {
          instance_patch_states =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstancePatchStates" xml)
                  InstancePatchStatesList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "InstancePatchStates"
                       ([], (InstancePatchStatesList.to_xml [x]))))
               v.instance_patch_states))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_patch_states",
               (InstancePatchStatesList.to_json v.instance_patch_states))])
    let of_json j =
      {
        instance_patch_states =
          (InstancePatchStatesList.of_json
             (Util.of_option_exn (Json.lookup j "instance_patch_states")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DuplicateInstanceId =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module InvalidSchedule =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module InvalidCommandId =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module SubTypeCountLimitExceededException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeAutomationExecutionsRequest =
  struct
    type t =
      {
      filters: AutomationExecutionFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(filters= [])  ?max_results  ?next_token  () =
      { filters; max_results; next_token }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  AutomationExecutionFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (AutomationExecutionFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("filters", (AutomationExecutionFilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (AutomationExecutionFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ListCommandsResult =
  struct
    type t = {
      commands: CommandList.t ;
      next_token: String.t option }
    let make ?(commands= [])  ?next_token  () = { commands; next_token }
    let parse xml =
      Some
        {
          commands =
            (Util.of_option []
               (Util.option_bind (Xml.member "Commands" xml)
                  CommandList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Commands"
                       ([], (CommandList.to_xml [x])))) v.commands))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("commands", (CommandList.to_json v.commands))])
    let of_json j =
      {
        commands =
          (CommandList.of_json
             (Util.of_option_exn (Json.lookup j "commands")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetAutomationExecutionRequest =
  struct
    type t = {
      automation_execution_id: String.t }
    let make ~automation_execution_id  () = { automation_execution_id }
    let parse xml =
      Some
        {
          automation_execution_id =
            (Xml.required "AutomationExecutionId"
               (Util.option_bind (Xml.member "AutomationExecutionId" xml)
                  String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "AutomationExecutionId"
                 ([], (String.to_xml v.automation_execution_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("automation_execution_id",
                (String.to_json v.automation_execution_id))])
    let of_json j =
      {
        automation_execution_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "automation_execution_id")))
      }
  end
module InvalidPermissionType =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module GetPatchBaselineRequest =
  struct
    type t = {
      baseline_id: String.t }
    let make ~baseline_id  () = { baseline_id }
    let parse xml =
      Some
        {
          baseline_id =
            (Xml.required "BaselineId"
               (Util.option_bind (Xml.member "BaselineId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "BaselineId"
                 ([], (String.to_xml v.baseline_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("baseline_id", (String.to_json v.baseline_id))])
    let of_json j =
      {
        baseline_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "baseline_id")))
      }
  end
module DeregisterManagedInstanceResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module InvalidAssociationVersion =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module CreateResourceDataSyncResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module DeleteMaintenanceWindowRequest =
  struct
    type t = {
      window_id: String.t }
    let make ~window_id  () = { window_id }
    let parse xml =
      Some
        {
          window_id =
            (Xml.required "WindowId"
               (Util.option_bind (Xml.member "WindowId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "WindowId" ([], (String.to_xml v.window_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("window_id", (String.to_json v.window_id))])
    let of_json j =
      {
        window_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "window_id")))
      }
  end
module UpdateAssociationStatusResult =
  struct
    type t = {
      association_description: AssociationDescription.t option }
    let make ?association_description  () = { association_description }
    let parse xml =
      Some
        {
          association_description =
            (Util.option_bind (Xml.member "AssociationDescription" xml)
               AssociationDescription.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.association_description
              (fun f ->
                 Ezxmlm.make_tag "AssociationDescription"
                   ([], (AssociationDescription.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_description
              (fun f ->
                 ("association_description",
                   (AssociationDescription.to_json f)))])
    let of_json j =
      {
        association_description =
          (Util.option_map (Json.lookup j "association_description")
             AssociationDescription.of_json)
      }
  end
module InvalidOptionException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeMaintenanceWindowTargetsResult =
  struct
    type t =
      {
      targets: MaintenanceWindowTargetList.t ;
      next_token: String.t option }
    let make ?(targets= [])  ?next_token  () = { targets; next_token }
    let parse xml =
      Some
        {
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml)
                  MaintenanceWindowTargetList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Targets"
                       ([], (MaintenanceWindowTargetList.to_xml [x]))))
               v.targets))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("targets", (MaintenanceWindowTargetList.to_json v.targets))])
    let of_json j =
      {
        targets =
          (MaintenanceWindowTargetList.of_json
             (Util.of_option_exn (Json.lookup j "targets")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module InvalidResourceType =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module CustomSchemaCountLimitExceededException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeOpsItemsResponse =
  struct
    type t =
      {
      next_token: String.t option ;
      ops_item_summaries: OpsItemSummaries.t }
    let make ?next_token  ?(ops_item_summaries= [])  () =
      { next_token; ops_item_summaries }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          ops_item_summaries =
            (Util.of_option []
               (Util.option_bind (Xml.member "OpsItemSummaries" xml)
                  OpsItemSummaries.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "OpsItemSummaries"
                      ([], (OpsItemSummaries.to_xml [x]))))
              v.ops_item_summaries))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("ops_item_summaries",
                (OpsItemSummaries.to_json v.ops_item_summaries));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        ops_item_summaries =
          (OpsItemSummaries.of_json
             (Util.of_option_exn (Json.lookup j "ops_item_summaries")))
      }
  end
module StartAutomationExecutionRequest =
  struct
    type t =
      {
      document_name: String.t ;
      document_version: String.t option ;
      parameters: AutomationParameterMap.t option ;
      client_token: String.t option ;
      mode: ExecutionMode.t option ;
      target_parameter_name: String.t option ;
      targets: Targets.t ;
      target_maps: TargetMaps.t ;
      max_concurrency: String.t option ;
      max_errors: String.t option ;
      target_locations: TargetLocations.t ;
      tags: TagList.t }
    let make ~document_name  ?document_version  ?parameters  ?client_token 
      ?mode  ?target_parameter_name  ?(targets= [])  ?(target_maps= []) 
      ?max_concurrency  ?max_errors  ?(target_locations= [])  ?(tags= [])  ()
      =
      {
        document_name;
        document_version;
        parameters;
        client_token;
        mode;
        target_parameter_name;
        targets;
        target_maps;
        max_concurrency;
        max_errors;
        target_locations;
        tags
      }
    let parse xml =
      Some
        {
          document_name =
            (Xml.required "DocumentName"
               (Util.option_bind (Xml.member "DocumentName" xml) String.parse));
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          parameters =
            (Util.option_bind (Xml.member "Parameters" xml)
               AutomationParameterMap.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          mode =
            (Util.option_bind (Xml.member "Mode" xml) ExecutionMode.parse);
          target_parameter_name =
            (Util.option_bind (Xml.member "TargetParameterName" xml)
               String.parse);
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          target_maps =
            (Util.of_option []
               (Util.option_bind (Xml.member "TargetMaps" xml)
                  TargetMaps.parse));
          max_concurrency =
            (Util.option_bind (Xml.member "MaxConcurrency" xml) String.parse);
          max_errors =
            (Util.option_bind (Xml.member "MaxErrors" xml) String.parse);
          target_locations =
            (Util.of_option []
               (Util.option_bind (Xml.member "TargetLocations" xml)
                  TargetLocations.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tags" xml) TagList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Some
                         (Ezxmlm.make_tag "DocumentName"
                            ([], (String.to_xml v.document_name)))])
                     @
                     [Util.option_map v.document_version
                        (fun f ->
                           Ezxmlm.make_tag "DocumentVersion"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.parameters
                       (fun f ->
                          Ezxmlm.make_tag "Parameters"
                            ([], (AutomationParameterMap.to_xml f)))])
                   @
                   [Util.option_map v.client_token
                      (fun f ->
                         Ezxmlm.make_tag "ClientToken"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.mode
                     (fun f ->
                        Ezxmlm.make_tag "Mode" ([], (ExecutionMode.to_xml f)))])
                 @
                 [Util.option_map v.target_parameter_name
                    (fun f ->
                       Ezxmlm.make_tag "TargetParameterName"
                         ([], (String.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "Targets" ([], (Targets.to_xml [x]))))
                   v.targets))
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "TargetMaps"
                          ([], (TargetMaps.to_xml [x])))) v.target_maps))
              @
              [Util.option_map v.max_concurrency
                 (fun f ->
                    Ezxmlm.make_tag "MaxConcurrency" ([], (String.to_xml f)))])
             @
             [Util.option_map v.max_errors
                (fun f -> Ezxmlm.make_tag "MaxErrors" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "TargetLocations"
                       ([], (TargetLocations.to_xml [x]))))
               v.target_locations))
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "Tags" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some
             ("target_locations",
               (TargetLocations.to_json v.target_locations));
           Util.option_map v.max_errors
             (fun f -> ("max_errors", (String.to_json f)));
           Util.option_map v.max_concurrency
             (fun f -> ("max_concurrency", (String.to_json f)));
           Some ("target_maps", (TargetMaps.to_json v.target_maps));
           Some ("targets", (Targets.to_json v.targets));
           Util.option_map v.target_parameter_name
             (fun f -> ("target_parameter_name", (String.to_json f)));
           Util.option_map v.mode
             (fun f -> ("mode", (ExecutionMode.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.parameters
             (fun f -> ("parameters", (AutomationParameterMap.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Some ("document_name", (String.to_json v.document_name))])
    let of_json j =
      {
        document_name =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "document_name")));
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        parameters =
          (Util.option_map (Json.lookup j "parameters")
             AutomationParameterMap.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        mode = (Util.option_map (Json.lookup j "mode") ExecutionMode.of_json);
        target_parameter_name =
          (Util.option_map (Json.lookup j "target_parameter_name")
             String.of_json);
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        target_maps =
          (TargetMaps.of_json
             (Util.of_option_exn (Json.lookup j "target_maps")));
        max_concurrency =
          (Util.option_map (Json.lookup j "max_concurrency") String.of_json);
        max_errors =
          (Util.option_map (Json.lookup j "max_errors") String.of_json);
        target_locations =
          (TargetLocations.of_json
             (Util.of_option_exn (Json.lookup j "target_locations")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module UpdatePatchBaselineResult =
  struct
    type t =
      {
      baseline_id: String.t option ;
      name: String.t option ;
      operating_system: OperatingSystem.t option ;
      global_filters: PatchFilterGroup.t option ;
      approval_rules: PatchRuleGroup.t option ;
      approved_patches: PatchIdList.t ;
      approved_patches_compliance_level: PatchComplianceLevel.t option ;
      approved_patches_enable_non_security: Boolean.t option ;
      rejected_patches: PatchIdList.t ;
      rejected_patches_action: PatchAction.t option ;
      created_date: DateTime.t option ;
      modified_date: DateTime.t option ;
      description: String.t option ;
      sources: PatchSourceList.t }
    let make ?baseline_id  ?name  ?operating_system  ?global_filters 
      ?approval_rules  ?(approved_patches= []) 
      ?approved_patches_compliance_level 
      ?approved_patches_enable_non_security  ?(rejected_patches= []) 
      ?rejected_patches_action  ?created_date  ?modified_date  ?description 
      ?(sources= [])  () =
      {
        baseline_id;
        name;
        operating_system;
        global_filters;
        approval_rules;
        approved_patches;
        approved_patches_compliance_level;
        approved_patches_enable_non_security;
        rejected_patches;
        rejected_patches_action;
        created_date;
        modified_date;
        description;
        sources
      }
    let parse xml =
      Some
        {
          baseline_id =
            (Util.option_bind (Xml.member "BaselineId" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          operating_system =
            (Util.option_bind (Xml.member "OperatingSystem" xml)
               OperatingSystem.parse);
          global_filters =
            (Util.option_bind (Xml.member "GlobalFilters" xml)
               PatchFilterGroup.parse);
          approval_rules =
            (Util.option_bind (Xml.member "ApprovalRules" xml)
               PatchRuleGroup.parse);
          approved_patches =
            (Util.of_option []
               (Util.option_bind (Xml.member "ApprovedPatches" xml)
                  PatchIdList.parse));
          approved_patches_compliance_level =
            (Util.option_bind
               (Xml.member "ApprovedPatchesComplianceLevel" xml)
               PatchComplianceLevel.parse);
          approved_patches_enable_non_security =
            (Util.option_bind
               (Xml.member "ApprovedPatchesEnableNonSecurity" xml)
               Boolean.parse);
          rejected_patches =
            (Util.of_option []
               (Util.option_bind (Xml.member "RejectedPatches" xml)
                  PatchIdList.parse));
          rejected_patches_action =
            (Util.option_bind (Xml.member "RejectedPatchesAction" xml)
               PatchAction.parse);
          created_date =
            (Util.option_bind (Xml.member "CreatedDate" xml) DateTime.parse);
          modified_date =
            (Util.option_bind (Xml.member "ModifiedDate" xml) DateTime.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          sources =
            (Util.of_option []
               (Util.option_bind (Xml.member "Sources" xml)
                  PatchSourceList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        [Util.option_map v.baseline_id
                           (fun f ->
                              Ezxmlm.make_tag "BaselineId"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.name
                          (fun f ->
                             Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.operating_system
                         (fun f ->
                            Ezxmlm.make_tag "OperatingSystem"
                              ([], (OperatingSystem.to_xml f)))])
                     @
                     [Util.option_map v.global_filters
                        (fun f ->
                           Ezxmlm.make_tag "GlobalFilters"
                             ([], (PatchFilterGroup.to_xml f)))])
                    @
                    [Util.option_map v.approval_rules
                       (fun f ->
                          Ezxmlm.make_tag "ApprovalRules"
                            ([], (PatchRuleGroup.to_xml f)))])
                   @
                   (List.map
                      (fun x ->
                         Some
                           (Ezxmlm.make_tag "ApprovedPatches"
                              ([], (PatchIdList.to_xml [x]))))
                      v.approved_patches))
                  @
                  [Util.option_map v.approved_patches_compliance_level
                     (fun f ->
                        Ezxmlm.make_tag "ApprovedPatchesComplianceLevel"
                          ([], (PatchComplianceLevel.to_xml f)))])
                 @
                 [Util.option_map v.approved_patches_enable_non_security
                    (fun f ->
                       Ezxmlm.make_tag "ApprovedPatchesEnableNonSecurity"
                         ([], (Boolean.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "RejectedPatches"
                           ([], (PatchIdList.to_xml [x]))))
                   v.rejected_patches))
               @
               [Util.option_map v.rejected_patches_action
                  (fun f ->
                     Ezxmlm.make_tag "RejectedPatchesAction"
                       ([], (PatchAction.to_xml f)))])
              @
              [Util.option_map v.created_date
                 (fun f ->
                    Ezxmlm.make_tag "CreatedDate" ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.modified_date
                (fun f ->
                   Ezxmlm.make_tag "ModifiedDate" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.description
               (fun f ->
                  Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Sources"
                      ([], (PatchSourceList.to_xml [x])))) v.sources))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("sources", (PatchSourceList.to_json v.sources));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.modified_date
             (fun f -> ("modified_date", (DateTime.to_json f)));
           Util.option_map v.created_date
             (fun f -> ("created_date", (DateTime.to_json f)));
           Util.option_map v.rejected_patches_action
             (fun f -> ("rejected_patches_action", (PatchAction.to_json f)));
           Some
             ("rejected_patches", (PatchIdList.to_json v.rejected_patches));
           Util.option_map v.approved_patches_enable_non_security
             (fun f ->
                ("approved_patches_enable_non_security", (Boolean.to_json f)));
           Util.option_map v.approved_patches_compliance_level
             (fun f ->
                ("approved_patches_compliance_level",
                  (PatchComplianceLevel.to_json f)));
           Some
             ("approved_patches", (PatchIdList.to_json v.approved_patches));
           Util.option_map v.approval_rules
             (fun f -> ("approval_rules", (PatchRuleGroup.to_json f)));
           Util.option_map v.global_filters
             (fun f -> ("global_filters", (PatchFilterGroup.to_json f)));
           Util.option_map v.operating_system
             (fun f -> ("operating_system", (OperatingSystem.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.baseline_id
             (fun f -> ("baseline_id", (String.to_json f)))])
    let of_json j =
      {
        baseline_id =
          (Util.option_map (Json.lookup j "baseline_id") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        operating_system =
          (Util.option_map (Json.lookup j "operating_system")
             OperatingSystem.of_json);
        global_filters =
          (Util.option_map (Json.lookup j "global_filters")
             PatchFilterGroup.of_json);
        approval_rules =
          (Util.option_map (Json.lookup j "approval_rules")
             PatchRuleGroup.of_json);
        approved_patches =
          (PatchIdList.of_json
             (Util.of_option_exn (Json.lookup j "approved_patches")));
        approved_patches_compliance_level =
          (Util.option_map
             (Json.lookup j "approved_patches_compliance_level")
             PatchComplianceLevel.of_json);
        approved_patches_enable_non_security =
          (Util.option_map
             (Json.lookup j "approved_patches_enable_non_security")
             Boolean.of_json);
        rejected_patches =
          (PatchIdList.of_json
             (Util.of_option_exn (Json.lookup j "rejected_patches")));
        rejected_patches_action =
          (Util.option_map (Json.lookup j "rejected_patches_action")
             PatchAction.of_json);
        created_date =
          (Util.option_map (Json.lookup j "created_date") DateTime.of_json);
        modified_date =
          (Util.option_map (Json.lookup j "modified_date") DateTime.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        sources =
          (PatchSourceList.of_json
             (Util.of_option_exn (Json.lookup j "sources")))
      }
  end
module InvalidItemContentException =
  struct
    type t = {
      type_name: String.t option ;
      message: String.t option }
    let make ?type_name  ?message  () = { type_name; message }
    let parse xml =
      Some
        {
          type_name =
            (Util.option_bind (Xml.member "TypeName" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.type_name
               (fun f -> Ezxmlm.make_tag "TypeName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.type_name
             (fun f -> ("type_name", (String.to_json f)))])
    let of_json j =
      {
        type_name =
          (Util.option_map (Json.lookup j "type_name") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module SendAutomationSignalResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module DescribeAutomationStepExecutionsResult =
  struct
    type t =
      {
      step_executions: StepExecutionList.t ;
      next_token: String.t option }
    let make ?(step_executions= [])  ?next_token  () =
      { step_executions; next_token }
    let parse xml =
      Some
        {
          step_executions =
            (Util.of_option []
               (Util.option_bind (Xml.member "StepExecutions" xml)
                  StepExecutionList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "StepExecutions"
                       ([], (StepExecutionList.to_xml [x]))))
               v.step_executions))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("step_executions",
               (StepExecutionList.to_json v.step_executions))])
    let of_json j =
      {
        step_executions =
          (StepExecutionList.of_json
             (Util.of_option_exn (Json.lookup j "step_executions")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ListTagsForResourceRequest =
  struct
    type t =
      {
      resource_type: ResourceTypeForTagging.t ;
      resource_id: String.t }
    let make ~resource_type  ~resource_id  () =
      { resource_type; resource_id }
    let parse xml =
      Some
        {
          resource_type =
            (Xml.required "ResourceType"
               (Util.option_bind (Xml.member "ResourceType" xml)
                  ResourceTypeForTagging.parse));
          resource_id =
            (Xml.required "ResourceId"
               (Util.option_bind (Xml.member "ResourceId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "ResourceType"
                  ([], (ResourceTypeForTagging.to_xml v.resource_type)))])
           @
           [Some
              (Ezxmlm.make_tag "ResourceId"
                 ([], (String.to_xml v.resource_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("resource_id", (String.to_json v.resource_id));
           Some
             ("resource_type",
               (ResourceTypeForTagging.to_json v.resource_type))])
    let of_json j =
      {
        resource_type =
          (ResourceTypeForTagging.of_json
             (Util.of_option_exn (Json.lookup j "resource_type")));
        resource_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "resource_id")))
      }
  end
module OpsItemInvalidParameterException =
  struct
    type t =
      {
      parameter_names: OpsItemParameterNamesList.t ;
      message: String.t option }
    let make ?(parameter_names= [])  ?message  () =
      { parameter_names; message }
    let parse xml =
      Some
        {
          parameter_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "ParameterNames" xml)
                  OpsItemParameterNamesList.parse));
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ParameterNames"
                       ([], (OpsItemParameterNamesList.to_xml [x]))))
               v.parameter_names))
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Some
             ("parameter_names",
               (OpsItemParameterNamesList.to_json v.parameter_names))])
    let of_json j =
      {
        parameter_names =
          (OpsItemParameterNamesList.of_json
             (Util.of_option_exn (Json.lookup j "parameter_names")));
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ResourceInUseException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module GetOpsSummaryRequest =
  struct
    type t =
      {
      sync_name: String.t option ;
      filters: OpsFilterList.t ;
      aggregators: OpsAggregatorList.t ;
      result_attributes: OpsResultAttributeList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?sync_name  ?(filters= [])  ?(aggregators= []) 
      ?(result_attributes= [])  ?next_token  ?max_results  () =
      {
        sync_name;
        filters;
        aggregators;
        result_attributes;
        next_token;
        max_results
      }
    let parse xml =
      Some
        {
          sync_name =
            (Util.option_bind (Xml.member "SyncName" xml) String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  OpsFilterList.parse));
          aggregators =
            (Util.of_option []
               (Util.option_bind (Xml.member "Aggregators" xml)
                  OpsAggregatorList.parse));
          result_attributes =
            (Util.of_option []
               (Util.option_bind (Xml.member "ResultAttributes" xml)
                  OpsResultAttributeList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.sync_name
                   (fun f ->
                      Ezxmlm.make_tag "SyncName" ([], (String.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filters"
                          ([], (OpsFilterList.to_xml [x])))) v.filters))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Aggregators"
                         ([], (OpsAggregatorList.to_xml [x])))) v.aggregators))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "ResultAttributes"
                        ([], (OpsResultAttributeList.to_xml [x]))))
                v.result_attributes))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("result_attributes",
               (OpsResultAttributeList.to_json v.result_attributes));
           Some ("aggregators", (OpsAggregatorList.to_json v.aggregators));
           Some ("filters", (OpsFilterList.to_json v.filters));
           Util.option_map v.sync_name
             (fun f -> ("sync_name", (String.to_json f)))])
    let of_json j =
      {
        sync_name =
          (Util.option_map (Json.lookup j "sync_name") String.of_json);
        filters =
          (OpsFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        aggregators =
          (OpsAggregatorList.of_json
             (Util.of_option_exn (Json.lookup j "aggregators")));
        result_attributes =
          (OpsResultAttributeList.of_json
             (Util.of_option_exn (Json.lookup j "result_attributes")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module InvalidInventoryItemContextException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module GetMaintenanceWindowTaskResult =
  struct
    type t =
      {
      window_id: String.t option ;
      window_task_id: String.t option ;
      targets: Targets.t ;
      task_arn: String.t option ;
      service_role_arn: String.t option ;
      task_type: MaintenanceWindowTaskType.t option ;
      task_parameters: MaintenanceWindowTaskParameters.t option ;
      task_invocation_parameters:
        MaintenanceWindowTaskInvocationParameters.t option ;
      priority: Integer.t option ;
      max_concurrency: String.t option ;
      max_errors: String.t option ;
      logging_info: LoggingInfo.t option ;
      name: String.t option ;
      description: String.t option }
    let make ?window_id  ?window_task_id  ?(targets= [])  ?task_arn 
      ?service_role_arn  ?task_type  ?task_parameters 
      ?task_invocation_parameters  ?priority  ?max_concurrency  ?max_errors 
      ?logging_info  ?name  ?description  () =
      {
        window_id;
        window_task_id;
        targets;
        task_arn;
        service_role_arn;
        task_type;
        task_parameters;
        task_invocation_parameters;
        priority;
        max_concurrency;
        max_errors;
        logging_info;
        name;
        description
      }
    let parse xml =
      Some
        {
          window_id =
            (Util.option_bind (Xml.member "WindowId" xml) String.parse);
          window_task_id =
            (Util.option_bind (Xml.member "WindowTaskId" xml) String.parse);
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          task_arn =
            (Util.option_bind (Xml.member "TaskArn" xml) String.parse);
          service_role_arn =
            (Util.option_bind (Xml.member "ServiceRoleArn" xml) String.parse);
          task_type =
            (Util.option_bind (Xml.member "TaskType" xml)
               MaintenanceWindowTaskType.parse);
          task_parameters =
            (Util.option_bind (Xml.member "TaskParameters" xml)
               MaintenanceWindowTaskParameters.parse);
          task_invocation_parameters =
            (Util.option_bind (Xml.member "TaskInvocationParameters" xml)
               MaintenanceWindowTaskInvocationParameters.parse);
          priority =
            (Util.option_bind (Xml.member "Priority" xml) Integer.parse);
          max_concurrency =
            (Util.option_bind (Xml.member "MaxConcurrency" xml) String.parse);
          max_errors =
            (Util.option_bind (Xml.member "MaxErrors" xml) String.parse);
          logging_info =
            (Util.option_bind (Xml.member "LoggingInfo" xml)
               LoggingInfo.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        [Util.option_map v.window_id
                           (fun f ->
                              Ezxmlm.make_tag "WindowId"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.window_task_id
                          (fun f ->
                             Ezxmlm.make_tag "WindowTaskId"
                               ([], (String.to_xml f)))])
                      @
                      (List.map
                         (fun x ->
                            Some
                              (Ezxmlm.make_tag "Targets"
                                 ([], (Targets.to_xml [x])))) v.targets))
                     @
                     [Util.option_map v.task_arn
                        (fun f ->
                           Ezxmlm.make_tag "TaskArn" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.service_role_arn
                       (fun f ->
                          Ezxmlm.make_tag "ServiceRoleArn"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.task_type
                      (fun f ->
                         Ezxmlm.make_tag "TaskType"
                           ([], (MaintenanceWindowTaskType.to_xml f)))])
                  @
                  [Util.option_map v.task_parameters
                     (fun f ->
                        Ezxmlm.make_tag "TaskParameters"
                          ([], (MaintenanceWindowTaskParameters.to_xml f)))])
                 @
                 [Util.option_map v.task_invocation_parameters
                    (fun f ->
                       Ezxmlm.make_tag "TaskInvocationParameters"
                         ([],
                           (MaintenanceWindowTaskInvocationParameters.to_xml
                              f)))])
                @
                [Util.option_map v.priority
                   (fun f ->
                      Ezxmlm.make_tag "Priority" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.max_concurrency
                  (fun f ->
                     Ezxmlm.make_tag "MaxConcurrency" ([], (String.to_xml f)))])
              @
              [Util.option_map v.max_errors
                 (fun f ->
                    Ezxmlm.make_tag "MaxErrors" ([], (String.to_xml f)))])
             @
             [Util.option_map v.logging_info
                (fun f ->
                   Ezxmlm.make_tag "LoggingInfo" ([], (LoggingInfo.to_xml f)))])
            @
            [Util.option_map v.name
               (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
           @
           [Util.option_map v.description
              (fun f -> Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.logging_info
             (fun f -> ("logging_info", (LoggingInfo.to_json f)));
           Util.option_map v.max_errors
             (fun f -> ("max_errors", (String.to_json f)));
           Util.option_map v.max_concurrency
             (fun f -> ("max_concurrency", (String.to_json f)));
           Util.option_map v.priority
             (fun f -> ("priority", (Integer.to_json f)));
           Util.option_map v.task_invocation_parameters
             (fun f ->
                ("task_invocation_parameters",
                  (MaintenanceWindowTaskInvocationParameters.to_json f)));
           Util.option_map v.task_parameters
             (fun f ->
                ("task_parameters",
                  (MaintenanceWindowTaskParameters.to_json f)));
           Util.option_map v.task_type
             (fun f -> ("task_type", (MaintenanceWindowTaskType.to_json f)));
           Util.option_map v.service_role_arn
             (fun f -> ("service_role_arn", (String.to_json f)));
           Util.option_map v.task_arn
             (fun f -> ("task_arn", (String.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Util.option_map v.window_task_id
             (fun f -> ("window_task_id", (String.to_json f)));
           Util.option_map v.window_id
             (fun f -> ("window_id", (String.to_json f)))])
    let of_json j =
      {
        window_id =
          (Util.option_map (Json.lookup j "window_id") String.of_json);
        window_task_id =
          (Util.option_map (Json.lookup j "window_task_id") String.of_json);
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        task_arn =
          (Util.option_map (Json.lookup j "task_arn") String.of_json);
        service_role_arn =
          (Util.option_map (Json.lookup j "service_role_arn") String.of_json);
        task_type =
          (Util.option_map (Json.lookup j "task_type")
             MaintenanceWindowTaskType.of_json);
        task_parameters =
          (Util.option_map (Json.lookup j "task_parameters")
             MaintenanceWindowTaskParameters.of_json);
        task_invocation_parameters =
          (Util.option_map (Json.lookup j "task_invocation_parameters")
             MaintenanceWindowTaskInvocationParameters.of_json);
        priority =
          (Util.option_map (Json.lookup j "priority") Integer.of_json);
        max_concurrency =
          (Util.option_map (Json.lookup j "max_concurrency") String.of_json);
        max_errors =
          (Util.option_map (Json.lookup j "max_errors") String.of_json);
        logging_info =
          (Util.option_map (Json.lookup j "logging_info") LoggingInfo.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module ComplianceTypeCountLimitExceededException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeInstancePatchesResult =
  struct
    type t =
      {
      patches: PatchComplianceDataList.t ;
      next_token: String.t option }
    let make ?(patches= [])  ?next_token  () = { patches; next_token }
    let parse xml =
      Some
        {
          patches =
            (Util.of_option []
               (Util.option_bind (Xml.member "Patches" xml)
                  PatchComplianceDataList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Patches"
                       ([], (PatchComplianceDataList.to_xml [x])))) v.patches))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("patches", (PatchComplianceDataList.to_json v.patches))])
    let of_json j =
      {
        patches =
          (PatchComplianceDataList.of_json
             (Util.of_option_exn (Json.lookup j "patches")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetPatchBaselineForPatchGroupResult =
  struct
    type t =
      {
      baseline_id: String.t option ;
      patch_group: String.t option ;
      operating_system: OperatingSystem.t option }
    let make ?baseline_id  ?patch_group  ?operating_system  () =
      { baseline_id; patch_group; operating_system }
    let parse xml =
      Some
        {
          baseline_id =
            (Util.option_bind (Xml.member "BaselineId" xml) String.parse);
          patch_group =
            (Util.option_bind (Xml.member "PatchGroup" xml) String.parse);
          operating_system =
            (Util.option_bind (Xml.member "OperatingSystem" xml)
               OperatingSystem.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.baseline_id
                (fun f ->
                   Ezxmlm.make_tag "BaselineId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.patch_group
               (fun f -> Ezxmlm.make_tag "PatchGroup" ([], (String.to_xml f)))])
           @
           [Util.option_map v.operating_system
              (fun f ->
                 Ezxmlm.make_tag "OperatingSystem"
                   ([], (OperatingSystem.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.operating_system
              (fun f -> ("operating_system", (OperatingSystem.to_json f)));
           Util.option_map v.patch_group
             (fun f -> ("patch_group", (String.to_json f)));
           Util.option_map v.baseline_id
             (fun f -> ("baseline_id", (String.to_json f)))])
    let of_json j =
      {
        baseline_id =
          (Util.option_map (Json.lookup j "baseline_id") String.of_json);
        patch_group =
          (Util.option_map (Json.lookup j "patch_group") String.of_json);
        operating_system =
          (Util.option_map (Json.lookup j "operating_system")
             OperatingSystem.of_json)
      }
  end
module InvalidPluginName =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module DescribeAvailablePatchesResult =
  struct
    type t = {
      patches: PatchList.t ;
      next_token: String.t option }
    let make ?(patches= [])  ?next_token  () = { patches; next_token }
    let parse xml =
      Some
        {
          patches =
            (Util.of_option []
               (Util.option_bind (Xml.member "Patches" xml) PatchList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Patches" ([], (PatchList.to_xml [x]))))
               v.patches))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("patches", (PatchList.to_json v.patches))])
    let of_json j =
      {
        patches =
          (PatchList.of_json (Util.of_option_exn (Json.lookup j "patches")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module InvalidDocumentVersion =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ResourceLimitExceededException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module GetCalendarStateResponse =
  struct
    type t =
      {
      state: CalendarState.t option ;
      at_time: String.t option ;
      next_transition_time: String.t option }
    let make ?state  ?at_time  ?next_transition_time  () =
      { state; at_time; next_transition_time }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "State" xml) CalendarState.parse);
          at_time = (Util.option_bind (Xml.member "AtTime" xml) String.parse);
          next_transition_time =
            (Util.option_bind (Xml.member "NextTransitionTime" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.state
                (fun f ->
                   Ezxmlm.make_tag "State" ([], (CalendarState.to_xml f)))])
            @
            [Util.option_map v.at_time
               (fun f -> Ezxmlm.make_tag "AtTime" ([], (String.to_xml f)))])
           @
           [Util.option_map v.next_transition_time
              (fun f ->
                 Ezxmlm.make_tag "NextTransitionTime" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_transition_time
              (fun f -> ("next_transition_time", (String.to_json f)));
           Util.option_map v.at_time
             (fun f -> ("at_time", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (CalendarState.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state") CalendarState.of_json);
        at_time = (Util.option_map (Json.lookup j "at_time") String.of_json);
        next_transition_time =
          (Util.option_map (Json.lookup j "next_transition_time")
             String.of_json)
      }
  end
module DescribeMaintenanceWindowExecutionTasksRequest =
  struct
    type t =
      {
      window_execution_id: String.t ;
      filters: MaintenanceWindowFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ~window_execution_id  ?(filters= [])  ?max_results  ?next_token 
      () = { window_execution_id; filters; max_results; next_token }
    let parse xml =
      Some
        {
          window_execution_id =
            (Xml.required "WindowExecutionId"
               (Util.option_bind (Xml.member "WindowExecutionId" xml)
                  String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  MaintenanceWindowFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "WindowExecutionId"
                    ([], (String.to_xml v.window_execution_id)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (MaintenanceWindowFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (MaintenanceWindowFilterList.to_json v.filters));
           Some
             ("window_execution_id", (String.to_json v.window_execution_id))])
    let of_json j =
      {
        window_execution_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "window_execution_id")));
        filters =
          (MaintenanceWindowFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module AutomationDefinitionVersionNotFoundException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ParameterMaxVersionLimitExceeded =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module StartSessionResponse =
  struct
    type t =
      {
      session_id: String.t option ;
      token_value: String.t option ;
      stream_url: String.t option }
    let make ?session_id  ?token_value  ?stream_url  () =
      { session_id; token_value; stream_url }
    let parse xml =
      Some
        {
          session_id =
            (Util.option_bind (Xml.member "SessionId" xml) String.parse);
          token_value =
            (Util.option_bind (Xml.member "TokenValue" xml) String.parse);
          stream_url =
            (Util.option_bind (Xml.member "StreamUrl" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.session_id
                (fun f -> Ezxmlm.make_tag "SessionId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.token_value
               (fun f -> Ezxmlm.make_tag "TokenValue" ([], (String.to_xml f)))])
           @
           [Util.option_map v.stream_url
              (fun f -> Ezxmlm.make_tag "StreamUrl" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.stream_url
              (fun f -> ("stream_url", (String.to_json f)));
           Util.option_map v.token_value
             (fun f -> ("token_value", (String.to_json f)));
           Util.option_map v.session_id
             (fun f -> ("session_id", (String.to_json f)))])
    let of_json j =
      {
        session_id =
          (Util.option_map (Json.lookup j "session_id") String.of_json);
        token_value =
          (Util.option_map (Json.lookup j "token_value") String.of_json);
        stream_url =
          (Util.option_map (Json.lookup j "stream_url") String.of_json)
      }
  end
module GetMaintenanceWindowRequest =
  struct
    type t = {
      window_id: String.t }
    let make ~window_id  () = { window_id }
    let parse xml =
      Some
        {
          window_id =
            (Xml.required "WindowId"
               (Util.option_bind (Xml.member "WindowId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "WindowId" ([], (String.to_xml v.window_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("window_id", (String.to_json v.window_id))])
    let of_json j =
      {
        window_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "window_id")))
      }
  end
module AutomationExecutionLimitExceededException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module CancelMaintenanceWindowExecutionRequest =
  struct
    type t = {
      window_execution_id: String.t }
    let make ~window_execution_id  () = { window_execution_id }
    let parse xml =
      Some
        {
          window_execution_id =
            (Xml.required "WindowExecutionId"
               (Util.option_bind (Xml.member "WindowExecutionId" xml)
                  String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "WindowExecutionId"
                 ([], (String.to_xml v.window_execution_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("window_execution_id", (String.to_json v.window_execution_id))])
    let of_json j =
      {
        window_execution_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "window_execution_id")))
      }
  end
module DeletePatchBaselineResult =
  struct
    type t = {
      baseline_id: String.t option }
    let make ?baseline_id  () = { baseline_id }
    let parse xml =
      Some
        {
          baseline_id =
            (Util.option_bind (Xml.member "BaselineId" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.baseline_id
              (fun f -> Ezxmlm.make_tag "BaselineId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.baseline_id
              (fun f -> ("baseline_id", (String.to_json f)))])
    let of_json j =
      {
        baseline_id =
          (Util.option_map (Json.lookup j "baseline_id") String.of_json)
      }
  end
module UpdateOpsItemResponse =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module CreateOpsItemResponse =
  struct
    type t = {
      ops_item_id: String.t option }
    let make ?ops_item_id  () = { ops_item_id }
    let parse xml =
      Some
        {
          ops_item_id =
            (Util.option_bind (Xml.member "OpsItemId" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ops_item_id
              (fun f -> Ezxmlm.make_tag "OpsItemId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ops_item_id
              (fun f -> ("ops_item_id", (String.to_json f)))])
    let of_json j =
      {
        ops_item_id =
          (Util.option_map (Json.lookup j "ops_item_id") String.of_json)
      }
  end
module LabelParameterVersionResult =
  struct
    type t =
      {
      invalid_labels: ParameterLabelList.t ;
      parameter_version: Long.t option }
    let make ?(invalid_labels= [])  ?parameter_version  () =
      { invalid_labels; parameter_version }
    let parse xml =
      Some
        {
          invalid_labels =
            (Util.of_option []
               (Util.option_bind (Xml.member "InvalidLabels" xml)
                  ParameterLabelList.parse));
          parameter_version =
            (Util.option_bind (Xml.member "ParameterVersion" xml) Long.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "InvalidLabels"
                       ([], (ParameterLabelList.to_xml [x]))))
               v.invalid_labels))
           @
           [Util.option_map v.parameter_version
              (fun f ->
                 Ezxmlm.make_tag "ParameterVersion" ([], (Long.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.parameter_version
              (fun f -> ("parameter_version", (Long.to_json f)));
           Some
             ("invalid_labels",
               (ParameterLabelList.to_json v.invalid_labels))])
    let of_json j =
      {
        invalid_labels =
          (ParameterLabelList.of_json
             (Util.of_option_exn (Json.lookup j "invalid_labels")));
        parameter_version =
          (Util.option_map (Json.lookup j "parameter_version") Long.of_json)
      }
  end
module DeleteInventoryResult =
  struct
    type t =
      {
      deletion_id: String.t option ;
      type_name: String.t option ;
      deletion_summary: InventoryDeletionSummary.t option }
    let make ?deletion_id  ?type_name  ?deletion_summary  () =
      { deletion_id; type_name; deletion_summary }
    let parse xml =
      Some
        {
          deletion_id =
            (Util.option_bind (Xml.member "DeletionId" xml) String.parse);
          type_name =
            (Util.option_bind (Xml.member "TypeName" xml) String.parse);
          deletion_summary =
            (Util.option_bind (Xml.member "DeletionSummary" xml)
               InventoryDeletionSummary.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.deletion_id
                (fun f ->
                   Ezxmlm.make_tag "DeletionId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.type_name
               (fun f -> Ezxmlm.make_tag "TypeName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.deletion_summary
              (fun f ->
                 Ezxmlm.make_tag "DeletionSummary"
                   ([], (InventoryDeletionSummary.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.deletion_summary
              (fun f ->
                 ("deletion_summary", (InventoryDeletionSummary.to_json f)));
           Util.option_map v.type_name
             (fun f -> ("type_name", (String.to_json f)));
           Util.option_map v.deletion_id
             (fun f -> ("deletion_id", (String.to_json f)))])
    let of_json j =
      {
        deletion_id =
          (Util.option_map (Json.lookup j "deletion_id") String.of_json);
        type_name =
          (Util.option_map (Json.lookup j "type_name") String.of_json);
        deletion_summary =
          (Util.option_map (Json.lookup j "deletion_summary")
             InventoryDeletionSummary.of_json)
      }
  end
module ItemContentMismatchException =
  struct
    type t = {
      type_name: String.t option ;
      message: String.t option }
    let make ?type_name  ?message  () = { type_name; message }
    let parse xml =
      Some
        {
          type_name =
            (Util.option_bind (Xml.member "TypeName" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.type_name
               (fun f -> Ezxmlm.make_tag "TypeName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.type_name
             (fun f -> ("type_name", (String.to_json f)))])
    let of_json j =
      {
        type_name =
          (Util.option_map (Json.lookup j "type_name") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeAssociationRequest =
  struct
    type t =
      {
      name: String.t option ;
      instance_id: String.t option ;
      association_id: String.t option ;
      association_version: String.t option }
    let make ?name  ?instance_id  ?association_id  ?association_version  () =
      { name; instance_id; association_id; association_version }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          association_id =
            (Util.option_bind (Xml.member "AssociationId" xml) String.parse);
          association_version =
            (Util.option_bind (Xml.member "AssociationVersion" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.name
                 (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
             @
             [Util.option_map v.instance_id
                (fun f ->
                   Ezxmlm.make_tag "InstanceId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.association_id
               (fun f ->
                  Ezxmlm.make_tag "AssociationId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.association_version
              (fun f ->
                 Ezxmlm.make_tag "AssociationVersion" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_version
              (fun f -> ("association_version", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        association_version =
          (Util.option_map (Json.lookup j "association_version")
             String.of_json)
      }
  end
module PutParameterResult =
  struct
    type t = {
      version: Long.t option ;
      tier: ParameterTier.t option }
    let make ?version  ?tier  () = { version; tier }
    let parse xml =
      Some
        {
          version = (Util.option_bind (Xml.member "Version" xml) Long.parse);
          tier =
            (Util.option_bind (Xml.member "Tier" xml) ParameterTier.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.version
               (fun f -> Ezxmlm.make_tag "Version" ([], (Long.to_xml f)))])
           @
           [Util.option_map v.tier
              (fun f -> Ezxmlm.make_tag "Tier" ([], (ParameterTier.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.tier
              (fun f -> ("tier", (ParameterTier.to_json f)));
           Util.option_map v.version (fun f -> ("version", (Long.to_json f)))])
    let of_json j =
      {
        version = (Util.option_map (Json.lookup j "version") Long.of_json);
        tier = (Util.option_map (Json.lookup j "tier") ParameterTier.of_json)
      }
  end
module AutomationStepNotFoundException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ListDocumentsRequest =
  struct
    type t =
      {
      document_filter_list: DocumentFilterList.t ;
      filters: DocumentKeyValuesFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(document_filter_list= [])  ?(filters= [])  ?max_results 
      ?next_token  () =
      { document_filter_list; filters; max_results; next_token }
    let parse xml =
      Some
        {
          document_filter_list =
            (Util.of_option []
               (Util.option_bind (Xml.member "DocumentFilterList" xml)
                  DocumentFilterList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  DocumentKeyValuesFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "DocumentFilterList"
                         ([], (DocumentFilterList.to_xml [x]))))
                 v.document_filter_list))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (DocumentKeyValuesFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (DocumentKeyValuesFilterList.to_json v.filters));
           Some
             ("document_filter_list",
               (DocumentFilterList.to_json v.document_filter_list))])
    let of_json j =
      {
        document_filter_list =
          (DocumentFilterList.of_json
             (Util.of_option_exn (Json.lookup j "document_filter_list")));
        filters =
          (DocumentKeyValuesFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ListAssociationVersionsResult =
  struct
    type t =
      {
      association_versions: AssociationVersionList.t ;
      next_token: String.t option }
    let make ?(association_versions= [])  ?next_token  () =
      { association_versions; next_token }
    let parse xml =
      Some
        {
          association_versions =
            (Util.of_option []
               (Util.option_bind (Xml.member "AssociationVersions" xml)
                  AssociationVersionList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "AssociationVersions"
                       ([], (AssociationVersionList.to_xml [x]))))
               v.association_versions))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("association_versions",
               (AssociationVersionList.to_json v.association_versions))])
    let of_json j =
      {
        association_versions =
          (AssociationVersionList.of_json
             (Util.of_option_exn (Json.lookup j "association_versions")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module InvalidFilterKey =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module UnsupportedParameterType =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ListDocumentVersionsRequest =
  struct
    type t =
      {
      name: String.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ~name  ?max_results  ?next_token  () =
      { name; max_results; next_token }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module RegisterTargetWithMaintenanceWindowResult =
  struct
    type t = {
      window_target_id: String.t option }
    let make ?window_target_id  () = { window_target_id }
    let parse xml =
      Some
        {
          window_target_id =
            (Util.option_bind (Xml.member "WindowTargetId" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.window_target_id
              (fun f ->
                 Ezxmlm.make_tag "WindowTargetId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.window_target_id
              (fun f -> ("window_target_id", (String.to_json f)))])
    let of_json j =
      {
        window_target_id =
          (Util.option_map (Json.lookup j "window_target_id") String.of_json)
      }
  end
module UpdateMaintenanceWindowRequest =
  struct
    type t =
      {
      window_id: String.t ;
      name: String.t option ;
      description: String.t option ;
      start_date: String.t option ;
      end_date: String.t option ;
      schedule: String.t option ;
      schedule_timezone: String.t option ;
      duration: Integer.t option ;
      cutoff: Integer.t option ;
      allow_unassociated_targets: Boolean.t option ;
      enabled: Boolean.t option ;
      replace: Boolean.t option }
    let make ~window_id  ?name  ?description  ?start_date  ?end_date 
      ?schedule  ?schedule_timezone  ?duration  ?cutoff 
      ?allow_unassociated_targets  ?enabled  ?replace  () =
      {
        window_id;
        name;
        description;
        start_date;
        end_date;
        schedule;
        schedule_timezone;
        duration;
        cutoff;
        allow_unassociated_targets;
        enabled;
        replace
      }
    let parse xml =
      Some
        {
          window_id =
            (Xml.required "WindowId"
               (Util.option_bind (Xml.member "WindowId" xml) String.parse));
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          start_date =
            (Util.option_bind (Xml.member "StartDate" xml) String.parse);
          end_date =
            (Util.option_bind (Xml.member "EndDate" xml) String.parse);
          schedule =
            (Util.option_bind (Xml.member "Schedule" xml) String.parse);
          schedule_timezone =
            (Util.option_bind (Xml.member "ScheduleTimezone" xml)
               String.parse);
          duration =
            (Util.option_bind (Xml.member "Duration" xml) Integer.parse);
          cutoff = (Util.option_bind (Xml.member "Cutoff" xml) Integer.parse);
          allow_unassociated_targets =
            (Util.option_bind (Xml.member "AllowUnassociatedTargets" xml)
               Boolean.parse);
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse);
          replace =
            (Util.option_bind (Xml.member "Replace" xml) Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((([] @
                      [Some
                         (Ezxmlm.make_tag "WindowId"
                            ([], (String.to_xml v.window_id)))])
                     @
                     [Util.option_map v.name
                        (fun f ->
                           Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.description
                       (fun f ->
                          Ezxmlm.make_tag "Description"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.start_date
                      (fun f ->
                         Ezxmlm.make_tag "StartDate" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.end_date
                     (fun f ->
                        Ezxmlm.make_tag "EndDate" ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.schedule
                    (fun f ->
                       Ezxmlm.make_tag "Schedule" ([], (String.to_xml f)))])
                @
                [Util.option_map v.schedule_timezone
                   (fun f ->
                      Ezxmlm.make_tag "ScheduleTimezone"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.duration
                  (fun f ->
                     Ezxmlm.make_tag "Duration" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.cutoff
                 (fun f -> Ezxmlm.make_tag "Cutoff" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.allow_unassociated_targets
                (fun f ->
                   Ezxmlm.make_tag "AllowUnassociatedTargets"
                     ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.enabled
               (fun f -> Ezxmlm.make_tag "Enabled" ([], (Boolean.to_xml f)))])
           @
           [Util.option_map v.replace
              (fun f -> Ezxmlm.make_tag "Replace" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.replace
              (fun f -> ("replace", (Boolean.to_json f)));
           Util.option_map v.enabled
             (fun f -> ("enabled", (Boolean.to_json f)));
           Util.option_map v.allow_unassociated_targets
             (fun f -> ("allow_unassociated_targets", (Boolean.to_json f)));
           Util.option_map v.cutoff
             (fun f -> ("cutoff", (Integer.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Integer.to_json f)));
           Util.option_map v.schedule_timezone
             (fun f -> ("schedule_timezone", (String.to_json f)));
           Util.option_map v.schedule
             (fun f -> ("schedule", (String.to_json f)));
           Util.option_map v.end_date
             (fun f -> ("end_date", (String.to_json f)));
           Util.option_map v.start_date
             (fun f -> ("start_date", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Some ("window_id", (String.to_json v.window_id))])
    let of_json j =
      {
        window_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "window_id")));
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        start_date =
          (Util.option_map (Json.lookup j "start_date") String.of_json);
        end_date =
          (Util.option_map (Json.lookup j "end_date") String.of_json);
        schedule =
          (Util.option_map (Json.lookup j "schedule") String.of_json);
        schedule_timezone =
          (Util.option_map (Json.lookup j "schedule_timezone") String.of_json);
        duration =
          (Util.option_map (Json.lookup j "duration") Integer.of_json);
        cutoff = (Util.option_map (Json.lookup j "cutoff") Integer.of_json);
        allow_unassociated_targets =
          (Util.option_map (Json.lookup j "allow_unassociated_targets")
             Boolean.of_json);
        enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json);
        replace = (Util.option_map (Json.lookup j "replace") Boolean.of_json)
      }
  end
module CreatePatchBaselineResult =
  struct
    type t = {
      baseline_id: String.t option }
    let make ?baseline_id  () = { baseline_id }
    let parse xml =
      Some
        {
          baseline_id =
            (Util.option_bind (Xml.member "BaselineId" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.baseline_id
              (fun f -> Ezxmlm.make_tag "BaselineId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.baseline_id
              (fun f -> ("baseline_id", (String.to_json f)))])
    let of_json j =
      {
        baseline_id =
          (Util.option_map (Json.lookup j "baseline_id") String.of_json)
      }
  end
module ListComplianceSummariesResult =
  struct
    type t =
      {
      compliance_summary_items: ComplianceSummaryItemList.t ;
      next_token: String.t option }
    let make ?(compliance_summary_items= [])  ?next_token  () =
      { compliance_summary_items; next_token }
    let parse xml =
      Some
        {
          compliance_summary_items =
            (Util.of_option []
               (Util.option_bind (Xml.member "ComplianceSummaryItems" xml)
                  ComplianceSummaryItemList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ComplianceSummaryItems"
                       ([], (ComplianceSummaryItemList.to_xml [x]))))
               v.compliance_summary_items))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("compliance_summary_items",
               (ComplianceSummaryItemList.to_json v.compliance_summary_items))])
    let of_json j =
      {
        compliance_summary_items =
          (ComplianceSummaryItemList.of_json
             (Util.of_option_exn (Json.lookup j "compliance_summary_items")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetCalendarStateRequest =
  struct
    type t =
      {
      calendar_names: CalendarNameOrARNList.t ;
      at_time: String.t option }
    let make ~calendar_names  ?at_time  () = { calendar_names; at_time }
    let parse xml =
      Some
        {
          calendar_names =
            (Xml.required "CalendarNames"
               (Util.option_bind (Xml.member "CalendarNames" xml)
                  CalendarNameOrARNList.parse));
          at_time = (Util.option_bind (Xml.member "AtTime" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "CalendarNames"
                       ([], (CalendarNameOrARNList.to_xml [x]))))
               v.calendar_names))
           @
           [Util.option_map v.at_time
              (fun f -> Ezxmlm.make_tag "AtTime" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.at_time
              (fun f -> ("at_time", (String.to_json f)));
           Some
             ("calendar_names",
               (CalendarNameOrARNList.to_json v.calendar_names))])
    let of_json j =
      {
        calendar_names =
          (CalendarNameOrARNList.of_json
             (Util.of_option_exn (Json.lookup j "calendar_names")));
        at_time = (Util.option_map (Json.lookup j "at_time") String.of_json)
      }
  end
module DescribeMaintenanceWindowExecutionTaskInvocationsRequest =
  struct
    type t =
      {
      window_execution_id: String.t ;
      task_id: String.t ;
      filters: MaintenanceWindowFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ~window_execution_id  ~task_id  ?(filters= [])  ?max_results 
      ?next_token  () =
      { window_execution_id; task_id; filters; max_results; next_token }
    let parse xml =
      Some
        {
          window_execution_id =
            (Xml.required "WindowExecutionId"
               (Util.option_bind (Xml.member "WindowExecutionId" xml)
                  String.parse));
          task_id =
            (Xml.required "TaskId"
               (Util.option_bind (Xml.member "TaskId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  MaintenanceWindowFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some
                  (Ezxmlm.make_tag "WindowExecutionId"
                     ([], (String.to_xml v.window_execution_id)))])
              @
              [Some
                 (Ezxmlm.make_tag "TaskId" ([], (String.to_xml v.task_id)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (MaintenanceWindowFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (MaintenanceWindowFilterList.to_json v.filters));
           Some ("task_id", (String.to_json v.task_id));
           Some
             ("window_execution_id", (String.to_json v.window_execution_id))])
    let of_json j =
      {
        window_execution_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "window_execution_id")));
        task_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "task_id")));
        filters =
          (MaintenanceWindowFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ParameterVersionNotFound =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module GetDefaultPatchBaselineRequest =
  struct
    type t = {
      operating_system: OperatingSystem.t option }
    let make ?operating_system  () = { operating_system }
    let parse xml =
      Some
        {
          operating_system =
            (Util.option_bind (Xml.member "OperatingSystem" xml)
               OperatingSystem.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.operating_system
              (fun f ->
                 Ezxmlm.make_tag "OperatingSystem"
                   ([], (OperatingSystem.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.operating_system
              (fun f -> ("operating_system", (OperatingSystem.to_json f)))])
    let of_json j =
      {
        operating_system =
          (Util.option_map (Json.lookup j "operating_system")
             OperatingSystem.of_json)
      }
  end
module StartSessionRequest =
  struct
    type t =
      {
      target: String.t ;
      document_name: String.t option ;
      parameters: SessionManagerParameters.t option }
    let make ~target  ?document_name  ?parameters  () =
      { target; document_name; parameters }
    let parse xml =
      Some
        {
          target =
            (Xml.required "Target"
               (Util.option_bind (Xml.member "Target" xml) String.parse));
          document_name =
            (Util.option_bind (Xml.member "DocumentName" xml) String.parse);
          parameters =
            (Util.option_bind (Xml.member "Parameters" xml)
               SessionManagerParameters.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some (Ezxmlm.make_tag "Target" ([], (String.to_xml v.target)))])
            @
            [Util.option_map v.document_name
               (fun f ->
                  Ezxmlm.make_tag "DocumentName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.parameters
              (fun f ->
                 Ezxmlm.make_tag "Parameters"
                   ([], (SessionManagerParameters.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.parameters
              (fun f -> ("parameters", (SessionManagerParameters.to_json f)));
           Util.option_map v.document_name
             (fun f -> ("document_name", (String.to_json f)));
           Some ("target", (String.to_json v.target))])
    let of_json j =
      {
        target =
          (String.of_json (Util.of_option_exn (Json.lookup j "target")));
        document_name =
          (Util.option_map (Json.lookup j "document_name") String.of_json);
        parameters =
          (Util.option_map (Json.lookup j "parameters")
             SessionManagerParameters.of_json)
      }
  end
module DescribeEffectivePatchesForPatchBaselineResult =
  struct
    type t =
      {
      effective_patches: EffectivePatchList.t ;
      next_token: String.t option }
    let make ?(effective_patches= [])  ?next_token  () =
      { effective_patches; next_token }
    let parse xml =
      Some
        {
          effective_patches =
            (Util.of_option []
               (Util.option_bind (Xml.member "EffectivePatches" xml)
                  EffectivePatchList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "EffectivePatches"
                       ([], (EffectivePatchList.to_xml [x]))))
               v.effective_patches))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("effective_patches",
               (EffectivePatchList.to_json v.effective_patches))])
    let of_json j =
      {
        effective_patches =
          (EffectivePatchList.of_json
             (Util.of_option_exn (Json.lookup j "effective_patches")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module InvalidUpdate =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module GetPatchBaselineForPatchGroupRequest =
  struct
    type t =
      {
      patch_group: String.t ;
      operating_system: OperatingSystem.t option }
    let make ~patch_group  ?operating_system  () =
      { patch_group; operating_system }
    let parse xml =
      Some
        {
          patch_group =
            (Xml.required "PatchGroup"
               (Util.option_bind (Xml.member "PatchGroup" xml) String.parse));
          operating_system =
            (Util.option_bind (Xml.member "OperatingSystem" xml)
               OperatingSystem.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "PatchGroup"
                  ([], (String.to_xml v.patch_group)))])
           @
           [Util.option_map v.operating_system
              (fun f ->
                 Ezxmlm.make_tag "OperatingSystem"
                   ([], (OperatingSystem.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.operating_system
              (fun f -> ("operating_system", (OperatingSystem.to_json f)));
           Some ("patch_group", (String.to_json v.patch_group))])
    let of_json j =
      {
        patch_group =
          (String.of_json (Util.of_option_exn (Json.lookup j "patch_group")));
        operating_system =
          (Util.option_map (Json.lookup j "operating_system")
             OperatingSystem.of_json)
      }
  end
module CreateAssociationBatchResult =
  struct
    type t =
      {
      successful: AssociationDescriptionList.t ;
      failed: FailedCreateAssociationList.t }
    let make ?(successful= [])  ?(failed= [])  () = { successful; failed }
    let parse xml =
      Some
        {
          successful =
            (Util.of_option []
               (Util.option_bind (Xml.member "Successful" xml)
                  AssociationDescriptionList.parse));
          failed =
            (Util.of_option []
               (Util.option_bind (Xml.member "Failed" xml)
                  FailedCreateAssociationList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Successful"
                       ([], (AssociationDescriptionList.to_xml [x]))))
               v.successful))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Failed"
                      ([], (FailedCreateAssociationList.to_xml [x]))))
              v.failed))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("failed", (FailedCreateAssociationList.to_json v.failed));
           Some
             ("successful",
               (AssociationDescriptionList.to_json v.successful))])
    let of_json j =
      {
        successful =
          (AssociationDescriptionList.of_json
             (Util.of_option_exn (Json.lookup j "successful")));
        failed =
          (FailedCreateAssociationList.of_json
             (Util.of_option_exn (Json.lookup j "failed")))
      }
  end
module InvalidRole =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module InvocationDoesNotExist =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module GetDeployablePatchSnapshotForInstanceResult =
  struct
    type t =
      {
      instance_id: String.t option ;
      snapshot_id: String.t option ;
      snapshot_download_url: String.t option ;
      product: String.t option }
    let make ?instance_id  ?snapshot_id  ?snapshot_download_url  ?product  ()
      = { instance_id; snapshot_id; snapshot_download_url; product }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "SnapshotId" xml) String.parse);
          snapshot_download_url =
            (Util.option_bind (Xml.member "SnapshotDownloadUrl" xml)
               String.parse);
          product =
            (Util.option_bind (Xml.member "Product" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Util.option_map v.instance_id
                 (fun f ->
                    Ezxmlm.make_tag "InstanceId" ([], (String.to_xml f)))])
             @
             [Util.option_map v.snapshot_id
                (fun f ->
                   Ezxmlm.make_tag "SnapshotId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.snapshot_download_url
               (fun f ->
                  Ezxmlm.make_tag "SnapshotDownloadUrl"
                    ([], (String.to_xml f)))])
           @
           [Util.option_map v.product
              (fun f -> Ezxmlm.make_tag "Product" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.product
              (fun f -> ("product", (String.to_json f)));
           Util.option_map v.snapshot_download_url
             (fun f -> ("snapshot_download_url", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        snapshot_download_url =
          (Util.option_map (Json.lookup j "snapshot_download_url")
             String.of_json);
        product = (Util.option_map (Json.lookup j "product") String.of_json)
      }
  end
module GetParameterRequest =
  struct
    type t = {
      name: String.t ;
      with_decryption: Boolean.t option }
    let make ~name  ?with_decryption  () = { name; with_decryption }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          with_decryption =
            (Util.option_bind (Xml.member "WithDecryption" xml) Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
           @
           [Util.option_map v.with_decryption
              (fun f ->
                 Ezxmlm.make_tag "WithDecryption" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.with_decryption
              (fun f -> ("with_decryption", (Boolean.to_json f)));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        with_decryption =
          (Util.option_map (Json.lookup j "with_decryption") Boolean.of_json)
      }
  end
module PutComplianceItemsRequest =
  struct
    type t =
      {
      resource_id: String.t ;
      resource_type: String.t ;
      compliance_type: String.t ;
      execution_summary: ComplianceExecutionSummary.t ;
      items: ComplianceItemEntryList.t ;
      item_content_hash: String.t option }
    let make ~resource_id  ~resource_type  ~compliance_type 
      ~execution_summary  ~items  ?item_content_hash  () =
      {
        resource_id;
        resource_type;
        compliance_type;
        execution_summary;
        items;
        item_content_hash
      }
    let parse xml =
      Some
        {
          resource_id =
            (Xml.required "ResourceId"
               (Util.option_bind (Xml.member "ResourceId" xml) String.parse));
          resource_type =
            (Xml.required "ResourceType"
               (Util.option_bind (Xml.member "ResourceType" xml) String.parse));
          compliance_type =
            (Xml.required "ComplianceType"
               (Util.option_bind (Xml.member "ComplianceType" xml)
                  String.parse));
          execution_summary =
            (Xml.required "ExecutionSummary"
               (Util.option_bind (Xml.member "ExecutionSummary" xml)
                  ComplianceExecutionSummary.parse));
          items =
            (Xml.required "Items"
               (Util.option_bind (Xml.member "Items" xml)
                  ComplianceItemEntryList.parse));
          item_content_hash =
            (Util.option_bind (Xml.member "ItemContentHash" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Some
                   (Ezxmlm.make_tag "ResourceId"
                      ([], (String.to_xml v.resource_id)))])
               @
               [Some
                  (Ezxmlm.make_tag "ResourceType"
                     ([], (String.to_xml v.resource_type)))])
              @
              [Some
                 (Ezxmlm.make_tag "ComplianceType"
                    ([], (String.to_xml v.compliance_type)))])
             @
             [Some
                (Ezxmlm.make_tag "ExecutionSummary"
                   ([],
                     (ComplianceExecutionSummary.to_xml v.execution_summary)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Items"
                       ([], (ComplianceItemEntryList.to_xml [x])))) v.items))
           @
           [Util.option_map v.item_content_hash
              (fun f ->
                 Ezxmlm.make_tag "ItemContentHash" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.item_content_hash
              (fun f -> ("item_content_hash", (String.to_json f)));
           Some ("items", (ComplianceItemEntryList.to_json v.items));
           Some
             ("execution_summary",
               (ComplianceExecutionSummary.to_json v.execution_summary));
           Some ("compliance_type", (String.to_json v.compliance_type));
           Some ("resource_type", (String.to_json v.resource_type));
           Some ("resource_id", (String.to_json v.resource_id))])
    let of_json j =
      {
        resource_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "resource_id")));
        resource_type =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "resource_type")));
        compliance_type =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "compliance_type")));
        execution_summary =
          (ComplianceExecutionSummary.of_json
             (Util.of_option_exn (Json.lookup j "execution_summary")));
        items =
          (ComplianceItemEntryList.of_json
             (Util.of_option_exn (Json.lookup j "items")));
        item_content_hash =
          (Util.option_map (Json.lookup j "item_content_hash") String.of_json)
      }
  end
module GetMaintenanceWindowExecutionTaskResult =
  struct
    type t =
      {
      window_execution_id: String.t option ;
      task_execution_id: String.t option ;
      task_arn: String.t option ;
      service_role: String.t option ;
      type_: MaintenanceWindowTaskType.t option ;
      task_parameters: MaintenanceWindowTaskParametersList.t ;
      priority: Integer.t option ;
      max_concurrency: String.t option ;
      max_errors: String.t option ;
      status: MaintenanceWindowExecutionStatus.t option ;
      status_details: String.t option ;
      start_time: DateTime.t option ;
      end_time: DateTime.t option }
    let make ?window_execution_id  ?task_execution_id  ?task_arn 
      ?service_role  ?type_  ?(task_parameters= [])  ?priority 
      ?max_concurrency  ?max_errors  ?status  ?status_details  ?start_time 
      ?end_time  () =
      {
        window_execution_id;
        task_execution_id;
        task_arn;
        service_role;
        type_;
        task_parameters;
        priority;
        max_concurrency;
        max_errors;
        status;
        status_details;
        start_time;
        end_time
      }
    let parse xml =
      Some
        {
          window_execution_id =
            (Util.option_bind (Xml.member "WindowExecutionId" xml)
               String.parse);
          task_execution_id =
            (Util.option_bind (Xml.member "TaskExecutionId" xml) String.parse);
          task_arn =
            (Util.option_bind (Xml.member "TaskArn" xml) String.parse);
          service_role =
            (Util.option_bind (Xml.member "ServiceRole" xml) String.parse);
          type_ =
            (Util.option_bind (Xml.member "Type" xml)
               MaintenanceWindowTaskType.parse);
          task_parameters =
            (Util.of_option []
               (Util.option_bind (Xml.member "TaskParameters" xml)
                  MaintenanceWindowTaskParametersList.parse));
          priority =
            (Util.option_bind (Xml.member "Priority" xml) Integer.parse);
          max_concurrency =
            (Util.option_bind (Xml.member "MaxConcurrency" xml) String.parse);
          max_errors =
            (Util.option_bind (Xml.member "MaxErrors" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml)
               MaintenanceWindowExecutionStatus.parse);
          status_details =
            (Util.option_bind (Xml.member "StatusDetails" xml) String.parse);
          start_time =
            (Util.option_bind (Xml.member "StartTime" xml) DateTime.parse);
          end_time =
            (Util.option_bind (Xml.member "EndTime" xml) DateTime.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Util.option_map v.window_execution_id
                          (fun f ->
                             Ezxmlm.make_tag "WindowExecutionId"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.task_execution_id
                         (fun f ->
                            Ezxmlm.make_tag "TaskExecutionId"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.task_arn
                        (fun f ->
                           Ezxmlm.make_tag "TaskArn" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.service_role
                       (fun f ->
                          Ezxmlm.make_tag "ServiceRole"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.type_
                      (fun f ->
                         Ezxmlm.make_tag "Type"
                           ([], (MaintenanceWindowTaskType.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "TaskParameters"
                             ([],
                               (MaintenanceWindowTaskParametersList.to_xml
                                  [x])))) v.task_parameters))
                 @
                 [Util.option_map v.priority
                    (fun f ->
                       Ezxmlm.make_tag "Priority" ([], (Integer.to_xml f)))])
                @
                [Util.option_map v.max_concurrency
                   (fun f ->
                      Ezxmlm.make_tag "MaxConcurrency"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.max_errors
                  (fun f ->
                     Ezxmlm.make_tag "MaxErrors" ([], (String.to_xml f)))])
              @
              [Util.option_map v.status
                 (fun f ->
                    Ezxmlm.make_tag "Status"
                      ([], (MaintenanceWindowExecutionStatus.to_xml f)))])
             @
             [Util.option_map v.status_details
                (fun f ->
                   Ezxmlm.make_tag "StatusDetails" ([], (String.to_xml f)))])
            @
            [Util.option_map v.start_time
               (fun f ->
                  Ezxmlm.make_tag "StartTime" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.end_time
              (fun f -> Ezxmlm.make_tag "EndTime" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.end_time
              (fun f -> ("end_time", (DateTime.to_json f)));
           Util.option_map v.start_time
             (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.status_details
             (fun f -> ("status_details", (String.to_json f)));
           Util.option_map v.status
             (fun f ->
                ("status", (MaintenanceWindowExecutionStatus.to_json f)));
           Util.option_map v.max_errors
             (fun f -> ("max_errors", (String.to_json f)));
           Util.option_map v.max_concurrency
             (fun f -> ("max_concurrency", (String.to_json f)));
           Util.option_map v.priority
             (fun f -> ("priority", (Integer.to_json f)));
           Some
             ("task_parameters",
               (MaintenanceWindowTaskParametersList.to_json v.task_parameters));
           Util.option_map v.type_
             (fun f -> ("type_", (MaintenanceWindowTaskType.to_json f)));
           Util.option_map v.service_role
             (fun f -> ("service_role", (String.to_json f)));
           Util.option_map v.task_arn
             (fun f -> ("task_arn", (String.to_json f)));
           Util.option_map v.task_execution_id
             (fun f -> ("task_execution_id", (String.to_json f)));
           Util.option_map v.window_execution_id
             (fun f -> ("window_execution_id", (String.to_json f)))])
    let of_json j =
      {
        window_execution_id =
          (Util.option_map (Json.lookup j "window_execution_id")
             String.of_json);
        task_execution_id =
          (Util.option_map (Json.lookup j "task_execution_id") String.of_json);
        task_arn =
          (Util.option_map (Json.lookup j "task_arn") String.of_json);
        service_role =
          (Util.option_map (Json.lookup j "service_role") String.of_json);
        type_ =
          (Util.option_map (Json.lookup j "type_")
             MaintenanceWindowTaskType.of_json);
        task_parameters =
          (MaintenanceWindowTaskParametersList.of_json
             (Util.of_option_exn (Json.lookup j "task_parameters")));
        priority =
          (Util.option_map (Json.lookup j "priority") Integer.of_json);
        max_concurrency =
          (Util.option_map (Json.lookup j "max_concurrency") String.of_json);
        max_errors =
          (Util.option_map (Json.lookup j "max_errors") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             MaintenanceWindowExecutionStatus.of_json);
        status_details =
          (Util.option_map (Json.lookup j "status_details") String.of_json);
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json);
        end_time =
          (Util.option_map (Json.lookup j "end_time") DateTime.of_json)
      }
  end
module GetMaintenanceWindowTaskRequest =
  struct
    type t = {
      window_id: String.t ;
      window_task_id: String.t }
    let make ~window_id  ~window_task_id  () = { window_id; window_task_id }
    let parse xml =
      Some
        {
          window_id =
            (Xml.required "WindowId"
               (Util.option_bind (Xml.member "WindowId" xml) String.parse));
          window_task_id =
            (Xml.required "WindowTaskId"
               (Util.option_bind (Xml.member "WindowTaskId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "WindowId" ([], (String.to_xml v.window_id)))])
           @
           [Some
              (Ezxmlm.make_tag "WindowTaskId"
                 ([], (String.to_xml v.window_task_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("window_task_id", (String.to_json v.window_task_id));
           Some ("window_id", (String.to_json v.window_id))])
    let of_json j =
      {
        window_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "window_id")));
        window_task_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "window_task_id")))
      }
  end
module GetOpsItemResponse =
  struct
    type t = {
      ops_item: OpsItem.t option }
    let make ?ops_item  () = { ops_item }
    let parse xml =
      Some
        {
          ops_item =
            (Util.option_bind (Xml.member "OpsItem" xml) OpsItem.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.ops_item
              (fun f -> Ezxmlm.make_tag "OpsItem" ([], (OpsItem.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ops_item
              (fun f -> ("ops_item", (OpsItem.to_json f)))])
    let of_json j =
      {
        ops_item =
          (Util.option_map (Json.lookup j "ops_item") OpsItem.of_json)
      }
  end
module DescribeMaintenanceWindowTasksRequest =
  struct
    type t =
      {
      window_id: String.t ;
      filters: MaintenanceWindowFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ~window_id  ?(filters= [])  ?max_results  ?next_token  () =
      { window_id; filters; max_results; next_token }
    let parse xml =
      Some
        {
          window_id =
            (Xml.required "WindowId"
               (Util.option_bind (Xml.member "WindowId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  MaintenanceWindowFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "WindowId"
                    ([], (String.to_xml v.window_id)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (MaintenanceWindowFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (MaintenanceWindowFilterList.to_json v.filters));
           Some ("window_id", (String.to_json v.window_id))])
    let of_json j =
      {
        window_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "window_id")));
        filters =
          (MaintenanceWindowFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DocumentLimitExceeded =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module InvalidFilter =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module GetDocumentRequest =
  struct
    type t =
      {
      name: String.t ;
      version_name: String.t option ;
      document_version: String.t option ;
      document_format: DocumentFormat.t option }
    let make ~name  ?version_name  ?document_version  ?document_format  () =
      { name; version_name; document_version; document_format }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          version_name =
            (Util.option_bind (Xml.member "VersionName" xml) String.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          document_format =
            (Util.option_bind (Xml.member "DocumentFormat" xml)
               DocumentFormat.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
             @
             [Util.option_map v.version_name
                (fun f ->
                   Ezxmlm.make_tag "VersionName" ([], (String.to_xml f)))])
            @
            [Util.option_map v.document_version
               (fun f ->
                  Ezxmlm.make_tag "DocumentVersion" ([], (String.to_xml f)))])
           @
           [Util.option_map v.document_format
              (fun f ->
                 Ezxmlm.make_tag "DocumentFormat"
                   ([], (DocumentFormat.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.document_format
              (fun f -> ("document_format", (DocumentFormat.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.version_name
             (fun f -> ("version_name", (String.to_json f)));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        version_name =
          (Util.option_map (Json.lookup j "version_name") String.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        document_format =
          (Util.option_map (Json.lookup j "document_format")
             DocumentFormat.of_json)
      }
  end
module ParameterNotFound =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeInventoryDeletionsResult =
  struct
    type t =
      {
      inventory_deletions: InventoryDeletionsList.t ;
      next_token: String.t option }
    let make ?(inventory_deletions= [])  ?next_token  () =
      { inventory_deletions; next_token }
    let parse xml =
      Some
        {
          inventory_deletions =
            (Util.of_option []
               (Util.option_bind (Xml.member "InventoryDeletions" xml)
                  InventoryDeletionsList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "InventoryDeletions"
                       ([], (InventoryDeletionsList.to_xml [x]))))
               v.inventory_deletions))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("inventory_deletions",
               (InventoryDeletionsList.to_json v.inventory_deletions))])
    let of_json j =
      {
        inventory_deletions =
          (InventoryDeletionsList.of_json
             (Util.of_option_exn (Json.lookup j "inventory_deletions")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module UnsupportedPlatformType =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeDocumentPermissionRequest =
  struct
    type t = {
      name: String.t ;
      permission_type: DocumentPermissionType.t }
    let make ~name  ~permission_type  () = { name; permission_type }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          permission_type =
            (Xml.required "PermissionType"
               (Util.option_bind (Xml.member "PermissionType" xml)
                  DocumentPermissionType.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
           @
           [Some
              (Ezxmlm.make_tag "PermissionType"
                 ([], (DocumentPermissionType.to_xml v.permission_type)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("permission_type",
                (DocumentPermissionType.to_json v.permission_type));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        permission_type =
          (DocumentPermissionType.of_json
             (Util.of_option_exn (Json.lookup j "permission_type")))
      }
  end
module DescribeSessionsRequest =
  struct
    type t =
      {
      state: SessionState.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      filters: SessionFilterList.t }
    let make ~state  ?max_results  ?next_token  ?(filters= [])  () =
      { state; max_results; next_token; filters }
    let parse xml =
      Some
        {
          state =
            (Xml.required "State"
               (Util.option_bind (Xml.member "State" xml) SessionState.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  SessionFilterList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "State" ([], (SessionState.to_xml v.state)))])
             @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Filters"
                      ([], (SessionFilterList.to_xml [x])))) v.filters))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (SessionFilterList.to_json v.filters));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("state", (SessionState.to_json v.state))])
    let of_json j =
      {
        state =
          (SessionState.of_json (Util.of_option_exn (Json.lookup j "state")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        filters =
          (SessionFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DescribeInstanceAssociationsStatusResult =
  struct
    type t =
      {
      instance_association_status_infos: InstanceAssociationStatusInfos.t ;
      next_token: String.t option }
    let make ?(instance_association_status_infos= [])  ?next_token  () =
      { instance_association_status_infos; next_token }
    let parse xml =
      Some
        {
          instance_association_status_infos =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "InstanceAssociationStatusInfos" xml)
                  InstanceAssociationStatusInfos.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "InstanceAssociationStatusInfos"
                       ([], (InstanceAssociationStatusInfos.to_xml [x]))))
               v.instance_association_status_infos))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_association_status_infos",
               (InstanceAssociationStatusInfos.to_json
                  v.instance_association_status_infos))])
    let of_json j =
      {
        instance_association_status_infos =
          (InstanceAssociationStatusInfos.of_json
             (Util.of_option_exn
                (Json.lookup j "instance_association_status_infos")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetInventorySchemaResult =
  struct
    type t =
      {
      schemas: InventoryItemSchemaResultList.t ;
      next_token: String.t option }
    let make ?(schemas= [])  ?next_token  () = { schemas; next_token }
    let parse xml =
      Some
        {
          schemas =
            (Util.of_option []
               (Util.option_bind (Xml.member "Schemas" xml)
                  InventoryItemSchemaResultList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Schemas"
                       ([], (InventoryItemSchemaResultList.to_xml [x]))))
               v.schemas))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("schemas", (InventoryItemSchemaResultList.to_json v.schemas))])
    let of_json j =
      {
        schemas =
          (InventoryItemSchemaResultList.of_json
             (Util.of_option_exn (Json.lookup j "schemas")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeMaintenanceWindowExecutionTasksResult =
  struct
    type t =
      {
      window_execution_task_identities:
        MaintenanceWindowExecutionTaskIdentityList.t ;
      next_token: String.t option }
    let make ?(window_execution_task_identities= [])  ?next_token  () =
      { window_execution_task_identities; next_token }
    let parse xml =
      Some
        {
          window_execution_task_identities =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "WindowExecutionTaskIdentities" xml)
                  MaintenanceWindowExecutionTaskIdentityList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "WindowExecutionTaskIdentities"
                       ([],
                         (MaintenanceWindowExecutionTaskIdentityList.to_xml
                            [x])))) v.window_execution_task_identities))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("window_execution_task_identities",
               (MaintenanceWindowExecutionTaskIdentityList.to_json
                  v.window_execution_task_identities))])
    let of_json j =
      {
        window_execution_task_identities =
          (MaintenanceWindowExecutionTaskIdentityList.of_json
             (Util.of_option_exn
                (Json.lookup j "window_execution_task_identities")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ServiceSettingNotFound =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module AddTagsToResourceRequest =
  struct
    type t =
      {
      resource_type: ResourceTypeForTagging.t ;
      resource_id: String.t ;
      tags: TagList.t }
    let make ~resource_type  ~resource_id  ~tags  () =
      { resource_type; resource_id; tags }
    let parse xml =
      Some
        {
          resource_type =
            (Xml.required "ResourceType"
               (Util.option_bind (Xml.member "ResourceType" xml)
                  ResourceTypeForTagging.parse));
          resource_id =
            (Xml.required "ResourceId"
               (Util.option_bind (Xml.member "ResourceId" xml) String.parse));
          tags =
            (Xml.required "Tags"
               (Util.option_bind (Xml.member "Tags" xml) TagList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "ResourceType"
                   ([], (ResourceTypeForTagging.to_xml v.resource_type)))])
            @
            [Some
               (Ezxmlm.make_tag "ResourceId"
                  ([], (String.to_xml v.resource_id)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "Tags" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some ("resource_id", (String.to_json v.resource_id));
           Some
             ("resource_type",
               (ResourceTypeForTagging.to_json v.resource_type))])
    let of_json j =
      {
        resource_type =
          (ResourceTypeForTagging.of_json
             (Util.of_option_exn (Json.lookup j "resource_type")));
        resource_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "resource_id")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module DescribeMaintenanceWindowsResult =
  struct
    type t =
      {
      window_identities: MaintenanceWindowIdentityList.t ;
      next_token: String.t option }
    let make ?(window_identities= [])  ?next_token  () =
      { window_identities; next_token }
    let parse xml =
      Some
        {
          window_identities =
            (Util.of_option []
               (Util.option_bind (Xml.member "WindowIdentities" xml)
                  MaintenanceWindowIdentityList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "WindowIdentities"
                       ([], (MaintenanceWindowIdentityList.to_xml [x]))))
               v.window_identities))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("window_identities",
               (MaintenanceWindowIdentityList.to_json v.window_identities))])
    let of_json j =
      {
        window_identities =
          (MaintenanceWindowIdentityList.of_json
             (Util.of_option_exn (Json.lookup j "window_identities")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetParametersByPathRequest =
  struct
    type t =
      {
      path: String.t ;
      recursive: Boolean.t option ;
      parameter_filters: ParameterStringFilterList.t ;
      with_decryption: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ~path  ?recursive  ?(parameter_filters= [])  ?with_decryption 
      ?max_results  ?next_token  () =
      {
        path;
        recursive;
        parameter_filters;
        with_decryption;
        max_results;
        next_token
      }
    let parse xml =
      Some
        {
          path =
            (Xml.required "Path"
               (Util.option_bind (Xml.member "Path" xml) String.parse));
          recursive =
            (Util.option_bind (Xml.member "Recursive" xml) Boolean.parse);
          parameter_filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "ParameterFilters" xml)
                  ParameterStringFilterList.parse));
          with_decryption =
            (Util.option_bind (Xml.member "WithDecryption" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Some (Ezxmlm.make_tag "Path" ([], (String.to_xml v.path)))])
               @
               [Util.option_map v.recursive
                  (fun f ->
                     Ezxmlm.make_tag "Recursive" ([], (Boolean.to_xml f)))])
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "ParameterFilters"
                         ([], (ParameterStringFilterList.to_xml [x]))))
                 v.parameter_filters))
             @
             [Util.option_map v.with_decryption
                (fun f ->
                   Ezxmlm.make_tag "WithDecryption" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.with_decryption
             (fun f -> ("with_decryption", (Boolean.to_json f)));
           Some
             ("parameter_filters",
               (ParameterStringFilterList.to_json v.parameter_filters));
           Util.option_map v.recursive
             (fun f -> ("recursive", (Boolean.to_json f)));
           Some ("path", (String.to_json v.path))])
    let of_json j =
      {
        path = (String.of_json (Util.of_option_exn (Json.lookup j "path")));
        recursive =
          (Util.option_map (Json.lookup j "recursive") Boolean.of_json);
        parameter_filters =
          (ParameterStringFilterList.of_json
             (Util.of_option_exn (Json.lookup j "parameter_filters")));
        with_decryption =
          (Util.option_map (Json.lookup j "with_decryption") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetConnectionStatusResponse =
  struct
    type t = {
      target: String.t option ;
      status: ConnectionStatus.t option }
    let make ?target  ?status  () = { target; status }
    let parse xml =
      Some
        {
          target = (Util.option_bind (Xml.member "Target" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml)
               ConnectionStatus.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.target
               (fun f -> Ezxmlm.make_tag "Target" ([], (String.to_xml f)))])
           @
           [Util.option_map v.status
              (fun f ->
                 Ezxmlm.make_tag "Status" ([], (ConnectionStatus.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (ConnectionStatus.to_json f)));
           Util.option_map v.target (fun f -> ("target", (String.to_json f)))])
    let of_json j =
      {
        target = (Util.option_map (Json.lookup j "target") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") ConnectionStatus.of_json)
      }
  end
module InvalidNotificationConfig =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module SendCommandResult =
  struct
    type t = {
      command: Command.t option }
    let make ?command  () = { command }
    let parse xml =
      Some
        {
          command =
            (Util.option_bind (Xml.member "Command" xml) Command.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.command
              (fun f -> Ezxmlm.make_tag "Command" ([], (Command.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.command
              (fun f -> ("command", (Command.to_json f)))])
    let of_json j =
      { command = (Util.option_map (Json.lookup j "command") Command.of_json)
      }
  end
module DeleteActivationRequest =
  struct
    type t = {
      activation_id: String.t }
    let make ~activation_id  () = { activation_id }
    let parse xml =
      Some
        {
          activation_id =
            (Xml.required "ActivationId"
               (Util.option_bind (Xml.member "ActivationId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "ActivationId"
                 ([], (String.to_xml v.activation_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("activation_id", (String.to_json v.activation_id))])
    let of_json j =
      {
        activation_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "activation_id")))
      }
  end
module DeleteAssociationRequest =
  struct
    type t =
      {
      name: String.t option ;
      instance_id: String.t option ;
      association_id: String.t option }
    let make ?name  ?instance_id  ?association_id  () =
      { name; instance_id; association_id }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          association_id =
            (Util.option_bind (Xml.member "AssociationId" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.name
                (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
            @
            [Util.option_map v.instance_id
               (fun f -> Ezxmlm.make_tag "InstanceId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.association_id
              (fun f ->
                 Ezxmlm.make_tag "AssociationId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_id
              (fun f -> ("association_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json)
      }
  end
module CreateActivationRequest =
  struct
    type t =
      {
      description: String.t option ;
      default_instance_name: String.t option ;
      iam_role: String.t ;
      registration_limit: Integer.t option ;
      expiration_date: DateTime.t option ;
      tags: TagList.t }
    let make ?description  ?default_instance_name  ~iam_role 
      ?registration_limit  ?expiration_date  ?(tags= [])  () =
      {
        description;
        default_instance_name;
        iam_role;
        registration_limit;
        expiration_date;
        tags
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          default_instance_name =
            (Util.option_bind (Xml.member "DefaultInstanceName" xml)
               String.parse);
          iam_role =
            (Xml.required "IamRole"
               (Util.option_bind (Xml.member "IamRole" xml) String.parse));
          registration_limit =
            (Util.option_bind (Xml.member "RegistrationLimit" xml)
               Integer.parse);
          expiration_date =
            (Util.option_bind (Xml.member "ExpirationDate" xml)
               DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tags" xml) TagList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.description
                   (fun f ->
                      Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
               @
               [Util.option_map v.default_instance_name
                  (fun f ->
                     Ezxmlm.make_tag "DefaultInstanceName"
                       ([], (String.to_xml f)))])
              @
              [Some
                 (Ezxmlm.make_tag "IamRole" ([], (String.to_xml v.iam_role)))])
             @
             [Util.option_map v.registration_limit
                (fun f ->
                   Ezxmlm.make_tag "RegistrationLimit"
                     ([], (Integer.to_xml f)))])
            @
            [Util.option_map v.expiration_date
               (fun f ->
                  Ezxmlm.make_tag "ExpirationDate" ([], (DateTime.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "Tags" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.expiration_date
             (fun f -> ("expiration_date", (DateTime.to_json f)));
           Util.option_map v.registration_limit
             (fun f -> ("registration_limit", (Integer.to_json f)));
           Some ("iam_role", (String.to_json v.iam_role));
           Util.option_map v.default_instance_name
             (fun f -> ("default_instance_name", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        default_instance_name =
          (Util.option_map (Json.lookup j "default_instance_name")
             String.of_json);
        iam_role =
          (String.of_json (Util.of_option_exn (Json.lookup j "iam_role")));
        registration_limit =
          (Util.option_map (Json.lookup j "registration_limit")
             Integer.of_json);
        expiration_date =
          (Util.option_map (Json.lookup j "expiration_date") DateTime.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ParameterVersionLabelLimitExceeded =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module AssociationExecutionDoesNotExist =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ModifyDocumentPermissionResponse =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module UpdateMaintenanceWindowTaskRequest =
  struct
    type t =
      {
      window_id: String.t ;
      window_task_id: String.t ;
      targets: Targets.t ;
      task_arn: String.t option ;
      service_role_arn: String.t option ;
      task_parameters: MaintenanceWindowTaskParameters.t option ;
      task_invocation_parameters:
        MaintenanceWindowTaskInvocationParameters.t option ;
      priority: Integer.t option ;
      max_concurrency: String.t option ;
      max_errors: String.t option ;
      logging_info: LoggingInfo.t option ;
      name: String.t option ;
      description: String.t option ;
      replace: Boolean.t option }
    let make ~window_id  ~window_task_id  ?(targets= [])  ?task_arn 
      ?service_role_arn  ?task_parameters  ?task_invocation_parameters 
      ?priority  ?max_concurrency  ?max_errors  ?logging_info  ?name 
      ?description  ?replace  () =
      {
        window_id;
        window_task_id;
        targets;
        task_arn;
        service_role_arn;
        task_parameters;
        task_invocation_parameters;
        priority;
        max_concurrency;
        max_errors;
        logging_info;
        name;
        description;
        replace
      }
    let parse xml =
      Some
        {
          window_id =
            (Xml.required "WindowId"
               (Util.option_bind (Xml.member "WindowId" xml) String.parse));
          window_task_id =
            (Xml.required "WindowTaskId"
               (Util.option_bind (Xml.member "WindowTaskId" xml) String.parse));
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          task_arn =
            (Util.option_bind (Xml.member "TaskArn" xml) String.parse);
          service_role_arn =
            (Util.option_bind (Xml.member "ServiceRoleArn" xml) String.parse);
          task_parameters =
            (Util.option_bind (Xml.member "TaskParameters" xml)
               MaintenanceWindowTaskParameters.parse);
          task_invocation_parameters =
            (Util.option_bind (Xml.member "TaskInvocationParameters" xml)
               MaintenanceWindowTaskInvocationParameters.parse);
          priority =
            (Util.option_bind (Xml.member "Priority" xml) Integer.parse);
          max_concurrency =
            (Util.option_bind (Xml.member "MaxConcurrency" xml) String.parse);
          max_errors =
            (Util.option_bind (Xml.member "MaxErrors" xml) String.parse);
          logging_info =
            (Util.option_bind (Xml.member "LoggingInfo" xml)
               LoggingInfo.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          replace =
            (Util.option_bind (Xml.member "Replace" xml) Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        [Some
                           (Ezxmlm.make_tag "WindowId"
                              ([], (String.to_xml v.window_id)))])
                       @
                       [Some
                          (Ezxmlm.make_tag "WindowTaskId"
                             ([], (String.to_xml v.window_task_id)))])
                      @
                      (List.map
                         (fun x ->
                            Some
                              (Ezxmlm.make_tag "Targets"
                                 ([], (Targets.to_xml [x])))) v.targets))
                     @
                     [Util.option_map v.task_arn
                        (fun f ->
                           Ezxmlm.make_tag "TaskArn" ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.service_role_arn
                       (fun f ->
                          Ezxmlm.make_tag "ServiceRoleArn"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.task_parameters
                      (fun f ->
                         Ezxmlm.make_tag "TaskParameters"
                           ([], (MaintenanceWindowTaskParameters.to_xml f)))])
                  @
                  [Util.option_map v.task_invocation_parameters
                     (fun f ->
                        Ezxmlm.make_tag "TaskInvocationParameters"
                          ([],
                            (MaintenanceWindowTaskInvocationParameters.to_xml
                               f)))])
                 @
                 [Util.option_map v.priority
                    (fun f ->
                       Ezxmlm.make_tag "Priority" ([], (Integer.to_xml f)))])
                @
                [Util.option_map v.max_concurrency
                   (fun f ->
                      Ezxmlm.make_tag "MaxConcurrency"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.max_errors
                  (fun f ->
                     Ezxmlm.make_tag "MaxErrors" ([], (String.to_xml f)))])
              @
              [Util.option_map v.logging_info
                 (fun f ->
                    Ezxmlm.make_tag "LoggingInfo"
                      ([], (LoggingInfo.to_xml f)))])
             @
             [Util.option_map v.name
                (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
            @
            [Util.option_map v.description
               (fun f ->
                  Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
           @
           [Util.option_map v.replace
              (fun f -> Ezxmlm.make_tag "Replace" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.replace
              (fun f -> ("replace", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.logging_info
             (fun f -> ("logging_info", (LoggingInfo.to_json f)));
           Util.option_map v.max_errors
             (fun f -> ("max_errors", (String.to_json f)));
           Util.option_map v.max_concurrency
             (fun f -> ("max_concurrency", (String.to_json f)));
           Util.option_map v.priority
             (fun f -> ("priority", (Integer.to_json f)));
           Util.option_map v.task_invocation_parameters
             (fun f ->
                ("task_invocation_parameters",
                  (MaintenanceWindowTaskInvocationParameters.to_json f)));
           Util.option_map v.task_parameters
             (fun f ->
                ("task_parameters",
                  (MaintenanceWindowTaskParameters.to_json f)));
           Util.option_map v.service_role_arn
             (fun f -> ("service_role_arn", (String.to_json f)));
           Util.option_map v.task_arn
             (fun f -> ("task_arn", (String.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Some ("window_task_id", (String.to_json v.window_task_id));
           Some ("window_id", (String.to_json v.window_id))])
    let of_json j =
      {
        window_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "window_id")));
        window_task_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "window_task_id")));
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        task_arn =
          (Util.option_map (Json.lookup j "task_arn") String.of_json);
        service_role_arn =
          (Util.option_map (Json.lookup j "service_role_arn") String.of_json);
        task_parameters =
          (Util.option_map (Json.lookup j "task_parameters")
             MaintenanceWindowTaskParameters.of_json);
        task_invocation_parameters =
          (Util.option_map (Json.lookup j "task_invocation_parameters")
             MaintenanceWindowTaskInvocationParameters.of_json);
        priority =
          (Util.option_map (Json.lookup j "priority") Integer.of_json);
        max_concurrency =
          (Util.option_map (Json.lookup j "max_concurrency") String.of_json);
        max_errors =
          (Util.option_map (Json.lookup j "max_errors") String.of_json);
        logging_info =
          (Util.option_map (Json.lookup j "logging_info") LoggingInfo.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        replace = (Util.option_map (Json.lookup j "replace") Boolean.of_json)
      }
  end
module CreateDocumentRequest =
  struct
    type t =
      {
      content: String.t ;
      requires: DocumentRequiresList.t ;
      attachments: AttachmentsSourceList.t ;
      name: String.t ;
      version_name: String.t option ;
      document_type: DocumentType.t option ;
      document_format: DocumentFormat.t option ;
      target_type: String.t option ;
      tags: TagList.t }
    let make ~content  ?(requires= [])  ?(attachments= [])  ~name 
      ?version_name  ?document_type  ?document_format  ?target_type  ?(tags=
      [])  () =
      {
        content;
        requires;
        attachments;
        name;
        version_name;
        document_type;
        document_format;
        target_type;
        tags
      }
    let parse xml =
      Some
        {
          content =
            (Xml.required "Content"
               (Util.option_bind (Xml.member "Content" xml) String.parse));
          requires =
            (Util.of_option []
               (Util.option_bind (Xml.member "Requires" xml)
                  DocumentRequiresList.parse));
          attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "Attachments" xml)
                  AttachmentsSourceList.parse));
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          version_name =
            (Util.option_bind (Xml.member "VersionName" xml) String.parse);
          document_type =
            (Util.option_bind (Xml.member "DocumentType" xml)
               DocumentType.parse);
          document_format =
            (Util.option_bind (Xml.member "DocumentFormat" xml)
               DocumentFormat.parse);
          target_type =
            (Util.option_bind (Xml.member "TargetType" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tags" xml) TagList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((([] @
                   [Some
                      (Ezxmlm.make_tag "Content"
                         ([], (String.to_xml v.content)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "Requires"
                             ([], (DocumentRequiresList.to_xml [x]))))
                     v.requires))
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "Attachments"
                            ([], (AttachmentsSourceList.to_xml [x]))))
                    v.attachments))
                @
                [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
               @
               [Util.option_map v.version_name
                  (fun f ->
                     Ezxmlm.make_tag "VersionName" ([], (String.to_xml f)))])
              @
              [Util.option_map v.document_type
                 (fun f ->
                    Ezxmlm.make_tag "DocumentType"
                      ([], (DocumentType.to_xml f)))])
             @
             [Util.option_map v.document_format
                (fun f ->
                   Ezxmlm.make_tag "DocumentFormat"
                     ([], (DocumentFormat.to_xml f)))])
            @
            [Util.option_map v.target_type
               (fun f -> Ezxmlm.make_tag "TargetType" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "Tags" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.target_type
             (fun f -> ("target_type", (String.to_json f)));
           Util.option_map v.document_format
             (fun f -> ("document_format", (DocumentFormat.to_json f)));
           Util.option_map v.document_type
             (fun f -> ("document_type", (DocumentType.to_json f)));
           Util.option_map v.version_name
             (fun f -> ("version_name", (String.to_json f)));
           Some ("name", (String.to_json v.name));
           Some
             ("attachments", (AttachmentsSourceList.to_json v.attachments));
           Some ("requires", (DocumentRequiresList.to_json v.requires));
           Some ("content", (String.to_json v.content))])
    let of_json j =
      {
        content =
          (String.of_json (Util.of_option_exn (Json.lookup j "content")));
        requires =
          (DocumentRequiresList.of_json
             (Util.of_option_exn (Json.lookup j "requires")));
        attachments =
          (AttachmentsSourceList.of_json
             (Util.of_option_exn (Json.lookup j "attachments")));
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        version_name =
          (Util.option_map (Json.lookup j "version_name") String.of_json);
        document_type =
          (Util.option_map (Json.lookup j "document_type")
             DocumentType.of_json);
        document_format =
          (Util.option_map (Json.lookup j "document_format")
             DocumentFormat.of_json);
        target_type =
          (Util.option_map (Json.lookup j "target_type") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module DescribeInventoryDeletionsRequest =
  struct
    type t =
      {
      deletion_id: String.t option ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?deletion_id  ?next_token  ?max_results  () =
      { deletion_id; next_token; max_results }
    let parse xml =
      Some
        {
          deletion_id =
            (Util.option_bind (Xml.member "DeletionId" xml) String.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.deletion_id
                (fun f ->
                   Ezxmlm.make_tag "DeletionId" ([], (String.to_xml f)))])
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.deletion_id
             (fun f -> ("deletion_id", (String.to_json f)))])
    let of_json j =
      {
        deletion_id =
          (Util.option_map (Json.lookup j "deletion_id") String.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module UpdateDocumentDefaultVersionRequest =
  struct
    type t = {
      name: String.t ;
      document_version: String.t }
    let make ~name  ~document_version  () = { name; document_version }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          document_version =
            (Xml.required "DocumentVersion"
               (Util.option_bind (Xml.member "DocumentVersion" xml)
                  String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
           @
           [Some
              (Ezxmlm.make_tag "DocumentVersion"
                 ([], (String.to_xml v.document_version)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("document_version", (String.to_json v.document_version));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        document_version =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "document_version")))
      }
  end
module DeleteParametersRequest =
  struct
    type t = {
      names: ParameterNameList.t }
    let make ~names  () = { names }
    let parse xml =
      Some
        {
          names =
            (Xml.required "Names"
               (Util.option_bind (Xml.member "Names" xml)
                  ParameterNameList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Names"
                      ([], (ParameterNameList.to_xml [x])))) v.names))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("names", (ParameterNameList.to_json v.names))])
    let of_json j =
      {
        names =
          (ParameterNameList.of_json
             (Util.of_option_exn (Json.lookup j "names")))
      }
  end
module DescribeMaintenanceWindowTargetsRequest =
  struct
    type t =
      {
      window_id: String.t ;
      filters: MaintenanceWindowFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ~window_id  ?(filters= [])  ?max_results  ?next_token  () =
      { window_id; filters; max_results; next_token }
    let parse xml =
      Some
        {
          window_id =
            (Xml.required "WindowId"
               (Util.option_bind (Xml.member "WindowId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  MaintenanceWindowFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              [Some
                 (Ezxmlm.make_tag "WindowId"
                    ([], (String.to_xml v.window_id)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (MaintenanceWindowFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (MaintenanceWindowFilterList.to_json v.filters));
           Some ("window_id", (String.to_json v.window_id))])
    let of_json j =
      {
        window_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "window_id")));
        filters =
          (MaintenanceWindowFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module StartAutomationExecutionResult =
  struct
    type t = {
      automation_execution_id: String.t option }
    let make ?automation_execution_id  () = { automation_execution_id }
    let parse xml =
      Some
        {
          automation_execution_id =
            (Util.option_bind (Xml.member "AutomationExecutionId" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.automation_execution_id
              (fun f ->
                 Ezxmlm.make_tag "AutomationExecutionId"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.automation_execution_id
              (fun f -> ("automation_execution_id", (String.to_json f)))])
    let of_json j =
      {
        automation_execution_id =
          (Util.option_map (Json.lookup j "automation_execution_id")
             String.of_json)
      }
  end
module ListComplianceItemsRequest =
  struct
    type t =
      {
      filters: ComplianceStringFilterList.t ;
      resource_ids: ComplianceResourceIdList.t ;
      resource_types: ComplianceResourceTypeList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?(resource_ids= [])  ?(resource_types= []) 
      ?next_token  ?max_results  () =
      { filters; resource_ids; resource_types; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  ComplianceStringFilterList.parse));
          resource_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ResourceIds" xml)
                  ComplianceResourceIdList.parse));
          resource_types =
            (Util.of_option []
               (Util.option_bind (Xml.member "ResourceTypes" xml)
                  ComplianceResourceTypeList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Filters"
                          ([], (ComplianceStringFilterList.to_xml [x]))))
                  v.filters))
              @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "ResourceIds"
                         ([], (ComplianceResourceIdList.to_xml [x]))))
                 v.resource_ids))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "ResourceTypes"
                        ([], (ComplianceResourceTypeList.to_xml [x]))))
                v.resource_types))
            @
            [Util.option_map v.next_token
               (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
           @
           [Util.option_map v.max_results
              (fun f -> Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("resource_types",
               (ComplianceResourceTypeList.to_json v.resource_types));
           Some
             ("resource_ids",
               (ComplianceResourceIdList.to_json v.resource_ids));
           Some ("filters", (ComplianceStringFilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (ComplianceStringFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        resource_ids =
          (ComplianceResourceIdList.of_json
             (Util.of_option_exn (Json.lookup j "resource_ids")));
        resource_types =
          (ComplianceResourceTypeList.of_json
             (Util.of_option_exn (Json.lookup j "resource_types")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module UpdateAssociationRequest =
  struct
    type t =
      {
      association_id: String.t ;
      parameters: Parameters.t option ;
      document_version: String.t option ;
      schedule_expression: String.t option ;
      output_location: InstanceAssociationOutputLocation.t option ;
      name: String.t option ;
      targets: Targets.t ;
      association_name: String.t option ;
      association_version: String.t option ;
      automation_target_parameter_name: String.t option ;
      max_errors: String.t option ;
      max_concurrency: String.t option ;
      compliance_severity: AssociationComplianceSeverity.t option }
    let make ~association_id  ?parameters  ?document_version 
      ?schedule_expression  ?output_location  ?name  ?(targets= []) 
      ?association_name  ?association_version 
      ?automation_target_parameter_name  ?max_errors  ?max_concurrency 
      ?compliance_severity  () =
      {
        association_id;
        parameters;
        document_version;
        schedule_expression;
        output_location;
        name;
        targets;
        association_name;
        association_version;
        automation_target_parameter_name;
        max_errors;
        max_concurrency;
        compliance_severity
      }
    let parse xml =
      Some
        {
          association_id =
            (Xml.required "AssociationId"
               (Util.option_bind (Xml.member "AssociationId" xml)
                  String.parse));
          parameters =
            (Util.option_bind (Xml.member "Parameters" xml) Parameters.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          schedule_expression =
            (Util.option_bind (Xml.member "ScheduleExpression" xml)
               String.parse);
          output_location =
            (Util.option_bind (Xml.member "OutputLocation" xml)
               InstanceAssociationOutputLocation.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          association_name =
            (Util.option_bind (Xml.member "AssociationName" xml) String.parse);
          association_version =
            (Util.option_bind (Xml.member "AssociationVersion" xml)
               String.parse);
          automation_target_parameter_name =
            (Util.option_bind
               (Xml.member "AutomationTargetParameterName" xml) String.parse);
          max_errors =
            (Util.option_bind (Xml.member "MaxErrors" xml) String.parse);
          max_concurrency =
            (Util.option_bind (Xml.member "MaxConcurrency" xml) String.parse);
          compliance_severity =
            (Util.option_bind (Xml.member "ComplianceSeverity" xml)
               AssociationComplianceSeverity.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((([] @
                       [Some
                          (Ezxmlm.make_tag "AssociationId"
                             ([], (String.to_xml v.association_id)))])
                      @
                      [Util.option_map v.parameters
                         (fun f ->
                            Ezxmlm.make_tag "Parameters"
                              ([], (Parameters.to_xml f)))])
                     @
                     [Util.option_map v.document_version
                        (fun f ->
                           Ezxmlm.make_tag "DocumentVersion"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.schedule_expression
                       (fun f ->
                          Ezxmlm.make_tag "ScheduleExpression"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.output_location
                      (fun f ->
                         Ezxmlm.make_tag "OutputLocation"
                           ([], (InstanceAssociationOutputLocation.to_xml f)))])
                  @
                  [Util.option_map v.name
                     (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "Targets"
                            ([], (Targets.to_xml [x])))) v.targets))
                @
                [Util.option_map v.association_name
                   (fun f ->
                      Ezxmlm.make_tag "AssociationName"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.association_version
                  (fun f ->
                     Ezxmlm.make_tag "AssociationVersion"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.automation_target_parameter_name
                 (fun f ->
                    Ezxmlm.make_tag "AutomationTargetParameterName"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.max_errors
                (fun f -> Ezxmlm.make_tag "MaxErrors" ([], (String.to_xml f)))])
            @
            [Util.option_map v.max_concurrency
               (fun f ->
                  Ezxmlm.make_tag "MaxConcurrency" ([], (String.to_xml f)))])
           @
           [Util.option_map v.compliance_severity
              (fun f ->
                 Ezxmlm.make_tag "ComplianceSeverity"
                   ([], (AssociationComplianceSeverity.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.compliance_severity
              (fun f ->
                 ("compliance_severity",
                   (AssociationComplianceSeverity.to_json f)));
           Util.option_map v.max_concurrency
             (fun f -> ("max_concurrency", (String.to_json f)));
           Util.option_map v.max_errors
             (fun f -> ("max_errors", (String.to_json f)));
           Util.option_map v.automation_target_parameter_name
             (fun f ->
                ("automation_target_parameter_name", (String.to_json f)));
           Util.option_map v.association_version
             (fun f -> ("association_version", (String.to_json f)));
           Util.option_map v.association_name
             (fun f -> ("association_name", (String.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.output_location
             (fun f ->
                ("output_location",
                  (InstanceAssociationOutputLocation.to_json f)));
           Util.option_map v.schedule_expression
             (fun f -> ("schedule_expression", (String.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.parameters
             (fun f -> ("parameters", (Parameters.to_json f)));
           Some ("association_id", (String.to_json v.association_id))])
    let of_json j =
      {
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")));
        parameters =
          (Util.option_map (Json.lookup j "parameters") Parameters.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        schedule_expression =
          (Util.option_map (Json.lookup j "schedule_expression")
             String.of_json);
        output_location =
          (Util.option_map (Json.lookup j "output_location")
             InstanceAssociationOutputLocation.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        association_name =
          (Util.option_map (Json.lookup j "association_name") String.of_json);
        association_version =
          (Util.option_map (Json.lookup j "association_version")
             String.of_json);
        automation_target_parameter_name =
          (Util.option_map (Json.lookup j "automation_target_parameter_name")
             String.of_json);
        max_errors =
          (Util.option_map (Json.lookup j "max_errors") String.of_json);
        max_concurrency =
          (Util.option_map (Json.lookup j "max_concurrency") String.of_json);
        compliance_severity =
          (Util.option_map (Json.lookup j "compliance_severity")
             AssociationComplianceSeverity.of_json)
      }
  end
module CancelCommandRequest =
  struct
    type t = {
      command_id: String.t ;
      instance_ids: InstanceIdList.t }
    let make ~command_id  ?(instance_ids= [])  () =
      { command_id; instance_ids }
    let parse xml =
      Some
        {
          command_id =
            (Xml.required "CommandId"
               (Util.option_bind (Xml.member "CommandId" xml) String.parse));
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceIds" xml)
                  InstanceIdList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "CommandId"
                  ([], (String.to_xml v.command_id)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "InstanceIds"
                      ([], (InstanceIdList.to_xml [x])))) v.instance_ids))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instance_ids", (InstanceIdList.to_json v.instance_ids));
           Some ("command_id", (String.to_json v.command_id))])
    let of_json j =
      {
        command_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "command_id")));
        instance_ids =
          (InstanceIdList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")))
      }
  end
module DescribeDocumentPermissionResponse =
  struct
    type t =
      {
      account_ids: AccountIdList.t ;
      account_sharing_info_list: AccountSharingInfoList.t }
    let make ?(account_ids= [])  ?(account_sharing_info_list= [])  () =
      { account_ids; account_sharing_info_list }
    let parse xml =
      Some
        {
          account_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AccountIds" xml)
                  AccountIdList.parse));
          account_sharing_info_list =
            (Util.of_option []
               (Util.option_bind (Xml.member "AccountSharingInfoList" xml)
                  AccountSharingInfoList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "AccountIds"
                       ([], (AccountIdList.to_xml [x])))) v.account_ids))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "AccountSharingInfoList"
                      ([], (AccountSharingInfoList.to_xml [x]))))
              v.account_sharing_info_list))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("account_sharing_info_list",
                (AccountSharingInfoList.to_json v.account_sharing_info_list));
           Some ("account_ids", (AccountIdList.to_json v.account_ids))])
    let of_json j =
      {
        account_ids =
          (AccountIdList.of_json
             (Util.of_option_exn (Json.lookup j "account_ids")));
        account_sharing_info_list =
          (AccountSharingInfoList.of_json
             (Util.of_option_exn (Json.lookup j "account_sharing_info_list")))
      }
  end
module ListInventoryEntriesResult =
  struct
    type t =
      {
      type_name: String.t option ;
      instance_id: String.t option ;
      schema_version: String.t option ;
      capture_time: String.t option ;
      entries: InventoryItemEntryList.t ;
      next_token: String.t option }
    let make ?type_name  ?instance_id  ?schema_version  ?capture_time 
      ?(entries= [])  ?next_token  () =
      {
        type_name;
        instance_id;
        schema_version;
        capture_time;
        entries;
        next_token
      }
    let parse xml =
      Some
        {
          type_name =
            (Util.option_bind (Xml.member "TypeName" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          schema_version =
            (Util.option_bind (Xml.member "SchemaVersion" xml) String.parse);
          capture_time =
            (Util.option_bind (Xml.member "CaptureTime" xml) String.parse);
          entries =
            (Util.of_option []
               (Util.option_bind (Xml.member "Entries" xml)
                  InventoryItemEntryList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.type_name
                   (fun f ->
                      Ezxmlm.make_tag "TypeName" ([], (String.to_xml f)))])
               @
               [Util.option_map v.instance_id
                  (fun f ->
                     Ezxmlm.make_tag "InstanceId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.schema_version
                 (fun f ->
                    Ezxmlm.make_tag "SchemaVersion" ([], (String.to_xml f)))])
             @
             [Util.option_map v.capture_time
                (fun f ->
                   Ezxmlm.make_tag "CaptureTime" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Entries"
                       ([], (InventoryItemEntryList.to_xml [x])))) v.entries))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("entries", (InventoryItemEntryList.to_json v.entries));
           Util.option_map v.capture_time
             (fun f -> ("capture_time", (String.to_json f)));
           Util.option_map v.schema_version
             (fun f -> ("schema_version", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.type_name
             (fun f -> ("type_name", (String.to_json f)))])
    let of_json j =
      {
        type_name =
          (Util.option_map (Json.lookup j "type_name") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        schema_version =
          (Util.option_map (Json.lookup j "schema_version") String.of_json);
        capture_time =
          (Util.option_map (Json.lookup j "capture_time") String.of_json);
        entries =
          (InventoryItemEntryList.of_json
             (Util.of_option_exn (Json.lookup j "entries")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ListTagsForResourceResult =
  struct
    type t = {
      tag_list: TagList.t }
    let make ?(tag_list= [])  () = { tag_list }
    let parse xml =
      Some
        {
          tag_list =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagList" xml) TagList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "TagList" ([], (TagList.to_xml [x]))))
              v.tag_list))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tag_list", (TagList.to_json v.tag_list))])
    let of_json j =
      {
        tag_list =
          (TagList.of_json (Util.of_option_exn (Json.lookup j "tag_list")))
      }
  end
module InvalidInstanceId =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeMaintenanceWindowExecutionTaskInvocationsResult =
  struct
    type t =
      {
      window_execution_task_invocation_identities:
        MaintenanceWindowExecutionTaskInvocationIdentityList.t ;
      next_token: String.t option }
    let make ?(window_execution_task_invocation_identities= [])  ?next_token 
      () = { window_execution_task_invocation_identities; next_token }
    let parse xml =
      Some
        {
          window_execution_task_invocation_identities =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "WindowExecutionTaskInvocationIdentities" xml)
                  MaintenanceWindowExecutionTaskInvocationIdentityList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag
                       "WindowExecutionTaskInvocationIdentities"
                       ([],
                         (MaintenanceWindowExecutionTaskInvocationIdentityList.to_xml
                            [x]))))
               v.window_execution_task_invocation_identities))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("window_execution_task_invocation_identities",
               (MaintenanceWindowExecutionTaskInvocationIdentityList.to_json
                  v.window_execution_task_invocation_identities))])
    let of_json j =
      {
        window_execution_task_invocation_identities =
          (MaintenanceWindowExecutionTaskInvocationIdentityList.of_json
             (Util.of_option_exn
                (Json.lookup j "window_execution_task_invocation_identities")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeMaintenanceWindowsForTargetResult =
  struct
    type t =
      {
      window_identities: MaintenanceWindowsForTargetList.t ;
      next_token: String.t option }
    let make ?(window_identities= [])  ?next_token  () =
      { window_identities; next_token }
    let parse xml =
      Some
        {
          window_identities =
            (Util.of_option []
               (Util.option_bind (Xml.member "WindowIdentities" xml)
                  MaintenanceWindowsForTargetList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "WindowIdentities"
                       ([], (MaintenanceWindowsForTargetList.to_xml [x]))))
               v.window_identities))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("window_identities",
               (MaintenanceWindowsForTargetList.to_json v.window_identities))])
    let of_json j =
      {
        window_identities =
          (MaintenanceWindowsForTargetList.of_json
             (Util.of_option_exn (Json.lookup j "window_identities")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeActivationsRequest =
  struct
    type t =
      {
      filters: DescribeActivationsFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(filters= [])  ?max_results  ?next_token  () =
      { filters; max_results; next_token }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  DescribeActivationsFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (DescribeActivationsFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("filters", (DescribeActivationsFilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (DescribeActivationsFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeregisterPatchBaselineForPatchGroupResult =
  struct
    type t = {
      baseline_id: String.t option ;
      patch_group: String.t option }
    let make ?baseline_id  ?patch_group  () = { baseline_id; patch_group }
    let parse xml =
      Some
        {
          baseline_id =
            (Util.option_bind (Xml.member "BaselineId" xml) String.parse);
          patch_group =
            (Util.option_bind (Xml.member "PatchGroup" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.baseline_id
               (fun f -> Ezxmlm.make_tag "BaselineId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.patch_group
              (fun f -> Ezxmlm.make_tag "PatchGroup" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.patch_group
              (fun f -> ("patch_group", (String.to_json f)));
           Util.option_map v.baseline_id
             (fun f -> ("baseline_id", (String.to_json f)))])
    let of_json j =
      {
        baseline_id =
          (Util.option_map (Json.lookup j "baseline_id") String.of_json);
        patch_group =
          (Util.option_map (Json.lookup j "patch_group") String.of_json)
      }
  end
module GetParametersRequest =
  struct
    type t = {
      names: ParameterNameList.t ;
      with_decryption: Boolean.t option }
    let make ~names  ?with_decryption  () = { names; with_decryption }
    let parse xml =
      Some
        {
          names =
            (Xml.required "Names"
               (Util.option_bind (Xml.member "Names" xml)
                  ParameterNameList.parse));
          with_decryption =
            (Util.option_bind (Xml.member "WithDecryption" xml) Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Names"
                       ([], (ParameterNameList.to_xml [x])))) v.names))
           @
           [Util.option_map v.with_decryption
              (fun f ->
                 Ezxmlm.make_tag "WithDecryption" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.with_decryption
              (fun f -> ("with_decryption", (Boolean.to_json f)));
           Some ("names", (ParameterNameList.to_json v.names))])
    let of_json j =
      {
        names =
          (ParameterNameList.of_json
             (Util.of_option_exn (Json.lookup j "names")));
        with_decryption =
          (Util.option_map (Json.lookup j "with_decryption") Boolean.of_json)
      }
  end
module ListCommandInvocationsRequest =
  struct
    type t =
      {
      command_id: String.t option ;
      instance_id: String.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      filters: CommandFilterList.t ;
      details: Boolean.t option }
    let make ?command_id  ?instance_id  ?max_results  ?next_token  ?(filters=
      [])  ?details  () =
      { command_id; instance_id; max_results; next_token; filters; details }
    let parse xml =
      Some
        {
          command_id =
            (Util.option_bind (Xml.member "CommandId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  CommandFilterList.parse));
          details =
            (Util.option_bind (Xml.member "Details" xml) Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((([] @
                [Util.option_map v.command_id
                   (fun f ->
                      Ezxmlm.make_tag "CommandId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.instance_id
                  (fun f ->
                     Ezxmlm.make_tag "InstanceId" ([], (String.to_xml f)))])
              @
              [Util.option_map v.max_results
                 (fun f ->
                    Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
             @
             [Util.option_map v.next_token
                (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Filters"
                       ([], (CommandFilterList.to_xml [x])))) v.filters))
           @
           [Util.option_map v.details
              (fun f -> Ezxmlm.make_tag "Details" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.details
              (fun f -> ("details", (Boolean.to_json f)));
           Some ("filters", (CommandFilterList.to_json v.filters));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.command_id
             (fun f -> ("command_id", (String.to_json f)))])
    let of_json j =
      {
        command_id =
          (Util.option_map (Json.lookup j "command_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        filters =
          (CommandFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        details = (Util.option_map (Json.lookup j "details") Boolean.of_json)
      }
  end
module InvalidFilterOption =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DuplicateDocumentContent =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module StopAutomationExecutionResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module ResetServiceSettingRequest =
  struct
    type t = {
      setting_id: String.t }
    let make ~setting_id  () = { setting_id }
    let parse xml =
      Some
        {
          setting_id =
            (Xml.required "SettingId"
               (Util.option_bind (Xml.member "SettingId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "SettingId" ([], (String.to_xml v.setting_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("setting_id", (String.to_json v.setting_id))])
    let of_json j =
      {
        setting_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "setting_id")))
      }
  end
module DescribeInstancePatchStatesResult =
  struct
    type t =
      {
      instance_patch_states: InstancePatchStateList.t ;
      next_token: String.t option }
    let make ?(instance_patch_states= [])  ?next_token  () =
      { instance_patch_states; next_token }
    let parse xml =
      Some
        {
          instance_patch_states =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstancePatchStates" xml)
                  InstancePatchStateList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "InstancePatchStates"
                       ([], (InstancePatchStateList.to_xml [x]))))
               v.instance_patch_states))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_patch_states",
               (InstancePatchStateList.to_json v.instance_patch_states))])
    let of_json j =
      {
        instance_patch_states =
          (InstancePatchStateList.of_json
             (Util.of_option_exn (Json.lookup j "instance_patch_states")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module UpdateDocumentRequest =
  struct
    type t =
      {
      content: String.t ;
      attachments: AttachmentsSourceList.t ;
      name: String.t ;
      version_name: String.t option ;
      document_version: String.t option ;
      document_format: DocumentFormat.t option ;
      target_type: String.t option }
    let make ~content  ?(attachments= [])  ~name  ?version_name 
      ?document_version  ?document_format  ?target_type  () =
      {
        content;
        attachments;
        name;
        version_name;
        document_version;
        document_format;
        target_type
      }
    let parse xml =
      Some
        {
          content =
            (Xml.required "Content"
               (Util.option_bind (Xml.member "Content" xml) String.parse));
          attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "Attachments" xml)
                  AttachmentsSourceList.parse));
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          version_name =
            (Util.option_bind (Xml.member "VersionName" xml) String.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          document_format =
            (Util.option_bind (Xml.member "DocumentFormat" xml)
               DocumentFormat.parse);
          target_type =
            (Util.option_bind (Xml.member "TargetType" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Some
                    (Ezxmlm.make_tag "Content"
                       ([], (String.to_xml v.content)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "Attachments"
                           ([], (AttachmentsSourceList.to_xml [x]))))
                   v.attachments))
               @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
              @
              [Util.option_map v.version_name
                 (fun f ->
                    Ezxmlm.make_tag "VersionName" ([], (String.to_xml f)))])
             @
             [Util.option_map v.document_version
                (fun f ->
                   Ezxmlm.make_tag "DocumentVersion" ([], (String.to_xml f)))])
            @
            [Util.option_map v.document_format
               (fun f ->
                  Ezxmlm.make_tag "DocumentFormat"
                    ([], (DocumentFormat.to_xml f)))])
           @
           [Util.option_map v.target_type
              (fun f -> Ezxmlm.make_tag "TargetType" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_type
              (fun f -> ("target_type", (String.to_json f)));
           Util.option_map v.document_format
             (fun f -> ("document_format", (DocumentFormat.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.version_name
             (fun f -> ("version_name", (String.to_json f)));
           Some ("name", (String.to_json v.name));
           Some
             ("attachments", (AttachmentsSourceList.to_json v.attachments));
           Some ("content", (String.to_json v.content))])
    let of_json j =
      {
        content =
          (String.of_json (Util.of_option_exn (Json.lookup j "content")));
        attachments =
          (AttachmentsSourceList.of_json
             (Util.of_option_exn (Json.lookup j "attachments")));
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        version_name =
          (Util.option_map (Json.lookup j "version_name") String.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        document_format =
          (Util.option_map (Json.lookup j "document_format")
             DocumentFormat.of_json);
        target_type =
          (Util.option_map (Json.lookup j "target_type") String.of_json)
      }
  end
module ModifyDocumentPermissionRequest =
  struct
    type t =
      {
      name: String.t ;
      permission_type: DocumentPermissionType.t ;
      account_ids_to_add: AccountIdList.t ;
      account_ids_to_remove: AccountIdList.t ;
      shared_document_version: String.t option }
    let make ~name  ~permission_type  ?(account_ids_to_add= []) 
      ?(account_ids_to_remove= [])  ?shared_document_version  () =
      {
        name;
        permission_type;
        account_ids_to_add;
        account_ids_to_remove;
        shared_document_version
      }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          permission_type =
            (Xml.required "PermissionType"
               (Util.option_bind (Xml.member "PermissionType" xml)
                  DocumentPermissionType.parse));
          account_ids_to_add =
            (Util.of_option []
               (Util.option_bind (Xml.member "AccountIdsToAdd" xml)
                  AccountIdList.parse));
          account_ids_to_remove =
            (Util.of_option []
               (Util.option_bind (Xml.member "AccountIdsToRemove" xml)
                  AccountIdList.parse));
          shared_document_version =
            (Util.option_bind (Xml.member "SharedDocumentVersion" xml)
               String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((([] @
               [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
              @
              [Some
                 (Ezxmlm.make_tag "PermissionType"
                    ([], (DocumentPermissionType.to_xml v.permission_type)))])
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "AccountIdsToAdd"
                        ([], (AccountIdList.to_xml [x]))))
                v.account_ids_to_add))
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "AccountIdsToRemove"
                       ([], (AccountIdList.to_xml [x]))))
               v.account_ids_to_remove))
           @
           [Util.option_map v.shared_document_version
              (fun f ->
                 Ezxmlm.make_tag "SharedDocumentVersion"
                   ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.shared_document_version
              (fun f -> ("shared_document_version", (String.to_json f)));
           Some
             ("account_ids_to_remove",
               (AccountIdList.to_json v.account_ids_to_remove));
           Some
             ("account_ids_to_add",
               (AccountIdList.to_json v.account_ids_to_add));
           Some
             ("permission_type",
               (DocumentPermissionType.to_json v.permission_type));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        permission_type =
          (DocumentPermissionType.of_json
             (Util.of_option_exn (Json.lookup j "permission_type")));
        account_ids_to_add =
          (AccountIdList.of_json
             (Util.of_option_exn (Json.lookup j "account_ids_to_add")));
        account_ids_to_remove =
          (AccountIdList.of_json
             (Util.of_option_exn (Json.lookup j "account_ids_to_remove")));
        shared_document_version =
          (Util.option_map (Json.lookup j "shared_document_version")
             String.of_json)
      }
  end
module RegisterTargetWithMaintenanceWindowRequest =
  struct
    type t =
      {
      window_id: String.t ;
      resource_type: MaintenanceWindowResourceType.t ;
      targets: Targets.t ;
      owner_information: String.t option ;
      name: String.t option ;
      description: String.t option ;
      client_token: String.t option }
    let make ~window_id  ~resource_type  ~targets  ?owner_information  ?name 
      ?description  ?client_token  () =
      {
        window_id;
        resource_type;
        targets;
        owner_information;
        name;
        description;
        client_token
      }
    let parse xml =
      Some
        {
          window_id =
            (Xml.required "WindowId"
               (Util.option_bind (Xml.member "WindowId" xml) String.parse));
          resource_type =
            (Xml.required "ResourceType"
               (Util.option_bind (Xml.member "ResourceType" xml)
                  MaintenanceWindowResourceType.parse));
          targets =
            (Xml.required "Targets"
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          owner_information =
            (Util.option_bind (Xml.member "OwnerInformation" xml)
               String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Some
                    (Ezxmlm.make_tag "WindowId"
                       ([], (String.to_xml v.window_id)))])
                @
                [Some
                   (Ezxmlm.make_tag "ResourceType"
                      ([],
                        (MaintenanceWindowResourceType.to_xml v.resource_type)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Targets" ([], (Targets.to_xml [x]))))
                  v.targets))
              @
              [Util.option_map v.owner_information
                 (fun f ->
                    Ezxmlm.make_tag "OwnerInformation"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.name
                (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
            @
            [Util.option_map v.description
               (fun f ->
                  Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
           @
           [Util.option_map v.client_token
              (fun f -> Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.owner_information
             (fun f -> ("owner_information", (String.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Some
             ("resource_type",
               (MaintenanceWindowResourceType.to_json v.resource_type));
           Some ("window_id", (String.to_json v.window_id))])
    let of_json j =
      {
        window_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "window_id")));
        resource_type =
          (MaintenanceWindowResourceType.of_json
             (Util.of_option_exn (Json.lookup j "resource_type")));
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        owner_information =
          (Util.option_map (Json.lookup j "owner_information") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module IncompatiblePolicyException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module TotalSizeLimitExceededException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module PutParameterRequest =
  struct
    type t =
      {
      name: String.t ;
      description: String.t option ;
      value: String.t ;
      type_: ParameterType.t ;
      key_id: String.t option ;
      overwrite: Boolean.t option ;
      allowed_pattern: String.t option ;
      tags: TagList.t ;
      tier: ParameterTier.t option ;
      policies: String.t option }
    let make ~name  ?description  ~value  ~type_  ?key_id  ?overwrite 
      ?allowed_pattern  ?(tags= [])  ?tier  ?policies  () =
      {
        name;
        description;
        value;
        type_;
        key_id;
        overwrite;
        allowed_pattern;
        tags;
        tier;
        policies
      }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          value =
            (Xml.required "Value"
               (Util.option_bind (Xml.member "Value" xml) String.parse));
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) ParameterType.parse));
          key_id = (Util.option_bind (Xml.member "KeyId" xml) String.parse);
          overwrite =
            (Util.option_bind (Xml.member "Overwrite" xml) Boolean.parse);
          allowed_pattern =
            (Util.option_bind (Xml.member "AllowedPattern" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tags" xml) TagList.parse));
          tier =
            (Util.option_bind (Xml.member "Tier" xml) ParameterTier.parse);
          policies =
            (Util.option_bind (Xml.member "Policies" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Some
                       (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
                   @
                   [Util.option_map v.description
                      (fun f ->
                         Ezxmlm.make_tag "Description"
                           ([], (String.to_xml f)))])
                  @
                  [Some
                     (Ezxmlm.make_tag "Value" ([], (String.to_xml v.value)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "Type"
                       ([], (ParameterType.to_xml v.type_)))])
                @
                [Util.option_map v.key_id
                   (fun f -> Ezxmlm.make_tag "KeyId" ([], (String.to_xml f)))])
               @
               [Util.option_map v.overwrite
                  (fun f ->
                     Ezxmlm.make_tag "Overwrite" ([], (Boolean.to_xml f)))])
              @
              [Util.option_map v.allowed_pattern
                 (fun f ->
                    Ezxmlm.make_tag "AllowedPattern" ([], (String.to_xml f)))])
             @
             (List.map
                (fun x ->
                   Some (Ezxmlm.make_tag "Tags" ([], (TagList.to_xml [x]))))
                v.tags))
            @
            [Util.option_map v.tier
               (fun f ->
                  Ezxmlm.make_tag "Tier" ([], (ParameterTier.to_xml f)))])
           @
           [Util.option_map v.policies
              (fun f -> Ezxmlm.make_tag "Policies" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.policies
              (fun f -> ("policies", (String.to_json f)));
           Util.option_map v.tier
             (fun f -> ("tier", (ParameterTier.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.allowed_pattern
             (fun f -> ("allowed_pattern", (String.to_json f)));
           Util.option_map v.overwrite
             (fun f -> ("overwrite", (Boolean.to_json f)));
           Util.option_map v.key_id (fun f -> ("key_id", (String.to_json f)));
           Some ("type_", (ParameterType.to_json v.type_));
           Some ("value", (String.to_json v.value));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        value = (String.of_json (Util.of_option_exn (Json.lookup j "value")));
        type_ =
          (ParameterType.of_json (Util.of_option_exn (Json.lookup j "type_")));
        key_id = (Util.option_map (Json.lookup j "key_id") String.of_json);
        overwrite =
          (Util.option_map (Json.lookup j "overwrite") Boolean.of_json);
        allowed_pattern =
          (Util.option_map (Json.lookup j "allowed_pattern") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        tier = (Util.option_map (Json.lookup j "tier") ParameterTier.of_json);
        policies =
          (Util.option_map (Json.lookup j "policies") String.of_json)
      }
  end
module CreateOpsItemRequest =
  struct
    type t =
      {
      description: String.t ;
      operational_data: OpsItemOperationalData.t option ;
      notifications: OpsItemNotifications.t ;
      priority: Integer.t option ;
      related_ops_items: RelatedOpsItems.t ;
      source: String.t ;
      title: String.t ;
      tags: TagList.t ;
      category: String.t option ;
      severity: String.t option }
    let make ~description  ?operational_data  ?(notifications= [])  ?priority
       ?(related_ops_items= [])  ~source  ~title  ?(tags= [])  ?category 
      ?severity  () =
      {
        description;
        operational_data;
        notifications;
        priority;
        related_ops_items;
        source;
        title;
        tags;
        category;
        severity
      }
    let parse xml =
      Some
        {
          description =
            (Xml.required "Description"
               (Util.option_bind (Xml.member "Description" xml) String.parse));
          operational_data =
            (Util.option_bind (Xml.member "OperationalData" xml)
               OpsItemOperationalData.parse);
          notifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "Notifications" xml)
                  OpsItemNotifications.parse));
          priority =
            (Util.option_bind (Xml.member "Priority" xml) Integer.parse);
          related_ops_items =
            (Util.of_option []
               (Util.option_bind (Xml.member "RelatedOpsItems" xml)
                  RelatedOpsItems.parse));
          source =
            (Xml.required "Source"
               (Util.option_bind (Xml.member "Source" xml) String.parse));
          title =
            (Xml.required "Title"
               (Util.option_bind (Xml.member "Title" xml) String.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tags" xml) TagList.parse));
          category =
            (Util.option_bind (Xml.member "Category" xml) String.parse);
          severity =
            (Util.option_bind (Xml.member "Severity" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Some
                       (Ezxmlm.make_tag "Description"
                          ([], (String.to_xml v.description)))])
                   @
                   [Util.option_map v.operational_data
                      (fun f ->
                         Ezxmlm.make_tag "OperationalData"
                           ([], (OpsItemOperationalData.to_xml f)))])
                  @
                  (List.map
                     (fun x ->
                        Some
                          (Ezxmlm.make_tag "Notifications"
                             ([], (OpsItemNotifications.to_xml [x]))))
                     v.notifications))
                 @
                 [Util.option_map v.priority
                    (fun f ->
                       Ezxmlm.make_tag "Priority" ([], (Integer.to_xml f)))])
                @
                (List.map
                   (fun x ->
                      Some
                        (Ezxmlm.make_tag "RelatedOpsItems"
                           ([], (RelatedOpsItems.to_xml [x]))))
                   v.related_ops_items))
               @
               [Some
                  (Ezxmlm.make_tag "Source" ([], (String.to_xml v.source)))])
              @
              [Some (Ezxmlm.make_tag "Title" ([], (String.to_xml v.title)))])
             @
             (List.map
                (fun x ->
                   Some (Ezxmlm.make_tag "Tags" ([], (TagList.to_xml [x]))))
                v.tags))
            @
            [Util.option_map v.category
               (fun f -> Ezxmlm.make_tag "Category" ([], (String.to_xml f)))])
           @
           [Util.option_map v.severity
              (fun f -> Ezxmlm.make_tag "Severity" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.severity
              (fun f -> ("severity", (String.to_json f)));
           Util.option_map v.category
             (fun f -> ("category", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Some ("title", (String.to_json v.title));
           Some ("source", (String.to_json v.source));
           Some
             ("related_ops_items",
               (RelatedOpsItems.to_json v.related_ops_items));
           Util.option_map v.priority
             (fun f -> ("priority", (Integer.to_json f)));
           Some
             ("notifications",
               (OpsItemNotifications.to_json v.notifications));
           Util.option_map v.operational_data
             (fun f ->
                ("operational_data", (OpsItemOperationalData.to_json f)));
           Some ("description", (String.to_json v.description))])
    let of_json j =
      {
        description =
          (String.of_json (Util.of_option_exn (Json.lookup j "description")));
        operational_data =
          (Util.option_map (Json.lookup j "operational_data")
             OpsItemOperationalData.of_json);
        notifications =
          (OpsItemNotifications.of_json
             (Util.of_option_exn (Json.lookup j "notifications")));
        priority =
          (Util.option_map (Json.lookup j "priority") Integer.of_json);
        related_ops_items =
          (RelatedOpsItems.of_json
             (Util.of_option_exn (Json.lookup j "related_ops_items")));
        source =
          (String.of_json (Util.of_option_exn (Json.lookup j "source")));
        title = (String.of_json (Util.of_option_exn (Json.lookup j "title")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        category =
          (Util.option_map (Json.lookup j "category") String.of_json);
        severity =
          (Util.option_map (Json.lookup j "severity") String.of_json)
      }
  end
module DeleteParameterResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module ListCommandInvocationsResult =
  struct
    type t =
      {
      command_invocations: CommandInvocationList.t ;
      next_token: String.t option }
    let make ?(command_invocations= [])  ?next_token  () =
      { command_invocations; next_token }
    let parse xml =
      Some
        {
          command_invocations =
            (Util.of_option []
               (Util.option_bind (Xml.member "CommandInvocations" xml)
                  CommandInvocationList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "CommandInvocations"
                       ([], (CommandInvocationList.to_xml [x]))))
               v.command_invocations))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("command_invocations",
               (CommandInvocationList.to_json v.command_invocations))])
    let of_json j =
      {
        command_invocations =
          (CommandInvocationList.of_json
             (Util.of_option_exn (Json.lookup j "command_invocations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module RemoveTagsFromResourceResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module DescribeMaintenanceWindowsRequest =
  struct
    type t =
      {
      filters: MaintenanceWindowFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(filters= [])  ?max_results  ?next_token  () =
      { filters; max_results; next_token }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  MaintenanceWindowFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "Filters"
                        ([], (MaintenanceWindowFilterList.to_xml [x]))))
                v.filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (MaintenanceWindowFilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (MaintenanceWindowFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module UnsupportedInventoryItemContextException =
  struct
    type t = {
      type_name: String.t option ;
      message: String.t option }
    let make ?type_name  ?message  () = { type_name; message }
    let parse xml =
      Some
        {
          type_name =
            (Util.option_bind (Xml.member "TypeName" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.type_name
               (fun f -> Ezxmlm.make_tag "TypeName" ([], (String.to_xml f)))])
           @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.type_name
             (fun f -> ("type_name", (String.to_json f)))])
    let of_json j =
      {
        type_name =
          (Util.option_map (Json.lookup j "type_name") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module UnsupportedFeatureRequiredException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ResetServiceSettingResult =
  struct
    type t = {
      service_setting: ServiceSetting.t option }
    let make ?service_setting  () = { service_setting }
    let parse xml =
      Some
        {
          service_setting =
            (Util.option_bind (Xml.member "ServiceSetting" xml)
               ServiceSetting.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.service_setting
              (fun f ->
                 Ezxmlm.make_tag "ServiceSetting"
                   ([], (ServiceSetting.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.service_setting
              (fun f -> ("service_setting", (ServiceSetting.to_json f)))])
    let of_json j =
      {
        service_setting =
          (Util.option_map (Json.lookup j "service_setting")
             ServiceSetting.of_json)
      }
  end
module DeleteAssociationResult =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module HierarchyTypeMismatchException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module InvalidActivation =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module StopAutomationExecutionRequest =
  struct
    type t = {
      automation_execution_id: String.t ;
      type_: StopType.t option }
    let make ~automation_execution_id  ?type_  () =
      { automation_execution_id; type_ }
    let parse xml =
      Some
        {
          automation_execution_id =
            (Xml.required "AutomationExecutionId"
               (Util.option_bind (Xml.member "AutomationExecutionId" xml)
                  String.parse));
          type_ = (Util.option_bind (Xml.member "Type" xml) StopType.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "AutomationExecutionId"
                  ([], (String.to_xml v.automation_execution_id)))])
           @
           [Util.option_map v.type_
              (fun f -> Ezxmlm.make_tag "Type" ([], (StopType.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> ("type_", (StopType.to_json f)));
           Some
             ("automation_execution_id",
               (String.to_json v.automation_execution_id))])
    let of_json j =
      {
        automation_execution_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "automation_execution_id")));
        type_ = (Util.option_map (Json.lookup j "type_") StopType.of_json)
      }
  end
module PutInventoryRequest =
  struct
    type t = {
      instance_id: String.t ;
      items: InventoryItemList.t }
    let make ~instance_id  ~items  () = { instance_id; items }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          items =
            (Xml.required "Items"
               (Util.option_bind (Xml.member "Items" xml)
                  InventoryItemList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Some
               (Ezxmlm.make_tag "InstanceId"
                  ([], (String.to_xml v.instance_id)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Items"
                      ([], (InventoryItemList.to_xml [x])))) v.items))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("items", (InventoryItemList.to_json v.items));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        items =
          (InventoryItemList.of_json
             (Util.of_option_exn (Json.lookup j "items")))
      }
  end
module RegisterDefaultPatchBaselineResult =
  struct
    type t = {
      baseline_id: String.t option }
    let make ?baseline_id  () = { baseline_id }
    let parse xml =
      Some
        {
          baseline_id =
            (Util.option_bind (Xml.member "BaselineId" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.baseline_id
              (fun f -> Ezxmlm.make_tag "BaselineId" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.baseline_id
              (fun f -> ("baseline_id", (String.to_json f)))])
    let of_json j =
      {
        baseline_id =
          (Util.option_map (Json.lookup j "baseline_id") String.of_json)
      }
  end
module DeleteParametersResult =
  struct
    type t =
      {
      deleted_parameters: ParameterNameList.t ;
      invalid_parameters: ParameterNameList.t }
    let make ?(deleted_parameters= [])  ?(invalid_parameters= [])  () =
      { deleted_parameters; invalid_parameters }
    let parse xml =
      Some
        {
          deleted_parameters =
            (Util.of_option []
               (Util.option_bind (Xml.member "DeletedParameters" xml)
                  ParameterNameList.parse));
          invalid_parameters =
            (Util.of_option []
               (Util.option_bind (Xml.member "InvalidParameters" xml)
                  ParameterNameList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "DeletedParameters"
                       ([], (ParameterNameList.to_xml [x]))))
               v.deleted_parameters))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "InvalidParameters"
                      ([], (ParameterNameList.to_xml [x]))))
              v.invalid_parameters))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("invalid_parameters",
                (ParameterNameList.to_json v.invalid_parameters));
           Some
             ("deleted_parameters",
               (ParameterNameList.to_json v.deleted_parameters))])
    let of_json j =
      {
        deleted_parameters =
          (ParameterNameList.of_json
             (Util.of_option_exn (Json.lookup j "deleted_parameters")));
        invalid_parameters =
          (ParameterNameList.of_json
             (Util.of_option_exn (Json.lookup j "invalid_parameters")))
      }
  end
module ParameterPatternMismatchException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module InvalidInventoryGroupException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeOpsItemsRequest =
  struct
    type t =
      {
      ops_item_filters: OpsItemFilters.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(ops_item_filters= [])  ?max_results  ?next_token  () =
      { ops_item_filters; max_results; next_token }
    let parse xml =
      Some
        {
          ops_item_filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "OpsItemFilters" xml)
                  OpsItemFilters.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "OpsItemFilters"
                        ([], (OpsItemFilters.to_xml [x]))))
                v.ops_item_filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("ops_item_filters",
               (OpsItemFilters.to_json v.ops_item_filters))])
    let of_json j =
      {
        ops_item_filters =
          (OpsItemFilters.of_json
             (Util.of_option_exn (Json.lookup j "ops_item_filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module IdempotentParameterMismatch =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribePatchGroupsRequest =
  struct
    type t =
      {
      max_results: Integer.t option ;
      filters: PatchOrchestratorFilterList.t ;
      next_token: String.t option }
    let make ?max_results  ?(filters= [])  ?next_token  () =
      { max_results; filters; next_token }
    let parse xml =
      Some
        {
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  PatchOrchestratorFilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Util.option_map v.max_results
                (fun f ->
                   Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Filters"
                       ([], (PatchOrchestratorFilterList.to_xml [x]))))
               v.filters))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (PatchOrchestratorFilterList.to_json v.filters));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)))])
    let of_json j =
      {
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        filters =
          (PatchOrchestratorFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateMaintenanceWindowRequest =
  struct
    type t =
      {
      name: String.t ;
      description: String.t option ;
      start_date: String.t option ;
      end_date: String.t option ;
      schedule: String.t ;
      schedule_timezone: String.t option ;
      duration: Integer.t ;
      cutoff: Integer.t ;
      allow_unassociated_targets: Boolean.t ;
      client_token: String.t option ;
      tags: TagList.t }
    let make ~name  ?description  ?start_date  ?end_date  ~schedule 
      ?schedule_timezone  ~duration  ~cutoff  ~allow_unassociated_targets 
      ?client_token  ?(tags= [])  () =
      {
        name;
        description;
        start_date;
        end_date;
        schedule;
        schedule_timezone;
        duration;
        cutoff;
        allow_unassociated_targets;
        client_token;
        tags
      }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          start_date =
            (Util.option_bind (Xml.member "StartDate" xml) String.parse);
          end_date =
            (Util.option_bind (Xml.member "EndDate" xml) String.parse);
          schedule =
            (Xml.required "Schedule"
               (Util.option_bind (Xml.member "Schedule" xml) String.parse));
          schedule_timezone =
            (Util.option_bind (Xml.member "ScheduleTimezone" xml)
               String.parse);
          duration =
            (Xml.required "Duration"
               (Util.option_bind (Xml.member "Duration" xml) Integer.parse));
          cutoff =
            (Xml.required "Cutoff"
               (Util.option_bind (Xml.member "Cutoff" xml) Integer.parse));
          allow_unassociated_targets =
            (Xml.required "AllowUnassociatedTargets"
               (Util.option_bind (Xml.member "AllowUnassociatedTargets" xml)
                  Boolean.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tags" xml) TagList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((([] @
                     [Some
                        (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
                    @
                    [Util.option_map v.description
                       (fun f ->
                          Ezxmlm.make_tag "Description"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.start_date
                      (fun f ->
                         Ezxmlm.make_tag "StartDate" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.end_date
                     (fun f ->
                        Ezxmlm.make_tag "EndDate" ([], (String.to_xml f)))])
                 @
                 [Some
                    (Ezxmlm.make_tag "Schedule"
                       ([], (String.to_xml v.schedule)))])
                @
                [Util.option_map v.schedule_timezone
                   (fun f ->
                      Ezxmlm.make_tag "ScheduleTimezone"
                        ([], (String.to_xml f)))])
               @
               [Some
                  (Ezxmlm.make_tag "Duration"
                     ([], (Integer.to_xml v.duration)))])
              @
              [Some
                 (Ezxmlm.make_tag "Cutoff" ([], (Integer.to_xml v.cutoff)))])
             @
             [Some
                (Ezxmlm.make_tag "AllowUnassociatedTargets"
                   ([], (Boolean.to_xml v.allow_unassociated_targets)))])
            @
            [Util.option_map v.client_token
               (fun f ->
                  Ezxmlm.make_tag "ClientToken" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some (Ezxmlm.make_tag "Tags" ([], (TagList.to_xml [x]))))
              v.tags))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some
             ("allow_unassociated_targets",
               (Boolean.to_json v.allow_unassociated_targets));
           Some ("cutoff", (Integer.to_json v.cutoff));
           Some ("duration", (Integer.to_json v.duration));
           Util.option_map v.schedule_timezone
             (fun f -> ("schedule_timezone", (String.to_json f)));
           Some ("schedule", (String.to_json v.schedule));
           Util.option_map v.end_date
             (fun f -> ("end_date", (String.to_json f)));
           Util.option_map v.start_date
             (fun f -> ("start_date", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        start_date =
          (Util.option_map (Json.lookup j "start_date") String.of_json);
        end_date =
          (Util.option_map (Json.lookup j "end_date") String.of_json);
        schedule =
          (String.of_json (Util.of_option_exn (Json.lookup j "schedule")));
        schedule_timezone =
          (Util.option_map (Json.lookup j "schedule_timezone") String.of_json);
        duration =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "duration")));
        cutoff =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "cutoff")));
        allow_unassociated_targets =
          (Boolean.of_json
             (Util.of_option_exn (Json.lookup j "allow_unassociated_targets")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ResourceDataSyncConflictException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module GetPatchBaselineResult =
  struct
    type t =
      {
      baseline_id: String.t option ;
      name: String.t option ;
      operating_system: OperatingSystem.t option ;
      global_filters: PatchFilterGroup.t option ;
      approval_rules: PatchRuleGroup.t option ;
      approved_patches: PatchIdList.t ;
      approved_patches_compliance_level: PatchComplianceLevel.t option ;
      approved_patches_enable_non_security: Boolean.t option ;
      rejected_patches: PatchIdList.t ;
      rejected_patches_action: PatchAction.t option ;
      patch_groups: PatchGroupList.t ;
      created_date: DateTime.t option ;
      modified_date: DateTime.t option ;
      description: String.t option ;
      sources: PatchSourceList.t }
    let make ?baseline_id  ?name  ?operating_system  ?global_filters 
      ?approval_rules  ?(approved_patches= []) 
      ?approved_patches_compliance_level 
      ?approved_patches_enable_non_security  ?(rejected_patches= []) 
      ?rejected_patches_action  ?(patch_groups= [])  ?created_date 
      ?modified_date  ?description  ?(sources= [])  () =
      {
        baseline_id;
        name;
        operating_system;
        global_filters;
        approval_rules;
        approved_patches;
        approved_patches_compliance_level;
        approved_patches_enable_non_security;
        rejected_patches;
        rejected_patches_action;
        patch_groups;
        created_date;
        modified_date;
        description;
        sources
      }
    let parse xml =
      Some
        {
          baseline_id =
            (Util.option_bind (Xml.member "BaselineId" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          operating_system =
            (Util.option_bind (Xml.member "OperatingSystem" xml)
               OperatingSystem.parse);
          global_filters =
            (Util.option_bind (Xml.member "GlobalFilters" xml)
               PatchFilterGroup.parse);
          approval_rules =
            (Util.option_bind (Xml.member "ApprovalRules" xml)
               PatchRuleGroup.parse);
          approved_patches =
            (Util.of_option []
               (Util.option_bind (Xml.member "ApprovedPatches" xml)
                  PatchIdList.parse));
          approved_patches_compliance_level =
            (Util.option_bind
               (Xml.member "ApprovedPatchesComplianceLevel" xml)
               PatchComplianceLevel.parse);
          approved_patches_enable_non_security =
            (Util.option_bind
               (Xml.member "ApprovedPatchesEnableNonSecurity" xml)
               Boolean.parse);
          rejected_patches =
            (Util.of_option []
               (Util.option_bind (Xml.member "RejectedPatches" xml)
                  PatchIdList.parse));
          rejected_patches_action =
            (Util.option_bind (Xml.member "RejectedPatchesAction" xml)
               PatchAction.parse);
          patch_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "PatchGroups" xml)
                  PatchGroupList.parse));
          created_date =
            (Util.option_bind (Xml.member "CreatedDate" xml) DateTime.parse);
          modified_date =
            (Util.option_bind (Xml.member "ModifiedDate" xml) DateTime.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          sources =
            (Util.of_option []
               (Util.option_bind (Xml.member "Sources" xml)
                  PatchSourceList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((([] @
                         [Util.option_map v.baseline_id
                            (fun f ->
                               Ezxmlm.make_tag "BaselineId"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.name
                           (fun f ->
                              Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.operating_system
                          (fun f ->
                             Ezxmlm.make_tag "OperatingSystem"
                               ([], (OperatingSystem.to_xml f)))])
                      @
                      [Util.option_map v.global_filters
                         (fun f ->
                            Ezxmlm.make_tag "GlobalFilters"
                              ([], (PatchFilterGroup.to_xml f)))])
                     @
                     [Util.option_map v.approval_rules
                        (fun f ->
                           Ezxmlm.make_tag "ApprovalRules"
                             ([], (PatchRuleGroup.to_xml f)))])
                    @
                    (List.map
                       (fun x ->
                          Some
                            (Ezxmlm.make_tag "ApprovedPatches"
                               ([], (PatchIdList.to_xml [x]))))
                       v.approved_patches))
                   @
                   [Util.option_map v.approved_patches_compliance_level
                      (fun f ->
                         Ezxmlm.make_tag "ApprovedPatchesComplianceLevel"
                           ([], (PatchComplianceLevel.to_xml f)))])
                  @
                  [Util.option_map v.approved_patches_enable_non_security
                     (fun f ->
                        Ezxmlm.make_tag "ApprovedPatchesEnableNonSecurity"
                          ([], (Boolean.to_xml f)))])
                 @
                 (List.map
                    (fun x ->
                       Some
                         (Ezxmlm.make_tag "RejectedPatches"
                            ([], (PatchIdList.to_xml [x]))))
                    v.rejected_patches))
                @
                [Util.option_map v.rejected_patches_action
                   (fun f ->
                      Ezxmlm.make_tag "RejectedPatchesAction"
                        ([], (PatchAction.to_xml f)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "PatchGroups"
                          ([], (PatchGroupList.to_xml [x])))) v.patch_groups))
              @
              [Util.option_map v.created_date
                 (fun f ->
                    Ezxmlm.make_tag "CreatedDate" ([], (DateTime.to_xml f)))])
             @
             [Util.option_map v.modified_date
                (fun f ->
                   Ezxmlm.make_tag "ModifiedDate" ([], (DateTime.to_xml f)))])
            @
            [Util.option_map v.description
               (fun f ->
                  Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "Sources"
                      ([], (PatchSourceList.to_xml [x])))) v.sources))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("sources", (PatchSourceList.to_json v.sources));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.modified_date
             (fun f -> ("modified_date", (DateTime.to_json f)));
           Util.option_map v.created_date
             (fun f -> ("created_date", (DateTime.to_json f)));
           Some ("patch_groups", (PatchGroupList.to_json v.patch_groups));
           Util.option_map v.rejected_patches_action
             (fun f -> ("rejected_patches_action", (PatchAction.to_json f)));
           Some
             ("rejected_patches", (PatchIdList.to_json v.rejected_patches));
           Util.option_map v.approved_patches_enable_non_security
             (fun f ->
                ("approved_patches_enable_non_security", (Boolean.to_json f)));
           Util.option_map v.approved_patches_compliance_level
             (fun f ->
                ("approved_patches_compliance_level",
                  (PatchComplianceLevel.to_json f)));
           Some
             ("approved_patches", (PatchIdList.to_json v.approved_patches));
           Util.option_map v.approval_rules
             (fun f -> ("approval_rules", (PatchRuleGroup.to_json f)));
           Util.option_map v.global_filters
             (fun f -> ("global_filters", (PatchFilterGroup.to_json f)));
           Util.option_map v.operating_system
             (fun f -> ("operating_system", (OperatingSystem.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.baseline_id
             (fun f -> ("baseline_id", (String.to_json f)))])
    let of_json j =
      {
        baseline_id =
          (Util.option_map (Json.lookup j "baseline_id") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        operating_system =
          (Util.option_map (Json.lookup j "operating_system")
             OperatingSystem.of_json);
        global_filters =
          (Util.option_map (Json.lookup j "global_filters")
             PatchFilterGroup.of_json);
        approval_rules =
          (Util.option_map (Json.lookup j "approval_rules")
             PatchRuleGroup.of_json);
        approved_patches =
          (PatchIdList.of_json
             (Util.of_option_exn (Json.lookup j "approved_patches")));
        approved_patches_compliance_level =
          (Util.option_map
             (Json.lookup j "approved_patches_compliance_level")
             PatchComplianceLevel.of_json);
        approved_patches_enable_non_security =
          (Util.option_map
             (Json.lookup j "approved_patches_enable_non_security")
             Boolean.of_json);
        rejected_patches =
          (PatchIdList.of_json
             (Util.of_option_exn (Json.lookup j "rejected_patches")));
        rejected_patches_action =
          (Util.option_map (Json.lookup j "rejected_patches_action")
             PatchAction.of_json);
        patch_groups =
          (PatchGroupList.of_json
             (Util.of_option_exn (Json.lookup j "patch_groups")));
        created_date =
          (Util.option_map (Json.lookup j "created_date") DateTime.of_json);
        modified_date =
          (Util.option_map (Json.lookup j "modified_date") DateTime.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        sources =
          (PatchSourceList.of_json
             (Util.of_option_exn (Json.lookup j "sources")))
      }
  end
module GetDocumentResult =
  struct
    type t =
      {
      name: String.t option ;
      version_name: String.t option ;
      document_version: String.t option ;
      status: DocumentStatus.t option ;
      status_information: String.t option ;
      content: String.t option ;
      document_type: DocumentType.t option ;
      document_format: DocumentFormat.t option ;
      requires: DocumentRequiresList.t ;
      attachments_content: AttachmentContentList.t }
    let make ?name  ?version_name  ?document_version  ?status 
      ?status_information  ?content  ?document_type  ?document_format 
      ?(requires= [])  ?(attachments_content= [])  () =
      {
        name;
        version_name;
        document_version;
        status;
        status_information;
        content;
        document_type;
        document_format;
        requires;
        attachments_content
      }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          version_name =
            (Util.option_bind (Xml.member "VersionName" xml) String.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml) DocumentStatus.parse);
          status_information =
            (Util.option_bind (Xml.member "StatusInformation" xml)
               String.parse);
          content =
            (Util.option_bind (Xml.member "Content" xml) String.parse);
          document_type =
            (Util.option_bind (Xml.member "DocumentType" xml)
               DocumentType.parse);
          document_format =
            (Util.option_bind (Xml.member "DocumentFormat" xml)
               DocumentFormat.parse);
          requires =
            (Util.of_option []
               (Util.option_bind (Xml.member "Requires" xml)
                  DocumentRequiresList.parse));
          attachments_content =
            (Util.of_option []
               (Util.option_bind (Xml.member "AttachmentsContent" xml)
                  AttachmentContentList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((([] @
                    [Util.option_map v.name
                       (fun f ->
                          Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.version_name
                      (fun f ->
                         Ezxmlm.make_tag "VersionName"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.document_version
                     (fun f ->
                        Ezxmlm.make_tag "DocumentVersion"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.status
                    (fun f ->
                       Ezxmlm.make_tag "Status"
                         ([], (DocumentStatus.to_xml f)))])
                @
                [Util.option_map v.status_information
                   (fun f ->
                      Ezxmlm.make_tag "StatusInformation"
                        ([], (String.to_xml f)))])
               @
               [Util.option_map v.content
                  (fun f -> Ezxmlm.make_tag "Content" ([], (String.to_xml f)))])
              @
              [Util.option_map v.document_type
                 (fun f ->
                    Ezxmlm.make_tag "DocumentType"
                      ([], (DocumentType.to_xml f)))])
             @
             [Util.option_map v.document_format
                (fun f ->
                   Ezxmlm.make_tag "DocumentFormat"
                     ([], (DocumentFormat.to_xml f)))])
            @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Requires"
                       ([], (DocumentRequiresList.to_xml [x])))) v.requires))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "AttachmentsContent"
                      ([], (AttachmentContentList.to_xml [x]))))
              v.attachments_content))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("attachments_content",
                (AttachmentContentList.to_json v.attachments_content));
           Some ("requires", (DocumentRequiresList.to_json v.requires));
           Util.option_map v.document_format
             (fun f -> ("document_format", (DocumentFormat.to_json f)));
           Util.option_map v.document_type
             (fun f -> ("document_type", (DocumentType.to_json f)));
           Util.option_map v.content
             (fun f -> ("content", (String.to_json f)));
           Util.option_map v.status_information
             (fun f -> ("status_information", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (DocumentStatus.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.version_name
             (fun f -> ("version_name", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        version_name =
          (Util.option_map (Json.lookup j "version_name") String.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") DocumentStatus.of_json);
        status_information =
          (Util.option_map (Json.lookup j "status_information")
             String.of_json);
        content = (Util.option_map (Json.lookup j "content") String.of_json);
        document_type =
          (Util.option_map (Json.lookup j "document_type")
             DocumentType.of_json);
        document_format =
          (Util.option_map (Json.lookup j "document_format")
             DocumentFormat.of_json);
        requires =
          (DocumentRequiresList.of_json
             (Util.of_option_exn (Json.lookup j "requires")));
        attachments_content =
          (AttachmentContentList.of_json
             (Util.of_option_exn (Json.lookup j "attachments_content")))
      }
  end
module GetMaintenanceWindowExecutionRequest =
  struct
    type t = {
      window_execution_id: String.t }
    let make ~window_execution_id  () = { window_execution_id }
    let parse xml =
      Some
        {
          window_execution_id =
            (Xml.required "WindowExecutionId"
               (Util.option_bind (Xml.member "WindowExecutionId" xml)
                  String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "WindowExecutionId"
                 ([], (String.to_xml v.window_execution_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("window_execution_id", (String.to_json v.window_execution_id))])
    let of_json j =
      {
        window_execution_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "window_execution_id")))
      }
  end
module ResumeSessionRequest =
  struct
    type t = {
      session_id: String.t }
    let make ~session_id  () = { session_id }
    let parse xml =
      Some
        {
          session_id =
            (Xml.required "SessionId"
               (Util.option_bind (Xml.member "SessionId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "SessionId" ([], (String.to_xml v.session_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("session_id", (String.to_json v.session_id))])
    let of_json j =
      {
        session_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "session_id")))
      }
  end
module ListResourceDataSyncResult =
  struct
    type t =
      {
      resource_data_sync_items: ResourceDataSyncItemList.t ;
      next_token: String.t option }
    let make ?(resource_data_sync_items= [])  ?next_token  () =
      { resource_data_sync_items; next_token }
    let parse xml =
      Some
        {
          resource_data_sync_items =
            (Util.of_option []
               (Util.option_bind (Xml.member "ResourceDataSyncItems" xml)
                  ResourceDataSyncItemList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "ResourceDataSyncItems"
                       ([], (ResourceDataSyncItemList.to_xml [x]))))
               v.resource_data_sync_items))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("resource_data_sync_items",
               (ResourceDataSyncItemList.to_json v.resource_data_sync_items))])
    let of_json j =
      {
        resource_data_sync_items =
          (ResourceDataSyncItemList.of_json
             (Util.of_option_exn (Json.lookup j "resource_data_sync_items")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetOpsItemRequest =
  struct
    type t = {
      ops_item_id: String.t }
    let make ~ops_item_id  () = { ops_item_id }
    let parse xml =
      Some
        {
          ops_item_id =
            (Xml.required "OpsItemId"
               (Util.option_bind (Xml.member "OpsItemId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "OpsItemId"
                 ([], (String.to_xml v.ops_item_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("ops_item_id", (String.to_json v.ops_item_id))])
    let of_json j =
      {
        ops_item_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "ops_item_id")))
      }
  end
module DoesNotExistException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module UnsupportedInventorySchemaVersionException =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeEffectivePatchesForPatchBaselineRequest =
  struct
    type t =
      {
      baseline_id: String.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ~baseline_id  ?max_results  ?next_token  () =
      { baseline_id; max_results; next_token }
    let parse xml =
      Some
        {
          baseline_id =
            (Xml.required "BaselineId"
               (Util.option_bind (Xml.member "BaselineId" xml) String.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((([] @
             [Some
                (Ezxmlm.make_tag "BaselineId"
                   ([], (String.to_xml v.baseline_id)))])
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("baseline_id", (String.to_json v.baseline_id))])
    let of_json j =
      {
        baseline_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "baseline_id")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetParametersResult =
  struct
    type t =
      {
      parameters: ParameterList.t ;
      invalid_parameters: ParameterNameList.t }
    let make ?(parameters= [])  ?(invalid_parameters= [])  () =
      { parameters; invalid_parameters }
    let parse xml =
      Some
        {
          parameters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Parameters" xml)
                  ParameterList.parse));
          invalid_parameters =
            (Util.of_option []
               (Util.option_bind (Xml.member "InvalidParameters" xml)
                  ParameterNameList.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Parameters"
                       ([], (ParameterList.to_xml [x])))) v.parameters))
           @
           (List.map
              (fun x ->
                 Some
                   (Ezxmlm.make_tag "InvalidParameters"
                      ([], (ParameterNameList.to_xml [x]))))
              v.invalid_parameters))
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("invalid_parameters",
                (ParameterNameList.to_json v.invalid_parameters));
           Some ("parameters", (ParameterList.to_json v.parameters))])
    let of_json j =
      {
        parameters =
          (ParameterList.of_json
             (Util.of_option_exn (Json.lookup j "parameters")));
        invalid_parameters =
          (ParameterNameList.of_json
             (Util.of_option_exn (Json.lookup j "invalid_parameters")))
      }
  end
module GetParameterHistoryRequest =
  struct
    type t =
      {
      name: String.t ;
      with_decryption: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ~name  ?with_decryption  ?max_results  ?next_token  () =
      { name; with_decryption; max_results; next_token }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          with_decryption =
            (Util.option_bind (Xml.member "WithDecryption" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @ [Some (Ezxmlm.make_tag "Name" ([], (String.to_xml v.name)))])
             @
             [Util.option_map v.with_decryption
                (fun f ->
                   Ezxmlm.make_tag "WithDecryption" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.with_decryption
             (fun f -> ("with_decryption", (Boolean.to_json f)));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        with_decryption =
          (Util.option_map (Json.lookup j "with_decryption") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeMaintenanceWindowsForTargetRequest =
  struct
    type t =
      {
      targets: Targets.t ;
      resource_type: MaintenanceWindowResourceType.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ~targets  ~resource_type  ?max_results  ?next_token  () =
      { targets; resource_type; max_results; next_token }
    let parse xml =
      Some
        {
          targets =
            (Xml.required "Targets"
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          resource_type =
            (Xml.required "ResourceType"
               (Util.option_bind (Xml.member "ResourceType" xml)
                  MaintenanceWindowResourceType.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Targets" ([], (Targets.to_xml [x]))))
                 v.targets))
             @
             [Some
                (Ezxmlm.make_tag "ResourceType"
                   ([],
                     (MaintenanceWindowResourceType.to_xml v.resource_type)))])
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("resource_type",
               (MaintenanceWindowResourceType.to_json v.resource_type));
           Some ("targets", (Targets.to_json v.targets))])
    let of_json j =
      {
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        resource_type =
          (MaintenanceWindowResourceType.of_json
             (Util.of_option_exn (Json.lookup j "resource_type")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetMaintenanceWindowResult =
  struct
    type t =
      {
      window_id: String.t option ;
      name: String.t option ;
      description: String.t option ;
      start_date: String.t option ;
      end_date: String.t option ;
      schedule: String.t option ;
      schedule_timezone: String.t option ;
      next_execution_time: String.t option ;
      duration: Integer.t option ;
      cutoff: Integer.t option ;
      allow_unassociated_targets: Boolean.t option ;
      enabled: Boolean.t option ;
      created_date: DateTime.t option ;
      modified_date: DateTime.t option }
    let make ?window_id  ?name  ?description  ?start_date  ?end_date 
      ?schedule  ?schedule_timezone  ?next_execution_time  ?duration  ?cutoff
       ?allow_unassociated_targets  ?enabled  ?created_date  ?modified_date 
      () =
      {
        window_id;
        name;
        description;
        start_date;
        end_date;
        schedule;
        schedule_timezone;
        next_execution_time;
        duration;
        cutoff;
        allow_unassociated_targets;
        enabled;
        created_date;
        modified_date
      }
    let parse xml =
      Some
        {
          window_id =
            (Util.option_bind (Xml.member "WindowId" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          start_date =
            (Util.option_bind (Xml.member "StartDate" xml) String.parse);
          end_date =
            (Util.option_bind (Xml.member "EndDate" xml) String.parse);
          schedule =
            (Util.option_bind (Xml.member "Schedule" xml) String.parse);
          schedule_timezone =
            (Util.option_bind (Xml.member "ScheduleTimezone" xml)
               String.parse);
          next_execution_time =
            (Util.option_bind (Xml.member "NextExecutionTime" xml)
               String.parse);
          duration =
            (Util.option_bind (Xml.member "Duration" xml) Integer.parse);
          cutoff = (Util.option_bind (Xml.member "Cutoff" xml) Integer.parse);
          allow_unassociated_targets =
            (Util.option_bind (Xml.member "AllowUnassociatedTargets" xml)
               Boolean.parse);
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse);
          created_date =
            (Util.option_bind (Xml.member "CreatedDate" xml) DateTime.parse);
          modified_date =
            (Util.option_bind (Xml.member "ModifiedDate" xml) DateTime.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((((((((((((([] @
                        [Util.option_map v.window_id
                           (fun f ->
                              Ezxmlm.make_tag "WindowId"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.name
                          (fun f ->
                             Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.description
                         (fun f ->
                            Ezxmlm.make_tag "Description"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.start_date
                        (fun f ->
                           Ezxmlm.make_tag "StartDate"
                             ([], (String.to_xml f)))])
                    @
                    [Util.option_map v.end_date
                       (fun f ->
                          Ezxmlm.make_tag "EndDate" ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.schedule
                      (fun f ->
                         Ezxmlm.make_tag "Schedule" ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.schedule_timezone
                     (fun f ->
                        Ezxmlm.make_tag "ScheduleTimezone"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.next_execution_time
                    (fun f ->
                       Ezxmlm.make_tag "NextExecutionTime"
                         ([], (String.to_xml f)))])
                @
                [Util.option_map v.duration
                   (fun f ->
                      Ezxmlm.make_tag "Duration" ([], (Integer.to_xml f)))])
               @
               [Util.option_map v.cutoff
                  (fun f -> Ezxmlm.make_tag "Cutoff" ([], (Integer.to_xml f)))])
              @
              [Util.option_map v.allow_unassociated_targets
                 (fun f ->
                    Ezxmlm.make_tag "AllowUnassociatedTargets"
                      ([], (Boolean.to_xml f)))])
             @
             [Util.option_map v.enabled
                (fun f -> Ezxmlm.make_tag "Enabled" ([], (Boolean.to_xml f)))])
            @
            [Util.option_map v.created_date
               (fun f ->
                  Ezxmlm.make_tag "CreatedDate" ([], (DateTime.to_xml f)))])
           @
           [Util.option_map v.modified_date
              (fun f ->
                 Ezxmlm.make_tag "ModifiedDate" ([], (DateTime.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.modified_date
              (fun f -> ("modified_date", (DateTime.to_json f)));
           Util.option_map v.created_date
             (fun f -> ("created_date", (DateTime.to_json f)));
           Util.option_map v.enabled
             (fun f -> ("enabled", (Boolean.to_json f)));
           Util.option_map v.allow_unassociated_targets
             (fun f -> ("allow_unassociated_targets", (Boolean.to_json f)));
           Util.option_map v.cutoff
             (fun f -> ("cutoff", (Integer.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Integer.to_json f)));
           Util.option_map v.next_execution_time
             (fun f -> ("next_execution_time", (String.to_json f)));
           Util.option_map v.schedule_timezone
             (fun f -> ("schedule_timezone", (String.to_json f)));
           Util.option_map v.schedule
             (fun f -> ("schedule", (String.to_json f)));
           Util.option_map v.end_date
             (fun f -> ("end_date", (String.to_json f)));
           Util.option_map v.start_date
             (fun f -> ("start_date", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.window_id
             (fun f -> ("window_id", (String.to_json f)))])
    let of_json j =
      {
        window_id =
          (Util.option_map (Json.lookup j "window_id") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        start_date =
          (Util.option_map (Json.lookup j "start_date") String.of_json);
        end_date =
          (Util.option_map (Json.lookup j "end_date") String.of_json);
        schedule =
          (Util.option_map (Json.lookup j "schedule") String.of_json);
        schedule_timezone =
          (Util.option_map (Json.lookup j "schedule_timezone") String.of_json);
        next_execution_time =
          (Util.option_map (Json.lookup j "next_execution_time")
             String.of_json);
        duration =
          (Util.option_map (Json.lookup j "duration") Integer.of_json);
        cutoff = (Util.option_map (Json.lookup j "cutoff") Integer.of_json);
        allow_unassociated_targets =
          (Util.option_map (Json.lookup j "allow_unassociated_targets")
             Boolean.of_json);
        enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json);
        created_date =
          (Util.option_map (Json.lookup j "created_date") DateTime.of_json);
        modified_date =
          (Util.option_map (Json.lookup j "modified_date") DateTime.of_json)
      }
  end
module DescribeMaintenanceWindowExecutionsResult =
  struct
    type t =
      {
      window_executions: MaintenanceWindowExecutionList.t ;
      next_token: String.t option }
    let make ?(window_executions= [])  ?next_token  () =
      { window_executions; next_token }
    let parse xml =
      Some
        {
          window_executions =
            (Util.of_option []
               (Util.option_bind (Xml.member "WindowExecutions" xml)
                  MaintenanceWindowExecutionList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "WindowExecutions"
                       ([], (MaintenanceWindowExecutionList.to_xml [x]))))
               v.window_executions))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("window_executions",
               (MaintenanceWindowExecutionList.to_json v.window_executions))])
    let of_json j =
      {
        window_executions =
          (MaintenanceWindowExecutionList.of_json
             (Util.of_option_exn (Json.lookup j "window_executions")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module UpdateMaintenanceWindowTargetRequest =
  struct
    type t =
      {
      window_id: String.t ;
      window_target_id: String.t ;
      targets: Targets.t ;
      owner_information: String.t option ;
      name: String.t option ;
      description: String.t option ;
      replace: Boolean.t option }
    let make ~window_id  ~window_target_id  ?(targets= []) 
      ?owner_information  ?name  ?description  ?replace  () =
      {
        window_id;
        window_target_id;
        targets;
        owner_information;
        name;
        description;
        replace
      }
    let parse xml =
      Some
        {
          window_id =
            (Xml.required "WindowId"
               (Util.option_bind (Xml.member "WindowId" xml) String.parse));
          window_target_id =
            (Xml.required "WindowTargetId"
               (Util.option_bind (Xml.member "WindowTargetId" xml)
                  String.parse));
          targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "Targets" xml) Targets.parse));
          owner_information =
            (Util.option_bind (Xml.member "OwnerInformation" xml)
               String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          replace =
            (Util.option_bind (Xml.member "Replace" xml) Boolean.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((([] @
                 [Some
                    (Ezxmlm.make_tag "WindowId"
                       ([], (String.to_xml v.window_id)))])
                @
                [Some
                   (Ezxmlm.make_tag "WindowTargetId"
                      ([], (String.to_xml v.window_target_id)))])
               @
               (List.map
                  (fun x ->
                     Some
                       (Ezxmlm.make_tag "Targets" ([], (Targets.to_xml [x]))))
                  v.targets))
              @
              [Util.option_map v.owner_information
                 (fun f ->
                    Ezxmlm.make_tag "OwnerInformation"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.name
                (fun f -> Ezxmlm.make_tag "Name" ([], (String.to_xml f)))])
            @
            [Util.option_map v.description
               (fun f ->
                  Ezxmlm.make_tag "Description" ([], (String.to_xml f)))])
           @
           [Util.option_map v.replace
              (fun f -> Ezxmlm.make_tag "Replace" ([], (Boolean.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.replace
              (fun f -> ("replace", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.owner_information
             (fun f -> ("owner_information", (String.to_json f)));
           Some ("targets", (Targets.to_json v.targets));
           Some ("window_target_id", (String.to_json v.window_target_id));
           Some ("window_id", (String.to_json v.window_id))])
    let of_json j =
      {
        window_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "window_id")));
        window_target_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "window_target_id")));
        targets =
          (Targets.of_json (Util.of_option_exn (Json.lookup j "targets")));
        owner_information =
          (Util.option_map (Json.lookup j "owner_information") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        replace = (Util.option_map (Json.lookup j "replace") Boolean.of_json)
      }
  end
module UnsupportedOperatingSystem =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module DescribeParametersRequest =
  struct
    type t =
      {
      filters: ParametersFilterList.t ;
      parameter_filters: ParameterStringFilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(filters= [])  ?(parameter_filters= [])  ?max_results 
      ?next_token  () =
      { filters; parameter_filters; max_results; next_token }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml)
                  ParametersFilterList.parse));
          parameter_filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "ParameterFilters" xml)
                  ParameterStringFilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (((([] @
              (List.map
                 (fun x ->
                    Some
                      (Ezxmlm.make_tag "Filters"
                         ([], (ParametersFilterList.to_xml [x])))) v.filters))
             @
             (List.map
                (fun x ->
                   Some
                     (Ezxmlm.make_tag "ParameterFilters"
                        ([], (ParameterStringFilterList.to_xml [x]))))
                v.parameter_filters))
            @
            [Util.option_map v.max_results
               (fun f ->
                  Ezxmlm.make_tag "MaxResults" ([], (Integer.to_xml f)))])
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("parameter_filters",
               (ParameterStringFilterList.to_json v.parameter_filters));
           Some ("filters", (ParametersFilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (ParametersFilterList.of_json
             (Util.of_option_exn (Json.lookup j "filters")));
        parameter_filters =
          (ParameterStringFilterList.of_json
             (Util.of_option_exn (Json.lookup j "parameter_filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module InvalidOutputLocation =
  struct
    type t = unit
    let make () = ()
    let parse xml = Some ()
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v = Util.list_filter_opt []
    let to_json v = `Assoc (Util.list_filter_opt [])
    let of_json j = ()
  end
module InvalidAssociation =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module InvalidDocumentContent =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "Message" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Util.option_map v.message
              (fun f -> Ezxmlm.make_tag "Message" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module GetCommandInvocationResult =
  struct
    type t =
      {
      command_id: String.t option ;
      instance_id: String.t option ;
      comment: String.t option ;
      document_name: String.t option ;
      document_version: String.t option ;
      plugin_name: String.t option ;
      response_code: Integer.t option ;
      execution_start_date_time: String.t option ;
      execution_elapsed_time: String.t option ;
      execution_end_date_time: String.t option ;
      status: CommandInvocationStatus.t option ;
      status_details: String.t option ;
      standard_output_content: String.t option ;
      standard_output_url: String.t option ;
      standard_error_content: String.t option ;
      standard_error_url: String.t option ;
      cloud_watch_output_config: CloudWatchOutputConfig.t option }
    let make ?command_id  ?instance_id  ?comment  ?document_name 
      ?document_version  ?plugin_name  ?response_code 
      ?execution_start_date_time  ?execution_elapsed_time 
      ?execution_end_date_time  ?status  ?status_details 
      ?standard_output_content  ?standard_output_url  ?standard_error_content
       ?standard_error_url  ?cloud_watch_output_config  () =
      {
        command_id;
        instance_id;
        comment;
        document_name;
        document_version;
        plugin_name;
        response_code;
        execution_start_date_time;
        execution_elapsed_time;
        execution_end_date_time;
        status;
        status_details;
        standard_output_content;
        standard_output_url;
        standard_error_content;
        standard_error_url;
        cloud_watch_output_config
      }
    let parse xml =
      Some
        {
          command_id =
            (Util.option_bind (Xml.member "CommandId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          comment =
            (Util.option_bind (Xml.member "Comment" xml) String.parse);
          document_name =
            (Util.option_bind (Xml.member "DocumentName" xml) String.parse);
          document_version =
            (Util.option_bind (Xml.member "DocumentVersion" xml) String.parse);
          plugin_name =
            (Util.option_bind (Xml.member "PluginName" xml) String.parse);
          response_code =
            (Util.option_bind (Xml.member "ResponseCode" xml) Integer.parse);
          execution_start_date_time =
            (Util.option_bind (Xml.member "ExecutionStartDateTime" xml)
               String.parse);
          execution_elapsed_time =
            (Util.option_bind (Xml.member "ExecutionElapsedTime" xml)
               String.parse);
          execution_end_date_time =
            (Util.option_bind (Xml.member "ExecutionEndDateTime" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "Status" xml)
               CommandInvocationStatus.parse);
          status_details =
            (Util.option_bind (Xml.member "StatusDetails" xml) String.parse);
          standard_output_content =
            (Util.option_bind (Xml.member "StandardOutputContent" xml)
               String.parse);
          standard_output_url =
            (Util.option_bind (Xml.member "StandardOutputUrl" xml)
               String.parse);
          standard_error_content =
            (Util.option_bind (Xml.member "StandardErrorContent" xml)
               String.parse);
          standard_error_url =
            (Util.option_bind (Xml.member "StandardErrorUrl" xml)
               String.parse);
          cloud_watch_output_config =
            (Util.option_bind (Xml.member "CloudWatchOutputConfig" xml)
               CloudWatchOutputConfig.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ((((((((((((((((([] @
                           [Util.option_map v.command_id
                              (fun f ->
                                 Ezxmlm.make_tag "CommandId"
                                   ([], (String.to_xml f)))])
                          @
                          [Util.option_map v.instance_id
                             (fun f ->
                                Ezxmlm.make_tag "InstanceId"
                                  ([], (String.to_xml f)))])
                         @
                         [Util.option_map v.comment
                            (fun f ->
                               Ezxmlm.make_tag "Comment"
                                 ([], (String.to_xml f)))])
                        @
                        [Util.option_map v.document_name
                           (fun f ->
                              Ezxmlm.make_tag "DocumentName"
                                ([], (String.to_xml f)))])
                       @
                       [Util.option_map v.document_version
                          (fun f ->
                             Ezxmlm.make_tag "DocumentVersion"
                               ([], (String.to_xml f)))])
                      @
                      [Util.option_map v.plugin_name
                         (fun f ->
                            Ezxmlm.make_tag "PluginName"
                              ([], (String.to_xml f)))])
                     @
                     [Util.option_map v.response_code
                        (fun f ->
                           Ezxmlm.make_tag "ResponseCode"
                             ([], (Integer.to_xml f)))])
                    @
                    [Util.option_map v.execution_start_date_time
                       (fun f ->
                          Ezxmlm.make_tag "ExecutionStartDateTime"
                            ([], (String.to_xml f)))])
                   @
                   [Util.option_map v.execution_elapsed_time
                      (fun f ->
                         Ezxmlm.make_tag "ExecutionElapsedTime"
                           ([], (String.to_xml f)))])
                  @
                  [Util.option_map v.execution_end_date_time
                     (fun f ->
                        Ezxmlm.make_tag "ExecutionEndDateTime"
                          ([], (String.to_xml f)))])
                 @
                 [Util.option_map v.status
                    (fun f ->
                       Ezxmlm.make_tag "Status"
                         ([], (CommandInvocationStatus.to_xml f)))])
                @
                [Util.option_map v.status_details
                   (fun f ->
                      Ezxmlm.make_tag "StatusDetails" ([], (String.to_xml f)))])
               @
               [Util.option_map v.standard_output_content
                  (fun f ->
                     Ezxmlm.make_tag "StandardOutputContent"
                       ([], (String.to_xml f)))])
              @
              [Util.option_map v.standard_output_url
                 (fun f ->
                    Ezxmlm.make_tag "StandardOutputUrl"
                      ([], (String.to_xml f)))])
             @
             [Util.option_map v.standard_error_content
                (fun f ->
                   Ezxmlm.make_tag "StandardErrorContent"
                     ([], (String.to_xml f)))])
            @
            [Util.option_map v.standard_error_url
               (fun f ->
                  Ezxmlm.make_tag "StandardErrorUrl" ([], (String.to_xml f)))])
           @
           [Util.option_map v.cloud_watch_output_config
              (fun f ->
                 Ezxmlm.make_tag "CloudWatchOutputConfig"
                   ([], (CloudWatchOutputConfig.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cloud_watch_output_config
              (fun f ->
                 ("cloud_watch_output_config",
                   (CloudWatchOutputConfig.to_json f)));
           Util.option_map v.standard_error_url
             (fun f -> ("standard_error_url", (String.to_json f)));
           Util.option_map v.standard_error_content
             (fun f -> ("standard_error_content", (String.to_json f)));
           Util.option_map v.standard_output_url
             (fun f -> ("standard_output_url", (String.to_json f)));
           Util.option_map v.standard_output_content
             (fun f -> ("standard_output_content", (String.to_json f)));
           Util.option_map v.status_details
             (fun f -> ("status_details", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (CommandInvocationStatus.to_json f)));
           Util.option_map v.execution_end_date_time
             (fun f -> ("execution_end_date_time", (String.to_json f)));
           Util.option_map v.execution_elapsed_time
             (fun f -> ("execution_elapsed_time", (String.to_json f)));
           Util.option_map v.execution_start_date_time
             (fun f -> ("execution_start_date_time", (String.to_json f)));
           Util.option_map v.response_code
             (fun f -> ("response_code", (Integer.to_json f)));
           Util.option_map v.plugin_name
             (fun f -> ("plugin_name", (String.to_json f)));
           Util.option_map v.document_version
             (fun f -> ("document_version", (String.to_json f)));
           Util.option_map v.document_name
             (fun f -> ("document_name", (String.to_json f)));
           Util.option_map v.comment
             (fun f -> ("comment", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.command_id
             (fun f -> ("command_id", (String.to_json f)))])
    let of_json j =
      {
        command_id =
          (Util.option_map (Json.lookup j "command_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        comment = (Util.option_map (Json.lookup j "comment") String.of_json);
        document_name =
          (Util.option_map (Json.lookup j "document_name") String.of_json);
        document_version =
          (Util.option_map (Json.lookup j "document_version") String.of_json);
        plugin_name =
          (Util.option_map (Json.lookup j "plugin_name") String.of_json);
        response_code =
          (Util.option_map (Json.lookup j "response_code") Integer.of_json);
        execution_start_date_time =
          (Util.option_map (Json.lookup j "execution_start_date_time")
             String.of_json);
        execution_elapsed_time =
          (Util.option_map (Json.lookup j "execution_elapsed_time")
             String.of_json);
        execution_end_date_time =
          (Util.option_map (Json.lookup j "execution_end_date_time")
             String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             CommandInvocationStatus.of_json);
        status_details =
          (Util.option_map (Json.lookup j "status_details") String.of_json);
        standard_output_content =
          (Util.option_map (Json.lookup j "standard_output_content")
             String.of_json);
        standard_output_url =
          (Util.option_map (Json.lookup j "standard_output_url")
             String.of_json);
        standard_error_content =
          (Util.option_map (Json.lookup j "standard_error_content")
             String.of_json);
        standard_error_url =
          (Util.option_map (Json.lookup j "standard_error_url")
             String.of_json);
        cloud_watch_output_config =
          (Util.option_map (Json.lookup j "cloud_watch_output_config")
             CloudWatchOutputConfig.of_json)
      }
  end
module GetConnectionStatusRequest =
  struct
    type t = {
      target: String.t }
    let make ~target  () = { target }
    let parse xml =
      Some
        {
          target =
            (Xml.required "Target"
               (Util.option_bind (Xml.member "Target" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some (Ezxmlm.make_tag "Target" ([], (String.to_xml v.target)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt [Some ("target", (String.to_json v.target))])
    let of_json j =
      {
        target =
          (String.of_json (Util.of_option_exn (Json.lookup j "target")))
      }
  end
module RegisterDefaultPatchBaselineRequest =
  struct
    type t = {
      baseline_id: String.t }
    let make ~baseline_id  () = { baseline_id }
    let parse xml =
      Some
        {
          baseline_id =
            (Xml.required "BaselineId"
               (Util.option_bind (Xml.member "BaselineId" xml) String.parse))
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        ([] @
           [Some
              (Ezxmlm.make_tag "BaselineId"
                 ([], (String.to_xml v.baseline_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("baseline_id", (String.to_json v.baseline_id))])
    let of_json j =
      {
        baseline_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "baseline_id")))
      }
  end
module DescribePatchGroupsResult =
  struct
    type t =
      {
      mappings: PatchGroupPatchBaselineMappingList.t ;
      next_token: String.t option }
    let make ?(mappings= [])  ?next_token  () = { mappings; next_token }
    let parse xml =
      Some
        {
          mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "Mappings" xml)
                  PatchGroupPatchBaselineMappingList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            (List.map
               (fun x ->
                  Some
                    (Ezxmlm.make_tag "Mappings"
                       ([], (PatchGroupPatchBaselineMappingList.to_xml [x]))))
               v.mappings))
           @
           [Util.option_map v.next_token
              (fun f -> Ezxmlm.make_tag "NextToken" ([], (String.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("mappings",
               (PatchGroupPatchBaselineMappingList.to_json v.mappings))])
    let of_json j =
      {
        mappings =
          (PatchGroupPatchBaselineMappingList.of_json
             (Util.of_option_exn (Json.lookup j "mappings")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetDefaultPatchBaselineResult =
  struct
    type t =
      {
      baseline_id: String.t option ;
      operating_system: OperatingSystem.t option }
    let make ?baseline_id  ?operating_system  () =
      { baseline_id; operating_system }
    let parse xml =
      Some
        {
          baseline_id =
            (Util.option_bind (Xml.member "BaselineId" xml) String.parse);
          operating_system =
            (Util.option_bind (Xml.member "OperatingSystem" xml)
               OperatingSystem.parse)
        }
    let to_query v = Query.List (Util.list_filter_opt [])
    let to_headers v = Headers.List (Util.list_filter_opt [])
    let to_xml v =
      Util.list_filter_opt
        (([] @
            [Util.option_map v.baseline_id
               (fun f -> Ezxmlm.make_tag "BaselineId" ([], (String.to_xml f)))])
           @
           [Util.option_map v.operating_system
              (fun f ->
                 Ezxmlm.make_tag "OperatingSystem"
                   ([], (OperatingSystem.to_xml f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.operating_system
              (fun f -> ("operating_system", (OperatingSystem.to_json f)));
           Util.option_map v.baseline_id
             (fun f -> ("baseline_id", (String.to_json f)))])
    let of_json j =
      {
        baseline_id =
          (Util.option_map (Json.lookup j "baseline_id") String.of_json);
        operating_system =
          (Util.option_map (Json.lookup j "operating_system")
             OperatingSystem.of_json)
      }
  end